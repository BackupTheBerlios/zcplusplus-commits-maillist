<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Zcplusplus-commits] r415 - trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/zcplusplus-commits/2010-May/index.html" >
   <LINK REL="made" HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r415%20-%20trunk&In-Reply-To=%3C201005072327.o47NRUIE025402%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000181.html">
   <LINK REL="Next"  HREF="000183.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Zcplusplus-commits] r415 - trunk</H1>
    <B>zaimoni at mail.berlios.de</B> 
    <A HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r415%20-%20trunk&In-Reply-To=%3C201005072327.o47NRUIE025402%40sheep.berlios.de%3E"
       TITLE="[Zcplusplus-commits] r415 - trunk">zaimoni at mail.berlios.de
       </A><BR>
    <I>Sat May  8 01:27:30 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="000181.html">[Zcplusplus-commits] r414 - trunk
</A></li>
        <LI>Next message: <A HREF="000183.html">[Zcplusplus-commits] r416 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#182">[ date ]</a>
              <a href="thread.html#182">[ thread ]</a>
              <a href="subject.html#182">[ subject ]</a>
              <a href="author.html#182">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zaimoni
Date: 2010-05-08 01:27:25 +0200 (Sat, 08 May 2010)
New Revision: 415

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
more std::bad_alloc hardening

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-07 22:05:11 UTC (rev 414)
+++ trunk/CSupport.cpp	2010-05-07 23:27:25 UTC (rev 415)
@@ -9418,6 +9418,7 @@
 	return false;
 }
 
+//! \throws std::bad_alloc
 static void C_conditional_op_easy_syntax_check(parse_tree&amp; src,const type_system&amp; types)
 {
 	assert(is_C99_conditional_operator_expression(src));
@@ -9505,6 +9506,7 @@
 	if (eval_conditional_op(src,C99_literal_converts_to_bool ARG_TYPES)) return;
 }
 
+//! \throws std::bad_alloc
 static void CPP_conditional_op_easy_syntax_check(parse_tree&amp; src,const type_system&amp; types)
 {
 	assert(is_C99_conditional_operator_expression(src));
@@ -9594,6 +9596,7 @@
 	if (eval_conditional_op(src,CPP_literal_converts_to_bool ARG_TYPES)) return;
 }
 
+//! \throws std::bad_alloc
 static void locate_C99_conditional_op(parse_tree&amp; src, size_t&amp; i, const type_system&amp; types)
 {
 	assert(!src.empty&lt;0&gt;());
@@ -9606,6 +9609,7 @@
 		C_conditional_op_easy_syntax_check(src.c_array&lt;0&gt;()[i],types);
 }
 
+//! \throws std::bad_alloc
 static void locate_CPP_conditional_op(parse_tree&amp; src, size_t&amp; i, const type_system&amp; types)
 {
 	assert(!src.empty&lt;0&gt;());
@@ -9649,16 +9653,53 @@
 }
 
 // top-level has SIZE_MAX for parent_identifier_count
+//! \throws std::bad_alloc
 static void C99_locate_expressions(parse_tree&amp; src,const size_t parent_identifier_count,const type_system&amp; types)
 {
 	if (PARSE_OBVIOUS &amp; src.flags) return;
 	size_t identifier_count = (0==parent_identifier_count) ? 0 : _count_identifiers(src);
-	size_t i = src.size&lt;0&gt;();
-	while(0&lt;i) C99_locate_expressions(src.c_array&lt;0&gt;()[--i],identifier_count,types);
-	i = src.size&lt;1&gt;();
-	while(0&lt;i) C99_locate_expressions(src.c_array&lt;1&gt;()[--i],identifier_count,types);
-	i = src.size&lt;2&gt;();
-	while(0&lt;i) C99_locate_expressions(src.c_array&lt;2&gt;()[--i],identifier_count,types);
+	{
+	size_t i[3] = {src.size&lt;0&gt;(), src.size&lt;1&gt;(), src.size&lt;2&gt;()};
+	size_t initial_i[3];
+full_restart:
+	memmove(initial_i,i,3*sizeof(size_t));
+	size_t stalled[3] = {SIZE_MAX,SIZE_MAX,SIZE_MAX};
+	try {
+		while(0&lt;i[0]) C99_locate_expressions(src.c_array&lt;0&gt;()[--i[0]],identifier_count,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{
+		stalled[0] = i[0]++;
+		goto restart_1;
+		}
+restart_1:
+	try {
+		while(0&lt;i[1]) C99_locate_expressions(src.c_array&lt;1&gt;()[--i[1]],identifier_count,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{
+		stalled[1] = i[1]++;
+		goto restart_2;
+		}
+restart_2:
+	try {
+		while(0&lt;i[2]) C99_locate_expressions(src.c_array&lt;2&gt;()[--i[2]],identifier_count,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{
+		stalled[2] = i[2]++;
+		goto restart_3;
+		}
+restart_3:
+	if (SIZE_MAX&gt;stalled[0] || SIZE_MAX&gt;stalled[1] || SIZE_MAX&gt;stalled[2])
+		{	// had a memory management problem
+		if (i[0]&lt;initial_i[0] || i[1]&lt;initial_i[1] || i[2]&lt;initial_i[2])
+			// if we made some progress, restart
+			goto full_restart;
+		// otherwise give up
+		throw std::bad_alloc();
+		}
+	}
 
 	const bool top_level = SIZE_MAX==parent_identifier_count;
 	const bool parens_are_expressions = 0==parent_identifier_count	// no identifiers from outside
@@ -9716,17 +9757,54 @@
 }
 
 // top-level has SIZE_MAX for parent_identifier_count
+//! \throws std::bad_alloc
 static void CPP_locate_expressions(parse_tree&amp; src,const size_t parent_identifier_count,const type_system&amp; types)
 {
 	if (PARSE_OBVIOUS &amp; src.flags) return;
 	const size_t identifier_count = (0==parent_identifier_count) ? 0 : _count_identifiers(src);
-	size_t i = src.size&lt;0&gt;();
-	while(0&lt;i) CPP_locate_expressions(src.c_array&lt;0&gt;()[--i],identifier_count,types);
-	i = src.size&lt;1&gt;();
-	while(0&lt;i) CPP_locate_expressions(src.c_array&lt;1&gt;()[--i],identifier_count,types);
-	i = src.size&lt;2&gt;();
-	while(0&lt;i) CPP_locate_expressions(src.c_array&lt;2&gt;()[--i],identifier_count,types);
-
+	{
+	size_t i[3] = {src.size&lt;0&gt;(), src.size&lt;1&gt;(), src.size&lt;2&gt;()};
+	size_t initial_i[3];
+full_restart:
+	memmove(initial_i,i,3*sizeof(size_t));
+	size_t stalled[3] = {SIZE_MAX,SIZE_MAX,SIZE_MAX};
+	try {
+		while(0&lt;i[0]) CPP_locate_expressions(src.c_array&lt;0&gt;()[--i[0]],identifier_count,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{
+		stalled[0] = i[0]++;
+		goto restart_1;
+		}
+restart_1:
+	try {
+		while(0&lt;i[1]) CPP_locate_expressions(src.c_array&lt;1&gt;()[--i[1]],identifier_count,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{
+		stalled[1] = i[1]++;
+		goto restart_2;
+		}
+restart_2:
+	try {
+		while(0&lt;i[2]) CPP_locate_expressions(src.c_array&lt;2&gt;()[--i[2]],identifier_count,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{
+		stalled[2] = i[2]++;
+		goto restart_3;
+		}
+restart_3:
+	if (SIZE_MAX&gt;stalled[0] || SIZE_MAX&gt;stalled[1] || SIZE_MAX&gt;stalled[2])
+		{	// had a memory management problem
+		if (i[0]&lt;initial_i[0] || i[1]&lt;initial_i[1] || i[2]&lt;initial_i[2])
+			// if we made some progress, restart
+			goto full_restart;
+		// otherwise give up
+		throw std::bad_alloc();
+		}
+	}
+	
 	const bool top_level = SIZE_MAX==parent_identifier_count;
 	const bool parens_are_expressions = 0==parent_identifier_count	// no identifiers from outside
 									|| (top_level &amp;&amp; 0==identifier_count);	// top-level, no identifiers
@@ -9814,6 +9892,7 @@
 		}
 }
 
+//! \throw std::bad_alloc
 static bool C99_CondenseParseTree(parse_tree&amp; src,const type_system&amp; types)
 {
 	assert(src.is_raw_list());
@@ -9821,12 +9900,20 @@
 	const size_t starting_errors = zcc_errors.err_count();
 	_label_literals(src,types);
 	if (!_match_pairs(src)) return false;
-	C99_locate_expressions(src,SIZE_MAX,types);
+	try {
+		C99_locate_expressions(src,SIZE_MAX,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{	// error count change is already false
+		if (starting_errors&lt;zcc_errors.err_count()) return false;
+		throw;
+		}
 	if (starting_errors&lt;zcc_errors.err_count()) return false;
 	while(src.is_raw_list() &amp;&amp; 1==src.size&lt;0&gt;()) src.eval_to_arg&lt;0&gt;(0);
 	return true;
 }
 
+//! \throw std::bad_alloc
 static bool CPP_CondenseParseTree(parse_tree&amp; src,const type_system&amp; types)
 {
 	assert(src.is_raw_list());
@@ -9839,7 +9926,14 @@
 	// check that this is at least within a brace pair or a parentheses pair (it is actually required to be in a non-static member function, or constructor mem-initializer
 	if (!_this_vaguely_where_it_could_be_cplusplus(src)) return false;
 #/*cut-cpp*/	
-	CPP_locate_expressions(src,SIZE_MAX,types);
+	try {
+		CPP_locate_expressions(src,SIZE_MAX,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{	// error count change is already false
+		if (starting_errors&lt;zcc_errors.err_count()) return false;
+		throw;
+		}
 	if (starting_errors&lt;zcc_errors.err_count()) return false;
 	while(src.is_raw_list() &amp;&amp; 1==src.size&lt;0&gt;()) src.eval_to_arg&lt;0&gt;(0);
 	return true;
@@ -9868,6 +9962,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static void CPP_notice_scope_glue(parse_tree&amp; src)
 {
 	assert(!src.empty&lt;0&gt;());
@@ -9961,30 +10056,18 @@
 	i = 0;
 	while(i&lt;src.size&lt;0&gt;())
 		{
-		parse_tree&amp; tmp = src.c_array&lt;0&gt;()[i];
-		if (is_naked_parentheses_pair(tmp))
-			{
-			if (!tmp.empty&lt;0&gt;())
-				// recurse into (...)
-				CPP_notice_scope_glue(tmp);
-			}
-		else if (is_naked_brace_pair(tmp))
-			{
-			if (!tmp.empty&lt;0&gt;())
-				// recurse into {...}
-				CPP_notice_scope_glue(tmp);
-			}
-		else if (is_naked_bracket_pair(tmp))
-			{
-			if (!tmp.empty&lt;0&gt;())
-				// recurse into [...]
-				CPP_notice_scope_glue(tmp);
-			}
-		++i;
+		parse_tree&amp; tmp = src.c_array&lt;0&gt;()[i++];
+		if (tmp.empty&lt;0&gt;()) continue;
+		// recurse into ...
+		if (   is_naked_parentheses_pair(tmp) // (...)
+			|| is_naked_brace_pair(tmp) // {...}
+			|| is_naked_bracket_pair(tmp)) // [...]
+			CPP_notice_scope_glue(tmp);
 		};
 }
 
 //! \todo check that the fact all literals are already legal-form is used
+//! \throw std::bad_alloc
 static void CPP_ContextFreeParse(parse_tree&amp; src,const type_system&amp; types)
 {
 	assert(src.is_raw_list());
@@ -10003,7 +10086,7 @@
 //! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
 bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
 {
-	assert(NULL!=x);
+	assert(x &amp;&amp; *x);
 	assert(0&lt;x_len);
 	assert(C_TESTFLAG_PP_NUMERAL &amp; flags);
 	assert(!(C_TESTFLAG_FLOAT &amp; flags));
@@ -10089,12 +10172,31 @@
 	char* tmp2 = NULL;
 	assert(tmp.representable_as_uint());
 	GetCCharacterLiteralAt(str_lit.first,str_lit.second,tmp.to_uint(),tmp2);
-	assert(NULL!=tmp2);
+	assert(tmp2);
 	src.destroy();	// str_lit goes invalid here, don't use again
 	src.grab_index_token_from&lt;0&gt;(tmp2,C_TESTFLAG_CHAR_LITERAL);
 	_label_one_literal(src,types);
 }
 
+#define ZCC_EVALPARSETREE_PAIR_EVAL(A,B)	\
+	{	\
+	bool RAM_err = false;	\
+	try {	\
+		EvalParseTree(*src.c_array&lt;A&gt;(),types);	\
+		}	\
+	catch(std::bad_alloc&amp;)	\
+		{	\
+		RAM_err = true;	\
+		goto restart_1;	\
+		}	\
+restart_1:	\
+	/* can't recover locally if this throws std::bad_alloc */	\
+	EvalParseTree(*src.c_array&lt;B&gt;(),types);	\
+	if (RAM_err) EvalParseTree(*src.c_array&lt;A&gt;(),types);	\
+	}
+
+
+//! \throw std::bad_alloc
 static bool
 eval_array_deref(parse_tree&amp; src,const type_system&amp; types,
 				 func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
@@ -10104,8 +10206,7 @@
 	if (!is_array_deref(src)) return false;
 	// crunch __[...]
 	// canonical definition: *((__)+(...))
-	EvalParseTree(*src.c_array&lt;0&gt;(),types);
-	EvalParseTree(*src.c_array&lt;1&gt;(),types);
+	ZCC_EVALPARSETREE_PAIR_EVAL(0,1);
 	if (parse_tree::CONSTANT_EXPRESSION &amp; src.flags)
 		{
 		const unsigned int str_index = 	(C_TESTFLAG_STRING_LITERAL==src.data&lt;0&gt;()-&gt;index_tokens[0].flags) ? 0 :
@@ -10123,6 +10224,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_deref(	parse_tree&amp; src, const type_system&amp; types,
 						func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree)
 {
@@ -10144,6 +10246,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_logical_NOT(parse_tree&amp; src, const type_system&amp; types,
 							 func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							 func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_logical_NOT_expression,
@@ -10157,6 +10260,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_compl(	parse_tree&amp; src, const type_system&amp; types,
 								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 								func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_complement_expression,
@@ -10170,6 +10274,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_unary_plus(parse_tree&amp; src, const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree)
 {
@@ -10181,6 +10286,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_unary_minus(parse_tree&amp; src, const type_system&amp; types,
 							 func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							 literal_converts_to_bool_func&amp; literal_converts_to_bool,
@@ -10194,6 +10300,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_mult_expression(parse_tree&amp; src,const type_system&amp; types,
 								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 								literal_converts_to_bool_func&amp; literal_converts_to_bool,
@@ -10201,13 +10308,13 @@
 {
 	if (is_C99_mult_operator_expression&lt;'*'&gt;(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_mult_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_div_expression(parse_tree&amp; src,const type_system&amp; types,
 								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 								literal_converts_to_bool_func&amp; literal_converts_to_bool,
@@ -10215,13 +10322,13 @@
 {
 	if (is_C99_mult_operator_expression&lt;'/'&gt;(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_div_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_mod_expression(parse_tree&amp; src,const type_system&amp; types,
 								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 								literal_converts_to_bool_func&amp; literal_converts_to_bool,
@@ -10229,14 +10336,13 @@
 {
 	if (is_C99_mult_operator_expression&lt;'%'&gt;(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_mod_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
-
+//! \throw std::bad_alloc
 static bool eval_add_expression(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							literal_converts_to_bool_func&amp; literal_converts_to_bool,
@@ -10244,13 +10350,13 @@
 {
 	if (is_C99_add_operator_expression&lt;'+'&gt;(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_add_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_sub_expression(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							literal_converts_to_bool_func&amp; literal_converts_to_bool,
@@ -10258,13 +10364,13 @@
 {
 	if (is_C99_add_operator_expression&lt;'-'&gt;(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_sub_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_shift(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							literal_converts_to_bool_func&amp; literal_converts_to_bool,
@@ -10272,26 +10378,26 @@
 {
 	if (is_C99_shift_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_shift(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_relation_expression(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							intlike_literal_to_VM_func&amp; intlike_literal_to_VM)
 {
 	if (is_C99_relation_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_relation_expression(src,types,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_equality_expression(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_equality_expression,
@@ -10300,13 +10406,13 @@
 {
 	if (is_equality_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_equality_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_AND(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_AND_expression,
@@ -10315,13 +10421,13 @@
 {
 	if (is_bitwise_AND_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_bitwise_AND(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_XOR(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_XOR_expression,
@@ -10330,13 +10436,13 @@
 {
 	if (is_bitwise_XOR_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_bitwise_XOR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_OR(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_OR_expression,
@@ -10345,13 +10451,13 @@
 {
 	if (is_bitwise_OR_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_bitwise_OR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_logical_AND(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_logical_AND_expression,
@@ -10359,13 +10465,13 @@
 {
 	if (is_logical_AND_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_logical_AND(src,types,literal_converts_to_bool)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_logical_OR(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_logical_OR_expression,
@@ -10373,13 +10479,13 @@
 {
 	if (is_logical_OR_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_logical_OR(src,types,literal_converts_to_bool)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_conditional_operator(parse_tree&amp; src,const type_system&amp; types,
 									  func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 									  literal_converts_to_bool_func&amp; literal_converts_to_bool)
@@ -10400,12 +10506,10 @@
 		{	// strip off &amp;*, and remove lvalue-ness of target
 		if (is_C99_unary_operator_expression&lt;'*'&gt;(*src.data&lt;2&gt;()) &amp;&amp; 0&lt;src.data&lt;2&gt;()-&gt;data&lt;2&gt;()-&gt;type_code.pointer_power)
 			{
-			parse_tree tmp = *src.data&lt;2&gt;()-&gt;data&lt;2&gt;();
+			parse_tree tmp;
+			src.c_array&lt;2&gt;()-&gt;c_array&lt;2&gt;()-&gt;OverwriteInto(tmp);
 			tmp.type_code.traits &amp;= ~type_spec::lvalue;
-			src.c_array&lt;2&gt;()-&gt;c_array&lt;2&gt;()-&gt;clear();
-			src.destroy();
-			src = tmp;
-			return true;
+			tmp.MoveInto(src);
 			}
 #if 0
 		if (is_array_deref(*src.data&lt;2&gt;()))
@@ -10417,6 +10521,7 @@
 }
 #endif
 
+//! \throw std::bad_alloc
 static bool C99_EvalParseTree(parse_tree&amp; src,const type_system&amp; types)
 {
 	const size_t starting_errors = zcc_errors.err_count();
@@ -10445,6 +10550,7 @@
 	return starting_errors==zcc_errors.err_count();
 }
 
+//! \throw std::bad_alloc
 static bool CPP_EvalParseTree(parse_tree&amp; src,const type_system&amp; types)
 {
 	const size_t starting_errors = zcc_errors.err_count();

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-07 22:05:11 UTC (rev 414)
+++ trunk/CSupport_pp.cpp	2010-05-07 23:27:25 UTC (rev 415)
@@ -8523,6 +8523,7 @@
 	return false;
 }
 
+//! \throws std::bad_alloc
 static void C_conditional_op_easy_syntax_check(parse_tree&amp; src,const type_system&amp; types)
 {
 	assert(is_C99_conditional_operator_expression(src));
@@ -8610,6 +8611,7 @@
 	if (eval_conditional_op(src,C99_literal_converts_to_bool ARG_TYPES)) return;
 }
 
+//! \throws std::bad_alloc
 static void CPP_conditional_op_easy_syntax_check(parse_tree&amp; src,const type_system&amp; types)
 {
 	assert(is_C99_conditional_operator_expression(src));
@@ -8699,6 +8701,7 @@
 	if (eval_conditional_op(src,CPP_literal_converts_to_bool ARG_TYPES)) return;
 }
 
+//! \throws std::bad_alloc
 static void locate_C99_conditional_op(parse_tree&amp; src, size_t&amp; i, const type_system&amp; types)
 {
 	assert(!src.empty&lt;0&gt;());
@@ -8711,6 +8714,7 @@
 		C_conditional_op_easy_syntax_check(src.c_array&lt;0&gt;()[i],types);
 }
 
+//! \throws std::bad_alloc
 static void locate_CPP_conditional_op(parse_tree&amp; src, size_t&amp; i, const type_system&amp; types)
 {
 	assert(!src.empty&lt;0&gt;());
@@ -8754,16 +8758,53 @@
 }
 
 // top-level has SIZE_MAX for parent_identifier_count
+//! \throws std::bad_alloc
 static void C99_locate_expressions(parse_tree&amp; src,const size_t parent_identifier_count,const type_system&amp; types)
 {
 	if (PARSE_OBVIOUS &amp; src.flags) return;
 	size_t identifier_count = (0==parent_identifier_count) ? 0 : _count_identifiers(src);
-	size_t i = src.size&lt;0&gt;();
-	while(0&lt;i) C99_locate_expressions(src.c_array&lt;0&gt;()[--i],identifier_count,types);
-	i = src.size&lt;1&gt;();
-	while(0&lt;i) C99_locate_expressions(src.c_array&lt;1&gt;()[--i],identifier_count,types);
-	i = src.size&lt;2&gt;();
-	while(0&lt;i) C99_locate_expressions(src.c_array&lt;2&gt;()[--i],identifier_count,types);
+	{
+	size_t i[3] = {src.size&lt;0&gt;(), src.size&lt;1&gt;(), src.size&lt;2&gt;()};
+	size_t initial_i[3];
+full_restart:
+	memmove(initial_i,i,3*sizeof(size_t));
+	size_t stalled[3] = {SIZE_MAX,SIZE_MAX,SIZE_MAX};
+	try {
+		while(0&lt;i[0]) C99_locate_expressions(src.c_array&lt;0&gt;()[--i[0]],identifier_count,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{
+		stalled[0] = i[0]++;
+		goto restart_1;
+		}
+restart_1:
+	try {
+		while(0&lt;i[1]) C99_locate_expressions(src.c_array&lt;1&gt;()[--i[1]],identifier_count,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{
+		stalled[1] = i[1]++;
+		goto restart_2;
+		}
+restart_2:
+	try {
+		while(0&lt;i[2]) C99_locate_expressions(src.c_array&lt;2&gt;()[--i[2]],identifier_count,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{
+		stalled[2] = i[2]++;
+		goto restart_3;
+		}
+restart_3:
+	if (SIZE_MAX&gt;stalled[0] || SIZE_MAX&gt;stalled[1] || SIZE_MAX&gt;stalled[2])
+		{	// had a memory management problem
+		if (i[0]&lt;initial_i[0] || i[1]&lt;initial_i[1] || i[2]&lt;initial_i[2])
+			// if we made some progress, restart
+			goto full_restart;
+		// otherwise give up
+		throw std::bad_alloc();
+		}
+	}
 
 	const bool top_level = SIZE_MAX==parent_identifier_count;
 	const bool parens_are_expressions = 0==parent_identifier_count	// no identifiers from outside
@@ -8821,17 +8862,54 @@
 }
 
 // top-level has SIZE_MAX for parent_identifier_count
+//! \throws std::bad_alloc
 static void CPP_locate_expressions(parse_tree&amp; src,const size_t parent_identifier_count,const type_system&amp; types)
 {
 	if (PARSE_OBVIOUS &amp; src.flags) return;
 	const size_t identifier_count = (0==parent_identifier_count) ? 0 : _count_identifiers(src);
-	size_t i = src.size&lt;0&gt;();
-	while(0&lt;i) CPP_locate_expressions(src.c_array&lt;0&gt;()[--i],identifier_count,types);
-	i = src.size&lt;1&gt;();
-	while(0&lt;i) CPP_locate_expressions(src.c_array&lt;1&gt;()[--i],identifier_count,types);
-	i = src.size&lt;2&gt;();
-	while(0&lt;i) CPP_locate_expressions(src.c_array&lt;2&gt;()[--i],identifier_count,types);
-
+	{
+	size_t i[3] = {src.size&lt;0&gt;(), src.size&lt;1&gt;(), src.size&lt;2&gt;()};
+	size_t initial_i[3];
+full_restart:
+	memmove(initial_i,i,3*sizeof(size_t));
+	size_t stalled[3] = {SIZE_MAX,SIZE_MAX,SIZE_MAX};
+	try {
+		while(0&lt;i[0]) CPP_locate_expressions(src.c_array&lt;0&gt;()[--i[0]],identifier_count,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{
+		stalled[0] = i[0]++;
+		goto restart_1;
+		}
+restart_1:
+	try {
+		while(0&lt;i[1]) CPP_locate_expressions(src.c_array&lt;1&gt;()[--i[1]],identifier_count,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{
+		stalled[1] = i[1]++;
+		goto restart_2;
+		}
+restart_2:
+	try {
+		while(0&lt;i[2]) CPP_locate_expressions(src.c_array&lt;2&gt;()[--i[2]],identifier_count,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{
+		stalled[2] = i[2]++;
+		goto restart_3;
+		}
+restart_3:
+	if (SIZE_MAX&gt;stalled[0] || SIZE_MAX&gt;stalled[1] || SIZE_MAX&gt;stalled[2])
+		{	// had a memory management problem
+		if (i[0]&lt;initial_i[0] || i[1]&lt;initial_i[1] || i[2]&lt;initial_i[2])
+			// if we made some progress, restart
+			goto full_restart;
+		// otherwise give up
+		throw std::bad_alloc();
+		}
+	}
+	
 	const bool top_level = SIZE_MAX==parent_identifier_count;
 	const bool parens_are_expressions = 0==parent_identifier_count	// no identifiers from outside
 									|| (top_level &amp;&amp; 0==identifier_count);	// top-level, no identifiers
@@ -8919,6 +8997,7 @@
 		}
 }
 
+//! \throw std::bad_alloc
 static bool C99_CondenseParseTree(parse_tree&amp; src,const type_system&amp; types)
 {
 	assert(src.is_raw_list());
@@ -8926,12 +9005,20 @@
 	const size_t starting_errors = zcc_errors.err_count();
 	_label_literals(src,types);
 	if (!_match_pairs(src)) return false;
-	C99_locate_expressions(src,SIZE_MAX,types);
+	try {
+		C99_locate_expressions(src,SIZE_MAX,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{	// error count change is already false
+		if (starting_errors&lt;zcc_errors.err_count()) return false;
+		throw;
+		}
 	if (starting_errors&lt;zcc_errors.err_count()) return false;
 	while(src.is_raw_list() &amp;&amp; 1==src.size&lt;0&gt;()) src.eval_to_arg&lt;0&gt;(0);
 	return true;
 }
 
+//! \throw std::bad_alloc
 static bool CPP_CondenseParseTree(parse_tree&amp; src,const type_system&amp; types)
 {
 	assert(src.is_raw_list());
@@ -8940,7 +9027,14 @@
 	_label_literals(src,types);
 	std::for_each(src.begin&lt;0&gt;(),src.end&lt;0&gt;(),_label_CPP_literal);	// intercepts: true, false, this
 	if (!_match_pairs(src)) return false;
-	CPP_locate_expressions(src,SIZE_MAX,types);
+	try {
+		CPP_locate_expressions(src,SIZE_MAX,types);
+		}
+	catch(std::bad_alloc&amp;)
+		{	// error count change is already false
+		if (starting_errors&lt;zcc_errors.err_count()) return false;
+		throw;
+		}
 	if (starting_errors&lt;zcc_errors.err_count()) return false;
 	while(src.is_raw_list() &amp;&amp; 1==src.size&lt;0&gt;()) src.eval_to_arg&lt;0&gt;(0);
 	return true;
@@ -8950,7 +9044,7 @@
 //! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
 bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
 {
-	assert(NULL!=x);
+	assert(x &amp;&amp; *x);
 	assert(0&lt;x_len);
 	assert(C_TESTFLAG_PP_NUMERAL &amp; flags);
 	assert(!(C_TESTFLAG_FLOAT &amp; flags));
@@ -9036,12 +9130,31 @@
 	char* tmp2 = NULL;
 	assert(tmp.representable_as_uint());
 	GetCCharacterLiteralAt(str_lit.first,str_lit.second,tmp.to_uint(),tmp2);
-	assert(NULL!=tmp2);
+	assert(tmp2);
 	src.destroy();	// str_lit goes invalid here, don't use again
 	src.grab_index_token_from&lt;0&gt;(tmp2,C_TESTFLAG_CHAR_LITERAL);
 	_label_one_literal(src,types);
 }
 
+#define ZCC_EVALPARSETREE_PAIR_EVAL(A,B)	\
+	{	\
+	bool RAM_err = false;	\
+	try {	\
+		EvalParseTree(*src.c_array&lt;A&gt;(),types);	\
+		}	\
+	catch(std::bad_alloc&amp;)	\
+		{	\
+		RAM_err = true;	\
+		goto restart_1;	\
+		}	\
+restart_1:	\
+	/* can't recover locally if this throws std::bad_alloc */	\
+	EvalParseTree(*src.c_array&lt;B&gt;(),types);	\
+	if (RAM_err) EvalParseTree(*src.c_array&lt;A&gt;(),types);	\
+	}
+
+
+//! \throw std::bad_alloc
 static bool
 eval_array_deref(parse_tree&amp; src,const type_system&amp; types,
 				 func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
@@ -9051,8 +9164,7 @@
 	if (!is_array_deref(src)) return false;
 	// crunch __[...]
 	// canonical definition: *((__)+(...))
-	EvalParseTree(*src.c_array&lt;0&gt;(),types);
-	EvalParseTree(*src.c_array&lt;1&gt;(),types);
+	ZCC_EVALPARSETREE_PAIR_EVAL(0,1);
 	if (parse_tree::CONSTANT_EXPRESSION &amp; src.flags)
 		{
 		const unsigned int str_index = 	(C_TESTFLAG_STRING_LITERAL==src.data&lt;0&gt;()-&gt;index_tokens[0].flags) ? 0 :
@@ -9070,6 +9182,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_deref(	parse_tree&amp; src, const type_system&amp; types,
 						func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree)
 {
@@ -9091,6 +9204,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_logical_NOT(parse_tree&amp; src, const type_system&amp; types,
 							 func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							 func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_logical_NOT_expression,
@@ -9104,6 +9218,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_compl(	parse_tree&amp; src, const type_system&amp; types,
 								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 								func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_complement_expression,
@@ -9117,6 +9232,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_unary_plus(parse_tree&amp; src, const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree)
 {
@@ -9128,6 +9244,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_unary_minus(parse_tree&amp; src, const type_system&amp; types,
 							 func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							 literal_converts_to_bool_func&amp; literal_converts_to_bool,
@@ -9141,6 +9258,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_mult_expression(parse_tree&amp; src,const type_system&amp; types,
 								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 								literal_converts_to_bool_func&amp; literal_converts_to_bool,
@@ -9148,13 +9266,13 @@
 {
 	if (is_C99_mult_operator_expression&lt;'*'&gt;(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_mult_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_div_expression(parse_tree&amp; src,const type_system&amp; types,
 								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 								literal_converts_to_bool_func&amp; literal_converts_to_bool,
@@ -9162,13 +9280,13 @@
 {
 	if (is_C99_mult_operator_expression&lt;'/'&gt;(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_div_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_mod_expression(parse_tree&amp; src,const type_system&amp; types,
 								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 								literal_converts_to_bool_func&amp; literal_converts_to_bool,
@@ -9176,14 +9294,13 @@
 {
 	if (is_C99_mult_operator_expression&lt;'%'&gt;(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_mod_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
-
+//! \throw std::bad_alloc
 static bool eval_add_expression(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							literal_converts_to_bool_func&amp; literal_converts_to_bool,
@@ -9191,13 +9308,13 @@
 {
 	if (is_C99_add_operator_expression&lt;'+'&gt;(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_add_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_sub_expression(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							literal_converts_to_bool_func&amp; literal_converts_to_bool,
@@ -9205,13 +9322,13 @@
 {
 	if (is_C99_add_operator_expression&lt;'-'&gt;(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_sub_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_shift(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							literal_converts_to_bool_func&amp; literal_converts_to_bool,
@@ -9219,26 +9336,26 @@
 {
 	if (is_C99_shift_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_shift(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_relation_expression(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							intlike_literal_to_VM_func&amp; intlike_literal_to_VM)
 {
 	if (is_C99_relation_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_relation_expression(src,types,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_equality_expression(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_equality_expression,
@@ -9247,13 +9364,13 @@
 {
 	if (is_equality_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_equality_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_AND(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_AND_expression,
@@ -9262,13 +9379,13 @@
 {
 	if (is_bitwise_AND_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_bitwise_AND(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_XOR(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_XOR_expression,
@@ -9277,13 +9394,13 @@
 {
 	if (is_bitwise_XOR_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_bitwise_XOR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_OR(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_OR_expression,
@@ -9292,13 +9409,13 @@
 {
 	if (is_bitwise_OR_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_bitwise_OR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_logical_AND(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_logical_AND_expression,
@@ -9306,13 +9423,13 @@
 {
 	if (is_logical_AND_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_logical_AND(src,types,literal_converts_to_bool)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_logical_OR(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_logical_OR_expression,
@@ -9320,13 +9437,13 @@
 {
 	if (is_logical_OR_expression(src))
 		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_logical_OR(src,types,literal_converts_to_bool)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_conditional_operator(parse_tree&amp; src,const type_system&amp; types,
 									  func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 									  literal_converts_to_bool_func&amp; literal_converts_to_bool)
@@ -9347,12 +9464,10 @@
 		{	// strip off &amp;*, and remove lvalue-ness of target
 		if (is_C99_unary_operator_expression&lt;'*'&gt;(*src.data&lt;2&gt;()) &amp;&amp; 0&lt;src.data&lt;2&gt;()-&gt;data&lt;2&gt;()-&gt;type_code.pointer_power)
 			{
-			parse_tree tmp = *src.data&lt;2&gt;()-&gt;data&lt;2&gt;();
+			parse_tree tmp;
+			src.c_array&lt;2&gt;()-&gt;c_array&lt;2&gt;()-&gt;OverwriteInto(tmp);
 			tmp.type_code.traits &amp;= ~type_spec::lvalue;
-			src.c_array&lt;2&gt;()-&gt;c_array&lt;2&gt;()-&gt;clear();
-			src.destroy();
-			src = tmp;
-			return true;
+			tmp.MoveInto(src);
 			}
 #if 0
 		if (is_array_deref(*src.data&lt;2&gt;()))
@@ -9364,6 +9479,7 @@
 }
 #endif
 
+//! \throw std::bad_alloc
 static bool C99_EvalParseTree(parse_tree&amp; src,const type_system&amp; types)
 {
 	const size_t starting_errors = zcc_errors.err_count();
@@ -9392,6 +9508,7 @@
 	return starting_errors==zcc_errors.err_count();
 }
 
+//! \throw std::bad_alloc
 static bool CPP_EvalParseTree(parse_tree&amp; src,const type_system&amp; types)
 {
 	const size_t starting_errors = zcc_errors.err_count();


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000181.html">[Zcplusplus-commits] r414 - trunk
</A></li>
	<LI>Next message: <A HREF="000183.html">[Zcplusplus-commits] r416 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#182">[ date ]</a>
              <a href="thread.html#182">[ thread ]</a>
              <a href="subject.html#182">[ subject ]</a>
              <a href="author.html#182">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/zcplusplus-commits">More information about the Zcplusplus-commits
mailing list</a><br>
</body></html>
