<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Zcplusplus-commits] r344 - trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/zcplusplus-commits/2010-March/index.html" >
   <LINK REL="made" HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r344%20-%20trunk&In-Reply-To=%3C201003070311.o273BRhL004669%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000110.html">
   <LINK REL="Next"  HREF="000112.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Zcplusplus-commits] r344 - trunk</H1>
    <B>zaimoni at mail.berlios.de</B> 
    <A HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r344%20-%20trunk&In-Reply-To=%3C201003070311.o273BRhL004669%40sheep.berlios.de%3E"
       TITLE="[Zcplusplus-commits] r344 - trunk">zaimoni at mail.berlios.de
       </A><BR>
    <I>Sun Mar  7 04:11:27 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="000110.html">[Zcplusplus-commits] r343 - trunk
</A></li>
        <LI>Next message: <A HREF="000112.html">[Zcplusplus-commits] r345 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#111">[ date ]</a>
              <a href="thread.html#111">[ thread ]</a>
              <a href="subject.html#111">[ subject ]</a>
              <a href="author.html#111">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zaimoni
Date: 2010-03-07 04:11:18 +0100 (Sun, 07 Mar 2010)
New Revision: 344

Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc_autogen.cpp
   trunk/CSupport_pp.hpp
   trunk/type_system.cpp
   trunk/type_system.hpp
   trunk/type_system_pp.cpp
   trunk/type_system_pp.hpp
Log:
strip type_system for z_cpp.exe

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2010-03-05 20:32:43 UTC (rev 343)
+++ trunk/CPreproc.cpp	2010-03-07 03:11:18 UTC (rev 344)
@@ -1,7 +1,10 @@
 // CPreproc.cpp
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
+#/*cut-cpp*/
 #include &quot;CPreproc.hpp&quot;
+#/*cut-cpp*/
+#include &quot;CPreproc_pp.hpp&quot;
 
 #include &lt;limits.h&gt;
 #include &lt;time.h&gt;
@@ -9,7 +12,10 @@
 #include &lt;unistd.h&gt;
 
 #include &quot;AtomicString.h&quot;
+#/*cut-cpp*/
 #include &quot;CSupport.hpp&quot;
+#/*cut-cpp*/
+#include &quot;CSupport_pp.hpp&quot;
 #include &quot;C_PPDecimalInteger.hpp&quot;
 #include &quot;CPUInfo.hpp&quot;
 #include &quot;errors.hpp&quot;

Modified: trunk/CPreproc_autogen.cpp
===================================================================
--- trunk/CPreproc_autogen.cpp	2010-03-05 20:32:43 UTC (rev 343)
+++ trunk/CPreproc_autogen.cpp	2010-03-07 03:11:18 UTC (rev 344)
@@ -2,7 +2,10 @@
 // (C)2009,2010 Kenneth Boyd, license: MIT.txt
 // class CPreprocessor support for autogenerating headers for arbitrary machine targets.
 
+#/*cut-cpp*/
 #include &quot;CPreproc.hpp&quot;
+#/*cut-cpp*/
+#include &quot;CPreproc_pp.hpp&quot;
 #include &quot;CPUInfo.hpp&quot;
 #include &quot;errors.hpp&quot;
 #include &quot;Zaimoni.STL/POD.hpp&quot;

Modified: trunk/CSupport_pp.hpp
===================================================================
--- trunk/CSupport_pp.hpp	2010-03-05 20:32:43 UTC (rev 343)
+++ trunk/CSupport_pp.hpp	2010-03-07 03:11:18 UTC (rev 344)
@@ -1,4 +1,4 @@
-// CSupport_pp.hpp
+// CSupport.hpp
 // support for C/C++ language parsing
 // (C)2009 Kenneth Boyd, license: MIT.txt
 

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2010-03-05 20:32:43 UTC (rev 343)
+++ trunk/type_system.cpp	2010-03-07 03:11:18 UTC (rev 344)
@@ -1,7 +1,10 @@
 // type_system.cpp
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
+#/*cut-cpp*/
 #include &quot;type_system.hpp&quot;
+#/*cut-cpp*/
+#include &quot;type_system_pp.hpp&quot;
 #include &quot;enum_type.hpp&quot;
 #include &quot;struct_type.hpp&quot;
 #include &quot;Zaimoni.STL/search.hpp&quot;
@@ -14,6 +17,7 @@
 #define DYNAMIC_STRUCTDECL 2
 #define DYNAMIC_C_STRUCTDEF 3
 #define DYNAMIC_ENUMDEF 4
+#/*cut-cpp*/
 
 type_system::type_index type_system::_get_id_union(const char* const x) const
 {
@@ -267,6 +271,7 @@
 		}
 	return _get_id_enum_CPP(alias);
 }
+#/*cut-cpp*/
 
 const char* type_system::_name(size_t id) const
 {
@@ -276,6 +281,7 @@
 		return dynamic_types[id].first;
 	return &quot;(?)&quot;;
 }
+#/*cut-cpp*/
 
 // implement C/C++ typedef system
 void type_system::set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec&amp; src)
@@ -851,4 +857,5 @@
 	tmp.third.first.third = src;
 	src = NULL;
 }
+#/*cut-cpp*/
 

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2010-03-05 20:32:43 UTC (rev 343)
+++ trunk/type_system.hpp	2010-03-07 03:11:18 UTC (rev 344)
@@ -28,10 +28,12 @@
 private:
 	typedef zaimoni::POD_triple&lt;const char*,size_t,zaimoni::POD_pair&lt;zaimoni::union_quartet&lt;function_type*,union_struct_decl*,C_union_struct_def*,enum_def*&gt;, unsigned char&gt; &gt; dynamic_type_format;
 	zaimoni::autovalarray_ptr&lt;dynamic_type_format&gt; dynamic_types;
+#/*cut-cpp*/
 	zaimoni::autovalarray_ptr&lt;zaimoni::POD_pair&lt;const char*,zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt; &gt; &gt; typedef_registry;
 	zaimoni::weakautovalarray_ptr&lt;const char*&gt; inline_namespace_alias_targets;
 	zaimoni::autovalarray_ptr&lt;zaimoni::POD_pair&lt;const char*,const char*&gt; &gt; inline_namespace_alias_map;
 	zaimoni::autovalarray_ptr&lt;enumerator_info&gt; enumerator_registry;
+#/*cut-cpp*/
 	// uncopyable
 	type_system(const type_system&amp; src);
 	void operator=(const type_system&amp; src);
@@ -42,6 +44,7 @@
 		core_types_size((assert(0&lt;_core_types_size),_core_types_size)),
 		int_priority_size((assert(0&lt;_int_priority_size),_int_priority_size)) {};
 
+#/*cut-cpp*/
 	type_index get_id_union(const char* x) const
 		{
 		assert(x &amp;&amp; *x);
@@ -60,14 +63,16 @@
 		return _get_id_enum(x);
 		}
 	type_index get_id_enum_CPP(const char* alias,const char* active_namespace) const;
+#/*cut-cpp*/
 	const char* name(type_index id) const
 		{
 		assert(core_types_size+dynamic_types.size()&gt;=id);
 		return _name(id);
 		}
+#/*cut-cpp*/
 
 	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
-	// defer seven other variants for now (YAGNI)
+	// defer five other variants for now (YAGNI)
 	static char* namespace_concatenate(const char* const name, const char* const active_namespace,const char* namespace_separator)
 		{
 		assert(name &amp;&amp; *name);
@@ -75,8 +80,6 @@
 		assert(namespace_separator &amp;&amp; *namespace_separator);
 		return _namespace_concatenate(name,strlen(name),active_namespace,strlen(active_namespace),namespace_separator,strlen(namespace_separator));
 		};
-
-	// defer six other variants for now (YAGNI)
 	static void namespace_concatenate(char* buf, const char* const name, const char* const active_namespace,const char* namespace_separator)
 		{
 		assert(buf);
@@ -95,7 +98,6 @@
 		_namespace_concatenate(buf,name,strlen(name),active_namespace,active_namespace_len,namespace_separator,strlen(namespace_separator));
 		};
 
-
 	void set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec&amp; src);	// invalidates src
 	void set_typedef_CPP(const char* const name, const char* const active_namespace, const char* filename, const size_t lineno, type_spec&amp; src);	// invalidates src
 	const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* get_typedef(const char* const alias) const;
@@ -120,7 +122,9 @@
 	const C_union_struct_def* get_C_structdef(type_index i);
 	const enum_def* get_enum_def(type_index i);
 	void upgrade_decl_to_def(type_index i,C_union_struct_def*&amp; src);
+#/*cut-cpp*/
 private:
+#/*cut-cpp*/
 	type_index _get_id_union(const char* x) const;
 	type_index _get_id_union_CPP(const char* x) const;
 	type_index _get_id_enum(const char* x) const;
@@ -128,11 +132,12 @@
 	type_index _get_id_struct_class(const char* x) const;
 	type_index _get_id_struct_class_CPP(const char* x) const;
 
+#/*cut-cpp*/
 	const char* _name(type_index id) const;
+#/*cut-cpp*/
 	zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; dealias_inline_namespace_index(const char* alias) const;
 	const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* _get_typedef_CPP(const char* alias) const;
 	const enumerator_info* _get_enumerator_CPP(const char* alias) const;
-
 	bool is_inline_namespace_CPP(const char* active_namespace, size_t active_namespace_len) const;
 	const char* canonical_name_is_inline_namespace_alias_target(const char* name, size_t name_len, const char* active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len) const;
 	const char* construct_canonical_name_and_aliasing_CPP(const char* name, size_t name_len, const char* active_namespace, size_t active_namespace_len);
@@ -140,5 +145,6 @@
 	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
 	static char* _namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
 	static void _namespace_concatenate(char* buf, const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
+#/*cut-cpp*/
 };
 #endif

Modified: trunk/type_system_pp.cpp
===================================================================
--- trunk/type_system_pp.cpp	2010-03-05 20:32:43 UTC (rev 343)
+++ trunk/type_system_pp.cpp	2010-03-07 03:11:18 UTC (rev 344)
@@ -1,7 +1,7 @@
-// type_system.cpp
+// type_system_pp.cpp
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-#include &quot;type_system.hpp&quot;
+#include &quot;type_system_pp.hpp&quot;
 #include &quot;enum_type.hpp&quot;
 #include &quot;struct_type.hpp&quot;
 #include &quot;Zaimoni.STL/search.hpp&quot;
@@ -15,259 +15,6 @@
 #define DYNAMIC_C_STRUCTDEF 3
 #define DYNAMIC_ENUMDEF 4
 
-type_system::type_index type_system::_get_id_union(const char* const x) const
-{
-	const size_t x_len = strlen(x);
-	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
-	while(0&lt;=tmp)
-		{
-		if (DYNAMIC_STRUCTDECL==dynamic_types[tmp].third.second)
-			{
-			if (union_struct_decl::decl_union==dynamic_types[tmp].third.first.second-&gt;keyword())
-				return tmp+1+core_types_size;
-			return 0;
-			};
-		if (DYNAMIC_C_STRUCTDEF==dynamic_types[tmp].third.second)
-			{
-			if (union_struct_decl::decl_union==dynamic_types[tmp].third.first.third-&gt;_decl.keyword())
-				return tmp+1+core_types_size;
-			return 0;
-			}
-		// in a different tag space...retry
-		if (1&gt;=dynamic_types.size()-tmp) break;
-		errr tmp2 = linear_find_lencached(x,x_len,dynamic_types.data()+tmp+1,dynamic_types.size()-(tmp+1));
-		if (0&gt;tmp2) break;
-		tmp += 1+tmp2;
-		}
-	return 0;
-}
-
-type_system::type_index
-type_system::_get_id_union_CPP(const char* const x) const
-{
-	errr tmp = _get_id_union(x);
-	if (0&lt;tmp) return tmp;
-
-	// hmm...not an exact match
-	zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; tmp2 = dealias_inline_namespace_index(x);
-	if (0&gt;tmp2.first) return 0;
-
-	// it was remapped
-	while(tmp2.first&lt;tmp2.second)
-		{
-		tmp = _get_id_union(inline_namespace_alias_map.data()[tmp2.first].second);
-		if (0&lt;tmp) return tmp;
-		++tmp2.first;
-		}
-	return _get_id_union(inline_namespace_alias_map.data()[tmp2.first].second);
-}
-
-type_system::type_index
-type_system::get_id_union_CPP(const char* alias,const char* active_namespace) const
-{
-	assert(alias &amp;&amp; *alias);
-
-	if (!strncmp(alias,&quot;::&quot;,2))
-		{	// fully-qualified
-		// pretend not fully qualified, but no surrounding namespace
-		alias += 2;
-		active_namespace = NULL;
-		};
-	if (active_namespace &amp;&amp; *active_namespace)
-		{
-		// ok..march up to global
-		char* tmp_alias = namespace_concatenate(alias,active_namespace,&quot;::&quot;);
-		if (is_string_registered(tmp_alias))
-			{	// registered, so could be indexed
-			const type_index tmp2 = _get_id_union_CPP(tmp_alias);
-			if (tmp2) return (free(tmp_alias),tmp2);
-			}
-
-		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,&quot;::&quot;);
-		if (extra_namespaces)
-			{
-			zaimoni::weakautovalarray_ptr_throws&lt;const char*&gt; intra_namespace(extra_namespaces);
-			report_disjoint_substring_instances(active_namespace,&quot;::&quot;,intra_namespace.c_array(),extra_namespaces);
-			size_t i = extra_namespaces;
-			do	{
-				--i;
-				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,&quot;::&quot;);
-				const type_index tmp2 = _get_id_union_CPP(tmp_alias);
-				if (tmp2) return (free(tmp_alias),tmp2);
-				}
-			while(0&lt;i);
-			}
-		free(tmp_alias);
-		}
-	return _get_id_union_CPP(alias);
-}
-
-type_system::type_index
-type_system::_get_id_struct_class(const char* const x) const
-{
-	const size_t x_len = strlen(x);
-	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
-	while(0&lt;=tmp)
-		{
-		if (DYNAMIC_STRUCTDECL==dynamic_types[tmp].third.second)
-			{
-			if (union_struct_decl::decl_union!=dynamic_types[tmp].third.first.second-&gt;keyword())
-				return tmp+1+core_types_size;
-			return 0;
-			};
-		if (DYNAMIC_C_STRUCTDEF==dynamic_types[tmp].third.second)
-			{
-			if (union_struct_decl::decl_union!=dynamic_types[tmp].third.first.third-&gt;_decl.keyword())
-				return tmp+1+core_types_size;
-			return 0;
-			}
-		// in a different tag space...retry
-		if (1&gt;=dynamic_types.size()-tmp) break;
-		errr tmp2 = linear_find_lencached(x,x_len,dynamic_types.data()+tmp+1,dynamic_types.size()-(tmp+1));
-		if (0&gt;tmp2) break;
-		tmp += 1+tmp2;
-		}
-	return 0;
-}
-
-type_system::type_index
-type_system::_get_id_struct_class_CPP(const char* const x) const
-{
-	errr tmp = _get_id_struct_class(x);
-	if (0&lt;tmp) return tmp;
-
-	// hmm...not an exact match
-	zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; tmp2 = dealias_inline_namespace_index(x);
-	if (0&gt;tmp2.first) return 0;
-
-	// it was remapped
-	while(tmp2.first&lt;tmp2.second)
-		{
-		tmp = _get_id_struct_class(inline_namespace_alias_map.data()[tmp2.first].second);
-		if (0&lt;tmp) return tmp;
-		++tmp2.first;
-		}
-	return _get_id_struct_class(inline_namespace_alias_map.data()[tmp2.first].second);
-}
-
-type_system::type_index
-type_system::get_id_struct_class_CPP(const char* alias,const char* active_namespace) const
-{
-	assert(alias &amp;&amp; *alias);
-
-	if (!strncmp(alias,&quot;::&quot;,2))
-		{	// fully-qualified
-		// pretend not fully qualified, but no surrounding namespace
-		alias += 2;
-		active_namespace = NULL;
-		};
-	if (active_namespace &amp;&amp; *active_namespace)
-		{
-		// ok..march up to global
-		char* tmp_alias = namespace_concatenate(alias,active_namespace,&quot;::&quot;);
-		if (is_string_registered(tmp_alias))
-			{	// registered, so could be indexed
-			const type_index tmp2 = _get_id_struct_class_CPP(tmp_alias);
-			if (tmp2) return (free(tmp_alias),tmp2);
-			}
-
-		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,&quot;::&quot;);
-		if (extra_namespaces)
-			{
-			zaimoni::weakautovalarray_ptr_throws&lt;const char*&gt; intra_namespace(extra_namespaces);
-			report_disjoint_substring_instances(active_namespace,&quot;::&quot;,intra_namespace.c_array(),extra_namespaces);
-			size_t i = extra_namespaces;
-			do	{
-				--i;
-				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,&quot;::&quot;);
-				const type_index tmp2 = _get_id_struct_class_CPP(tmp_alias);
-				if (tmp2) return (free(tmp_alias),tmp2);
-				}
-			while(0&lt;i);
-			}
-		free(tmp_alias);
-		}
-	return _get_id_struct_class_CPP(alias);
-}
-
-type_system::type_index type_system::_get_id_enum(const char* const x) const
-{
-	const size_t x_len = strlen(x);
-	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
-	while(0&lt;=tmp)
-		{
-		if (DYNAMIC_ENUMDEF==dynamic_types[tmp].third.second)
-			return tmp+1+core_types_size;
-
-		// in a different tag space...retry
-		if (1&gt;=dynamic_types.size()-tmp) break;
-		errr tmp2 = linear_find_lencached(x,x_len,dynamic_types.data()+tmp+1,dynamic_types.size()-(tmp+1));
-		if (0&gt;tmp2) break;
-		tmp += 1+tmp2;
-		}
-	return 0;
-}
-
-type_system::type_index
-type_system::_get_id_enum_CPP(const char* const x) const
-{
-	errr tmp = _get_id_enum(x);
-	if (0&lt;tmp) return tmp;
-
-	// hmm...not an exact match
-	zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; tmp2 = dealias_inline_namespace_index(x);
-	if (0&gt;tmp2.first) return 0;
-
-	// it was remapped
-	while(tmp2.first&lt;tmp2.second)
-		{
-		tmp = _get_id_enum(inline_namespace_alias_map.data()[tmp2.first].second);
-		if (0&lt;tmp) return tmp;
-		++tmp2.first;
-		}
-	return _get_id_enum(inline_namespace_alias_map.data()[tmp2.first].second);
-}
-
-type_system::type_index
-type_system::get_id_enum_CPP(const char* alias,const char* active_namespace) const
-{
-	assert(alias &amp;&amp; *alias);
-
-	if (!strncmp(alias,&quot;::&quot;,2))
-		{	// fully-qualified
-		// pretend not fully qualified, but no surrounding namespace
-		alias += 2;
-		active_namespace = NULL;
-		};
-	if (active_namespace &amp;&amp; *active_namespace)
-		{
-		// ok..march up to global
-		char* tmp_alias = namespace_concatenate(alias,active_namespace,&quot;::&quot;);
-		if (is_string_registered(tmp_alias))
-			{	// registered, so could be indexed
-			const type_index tmp2 = _get_id_enum_CPP(tmp_alias);
-			if (tmp2) return (free(tmp_alias),tmp2);
-			}
-
-		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,&quot;::&quot;);
-		if (extra_namespaces)
-			{
-			zaimoni::weakautovalarray_ptr_throws&lt;const char*&gt; intra_namespace(extra_namespaces);
-			report_disjoint_substring_instances(active_namespace,&quot;::&quot;,intra_namespace.c_array(),extra_namespaces);
-			size_t i = extra_namespaces;
-			do	{
-				--i;
-				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,&quot;::&quot;);
-				const type_index tmp2 = _get_id_enum_CPP(tmp_alias);
-				if (tmp2) return (free(tmp_alias),tmp2);
-				}
-			while(0&lt;i);
-			}
-		free(tmp_alias);
-		}
-	return _get_id_enum_CPP(alias);
-}
-
 const char* type_system::_name(size_t id) const
 {
 	if (0==id) return &quot;(?)&quot;;
@@ -277,578 +24,3 @@
 	return &quot;(?)&quot;;
 }
 
-// implement C/C++ typedef system
-void type_system::set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec&amp; src)
-{
-	assert(alias &amp;&amp; *alias);
-	assert(filename &amp;&amp; *filename);
-	errr tmp = binary_find(alias,strlen(alias),typedef_registry.data(),typedef_registry.size());
-	assert(0&gt;tmp);		// error to call with conflicting prior definition
-	if (0&lt;=tmp) return;	// conflicting prior definition
-#if UINTMAX_MAX==SIZE_MAX
-	if (-1==tmp) _fatal(&quot;implementation limit exceeded (typedefs registered at once)&quot;);
-#endif
-	zaimoni::POD_pair&lt;const char*,zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt; &gt; tmp2 = {alias, {src, filename, lineno}};
-	if (!typedef_registry.InsertSlotAt(BINARY_SEARCH_DECODE_INSERTION_POINT(tmp),tmp2)) throw std::bad_alloc();
-	src.clear();
-}
-
-void type_system::set_typedef_CPP(const char* name, const char* const active_namespace, const char* filename, const size_t lineno, type_spec&amp; src)
-{
-	assert(name &amp;&amp; *name);
-	assert(filename &amp;&amp; *filename);
-
-	// use active namespace if present
-	if (active_namespace &amp;&amp; *active_namespace)
-		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
-
-	return set_typedef(name,filename,lineno,src);
-}
-
-const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* type_system::get_typedef(const char* const alias) const
-{
-	assert(alias &amp;&amp; *alias);
-	//! \todo: strip off trailing inline namespaces
-	// &lt;unknown&gt; is the hack for anonymous namespaces taken from GCC, it's always inline
-	errr tmp = binary_find(alias,strlen(alias),typedef_registry.data(),typedef_registry.size());
-	if (0&lt;=tmp) return &amp;typedef_registry[tmp].second;
-	return NULL;
-}
-
-const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* type_system::_get_typedef_CPP(const char* const alias) const
-{
-	const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp = get_typedef(alias);
-	if (tmp) return tmp;
-
-	// hmm...not an exact match
-	zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; tmp2 = dealias_inline_namespace_index(alias);
-	if (0&gt;tmp2.first) return NULL;
-
-	// it was remapped
-	while(tmp2.first&lt;tmp2.second)
-		{
-		tmp = get_typedef(inline_namespace_alias_map.data()[tmp2.first].second);
-		if (tmp) return tmp;
-		++tmp2.first;
-		}
-	return get_typedef(inline_namespace_alias_map.data()[tmp2.first].second);
-}
-
-const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* type_system::get_typedef_CPP(const char* alias,const char* active_namespace) const
-{
-	assert(alias &amp;&amp; *alias);
-
-	if (!strncmp(alias,&quot;::&quot;,2))
-		{	// fully-qualified typedef name
-			// cheat: pretend not fully qualified but no surrounding namespace
-		alias += 2;
-		active_namespace = NULL;
-		};
-	if (active_namespace &amp;&amp; *active_namespace)
-		{
-		// ok..march up to global
-		char* tmp_alias = namespace_concatenate(alias,active_namespace,&quot;::&quot;);
-		if (is_string_registered(tmp_alias))
-			{	// registered, so could be indexed
-			const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp2 = _get_typedef_CPP(tmp_alias);
-			if (tmp2) return (free(tmp_alias),tmp2);
-			}
-
-		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,&quot;::&quot;);
-		if (extra_namespaces)
-			{
-			zaimoni::weakautovalarray_ptr_throws&lt;const char*&gt; intra_namespace(extra_namespaces);
-			report_disjoint_substring_instances(active_namespace,&quot;::&quot;,intra_namespace.c_array(),extra_namespaces);
-			size_t i = extra_namespaces;
-			do	{
-				--i;
-				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,&quot;::&quot;);
-				const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp2 = _get_typedef_CPP(tmp_alias);
-				if (tmp2) return (free(tmp_alias),tmp2);
-				}
-			while(0&lt;i);
-			}
-		free(tmp_alias);
-		}
-	return _get_typedef_CPP(alias);
-}
-
-void type_system::set_enumerator_def(const char* const alias, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* const src_filename,unsigned char representation,const uchar_blob&amp; src,type_index type)
-{
-	assert(alias &amp;&amp; *alias);
-	assert(src_filename &amp;&amp; *src_filename);
-	errr tmp = binary_find(alias,strlen(alias),enumerator_registry.data(),enumerator_registry.size());
-	assert(0&gt;tmp);		// error to call with conflicting prior definition
-	if (0&lt;=tmp) return;	// conflicting prior definition
-#if UINTMAX_MAX==SIZE_MAX
-	if (-1==tmp) _fatal(&quot;implementation limit exceeded (enumerators registered at once)&quot;);
-#endif
-	enumerator_info tmp2 = {alias, { {type, representation, src}, {src_filename, logical_line} } };
-	if (!enumerator_registry.InsertSlotAt(BINARY_SEARCH_DECODE_INSERTION_POINT(tmp),tmp2)) throw std::bad_alloc();
-}
-
-void type_system::set_enumerator_def_CPP(const char* name, const char* const active_namespace, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* const src_filename,unsigned char representation,const uchar_blob&amp; src,type_index type)
-{
-	assert(name &amp;&amp; *name);
-	assert(src_filename &amp;&amp; *src_filename);
-
-	// use active namespace if present
-	if (active_namespace &amp;&amp; *active_namespace)
-		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
-
-	set_enumerator_def(name,logical_line,src_filename,representation,src,type);
-}
-
-const type_system::enumerator_info* type_system::get_enumerator(const char* const alias) const
-{
-	assert(alias &amp;&amp; *alias);
-	//! \todo: strip off trailing inline namespaces
-	// &lt;unknown&gt; is the hack for anonymous namespaces taken from GCC, it's always inline
-	errr tmp = binary_find(alias,strlen(alias),enumerator_registry.data(),enumerator_registry.size());
-	if (0&lt;=tmp) return &amp;enumerator_registry[tmp];
-	return NULL;
-}
-
-const type_system::enumerator_info* type_system::_get_enumerator_CPP(const char* const alias) const
-{
-	const enumerator_info* tmp = get_enumerator(alias);
-	if (tmp) return tmp;
-
-	// hmm...not an exact match
-	zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; tmp2 = dealias_inline_namespace_index(alias);
-	if (0&gt;tmp2.first) return NULL;
-
-	// it was remapped
-	while(tmp2.first&lt;tmp2.second)
-		{
-		tmp = get_enumerator(inline_namespace_alias_map.data()[tmp2.first].second);
-		if (tmp) return tmp;
-		++tmp2.first;
-		}
-	return get_enumerator(inline_namespace_alias_map.data()[tmp2.first].second);
-}
-
-const type_system::enumerator_info* type_system::get_enumerator_CPP(const char* alias,const char* active_namespace) const
-{
-	assert(alias &amp;&amp; *alias);
-
-	if (!strncmp(alias,&quot;::&quot;,2))
-		{	// fully-qualified typedef name
-			// cheat: pretend not fully qualified but no surrounding namespace
-		alias += 2;
-		active_namespace = NULL;
-		};
-	if (active_namespace &amp;&amp; *active_namespace)
-		{
-		// ok..march up to global
-		char* tmp_alias = namespace_concatenate(alias,active_namespace,&quot;::&quot;);
-		if (is_string_registered(tmp_alias))
-			{	// registered, so could be indexed
-			const enumerator_info* tmp2 = _get_enumerator_CPP(tmp_alias);
-			if (tmp2) return (free(tmp_alias),tmp2);
-			}
-
-		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,&quot;::&quot;);
-		if (extra_namespaces)
-			{
-			zaimoni::weakautovalarray_ptr_throws&lt;const char*&gt; intra_namespace(extra_namespaces);
-			report_disjoint_substring_instances(active_namespace,&quot;::&quot;,intra_namespace.c_array(),extra_namespaces);
-			size_t i = extra_namespaces;
-			do	{
-				--i;
-				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,&quot;::&quot;);
-				const enumerator_info* tmp2 = _get_enumerator_CPP(tmp_alias);
-				if (tmp2) return (free(tmp_alias),tmp2);
-				}
-			while(0&lt;i);
-			}
-		free(tmp_alias);
-		}
-	return _get_enumerator_CPP(alias);
-}
-
-char* type_system::_namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len)
-{	// remove comment after other seven wrapper variants implemented
-//	assert(active_namespace &amp;&amp; *active_namespace &amp;&amp; 0&lt;active_namespace_len &amp;&amp; active_namespace_len&lt;=strlen(active_namespace));
-//	assert(name &amp;&amp; *name &amp;&amp; 0&lt;name_len &amp;&amp; name_len&lt;=strlen(name));
-//	assert(namespace_separator &amp;&amp; *namespace_separator &amp;&amp; 0&lt;namespace_separator_len &amp;&amp; namespace_separator_len&lt;=strlen(namespace_separator));
-	char* const actual_name = zaimoni::_new_buffer_nonNULL_throws&lt;char&gt;(ZAIMONI_LEN_WITH_NULL(active_namespace_len+2+name_len));
-	strncpy(actual_name,active_namespace,active_namespace_len);
-	strncpy(actual_name+active_namespace_len,namespace_separator,namespace_separator_len);
-	strncpy(actual_name+active_namespace_len+namespace_separator_len,name,name_len);
-	return actual_name;
-}
-
-void type_system::_namespace_concatenate(char* buf, const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len)
-{	// remove comment after other seven wrapper variants implemented
-//	assert(buf)
-//	assert(active_namespace &amp;&amp; *active_namespace &amp;&amp; 0&lt;active_namespace_len &amp;&amp; active_namespace_len&lt;=strlen(active_namespace));
-//	assert(name &amp;&amp; *name &amp;&amp; 0&lt;name_len &amp;&amp; name_len&lt;=strlen(name));
-//	assert(namespace_separator &amp;&amp; *namespace_separator &amp;&amp; 0&lt;namespace_separator_len &amp;&amp; namespace_separator_len&lt;=strlen(namespace_separator));
-	strncpy(buf,active_namespace,active_namespace_len);
-	strncpy(buf+active_namespace_len,namespace_separator,namespace_separator_len);
-	strncpy(buf+active_namespace_len+namespace_separator_len,name,name_len);
-	ZAIMONI_NULL_TERMINATE(buf[active_namespace_len+namespace_separator_len+name_len]);
-}
-
-zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; type_system::dealias_inline_namespace_index(const char* const alias) const
-{
-	assert(alias &amp;&amp; *alias);
-	zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; tmp = {-1,-1};
-	size_t strict_ub = inline_namespace_alias_map.size();
-	size_t lb = 0;
-	// binary search
-	// is inline_namespace_alias_map.data() a code size optimization target?
-	while(strict_ub&gt;lb)
-		{
-		const size_t midpoint = lb+(strict_ub-lb)/2;
-		switch(strcmp(inline_namespace_alias_map.data()[midpoint].first,alias))
-		{
-#ifndef NDEBUG
-		default: FATAL(&quot;strcmp out of range -1,0,1&quot;);
-#endif
-		case 0: {
-			tmp.first = midpoint;
-			tmp.second = midpoint;
-			while(lb&lt;(size_t)tmp.first &amp;&amp; !strcmp(inline_namespace_alias_map.data()[tmp.first-1].first,alias)) --tmp.first;
-			while(strict_ub-1&gt;(size_t)tmp.second &amp;&amp; !strcmp(inline_namespace_alias_map.data()[tmp.second+1].first,alias)) ++tmp.second;
-			return tmp;
-			}
-		case 1: {
-			strict_ub = midpoint;
-			break;
-			}
-		case -1:{
-			lb = midpoint+1;
-			}
-		}
-		}
-	return tmp;
-}
-
-bool type_system::is_inline_namespace_CPP(const char* const active_namespace, const size_t active_namespace_len) const
-{
-	assert(active_namespace &amp;&amp; *active_namespace &amp;&amp; 0&lt;active_namespace_len);
-	assert(strncmp(active_namespace,&quot;::&quot;,2));
-	
-	// ::&lt;unknown&gt;, our hack for anonymous namespaces, is always an inline namespace 
-	if (sizeof(&quot;&lt;unknown&gt;&quot;)-1==active_namespace_len &amp;&amp; !strncmp(active_namespace,&quot;&lt;unknown&gt;&quot;,sizeof(&quot;&lt;unknown&gt;&quot;)-1)) return true;
-	if (sizeof(&quot;::&lt;unknown&gt;&quot;)-1&lt;active_namespace_len &amp;&amp; !strncmp(active_namespace+(active_namespace_len-(sizeof(&quot;::&lt;unknown&gt;&quot;)-1)),&quot;::&lt;unknown&gt;&quot;,sizeof(&quot;::&lt;unknown&gt;&quot;)-1)) return true;
-
-	//! \todo check for C++0X inline namespaces
-	// should be fine with binary search against canonical names
-	return false;
-}
-
-const char* type_system::canonical_name_is_inline_namespace_alias_target(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len) const
-{
-	assert(active_namespace &amp;&amp; *active_namespace &amp;&amp; 0&lt;active_namespace_len);
-	assert(name &amp;&amp; *name &amp;&amp; 0&lt;name_len);
-	assert(namespace_separator &amp;&amp; *namespace_separator &amp;&amp; 0&lt;namespace_separator_len);
-	size_t strict_ub = inline_namespace_alias_targets.size();
-	size_t lb = 0;
-	// classic binary search.
-	// is inline_namespace_alias_targets.data() a code-size optimization target?
-	while(strict_ub&gt;lb)
-		{
-		const size_t midpoint = lb+(strict_ub-lb)/2;
-		int tmp = strncmp(inline_namespace_alias_targets.data()[midpoint],active_namespace,active_namespace_len);
-		if (!tmp) tmp = strncmp(inline_namespace_alias_targets.data()[midpoint]+active_namespace_len,namespace_separator,namespace_separator_len);
-		if (!tmp) tmp = strncmp(inline_namespace_alias_targets.data()[midpoint]+active_namespace_len+namespace_separator_len,name,name_len);
-		switch(tmp)
-		{
-#ifndef NDEBUG
-		default: FATAL(&quot;strncmp out of range -1,0,1&quot;);
-#endif
-		case 0: return  inline_namespace_alias_targets.data()[midpoint];
-		case 1: {
-			strict_ub = midpoint;
-			break;
-			}
-		case -1:{
-			lb = midpoint+1;
-			}
-		}
-		}
-	return NULL;
-}
-
-const char* type_system::construct_canonical_name_and_aliasing_CPP(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len)
-{
-	assert(active_namespace &amp;&amp; *active_namespace &amp;&amp; 0&lt;active_namespace_len);
-	assert(name &amp;&amp; *name &amp;&amp; 0&lt;name_len);
-	assert(strncmp(active_namespace,&quot;::&quot;,2));
-	// check for whether we already are aliased
-	const char* retval = canonical_name_is_inline_namespace_alias_target(name,name_len,active_namespace,active_namespace_len,&quot;::&quot;,2);
-	if (NULL!=retval) return retval;
-
-	// canonical name is simply active_namespace::name
-	zaimoni::autoval_ptr&lt;char&gt; retval_tmp;
-	retval_tmp = _namespace_concatenate(name,name_len,active_namespace,active_namespace_len,&quot;::&quot;,2);
-
-	// aliasing is built by removing trailing inline namespaces incrementally
-	const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,&quot;::&quot;);
-	if (is_inline_namespace_CPP(active_namespace,active_namespace_len))
-		{
-		zaimoni::autovalarray_ptr_throws&lt;char*&gt; namespace_tmp(extra_namespaces);
-#ifndef ZAIMONI_NULL_REALLY_IS_ZERO
-#error need to null-initialize pointers for namespace_tmp
-#endif
-		bool can_be_completely_gone = false;
-		{
-		zaimoni::weakautovalarray_ptr_throws&lt;const char*&gt; intra_namespace(extra_namespaces);
-		if (extra_namespaces)
-			{
-			report_disjoint_substring_instances(active_namespace,&quot;::&quot;,intra_namespace.c_array(),extra_namespaces);
-			size_t i = extra_namespaces;
-			do	{
-				if (!is_inline_namespace_CPP(active_namespace,i==extra_namespaces ? active_namespace_len : intra_namespace[i]-active_namespace))
-					break;
-				--i;
-				namespace_tmp[i] = _namespace_concatenate(name,name_len,active_namespace,intra_namespace[i]-active_namespace,&quot;::&quot;,2);
-				}
-			while(0&lt;i);
-			can_be_completely_gone = (0==i &amp;&amp; is_inline_namespace_CPP(active_namespace,intra_namespace[0]-active_namespace));
-			if (0&lt;i) namespace_tmp.DeleteNSlotsAt(i,0);
-			}
-		else{
-			can_be_completely_gone = true;
-			}
-		}
-		assert(can_be_completely_gone || !namespace_tmp.empty());
-
-		size_t origin = inline_namespace_alias_map.size();
-		size_t origin2 = inline_namespace_alias_targets.size();
-		inline_namespace_alias_targets.resize(origin2+1);
-		try	{
-			inline_namespace_alias_map.resize(origin+namespace_tmp.size()+can_be_completely_gone);
-			}
-		catch(std::bad_alloc&amp; e)
-			{
-			inline_namespace_alias_targets.resize(origin2);
-			throw;
-			}
-
-		retval = register_string(retval_tmp);	//! \todo would prefer to consume the string; changes reset() to NULLPtr() to be safe
-		retval_tmp.reset();
-		/* do a downward insertsort against the second index*/
-		while(origin2 &amp;&amp; 1==strcmp(inline_namespace_alias_targets.c_array()[origin2-1],retval))
-			{
-			inline_namespace_alias_targets.c_array()[origin2] = inline_namespace_alias_targets.c_array()[origin2-1];
-			--origin2;
-			};
-		inline_namespace_alias_targets.c_array()[origin2] = retval;
-
-		size_t i = namespace_tmp.size();
-		while(0&lt;i)
-			{
-			const zaimoni::POD_pair&lt;const char*,const char*&gt; tmp = {register_string(namespace_tmp[--i]), retval};
-			size_t j = origin;
-			while(j &amp;&amp; 1==strcmp(inline_namespace_alias_map.c_array()[j-1].first,tmp.first))
-				{
-				inline_namespace_alias_map.c_array()[j] = inline_namespace_alias_map.c_array()[j-1];
-				--j;
-				};
-			inline_namespace_alias_map.c_array()[origin++] = tmp;
-			free(namespace_tmp[i]);
-			namespace_tmp[i] = NULL;
-			};
-		if (can_be_completely_gone)
-			{
-			const zaimoni::POD_pair&lt;const char*,const char*&gt; tmp = {register_substring(name,name_len), retval};
-			size_t j = origin;
-			while(j &amp;&amp; 1==strcmp(inline_namespace_alias_map.c_array()[j-1].first,tmp.first))
-				{
-				inline_namespace_alias_map.c_array()[j] = inline_namespace_alias_map.c_array()[j-1];
-				--j;
-				};
-			inline_namespace_alias_map.c_array()[origin++] = tmp;
-			}
-		}
-
-	if (!retval)
-		{
-		retval = register_string(retval_tmp);	//! \todo would prefer to consume the string; changes reset() to NULLPtr() to be safe
-		retval_tmp.reset();
-		};
-	// return the canonical name
-	return retval;
-}
-
-type_system::type_index type_system::register_functype(const char* const alias, function_type*&amp; src)
-{
-	assert(alias &amp;&amp; *alias);
-	assert(src);
-	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_FUNCTYPE}};
-	tmp.third.first.first = src;
-
-	const size_t dynamic_types_size = dynamic_types.size();
-	const size_t dynamic_types_max_size = dynamic_types.max_size();
-	if (	dynamic_types_max_size&lt;1+core_types_size
-		|| 	dynamic_types_max_size-(1+core_types_size)&lt;dynamic_types_size)
-		FATAL(&quot;Host implementation limit exceeded: cannot record function type used in program&quot;);
-	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
-	src = NULL;
-	return dynamic_types_size+1+core_types_size;
-}
-
-type_system::type_index type_system::register_functype_CPP(const char* name, const char* const active_namespace, function_type*&amp; src)
-{
-	assert(name &amp;&amp; *name);
-	assert(src);
-
-	// use active namespace if present
-	if (active_namespace &amp;&amp; *active_namespace)
-		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
-
-	return register_functype(name,src);
-}
-
-type_system::type_index type_system::register_structdecl(const char* const alias, int keyword)
-{
-	assert(alias &amp;&amp; *alias);
-	const size_t dynamic_types_size = dynamic_types.size();
-	const size_t dynamic_types_max_size = dynamic_types.max_size();
-	if (	dynamic_types_max_size&lt;2+core_types_size
-		|| 	dynamic_types_max_size-(2+core_types_size)&lt;dynamic_types_size)
-		FATAL(&quot;Host implementation limit exceeded: cannot record union/struct type used in program&quot;);
-
-	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_STRUCTDECL}};
-	tmp.third.first.second = new union_struct_decl((union_struct_decl::keywords)keyword,alias);
-
-	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp))
-		{
-		delete tmp.third.first.second;
-		throw std::bad_alloc();
-		}
-	return dynamic_types_size+1+core_types_size;
-}
-
-type_system::type_index type_system::register_structdecl_CPP(const char* name, const char* const active_namespace, int keyword)
-{
-	assert(name &amp;&amp; *name);
-
-	// use active namespace if present
-	if (active_namespace &amp;&amp; *active_namespace)
-		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
-
-	return register_structdecl(name,keyword);
-}
-
-type_system::type_index type_system::register_C_structdef(const char* const alias, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* const src_filename, int keyword)
-{
-	assert(alias &amp;&amp; *alias);
-	assert(src_filename &amp;&amp; *src_filename);
-	const size_t dynamic_types_size = dynamic_types.size();
-	const size_t dynamic_types_max_size = dynamic_types.max_size();
-	if (	dynamic_types_max_size&lt;2+core_types_size
-		|| 	dynamic_types_max_size-(2+core_types_size)&lt;dynamic_types_size)
-		FATAL(&quot;Host implementation limit exceeded: cannot record union/struct type used in program&quot;);
-
-	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_C_STRUCTDEF}};
-	tmp.third.first.third = new C_union_struct_def((union_struct_decl::keywords)keyword,alias,logical_line,src_filename);
-
-	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
-	return dynamic_types_size+1+core_types_size;
-}
-
-type_system::type_index type_system::register_C_structdef_CPP(const char* name, const char* const active_namespace, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* const src_filename, int keyword)
-{
-	assert(name &amp;&amp; *name);
-	assert(src_filename &amp;&amp; *src_filename);
-
-	// use active namespace if present
-	if (active_namespace &amp;&amp; *active_namespace)
-		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
-
-	return register_C_structdef(name,logical_line,src_filename,keyword);
-}
-
-type_system::type_index type_system::register_enum_def(const char* const alias, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* const src_filename)
-{
-	assert(alias &amp;&amp; *alias);
-	assert(src_filename &amp;&amp; *src_filename);
-	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_ENUMDEF}};
-	tmp.third.first.fourth = new enum_def(alias,logical_line,src_filename);
-
-	const size_t dynamic_types_size = dynamic_types.size();
-	const size_t dynamic_types_max_size = dynamic_types.max_size();
-	if (	dynamic_types_max_size&lt;2+core_types_size
-		|| 	dynamic_types_max_size-(2+core_types_size)&lt;dynamic_types_size)
-		FATAL(&quot;Host implementation limit exceeded: cannot record enum type used in program&quot;);
-	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
-	return dynamic_types_size+1+core_types_size;
-}
-
-type_system::type_index type_system::register_enum_def_CPP(const char* name, const char* const active_namespace, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* const src_filename)
-{
-	assert(name &amp;&amp; *name);
-	assert(src_filename &amp;&amp; *src_filename);
-
-	// use active namespace if present
-	if (active_namespace &amp;&amp; *active_namespace)
-		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
-
-	return register_enum_def(name,logical_line,src_filename);
-}
-
-const function_type* type_system::get_functype(type_system::type_index i)
-{
-	if (core_types_size&gt;=i) return NULL;
-	i -= core_types_size;
-	--i;
-	if (dynamic_types.size()&lt;=i) return NULL;
-	const dynamic_type_format&amp; tmp = dynamic_types[i];
-	if (DYNAMIC_FUNCTYPE!=tmp.third.second) return NULL;
-	return tmp.third.first.first;
-}
-
-const union_struct_decl* type_system::get_structdecl(type_system::type_index i)
-{
-	if (core_types_size&gt;=i) return NULL;
-	i -= core_types_size;
-	--i;
-	if (dynamic_types.size()&lt;=i) return NULL;
-	const dynamic_type_format&amp; tmp = dynamic_types[i];
-	if (DYNAMIC_STRUCTDECL!=tmp.third.second) return NULL;
-	return tmp.third.first.second;
-}
-
-const C_union_struct_def* type_system::get_C_structdef(type_system::type_index i)
-{
-	if (core_types_size&gt;=i) return NULL;
-	i -= core_types_size;
-	--i;
-	if (dynamic_types.size()&lt;=i) return NULL;
-	const dynamic_type_format&amp; tmp = dynamic_types[i];
-	if (DYNAMIC_C_STRUCTDEF!=tmp.third.second) return NULL;
-	return tmp.third.first.third;
-}
-
-const enum_def* type_system::get_enum_def(type_index i)
-{
-	if (core_types_size&gt;=i) return NULL;
-	i -= core_types_size;
-	--i;
-	if (dynamic_types.size()&lt;=i) return NULL;
-	const dynamic_type_format&amp; tmp = dynamic_types[i];
-	if (DYNAMIC_ENUMDEF!=tmp.third.second) return NULL;
-	return tmp.third.first.fourth;
-}
-
-void type_system::upgrade_decl_to_def(type_index i,C_union_struct_def*&amp; src)
-{	// cf. get_structdecl
-	assert(src);
-	assert(core_types_size&lt;i);
-	i -= core_types_size;
-	--i;
-	assert(dynamic_types.size()&gt;i);
-	dynamic_type_format&amp; tmp = dynamic_types[i];
-	assert(DYNAMIC_STRUCTDECL==tmp.third.second);
-	assert(*tmp.third.first.second==src-&gt;_decl);
-	tmp.third.second = DYNAMIC_C_STRUCTDEF;
-	delete tmp.third.first.second;
-	tmp.third.first.third = src;
-	src = NULL;
-}
-

Modified: trunk/type_system_pp.hpp
===================================================================
--- trunk/type_system_pp.hpp	2010-03-05 20:32:43 UTC (rev 343)
+++ trunk/type_system_pp.hpp	2010-03-07 03:11:18 UTC (rev 344)
@@ -1,4 +1,4 @@
-// type_system.hpp
+// type_system_pp.hpp
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
 #ifndef TYPE_SYSTEM_HPP
@@ -28,10 +28,6 @@
 private:
 	typedef zaimoni::POD_triple&lt;const char*,size_t,zaimoni::POD_pair&lt;zaimoni::union_quartet&lt;function_type*,union_struct_decl*,C_union_struct_def*,enum_def*&gt;, unsigned char&gt; &gt; dynamic_type_format;
 	zaimoni::autovalarray_ptr&lt;dynamic_type_format&gt; dynamic_types;
-	zaimoni::autovalarray_ptr&lt;zaimoni::POD_pair&lt;const char*,zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt; &gt; &gt; typedef_registry;
-	zaimoni::weakautovalarray_ptr&lt;const char*&gt; inline_namespace_alias_targets;
-	zaimoni::autovalarray_ptr&lt;zaimoni::POD_pair&lt;const char*,const char*&gt; &gt; inline_namespace_alias_map;
-	zaimoni::autovalarray_ptr&lt;enumerator_info&gt; enumerator_registry;
 	// uncopyable
 	type_system(const type_system&amp; src);
 	void operator=(const type_system&amp; src);
@@ -42,103 +38,12 @@
 		core_types_size((assert(0&lt;_core_types_size),_core_types_size)),
 		int_priority_size((assert(0&lt;_int_priority_size),_int_priority_size)) {};
 
-	type_index get_id_union(const char* x) const
-		{
-		assert(x &amp;&amp; *x);
-		return _get_id_union(x);
-		}
-	type_index get_id_union_CPP(const char* alias,const char* active_namespace) const;
-	type_index get_id_struct_class(const char* x) const
-		{
-		assert(x &amp;&amp; *x);
-		return _get_id_struct_class(x);
-		}
-	type_index get_id_struct_class_CPP(const char* alias,const char* active_namespace) const;
-	type_index get_id_enum(const char* x) const
-		{
-		assert(x &amp;&amp; *x);
-		return _get_id_enum(x);
-		}
-	type_index get_id_enum_CPP(const char* alias,const char* active_namespace) const;
 	const char* name(type_index id) const
 		{
 		assert(core_types_size+dynamic_types.size()&gt;=id);
 		return _name(id);
 		}
-
-	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
-	// defer seven other variants for now (YAGNI)
-	static char* namespace_concatenate(const char* const name, const char* const active_namespace,const char* namespace_separator)
-		{
-		assert(name &amp;&amp; *name);
-		assert(active_namespace &amp;&amp; *active_namespace);
-		assert(namespace_separator &amp;&amp; *namespace_separator);
-		return _namespace_concatenate(name,strlen(name),active_namespace,strlen(active_namespace),namespace_separator,strlen(namespace_separator));
-		};
-
-	// defer six other variants for now (YAGNI)
-	static void namespace_concatenate(char* buf, const char* const name, const char* const active_namespace,const char* namespace_separator)
-		{
-		assert(buf);
-		assert(name &amp;&amp; *name);
-		assert(active_namespace &amp;&amp; *active_namespace);
-		assert(namespace_separator &amp;&amp; *namespace_separator);
-		_namespace_concatenate(buf,name,strlen(name),active_namespace,strlen(active_namespace),namespace_separator,strlen(namespace_separator));
-		};
-	static void namespace_concatenate(char* buf, const char* const name, const char* const active_namespace,size_t active_namespace_len,const char* namespace_separator)
-		{
-		assert(buf);
-		assert(name &amp;&amp; *name);
-		assert(active_namespace &amp;&amp; *active_namespace);
-		assert(0&lt;active_namespace_len &amp;&amp; active_namespace_len&lt;=strlen(active_namespace));
-		assert(namespace_separator &amp;&amp; *namespace_separator);
-		_namespace_concatenate(buf,name,strlen(name),active_namespace,active_namespace_len,namespace_separator,strlen(namespace_separator));
-		};
-
-
-	void set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec&amp; src);	// invalidates src
-	void set_typedef_CPP(const char* const name, const char* const active_namespace, const char* filename, const size_t lineno, type_spec&amp; src);	// invalidates src
-	const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* get_typedef(const char* const alias) const;
-	const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* get_typedef_CPP(const char* alias,const char* active_namespace) const;
-
-	void set_enumerator_def(const char* alias, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* src_filename,unsigned char representation,const uchar_blob&amp; src,type_index type);
-	void set_enumerator_def_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* src_filename,unsigned char representation,const uchar_blob&amp; src,type_index type);
-	const enumerator_info* get_enumerator(const char* alias) const;
-	const enumerator_info* get_enumerator_CPP(const char* alias,const char* active_namespace) const;
-
-	type_index register_functype(const char* const alias, function_type*&amp; src);
-	type_index register_functype_CPP(const char* name, const char* active_namespace, function_type*&amp; src);
-//	keyword actually should be type union_struct_decl::keywords, but that increases coupling unacceptably
-	type_index register_structdecl(const char* alias, int keyword);
-	type_index register_structdecl_CPP(const char* name, const char* active_namespace, int keyword);
-	type_index register_C_structdef(const char* alias, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* src_filename, int keyword);
-	type_index register_C_structdef_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* src_filename, int keyword);
-	type_index register_enum_def(const char* alias, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* src_filename);
-	type_index register_enum_def_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* src_filename);
-	const function_type* get_functype(type_index i);
-	const union_struct_decl* get_structdecl(type_index i);
-	const C_union_struct_def* get_C_structdef(type_index i);
-	const enum_def* get_enum_def(type_index i);
-	void upgrade_decl_to_def(type_index i,C_union_struct_def*&amp; src);
 private:
-	type_index _get_id_union(const char* x) const;
-	type_index _get_id_union_CPP(const char* x) const;
-	type_index _get_id_enum(const char* x) const;
-	type_index _get_id_enum_CPP(const char* x) const;
-	type_index _get_id_struct_class(const char* x) const;
-	type_index _get_id_struct_class_CPP(const char* x) const;
-
 	const char* _name(type_index id) const;
-	zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; dealias_inline_namespace_index(const char* alias) const;
-	const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* _get_typedef_CPP(const char* alias) const;
-	const enumerator_info* _get_enumerator_CPP(const char* alias) const;
-
-	bool is_inline_namespace_CPP(const char* active_namespace, size_t active_namespace_len) const;
-	const char* canonical_name_is_inline_namespace_alias_target(const char* name, size_t name_len, const char* active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len) const;
-	const char* construct_canonical_name_and_aliasing_CPP(const char* name, size_t name_len, const char* active_namespace, size_t active_namespace_len);
-
-	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
-	static char* _namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
-	static void _namespace_concatenate(char* buf, const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
 };
 #endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000110.html">[Zcplusplus-commits] r343 - trunk
</A></li>
	<LI>Next message: <A HREF="000112.html">[Zcplusplus-commits] r345 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#111">[ date ]</a>
              <a href="thread.html#111">[ thread ]</a>
              <a href="subject.html#111">[ subject ]</a>
              <a href="author.html#111">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/zcplusplus-commits">More information about the Zcplusplus-commits
mailing list</a><br>
</body></html>
