<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Zcplusplus-commits] r341 - trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/zcplusplus-commits/2010-March/index.html" >
   <LINK REL="made" HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r341%20-%20trunk&In-Reply-To=%3C201003040254.o242sjZo022168%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000103.html">
   <LINK REL="Next"  HREF="000109.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Zcplusplus-commits] r341 - trunk</H1>
    <B>zaimoni at mail.berlios.de</B> 
    <A HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r341%20-%20trunk&In-Reply-To=%3C201003040254.o242sjZo022168%40sheep.berlios.de%3E"
       TITLE="[Zcplusplus-commits] r341 - trunk">zaimoni at mail.berlios.de
       </A><BR>
    <I>Thu Mar  4 03:54:45 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="000103.html">[Zcplusplus-commits] r340 - trunk
</A></li>
        <LI>Next message: <A HREF="000109.html">[Zcplusplus-commits] r342 - in trunk: . tools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#108">[ date ]</a>
              <a href="thread.html#108">[ thread ]</a>
              <a href="subject.html#108">[ subject ]</a>
              <a href="author.html#108">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zaimoni
Date: 2010-03-04 03:54:34 +0100 (Thu, 04 Mar 2010)
New Revision: 341

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.hpp
   trunk/CSupport_pp.cpp
   trunk/CSupport_pp.hpp
Log:
z_cpp object file reduction, pass #1

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-03 21:57:11 UTC (rev 340)
+++ trunk/CSupport.cpp	2010-03-04 02:54:34 UTC (rev 341)
@@ -537,6 +537,7 @@
 	return NULL;
 }
 
+#/*cut-cpp*/
 static const char* C99_echo_reserved_symbol(const char* x,size_t x_len)
 {
 	assert(NULL!=x);
@@ -558,6 +559,7 @@
 	while(0&lt;i);
 	return NULL;
 }
+#/*cut-cpp*/
 
 namespace C_TYPE {
 
@@ -1049,6 +1051,7 @@
 	message_header(src.src_filename,src.logical_line.first);
 }
 
+#/*cut-cpp*/
 /* XXX this may belong with enum_type XXX */
 static void message_header(const enum_def&amp; src)
 {
@@ -1062,6 +1065,7 @@
 	assert(src.filename() &amp;&amp; *src.filename());
 	message_header(src.filename(),src.loc().first);
 }
+#/*cut-cpp*/
 
 // balanced character count
 static POD_pair&lt;size_t,size_t&gt;
@@ -4497,6 +4501,7 @@
 		}
 }
 
+#/*cut-cpp*/
 // returns true if and only if no errors
 static bool _this_vaguely_where_it_could_be_cplusplus(const parse_tree&amp; src)
 {
@@ -4531,6 +4536,7 @@
 	while(0&lt;j);
 	return starting_errors==zcc_errors.err_count();
 }
+#/*cut-cpp*/
 
 // this handles: ( ), [ ], { }
 // the content of ( ), [ ], { } fills the zeroth argument array
@@ -9177,14 +9183,17 @@
 	_label_literals(src,types);
 	std::for_each(src.begin&lt;0&gt;(),src.end&lt;0&gt;(),_label_CPP_literal);	// intercepts: true, false, this
 	if (!_match_pairs(src)) return false;
+#/*cut-cpp*/
 	// check that this is at least within a brace pair or a parentheses pair (it is actually required to be in a non-static member function, or constructor mem-initializer
 	if (!_this_vaguely_where_it_could_be_cplusplus(src)) return false;
+#/*cut-cpp*/	
 	CPP_locate_expressions(src,SIZE_MAX,types);
 	if (starting_errors&lt;zcc_errors.err_count()) return false;
 	while(src.is_raw_list() &amp;&amp; 1==src.size&lt;0&gt;()) src.eval_to_arg&lt;0&gt;(0);
 	return true;
 }
 
+#/*cut-cpp*/
 //! \todo check that the fact all literals are already legal-form is used
 static void C99_ContextFreeParse(parse_tree&amp; src,const type_system&amp; types)
 {
@@ -9196,6 +9205,7 @@
 	// struct/union/enum specifiers can occur in all sorts of strange places
 	C99_notice_struct_union_enum(src);
 }
+#/*cut-cpp*/
 
 bool CPP_ok_for_toplevel_qualified_name(const parse_tree&amp; x)
 {
@@ -9323,6 +9333,7 @@
 		};
 }
 
+#/*cut-cpp*/
 //! \todo check that the fact all literals are already legal-form is used
 static void CPP_ContextFreeParse(parse_tree&amp; src,const type_system&amp; types)
 {
@@ -9337,6 +9348,7 @@
 	// class/struct/union/enum specifiers can occur in all sorts of strange places
 	CPP_notice_class_struct_union_enum(src);
 }
+#/*cut-cpp*/
 
 //! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
 bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
@@ -9947,6 +9959,7 @@
 		}
 }
 
+#/*cut-cpp*/
 static void conserve_tokens(parse_tree&amp; x)
 {
 	if (x.own_index_token&lt;0&gt;())
@@ -9972,6 +9985,7 @@
 			}
 		}
 }
+#/*cut-cpp*/
 
 //! \todo really should be somewhere in natural-language output
 void INFORM_separated_list(const char* const* x,size_t x_len, const char* const sep)
@@ -10345,6 +10359,7 @@
 	return 0;
 }
 
+#/*cut-cpp*/
 static size_t span_to_semicolon(const parse_tree* const first,const parse_tree* const last)
 {
 	assert(first);
@@ -12129,6 +12144,7 @@
 {
 	CPP_ParseNamespace(src,types,NULL);
 }
+#/*cut-cpp*/
 
 PP_auxfunc C99_aux
  = 	{
@@ -12143,12 +12159,14 @@
 	C99_PPHackTree,
 	ConcatenateCStringLiterals,
 	C99_bad_syntax_tokenized,
+#/*cut-cpp*/
 	C99_echo_reserved_keyword,
 	C99_echo_reserved_symbol,
 	C99_ContextFreeParse,
 	C99_ContextParse,
 	C99_locate_expressions,
 	C99_literal_converts_to_bool
+#/*cut-cpp*/
 	};
 
 PP_auxfunc CPlusPlus_aux
@@ -12164,12 +12182,14 @@
 	CPP_PPHackTree,
 	ConcatenateCStringLiterals,
 	CPP_bad_syntax_tokenized,
+#/*cut-cpp*/
 	CPP_echo_reserved_keyword,
 	CPP_echo_reserved_symbol,
 	CPP_ContextFreeParse,
 	CPP_ContextParse,
 	CPP_locate_expressions,
 	CPP_literal_converts_to_bool
+#/*cut-cpp*/
 	};
 
 #if 0

Modified: trunk/CSupport.hpp
===================================================================
--- trunk/CSupport.hpp	2010-03-03 21:57:11 UTC (rev 340)
+++ trunk/CSupport.hpp	2010-03-04 02:54:34 UTC (rev 341)
@@ -115,6 +115,7 @@
 	func_traits&lt;int (*)(const char* src, size_t src_len, const char* src2, size_t src2_len, char*&amp; target)&gt;::function_ref_type EscapedStringConcatenate;
 	// z_cpp 0.0.2
 	func_traits&lt;void (*)(const char* const x, size_t x_len, lex_flags&amp; flags, const char* const src_filename, size_t line_no)&gt;::function_ref_type AddPostLexFlags;
+#/*cut-cpp*/
 	// zcc 0.0.2
 	func_traits&lt;const char* (*)(const char* x,size_t x_len)&gt;::function_ref_type EchoReservedKeyword;
 	func_traits&lt;const char* (*)(const char* x,size_t x_len)&gt;::function_ref_type EchoReservedSymbol;
@@ -123,6 +124,7 @@
 	// zcc 0.0.3
 	func_traits&lt;void (*)(parse_tree&amp;,const size_t,const type_system&amp;)&gt;::function_ref_type LocateExpression;
 	func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type LiteralConvertsToBool;
+#/*cut-cpp*/
 };
 
 }

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-03 21:57:11 UTC (rev 340)
+++ trunk/CSupport_pp.cpp	2010-03-04 02:54:34 UTC (rev 341)
@@ -537,28 +537,7 @@
 	return NULL;
 }
 
-static const char* C99_echo_reserved_symbol(const char* x,size_t x_len)
-{
-	assert(NULL!=x);
-	assert(x_len&lt;=strlen(x));
-	size_t i = C_PREPROC_OP_STRICT_UB;
-	do	if (x_len==valid_pure_preprocessing_op_punc[--i].second &amp;&amp; !strncmp(valid_pure_preprocessing_op_punc[i].first,x,x_len))
-			return valid_pure_preprocessing_op_punc[i].first;
-	while(0&lt;i);
-	return NULL;
-}
 
-static const char* CPP_echo_reserved_symbol(const char* x,size_t x_len)
-{
-	assert(NULL!=x);
-	assert(x_len&lt;=strlen(x));
-	size_t i = CPP_PREPROC_OP_STRICT_UB;
-	do	if (x_len==valid_pure_preprocessing_op_punc[--i].second &amp;&amp; !strncmp(valid_pure_preprocessing_op_punc[i].first,x,x_len))
-			return valid_pure_preprocessing_op_punc[i].first;
-	while(0&lt;i);
-	return NULL;
-}
-
 namespace C_TYPE {
 
 enum hard_type_indexes {
@@ -1049,20 +1028,7 @@
 	message_header(src.src_filename,src.logical_line.first);
 }
 
-/* XXX this may belong with enum_type XXX */
-static void message_header(const enum_def&amp; src)
-{
-	assert(src.filename() &amp;&amp; *src.filename());
-	message_header(src.filename(),src.loc().first);
-}
 
-/* XXX this may belong with C_union_struct_def XXX */
-static void message_header(const C_union_struct_def&amp; src)
-{
-	assert(src.filename() &amp;&amp; *src.filename());
-	message_header(src.filename(),src.loc().first);
-}
-
 // balanced character count
 static POD_pair&lt;size_t,size_t&gt;
 _balanced_character_count(const weak_token* tokenlist,size_t tokenlist_len,const char l_match,const char r_match)
@@ -4497,41 +4463,7 @@
 		}
 }
 
-// returns true if and only if no errors
-static bool _this_vaguely_where_it_could_be_cplusplus(const parse_tree&amp; src)
-{
-	const size_t starting_errors = zcc_errors.err_count();
-	if (robust_token_is_string&lt;4&gt;(src.index_tokens[0].token,&quot;this&quot;))
-		{
-		message_header(src.index_tokens[0]);
-		INC_INFORM(ERR_STR);
-		INFORM(&quot;keyword this is allowed only within a non-static member function body or a constructor memory initializer (C++98 5.1p3)&quot;);
-		zcc_errors.inc_error();
-		};
 
-	size_t j = STATIC_SIZE(src.args);
-	do	{
-		if (0== --j &amp;&amp; NULL!=src.index_tokens[0].token.first &amp;&amp; NULL!=src.index_tokens[1].token.first)
-			{
-			if (token_is_char&lt;'('&gt;(src.index_tokens[0].token) &amp;&amp; token_is_char&lt;')'&gt;(src.index_tokens[1].token)) break;	// need to parse to rule out constructor memory initializer
-			if (token_is_char&lt;'{'&gt;(src.index_tokens[0].token) &amp;&amp; token_is_char&lt;'}'&gt;(src.index_tokens[1].token)) break;	// need to parse to rule out non-static member function
-			}
-		size_t i = src.size(j);
-		while(0&lt;i)
-			{
-			if (robust_token_is_string&lt;4&gt;(src.data(j)[--i].index_tokens[0].token,&quot;this&quot;))
-				{
-				message_header(src.data(j)[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM(&quot;keyword this is allowed only within a non-static member function body or a constructor memory initializer (C++98 5.1p3)&quot;);
-				zcc_errors.inc_error();
-				};
-			}
-		}
-	while(0&lt;j);
-	return starting_errors==zcc_errors.err_count();
-}
-
 // this handles: ( ), [ ], { }
 // the content of ( ), [ ], { } fills the zeroth argument array
 // C++ *sometimes* wants to match &lt; &gt; as well, but its approaches are...painful.  Do that elsewhere
@@ -9177,25 +9109,12 @@
 	_label_literals(src,types);
 	std::for_each(src.begin&lt;0&gt;(),src.end&lt;0&gt;(),_label_CPP_literal);	// intercepts: true, false, this
 	if (!_match_pairs(src)) return false;
-	// check that this is at least within a brace pair or a parentheses pair (it is actually required to be in a non-static member function, or constructor mem-initializer
-	if (!_this_vaguely_where_it_could_be_cplusplus(src)) return false;
 	CPP_locate_expressions(src,SIZE_MAX,types);
 	if (starting_errors&lt;zcc_errors.err_count()) return false;
 	while(src.is_raw_list() &amp;&amp; 1==src.size&lt;0&gt;()) src.eval_to_arg&lt;0&gt;(0);
 	return true;
 }
 
-//! \todo check that the fact all literals are already legal-form is used
-static void C99_ContextFreeParse(parse_tree&amp; src,const type_system&amp; types)
-{
-	assert(src.is_raw_list());
-	_label_literals(src,types);
-	if (!_match_pairs(src)) return;
-	// handle core type specifiers
-	C99_notice_primary_type(src);
-	// struct/union/enum specifiers can occur in all sorts of strange places
-	C99_notice_struct_union_enum(src);
-}
 
 bool CPP_ok_for_toplevel_qualified_name(const parse_tree&amp; x)
 {
@@ -9323,20 +9242,6 @@
 		};
 }
 
-//! \todo check that the fact all literals are already legal-form is used
-static void CPP_ContextFreeParse(parse_tree&amp; src,const type_system&amp; types)
-{
-	assert(src.is_raw_list());
-	_label_literals(src,types);
-	std::for_each(src.begin&lt;0&gt;(),src.end&lt;0&gt;(),_label_CPP_literal);	// intercepts: true, false, this
-	if (!_match_pairs(src)) return;
-	// handle core type specifiers
-	CPP_notice_primary_type(src);
-	// do context-free part of qualified-names
-	CPP_notice_scope_glue(src);
-	// class/struct/union/enum specifiers can occur in all sorts of strange places
-	CPP_notice_class_struct_union_enum(src);
-}
 
 //! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
 bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
@@ -9947,31 +9852,6 @@
 		}
 }
 
-static void conserve_tokens(parse_tree&amp; x)
-{
-	if (x.own_index_token&lt;0&gt;())
-		{
-		const char* const tmp = is_substring_registered(x.index_tokens[0].token.first,x.index_tokens[0].token.second);
-		if (tmp)
-			{
-			assert(tmp!=x.index_tokens[0].token.first);
-			free(const_cast&lt;char*&gt;(x.index_tokens[0].token.first));
-			x.index_tokens[0].token.first = tmp;
-			x.control_index_token&lt;0&gt;(false);
-			}
-		}
-	if (x.own_index_token&lt;1&gt;())
-		{
-		const char* const tmp = is_substring_registered(x.index_tokens[1].token.first,x.index_tokens[1].token.second);
-		if (tmp)
-			{
-			assert(tmp!=x.index_tokens[1].token.first);
-			free(const_cast&lt;char*&gt;(x.index_tokens[1].token.first));
-			x.index_tokens[1].token.first = tmp;
-			x.control_index_token&lt;1&gt;(false);
-			}
-		}
-}
 
 //! \todo really should be somewhere in natural-language output
 void INFORM_separated_list(const char* const* x,size_t x_len, const char* const sep)
@@ -10345,1791 +10225,7 @@
 	return 0;
 }
 
-static size_t span_to_semicolon(const parse_tree* const first,const parse_tree* const last)
-{
-	assert(first);
-	assert(last);
-	const parse_tree* iter = first;
-	while(iter!=last &amp;&amp; !robust_token_is_char&lt;';'&gt;(*iter)) ++iter;
-	return iter-first;
-}
 
-#if 0
-static bool is_identifier_list(const parse_tree&amp; src,func_traits&lt;const char* (*)(const char* x,size_t x_len)&gt;::function_ref_type EchoReservedKeyword)
-{
-	assert(!src.empty());
-	size_t j = src.size&lt;0&gt;();
-	if (!(j%2)) return false;
-	const parse_tree* const x = src.data&lt;0&gt;();
-	assert(x);
-	do	{
-		if (!x[--j].is_atomic()) return false;
-		if (0==j%2)
-			{	// identifier needed
-			if (   C_TESTFLAG_IDENTIFIER!=x[j].index_tokens[0].flags	// must be identifier
-				|| (PARSE_TYPE &amp; x[j].flags) 	// internal representation could land some types here, especially primary types
-				|| EchoReservedKeyword(x[j].index_tokens[0].token.first,x[j].index_tokens[0].token.second))	// keywords are only lexically identifiers, they'll cause problems
-				return false;
-			}
-		else{	// comma needed
-			if (!token_is_char&lt;','&gt;(x[j].index_tokens[0].token))
-				return false;
-			}
-		}
-	while(0&lt;j);
-	return true;
-}
-#endif
-
-static void C99_CPP_handle_static_assertion(parse_tree&amp; src,type_system&amp; types,PP_auxfunc&amp; langinfo,const size_t i,const char* const err)
-{
-	assert(err &amp;&amp; *err);
-	// find the next ';'
-	const size_t j = i+span_to_semicolon(src.data&lt;0&gt;()+i,src.end&lt;0&gt;());
-	if (src.size&lt;0&gt;()&lt;=j)
-		{	//! \test zcc/staticassert.C99/Error_scope1.h, zcc/staticassert.C99/Error_scope1.hpp
-			//! \test zcc/staticassert.C99/Error_scope2.h, zcc/staticassert.C99/Error_scope2.hpp
-		message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-		INC_INFORM(ERR_STR);
-		INFORM(&quot;static assertion cut off by end of scope&quot;);
-		zcc_errors.inc_error();
-		src.DeleteNSlotsAt&lt;0&gt;(j-i,i);
-		return;
-		};
-	if (   !is_naked_parentheses_pair(src.data&lt;0&gt;()[i+1])
-		|| 3&gt;src.data&lt;0&gt;()[i+1].size&lt;0&gt;()
-		|| !robust_token_is_char&lt;','&gt;(src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-2])
-		|| !src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].is_atomic()
-		|| C_TESTFLAG_STRING_LITERAL!=src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].flags)
-		{	//! \test zcc/staticassert.C99/Error_badarg1.h, zcc/staticassert.C99/Error_badarg1.hpp
-			//! \test zcc/staticassert.C99/Error_badarg2.h, zcc/staticassert.C99/Error_badarg2.hpp
-			//! \test zcc/staticassert.C99/Error_badarg3.h, zcc/staticassert.C99/Error_badarg3.hpp
-			//! \test zcc/staticassert.C99/Error_badarg5.h, zcc/staticassert.C99/Error_badarg5.hpp
-			//! \test zcc/staticassert.C99/Error_badarg6.h, zcc/staticassert.C99/Error_badarg6.hpp
-			//! \test zcc/staticassert.C99/Error_badarg7.h, zcc/staticassert.C99/Error_badarg7.hpp
-		message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-		INC_INFORM(ERR_STR);
-		INFORM(&quot;malformed static assertion&quot;);
-		zcc_errors.inc_error();
-		src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
-		return;
-		};
-	if (2!=j-i)
-		{	//! \test zcc/staticassert.C99/Error_badarg4.h, zcc/staticassert.C99/Error_badarg4.hpp
-		message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-		INC_INFORM(ERR_STR);
-		INFORM(&quot;garbage between static assertion arguments and terminating ;&quot;);
-		zcc_errors.inc_error();
-		src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
-		return;
-		};
-	// actually use the static assertion correctly.
-	parse_tree_class parsetree;
-	{
-	const size_t k = src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-2;
-	if (!parsetree.resize&lt;0&gt;(k))
-		{
-		message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-		INC_INFORM(ERR_STR);
-		_fatal(&quot;insufficient RAM to parse static assertion&quot;);
-		};
-	zaimoni::autotransform_n&lt;void (*)(parse_tree&amp;,const parse_tree&amp;)&gt;(parsetree.c_array&lt;0&gt;(),src.data&lt;0&gt;()[i+1].data&lt;0&gt;(),k,value_copy);
-	}
-	// init above correctly
-	// snip from Condense
-	const size_t starting_errors = zcc_errors.err_count();
-	(langinfo.LocateExpression)(parsetree,SIZE_MAX,types);
-	if (starting_errors==zcc_errors.err_count())
-		{
-		while(parsetree.is_raw_list() &amp;&amp; 1==parsetree.size&lt;0&gt;()) parsetree.eval_to_arg&lt;0&gt;(0);
-		// end snip from Condense
-		// snip from CPreproc
-		if (!parsetree.is_atomic() &amp;&amp; !(langinfo.EvalParseTree)(parsetree,types))
-			{
-			parsetree.destroy();	// efficiency
-			message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM(err);
-			zcc_errors.inc_error();
-			src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
-			return;
-			}
-		(langinfo.PPHackTree)(parsetree,types);
-		// final, when above is working properly
-		if (!parsetree.is_atomic())
-			{	//! \bug need test cases
-			parsetree.destroy();	// efficiency
-			message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM(err);
-			zcc_errors.inc_error();
-			src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
-			return;
-			}
-		// end snip from CPreproc
-		bool is_true = false;
-		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true))
-			{	//! \bug need test cases
-			parsetree.destroy();	// efficiency
-			message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM(err);
-			zcc_errors.inc_error();
-			src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
-			return;
-			};
-		parsetree.destroy();	// efficiency
-		//! \test zcc/staticassert.C1X/Pass_autosucceed.h, zcc/staticassert.C1X/Pass_autosucceed.hpp
-		if (!is_true)
-			{	//! \test zcc/staticassert.C1X/Error_autofail.h, zcc/staticassert.C1X/Error_autofail.hpp
-			message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			// hmm...really should unescape string before emitting
-			const size_t tmp_size = LengthOfCStringLiteral(src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].token.first,src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].token.second);
-			if (1U&gt;=tmp_size || 'L'== *src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].token.first)
-				{	//! \todo handle wide-strings later
-				INFORM(&quot;(static assertion failure)&quot;);
-				zcc_errors.inc_error();
-				src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
-				return;
-				};
-
-			char* tmp = _new_buffer&lt;char&gt;(tmp_size);
-			if (NULL==tmp)
-				{
-				INFORM(&quot;(static assertion failure)&quot;);
-				zcc_errors.inc_error();
-				src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
-				return;
-				}
-			UnescapeCString(tmp,src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].token.first+1,src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].token.second-2);
-			INFORM(tmp);
-			free(tmp);
-			zcc_errors.inc_error();
-			src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
-			return;
-			};
-		}
-	src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
-}
-
-static bool default_enumerator_init_legal(const bool allow_empty, unsigned char&amp; current_enumerator_type, const unsigned_var_int&amp; prior_value, const weak_token&amp; src)
-{
-	if (allow_empty)
-		{	// C++
-		//! \todo research how to rewrite this without the goto
-cpp_enum_was_retyped:
-		const promote_aux test(current_enumerator_type);
-		//! \bug need -Wc-c++-compat to go off here
-		if (test.is_signed)
-			{
-			if (prior_value==target_machine-&gt;signed_max(test.machine_type))
-				{
-				++current_enumerator_type;	// smallest type that can handle this
-				goto cpp_enum_was_retyped;
-				}
-			}
-		else{
-			if (prior_value==target_machine-&gt;unsigned_max(test.machine_type))
-				{
-				if (C_TYPE::INTEGERLIKE == ++current_enumerator_type)	// smallest type that can handle this
-					{	// unsigned long long overflow, fact it's defined doesn't save us
-					//! \test decl.C99/Error_enum_overflow.hpp
-					message_header(src);
-					INC_INFORM(ERR_STR);
-					INFORM(&quot;default-initialization of enumerator requires uintmax_t overflow (C++0X 7.2p5)&quot;);
-					zcc_errors.inc_error();
-					return false;
-					}
-				goto cpp_enum_was_retyped;
-				}
-			}
-		}
-	else{	// C
-		if (prior_value==target_machine-&gt;signed_max&lt;virtual_machine::std_int_int&gt;())
-			{	// signed integer overflow
-				//! \test decl.C99/Error_enum_overflow.h
-			message_header(src);
-			INC_INFORM(ERR_STR);
-			INFORM(&quot;default-initialization of enumerator requires signed int overflow (C99 6.7.2.2p3)&quot;);
-			zcc_errors.inc_error();
-			return false;
-			}
-		}
-	return true;
-}
-
-static bool record_enum_values(parse_tree&amp; src, type_system&amp; types, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits&lt;const char* (*)(const char*, size_t)&gt;::function_ref_type echo_reserved_keyword, func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM, func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type CondenseParseTree, func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree)
-{
-	assert(enum_type_index);
-	assert(!active_namespace || *active_namespace);
-	assert(is_naked_brace_pair(src));
-	// enumeration idea:
-	// * identifer [= ...] ,
-	// terminal , is optional (and in fact should trigger a warning for -Wbackport)
-	// empty collection of enumerators is fine for C++, rejected by C (should be error in C and -Wc-c++-compat for C++)
-	// XXX use allow_empty to signal C vs. C++ language
-	// values would be unsigned_var_int
-	if (src.empty&lt;0&gt;())
-		{
-		if (!allow_empty)
-			{	//! \test zcc/decl.C99/Error_enum_empty.h
-			message_header(src.index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM(&quot;enumeration has no enumerators (C99 6.7.2.2p1)&quot;);
-			zcc_errors.inc_error();
-			return false;
-			}
-		else if (bool_options[boolopt::warn_crosslang_compatibility])
-			{	//! \test zcc/compat/Warn_enum_empty.hpp
-			message_header(src.index_tokens[0]);
-			INC_INFORM(WARN_STR);
-			INFORM(&quot;enumeration with no enumerators is an error in C90/C99/C1X&quot;);
-			if (bool_options[boolopt::warnings_are_errors])
-				{
-				zcc_errors.inc_error();
-				return false;
-				}
-			}
-		//! \test zcc/decl.C99/Pass_enum_empty.hpp
-		return true;
-		};
-	// determine if format generally there
-	// stage 1: top-level comma check
-	// * terminal comma is optional, zap it and warn if -Wbackport
-	// * one more enumerator possible than surviving commas; use this to construct buffers
-	size_t i = 0;
-	while(src.size&lt;0&gt;()&gt;i)
-		{	// require identifier that is neither keyword nor a primitive type
-			// C++ will have problems with enum/struct/class/union names, verify status of both of these (could be -Wc-c++-compat issue if legal in C)
-			// if identifier, verify next is = or ,
-			// if next is =, locate comma afterwards (do not do expression parsing yet)
-			//! \todo: enforce One Definition Rule for C++ vs types; determine how much of the effect is in C as well
-		if (   !src.data&lt;0&gt;()[i].is_atomic()
-			||  C_TESTFLAG_IDENTIFIER!=src.data&lt;0&gt;()[i].index_tokens[0].flags
-			|| (PARSE_TYPE &amp; src.data&lt;0&gt;()[i].flags)
-			|| echo_reserved_keyword(src.data&lt;0&gt;()[i].index_tokens[0].token.first,src.data&lt;0&gt;()[i].index_tokens[0].token.second))
-			{	//! \test zcc/decl.C99/Error_enum_brace.h, zcc/decl.C99/Error_enum_brace.hpp
-				//! \test zcc/decl.C99/Error_enum_symbol.h, zcc/decl.C99/Error_enum_symbol.hpp
-				//! \test zcc/decl.C99/Error_enum_type.h, zcc/decl.C99/Error_enum_type.hpp
-				//! \test zcc/decl.C99/Error_enum_keyword.h, zcc/decl.C99/Error_enum_keyword.hpp
-			message_header(0==i ? src.index_tokens[0] : src.data&lt;0&gt;()[i-i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM(&quot;non-keyword identifier expected as enumerator (C99 6.4.4.3p1/C++0X 7.2p1)&quot;);
-			zcc_errors.inc_error();
-			return false;
-			}
-		if (1&gt;=src.size&lt;0&gt;()-i) break;	// fine, would default-update
-		if (robust_token_is_char&lt;','&gt;(src.data&lt;0&gt;()[i+1]))
-			{	// would default-update
-			i += 2;
-			continue;
-			};
-		if (!robust_token_is_char&lt;'='&gt;(src.data&lt;0&gt;()[i+1]))
-			{	//! \test zcc/decl.C99/Error_enum_no_init.h, zcc/decl.C99/Error_enum_no_init.hpp
-			message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM(&quot;enumerator neither explicitly initialized nor default-initialized (C99 6.4.4.3p1/C++0X 7.2p1)&quot;);
-			zcc_errors.inc_error();
-			return false;
-			};
-		i += 2;
-		if (src.size&lt;0&gt;()&lt;=i || robust_token_is_char&lt;','&gt;(src.data&lt;0&gt;()[i]))
-			{	//! \test zcc/decl.C99/Error_enum_init_truncated.h, zcc/decl.C99/Error_enum_init_truncated.hpp
-			message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM(&quot;enumerator initializer cut off by , (C99 6.4.4.3p1/C++0X 7.2p1)&quot;);
-			zcc_errors.inc_error();
-			return false;
-			};
-		while(++i &lt; src.size&lt;0&gt;())
-			{
-			if (robust_token_is_char&lt;','&gt;(src.data&lt;0&gt;()[i]))
-				{
-				++i;
-				break;
-				}
-			};
-		}
-	if (robust_token_is_char&lt;','&gt;(src.back&lt;0&gt;()))
-		{	// warn for -Wbackport
-			//! \test zcc/decl.C99/Pass_enum_trailing_comma.h, zcc/decl.C99/Pass_enum_trailing_comma.hpp
-			//! \test zcc/backport/Warn_enum_trailing_comma.h, zcc/backport/Warn_enum_trailing_comma.hpp
-		if (bool_options[boolopt::warn_backport])
-			{
-			message_header(src.back&lt;0&gt;().index_tokens[0]);
-			INC_INFORM(WARN_STR);
-			INFORM(&quot;trailing , in enumeration definition would be an error in C90/C++98&quot;);
-			if (bool_options[boolopt::warnings_are_errors])
-				{
-				zcc_errors.inc_error();
-				return false;
-				}
-			}
-		src.DeleteIdx&lt;0&gt;(src.size&lt;0&gt;()-1); // clean up anyway
-		}
-	//! \todo actually record enumerator matchings
-	unsigned_var_int latest_value(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
-	unsigned_var_int prior_value(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
-	unsigned char current_enumerator_type = C_TYPE::INT;
-//	bool cpp_using_negative = false;
-//	bool cpp_using_above_LLONG_MAX = false;
-	i = 0;
-	while(src.size&lt;0&gt;()&gt;i)
-		{	// require identifier that is neither keyword nor a primitive type
-			// C++ will have problems with enum/struct/class/union names, verify status of both of these (could be -Wc-c++-compat issue if legal in C)
-			// if identifier, verify next is = or ,
-			// if next is =, locate comma afterwards (do not do expression parsing yet)
-			//! \todo: enforce One Definition Rule for C++ vs types; determine how much of the effect is in C as well
-		assert(src.data&lt;0&gt;()[i].is_atomic());
-		assert(C_TESTFLAG_IDENTIFIER==src.data&lt;0&gt;()[i].index_tokens[0].flags);
-		assert(!(PARSE_TYPE &amp; src.data&lt;0&gt;()[i].flags));
-		assert(!echo_reserved_keyword(src.data&lt;0&gt;()[i].index_tokens[0].token.first,src.data&lt;0&gt;()[i].index_tokens[0].token.second));
-		{
-		char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[0].token.first,active_namespace,&quot;::&quot;) : NULL;
-		const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[0].token.first;
-		{
-		const type_system::enumerator_info* tmp = types.get_enumerator(fullname);
-		if (tmp)
-			{	// --do-what-i-mean could recover if the prior definition were identical
-				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined
-				// C++: One Definition Rule wipes out
-				//! \test decl.C99/Error_enum_multidef.h, decl.C99/Error_enum_multidef.hpp 
-			message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM(&quot;enumerator is already defined (C99 6.7.2.2p3/C++98 3.2)&quot;);
-			zcc_errors.inc_error();
-			free(namespace_name);
-			return false;
-			};
-		}
-		free(namespace_name);
-		}
-#if 0
-		// next proposed function call is a bit handwavish right now...
-		// C++0X 3.3.1p4: enumerator gets to hide class names and enum names, nothing else [in particular dies against typedefs and functions]
-		if (types.enum_already_defined(active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].token.first))
-			{	// -Wbackport warn in C++, fail in C
-			if (allow_empty)
-				{	// C++0X
-				if (bool_options[boolopt::warn_crosslang_compatibility] || bool_options[boolopt::warn_backport])
-					{
-					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM(&quot;enum with same name as enumerator is already defined (C99 6.7.2.2p3/C++98 3.2/C++0X 3.2)&quot;);
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					}
-			else{	// C
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM(&quot;enum with same name as enumerator is already defined (C99 6.7.2.2p3)&quot;);
-				zcc_errors.inc_error();
-				return false;
-				}	
-			};
-		if (types.union_class_struct_already_declared(active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].token.first))
-			{	// -Wbackport warn in C++, fail in C
-			if (allow_empty)
-				{	// C++0X
-				if (bool_options[boolopt::warn_crosslang_compatibility] || bool_options[boolopt::warn_backport])
-					{
-					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM(&quot;union, struct, or class with same name as enumerator is already defined (C99 6.7.2.2p3/C++98 3.2/C++0X 3.2)&quot;);
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					}
-				}
-			else{	// C
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM(&quot;union or struct with same name as enumerator is already defined (C99 6.7.2.2p3)&quot;);
-				zcc_errors.inc_error();
-				return false;
-				}	
-			};
-		if (types.function_already_declared(active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].token.first))
-			{	// C++: One Definition Rule
-			};
-#endif
-		{
-		const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* const tmp = types.get_typedef_CPP(src.data&lt;0&gt;()[i].index_tokens[0].token.first,active_namespace); 
-		if (tmp)
-			{	// C++: One Definition Rule
-				//! \test decl.C99/Error_enum_typedef.h, decl.C99/Error_enum_typedef.hpp 
-			message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM(&quot;typedef is already defined, conflicts with enumerator (C99 6.7.2.2p3/C++98 3.2)&quot;);
-			INC_INFORM(tmp-&gt;second);
-			INC_INFORM(&quot;:&quot;);
-			INC_INFORM(tmp-&gt;third);
-			INFORM(&quot;: typedef definition here&quot;);
-			zcc_errors.inc_error();
-			return false;
-			};
-		}
-
-		// The type and representation of an enumeration varies by language
-		// C: values are type int; actual representation can be decided after seeing all enumeration values.
-		// C++: if the underlying type is fixed, then the enumerator is of that type.  Othewise,
-		// each enumerator has the same type as its initializing expression, and the underlying type of
-		// the enumeration is large enough to represent all values.
-		// So, for the default-update cases
-		// C: type int, hard-error if going above INT_MAX
-		// C++: type per language specification,
-		// * hard-error if going above ULONG_MAX
-		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
-		// in any case, do not react if the default-init isn't used
-		value_copy(prior_value,latest_value);
-		bool value_is_nonnegative_or_twos_complement = true;
-		if (virtual_machine::twos_complement!=target_machine-&gt;C_signed_int_representation())
-			{
-			const promote_aux test(current_enumerator_type);
-			if (test.is_signed &amp;&amp; latest_value.test(test.bitcount-1))
-				{
-				target_machine-&gt;signed_additive_inverse(latest_value,test.machine_type);
-				if (0&lt;latest_value)
-					{
-					latest_value -= 1;
-					if (0&lt;latest_value) target_machine-&gt;signed_additive_inverse(latest_value,test.machine_type);
-					value_is_nonnegative_or_twos_complement = false;
-					}
-				}
-			}
-		if (value_is_nonnegative_or_twos_complement) latest_value += 1;
-
-		if (1&gt;=src.size&lt;0&gt;()-i)
-			{	// default-update
-			// handle type errors
-			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data&lt;0&gt;()[i].index_tokens[0]))
-				return false;
-			uchar_blob latest_value_copy;
-			latest_value_copy.init(0);
-			value_copy(latest_value_copy,latest_value);
-			if (active_namespace)
-				types.set_enumerator_def_CPP(src.data&lt;0&gt;()[i].index_tokens[0].token.first, active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
-			else
-				types.set_enumerator_def(src.data&lt;0&gt;()[i].index_tokens[0].token.first,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
-			break;
-			}
-		// complete conversion
-		// C: type int, hard-error if not within INT_MIN..INT_MAX
-		// C++: type per language specification
-		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
-		if (robust_token_is_char&lt;','&gt;(src.data&lt;0&gt;()[i+1]))
-			{	// would default-update
-			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data&lt;0&gt;()[i].index_tokens[0]))
-				return false;
-			uchar_blob latest_value_copy;
-			latest_value_copy.init(0);
-			value_copy(latest_value_copy,latest_value);
-			if (active_namespace)
-				types.set_enumerator_def_CPP(src.data&lt;0&gt;()[i].index_tokens[0].token.first, active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
-			else
-				types.set_enumerator_def(src.data&lt;0&gt;()[i].index_tokens[0].token.first,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
-			i += 2;
-			continue;
-			};
-		assert(robust_token_is_char&lt;'='&gt;(src.data&lt;0&gt;()[i+1]));
-		i += 2;
-		const size_t origin = i;
-		assert(src.size&lt;0&gt;()&gt;i &amp;&amp; !robust_token_is_char&lt;','&gt;(src.data&lt;0&gt;()[i]));
-		bool comma_overextended = false;
-		while(++i &lt; src.size&lt;0&gt;())
-			{
-			if (robust_token_is_char&lt;','&gt;(src.data&lt;0&gt;()[i]))
-				{
-				++i;
-				comma_overextended = true;
-				break;
-				}
-			};
-		{	// see if it's a compile-time constant
-		parse_tree_class tmp(src,origin,i-comma_overextended,0);
-		if (tmp.is_raw_list() &amp;&amp; !CondenseParseTree(tmp,types)) return false;
-		if (!EvalParseTree(tmp,types)) return false;
-		if (!intlike_literal_to_VM(latest_value,tmp))
-			{	//! \bug need test case
-			message_header(src.data&lt;0&gt;()[origin-2].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM(&quot;enumerator can only be explicitly initialized by a compile-time constant (C99 6.7.2.2p3/C++98 7.2p1)&quot;);
-			zcc_errors.inc_error();
-			return false;
-			}
-		// range checks
-		if (allow_empty)
-			{	// C++
-			current_enumerator_type = tmp.type_code.base_type_index;
-			}
-		else{	// C
-			const promote_aux test(tmp.type_code.base_type_index);
-			const promote_aux dest_type(C_TYPE::INT);
-			const bool is_negative = test.is_signed &amp;&amp; latest_value.test(test.bitcount-1);
-			if (is_negative)
-				target_machine-&gt;signed_additive_inverse(latest_value,test.machine_type);
-			bool out_of_range = latest_value&gt;target_machine-&gt;signed_max&lt;virtual_machine::std_int_int&gt;();
-			if (out_of_range &amp;&amp; is_negative &amp;&amp; virtual_machine::twos_complement==target_machine-&gt;C_signed_int_representation())
-				{	// handle two's complement INT_MIN
-				latest_value -= 1;
-				if (latest_value&lt;=target_machine-&gt;signed_max&lt;virtual_machine::std_int_int&gt;()) 
-					out_of_range = false;
-				latest_value += 1;
-				}
-			if (out_of_range)
-				{	//! \test decl.C99/Error_enum_overflow2.h
-					//! \bug need -Wc-c++-compat to go off here
-				message_header(src.data&lt;0&gt;()[origin-2].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM(&quot;initializer of enumerator not representable as signed int (C99 6.7.2.2p3)&quot;);
-				zcc_errors.inc_error();
-				return false;
-				}
-			if (is_negative)
-				target_machine-&gt;signed_additive_inverse(latest_value,dest_type.machine_type);
-			tmp.type_code.base_type_index = C_TYPE::INT;
-			}
-#if 0
-		if (origin+1&lt;i-comma_overextended)
-			{	// net token reduction, do source code optimization?
-			}
-#endif
-		}
-
-		{	// actually register the enumerator
-		uchar_blob latest_value_copy;
-		latest_value_copy.init(0);
-		value_copy(latest_value_copy,latest_value);
-		if (active_namespace)
-			types.set_enumerator_def_CPP(src.data&lt;0&gt;()[origin-2].index_tokens[0].token.first, active_namespace,src.data&lt;0&gt;()[origin-2].index_tokens[0].logical_line,src.data&lt;0&gt;()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
-		else
-			types.set_enumerator_def(src.data&lt;0&gt;()[origin-2].index_tokens[0].token.first,src.data&lt;0&gt;()[origin-2].index_tokens[0].logical_line,src.data&lt;0&gt;()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
-		}
-		}
-	// now ok to crunch underlying type/machine representation
-	return true;
-}
-
-// will need: &quot;function-type vector&quot;
-// return: 1 typespec record (for now, other languages may have more demanding requirements)
-// incoming: n typespec records, flag for trailing ...
-// will need: typedef map: identifier |-&gt; typespec record
-//! \todo check that the fact all literals are already legal-form is used
-static void C99_ContextParse(parse_tree&amp; src,type_system&amp; types)
-{
-	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle in type_spec, which is required to be POD to allow C memory management:
-	// * indirection depth n (already have this in practice)
-	// * const, volatile at each level of indirection 0..n
-	// * extent at each level of indirection 1..n (0 := raw-ptr, positive := array that can be bounds-checked for undefined behavior
-	// * top-level reference (check standards to see if reference-in-middle is illegal, never seen it in real source)
-	// * C99: restrict qualifier at each level of indirection 1..n (this is *not* in C++0x as of April 8 2009!)
-	// * storage-qualifiers extern, static, register, auto
-	// * fake type-qualifier typedef
-	// Exploit uintptr_t to mitigate dynamic memory management.
-	// * union of uintptr_t,unsigned char[sizeof(uintptr_t)] is probably best way to handle the qualifier-vector
-	// * extent-vector will be painful: properly should be a CPUInfo-controlled type.  Can get away with uintmax_t for now.  (size_t won't work because we're
-	//   a cross-compiler; target size_t could be larger than host size_t.  size_t does work for string literals since we have to represent those on the host.)
-	// note that typedefs and struct/union declarations/definitions create new types; if this happens we are no longer context-free (so second pass with context-based parsing)
-	// ask GCC: struct/class/union/enum collides with each other (both C and C++), does not collide with namespace
-	// think we can handle this as &quot;disallow conflicting definitions&quot;
-	size_t i = 0;
-	while(i&lt;src.size&lt;0&gt;())
-		{
-		conserve_tokens(src.c_array&lt;0&gt;()[i]);
-		// C static assertion scanner
-		if (robust_token_is_string&lt;14&gt;(src.data&lt;0&gt;()[i],&quot;_Static_Assert&quot;))
-			{	// _Static_Assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CLexer-&gt;pp_support,i,&quot; : control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)&quot;);
-			continue;
-			};
-		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
-		// check naked declarations first
-		if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
-			{
-			type_system::type_index tmp = types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
-			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
-			}
-		else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
-			{
-			type_system::type_index tmp = types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
-			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
-			}
-		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;union&quot;))
-			{	// can only define once
-			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-			if (tmp)
-				{	//! \test zcc/decl.C99/Error_union_multidef.h
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM(&quot;'union &quot;);
-				INC_INFORM(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].token.second);
-				INFORM(&quot;' already defined (C99 6.7.2.3p1)&quot;);
-				message_header(*tmp);
-				INFORM(&quot;prior definition here&quot;);
-				zcc_errors.inc_error();
-				// now it's gone
-				// remove trailing semicolon if present
-				src.DeleteNSlotsAt&lt;0&gt;((1&lt;src.size&lt;0&gt;()-i &amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1])) ? 2 : 1,i);
-				continue;
-				}
-			}
-		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;struct&quot;))
-			{	// can only define once
-			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-			if (tmp)
-				{	//! \test zcc/decl.C99/Error_struct_multidef.h
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM(&quot;'struct &quot;);
-				INC_INFORM(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].token.second);
-				INFORM(&quot;' already defined (C99 6.7.2.3p1)&quot;);
-				message_header(*tmp);
-				INFORM(&quot;prior definition here&quot;);
-				zcc_errors.inc_error();
-				// now it's gone
-				// remove trailing semicolon if present
-				src.DeleteNSlotsAt&lt;0&gt;((1&lt;src.size&lt;0&gt;()-i &amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1])) ? 2 : 1,i);
-				continue;
-				}
-			}
-		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
-		else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;))
-			{	// C99 6.7.2.3: allowed only after name is defined
-			if (!(src.c_array&lt;0&gt;()[i].flags &amp; parse_tree::INVALID))
-				{
-				type_system::type_index tmp = types.get_id_enum(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
-				src.c_array&lt;0&gt;()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
-				if (!tmp)
-					{	//! \test zcc\decl.C99\Error_enum_undef.h
-					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM(&quot;'enum &quot;);
-					INC_INFORM(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].token.second);
-					INFORM(&quot;' must refer to completely defined enum (C99 6.7.2.3p2)&quot;);
-					zcc_errors.inc_error();
-					src.c_array&lt;0&gt;()[i].flags |= parse_tree::INVALID;
-					}
-				}
-			}
-		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;enum&quot;))
-			{	// can only define once
-			const type_system::type_index tmp = types.get_id_enum(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
-			if (tmp)
-				{	//! \test zcc\decl.C99\Error_enum_multidef.h
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM(&quot;'enum &quot;);
-				INC_INFORM(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].token.second);
-				INFORM(&quot;' already defined (C99 6.7.2.3p1)&quot;);
-				const enum_def* const tmp2 = types.get_enum_def(tmp);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM(&quot;prior definition here&quot;);
-				zcc_errors.inc_error();
-				// now it's gone
-				src.DeleteNSlotsAt&lt;0&gt;(1,i);
-				continue;
-				};
-			// enum-specifier doesn't have a specific declaration mode
-			//! \test zcc\decl.C99\Pass_enum_def.h
-			const type_system::type_index tmp2 = types.register_enum_def(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
-			assert(types.get_id_enum(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
-				{
-				INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
-				return;
-				}
-			}
-		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;))
-			{	// enum-specifier doesn't have a specific declaration mode
-				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = types.register_enum_def(&quot;&lt;unknown&gt;&quot;,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
-				{
-				INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
-				return;
-				}
-			}
-
-		if (	1&lt;src.size&lt;0&gt;()-i
-			&amp;&amp; 	robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
-			{	// is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;) will cause an error later, in variable parsing
-			if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_union.h
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM(&quot;unreferenceable anonymous union declaration&quot;);
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt&lt;0&gt;(2,i);
-				continue;
-				}
-			else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_struct.h
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM(&quot;unreferenceable anonymous struct declaration&quot;);
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt&lt;0&gt;(2,i);
-				continue;
-				}
-			else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
-				{	// forward-declare, fine
-				if (types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first))
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_union_forward_def.h
-					// remove from parse
-					src.DeleteNSlotsAt&lt;0&gt;(2,i);
-					continue;					
-					}
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_union_forward_def.h
-				const type_system::type_index tmp2 = types.register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
-				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
-				{	// forward-declare, fine
-				if (types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first))
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_struct_forward_def.h
-					// remove from parse
-					src.DeleteNSlotsAt&lt;0&gt;(2,i);
-					continue;					
-					}
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				const type_system::type_index tmp2 = types.register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
-				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;union&quot;))
-				{	// definitions...fine
-				const type_system::type_index tmp = types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
-				C_union_struct_def* tmp2 = NULL;
-				if (tmp)
-					{	// promoting forward-declare to definition
-						//! \test zcc/decl.C99/Pass_union_forward_def.h
-					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-					assert(tmp3);
-					tmp2 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
-					//! \todo record field structure, etc.
-					types.upgrade_decl_to_def(tmp,tmp2);
-					assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp);
-					assert(types.get_C_structdef(tmp));
-					}
-				else{	// definition
-						//! \test zcc/decl.C99/Pass_union_def.h
-					//! \todo record field structure, etc.
-					const type_system::type_index tmp3 = types.register_C_structdef(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename,union_struct_decl::decl_union);
-					assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-					assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp3);
-					assert(types.get_C_structdef(tmp3));
-					src.c_array&lt;0&gt;()[i].type_code.set_type(tmp3);
-					}
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;struct&quot;))
-				{	// definitions...fine
-				const type_system::type_index tmp = types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
-				C_union_struct_def* tmp2 = NULL;
-				if (tmp)
-					{	// promoting forward-declare to definition
-						//! \test zcc/decl.C99/Pass_struct_forward_def.h
-					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-					assert(tmp3);
-					tmp2 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
-					//! \todo record field structure, etc.
-					types.upgrade_decl_to_def(tmp,tmp2);
-					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp);
-					assert(types.get_C_structdef(tmp));
-					}
-				else{	// definition
-						//! \test zcc/decl.C99/Pass_struct_def.h
-					//! \todo record field structure, etc.
-					const type_system::type_index tmp3 = types.register_C_structdef(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename,union_struct_decl::decl_struct);
-					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp3);
-					assert(types.get_C_structdef(tmp3));
-					src.c_array&lt;0&gt;()[i].type_code.set_type(tmp3);
-					}
-				i += 2;
-				continue;
-				};
-			};
-		// general declaration scanner 
-		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
-		// intercept declarations as follows
-		// * storage-class specifiers
-		// ** C: extern static auto register
-		// ** C: taking address of a register-qualified var is an error; not so for C++ (just downgrades register to auto implicitly)
-		// * typedef (pretty much a fake storage-class specifier)
-		// * function specifiers
-		// ** C: inline
-		// * cv-qualification
-		// ** C: const volatile restrict (but pointer type required for restrict)
-		// * atomic types have already been parsed, we need to catch the others
-		{
-		C99_decl_specifier_scanner declFind(types);
-		size_t decl_count = src.get_span&lt;0&gt;(i,declFind);
-		if (decl_count)
-			{
-			const bool coherent_storage_specifiers = declFind.analyze_flags_global(src,i,decl_count);
-			if (src.size&lt;0&gt;()-i&lt;=decl_count)
-				{	// unterminated declaration
-					//! \test zcc/decl.C99/Error_extern_scope.h
-					//! \test zcc/decl.C99/Error_static_scope.h
-					//! \test zcc/decl.C99/Error_typedef_scope.h
-					//! \test zcc/decl.C99/Error_register_scope.h
-					//! \test zcc/decl.C99/Error_auto_scope.h
-				if (src.size&lt;0&gt;()&gt;i) message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM(&quot;declaration cut off by end of scope (C99 6.7p1)&quot;);
-				zcc_errors.inc_error();
-				// remove from parse
-				if (src.size&lt;0&gt;()&gt;i)
-					src.DeleteNSlotsAt&lt;0&gt;(decl_count,i);
-				return;
-				};
-			if (robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+decl_count]))
-				{	// C99 7p2 error: must declare something
-					//! \test zcc/decl.C99/Error_extern_semicolon.h
-					//! \test zcc/decl.C99/Error_static_semicolon.h
-					//! \test zcc/decl.C99/Error_typedef_semicolon.h
-					//! \test zcc/decl.C99/Error_register_semicolon.h
-					//! \test zcc/decl.C99/Error_auto_semicolon.h
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM(&quot;declaration must declare something (C99 6.7p2)&quot;);
-				zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt&lt;0&gt;(decl_count+1,i);
-				continue;
-				};
-			declFind.fixup_type();	// apply const, volatile
-
-			size_t decl_offset = 0;
-			bool have_we_parsed_yet = false;
-			do	{
-				type_spec bootstrap;
-				bootstrap.clear();
-				declFind.value_copy_type(bootstrap);
-				size_t initdecl_identifier_idx = 0;
-				size_t initdecl_span = C99_init_declarator_scanner(src,i+decl_count+decl_offset,bootstrap,initdecl_identifier_idx);
-				assert(0&lt;initdecl_span || 0==initdecl_identifier_idx);
-				if (0==initdecl_span)
-					{	// no declarator where expected
-						// a botched function-declarator will have non-zero length
-					message_header(src.data&lt;0&gt;()[i+decl_count+decl_offset].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM(&quot;declarator missing (C99 6.7p1)&quot;);
-					zcc_errors.inc_error();
-					// find the next semicolon
-					const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data&lt;0&gt;()+i+decl_count+decl_offset,src.end&lt;0&gt;());
-					if (have_we_parsed_yet)
-						src.DeleteNSlotsAt&lt;0&gt;(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
-					else
-						src.DeleteNSlotsAt&lt;0&gt;((j-i)+(src.size&lt;0&gt;()&gt;j),i);
-					break;
-					};
-				if (!initdecl_identifier_idx)
-					{	// didn't find identifier when needed
-					message_header(src.data&lt;0&gt;()[i+decl_count+decl_offset].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM(&quot;declarator has no identifier to declare (C99 6.7p1)&quot;);
-					zcc_errors.inc_error();
-					// find the next semicolon, unless we have () immediately in which case we have nothing to look for
-					const bool unwind_to_compound_statement = is_naked_parentheses_pair(src.data&lt;0&gt;()[i+decl_count+decl_offset]);
-					if (unwind_to_compound_statement)
-						{
-						assert(!have_we_parsed_yet);
-						src.DeleteNSlotsAt&lt;0&gt;(decl_count+decl_offset+initdecl_span,i);
-						}
-					else{
-						const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data&lt;0&gt;()+i+decl_count+decl_offset,src.end&lt;0&gt;());
-						if (have_we_parsed_yet)
-							src.DeleteNSlotsAt&lt;0&gt;(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
-						else
-							src.DeleteNSlotsAt&lt;0&gt;((j-i)+1,i);
-						}
-					break;
-					};
-				//! \todo analyze decl_specifiers for errors (now have full target type)
-				// something is being declared
-				have_we_parsed_yet = true;
-				if (coherent_storage_specifiers)
-					{
-					if (C99_CPP0X_DECLSPEC_TYPEDEF &amp; declFind.get_flags())
-						{	// typedef
-						register_token&lt;0&gt;(src.c_array&lt;0&gt;()[initdecl_identifier_idx]);
-						// verify that there is no prior definition
-						const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp = types.get_typedef(src.data&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0].token.first);
-						if (NULL!=tmp)
-							{
-							if (bootstrap==tmp-&gt;first)
-								{	// warn if there is a prior, consistent definition
-									//! \test zcc/decl.C99/Warn_redeclare_typedef.h
-									//! \todo control this warning with an option --no-OAOO or --no-DRY
-								message_header(src.data&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0]);
-								INC_INFORM(WARN_STR);
-								INC_INFORM(&quot;redeclaring typedef &quot;);
-								INFORM(src.data&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0].token.first);
-								INC_INFORM(tmp-&gt;second);
-								INC_INFORM(':');
-								INC_INFORM(tmp-&gt;third);
-								INFORM(&quot;: prior typedef&quot;);
-								if (bool_options[boolopt::warnings_are_errors])
-									zcc_errors.inc_error();
-								}
-							else{	// error if there is a prior, inconsistent definition
-									//! \test zcc/decl.C99/Warn_redeclare_typedef.h
-								message_header(src.data&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0]);
-								INC_INFORM(ERR_STR);
-								INC_INFORM(&quot;redeclaring typedef &quot;);
-								INFORM(src.data&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0].token.first);
-								INC_INFORM(tmp-&gt;second);
-								INC_INFORM(':');
-								INC_INFORM(tmp-&gt;third);
-								INFORM(&quot;: prior typedef&quot;);
-								zcc_errors.inc_error();
-								}	
-							// do not re-register if there is a prior definition
-							}
-						else{	// prepare to register this with types object
-							const type_system::enumerator_info* tmp2 = types.get_enumerator(src.data&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0].token.first);
-							if (tmp2)
-								{	//! \bug needs test case
-								message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-								INC_INFORM(ERR_STR);
-//								INFORM(&quot;enumerator is already defined, conflicts with typedef (C99 6.7.2.2p3/C++98 3.2)&quot;);
-								INFORM(&quot;enumerator is already defined, conflicts with typedef (C99 6.7.2.2p3)&quot;);
-								INC_INFORM(tmp2-&gt;second.second.first);
-								INC_INFORM(&quot;:&quot;);
-								INC_INFORM(tmp2-&gt;second.second.second.first);
-								INFORM(&quot;: enumerator definition here&quot;);
-								zcc_errors.inc_error();
-								return;
-								}
-							types.set_typedef(src.data&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0].token.first,src.data&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0].src_filename,src.data&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0].logical_line.first,bootstrap);
-							}
-						}
-#if 0
-					else{	// something else
-						};
-#endif
-					}
-				decl_offset += initdecl_span;
-				if (src.size&lt;0&gt;()-(i+decl_count)&lt;=decl_offset)
-					{	// unterminated declaration: error
-						//! \test zcc/decl.C99/Error_scope.h
-					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM(&quot;declaration cut off by end of scope (C99 6.7p1)&quot;);
-					zcc_errors.inc_error();
-					return;
-					};
-				//! \todo function declarations can be self-terminating
-				// ;: done
-				if (robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+decl_count+decl_offset]))
-					{
-					src.c_array&lt;0&gt;()[i+decl_count+decl_offset].flags |= parse_tree::GOOD_LINE_BREAK;
-					++decl_offset;
-					break;
-					};
-				// ,: iterate
-				// anything else: error
-				if (!robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+decl_count+decl_offset]))
-					{
-					message_header(src.data&lt;0&gt;()[i+decl_count+decl_offset].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM(&quot;declaration disoriented by missing , (C99 6.7p1)&quot;);
-					// find the next semicolon
-					size_t j = i+decl_count+decl_offset;
-					while(!robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[j]) &amp;&amp; src.size&lt;0&gt;()&gt; ++j);
-					src.DeleteNSlotsAt&lt;0&gt;(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
-					continue;
-					}
-				++decl_offset;
-				}
-			while(src.size&lt;0&gt;()&gt;(i+decl_count+decl_offset));
-			i += decl_count+decl_offset;
-			continue;
-			}
-		}
-		++i;
-		}
-}
-
-#ifndef NDEBUG
-static bool is_CPP_namespace(const parse_tree&amp; src)
-{
-	return		robust_token_is_string&lt;9&gt;(src.index_tokens[0].token,&quot;namespace&quot;)
-			&amp;&amp;	2==src.size&lt;2&gt;()
-			&amp;&amp;	src.data&lt;2&gt;()[0].is_atomic()
-#ifndef NDEBUG
-			&amp;&amp;	C_TESTFLAG_IDENTIFIER==src.data&lt;2&gt;()[0].index_tokens[0].flags
-#endif
-			&amp;&amp;	robust_token_is_char&lt;'{'&gt;(src.data&lt;2&gt;()[1].index_tokens[0].token)
-			&amp;&amp;	robust_token_is_char&lt;'}'&gt;(src.data&lt;2&gt;()[1].index_tokens[1].token);
-}
-#endif
-
-// handle namespaces or else
-//! \todo check that the fact all literals are already legal-form is used
-static void CPP_ParseNamespace(parse_tree&amp; src,type_system&amp; types,const char* const active_namespace)
-{
-	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle
-	// * indirection depth n (already have this in practice)
-	// * const, volatile at each level of indirection 0..n
-	// * extent at each level of indirection 1..n (0 := raw-ptr, positive := array that can be bounds-checked for undefined behavior
-	// * top-level reference (check standards to see if reference-in-middle is illegal, never seen it in real source)
-	// * storage-qualifiers extern, static, register, mutable, thread_local
-	// * fake type-qualifier typedef
-	// note that typedefs and struct/union declarations/definitions create new types
-	// C++: note that class declarations/definitions create new types
-	// note that we need a sense of &quot;current namespace&quot; in C++
-	// ask GCC: struct/class/union/enum collides with each other (both C and C++), does not collide with namespace
-	// think we can handle this as &quot;disallow conflicting definitions&quot;
-	// should be able to disable this warning (it's about bloat)
-	if (src.empty&lt;0&gt;())
-		{	//! \test zcc\namespace.CPP\Warn_emptybody1.hpp
-			//! \test zcc\namespace.CPP\Warn_emptybody2.hpp
-			//! \todo -Wno-bloat turns off 
-		message_header(src.index_tokens[0]);
-		INC_INFORM(WARN_STR);
-		INFORM(&quot;namespace contains no declarations&quot;);
-		if (bool_options[boolopt::warnings_are_errors])
-			zcc_errors.inc_error();
-		return;
-		}
-
-	size_t i = 0;
-	while(i&lt;src.size&lt;0&gt;())
-		{
-		conserve_tokens(src.c_array&lt;0&gt;()[i]);
-		// C++ static assertion scanner
-		if (robust_token_is_string&lt;13&gt;(src.data&lt;0&gt;()[i],&quot;static_assert&quot;))
-			{	// static_assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CPlusPlusLexer-&gt;pp_support,i,&quot; : control expression for static assertion must be a constant convertible to bool (C++0X 7p4)&quot;);
-			continue;
-			};
-		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
-		// check naked declarations first; handle namespaces later
-		//! \bug indentation fixup needed (stage 3)
-		if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
-			{
-			type_system::type_index tmp = types.get_id_union_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
-			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
-			}
-		else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
-			{
-			type_system::type_index tmp = types.get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
-			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
-			}
-		else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;class&quot;))
-			{
-			type_system::type_index tmp = types.get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
-			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
-			}
-		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;union&quot;))
-			{	// can only define once
-			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-			const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_union(fullname));
-			if (tmp)
-				{	//! \test zcc/decl.C99/Error_union_multidef.hpp
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM(&quot;'union &quot;);
-				INC_INFORM(fullname);
-				free(namespace_name);
-				INFORM(&quot;' already defined (C++98 3.2p1)&quot;);
-				message_header(*tmp);
-				INFORM(&quot;prior definition here&quot;);
-				zcc_errors.inc_error();
-				// now it's gone
-				// remove trailing semicolon if present
-				src.DeleteNSlotsAt&lt;0&gt;((1&lt;src.size&lt;0&gt;()-i &amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1])) ? 2 : 1,i);
-				continue;
-				}
-			free(namespace_name);
-			}
-		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;struct&quot;))
-			{	// can only define once
-			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-			const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(fullname));
-			if (tmp)
-				{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM(&quot;'struct &quot;);
-				INC_INFORM(fullname);
-				free(namespace_name);
-				INFORM(&quot;' already defined (C++98 3.2p1)&quot;);
-				message_header(*tmp);
-				INFORM(&quot;prior definition here&quot;);
-				zcc_errors.inc_error();
-				// now it's gone
-				// remove trailing semicolon if present
-				src.DeleteNSlotsAt&lt;0&gt;((1&lt;src.size&lt;0&gt;()-i &amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1])) ? 2 : 1,i);
-				continue;
-				}
-			free(namespace_name);
-			}
-		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;class&quot;))
-			{	// can only define once
-			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-			const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(fullname));
-			if (tmp)
-				{	//! \test zcc/decl.C99/Error_class_multidef.hpp
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM(&quot;'class &quot;);
-				INC_INFORM(fullname);
-				free(namespace_name);
-				INFORM(&quot;' already defined (C++98 3.2p1)&quot;);
-				message_header(*tmp);
-				INFORM(&quot;prior definition here&quot;);
-				zcc_errors.inc_error();
-				// now it's gone
-				// remove trailing semicolon if present
-				src.DeleteNSlotsAt&lt;0&gt;((1&lt;src.size&lt;0&gt;()-i &amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1])) ? 2 : 1,i);
-				continue;
-				}
-			free(namespace_name);
-			}
-		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
-		//! \todo actually, we can try forward-declare both scoped enums and enum-based enums (C++0X 7.2p3, these have enough size information); but other parts of the standard get in the way
-		else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;))
-			{
-			if (!(src.c_array&lt;0&gt;()[i].flags &amp; parse_tree::INVALID))
-				{
-				type_system::type_index tmp = types.get_id_enum_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
-				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);	// C++: enums are own type
-				if (!tmp)
-					{	// this belongs elsewhere
-						//! \test zcc\decl.C99\Error_enum_undef.hpp
-					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM(&quot;'enum &quot;);
-					INC_INFORM(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].token.second);
-					INFORM(&quot;' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)&quot;);
-					zcc_errors.inc_error();
-					src.c_array&lt;0&gt;()[i].flags |= parse_tree::INVALID;
-					}
-				}
-			//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
-			}
-		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;enum&quot;))
-			{	// can only define once
-			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-			const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-			type_system::type_index tmp = types.get_id_enum(fullname);
-			if (tmp)
-				{	//! \test zcc\decl.C99\Error_enum_multidef.hpp
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM(&quot;'enum &quot;);
-				INC_INFORM(fullname);
-				free(namespace_name);
-				INFORM(&quot;' already defined (C++98 3.2p1)&quot;);
-				const enum_def* const tmp2 = types.get_enum_def(tmp);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM(&quot;prior definition here&quot;);
-				zcc_errors.inc_error();
-				// now it's gone
-				src.DeleteNSlotsAt&lt;0&gt;(1,i);
-				continue;
-				};
-			free(namespace_name);
-			//! \test zcc\decl.C99\Pass_enum_def.hpp
-			// enum-specifier doesn't have a specific declaration mode
-			const type_system::type_index tmp2 = types.register_enum_def_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
-			assert(types.get_id_enum_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,tmp2,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
-				{
-				INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
-				return;
-				}
-			}
-		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;))
-			{	// enum-specifier doesn't have a specific declaration mode
-				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = types.register_enum_def_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
-				{
-				INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
-				return;
-				}
-			}
-
-		if (	1&lt;src.size&lt;0&gt;()-i
-			&amp;&amp; 	robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
-			{	// is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;) will cause an error later, in variable parsing
-			if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM(&quot;unreferenceable anonymous union declaration&quot;);
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt&lt;0&gt;(2,i);
-				continue;
-				}
-			else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM(&quot;unreferenceable anonymous struct declaration&quot;);
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt&lt;0&gt;(2,i);
-				continue;
-				}
-			else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;class&quot;))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM(&quot;unreferenceable anonymous class declaration&quot;);
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt&lt;0&gt;(2,i);
-				continue;
-				}
-			else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
-				{	// forward-declare, fine
-				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-				const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-				if (types.get_id_union(fullname))
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-					// remove from parse
-					free(namespace_name);
-					src.DeleteNSlotsAt&lt;0&gt;(2,i);
-					continue;					
-					}
-				free(namespace_name);
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				//! \todo fix up fully-qualified name
-				const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
-				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
-				{	// forward-declare, fine
-				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-				const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-				if (types.get_id_struct_class(fullname))
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-					// remove from parse
-					free(namespace_name);
-					src.DeleteNSlotsAt&lt;0&gt;(2,i);
-					continue;					
-					}
-				free(namespace_name);
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				//! \todo fix up fully-qualified name
-				const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
-				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;class&quot;))
-				{	// forward-declare, fine
-				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-				const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-				if (types.get_id_struct_class(fullname))
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-					// remove from parse
-					free(namespace_name);
-					src.DeleteNSlotsAt&lt;0&gt;(2,i);
-					continue;					
-					}
-				free(namespace_name);
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				//! \todo fix up fully-qualified name
-				const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
-				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;union&quot;))
-				{	// definitions...fine
-				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-				const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-				const type_system::type_index tmp = types.get_id_union(fullname);
-				free(namespace_name);
-				C_union_struct_def* tmp2 = NULL;
-				if (tmp)
-					{	// promoting forward-declare to definition
-						//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-					assert(tmp3);
-					tmp2 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
-					//! \todo record field structure, etc.
-					types.upgrade_decl_to_def(tmp,tmp2);
-					assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp);
-					assert(types.get_C_structdef(tmp));
-					}
-				else{	// definition
-						//! \test zcc/decl.C99/Pass_union_def.hpp
-					//! \todo record field structure, etc.
-					const type_system::type_index tmp3 = types.register_C_structdef(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename,union_struct_decl::decl_union);
-					assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-					assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp3);
-					assert(types.get_C_structdef(tmp3));
-					src.c_array&lt;0&gt;()[i].type_code.set_type(tmp3);
-					}
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;struct&quot;))
-				{	// definitions...fine
-				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-				const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-				const type_system::type_index tmp = types.get_id_struct_class(fullname);
-				free(namespace_name);
-				C_union_struct_def* tmp2 = NULL;
-				if (tmp)
-					{	// promoting forward-declare to definition
-						//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-					assert(tmp3);
-					tmp2 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
-					//! \todo record field structure, etc.
-					types.upgrade_decl_to_def(tmp,tmp2);
-					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp);
-					assert(types.get_C_structdef(tmp));
-					}
-				else{	// definition
-						//! \test zcc/decl.C99/Pass_struct_def.hpp
-					//! \todo record field structure, etc.
-					const type_system::type_index tmp3 = types.register_C_structdef(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename,union_struct_decl::decl_struct);
-					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp3);
-					assert(types.get_C_structdef(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)));
-					src.c_array&lt;0&gt;()[i].type_code.set_type(tmp3);
-					}
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;class&quot;))
-				{	// definitions...fine
-				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-				const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-				const type_system::type_index tmp = types.get_id_struct_class(fullname);
-				free(namespace_name);
-				C_union_struct_def* tmp2 = NULL;
-				if (tmp)
-					{	// promoting forward-declare to definition
-						//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-					assert(tmp3);
-					tmp2 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
-					//! \todo record field structure, etc.
-					types.upgrade_decl_to_def(tmp,tmp2);
-					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp);
-					assert(types.get_C_structdef(tmp));
-					}
-				else{	// definition
-						//! \test zcc/decl.C99/Pass_class_def.hpp
-					//! \todo record field structure, etc.
-					const type_system::type_index tmp3 = types.register_C_structdef(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename,union_struct_decl::decl_class);
-					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp3);
-					assert(types.get_C_structdef(tmp3));
-					src.c_array&lt;0&gt;()[i].type_code.set_type(tmp3);
-					}
-				i += 2;
-				continue;
-				};
-			};
-		// namespace scanner
-		// need some scheme to handle unnamed namespaces (probably alphabetical counter after something illegal so unmatchable)
-		// C++0X has inline namespaces; ignore these for now (well, maybe not: consuming the inline will prevent problems)
-		// C++0X has more complicated using namespace directives: ignore these for now
-		// basic namespace; C++98 and C++0X agree on what this is
-		if (robust_token_is_string&lt;9&gt;(src.data&lt;0&gt;()[i],&quot;namespace&quot;))
-			{	// fail if: end of token stream
-				// fail if: next token is a type
-				// accept if: next token is {} (unnamed namespace)
-				// accept if: next token is an identifier, and the token after that is {} (typical namespace)
-				// fail otherwise
-			if (1&gt;=src.size&lt;0&gt;()-i)
-				{	//! \test zcc\namespace.CPP\Error_premature1.hpp
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM(&quot;namespace declaration cut off by end of scope&quot;);
-				zcc_errors.inc_error();
-				src.DeleteIdx&lt;0&gt;(i);
-				break;
-				};
-			if (	robust_token_is_char&lt;'{'&gt;(src.data&lt;0&gt;()[i+1].index_tokens[0].token)
-				&amp;&amp;	robust_token_is_char&lt;'}'&gt;(src.data&lt;0&gt;()[i+1].index_tokens[1].token))
-				{	//! handle unnamed namespace
-					//! \test zcc\namespace.CPP\Warn_emptybody2.hpp
-					// regardless of official linkage, entities in anonymous namespaces aren't very accessible outside of the current translation unit;
-					// any reasonable linker thinks they have static linkage
-				src.c_array&lt;0&gt;()[i].resize&lt;2&gt;(2);
-				src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[1] = src.data&lt;0&gt;()[i+1];
-				src.c_array&lt;0&gt;()[i+1].clear();
-				src.DeleteIdx&lt;0&gt;(i+1);
-
-				// anonymous namespace names are technically illegal
-				// GCC uses &lt;unknown&gt; and handles uniqueness at link time
-				src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0].grab_index_token_from_str_literal&lt;0&gt;(&quot;&lt;unknown&gt;&quot;,C_TESTFLAG_IDENTIFIER);	// pretend it's an identifier
-				src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0].grab_index_token_location_from&lt;0,0&gt;(src.data&lt;0&gt;()[i].data&lt;2&gt;()[1]);	// inject it at where the namespace body starts
-				src.c_array&lt;0&gt;()[i].flags |= parse_tree::GOOD_LINE_BREAK;
-				assert(is_CPP_namespace(src.data&lt;0&gt;()[i]));
-
-				if (active_namespace)
-					{
-					char* new_active_namespace = _new_buffer_nonNULL_throws&lt;char&gt;(ZAIMONI_LEN_WITH_NULL(strlen(active_namespace)+11 /*sizeof(&quot;::&lt;unknown&gt;&quot;)-1*/));
-					strcpy(new_active_namespace,active_namespace);
-					strcat(new_active_namespace,&quot;::&lt;unknown&gt;&quot;);
-					strcat(new_active_namespace,&quot;&quot;);
-					CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[1],types,new_active_namespace);
-					free(new_active_namespace);
-					}
-				else{
-					CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[1],types,&quot;&lt;unknown&gt;&quot;);
-					}
-				++i;
-				continue;
-				}
-			const bool namespace_has_body = (	3&lt;=src.size&lt;0&gt;()-i
-											&amp;&amp;	robust_token_is_char&lt;'{'&gt;(src.data&lt;0&gt;()[i+2].index_tokens[0].token)
-											&amp;&amp;	robust_token_is_char&lt;'}'&gt;(src.data&lt;0&gt;()[i+2].index_tokens[1].token));
-			// next token must be an atomic identifier
-			// already-parsed primary types are no good, neither are reserved keywords
-			if (	!src.data&lt;0&gt;()[i+1].is_atomic()
-				|| 	!(C_TESTFLAG_IDENTIFIER &amp; src.data&lt;0&gt;()[i+1].index_tokens[0].flags)
-				||	(PARSE_TYPE &amp; src.data&lt;0&gt;()[i+1].flags)
-				||	CPP_echo_reserved_keyword(src.data&lt;0&gt;()[i+1].index_tokens[0].token.first,src.data&lt;0&gt;()[i+1].index_tokens[0].token.second))
-				{	//! \test zcc/namespace.CPP/Error_badname1.hpp
-					//! \test zcc/namespace.CPP/Error_badname2.hpp
-					//! \test zcc/namespace.CPP/Error_badname3.hpp
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM(&quot;named namespace declaration must use non-reserved identifier (C++98 7.3.1p1, 7.3.2p1)&quot;);
-				zcc_errors.inc_error();
-				src.DeleteNSlotsAt&lt;0&gt;(2+namespace_has_body,i);
-				continue;
-				};
-			if (!namespace_has_body)
-				{	//! \test zcc\namespace.CPP\Error_premature2.hpp
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM(&quot;'namespace &quot;);
-				INC_INFORM(src.data&lt;0&gt;()[i+1]);
-				INFORM(&quot;' definition needs a body (C++98 7.3.1p1)&quot;);
-				zcc_errors.inc_error();
-				src.DeleteNSlotsAt&lt;0&gt;(2,i);
-				continue;
-				};
-			//! \test zcc\namespace.CPP\Warn_emptybody1.hpp
-			// process namespace
-			// namespace name: postfix arg 1
-			// namespace definition body: postfix arg 2
-			// the namespace name is likely to be reused: atomic string target
-			register_token&lt;0&gt;(src.c_array&lt;0&gt;()[i+1]);
-			src.c_array&lt;0&gt;()[i].resize&lt;2&gt;(2);
-			src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0] = src.data&lt;0&gt;()[i+1];
-			src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[1] = src.data&lt;0&gt;()[i+2];
-			src.c_array&lt;0&gt;()[i+1].clear();
-			src.c_array&lt;0&gt;()[i+2].clear();
-			src.DeleteNSlotsAt&lt;0&gt;(2,i+1);
-			src.c_array&lt;0&gt;()[i].flags |= parse_tree::GOOD_LINE_BREAK;
-			assert(is_CPP_namespace(src.data&lt;0&gt;()[i]));
-			// handle named namespace
-			if (NULL==active_namespace)
-				{	// global
-					//! \todo expand namespace aliases
-				CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[1],types,src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0].index_tokens[0].token.first);
-				}
-			else{	// nested
-					//! \todo expand namespace aliases
-				char* const new_active_namespace = type_system::namespace_concatenate(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0].index_tokens[0].token.first,active_namespace,&quot;::&quot;);
-				CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[1],types,new_active_namespace);
-				free(new_active_namespace);
-				}
-			++i;
-			continue;
-			};
-		// C++0X also has inline namespaces; all anonymous namespaces are already inline
-		// general declaration scanner (have to catch C++0X inline namespaces first when those come up)
-		// ideally would cope with both C++98 and C++0X
-		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
-		// intercept declarations as follows
-		// * storage-class specifiers
-		// ** C++98: auto register static extern mutable [class-data only]
-		// ** C++0x: register static thread_local extern mutable [class-data only]
-		// ** C: taking address of a register-qualified var is an error; not so for C++ (just downgrades register to auto implicitly)
-		// * typedef (pretty much a fake storage-class specifier)
-		// * C++0X: constexpr
-		// * function specifiers
-		// ** C++: inline virtual [nonstatic class-member-function only] explicit [constructors only]
-		// * C++: friend (inside class declaration only)
-		// * cv-qualification
-		// ** C++: const volatile
-		// * atomic types have already been parsed, we need to catch the others
-		// * C++0x: auto is a possible type!
-		{
-		CPP0X_decl_specifier_scanner declFind(types,active_namespace);
-		size_t decl_count = src.destructive_get_span&lt;0&gt;(i,declFind);
-		if (decl_count)
-			{
-			const bool coherent_storage_specifiers = declFind.analyze_flags_global(src,i,decl_count);
-			if (src.size&lt;0&gt;()-i&lt;=decl_count)
-				{	// unterminated declaration
-					//! \test zcc/decl.C99/Error_extern_scope.hpp
-					//! \test zcc/decl.C99/Error_static_scope.hpp
-					//! \test zcc/decl.C99/Error_typedef_scope.hpp
-					//! \test zcc/decl.C99/Error_register_scope.hpp
-					//! \test zcc/decl.C99/Error_mutable_scope.hpp
-					//! \test zcc/decl.C99/Error_virtual_scope.hpp
-					//! \test zcc/decl.C99/Error_friend_scope.hpp
-					//! \test zcc/decl.C99/Error_explicit_scope.hpp
-				if (src.size&lt;0&gt;()&gt;i) message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM(&quot;declaration cut off by end of scope (C++98 7p1)&quot;);
-				zcc_errors.inc_error();
-				// remove from parse
-				if (src.size&lt;0&gt;()&gt;i)
-					src.DeleteNSlotsAt&lt;0&gt;(decl_count,i);
-				return;
-				};
-			if (robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+decl_count]))
-				{	// must declare something
-					//! \test zcc/decl.C99/Error_extern_semicolon.hpp
-					//! \test zcc/decl.C99/Error_static_semicolon.hpp
-					//! \test zcc/decl.C99/Error_typedef_semicolon.hpp
-					//! \test zcc/decl.C99/Error_register_semicolon.hpp
-					//! \test zcc/decl.C99/Error_mutable_semicolon.hpp
-					//! \test zcc/decl.C99/Error_virtual_semicolon.hpp
-					//! \test zcc/decl.C99/Error_friend_semicolon.hpp
-					//! \test zcc/decl.C99/Error_explicit_semicolon.hpp
-				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM(&quot;declaration must declare something (C++98 7p4)&quot;);
-				zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt&lt;0&gt;(decl_count+1,i);
-				continue;
-				};
-			declFind.fixup_type();	// apply const, volatile
-
-			size_t decl_offset = 0;
-			bool have_we_parsed_yet = false;
-			do	{
-				type_spec bootstrap;
-				bootstrap.clear();
-				declFind.value_copy_type(bootstrap);
-				size_t initdecl_identifier_idx = 0;
-				size_t initdecl_span = CPP_init_declarator_scanner(src,i+decl_count+decl_offset,bootstrap,initdecl_identifier_idx);
-				assert(0&lt;initdecl_span || 0==initdecl_identifier_idx);
-				if (0==initdecl_span)
-					{	// no declarator where expected
-						// a botched function-declarator will have non-zero length
-					message_header(src.data&lt;0&gt;()[i+decl_count+decl_offset].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM(&quot;declarator missing (C++98 7p1)&quot;);
-					zcc_errors.inc_error();
-					// find the next semicolon
-					const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data&lt;0&gt;()+i+decl_count+decl_offset,src.end&lt;0&gt;());
-					if (have_we_parsed_yet)
-						src.DeleteNSlotsAt&lt;0&gt;(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
-					else
-						src.DeleteNSlotsAt&lt;0&gt;((j-i)+(src.size&lt;0&gt;()&gt;j),i);
-					break;
-					};
-				if (!initdecl_identifier_idx)
-					{	// didn't find identifier when needed
-					message_header(src.data&lt;0&gt;()[i+decl_count+decl_offset].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM(&quot;declarator has no name to declare (C++98 7p1)&quot;);
-					zcc_errors.inc_error();
-					// find the next semicolon, unless we have () immediately in which case we have nothing to look for
-					const bool unwind_to_compound_statement = is_naked_parentheses_pair(src.data&lt;0&gt;()[i+decl_count+decl_offset]);
-					if (unwind_to_compound_statement)
-						{
-						assert(!have_we_parsed_yet);
-						src.DeleteNSlotsAt&lt;0&gt;(decl_count+decl_offset+initdecl_span,i);
-						}
-					else{
-						const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data&lt;0&gt;()+i+decl_count+decl_offset,src.end&lt;0&gt;());
-						if (have_we_parsed_yet)
-							src.DeleteNSlotsAt&lt;0&gt;(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
-						else
-							src.DeleteNSlotsAt&lt;0&gt;((j-i)+1,i);
-						}
-					break;
-					};
-				//! \todo analyze decl_specifiers for errors (now have full target type)
-				// something is being declared
-				have_we_parsed_yet = true;
-				if (coherent_storage_specifiers)
-					{
-					if (C99_CPP0X_DECLSPEC_TYPEDEF &amp; declFind.get_flags())
-						{	// typedef
-						register_token&lt;0&gt;(src.c_array&lt;0&gt;()[initdecl_identifier_idx]);
-						char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.c_array&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0].token.first,active_namespace,&quot;::&quot;) : NULL;
-						const char* fullname = namespace_name ? namespace_name : src.c_array&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0].token.first;
-						// We could run an is_string_registered check to try to conserve RAM, but in this case conserving RAM 
-						// doesn't actually reduce maximum RAM loading before the types.set_typedef_CPP call.
-
-						// verify that there is no prior definition
-						// we're fine redeclaring at a different level, so do not use full C++ typedef lookup
-						const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp = types.get_typedef(fullname);					
-						if (NULL!=tmp)
-							{
-							if (bootstrap==tmp-&gt;first)
-								{	// warn if there is a prior, consistent definition
-									//! \test zcc/decl.C99/Warn_redeclare_typedef.hpp
-									//! \todo control this warning with an option --no-OAOO or --no-DRY
-								message_header(src.data&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0]);
-								INC_INFORM(WARN_STR);
-								INC_INFORM(&quot;redeclaring typedef &quot;);
-								INFORM(fullname);
-								INC_INFORM(tmp-&gt;second);
-								INC_INFORM(':');
-								INC_INFORM(tmp-&gt;third);
-								INFORM(&quot;: prior typedef&quot;);
-								if (bool_options[boolopt::warnings_are_errors])
-									zcc_errors.inc_error();
-								}
-							else{	// error if there is a prior, inconsistent definition
-									//! \test zcc/decl.C99/Error_redeclare_typedef.hpp
-								message_header(src.data&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0]);
-								INC_INFORM(ERR_STR);
-								INC_INFORM(&quot;redeclaring typedef &quot;);
-								INFORM(fullname);
-								INC_INFORM(tmp-&gt;second);
-								INC_INFORM(':');
-								INC_INFORM(tmp-&gt;third);
-								INFORM(&quot;: prior typedef&quot;);
-								zcc_errors.inc_error();
-								}
-							// do not re-register if there is a prior definition
-							free(namespace_name);
-							}
-						else{	// register this with types object
-							free(namespace_name);
-							const type_system::enumerator_info* tmp2 = types.get_enumerator_CPP(src.data&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0].token.first,active_namespace);
-							if (tmp2)
-								{	//! \bug needs test case
-								message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-								INC_INFORM(ERR_STR);
-								INFORM(&quot;enumerator is already defined, conflicts with typedef (C++98 3.2)&quot;);
-								INC_INFORM(tmp2-&gt;second.second.first);
-								INC_INFORM(&quot;:&quot;);
-								INC_INFORM(tmp2-&gt;second.second.second.first);
-								INFORM(&quot;: enumerator definition here&quot;);
-								zcc_errors.inc_error();
-								return;
-								}							
-							types.set_typedef_CPP(src.c_array&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0].token.first,active_namespace,src.data&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0].src_filename,src.data&lt;0&gt;()[initdecl_identifier_idx].index_tokens[0].logical_line.first,bootstrap);
-							}
-						}
-#if 0
-					else{	// something else
-						};
-#endif
-					};
-				decl_offset += initdecl_span;
-				if (src.size&lt;0&gt;()-(i+decl_count)&lt;=decl_offset)
-					{	// unterminated declaration: error
-						//! \test zcc/decl.C99/Error_scope.hpp
-					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM(&quot;declaration cut off by end of scope (C++98 7p1)&quot;);
-					zcc_errors.inc_error();
-					return;
-					};
-				//! \todo function declarations can be self-terminating
-				// ;: done
-				if (robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+decl_count+decl_offset]))
-					{
-					src.c_array&lt;0&gt;()[i+decl_count+decl_offset].flags |= parse_tree::GOOD_LINE_BREAK;
-					++decl_offset;
-					break;
-					};
-				// ,: iterate
-				// anything else: error
-				if (!robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+decl_count+decl_offset]))
-					{
-					message_header(src.data&lt;0&gt;()[i+decl_count+decl_offset].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM(&quot;declaration disoriented by missing , (C++98 7p1)&quot;);
-					// find the next semicolon
-					const size_t span = span_to_semicolon(src.begin&lt;0&gt;()+(i+decl_count+decl_offset),src.end&lt;0&gt;());
-					src.DeleteNSlotsAt&lt;0&gt;(span,i+decl_count+decl_offset);
-					continue;
-					}
-				++decl_offset;
-				}
-			while(src.size&lt;0&gt;()&gt;(i+decl_count+decl_offset));
-			i += decl_count+decl_offset;
-			continue;
-			}
-		}
-		++i;
-		}
-}
-
-static void CPP_ContextParse(parse_tree&amp; src,type_system&amp; types)
-{
-	CPP_ParseNamespace(src,types,NULL);
-}
-
 PP_auxfunc C99_aux
  = 	{
 	LengthOfCSystemHeader,
@@ -12143,12 +10239,6 @@
 	C99_PPHackTree,
 	ConcatenateCStringLiterals,
 	C99_bad_syntax_tokenized,
-	C99_echo_reserved_keyword,
-	C99_echo_reserved_symbol,
-	C99_ContextFreeParse,
-	C99_ContextParse,
-	C99_locate_expressions,
-	C99_literal_converts_to_bool
 	};
 
 PP_auxfunc CPlusPlus_aux
@@ -12164,12 +10254,6 @@
 	CPP_PPHackTree,
 	ConcatenateCStringLiterals,
 	CPP_bad_syntax_tokenized,
-	CPP_echo_reserved_keyword,
-	CPP_echo_reserved_symbol,
-	CPP_ContextFreeParse,
-	CPP_ContextParse,
-	CPP_locate_expressions,
-	CPP_literal_converts_to_bool
 	};
 
 #if 0

Modified: trunk/CSupport_pp.hpp
===================================================================
--- trunk/CSupport_pp.hpp	2010-03-03 21:57:11 UTC (rev 340)
+++ trunk/CSupport_pp.hpp	2010-03-04 02:54:34 UTC (rev 341)
@@ -115,14 +115,6 @@
 	func_traits&lt;int (*)(const char* src, size_t src_len, const char* src2, size_t src2_len, char*&amp; target)&gt;::function_ref_type EscapedStringConcatenate;
 	// z_cpp 0.0.2
 	func_traits&lt;void (*)(const char* const x, size_t x_len, lex_flags&amp; flags, const char* const src_filename, size_t line_no)&gt;::function_ref_type AddPostLexFlags;
-	// zcc 0.0.2
-	func_traits&lt;const char* (*)(const char* x,size_t x_len)&gt;::function_ref_type EchoReservedKeyword;
-	func_traits&lt;const char* (*)(const char* x,size_t x_len)&gt;::function_ref_type EchoReservedSymbol;
-	func_traits&lt;void (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type ContextFreeParse;		// return true iff no errors
-	func_traits&lt;void (*)(parse_tree&amp;,type_system&amp;)&gt;::function_ref_type ContextParse;		// return true iff no errors
-	// zcc 0.0.3
-	func_traits&lt;void (*)(parse_tree&amp;,const size_t,const type_system&amp;)&gt;::function_ref_type LocateExpression;
-	func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type LiteralConvertsToBool;
 };
 
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000103.html">[Zcplusplus-commits] r340 - trunk
</A></li>
	<LI>Next message: <A HREF="000109.html">[Zcplusplus-commits] r342 - in trunk: . tools
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#108">[ date ]</a>
              <a href="thread.html#108">[ thread ]</a>
              <a href="subject.html#108">[ subject ]</a>
              <a href="author.html#108">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/zcplusplus-commits">More information about the Zcplusplus-commits
mailing list</a><br>
</body></html>
