From zaimoni at mail.berlios.de  Thu Dec  9 10:32:55 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu,  9 Dec 2010 10:32:55 +0100
Subject: [Zcplusplus-commits] r549 - in trunk/tests: zcc/backport
	zcc/decl.C99 zcc/staticassert.C1X zcc.in/backport
	zcc.in/decl.C99 zcc.in/staticassert.C1X
Message-ID: <20101209093255.ADF14480E5F@sheep.berlios.de>

Author: zaimoni
Date: 2010-12-09 10:32:55 +0100 (Thu, 09 Dec 2010)
New Revision: 549

Modified:
   trunk/tests/zcc.in/backport/Warn_enum_trailing_comma.in
   trunk/tests/zcc.in/decl.C99/Error_enum_brace.in
   trunk/tests/zcc.in/decl.C99/Error_enum_init_truncated.in
   trunk/tests/zcc.in/decl.C99/Error_enum_keyword.in
   trunk/tests/zcc.in/decl.C99/Error_enum_multidef.in
   trunk/tests/zcc.in/decl.C99/Error_enum_no_init.in
   trunk/tests/zcc.in/decl.C99/Error_enum_symbol.in
   trunk/tests/zcc.in/decl.C99/Error_enum_type.in
   trunk/tests/zcc.in/decl.C99/Error_enum_typedef.in
   trunk/tests/zcc.in/decl.C99/Error_enum_undef.in
   trunk/tests/zcc.in/decl.C99/Pass_anonymous_enum_def.in
   trunk/tests/zcc.in/decl.C99/Pass_enum_def.in
   trunk/tests/zcc.in/decl.C99/Pass_enum_trailing_comma.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
   trunk/tests/zcc/backport/Warn_enum_trailing_comma.h
   trunk/tests/zcc/backport/Warn_enum_trailing_comma.hpp
   trunk/tests/zcc/decl.C99/Error_enum_brace.h
   trunk/tests/zcc/decl.C99/Error_enum_brace.hpp
   trunk/tests/zcc/decl.C99/Error_enum_init_truncated.h
   trunk/tests/zcc/decl.C99/Error_enum_init_truncated.hpp
   trunk/tests/zcc/decl.C99/Error_enum_keyword.h
   trunk/tests/zcc/decl.C99/Error_enum_keyword.hpp
   trunk/tests/zcc/decl.C99/Error_enum_multidef.h
   trunk/tests/zcc/decl.C99/Error_enum_multidef.hpp
   trunk/tests/zcc/decl.C99/Error_enum_no_init.h
   trunk/tests/zcc/decl.C99/Error_enum_no_init.hpp
   trunk/tests/zcc/decl.C99/Error_enum_symbol.h
   trunk/tests/zcc/decl.C99/Error_enum_symbol.hpp
   trunk/tests/zcc/decl.C99/Error_enum_type.h
   trunk/tests/zcc/decl.C99/Error_enum_type.hpp
   trunk/tests/zcc/decl.C99/Error_enum_typedef.h
   trunk/tests/zcc/decl.C99/Error_enum_typedef.hpp
   trunk/tests/zcc/decl.C99/Error_enum_undef.h
   trunk/tests/zcc/decl.C99/Error_enum_undef.hpp
   trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.h
   trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.hpp
   trunk/tests/zcc/decl.C99/Pass_enum_def.h
   trunk/tests/zcc/decl.C99/Pass_enum_def.hpp
   trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.h
   trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
Log:
fix missing-comma errors in test cases

Modified: trunk/tests/zcc/backport/Warn_enum_trailing_comma.h
===================================================================
--- trunk/tests/zcc/backport/Warn_enum_trailing_comma.h	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/backport/Warn_enum_trailing_comma.h	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum weird_test {
 	x_factor = 1,
-}
+};
 

Modified: trunk/tests/zcc/backport/Warn_enum_trailing_comma.hpp
===================================================================
--- trunk/tests/zcc/backport/Warn_enum_trailing_comma.hpp	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/backport/Warn_enum_trailing_comma.hpp	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum weird_test {
 	x_factor = 1,
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_brace.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_brace.h	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_brace.h	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum bad_test {
 	{} = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_brace.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_brace.hpp	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_brace.hpp	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum bad_test {
 	{} = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_init_truncated.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_init_truncated.h	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_init_truncated.h	2010-12-09 09:32:55 UTC (rev 549)
@@ -5,5 +5,5 @@
 enum bad_test {
 	x_factor = ,
 	x_factor2 = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_init_truncated.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_init_truncated.hpp	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_init_truncated.hpp	2010-12-09 09:32:55 UTC (rev 549)
@@ -5,5 +5,5 @@
 enum bad_test {
 	x_factor = ,
 	x_factor2 = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_keyword.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_keyword.h	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_keyword.h	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum bad_test {
 	return = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_keyword.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_keyword.hpp	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_keyword.hpp	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum bad_test {
 	return = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_multidef.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_multidef.h	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_multidef.h	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,9 +4,9 @@
 
 enum bad_test {
 	x_factor = 1
-}
+};
 
 enum bad_test {
 	x_factor = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_multidef.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_multidef.hpp	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_multidef.hpp	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,9 +4,9 @@
 
 enum bad_test {
 	x_factor = 1
-}
+};
 
 enum bad_test {
 	x_factor = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_no_init.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_no_init.h	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_no_init.h	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum bad_test {
 	x_factor &
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_no_init.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_no_init.hpp	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_no_init.hpp	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum bad_test {
 	x_factor &
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_symbol.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_symbol.h	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_symbol.h	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum bad_test {
 	& = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_symbol.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_symbol.hpp	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_symbol.hpp	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum bad_test {
 	& = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_type.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_type.h	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_type.h	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum bad_test {
 	unsigned int = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_type.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_type.hpp	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_type.hpp	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum bad_test {
 	unsigned int = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_typedef.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_typedef.h	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_typedef.h	2010-12-09 09:32:55 UTC (rev 549)
@@ -6,5 +6,5 @@
 
 enum bad_test {
 	x_factor = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_typedef.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_typedef.hpp	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_typedef.hpp	2010-12-09 09:32:55 UTC (rev 549)
@@ -6,5 +6,5 @@
 
 enum bad_test {
 	x_factor = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_undef.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_undef.h	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_undef.h	2010-12-09 09:32:55 UTC (rev 549)
@@ -2,5 +2,5 @@
 // using undefined enum
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-enum bad_test
+enum bad_test;
 

Modified: trunk/tests/zcc/decl.C99/Error_enum_undef.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_undef.hpp	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Error_enum_undef.hpp	2010-12-09 09:32:55 UTC (rev 549)
@@ -2,5 +2,5 @@
 // using undefined enum
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-enum bad_test
+enum bad_test;
 

Modified: trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.h	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.h	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum {
 	x_factor = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.hpp	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.hpp	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum {
 	x_factor = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Pass_enum_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_def.h	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Pass_enum_def.h	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum good_test {
 	x_factor = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Pass_enum_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_def.hpp	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Pass_enum_def.hpp	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum good_test {
 	x_factor = 1
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.h	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.h	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum weird_test {
 	x_factor = 1,
-}
+};
 

Modified: trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.hpp	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.hpp	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum weird_test {
 	x_factor = 1,
-}
+};
 

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-12-09 09:32:55 UTC (rev 549)
@@ -6,7 +6,7 @@
 	zero,
 	one,
 	two
-}
+};
 
 _Static_Assert(neg_one,"automatic success has failed");
 _Static_Assert(one,"automatic success has failed");

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-12-09 09:32:55 UTC (rev 549)
@@ -6,7 +6,7 @@
 	zero,
 	one,
 	two
-}
+};
 
 static_assert(neg_one,"automatic success has failed");
 static_assert(one,"automatic success has failed");

Modified: trunk/tests/zcc.in/backport/Warn_enum_trailing_comma.in
===================================================================
--- trunk/tests/zcc.in/backport/Warn_enum_trailing_comma.in	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc.in/backport/Warn_enum_trailing_comma.in	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum weird_test {
 	x_factor = 1,
-}
+};
 

Modified: trunk/tests/zcc.in/decl.C99/Error_enum_brace.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_brace.in	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_brace.in	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum bad_test {
 	{} = 1
-}
+};
 

Modified: trunk/tests/zcc.in/decl.C99/Error_enum_init_truncated.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_init_truncated.in	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_init_truncated.in	2010-12-09 09:32:55 UTC (rev 549)
@@ -5,5 +5,5 @@
 enum bad_test {
 	x_factor = ,
 	x_factor2 = 1
-}
+};
 

Modified: trunk/tests/zcc.in/decl.C99/Error_enum_keyword.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_keyword.in	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_keyword.in	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum bad_test {
 	return = 1
-}
+};
 

Modified: trunk/tests/zcc.in/decl.C99/Error_enum_multidef.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_multidef.in	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_multidef.in	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,9 +4,9 @@
 
 enum bad_test {
 	x_factor = 1
-}
+};
 
 enum bad_test {
 	x_factor = 1
-}
+};
 

Modified: trunk/tests/zcc.in/decl.C99/Error_enum_no_init.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_no_init.in	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_no_init.in	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum bad_test {
 	x_factor &
-}
+};
 

Modified: trunk/tests/zcc.in/decl.C99/Error_enum_symbol.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_symbol.in	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_symbol.in	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum bad_test {
 	& = 1
-}
+};
 

Modified: trunk/tests/zcc.in/decl.C99/Error_enum_type.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_type.in	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_type.in	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum bad_test {
 	unsigned int = 1
-}
+};
 

Modified: trunk/tests/zcc.in/decl.C99/Error_enum_typedef.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_typedef.in	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_typedef.in	2010-12-09 09:32:55 UTC (rev 549)
@@ -6,5 +6,5 @@
 
 enum bad_test {
 	x_factor = 1
-}
+};
 

Modified: trunk/tests/zcc.in/decl.C99/Error_enum_undef.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_undef.in	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_undef.in	2010-12-09 09:32:55 UTC (rev 549)
@@ -2,5 +2,5 @@
 // using undefined enum
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-enum bad_test
+enum bad_test;
 

Modified: trunk/tests/zcc.in/decl.C99/Pass_anonymous_enum_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_anonymous_enum_def.in	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc.in/decl.C99/Pass_anonymous_enum_def.in	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum {
 	x_factor = 1
-}
+};
 

Modified: trunk/tests/zcc.in/decl.C99/Pass_enum_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_enum_def.in	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc.in/decl.C99/Pass_enum_def.in	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum good_test {
 	x_factor = 1
-}
+};
 

Modified: trunk/tests/zcc.in/decl.C99/Pass_enum_trailing_comma.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_enum_trailing_comma.in	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc.in/decl.C99/Pass_enum_trailing_comma.in	2010-12-09 09:32:55 UTC (rev 549)
@@ -4,5 +4,5 @@
 
 enum weird_test {
 	x_factor = 1,
-}
+};
 

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-11-28 03:36:45 UTC (rev 548)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-12-09 09:32:55 UTC (rev 549)
@@ -7,7 +7,7 @@
 	zero,
 	one,
 	two
-}
+};
 
 STATIC_ASSERT(neg_one,"automatic success has failed");
 STATIC_ASSERT(one,"automatic success has failed");



From zaimoni at mail.berlios.de  Thu Dec  9 11:37:16 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu,  9 Dec 2010 11:37:16 +0100
Subject: [Zcplusplus-commits] r550 - in trunk/tests/zcc: compat decl.C99
Message-ID: <20101209103716.69DA1480E5F@sheep.berlios.de>

Author: zaimoni
Date: 2010-12-09 11:37:16 +0100 (Thu, 09 Dec 2010)
New Revision: 550

Modified:
   trunk/tests/zcc/compat/Warn_enum_empty.hpp
   trunk/tests/zcc/compat/Warn_enum_overflow.hpp
   trunk/tests/zcc/decl.C99/Error_enum_empty.h
   trunk/tests/zcc/decl.C99/Error_enum_nobase.hpp
   trunk/tests/zcc/decl.C99/Error_enum_nobase2.hpp
   trunk/tests/zcc/decl.C99/Error_enum_overflow.h
   trunk/tests/zcc/decl.C99/Pass_enum_empty.hpp
Log:
fix missing-comma errors in test cases

Modified: trunk/tests/zcc/compat/Warn_enum_empty.hpp
===================================================================
--- trunk/tests/zcc/compat/Warn_enum_empty.hpp	2010-12-09 09:32:55 UTC (rev 549)
+++ trunk/tests/zcc/compat/Warn_enum_empty.hpp	2010-12-09 10:37:16 UTC (rev 550)
@@ -3,4 +3,4 @@
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
 enum good_test {
-}
+};

Modified: trunk/tests/zcc/compat/Warn_enum_overflow.hpp
===================================================================
--- trunk/tests/zcc/compat/Warn_enum_overflow.hpp	2010-12-09 09:32:55 UTC (rev 549)
+++ trunk/tests/zcc/compat/Warn_enum_overflow.hpp	2010-12-09 10:37:16 UTC (rev 550)
@@ -9,7 +9,7 @@
 enum bad_enum {
 	x = INT_MAX,
 	x1
-}
+};
 #else
 #error test not meaningful for exotic target (INT_MAX==UINTMAX_MAX)
 #endif

Modified: trunk/tests/zcc/decl.C99/Error_enum_empty.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_empty.h	2010-12-09 09:32:55 UTC (rev 549)
+++ trunk/tests/zcc/decl.C99/Error_enum_empty.h	2010-12-09 10:37:16 UTC (rev 550)
@@ -3,4 +3,4 @@
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
 enum bad_test {
-}
+};

Modified: trunk/tests/zcc/decl.C99/Error_enum_nobase.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_nobase.hpp	2010-12-09 09:32:55 UTC (rev 549)
+++ trunk/tests/zcc/decl.C99/Error_enum_nobase.hpp	2010-12-09 10:37:16 UTC (rev 550)
@@ -8,7 +8,7 @@
 enum bad_enum {
 	x = UINTMAX_MAX,
 	y = -1
-}
+};
 #else
 #error test not meaningful for exotic target (INT_MAX==UINTMAX_MAX)
 #endif

Modified: trunk/tests/zcc/decl.C99/Error_enum_nobase2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_nobase2.hpp	2010-12-09 09:32:55 UTC (rev 549)
+++ trunk/tests/zcc/decl.C99/Error_enum_nobase2.hpp	2010-12-09 10:37:16 UTC (rev 550)
@@ -8,7 +8,7 @@
 enum bad_enum {
 	x = -1,
 	y = UINTMAX_MAX
-}
+};
 #else
 #error test not meaningful for exotic target (INT_MAX==UINTMAX_MAX)
 #endif

Modified: trunk/tests/zcc/decl.C99/Error_enum_overflow.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_overflow.h	2010-12-09 09:32:55 UTC (rev 549)
+++ trunk/tests/zcc/decl.C99/Error_enum_overflow.h	2010-12-09 10:37:16 UTC (rev 550)
@@ -7,4 +7,4 @@
 enum bad_enum {
 	x = INT_MAX,
 	y
-}
+};

Modified: trunk/tests/zcc/decl.C99/Pass_enum_empty.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_empty.hpp	2010-12-09 09:32:55 UTC (rev 549)
+++ trunk/tests/zcc/decl.C99/Pass_enum_empty.hpp	2010-12-09 10:37:16 UTC (rev 550)
@@ -3,4 +3,4 @@
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
 enum good_test {
-}
+};



From zaimoni at mail.berlios.de  Thu Dec  9 11:46:26 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu,  9 Dec 2010 11:46:26 +0100
Subject: [Zcplusplus-commits] r551 - trunk
Message-ID: <20101209104626.EE66A480E5F@sheep.berlios.de>

Author: zaimoni
Date: 2010-12-09 11:46:26 +0100 (Thu, 09 Dec 2010)
New Revision: 551

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
first stage of aligning declaration parsing with standards

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-12-09 10:37:16 UTC (rev 550)
+++ trunk/CSupport.cpp	2010-12-09 10:46:26 UTC (rev 551)
@@ -3080,9 +3080,10 @@
 #define PARSE_PRIMARY_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-19))
 #define PARSE_UNION_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-20))
 #define PARSE_CLASS_STRUCT_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-21))
+#define PARSE_ENUM_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-22))
 
 // check for collision with lowest three bits
-BOOST_STATIC_ASSERT(sizeof(lex_flags)*CHAR_BIT-parse_tree::PREDEFINED_STRICT_UB>=20);
+BOOST_STATIC_ASSERT(sizeof(lex_flags)*CHAR_BIT-parse_tree::PREDEFINED_STRICT_UB>=22);
 
 /* nonstrict expression types */
 #define PARSE_POSTFIX_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION)
@@ -3104,7 +3105,7 @@
 #define PARSE_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION | PARSE_STRICT_SHIFT_EXPRESSION | PARSE_STRICT_RELATIONAL_EXPRESSION | PARSE_STRICT_EQUALITY_EXPRESSION | PARSE_STRICT_BITAND_EXPRESSION | PARSE_STRICT_BITXOR_EXPRESSION | PARSE_STRICT_BITOR_EXPRESSION | PARSE_STRICT_LOGICAND_EXPRESSION | PARSE_STRICT_LOGICOR_EXPRESSION | PARSE_STRICT_CONDITIONAL_EXPRESSION | PARSE_STRICT_ASSIGNMENT_EXPRESSION | PARSE_STRICT_COMMA_EXPRESSION)
 
 /* nonstrict type categories */
-#define PARSE_TYPE (PARSE_PRIMARY_TYPE | PARSE_UNION_TYPE | PARSE_CLASS_STRUCT_TYPE)
+#define PARSE_TYPE (PARSE_PRIMARY_TYPE | PARSE_UNION_TYPE | PARSE_CLASS_STRUCT_TYPE | PARSE_ENUM_TYPE)
 
 /* already-parsed */
 #define PARSE_OBVIOUS (PARSE_EXPRESSION | PARSE_TYPE | parse_tree::INVALID)
@@ -10456,7 +10457,7 @@
 		DICT_STRUCT("friend")
 	};
 
-size_t C99_type_or_invariant_decl_specifier(const parse_tree& x)
+static size_t C99_type_or_invariant_decl_specifier(const parse_tree& x)
 {
 	if (PARSE_TYPE & x.flags)
 		return STATIC_SIZE(C99_nontype_decl_specifier_list);
@@ -10468,7 +10469,7 @@
 	return SIZE_MAX;
 }
 
-size_t CPP0X_type_or_invariant_decl_specifier(const parse_tree& x)
+static size_t CPP0X_type_or_invariant_decl_specifier(const parse_tree& x)
 {
 	if (PARSE_TYPE & x.flags)
 		return STATIC_SIZE(CPP0X_nontype_decl_specifier_list); 
@@ -12901,6 +12902,34 @@
 
 #undef ZCC_CORE_NOTICE_TAG
 
+static size_t C99_type_or_invariant_decl_specifier_or_tag(const parse_tree& x)
+{
+	if (PARSE_TYPE & x.flags)
+		return STATIC_SIZE(C99_nontype_decl_specifier_list);
+	if (x.is_atomic())
+		{
+		const errr i = linear_find(x.index_tokens[0].token.first,C99_nontype_decl_specifier_list,STATIC_SIZE(C99_nontype_decl_specifier_list));
+		if (STATIC_SIZE(C99_nontype_decl_specifier_list)>i) return i;
+		}
+	int tmp = notice_C99_tag(x);
+	if (tmp) return STATIC_SIZE(C99_nontype_decl_specifier_list)+tmp;
+	return SIZE_MAX;
+}
+
+static size_t CPP0X_type_or_invariant_decl_specifier_or_tag(const parse_tree& x)
+{
+	if (PARSE_TYPE & x.flags)
+		return STATIC_SIZE(CPP0X_nontype_decl_specifier_list); 
+	if (x.is_atomic())
+		{
+		const errr i = linear_find(x.index_tokens[0].token.first,CPP0X_nontype_decl_specifier_list,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+		if (STATIC_SIZE(CPP0X_nontype_decl_specifier_list)>i) return i;
+		}
+	int tmp = notice_CPP_tag(x);
+	if (tmp) return STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+tmp;
+	return SIZE_MAX;
+}	
+
 static void _forward_declare_C_union(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i];
@@ -12959,6 +12988,7 @@
 	// ask GCC: struct/class/union/enum collides with each other (both C and C++), does not collide with namespace
 	// think we can handle this as "disallow conflicting definitions"
 	kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(C99_type_or_invariant_decl_specifier);
+	kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1+9,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(C99_type_or_invariant_decl_specifier_or_tag);
 	size_t i = 0;
 	while(i<src.size<0>())
 		{
@@ -12970,6 +13000,61 @@
 			continue;
 			};
 		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
+		// pre-scan for declaration-like items
+		{
+rescan:
+		size_t j = 0;
+		while(pre_invariant_decl_scanner(src.data<0>()[i+j++]) && src.size<0>()-i > j);
+		if (!pre_invariant_decl_scanner.empty())
+			{	// if we ran out of tokens, bad
+			if (src.size<0>()-i <= pre_invariant_decl_scanner.size())
+				{	// unterminated declaration, top-level
+				//! \test zcc/decl.C99/Error_extern_scope.h
+				//! \test zcc/decl.C99/Error_static_scope.h
+				//! \test zcc/decl.C99/Error_typedef_scope.h
+				//! \test zcc/decl.C99/Error_register_scope.h
+				//! \test zcc/decl.C99/Error_auto_scope.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("declaration cut off by end of scope (C99 6.7p1)");
+				zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(src.size<0>()-i,i);
+				return;
+				};
+			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
+			//! \todo ; means decl terminates w/o identifier which is an error 
+			//! \todo if there are unparsed tags, scan for them and parse
+			size_t k = 0;
+			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(C99_nontype_decl_specifier_list))
+				{
+				case UNION_NAME: break;
+				case UNION_NAMED_DEF: break;
+				case UNION_ANON_DEF: break;
+				case STRUCT_NAME: break;
+				case STRUCT_NAMED_DEF: break;
+				case STRUCT_ANON_DEF: break;
+				case ENUM_NAME: break;
+				case ENUM_NAMED_DEF: break;
+				case ENUM_ANON_DEF:
+				{	// enum-specifier doesn't have a specific declaration mode
+					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
+				const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
+				src.c_array<0>()[i+k].type_code.set_type(tmp);	// C: enums are int (although we'd like to extend this a bit)
+				src.c_array<0>()[i+k].flags |= PARSE_ENUM_TYPE;
+				if (!record_enum_values(*src.c_array<0>()[i+k].c_array<2>(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+					{
+					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+					return;
+					}
+				pre_invariant_decl_scanner.clear();
+				goto rescan;
+				}
+				}
+			while(pre_invariant_decl_scanner.size()> ++k);
+			pre_invariant_decl_scanner.clear();
+			};
+		}
 		// check naked declarations first
 reparse:
 		const int tag_type = notice_C99_tag(src.data<0>()[i]);
@@ -13534,20 +13619,9 @@
 				}
 			}
 			break;
-			case ENUM_ANON_DEF:
-			{	// enum-specifier doesn't have a specific declaration mode
-				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			src.c_array<0>()[i].type_code.set_type(tmp);	// C: enums are int (although we'd like to extend this a bit)
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
-				{
-				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
-				return;
-				}
+			case ENUM_ANON_DEF: break;	/* already handled */
 			}
-			break;
 			}
-			}
 			
 		// general declaration scanner 
 		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
@@ -13567,22 +13641,7 @@
 		if (decl_count)
 			{
 			const bool coherent_storage_specifiers = declFind.analyze_flags_global(src,i,decl_count);
-			if (src.size<0>()-i<=decl_count)
-				{	// unterminated declaration
-					//! \test zcc/decl.C99/Error_extern_scope.h
-					//! \test zcc/decl.C99/Error_static_scope.h
-					//! \test zcc/decl.C99/Error_typedef_scope.h
-					//! \test zcc/decl.C99/Error_register_scope.h
-					//! \test zcc/decl.C99/Error_auto_scope.h
-				if (src.size<0>()>i) message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("declaration cut off by end of scope (C99 6.7p1)");
-				zcc_errors.inc_error();
-				// remove from parse
-				if (src.size<0>()>i)
-					src.DeleteNSlotsAt<0>(decl_count,i);
-				return;
-				};
+			assert(src.size<0>()-i>decl_count);	// unterminated declaration handled above
 			if (robust_token_is_char<';'>(src.data<0>()[i+decl_count]))
 				{	// C99 7p2 error: must declare something
 					//! \test zcc/decl.C99/Error_extern_semicolon.h
@@ -13968,6 +14027,7 @@
 		}
 
 	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier);
+	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1+12,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier_or_tag);
 	size_t i = 0;
 	while(i<src.size<0>())
 		{
@@ -13979,6 +14039,67 @@
 			continue;
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
+		// pre-scan for declaration-like items
+		{
+rescan:
+		size_t j = 0;
+		while(pre_invariant_decl_scanner(src.data<0>()[i+j++]) && src.size<0>()-i > j);
+		if (!pre_invariant_decl_scanner.empty())
+			{	// if we ran out of tokens, bad
+			if (src.size<0>()-i <= pre_invariant_decl_scanner.size())
+				{	// unterminated declaration, top-level
+				//! \test zcc/decl.C99/Error_extern_scope.hpp
+				//! \test zcc/decl.C99/Error_static_scope.hpp
+				//! \test zcc/decl.C99/Error_typedef_scope.hpp
+				//! \test zcc/decl.C99/Error_register_scope.hpp
+				//! \test zcc/decl.C99/Error_mutable_scope.hpp
+				//! \test zcc/decl.C99/Error_virtual_scope.hpp
+				//! \test zcc/decl.C99/Error_friend_scope.hpp
+				//! \test zcc/decl.C99/Error_explicit_scope.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("declaration cut off by end of scope (C++98 7p1)");
+				zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(src.size<0>()-i,i);
+				return;
+				};
+			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
+			//! \todo ; means decl terminates w/o identifier which is an error 
+			//! \todo if there are unparsed tags, scan for them and parse
+			size_t k = 0;
+			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(CPP0X_nontype_decl_specifier_list))
+				{
+				case UNION_NAME: break;
+				case UNION_NAMED_DEF: break;
+				case UNION_ANON_DEF: break;
+				case STRUCT_NAME: break;
+				case STRUCT_NAMED_DEF: break;
+				case STRUCT_ANON_DEF: break;
+				case CLASS_NAME: break;
+				case CLASS_NAMED_DEF: break;
+				case CLASS_ANON_DEF: break;
+				case ENUM_NAME: break;
+				case ENUM_NAMED_DEF: break;
+				case ENUM_ANON_DEF:
+				{	// enum-specifier doesn't have a specific declaration mode
+					//! \test zcc/decl.C99/Pass_anonymous_enum_def.hpp
+				const type_system::type_index tmp = parse_tree::types->register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
+				src.c_array<0>()[i+k].type_code.set_type(tmp);	// C++: enums are own type
+				src.c_array<0>()[i+k].flags |= PARSE_ENUM_TYPE;
+				if (!record_enum_values(*src.c_array<0>()[i+k].c_array<2>(),tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+					{
+					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+					return;
+					}
+				pre_invariant_decl_scanner.clear();
+				goto rescan;
+				}
+				}
+			while(pre_invariant_decl_scanner.size()> ++k);
+			pre_invariant_decl_scanner.clear();
+			};
+		}
 		// check naked declarations first; handle namespaces later
 reparse:
 		const int tag_type = notice_CPP_tag(src.data<0>()[i]);
@@ -14783,19 +14904,8 @@
 				}
 			}
 			break;
-			case ENUM_ANON_DEF:
-			{	// enum-specifier doesn't have a specific declaration mode
-				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = parse_tree::types->register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
-				{
-				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
-				return;
-				}
+			case ENUM_ANON_DEF: break;	/* already handled */
 			}
-			break;
-			}
 			};
 
 		// namespace scanner
@@ -14932,25 +15042,7 @@
 		if (decl_count)
 			{
 			const bool coherent_storage_specifiers = declFind.analyze_flags_global(src,i,decl_count);
-			if (src.size<0>()-i<=decl_count)
-				{	// unterminated declaration
-					//! \test zcc/decl.C99/Error_extern_scope.hpp
-					//! \test zcc/decl.C99/Error_static_scope.hpp
-					//! \test zcc/decl.C99/Error_typedef_scope.hpp
-					//! \test zcc/decl.C99/Error_register_scope.hpp
-					//! \test zcc/decl.C99/Error_mutable_scope.hpp
-					//! \test zcc/decl.C99/Error_virtual_scope.hpp
-					//! \test zcc/decl.C99/Error_friend_scope.hpp
-					//! \test zcc/decl.C99/Error_explicit_scope.hpp
-				if (src.size<0>()>i) message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("declaration cut off by end of scope (C++98 7p1)");
-				zcc_errors.inc_error();
-				// remove from parse
-				if (src.size<0>()>i)
-					src.DeleteNSlotsAt<0>(decl_count,i);
-				return;
-				};
+			assert(src.size<0>()-i>decl_count);	/* unterminated declarations already handled */
 			if (robust_token_is_char<';'>(src.data<0>()[i+decl_count]))
 				{	// must declare something
 					//! \test zcc/decl.C99/Error_extern_semicolon.hpp

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-12-09 10:37:16 UTC (rev 550)
+++ trunk/CSupport.cpp.in	2010-12-09 10:46:26 UTC (rev 551)
@@ -3135,9 +3135,10 @@
 #define PARSE_PRIMARY_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-19))
 #define PARSE_UNION_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-20))
 #define PARSE_CLASS_STRUCT_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-21))
+#define PARSE_ENUM_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-22))
 
 // check for collision with lowest three bits
-BOOST_STATIC_ASSERT(sizeof(lex_flags)*CHAR_BIT-parse_tree::PREDEFINED_STRICT_UB>=20);
+BOOST_STATIC_ASSERT(sizeof(lex_flags)*CHAR_BIT-parse_tree::PREDEFINED_STRICT_UB>=22);
 
 /* nonstrict expression types */
 #define PARSE_POSTFIX_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION)
@@ -3159,7 +3160,7 @@
 #define PARSE_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION | PARSE_STRICT_SHIFT_EXPRESSION | PARSE_STRICT_RELATIONAL_EXPRESSION | PARSE_STRICT_EQUALITY_EXPRESSION | PARSE_STRICT_BITAND_EXPRESSION | PARSE_STRICT_BITXOR_EXPRESSION | PARSE_STRICT_BITOR_EXPRESSION | PARSE_STRICT_LOGICAND_EXPRESSION | PARSE_STRICT_LOGICOR_EXPRESSION | PARSE_STRICT_CONDITIONAL_EXPRESSION | PARSE_STRICT_ASSIGNMENT_EXPRESSION | PARSE_STRICT_COMMA_EXPRESSION)
 
 /* nonstrict type categories */
-#define PARSE_TYPE (PARSE_PRIMARY_TYPE | PARSE_UNION_TYPE | PARSE_CLASS_STRUCT_TYPE)
+#define PARSE_TYPE (PARSE_PRIMARY_TYPE | PARSE_UNION_TYPE | PARSE_CLASS_STRUCT_TYPE | PARSE_ENUM_TYPE)
 
 /* already-parsed */
 #define PARSE_OBVIOUS (PARSE_EXPRESSION | PARSE_TYPE | parse_tree::INVALID)
@@ -10592,7 +10593,7 @@
 		DICT_STRUCT("friend")
 	};
 
-size_t C99_type_or_invariant_decl_specifier(const parse_tree& x)
+static size_t C99_type_or_invariant_decl_specifier(const parse_tree& x)
 {
 	if (PARSE_TYPE & x.flags)
 		return STATIC_SIZE(C99_nontype_decl_specifier_list);
@@ -10604,7 +10605,7 @@
 	return SIZE_MAX;
 }
 
-size_t CPP0X_type_or_invariant_decl_specifier(const parse_tree& x)
+static size_t CPP0X_type_or_invariant_decl_specifier(const parse_tree& x)
 {
 	if (PARSE_TYPE & x.flags)
 		return STATIC_SIZE(CPP0X_nontype_decl_specifier_list); 
@@ -13045,6 +13046,34 @@
 
 #undef ZCC_CORE_NOTICE_TAG
 
+static size_t C99_type_or_invariant_decl_specifier_or_tag(const parse_tree& x)
+{
+	if (PARSE_TYPE & x.flags)
+		return STATIC_SIZE(C99_nontype_decl_specifier_list);
+	if (x.is_atomic())
+		{
+		const errr i = linear_find(x.index_tokens[0].token.first,C99_nontype_decl_specifier_list,STATIC_SIZE(C99_nontype_decl_specifier_list));
+		if (STATIC_SIZE(C99_nontype_decl_specifier_list)>i) return i;
+		}
+	int tmp = notice_C99_tag(x);
+	if (tmp) return STATIC_SIZE(C99_nontype_decl_specifier_list)+tmp;
+	return SIZE_MAX;
+}
+
+static size_t CPP0X_type_or_invariant_decl_specifier_or_tag(const parse_tree& x)
+{
+	if (PARSE_TYPE & x.flags)
+		return STATIC_SIZE(CPP0X_nontype_decl_specifier_list); 
+	if (x.is_atomic())
+		{
+		const errr i = linear_find(x.index_tokens[0].token.first,CPP0X_nontype_decl_specifier_list,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+		if (STATIC_SIZE(CPP0X_nontype_decl_specifier_list)>i) return i;
+		}
+	int tmp = notice_CPP_tag(x);
+	if (tmp) return STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+tmp;
+	return SIZE_MAX;
+}	
+
 static void _forward_declare_C_union(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i];
@@ -13103,6 +13132,7 @@
 	// ask GCC: struct/class/union/enum collides with each other (both C and C++), does not collide with namespace
 	// think we can handle this as "disallow conflicting definitions"
 	kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(C99_type_or_invariant_decl_specifier);
+	kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1+9,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(C99_type_or_invariant_decl_specifier_or_tag);
 	size_t i = 0;
 	while(i<src.size<0>())
 		{
@@ -13114,6 +13144,61 @@
 			continue;
 			};
 		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
+		// pre-scan for declaration-like items
+		{
+rescan:
+		size_t j = 0;
+		while(pre_invariant_decl_scanner(src.data<0>()[i+j++]) && src.size<0>()-i > j);
+		if (!pre_invariant_decl_scanner.empty())
+			{	// if we ran out of tokens, bad
+			if (src.size<0>()-i <= pre_invariant_decl_scanner.size())
+				{	// unterminated declaration, top-level
+				//! \test zcc/decl.C99/Error_extern_scope.h
+				//! \test zcc/decl.C99/Error_static_scope.h
+				//! \test zcc/decl.C99/Error_typedef_scope.h
+				//! \test zcc/decl.C99/Error_register_scope.h
+				//! \test zcc/decl.C99/Error_auto_scope.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("declaration cut off by end of scope (C99 6.7p1)");
+				zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(src.size<0>()-i,i);
+				return;
+				};
+			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
+			//! \todo ; means decl terminates w/o identifier which is an error 
+			//! \todo if there are unparsed tags, scan for them and parse
+			size_t k = 0;
+			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(C99_nontype_decl_specifier_list))
+				{
+				case UNION_NAME: break;
+				case UNION_NAMED_DEF: break;
+				case UNION_ANON_DEF: break;
+				case STRUCT_NAME: break;
+				case STRUCT_NAMED_DEF: break;
+				case STRUCT_ANON_DEF: break;
+				case ENUM_NAME: break;
+				case ENUM_NAMED_DEF: break;
+				case ENUM_ANON_DEF:
+				{	// enum-specifier doesn't have a specific declaration mode
+					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
+				const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
+				src.c_array<0>()[i+k].type_code.set_type(tmp);	// C: enums are int (although we'd like to extend this a bit)
+				src.c_array<0>()[i+k].flags |= PARSE_ENUM_TYPE;
+				if (!record_enum_values(*src.c_array<0>()[i+k].c_array<2>(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+					{
+					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+					return;
+					}
+				pre_invariant_decl_scanner.clear();
+				goto rescan;
+				}
+				}
+			while(pre_invariant_decl_scanner.size()> ++k);
+			pre_invariant_decl_scanner.clear();
+			};
+		}
 		// check naked declarations first
 reparse:
 		const int tag_type = notice_C99_tag(src.data<0>()[i]);
@@ -13678,20 +13763,9 @@
 				}
 			}
 			break;
-			case ENUM_ANON_DEF:
-			{	// enum-specifier doesn't have a specific declaration mode
-				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			src.c_array<0>()[i].type_code.set_type(tmp);	// C: enums are int (although we'd like to extend this a bit)
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
-				{
-				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
-				return;
-				}
+			case ENUM_ANON_DEF: break;	/* already handled */
 			}
-			break;
 			}
-			}
 			
 		// general declaration scanner 
 		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
@@ -13711,22 +13785,7 @@
 		if (decl_count)
 			{
 			const bool coherent_storage_specifiers = declFind.analyze_flags_global(src,i,decl_count);
-			if (src.size<0>()-i<=decl_count)
-				{	// unterminated declaration
-					//! \test zcc/decl.C99/Error_extern_scope.h
-					//! \test zcc/decl.C99/Error_static_scope.h
-					//! \test zcc/decl.C99/Error_typedef_scope.h
-					//! \test zcc/decl.C99/Error_register_scope.h
-					//! \test zcc/decl.C99/Error_auto_scope.h
-				if (src.size<0>()>i) message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("declaration cut off by end of scope (C99 6.7p1)");
-				zcc_errors.inc_error();
-				// remove from parse
-				if (src.size<0>()>i)
-					src.DeleteNSlotsAt<0>(decl_count,i);
-				return;
-				};
+			assert(src.size<0>()-i>decl_count);	// unterminated declaration handled above
 			if (robust_token_is_char<';'>(src.data<0>()[i+decl_count]))
 				{	// C99 7p2 error: must declare something
 					//! \test zcc/decl.C99/Error_extern_semicolon.h
@@ -14112,6 +14171,7 @@
 		}
 
 	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier);
+	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1+12,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier_or_tag);
 	size_t i = 0;
 	while(i<src.size<0>())
 		{
@@ -14123,6 +14183,67 @@
 			continue;
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
+		// pre-scan for declaration-like items
+		{
+rescan:
+		size_t j = 0;
+		while(pre_invariant_decl_scanner(src.data<0>()[i+j++]) && src.size<0>()-i > j);
+		if (!pre_invariant_decl_scanner.empty())
+			{	// if we ran out of tokens, bad
+			if (src.size<0>()-i <= pre_invariant_decl_scanner.size())
+				{	// unterminated declaration, top-level
+				//! \test zcc/decl.C99/Error_extern_scope.hpp
+				//! \test zcc/decl.C99/Error_static_scope.hpp
+				//! \test zcc/decl.C99/Error_typedef_scope.hpp
+				//! \test zcc/decl.C99/Error_register_scope.hpp
+				//! \test zcc/decl.C99/Error_mutable_scope.hpp
+				//! \test zcc/decl.C99/Error_virtual_scope.hpp
+				//! \test zcc/decl.C99/Error_friend_scope.hpp
+				//! \test zcc/decl.C99/Error_explicit_scope.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("declaration cut off by end of scope (C++98 7p1)");
+				zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(src.size<0>()-i,i);
+				return;
+				};
+			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
+			//! \todo ; means decl terminates w/o identifier which is an error 
+			//! \todo if there are unparsed tags, scan for them and parse
+			size_t k = 0;
+			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(CPP0X_nontype_decl_specifier_list))
+				{
+				case UNION_NAME: break;
+				case UNION_NAMED_DEF: break;
+				case UNION_ANON_DEF: break;
+				case STRUCT_NAME: break;
+				case STRUCT_NAMED_DEF: break;
+				case STRUCT_ANON_DEF: break;
+				case CLASS_NAME: break;
+				case CLASS_NAMED_DEF: break;
+				case CLASS_ANON_DEF: break;
+				case ENUM_NAME: break;
+				case ENUM_NAMED_DEF: break;
+				case ENUM_ANON_DEF:
+				{	// enum-specifier doesn't have a specific declaration mode
+					//! \test zcc/decl.C99/Pass_anonymous_enum_def.hpp
+				const type_system::type_index tmp = parse_tree::types->register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
+				src.c_array<0>()[i+k].type_code.set_type(tmp);	// C++: enums are own type
+				src.c_array<0>()[i+k].flags |= PARSE_ENUM_TYPE;
+				if (!record_enum_values(*src.c_array<0>()[i+k].c_array<2>(),tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+					{
+					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+					return;
+					}
+				pre_invariant_decl_scanner.clear();
+				goto rescan;
+				}
+				}
+			while(pre_invariant_decl_scanner.size()> ++k);
+			pre_invariant_decl_scanner.clear();
+			};
+		}
 		// check naked declarations first; handle namespaces later
 reparse:
 		const int tag_type = notice_CPP_tag(src.data<0>()[i]);
@@ -14927,19 +15048,8 @@
 				}
 			}
 			break;
-			case ENUM_ANON_DEF:
-			{	// enum-specifier doesn't have a specific declaration mode
-				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = parse_tree::types->register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
-				{
-				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
-				return;
-				}
+			case ENUM_ANON_DEF: break;	/* already handled */
 			}
-			break;
-			}
 			};
 
 		// namespace scanner
@@ -15076,25 +15186,7 @@
 		if (decl_count)
 			{
 			const bool coherent_storage_specifiers = declFind.analyze_flags_global(src,i,decl_count);
-			if (src.size<0>()-i<=decl_count)
-				{	// unterminated declaration
-					//! \test zcc/decl.C99/Error_extern_scope.hpp
-					//! \test zcc/decl.C99/Error_static_scope.hpp
-					//! \test zcc/decl.C99/Error_typedef_scope.hpp
-					//! \test zcc/decl.C99/Error_register_scope.hpp
-					//! \test zcc/decl.C99/Error_mutable_scope.hpp
-					//! \test zcc/decl.C99/Error_virtual_scope.hpp
-					//! \test zcc/decl.C99/Error_friend_scope.hpp
-					//! \test zcc/decl.C99/Error_explicit_scope.hpp
-				if (src.size<0>()>i) message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("declaration cut off by end of scope (C++98 7p1)");
-				zcc_errors.inc_error();
-				// remove from parse
-				if (src.size<0>()>i)
-					src.DeleteNSlotsAt<0>(decl_count,i);
-				return;
-				};
+			assert(src.size<0>()-i>decl_count);	/* unterminated declarations already handled */
 			if (robust_token_is_char<';'>(src.data<0>()[i+decl_count]))
 				{	// must declare something
 					//! \test zcc/decl.C99/Error_extern_semicolon.hpp



From zaimoni at mail.berlios.de  Sat Dec 11 09:47:10 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 11 Dec 2010 09:47:10 +0100
Subject: [Zcplusplus-commits] r552 - trunk
Message-ID: <20101211084710.D126B480EAC@sheep.berlios.de>

Author: zaimoni
Date: 2010-12-11 09:47:10 +0100 (Sat, 11 Dec 2010)
New Revision: 552

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
switch over named enum recognition; object size reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-12-09 10:46:26 UTC (rev 551)
+++ trunk/CSupport.cpp	2010-12-11 08:47:10 UTC (rev 552)
@@ -13004,6 +13004,7 @@
 		{
 rescan:
 		size_t j = 0;
+		pre_invariant_decl_scanner.clear(); // there's a lot of rescanning paths, so conserve lines of code
 		while(pre_invariant_decl_scanner(src.data<0>()[i+j++]) && src.size<0>()-i > j);
 		if (!pre_invariant_decl_scanner.empty())
 			{	// if we ran out of tokens, bad
@@ -13023,7 +13024,7 @@
 				return;
 				};
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
-			//! \todo ; means decl terminates w/o identifier which is an error 
+			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse
 			size_t k = 0;
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(C99_nontype_decl_specifier_list))
@@ -13034,25 +13035,45 @@
 				case STRUCT_NAME: break;
 				case STRUCT_NAMED_DEF: break;
 				case STRUCT_ANON_DEF: break;
-				case ENUM_NAME: break;
+				case ENUM_NAME:
+				{	// C99 6.7.2.3: allowed only after name is defined
+				// XXX C: enums are int, but the optimizers will want to know
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (type_system::type_index tmp = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
+					{
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_ENUM_TYPE;
+					}
+				else{	//! \test zcc/decl.C99/Error_enum_undef.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'enum ");
+					INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+					INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
+					zcc_errors.inc_error();
+					tmp2.type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
+					tmp2.flags |= (parse_tree::INVALID | PARSE_PRIMARY_TYPE);
+					};
+				goto rescan;
+				}
 				case ENUM_NAMED_DEF: break;
 				case ENUM_ANON_DEF:
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-				const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
-				src.c_array<0>()[i+k].type_code.set_type(tmp);	// C: enums are int (although we'd like to extend this a bit)
-				src.c_array<0>()[i+k].flags |= PARSE_ENUM_TYPE;
-				if (!record_enum_values(*src.c_array<0>()[i+k].c_array<2>(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
+				const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
+				tmp2.type_code.set_type(tmp);	// C: enums are int (although we'd like to extend this a bit)
+				tmp2.flags |= PARSE_ENUM_TYPE;
+				if (!record_enum_values(*tmp2.c_array<2>(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 					{
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				pre_invariant_decl_scanner.clear();
 				goto rescan;
 				}
 				}
 			while(pre_invariant_decl_scanner.size()> ++k);
-			pre_invariant_decl_scanner.clear();
+			pre_invariant_decl_scanner.clear();	// RAM efficiency
 			};
 		}
 		// check naked declarations first
@@ -13534,23 +13555,7 @@
 				}
 			}
 			break;
-			case ENUM_NAME:
-			{	// C99 6.7.2.3: allowed only after name is defined
-			// XXX C: enums are int, but the optimizers will want to know
-			if (type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
-				 src.c_array<0>()[i].type_code.set_type(tmp);
-			else{	//! \test zcc/decl.C99/Error_enum_undef.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'enum ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-				INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
-				src.c_array<0>()[i].flags |= parse_tree::INVALID;
-				};
-			}
-			break;
+			case ENUM_NAME: break;	/* already handled */
 			case ENUM_NAMED_DEF:
 			{	// can only define once
 			if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
@@ -14043,6 +14048,7 @@
 		{
 rescan:
 		size_t j = 0;
+		pre_invariant_decl_scanner.clear(); // there's a lot of rescanning paths, so conserve lines of code
 		while(pre_invariant_decl_scanner(src.data<0>()[i+j++]) && src.size<0>()-i > j);
 		if (!pre_invariant_decl_scanner.empty())
 			{	// if we ran out of tokens, bad
@@ -14065,7 +14071,7 @@
 				return;
 				};
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
-			//! \todo ; means decl terminates w/o identifier which is an error 
+			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse
 			size_t k = 0;
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(CPP0X_nontype_decl_specifier_list))
@@ -14079,25 +14085,45 @@
 				case CLASS_NAME: break;
 				case CLASS_NAMED_DEF: break;
 				case CLASS_ANON_DEF: break;
-				case ENUM_NAME: break;
+				case ENUM_NAME:
+				{
+				parse_tree& tmp2 =  src.c_array<0>()[i+k];
+				if (const type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{
+					tmp2.type_code.set_type(tmp);	// C++: enums are own type
+					tmp2.flags |= PARSE_ENUM_TYPE;
+					}
+				else{	// this belongs elsewhere
+					//! \test zcc/decl.C99/Error_enum_undef.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'enum ");
+					INC_INFORM(src.data<0>()[i+k].index_tokens[1].token.first,src.data<0>()[i+k].index_tokens[1].token.second);
+					INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
+					zcc_errors.inc_error();
+					tmp2.type_code.set_type(C_TYPE::INT);	// fail over to int, like C
+					tmp2.flags |= (parse_tree::INVALID | PARSE_PRIMARY_TYPE);
+					}
+				goto rescan;
+				}
 				case ENUM_NAMED_DEF: break;
 				case ENUM_ANON_DEF:
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.hpp
-				const type_system::type_index tmp = parse_tree::types->register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
-				src.c_array<0>()[i+k].type_code.set_type(tmp);	// C++: enums are own type
-				src.c_array<0>()[i+k].flags |= PARSE_ENUM_TYPE;
-				if (!record_enum_values(*src.c_array<0>()[i+k].c_array<2>(),tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
+				const type_system::type_index tmp = parse_tree::types->register_enum_def_CPP("<unknown>",active_namespace,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
+				tmp2.type_code.set_type(tmp);	// C++: enums are own type
+				tmp2.flags |= PARSE_ENUM_TYPE;
+				if (!record_enum_values(*tmp2.c_array<2>(),tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 					{
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				pre_invariant_decl_scanner.clear();
 				goto rescan;
 				}
 				}
 			while(pre_invariant_decl_scanner.size()> ++k);
-			pre_invariant_decl_scanner.clear();
+			pre_invariant_decl_scanner.clear();	// RAM efficiency
 			};
 		}
 		// check naked declarations first; handle namespaces later
@@ -14815,24 +14841,7 @@
 				}
 			}
 			break;
-			case ENUM_NAME:
-			{
-			if (const type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				 src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
-			else{	// this belongs elsewhere
-					//! \test zcc/decl.C99/Error_enum_undef.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'enum ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-				INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// fail over to int, like C
-				src.c_array<0>()[i].flags |= parse_tree::INVALID;
-				}
-			//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
-			}
-			break;
+			case ENUM_NAME: break;	/* already handled */
 			case ENUM_NAMED_DEF:
 			{	// can only define once
 			if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-12-09 10:46:26 UTC (rev 551)
+++ trunk/CSupport.cpp.in	2010-12-11 08:47:10 UTC (rev 552)
@@ -13148,6 +13148,7 @@
 		{
 rescan:
 		size_t j = 0;
+		pre_invariant_decl_scanner.clear(); // there's a lot of rescanning paths, so conserve lines of code
 		while(pre_invariant_decl_scanner(src.data<0>()[i+j++]) && src.size<0>()-i > j);
 		if (!pre_invariant_decl_scanner.empty())
 			{	// if we ran out of tokens, bad
@@ -13167,7 +13168,7 @@
 				return;
 				};
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
-			//! \todo ; means decl terminates w/o identifier which is an error 
+			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse
 			size_t k = 0;
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(C99_nontype_decl_specifier_list))
@@ -13178,25 +13179,45 @@
 				case STRUCT_NAME: break;
 				case STRUCT_NAMED_DEF: break;
 				case STRUCT_ANON_DEF: break;
-				case ENUM_NAME: break;
+				case ENUM_NAME:
+				{	// C99 6.7.2.3: allowed only after name is defined
+				// XXX C: enums are int, but the optimizers will want to know
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (type_system::type_index tmp = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
+					{
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_ENUM_TYPE;
+					}
+				else{	//! \test zcc/decl.C99/Error_enum_undef.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'enum ");
+					INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+					INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
+					zcc_errors.inc_error();
+					tmp2.type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
+					tmp2.flags |= (parse_tree::INVALID | PARSE_PRIMARY_TYPE);
+					};
+				goto rescan;
+				}
 				case ENUM_NAMED_DEF: break;
 				case ENUM_ANON_DEF:
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-				const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
-				src.c_array<0>()[i+k].type_code.set_type(tmp);	// C: enums are int (although we'd like to extend this a bit)
-				src.c_array<0>()[i+k].flags |= PARSE_ENUM_TYPE;
-				if (!record_enum_values(*src.c_array<0>()[i+k].c_array<2>(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
+				const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
+				tmp2.type_code.set_type(tmp);	// C: enums are int (although we'd like to extend this a bit)
+				tmp2.flags |= PARSE_ENUM_TYPE;
+				if (!record_enum_values(*tmp2.c_array<2>(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 					{
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				pre_invariant_decl_scanner.clear();
 				goto rescan;
 				}
 				}
 			while(pre_invariant_decl_scanner.size()> ++k);
-			pre_invariant_decl_scanner.clear();
+			pre_invariant_decl_scanner.clear();	// RAM efficiency
 			};
 		}
 		// check naked declarations first
@@ -13678,23 +13699,7 @@
 				}
 			}
 			break;
-			case ENUM_NAME:
-			{	// C99 6.7.2.3: allowed only after name is defined
-			// XXX C: enums are int, but the optimizers will want to know
-			if (type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
-				 src.c_array<0>()[i].type_code.set_type(tmp);
-			else{	//! \test zcc/decl.C99/Error_enum_undef.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'enum ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-				INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
-				src.c_array<0>()[i].flags |= parse_tree::INVALID;
-				};
-			}
-			break;
+			case ENUM_NAME: break;	/* already handled */
 			case ENUM_NAMED_DEF:
 			{	// can only define once
 			if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
@@ -14187,6 +14192,7 @@
 		{
 rescan:
 		size_t j = 0;
+		pre_invariant_decl_scanner.clear(); // there's a lot of rescanning paths, so conserve lines of code
 		while(pre_invariant_decl_scanner(src.data<0>()[i+j++]) && src.size<0>()-i > j);
 		if (!pre_invariant_decl_scanner.empty())
 			{	// if we ran out of tokens, bad
@@ -14209,7 +14215,7 @@
 				return;
 				};
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
-			//! \todo ; means decl terminates w/o identifier which is an error 
+			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse
 			size_t k = 0;
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(CPP0X_nontype_decl_specifier_list))
@@ -14223,25 +14229,45 @@
 				case CLASS_NAME: break;
 				case CLASS_NAMED_DEF: break;
 				case CLASS_ANON_DEF: break;
-				case ENUM_NAME: break;
+				case ENUM_NAME:
+				{
+				parse_tree& tmp2 =  src.c_array<0>()[i+k];
+				if (const type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{
+					tmp2.type_code.set_type(tmp);	// C++: enums are own type
+					tmp2.flags |= PARSE_ENUM_TYPE;
+					}
+				else{	// this belongs elsewhere
+					//! \test zcc/decl.C99/Error_enum_undef.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'enum ");
+					INC_INFORM(src.data<0>()[i+k].index_tokens[1].token.first,src.data<0>()[i+k].index_tokens[1].token.second);
+					INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
+					zcc_errors.inc_error();
+					tmp2.type_code.set_type(C_TYPE::INT);	// fail over to int, like C
+					tmp2.flags |= (parse_tree::INVALID | PARSE_PRIMARY_TYPE);
+					}
+				goto rescan;
+				}
 				case ENUM_NAMED_DEF: break;
 				case ENUM_ANON_DEF:
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.hpp
-				const type_system::type_index tmp = parse_tree::types->register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
-				src.c_array<0>()[i+k].type_code.set_type(tmp);	// C++: enums are own type
-				src.c_array<0>()[i+k].flags |= PARSE_ENUM_TYPE;
-				if (!record_enum_values(*src.c_array<0>()[i+k].c_array<2>(),tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
+				const type_system::type_index tmp = parse_tree::types->register_enum_def_CPP("<unknown>",active_namespace,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
+				tmp2.type_code.set_type(tmp);	// C++: enums are own type
+				tmp2.flags |= PARSE_ENUM_TYPE;
+				if (!record_enum_values(*tmp2.c_array<2>(),tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 					{
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				pre_invariant_decl_scanner.clear();
 				goto rescan;
 				}
 				}
 			while(pre_invariant_decl_scanner.size()> ++k);
-			pre_invariant_decl_scanner.clear();
+			pre_invariant_decl_scanner.clear();	// RAM efficiency
 			};
 		}
 		// check naked declarations first; handle namespaces later
@@ -14959,24 +14985,7 @@
 				}
 			}
 			break;
-			case ENUM_NAME:
-			{
-			if (const type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				 src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
-			else{	// this belongs elsewhere
-					//! \test zcc/decl.C99/Error_enum_undef.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'enum ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-				INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// fail over to int, like C
-				src.c_array<0>()[i].flags |= parse_tree::INVALID;
-				}
-			//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
-			}
-			break;
+			case ENUM_NAME: break;	/* already handled */
 			case ENUM_NAMED_DEF:
 			{	// can only define once
 			if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))



From zaimoni at mail.berlios.de  Sat Dec 18 20:32:58 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 18 Dec 2010 20:32:58 +0100
Subject: [Zcplusplus-commits] r553 - trunk
Message-ID: <20101218193258.BC002480ED2@sheep.berlios.de>

Author: zaimoni
Date: 2010-12-18 20:32:58 +0100 (Sat, 18 Dec 2010)
New Revision: 553

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
align parsing of enumeration definitions with standards

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-12-11 08:47:10 UTC (rev 552)
+++ trunk/CSupport.cpp	2010-12-18 19:32:58 UTC (rev 553)
@@ -13035,6 +13035,7 @@
 				case STRUCT_NAME: break;
 				case STRUCT_NAMED_DEF: break;
 				case STRUCT_ANON_DEF: break;
+				//! \bug the enums aren't handling const/volatile qualification
 				case ENUM_NAME:
 				{	// C99 6.7.2.3: allowed only after name is defined
 				// XXX C: enums are int, but the optimizers will want to know
@@ -13056,7 +13057,76 @@
 					};
 				goto rescan;
 				}
-				case ENUM_NAMED_DEF: break;
+				case ENUM_NAMED_DEF:
+				{	// can only define once
+				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
+				if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_enum_multidef.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'enum ");
+					INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+					INFORM("' already defined (C99 6.7.2.3p1)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					goto rescan;
+					}
+				// C1X 6.7.2.3p2 states that conflicting union or struct must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_union_as_enum.h
+						//! \test zcc/decl.C99/Error_union_as_enum2.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C99 6.7.2.3p2)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_struct_as_enum.h
+						//! \test zcc/decl.C99/Error_struct_as_enum2.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as struct (C99 6.7.2.3p2)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("struct");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"struct"));
+					goto rescan;
+					}
+				
+				// enum-specifier doesn't have a specific declaration mode
+				//! \test zcc/decl.C99/Pass_enum_def.h
+				const type_system::type_index tmp3 = parse_tree::types->register_enum_def(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
+				assert(parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first)==tmp3);
+				tmp2.type_code.set_type(tmp3);	// C: enums are int (although we'd like to extend this a bit)
+				tmp2.flags |= PARSE_ENUM_TYPE;
+				if (!record_enum_values(*tmp2.c_array<2>(),tmp3,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+					{
+					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+					return;
+					}
+				}
+				break;
 				case ENUM_ANON_DEF:
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
@@ -13556,74 +13626,7 @@
 			}
 			break;
 			case ENUM_NAME: break;	/* already handled */
-			case ENUM_NAMED_DEF:
-			{	// can only define once
-			if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_enum_multidef.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'enum ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-				INFORM("' already defined (C99 6.7.2.3p1)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// C1X 6.7.2.3p2 states that conflicting union or struct must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_union_as_enum.h
-					//! \test zcc/decl.C99/Error_union_as_enum2.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C99 6.7.2.3p2)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_struct_as_enum.h
-					//! \test zcc/decl.C99/Error_struct_as_enum2.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as struct (C99 6.7.2.3p2)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-				goto reparse;
-				}
-				
-			// enum-specifier doesn't have a specific declaration mode
-			//! \test zcc/decl.C99/Pass_enum_def.h
-			const type_system::type_index tmp2 = parse_tree::types->register_enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			assert(parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-			src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
-				{
-				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
-				return;
-				}
-			}
-			break;
+			case ENUM_NAMED_DEF: break;	/* already handled */
 			case ENUM_ANON_DEF: break;	/* already handled */
 			}
 			}
@@ -14085,6 +14088,7 @@
 				case CLASS_NAME: break;
 				case CLASS_NAMED_DEF: break;
 				case CLASS_ANON_DEF: break;
+				//! \bug the enums aren't handling const/volatile qualification
 				case ENUM_NAME:
 				{
 				parse_tree& tmp2 =  src.c_array<0>()[i+k];
@@ -14106,7 +14110,79 @@
 					}
 				goto rescan;
 				}
-				case ENUM_NAMED_DEF: break;
+				case ENUM_NAMED_DEF:
+				{	// can only define once
+				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
+				if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_enum_multidef.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'enum ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM("' already defined (C++98 3.2p1)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					goto rescan;
+					}
+				// One Definition Rule states that conflicting enum, struct, or class must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_union_as_enum.hpp
+						//! \test zcc/decl.C99/Error_union_as_enum2.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C++98 One Definition Rule)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_struct_as_enum.hpp
+						//! \test zcc/decl.C99/Error_struct_as_enum2.hpp
+						//! \test zcc/decl.C99/Error_class_as_enum.hpp
+						//! \test zcc/decl.C99/Error_class_as_enum2.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(" declared as ");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					INC_INFORM(text_from_keyword(*tmp3));
+					INFORM(" (C++98 One Definition Rule)");
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("struct");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"struct"));
+					goto rescan;
+					}
+				//! \test zcc/decl.C99/Pass_enum_def.hpp
+				// enum-specifier doesn't have a specific declaration mode
+				const type_system::type_index tmp3 = parse_tree::types->register_enum_def_CPP(tmp2.index_tokens[1].token.first,active_namespace,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
+				assert(parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace)==tmp3);
+				tmp2.type_code.set_type(tmp3);	// C++: enums are own type
+				tmp2.flags |= PARSE_ENUM_TYPE;
+				if (!record_enum_values(*tmp2.c_array<2>(),tmp3,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+					{
+					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+					return;
+					}
+				}
+				break;
 				case ENUM_ANON_DEF:
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.hpp
@@ -14842,77 +14918,7 @@
 			}
 			break;
 			case ENUM_NAME: break;	/* already handled */
-			case ENUM_NAMED_DEF:
-			{	// can only define once
-			if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_enum_multidef.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'enum ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM("' already defined (C++98 3.2p1)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// One Definition Rule states that conflicting enum, struct, or class must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_union_as_enum.hpp
-					//! \test zcc/decl.C99/Error_union_as_enum2.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C++98 One Definition Rule)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_struct_as_enum.hpp
-					//! \test zcc/decl.C99/Error_struct_as_enum2.hpp
-					//! \test zcc/decl.C99/Error_class_as_enum.hpp
-					//! \test zcc/decl.C99/Error_class_as_enum2.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INC_INFORM(" declared as ");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				INC_INFORM(text_from_keyword(*tmp2));
-				INFORM(" (C++98 One Definition Rule)");
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-				goto reparse;
-				}
-			//! \test zcc/decl.C99/Pass_enum_def.hpp
-			// enum-specifier doesn't have a specific declaration mode
-			const type_system::type_index tmp2 = parse_tree::types->register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			assert(parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-			src.c_array<0>()[i].type_code.set_type(tmp2);	// C++: enums are own type
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp2,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
-				{
-				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
-				return;
-				}
-			}
-			break;
+			case ENUM_NAMED_DEF: break;	/* already handled */
 			case ENUM_ANON_DEF: break;	/* already handled */
 			}
 			};

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-12-11 08:47:10 UTC (rev 552)
+++ trunk/CSupport.cpp.in	2010-12-18 19:32:58 UTC (rev 553)
@@ -13167,6 +13167,9 @@
 				src.DeleteNSlotsAt<0>(src.size<0>()-i,i);
 				return;
 				};
+#/*cut-nocpp*/
+			const bool semicolon_terminated_decl = src.size<0>()-i > j && robust_token_is_char<';'>(src.data<0>()[i+j]); 
+#/*cut-nocpp*/
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
 			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse
@@ -13179,6 +13182,7 @@
 				case STRUCT_NAME: break;
 				case STRUCT_NAMED_DEF: break;
 				case STRUCT_ANON_DEF: break;
+				//! \bug the enums aren't handling const/volatile qualification
 				case ENUM_NAME:
 				{	// C99 6.7.2.3: allowed only after name is defined
 				// XXX C: enums are int, but the optimizers will want to know
@@ -13200,7 +13204,76 @@
 					};
 				goto rescan;
 				}
-				case ENUM_NAMED_DEF: break;
+				case ENUM_NAMED_DEF:
+				{	// can only define once
+				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
+				if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_enum_multidef.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'enum ");
+					INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+					INFORM("' already defined (C99 6.7.2.3p1)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					goto rescan;
+					}
+				// C1X 6.7.2.3p2 states that conflicting union or struct must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_union_as_enum.h
+						//! \test zcc/decl.C99/Error_union_as_enum2.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C99 6.7.2.3p2)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_struct_as_enum.h
+						//! \test zcc/decl.C99/Error_struct_as_enum2.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as struct (C99 6.7.2.3p2)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("struct");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"struct"));
+					goto rescan;
+					}
+				
+				// enum-specifier doesn't have a specific declaration mode
+				//! \test zcc/decl.C99/Pass_enum_def.h
+				const type_system::type_index tmp3 = parse_tree::types->register_enum_def(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
+				assert(parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first)==tmp3);
+				tmp2.type_code.set_type(tmp3);	// C: enums are int (although we'd like to extend this a bit)
+				tmp2.flags |= PARSE_ENUM_TYPE;
+				if (!record_enum_values(*tmp2.c_array<2>(),tmp3,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+					{
+					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+					return;
+					}
+				}
+				break;
 				case ENUM_ANON_DEF:
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
@@ -13700,74 +13773,7 @@
 			}
 			break;
 			case ENUM_NAME: break;	/* already handled */
-			case ENUM_NAMED_DEF:
-			{	// can only define once
-			if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_enum_multidef.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'enum ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-				INFORM("' already defined (C99 6.7.2.3p1)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// C1X 6.7.2.3p2 states that conflicting union or struct must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_union_as_enum.h
-					//! \test zcc/decl.C99/Error_union_as_enum2.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C99 6.7.2.3p2)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_struct_as_enum.h
-					//! \test zcc/decl.C99/Error_struct_as_enum2.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as struct (C99 6.7.2.3p2)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-				goto reparse;
-				}
-				
-			// enum-specifier doesn't have a specific declaration mode
-			//! \test zcc/decl.C99/Pass_enum_def.h
-			const type_system::type_index tmp2 = parse_tree::types->register_enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			assert(parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-			src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
-				{
-				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
-				return;
-				}
-			}
-			break;
+			case ENUM_NAMED_DEF: break;	/* already handled */
 			case ENUM_ANON_DEF: break;	/* already handled */
 			}
 			}
@@ -14214,6 +14220,9 @@
 				src.DeleteNSlotsAt<0>(src.size<0>()-i,i);
 				return;
 				};
+#/*cut-nocpp*/
+			const bool semicolon_terminated_decl = src.size<0>()-i > j && robust_token_is_char<';'>(src.data<0>()[i+j]); 
+#/*cut-nocpp*/
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
 			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse
@@ -14229,6 +14238,7 @@
 				case CLASS_NAME: break;
 				case CLASS_NAMED_DEF: break;
 				case CLASS_ANON_DEF: break;
+				//! \bug the enums aren't handling const/volatile qualification
 				case ENUM_NAME:
 				{
 				parse_tree& tmp2 =  src.c_array<0>()[i+k];
@@ -14250,7 +14260,79 @@
 					}
 				goto rescan;
 				}
-				case ENUM_NAMED_DEF: break;
+				case ENUM_NAMED_DEF:
+				{	// can only define once
+				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
+				if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_enum_multidef.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'enum ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM("' already defined (C++98 3.2p1)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					goto rescan;
+					}
+				// One Definition Rule states that conflicting enum, struct, or class must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_union_as_enum.hpp
+						//! \test zcc/decl.C99/Error_union_as_enum2.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C++98 One Definition Rule)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_struct_as_enum.hpp
+						//! \test zcc/decl.C99/Error_struct_as_enum2.hpp
+						//! \test zcc/decl.C99/Error_class_as_enum.hpp
+						//! \test zcc/decl.C99/Error_class_as_enum2.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(" declared as ");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					INC_INFORM(text_from_keyword(*tmp3));
+					INFORM(" (C++98 One Definition Rule)");
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("struct");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"struct"));
+					goto rescan;
+					}
+				//! \test zcc/decl.C99/Pass_enum_def.hpp
+				// enum-specifier doesn't have a specific declaration mode
+				const type_system::type_index tmp3 = parse_tree::types->register_enum_def_CPP(tmp2.index_tokens[1].token.first,active_namespace,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
+				assert(parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace)==tmp3);
+				tmp2.type_code.set_type(tmp3);	// C++: enums are own type
+				tmp2.flags |= PARSE_ENUM_TYPE;
+				if (!record_enum_values(*tmp2.c_array<2>(),tmp3,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+					{
+					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+					return;
+					}
+				}
+				break;
 				case ENUM_ANON_DEF:
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.hpp
@@ -14986,77 +15068,7 @@
 			}
 			break;
 			case ENUM_NAME: break;	/* already handled */
-			case ENUM_NAMED_DEF:
-			{	// can only define once
-			if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_enum_multidef.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'enum ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM("' already defined (C++98 3.2p1)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// One Definition Rule states that conflicting enum, struct, or class must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_union_as_enum.hpp
-					//! \test zcc/decl.C99/Error_union_as_enum2.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C++98 One Definition Rule)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_struct_as_enum.hpp
-					//! \test zcc/decl.C99/Error_struct_as_enum2.hpp
-					//! \test zcc/decl.C99/Error_class_as_enum.hpp
-					//! \test zcc/decl.C99/Error_class_as_enum2.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INC_INFORM(" declared as ");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				INC_INFORM(text_from_keyword(*tmp2));
-				INFORM(" (C++98 One Definition Rule)");
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-				goto reparse;
-				}
-			//! \test zcc/decl.C99/Pass_enum_def.hpp
-			// enum-specifier doesn't have a specific declaration mode
-			const type_system::type_index tmp2 = parse_tree::types->register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			assert(parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-			src.c_array<0>()[i].type_code.set_type(tmp2);	// C++: enums are own type
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp2,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
-				{
-				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
-				return;
-				}
-			}
-			break;
+			case ENUM_NAMED_DEF: break;	/* already handled */
 			case ENUM_ANON_DEF: break;	/* already handled */
 			}
 			};



From zaimoni at mail.berlios.de  Wed Dec 22 22:00:14 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 22 Dec 2010 22:00:14 +0100
Subject: [Zcplusplus-commits] r554 - trunk/tests/zcc/decl.C99
Message-ID: <20101222210014.B55D24801D6@sheep.berlios.de>

Author: zaimoni
Date: 2010-12-22 22:00:14 +0100 (Wed, 22 Dec 2010)
New Revision: 554

Modified:
   trunk/tests/zcc/decl.C99/Error_enum_overflow.hpp
   trunk/tests/zcc/decl.C99/Error_enum_typedef2.hpp
Log:
test the error we want to test

Modified: trunk/tests/zcc/decl.C99/Error_enum_overflow.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_overflow.hpp	2010-12-18 19:32:58 UTC (rev 553)
+++ trunk/tests/zcc/decl.C99/Error_enum_overflow.hpp	2010-12-22 21:00:14 UTC (rev 554)
@@ -7,4 +7,4 @@
 enum bad_enum {
 	x = UINTMAX_MAX,
 	y
-}
+};

Modified: trunk/tests/zcc/decl.C99/Error_enum_typedef2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_typedef2.hpp	2010-12-18 19:32:58 UTC (rev 553)
+++ trunk/tests/zcc/decl.C99/Error_enum_typedef2.hpp	2010-12-22 21:00:14 UTC (rev 554)
@@ -8,6 +8,6 @@
 
 enum bad_test {
 	x_factor = 1
-}
+};
 
 }



From zaimoni at mail.berlios.de  Wed Dec 22 22:50:38 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 22 Dec 2010 22:50:38 +0100
Subject: [Zcplusplus-commits] r555 - trunk
Message-ID: <20101222215038.84EB14801D6@sheep.berlios.de>

Author: zaimoni
Date: 2010-12-22 22:50:38 +0100 (Wed, 22 Dec 2010)
New Revision: 555

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
formal verifiability improvement to declaration-terminated-by-scope errors

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-12-22 21:00:14 UTC (rev 554)
+++ trunk/CSupport.cpp	2010-12-22 21:50:38 UTC (rev 555)
@@ -13003,26 +13003,30 @@
 		// pre-scan for declaration-like items
 		{
 rescan:
-		size_t j = 0;
 		pre_invariant_decl_scanner.clear(); // there's a lot of rescanning paths, so conserve lines of code
-		while(pre_invariant_decl_scanner(src.data<0>()[i+j++]) && src.size<0>()-i > j);
-		if (!pre_invariant_decl_scanner.empty())
-			{	// if we ran out of tokens, bad
-			if (src.size<0>()-i <= pre_invariant_decl_scanner.size())
+		{	// wouldn't work for unnamed function parameters
+		const size_t strict_ub = src.size<0>()-i;
+		const parse_tree* const origin = src.data<0>()+i;
+		while(pre_invariant_decl_scanner(origin[pre_invariant_decl_scanner.size()]))
+			// if we ran out of tokens, bad
+			if (strict_ub <= pre_invariant_decl_scanner.size())
 				{	// unterminated declaration, top-level
 				//! \test zcc/decl.C99/Error_extern_scope.h
 				//! \test zcc/decl.C99/Error_static_scope.h
 				//! \test zcc/decl.C99/Error_typedef_scope.h
 				//! \test zcc/decl.C99/Error_register_scope.h
 				//! \test zcc/decl.C99/Error_auto_scope.h
-				message_header(src.data<0>()[i].index_tokens[0]);
+				message_header(origin->index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("declaration cut off by end of scope (C99 6.7p1)");
 				zcc_errors.inc_error();
 				// remove from parse
-				src.DeleteNSlotsAt<0>(src.size<0>()-i,i);
+				src.DeleteNSlotsAt<0>(strict_ub,i);
 				return;
 				};
+		}
+		if (!pre_invariant_decl_scanner.empty())
+			{
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
 			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse
@@ -14050,12 +14054,13 @@
 		// pre-scan for declaration-like items
 		{
 rescan:
-		size_t j = 0;
 		pre_invariant_decl_scanner.clear(); // there's a lot of rescanning paths, so conserve lines of code
-		while(pre_invariant_decl_scanner(src.data<0>()[i+j++]) && src.size<0>()-i > j);
-		if (!pre_invariant_decl_scanner.empty())
-			{	// if we ran out of tokens, bad
-			if (src.size<0>()-i <= pre_invariant_decl_scanner.size())
+		{	// wouldn't work for unnamed function parameters
+		const size_t strict_ub = src.size<0>()-i;
+		const parse_tree* const origin = src.data<0>()+i;
+		while(pre_invariant_decl_scanner(origin[pre_invariant_decl_scanner.size()]))
+			// if we ran out of tokens, bad
+			if (strict_ub <= pre_invariant_decl_scanner.size())
 				{	// unterminated declaration, top-level
 				//! \test zcc/decl.C99/Error_extern_scope.hpp
 				//! \test zcc/decl.C99/Error_static_scope.hpp
@@ -14065,14 +14070,17 @@
 				//! \test zcc/decl.C99/Error_virtual_scope.hpp
 				//! \test zcc/decl.C99/Error_friend_scope.hpp
 				//! \test zcc/decl.C99/Error_explicit_scope.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
+				message_header(origin->index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("declaration cut off by end of scope (C++98 7p1)");
 				zcc_errors.inc_error();
 				// remove from parse
-				src.DeleteNSlotsAt<0>(src.size<0>()-i,i);
+				src.DeleteNSlotsAt<0>(strict_ub,i);
 				return;
 				};
+		}
+		if (!pre_invariant_decl_scanner.empty())
+			{
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
 			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-12-22 21:00:14 UTC (rev 554)
+++ trunk/CSupport.cpp.in	2010-12-22 21:50:38 UTC (rev 555)
@@ -13147,28 +13147,32 @@
 		// pre-scan for declaration-like items
 		{
 rescan:
-		size_t j = 0;
 		pre_invariant_decl_scanner.clear(); // there's a lot of rescanning paths, so conserve lines of code
-		while(pre_invariant_decl_scanner(src.data<0>()[i+j++]) && src.size<0>()-i > j);
-		if (!pre_invariant_decl_scanner.empty())
-			{	// if we ran out of tokens, bad
-			if (src.size<0>()-i <= pre_invariant_decl_scanner.size())
+		{	// wouldn't work for unnamed function parameters
+		const size_t strict_ub = src.size<0>()-i;
+		const parse_tree* const origin = src.data<0>()+i;
+		while(pre_invariant_decl_scanner(origin[pre_invariant_decl_scanner.size()]))
+			// if we ran out of tokens, bad
+			if (strict_ub <= pre_invariant_decl_scanner.size())
 				{	// unterminated declaration, top-level
 				//! \test zcc/decl.C99/Error_extern_scope.h
 				//! \test zcc/decl.C99/Error_static_scope.h
 				//! \test zcc/decl.C99/Error_typedef_scope.h
 				//! \test zcc/decl.C99/Error_register_scope.h
 				//! \test zcc/decl.C99/Error_auto_scope.h
-				message_header(src.data<0>()[i].index_tokens[0]);
+				message_header(origin->index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("declaration cut off by end of scope (C99 6.7p1)");
 				zcc_errors.inc_error();
 				// remove from parse
-				src.DeleteNSlotsAt<0>(src.size<0>()-i,i);
+				src.DeleteNSlotsAt<0>(strict_ub,i);
 				return;
 				};
+		}
+		if (!pre_invariant_decl_scanner.empty())
+			{
 #/*cut-nocpp*/
-			const bool semicolon_terminated_decl = src.size<0>()-i > j && robust_token_is_char<';'>(src.data<0>()[i+j]); 
+			const bool semicolon_terminated_decl = robust_token_is_char<';'>(src.data<0>()[i+pre_invariant_decl_scanner.empty()]); 
 #/*cut-nocpp*/
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
 			//! \todo ; means decl terminates w/o identifier 
@@ -14197,12 +14201,13 @@
 		// pre-scan for declaration-like items
 		{
 rescan:
-		size_t j = 0;
 		pre_invariant_decl_scanner.clear(); // there's a lot of rescanning paths, so conserve lines of code
-		while(pre_invariant_decl_scanner(src.data<0>()[i+j++]) && src.size<0>()-i > j);
-		if (!pre_invariant_decl_scanner.empty())
-			{	// if we ran out of tokens, bad
-			if (src.size<0>()-i <= pre_invariant_decl_scanner.size())
+		{	// wouldn't work for unnamed function parameters
+		const size_t strict_ub = src.size<0>()-i;
+		const parse_tree* const origin = src.data<0>()+i;
+		while(pre_invariant_decl_scanner(origin[pre_invariant_decl_scanner.size()]))
+			// if we ran out of tokens, bad
+			if (strict_ub <= pre_invariant_decl_scanner.size())
 				{	// unterminated declaration, top-level
 				//! \test zcc/decl.C99/Error_extern_scope.hpp
 				//! \test zcc/decl.C99/Error_static_scope.hpp
@@ -14212,16 +14217,19 @@
 				//! \test zcc/decl.C99/Error_virtual_scope.hpp
 				//! \test zcc/decl.C99/Error_friend_scope.hpp
 				//! \test zcc/decl.C99/Error_explicit_scope.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
+				message_header(origin->index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("declaration cut off by end of scope (C++98 7p1)");
 				zcc_errors.inc_error();
 				// remove from parse
-				src.DeleteNSlotsAt<0>(src.size<0>()-i,i);
+				src.DeleteNSlotsAt<0>(strict_ub,i);
 				return;
 				};
+		}
+		if (!pre_invariant_decl_scanner.empty())
+			{
 #/*cut-nocpp*/
-			const bool semicolon_terminated_decl = src.size<0>()-i > j && robust_token_is_char<';'>(src.data<0>()[i+j]); 
+			const bool semicolon_terminated_decl = robust_token_is_char<';'>(src.data<0>()[i+pre_invariant_decl_scanner.size()]); 
 #/*cut-nocpp*/
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
 			//! \todo ; means decl terminates w/o identifier 



