From zaimoni at mail.berlios.de  Sat Jan  2 10:11:05 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 2 Jan 2010 10:11:05 +0100
Subject: [Zcplusplus-commits] r318 - in trunk: . Zaimoni.STL tools
Message-ID: <201001020911.o029B5cp000614@sheep.berlios.de>

Author: zaimoni
Date: 2010-01-02 10:10:26 +0100 (Sat, 02 Jan 2010)
New Revision: 318

Modified:
   trunk/CPreproc_autogen.cpp
   trunk/MakeMake.cfg
   trunk/Zaimoni.STL/AutoPtr.hpp
   trunk/tools/MakeMake.py
Log:
ISO build fixes

Modified: trunk/CPreproc_autogen.cpp
===================================================================
--- trunk/CPreproc_autogen.cpp	2009-12-30 21:18:48 UTC (rev 317)
+++ trunk/CPreproc_autogen.cpp	2010-01-02 09:10:26 UTC (rev 318)
@@ -294,7 +294,11 @@
 		char* tmp2 = zaimoni::_new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(sizeof("#ifdef ")-1+identifier_len));
 		strcpy(tmp2,"#ifdef ");
 		strcpy(tmp2+sizeof("#ifdef ")-1,*identifiers);
-		tmp[i] = new(std::nothrow) zaimoni::Token<char>(tmp2,NULL);
+#ifndef ZAIMONI_FORCE_ISO
+		tmp[i] = new zaimoni::Token<char>(tmp2,NULL);
+#else
+		tmp[i] = new zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#ifdef ")-1+identifier_len),NULL);
+#endif
 		if (NULL==tmp[i])
 			{
 			free(tmp2);
@@ -304,7 +308,11 @@
 		tmp2 = zaimoni::_new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(sizeof("#undef ")-1+identifier_len));
 		strcpy(tmp2,"#undef ");
 		strcpy(tmp2+sizeof("#undef ")-1,*identifiers);
+#ifndef ZAIMONI_FORCE_ISO
 		tmp[i+2] = new zaimoni::Token<char>(tmp2,NULL);
+#else
+		tmp[i+2] = new zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#undef ")-1+identifier_len),NULL);
+#endif
 		if (NULL==tmp[i+2])
 			{
 			free(tmp2);
@@ -315,7 +323,11 @@
 		strcpy(tmp2,"#error Undefined Behavior: reserved identifier '");
 		strcpy(tmp2+sizeof("#error Undefined Behavior: reserved identifier '")-1,*identifiers);
 		strcpy(tmp2+sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len,"' defined as macro");
+#ifndef ZAIMONI_FORCE_ISO
 		tmp[i+1] = new zaimoni::Token<char>(tmp2,NULL);
+#else
+		tmp[i+1] = new zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len+sizeof("' defined as macro")-1),NULL);
+#endif
 		if (NULL==tmp[i+1])
 			{
 			free(tmp2);
@@ -354,7 +366,11 @@
 		++identifiers;
 		--identifiers_len;
 		};
+#ifndef ZAIMONI_FORCE_ISO
 	zaimoni::Token<char>* relay = new(std::nothrow) zaimoni::Token<char>(tmp,NULL);
+#else
+	zaimoni::Token<char>* relay = new(std::nothrow) zaimoni::Token<char>(tmp,ZAIMONI_LEN_WITH_NULL(target_len),NULL);
+#endif
 	if (NULL==relay)
 		{
 		free(tmp);

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2009-12-30 21:18:48 UTC (rev 317)
+++ trunk/MakeMake.cfg	2010-01-02 09:10:26 UTC (rev 318)
@@ -9,7 +9,6 @@
 #object_strip = 'strip --preserve-dates --strip-unneeded $*.o'
 
 # defines catalog
-# NDEBUG: release mode
 # ZAIMONI_FORCE_ISO: try to build as ISO C++ rather than with custom memory manager (pre-alpha)
 C_defines = []
 
@@ -19,7 +18,9 @@
 CPP_override_libraries = {}
 
 if 0==C_defines.count('ZAIMONI_FORCE_ISO'):
-	CPP_libraries = '-lz_memory '+CPP_libraries
+	CPP_libraries = '-lz_langconf '+CPP_libraries+' -lz_memory'
+else:
+	CPP_libraries = '-lz_langconf_iso '+CPP_libraries
 
 C_enabled = ''
 C_hard_nonsystem_includedirs = []

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2009-12-30 21:18:48 UTC (rev 317)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2010-01-02 09:10:26 UTC (rev 318)
@@ -302,7 +302,7 @@
 #else
 	explicit _meta_autoarray_ptr() : _ptr(NULL),_size(0) {};
 	explicit _meta_autoarray_ptr(T*& src,size_t src_size) : _ptr(src),_size(src_size) {src = NULL;};
-	explicit _meta_autoarray_ptr(size_t n) : _ptr(_new_buffer<T>(n ? _new_buffer_nonNULL_throws<T>(n) : NULL)),_size(n) {};
+	explicit _meta_autoarray_ptr(size_t n) : _ptr(n ? _new_buffer_nonNULL_throws<T>(n) : NULL),_size(n) {};
 	explicit _meta_autoarray_ptr(const std::nothrow_t& tracer, size_t n) : _ptr(_new_buffer<T>(n)),_size(n) {};
 	explicit _meta_autoarray_ptr(const _meta_autoarray_ptr& src) : _ptr(NULL),_size(0) {*this=src;};
 #endif

Modified: trunk/tools/MakeMake.py
===================================================================
--- trunk/tools/MakeMake.py	2009-12-30 21:18:48 UTC (rev 317)
+++ trunk/tools/MakeMake.py	2010-01-02 09:10:26 UTC (rev 318)
@@ -155,8 +155,8 @@
 #		LineList.append('\t '+ join(map(lambda x: '-I '+x,C_hard_nonsystem_includedirs),' ') +' -I- \\\n')
 #	if C_soft_nonsystem_includedirs:
 #		LineList.append('\t '+ join(map(lambda x: '-I '+x,C_soft_nonsystem_includedirs),' ') +' \\\n')
-#	if C_defines:
-#		LineList.append('\t '+ join(map(lambda x: '-D'+x,C_defines),' ') +' \\\n')
+	if C_defines:
+		LineList.append('\t '+ join(map(lambda x: '-D'+x,C_defines),' ') +' \\\n')
 	if C_assembly_preprocessing:
 		LineList.append('\t -o $*.s -S -xc++ -pipe $<\n')
 		LineList.append('\t'+C_assembly_preprocessing+'\n')
@@ -171,8 +171,8 @@
 #		LineList.append('\t '+ join(map(lambda x: '-I '+x,C_hard_nonsystem_includedirs),' ') +' -I- \\\n')
 #	if C_soft_nonsystem_includedirs:
 #		LineList.append('\t '+ join(map(lambda x: '-I '+x,C_soft_nonsystem_includedirs),' ') +' \\\n')
-#	if C_defines:
-#		LineList.append('\t '+ join(map(lambda x: '-D'+x,C_defines),' ') +' \\\n')
+	if C_defines:
+		LineList.append('\t '+ join(map(lambda x: '-D'+x,C_defines),' ') +' \\\n')
 	if C_assembly_preprocessing:
 		LineList.append('\t -o $*.s -S -xc -pipe $<\n')
 		LineList.append('\t'+C_assembly_preprocessing+'\n')



From zaimoni at mail.berlios.de  Sun Jan  3 02:54:57 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 3 Jan 2010 02:54:57 +0100
Subject: [Zcplusplus-commits] r319 - in trunk: . Zaimoni.STL
Message-ID: <201001030154.o031svhf026340@sheep.berlios.de>

Author: zaimoni
Date: 2010-01-03 02:54:51 +0100 (Sun, 03 Jan 2010)
New Revision: 319

Modified:
   trunk/CSupport.cpp
   trunk/Zaimoni.STL/AutoPtr.hpp
   trunk/type_spec.cpp
Log:
ISO build fixes (should compile now)

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-01-02 09:10:26 UTC (rev 318)
+++ trunk/CSupport.cpp	2010-01-03 01:54:51 UTC (rev 319)
@@ -4664,11 +4664,7 @@
 #endif
 		src.c_array<0>()->destroy();
 		parse_tree* const tmp2 = src.c_array<0>();
-#ifdef ZAIMONI_FORCE_ISO
-		src.args[0].first = tmp;
-#else
 		src.args[0] = tmp;
-#endif
 		return tmp2;
 		};
 	return _new_buffer_nonNULL_throws<parse_tree>(1);
@@ -4686,11 +4682,7 @@
 #endif
 		src.c_array<0>()->destroy();
 		free(src.c_array<0>());
-#ifdef ZAIMONI_FORCE_ISO
-		src.args[0].first = tmp;
-#else
 		src.args[0] = tmp;
-#endif
 		}
 }
 

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2010-01-02 09:10:26 UTC (rev 318)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2010-01-03 01:54:51 UTC (rev 319)
@@ -170,7 +170,7 @@
 	explicit _meta_weakautoarray_ptr(T*& src,size_t src_size) : _ptr(src),_size(src_size) {src = NULL;};
 	explicit _meta_weakautoarray_ptr(size_t n) : _ptr(n ? _new_buffer_nonNULL_throws<T>(n) : NULL),_size(n) {};
 	explicit _meta_weakautoarray_ptr(const std::nothrow_t& tracer, size_t n) : _ptr(_new_buffer<T>(n)),_size(n) {};
-	explicit _meta_weakautoarray_ptr(_meta_weakautoarray_ptr& src) : _ptr(NULL),_size(0) {*this=src;};
+	explicit _meta_weakautoarray_ptr(const _meta_weakautoarray_ptr& src) : _ptr(NULL),_size(0) {*this=src;};
 #endif
 	~_meta_weakautoarray_ptr() {_weak_flush(_ptr);};
 
@@ -184,7 +184,11 @@
 	void MoveInto(_meta_weakautoarray_ptr<T>& dest) {dest.reset(_ptr);};
 
 	void TransferOutAndNULL(T*& Target) {_weak_flush(Target); Target = _ptr; this->NULLPtr();}
+#ifndef ZAIMONI_FORCE_ISO
 	bool Resize(size_t n) {return _weak_resize(_ptr,n);};
+#else
+	bool Resize(size_t n) {return _weak_resize(_ptr,_size,n);};
+#endif
 	void FastDeleteIdx(size_t n) {_weak_delete_idx(_ptr,n);};
 #ifndef ZAIMONI_FORCE_ISO
 	void DeleteIdx(size_t n) {_safe_weak_delete_idx(_ptr,n);};
@@ -278,7 +282,7 @@
 #ifndef ZAIMONI_FORCE_ISO
 	const weakautovalarray_ptr_throws& operator=(T* src) {_meta_weakautoarray_ptr<T>::operator=(src); return *this;};
 #endif
-	const weakautovalarray_ptr_throws& operator=(weakautovalarray_ptr_throws& src) {_meta_weakautoarray_ptr<T>::operator=(src); return *this;};
+	const weakautovalarray_ptr_throws& operator=(const weakautovalarray_ptr_throws& src) {_meta_weakautoarray_ptr<T>::operator=(src); return *this;};
 
 	friend void zaimoni::swap(weakautovalarray_ptr_throws& lhs, weakautovalarray_ptr_throws& rhs) {lhs.swap(rhs);};
 };

Modified: trunk/type_spec.cpp
===================================================================
--- trunk/type_spec.cpp	2010-01-02 09:10:26 UTC (rev 318)
+++ trunk/type_spec.cpp	2010-01-03 01:54:51 UTC (rev 319)
@@ -21,17 +21,25 @@
 	if (_size==pointer_power) return;
 	assert(0<_size);
 	const bool shrinking = _size<pointer_power;
+	const size_t pointer_power_copy = pointer_power;
 	const size_t old_ptr_power = pointer_power_after_array_decay();
 	const size_t new_ptr_power = old_ptr_power+(_size-pointer_power);	// modulo arithmetic
 	unsigned char* tmp_first = (shrinking || sizeof(unsigned char*)>new_ptr_power) ? NULL : zaimoni::_new_buffer_nonNULL_throws<unsigned char>(new_ptr_power+1);
+#ifndef ZAIMONI_FORCE_ISO
 	if (!zaimoni::_resize(extent_vector,_size))
+#else
+	if (!zaimoni::_resize(extent_vector,pointer_power,_size))
+#endif
 		{
 		free(tmp_first);
 		throw std::bad_alloc();
 		};
+#ifndef ZAIMONI_FORCE_ISO
+	pointer_power = _size;
+#endif
 	if (!shrinking)
 		{
-		memset(extent_vector+pointer_power,0,sizeof(uintmax_t)*(_size-pointer_power));
+		memset(extent_vector+pointer_power_copy,0,sizeof(uintmax_t)*(_size-pointer_power_copy));
 		if (NULL!=tmp_first)
 			{
 			memcpy(tmp_first,sizeof(unsigned char*)>old_ptr_power ? q_vector.second : q_vector.first,old_ptr_power+1);
@@ -65,13 +73,19 @@
 		}
 	else{
 		if (shrinking)
+#ifndef ZAIMONI_FORCE_ISO
 			ZAIMONI_PASSTHROUGH_ASSERT(zaimoni::_resize(q_vector.first,new_ptr_power+1));
+#else
+			{
+			size_t tmp_size = old_ptr_power+1;
+			ZAIMONI_PASSTHROUGH_ASSERT(zaimoni::_resize(q_vector.first,tmp_size,new_ptr_power+1));
+			}
+#endif
 		else{
 			free(q_vector.first);
 			q_vector.first = tmp_first;
 			}
 		}
-	pointer_power = _size;
 }
 
 // XXX properly operator= in C++, but type_spec has to be POD



From zaimoni at mail.berlios.de  Mon Jan  4 10:13:24 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 4 Jan 2010 10:13:24 +0100
Subject: [Zcplusplus-commits] r320 - trunk/Zaimoni.STL
Message-ID: <201001040913.o049DO8l022749@sheep.berlios.de>

Author: zaimoni
Date: 2010-01-04 10:13:20 +0100 (Mon, 04 Jan 2010)
New Revision: 320

Modified:
   trunk/Zaimoni.STL/MetaRAM.hpp
   trunk/Zaimoni.STL/MetaRAM2.hpp
Log:
lift some template functions that don't actually use the custom memory manager

Modified: trunk/Zaimoni.STL/MetaRAM.hpp
===================================================================
--- trunk/Zaimoni.STL/MetaRAM.hpp	2010-01-03 01:54:51 UTC (rev 319)
+++ trunk/Zaimoni.STL/MetaRAM.hpp	2010-01-04 09:13:20 UTC (rev 320)
@@ -8,6 +8,7 @@
 
 #include <string.h>
 #include "flat_alg.h"
+#include <stdlib.h>
 
 /* ZAIMONI_PROTECT_NONANSI_NONNULL_CHECKING_DEALLOCATORS : code fragment suitable as a guard clause for non-ansi free/delete that can't handle NULL */
 /* good alternative if needed: */
@@ -290,6 +291,38 @@
 	free(_ptr);
 }
 
+// _new_buffer/_new_buffer_nonNULL_throws and _flush [MetaRAM2.hpp] have to be synchronized for ISO C++
+// _new_buffer_nonNULL is in MetaRAM2.hpp, as it depends on Logging.h
+template<typename T>
+inline typename boost::disable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
+_new_buffer(size_t Idx)
+{
+	return new(std::nothrow) T[Idx];
+}
+
+template<typename T>
+inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
+_new_buffer(size_t Idx)
+{
+	return reinterpret_cast<T*>(calloc(Idx,sizeof(T)));
+}
+
+template<typename T>
+inline typename boost::disable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
+_new_buffer_nonNULL_throws(size_t Idx)
+{
+	return new T[Idx];
+}
+
+template<typename T>
+inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
+_new_buffer_nonNULL_throws(size_t Idx)
+{
+	T* tmp = reinterpret_cast<T*>(calloc(Idx,sizeof(T)));
+	if (NULL==tmp) throw std::bad_alloc();
+	return tmp;
+}
+
 }	// end namespace zaimoni
 
 #else	/* not in C++ */

Modified: trunk/Zaimoni.STL/MetaRAM2.hpp
===================================================================
--- trunk/Zaimoni.STL/MetaRAM2.hpp	2010-01-03 01:54:51 UTC (rev 319)
+++ trunk/Zaimoni.STL/MetaRAM2.hpp	2010-01-04 09:13:20 UTC (rev 320)
@@ -9,8 +9,6 @@
 #include "MetaRAM.hpp"
 #ifndef ZAIMONI_FORCE_ISO
 #include "z_memory.h"
-#else
-#include <stdlib.h>
 #endif
 #include "Logging.h"
 
@@ -140,23 +138,10 @@
 
 // How to tell difference between T* (single) and T* (array) in resize/shrink?
 // we don't, assume single
-// note: _new_buffer and _flush have to be synchronized for ISO C++
 
+// _new_buffer_nonNULL and _flush have to be synchronized for ISO C++
+// _new_buffer and _new_buffer_nonNULL_throws are in MetaRAM.hpp (they don't depend on Logging.h)
 template<typename T>
-inline typename boost::disable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
-_new_buffer(size_t Idx)
-{
-	return new(std::nothrow) T[Idx];
-}
-
-template<typename T>
-inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
-_new_buffer(size_t Idx)
-{
-	return reinterpret_cast<T*>(calloc(Idx,sizeof(T)));
-}
-
-template<typename T>
 typename boost::disable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
 _new_buffer_nonNULL(size_t Idx)
 {
@@ -175,22 +160,6 @@
 }
 
 template<typename T>
-inline typename boost::disable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
-_new_buffer_nonNULL_throws(size_t Idx)
-{
-	return new T[Idx];
-}
-
-template<typename T>
-inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
-_new_buffer_nonNULL_throws(size_t Idx)
-{
-	T* tmp = reinterpret_cast<T*>(calloc(Idx,sizeof(T)));
-	if (NULL==tmp) throw std::bad_alloc();
-	return tmp;
-}
-
-template<typename T>
 inline typename boost::disable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, void>::type
 _flush(T* _ptr)
 {



From zaimoni at mail.berlios.de  Mon Jan  4 10:15:12 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 4 Jan 2010 10:15:12 +0100
Subject: [Zcplusplus-commits] r321 - trunk
Message-ID: <201001040915.o049FCYF023332@sheep.berlios.de>

Author: zaimoni
Date: 2010-01-04 10:14:59 +0100 (Mon, 04 Jan 2010)
New Revision: 321

Added:
   trunk/uchar_blob.cpp
   trunk/uchar_blob.hpp
Modified:
   trunk/CSupport.cpp
   trunk/MakeMake.cfg
   trunk/Makefile
   trunk/POSIX.dep
   trunk/struct_type.cpp
   trunk/type_spec.cpp
   trunk/type_spec.hpp
Log:
uchar_blob POD-struct.  Idea yanked from dbm databases.

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-01-04 09:13:20 UTC (rev 320)
+++ trunk/CSupport.cpp	2010-01-04 09:14:59 UTC (rev 321)
@@ -1,6 +1,6 @@
 // CSupport.cpp
 // support for C/C++ parsing
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
 #include "CSupport.hpp"
 
@@ -4805,7 +4805,7 @@
 			cancel_outermost_parentheses(src.c_array<0>()[i].c_array<1>()[0]);
 			cancel_outermost_parentheses(src.c_array<0>()[i].c_array<0>()[0]);
 			src.type_code.set_type(C_TYPE::NOT_VOID);
-			src.c_array<0>()[i].type_code.q_vector.second[0] |= type_spec::lvalue;
+			src.c_array<0>()[i].type_code.q_vector.front() |= type_spec::lvalue;
 			assert(is_array_deref(src.data<0>()[i]));
 			return true;
 			};

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2010-01-04 09:13:20 UTC (rev 320)
+++ trunk/MakeMake.cfg	2010-01-04 09:14:59 UTC (rev 321)
@@ -1,6 +1,6 @@
 ########
-ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','filesystem','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
-				'zcc':('zcc','errors','langroute','AtomicString','str_aux','filesystem','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
+ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','filesystem','uchar_blob','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
+				'zcc':('zcc','errors','langroute','AtomicString','str_aux','filesystem','uchar_blob','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
 MainPrograms = ['z_cpp','zcc']
 
 # process control

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2010-01-04 09:13:20 UTC (rev 320)
+++ trunk/Makefile	2010-01-04 09:14:59 UTC (rev 321)
@@ -15,11 +15,11 @@
 include POSIX.dep
 
 z_cpp.exe : $(OBJECTS_Z_CPP_LINK_PRIORITY)
-	g++ $(LINK_FLAGS) -oz_cpp.exe $(OBJECTS_Z_CPP) -lz_memory  -lz_langconf -lz_log_adapter -lz_stdio_log -lz_mutex -lz_format_util
+	g++ $(LINK_FLAGS) -oz_cpp.exe $(OBJECTS_Z_CPP) -lz_langconf  -lz_langconf -lz_log_adapter -lz_stdio_log -lz_mutex -lz_format_util -lz_memory
 	strip --preserve-dates --strip-unneeded z_cpp.exe
 
 zcc.exe : $(OBJECTS_ZCC_LINK_PRIORITY)
-	g++ $(LINK_FLAGS) -ozcc.exe $(OBJECTS_ZCC) -lz_memory  -lz_langconf -lz_log_adapter -lz_stdio_log -lz_mutex -lz_format_util
+	g++ $(LINK_FLAGS) -ozcc.exe $(OBJECTS_ZCC) -lz_langconf  -lz_langconf -lz_log_adapter -lz_stdio_log -lz_mutex -lz_format_util -lz_memory
 	strip --preserve-dates --strip-unneeded zcc.exe
 
 # inference rules

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-01-04 09:13:20 UTC (rev 320)
+++ trunk/POSIX.dep	2010-01-04 09:14:59 UTC (rev 321)
@@ -1,8 +1,8 @@
-OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
-OBJECTS_Z_CPP_LINK_PRIORITY = struct_type.o ParseTree.o CSupport.o type_spec.o type_system.o str_aux.o CPreproc.o errors.o z_cpp.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o uchar_blob.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
+OBJECTS_Z_CPP_LINK_PRIORITY = uchar_blob.o struct_type.o CSupport.o type_spec.o CPreproc_autogen.o z_cpp.o CPreproc.o load_src.o errors.o ParseTree.o type_system.o str_aux.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
-OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = struct_type.o ParseTree.o CSupport.o type_spec.o type_system.o str_aux.o CPreproc.o errors.o zcc.o ZParser.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o uchar_blob.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
+OBJECTS_ZCC_LINK_PRIORITY = uchar_blob.o struct_type.o CSupport.o type_spec.o CPreproc_autogen.o zcc.o CPreproc.o load_src.o errors.o ParseTree.o type_system.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
 # dependencies
 z_cpp.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_aux.hpp
@@ -11,12 +11,13 @@
 AtomicString.o: AtomicString.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 str_aux.o: str_aux.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 filesystem.o: filesystem.h Zaimoni.STL/Compiler.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h
+uchar_blob.o: uchar_blob.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp
 CPUInfo.o: CPUInfo.hpp unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
-struct_type.o: struct_type.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
-type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
-ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport.o: CSupport.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+struct_type.o: struct_type.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp
+type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
+ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
+type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
+CSupport.o: CSupport.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp uchar_blob.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -26,8 +27,8 @@
 unsigned_aux.o: unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 Trigraph.o: Trigraph.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 Flat_UNI.o: Flat_UNI.hpp CSupport.hpp Zaimoni.STL/MetaRAM2.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
-load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
-CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/comptest.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
+CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
-zcc.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
-ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+zcc.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp weak_token.hpp uchar_blob.hpp Zaimoni.STL/Lexparse/std.h
+ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp

Modified: trunk/struct_type.cpp
===================================================================
--- trunk/struct_type.cpp	2010-01-04 09:13:20 UTC (rev 320)
+++ trunk/struct_type.cpp	2010-01-04 09:14:59 UTC (rev 321)
@@ -1,4 +1,5 @@
 // struct_type.cpp
+// (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
 #include "struct_type.hpp"
 #include "Zaimoni.STL/Pure.C/auto_int.h"
@@ -27,7 +28,7 @@
 #ifndef ZAIMONI_NULL_REALLY_IS_ZERO
 #error must implement proper clearing for data_field_spec
 #endif
-	zaimoni::autotransform_n(data_field_spec.c_array(),src.data_field_spec.data(),data_field_spec.size(),value_copy);
+	zaimoni::autotransform_n(data_field_spec.c_array(),src.data_field_spec.data(),data_field_spec.size(),type_spec::value_copy);
 	assert(syntax_ok());
 }
 
@@ -56,7 +57,7 @@
 #ifndef ZAIMONI_NULL_REALLY_IS_ZERO
 #error must implement proper clearing for tmp_data_field_spec
 #endif
-		zaimoni::autotransform_n(tmp_data_field_spec.c_array(),src.data_field_spec.data(),src_field_count,value_copy);
+		zaimoni::autotransform_n(tmp_data_field_spec.c_array(),src.data_field_spec.data(),src_field_count,type_spec::value_copy);
 
 		if (src_field_count<=now_field_count)
 			data_field_names = src.data_field_names;

Modified: trunk/type_spec.cpp
===================================================================
--- trunk/type_spec.cpp	2010-01-04 09:13:20 UTC (rev 320)
+++ trunk/type_spec.cpp	2010-01-04 09:14:59 UTC (rev 321)
@@ -1,5 +1,5 @@
 // type_spec.cpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
 #include "type_spec.hpp"
 
@@ -8,12 +8,12 @@
 
 void type_spec::set_static_array_size(size_t _size)
 {
+	// expand pointer_power_after_array_decay() to be ACID
+	q_vector.resize(pointer_power+(0<_size)+1);
 	static_array_size = _size;
 	if (0==_size) return;
-	if (sizeof(unsigned char*)<=pointer_power_after_array_decay())
-		q_vector.first[0] |= lvalue;
-	else
-		q_vector.second[0] |= lvalue;
+	// XXX this may well require a more substantial recalculation XXX
+	q_vector.front() |= lvalue;
 }
 
 void type_spec::set_pointer_power(size_t _size)
@@ -24,14 +24,16 @@
 	const size_t pointer_power_copy = pointer_power;
 	const size_t old_ptr_power = pointer_power_after_array_decay();
 	const size_t new_ptr_power = old_ptr_power+(_size-pointer_power);	// modulo arithmetic
-	unsigned char* tmp_first = (shrinking || sizeof(unsigned char*)>new_ptr_power) ? NULL : zaimoni::_new_buffer_nonNULL_throws<unsigned char>(new_ptr_power+1);
+	// zaimoni::_resize always succeeds when shrinking; if it fails, then reverting q_vector's resize 
+	// is a shrinking operation which always succeeds.
+	q_vector.resize(new_ptr_power+1);
 #ifndef ZAIMONI_FORCE_ISO
 	if (!zaimoni::_resize(extent_vector,_size))
 #else
 	if (!zaimoni::_resize(extent_vector,pointer_power,_size))
 #endif
 		{
-		free(tmp_first);
+		q_vector.resize(old_ptr_power+1);
 		throw std::bad_alloc();
 		};
 #ifndef ZAIMONI_FORCE_ISO
@@ -40,110 +42,48 @@
 	if (!shrinking)
 		{
 		memset(extent_vector+pointer_power_copy,0,sizeof(uintmax_t)*(_size-pointer_power_copy));
-		if (NULL!=tmp_first)
-			{
-			memcpy(tmp_first,sizeof(unsigned char*)>old_ptr_power ? q_vector.second : q_vector.first,old_ptr_power+1);
-			size_t i = old_ptr_power;
-			while(i<new_ptr_power) q_vector.first[i++] = lvalue;
-			q_vector.first[new_ptr_power] = '\0';
-			}
+		size_t i = old_ptr_power;
+		while(i<new_ptr_power) q_vector.c_array()[i++] = lvalue;
+		// q_vector.second[new_ptr_power] = '\0';	// handled by uchar_blob
 		};
-	if (sizeof(unsigned char*)>old_ptr_power)
-		{
-		if (sizeof(unsigned char*)>new_ptr_power)
-			{
-			if (shrinking)
-				memset(q_vector.second+new_ptr_power,0,old_ptr_power-new_ptr_power);
-			else{
-				size_t i = old_ptr_power;
-				while(i<new_ptr_power) q_vector.second[i++] = lvalue;
-				q_vector.second[new_ptr_power] = '\0';
-				}
-			}
-		else
-			q_vector.first = tmp_first;
-		}
-	else if (sizeof(unsigned char*)>new_ptr_power)
-		{
-		unsigned char tmp[sizeof(unsigned char*)];
-		memcpy(tmp,q_vector.first,new_ptr_power+1);
-		free(q_vector.first);
-		memset(q_vector.second,0,sizeof(unsigned char*));
-		memcpy(q_vector.second,tmp,new_ptr_power+1);
-		}
-	else{
-		if (shrinking)
-#ifndef ZAIMONI_FORCE_ISO
-			ZAIMONI_PASSTHROUGH_ASSERT(zaimoni::_resize(q_vector.first,new_ptr_power+1));
-#else
-			{
-			size_t tmp_size = old_ptr_power+1;
-			ZAIMONI_PASSTHROUGH_ASSERT(zaimoni::_resize(q_vector.first,tmp_size,new_ptr_power+1));
-			}
-#endif
-		else{
-			free(q_vector.first);
-			q_vector.first = tmp_first;
-			}
-		}
 }
 
 // XXX properly operator= in C++, but type_spec has to be POD
 // ACID, throws std::bad_alloc on failure
 void value_copy(type_spec& dest,const type_spec& src)
 {
-	{
 	type_spec tmp;
 	tmp.clear();
 	tmp.base_type_index = src.base_type_index;
 	tmp.set_static_array_size(src.static_array_size);
 	tmp.set_pointer_power(src.pointer_power);
+	value_copy(tmp.q_vector,src.q_vector);
 	dest.destroy();
 	dest = tmp;
-	}
-
-	const size_t new_ptr_power = dest.pointer_power_after_array_decay();
-	if (sizeof(unsigned char*)<=new_ptr_power)
-		memmove(dest.q_vector.first,src.q_vector.first,new_ptr_power+1);
-	else
-		memmove(dest.q_vector.second,src.q_vector.second,new_ptr_power+1);
-	if (0<dest.pointer_power) memmove(dest.extent_vector,src.extent_vector,sizeof(uintmax_t)*dest.pointer_power);
 }
 
 
 bool type_spec::dereference()
 {
 	const size_t old_ptr_power = pointer_power_after_array_decay();
+	if (0==old_ptr_power) return false;
+//	q_vector.c_array()[old_ptr_power] = '\0';	// redundant, wiped by q_vector.resize()
+	assert(lvalue & q_vector.data()[old_ptr_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
+	q_vector.resize(old_ptr_power);	// lost a level of indirection
 	if (0<pointer_power)
 		{
 		if (0== --pointer_power)
 			{
 			FREE_AND_NULL(extent_vector);
-			q_vector.second[old_ptr_power] = '\0';
-			assert(lvalue & q_vector.second[old_ptr_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
 			}
-		else if (sizeof(unsigned char*)==old_ptr_power)
-			{
-			unsigned char tmp[4];
-			memcpy(tmp,q_vector.first,sizeof(unsigned char*));
-			free(q_vector.first);
-			memcpy(q_vector.second,tmp,sizeof(unsigned char*));
-			assert(lvalue & q_vector.second[old_ptr_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
-			}
 		else{
-			q_vector.first[old_ptr_power] = '\0';
-			assert(lvalue & q_vector.first[old_ptr_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
+			extent_vector = REALLOC(extent_vector,pointer_power*sizeof(*extent_vector));
 			}
 		return true;
 		}
-	else if (0<static_array_size)
-		{
-		static_array_size = 0;
-		q_vector.second[1] = '\0';
-		assert(lvalue & q_vector.second[0]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
-		return true;
-		};
-	return false;
+	assert(0<static_array_size);	// other cause of non-zero pointer power after array decay
+	static_array_size = 0;
+	return true;
 }
 
 void type_spec::clear()
@@ -151,23 +91,14 @@
 	base_type_index = 0;
 	pointer_power = 0;
 	static_array_size = 0;
-	memset(q_vector.second,0,sizeof(q_vector.second));
+	q_vector.init(0);
 	extent_vector = NULL;
 }
 
 void type_spec::destroy()
 {
-	if (0<base_type_index)
-		{
-		FREE_AND_NULL(extent_vector);
-		if (sizeof(unsigned char*)<=pointer_power_after_array_decay())
-			{
-			free(q_vector.first);
-			memset(q_vector.second,0,sizeof(q_vector.second));
-			}
-		}
-	else
-		q_vector.second[0] = '\0';
+	FREE_AND_NULL(extent_vector);
+	q_vector.resize(0);
 	base_type_index = 0;
 	pointer_power = 0;
 	static_array_size = 0;
@@ -175,17 +106,8 @@
 
 void type_spec::set_type(size_t _base_type_index)
 {
-	if (0<base_type_index)
-		{
-		FREE_AND_NULL(extent_vector);
-		if (sizeof(unsigned char*)<=pointer_power_after_array_decay())
-			{
-			free(q_vector.first);
-			memset(q_vector.second,0,sizeof(q_vector.second));
-			}
-		}
-	else
-		q_vector.second[0] = '\0';
+	FREE_AND_NULL(extent_vector);
+	q_vector.resize(0);
 	base_type_index = _base_type_index;
 	pointer_power = 0;
 	static_array_size = 0;
@@ -196,7 +118,7 @@
 	return 	base_type_index==rhs.base_type_index
 		&&	pointer_power==rhs.pointer_power
 		&& 	static_array_size==rhs.static_array_size
-		&& (sizeof(unsigned char*)<=pointer_power_after_array_decay() ? !memcmp(q_vector.first,rhs.q_vector.first,pointer_power_after_array_decay()+1) : !memcmp(q_vector.second,rhs.q_vector.second,pointer_power_after_array_decay()+1))
+		&&  q_vector==rhs.q_vector
 		&& (0==pointer_power || !memcmp(extent_vector,rhs.extent_vector,sizeof(uintmax_t)*pointer_power));
 }
 

Modified: trunk/type_spec.hpp
===================================================================
--- trunk/type_spec.hpp	2010-01-04 09:13:20 UTC (rev 320)
+++ trunk/type_spec.hpp	2010-01-04 09:14:59 UTC (rev 321)
@@ -1,16 +1,20 @@
 // type_spec.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
 #ifndef TYPE_SPEC_HPP
 #define TYPE_SPEC_HPP 1
 
 #include "Zaimoni.STL/POD.hpp"
+#include "uchar_blob.hpp"
 
 // KBB: this really should be a class rather than a struct; it would benefit from having a proper destructor.
 // Unfortunately, new/delete and realloc don't mix -- and this type can have multiple lists of tokens underneath it....
 
 struct type_spec;
 
+// ACID; throws std::bad_alloc on failure
+void value_copy(type_spec& dest, const type_spec& src);
+
 namespace boost {
 
 #define ZAIMONI_TEMPLATE_SPEC template<>
@@ -28,7 +32,7 @@
 	size_t pointer_power;		// use wrappers for altering this (affects valid memory representations) [implement]
 	size_t static_array_size;	// C-ish, but mitigates bloating the type manager; use wrappers for altering this [implement]
 
-	zaimoni::union_pair<unsigned char*,unsigned char[sizeof(unsigned char*)]> q_vector;	// q(ualifier)_vector
+	uchar_blob q_vector;	// q(ualifier)_vector
 	uintmax_t* extent_vector;
 
 	enum typetrait_list {
@@ -44,17 +48,16 @@
 	void set_static_array_size(size_t _size);
 	void set_pointer_power(size_t _size);	// ACID, throws std::bad_alloc on failure
 	bool dereference();
-	unsigned char& qualifier(size_t i) {return sizeof(unsigned char*)>pointer_power_after_array_decay() ? q_vector.second[i] : q_vector.first[i];};
-	template<size_t i> unsigned char& qualifier() {return sizeof(unsigned char*)>pointer_power_after_array_decay() ? q_vector.second[i] : q_vector.first[i];}
+	unsigned char& qualifier(size_t i) {return q_vector.c_array()[i];};
+	template<size_t i> unsigned char& qualifier() {return q_vector.c_array()[i];}
 
 	void clear();	// XXX should be constructor; good way to leak memory in other contexts
 	void destroy();	// XXX should be destructor
 	void set_type(size_t _base_type_index);
 	bool operator==(const type_spec& rhs) const;
 	bool operator!=(const type_spec& rhs) const {return !(*this==rhs);};
+
+	static void value_copy(type_spec& dest, const type_spec& src) {::value_copy(dest,src);};
 };
 
-// ACID; throws std::bad_alloc on failure
-void value_copy(type_spec& dest, const type_spec& src);
-
 #endif

Added: trunk/uchar_blob.cpp
===================================================================
--- trunk/uchar_blob.cpp	2010-01-04 09:13:20 UTC (rev 320)
+++ trunk/uchar_blob.cpp	2010-01-04 09:14:59 UTC (rev 321)
@@ -0,0 +1,64 @@
+// uchar_blob.cpp
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#include "uchar_blob.hpp"
+#include "Zaimoni.STL/MetaRAM.hpp"
+
+void uchar_blob::init(size_t new_size)
+{
+	if (sizeof(unsigned char*)>new_size)
+		memset(_x.first,0,sizeof(sizeof(unsigned char*)));
+	else
+		_x.second = zaimoni::_new_buffer_nonNULL_throws<unsigned char>(new_size);
+	_size = new_size;
+}
+
+void uchar_blob::resize(size_t new_size)
+{
+	if (_size==new_size) return;
+	if (sizeof(unsigned char*)>_size)
+		{
+		if (sizeof(unsigned char*)>new_size)
+			{
+			const size_t min_N = _size<new_size ? _size : new_size;
+			memset(_x.first+min_N,0,(sizeof(unsigned char*)-min_N));
+			_size = new_size;
+			return;
+			}
+		else{
+			unsigned char* tmp = zaimoni::_new_buffer_nonNULL_throws<unsigned char>(new_size);
+			memmove(tmp,_x.first,_size);
+			_x.second = tmp;
+			_size = new_size;
+			return;
+			}
+		}
+	else{
+		if (sizeof(unsigned char*)>new_size)
+			{
+			unsigned char tmp[sizeof(unsigned char*)];
+			memset(tmp,0,sizeof(unsigned char*));
+			memmove(tmp,_x.second,new_size);
+			free(_x.second);
+			memmove(_x.first,tmp,sizeof(unsigned char*));
+			_size = new_size;
+			return;
+			}
+		else{
+			unsigned char* tmp = zaimoni::REALLOC(_x.second,new_size);
+			if (!tmp) throw std::bad_alloc();
+			if (_size<new_size) memset(tmp+_size,0,new_size-_size);
+			_x.second = tmp;
+			_size = new_size;
+			return;
+			}
+		}
+}
+
+void value_copy(uchar_blob& dest,const uchar_blob& src)
+{
+	const size_t src_size = src.size();
+	dest.resize(src_size);
+	if (0<src_size) memcpy(dest.c_array(),src.data(),src_size);
+}
+

Added: trunk/uchar_blob.hpp
===================================================================
--- trunk/uchar_blob.hpp	2010-01-04 09:13:20 UTC (rev 320)
+++ trunk/uchar_blob.hpp	2010-01-04 09:14:59 UTC (rev 321)
@@ -0,0 +1,45 @@
+// uchar_blob.hpp
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#ifndef UCHAR_BLOB_HPP
+#define UCHAR_BLOB_HPP 1
+
+#include "Zaimoni.STL/POD.hpp"
+
+struct uchar_blob;
+void value_copy(uchar_blob& dest,const uchar_blob& src);
+
+namespace boost {
+
+#define ZAIMONI_TEMPLATE_SPEC template<>
+#define ZAIMONI_CLASS_SPEC uchar_blob
+ZAIMONI_POD_STRUCT(ZAIMONI_TEMPLATE_SPEC,ZAIMONI_CLASS_SPEC,char)
+#undef ZAIMONI_CLASS_SPEC
+#undef ZAIMONI_TEMPLATE_SPEC
+
+}
+
+struct uchar_blob
+{
+private:
+	size_t _size;
+	zaimoni::union_pair<unsigned char[sizeof(unsigned char*)],unsigned char*> _x;
+public:
+	// STL glue
+	size_t size() const {return _size;};
+	const unsigned char* data() const {return sizeof(unsigned char*)>_size ? _x.first : _x.second;};
+	unsigned char* c_array() {return sizeof(unsigned char*)>_size ? _x.first : _x.second;};
+	unsigned char& front() {return sizeof(unsigned char*)>_size ? _x.first[0] : _x.second[0];};
+	const unsigned char front() const {return sizeof(unsigned char*)>_size ? _x.first[0] : _x.second[0];};
+
+	void resize(size_t new_size);
+	void init(size_t new_size);
+	static void value_copy(uchar_blob& dest,const uchar_blob& src) {::value_copy(dest,src);};
+};
+
+inline bool operator==(const uchar_blob& lhs, const uchar_blob& rhs)
+{return lhs.size()==rhs.size() && !memcmp(lhs.data(),rhs.data(),lhs.size());}
+
+inline bool operator!=(const uchar_blob& lhs, const uchar_blob& rhs) {return !(lhs==rhs);}
+
+#endif



From zaimoni at mail.berlios.de  Tue Jan  5 08:16:22 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 5 Jan 2010 08:16:22 +0100
Subject: [Zcplusplus-commits] r322 - trunk
Message-ID: <201001050716.o057GMX9017785@sheep.berlios.de>

Author: zaimoni
Date: 2010-01-05 08:16:18 +0100 (Tue, 05 Jan 2010)
New Revision: 322

Modified:
   trunk/uchar_blob.hpp
Log:
STL interface augmentation

Modified: trunk/uchar_blob.hpp
===================================================================
--- trunk/uchar_blob.hpp	2010-01-04 09:14:59 UTC (rev 321)
+++ trunk/uchar_blob.hpp	2010-01-05 07:16:18 UTC (rev 322)
@@ -26,12 +26,21 @@
 	zaimoni::union_pair<unsigned char[sizeof(unsigned char*)],unsigned char*> _x;
 public:
 	// STL glue
-	size_t size() const {return _size;};
 	const unsigned char* data() const {return sizeof(unsigned char*)>_size ? _x.first : _x.second;};
 	unsigned char* c_array() {return sizeof(unsigned char*)>_size ? _x.first : _x.second;};
-	unsigned char& front() {return sizeof(unsigned char*)>_size ? _x.first[0] : _x.second[0];};
-	const unsigned char front() const {return sizeof(unsigned char*)>_size ? _x.first[0] : _x.second[0];};
+	size_t size() const {return _size;};
+	bool empty() const {return 0==_size;};
 
+	unsigned char* begin() {return sizeof(unsigned char*)>_size ? _x.first : _x.second;};
+	const unsigned char* begin() const {return sizeof(unsigned char*)>_size ? _x.first : _x.second;};
+	unsigned char* end() {return (sizeof(unsigned char*)>_size ? _x.first : _x.second)+_size;};
+	const unsigned char* end() const {return (sizeof(unsigned char*)>_size ? _x.first : _x.second)+_size;};
+
+	unsigned char& front() {return *(sizeof(unsigned char*)>_size ? _x.first : _x.second);};
+	const unsigned char front() const {return *(sizeof(unsigned char*)>_size ? _x.first : _x.second);};
+	unsigned char& back() {return (sizeof(unsigned char*)>_size ? _x.first : _x.second)[_size-1];};
+	const unsigned char back() const {return (sizeof(unsigned char*)>_size ? _x.first : _x.second)[_size-1];};
+
 	void resize(size_t new_size);
 	void init(size_t new_size);
 	static void value_copy(uchar_blob& dest,const uchar_blob& src) {::value_copy(dest,src);};



From zaimoni at mail.berlios.de  Tue Jan  5 08:17:13 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 5 Jan 2010 08:17:13 +0100
Subject: [Zcplusplus-commits] r323 - trunk
Message-ID: <201001050717.o057HDc6017841@sheep.berlios.de>

Author: zaimoni
Date: 2010-01-05 08:17:07 +0100 (Tue, 05 Jan 2010)
New Revision: 323

Modified:
   trunk/unsigned_aux.cpp
   trunk/unsigned_aux.hpp
   trunk/unsigned_fixed_int.hpp
Log:
const correctness augmentation; fix formal error in definition of end()

Modified: trunk/unsigned_aux.cpp
===================================================================
--- trunk/unsigned_aux.cpp	2010-01-05 07:16:18 UTC (rev 322)
+++ trunk/unsigned_aux.cpp	2010-01-05 07:17:07 UTC (rev 323)
@@ -143,7 +143,7 @@
 	while(lhs_len > ++i && (rhs || carry));
 }
 
-unsigned int _int_log2(unsigned char* x, size_t x_len)
+unsigned int _int_log2(const unsigned char* const x, size_t x_len)
 {
 	while(0<x_len)
 		{

Modified: trunk/unsigned_aux.hpp
===================================================================
--- trunk/unsigned_aux.hpp	2010-01-05 07:16:18 UTC (rev 322)
+++ trunk/unsigned_aux.hpp	2010-01-05 07:17:07 UTC (rev 323)
@@ -13,7 +13,7 @@
 void _unsigned_sum(unsigned char* lhs, size_t lhs_len, uintmax_t rhs);
 void _unsigned_diff(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs);
 void _unsigned_diff(unsigned char* lhs, size_t lhs_len, uintmax_t rhs);
-unsigned int _int_log2(unsigned char* x, size_t x_len);
+unsigned int _int_log2(const unsigned char* x, size_t x_len);
 void _bitwise_compl(unsigned char* x, size_t x_len);
 void _bitwise_and(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs);
 void _bitwise_xor(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs);
@@ -87,7 +87,7 @@
 	_unsigned_diff(lhs,lhs_len,rhs);
 }
 
-inline unsigned int int_log2(unsigned char* buf, size_t buf_len)
+inline unsigned int int_log2(const unsigned char* buf, size_t buf_len)
 {
 	assert(NULL!=buf);
 	assert(0<buf_len);

Modified: trunk/unsigned_fixed_int.hpp
===================================================================
--- trunk/unsigned_fixed_int.hpp	2010-01-05 07:16:18 UTC (rev 322)
+++ trunk/unsigned_fixed_int.hpp	2010-01-05 07:17:07 UTC (rev 323)
@@ -39,7 +39,7 @@
 	_unsigned_fixed_charint& operator/=(const _unsigned_fixed_charint& RHS);
 	_unsigned_fixed_charint& operator%=(const _unsigned_fixed_charint& RHS);
 
-	unsigned int int_log2() {return ::int_log2(_x,N);};
+	unsigned int int_log2() const {return ::int_log2(_x,N);};
 
 	void set(size_t n)
 		{
@@ -121,8 +121,8 @@
 
 	const unsigned char* begin() const {return _x;};
 	unsigned char* begin() {return _x;};
-	const unsigned char* end() const {return _x+(N-1U);};
-	unsigned char* end() {return _x+(N-1U);};
+	const unsigned char* end() const {return _x+N;};
+	unsigned char* end() {return _x+N;};
 
 	unsigned char front() const {return _x[0];};
 	unsigned char& front() {return _x[0];};



From zaimoni at mail.berlios.de  Wed Jan  6 05:15:06 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 6 Jan 2010 05:15:06 +0100
Subject: [Zcplusplus-commits] r324 - trunk
Message-ID: <201001060415.o064F6ki017568@sheep.berlios.de>

Author: zaimoni
Date: 2010-01-06 05:15:00 +0100 (Wed, 06 Jan 2010)
New Revision: 324

Modified:
   trunk/CPUInfo.cpp
   trunk/CPUInfo.hpp
   trunk/MakeMake.cfg
   trunk/POSIX.dep
Log:
new class unsigned_var_int, basic compile check

Modified: trunk/CPUInfo.cpp
===================================================================
--- trunk/CPUInfo.cpp	2010-01-05 07:17:07 UTC (rev 323)
+++ trunk/CPUInfo.cpp	2010-01-06 04:15:00 UTC (rev 324)
@@ -11,12 +11,13 @@
 void CPUInfo::_init()
 {
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM+1> tmp;
+	unsigned_var_int tmp2;
 
 #define SET_MAXIMUM(A)	\
 	tmp.clear();	\
 	tmp.set((SUCCEED_OR_DIE(VM_MAX_BIT_PLATFORM>=C_char_bit()*C_sizeof_##A()),C_char_bit()*C_sizeof_##A()));	\
 	tmp -= 1;	\
-	unsigned_maxima[std_int_##A-1] = tmp	\
+	unsigned_maxima[std_int_##A-1] = tmp
 
 	SET_MAXIMUM(char);
 	SET_MAXIMUM(short);
@@ -25,10 +26,29 @@
 	SET_MAXIMUM(long_long);
 
 #undef SET_MAXIMUM
+#define SET_MAXIMUM(A)	\
+	tmp2.set_bitcount(VM_MAX_BIT_PLATFORM+1);	\
+	tmp2.clear();	\
+	tmp2.set((SUCCEED_OR_DIE(VM_MAX_BIT_PLATFORM>=C_char_bit()*C_sizeof_##A()),C_char_bit()*C_sizeof_##A()));	\
+	tmp2 -= 1;	\
+	tmp2.set_bitcount(VM_MAX_BIT_PLATFORM);	\
+	tmp2.MoveInto(unsigned_maxima_alt[std_int_##A-1])
 
+	SET_MAXIMUM(char);
+	SET_MAXIMUM(short);
+	SET_MAXIMUM(int);
+	SET_MAXIMUM(long);
+	SET_MAXIMUM(long_long);
+
+#undef SET_MAXIMUM
+
 	size_t i = 0;
 	do	(signed_maxima[i] = unsigned_maxima[i]) >>= 1;
 	while(std_int_long_long> ++i);
+
+	i = 0;
+	do	(signed_maxima_alt[i] = unsigned_maxima_alt[i]) >>= 1;
+	while(std_int_long_long> ++i);
 }
 
 bool CPUInfo::trap_int(const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type) const

Modified: trunk/CPUInfo.hpp
===================================================================
--- trunk/CPUInfo.hpp	2010-01-05 07:17:07 UTC (rev 323)
+++ trunk/CPUInfo.hpp	2010-01-06 04:15:00 UTC (rev 324)
@@ -5,6 +5,7 @@
 #define CPUINFO_HPP
 
 #include "unsigned_fixed_int.hpp"
+#include "unsigned_var_int.hpp"
 
 namespace virtual_machine {
 
@@ -67,6 +68,8 @@
 
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> unsigned_maxima[std_int_enum_max];
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> signed_maxima[std_int_enum_max];
+	unsigned_var_int unsigned_maxima_alt[std_int_enum_max];
+	unsigned_var_int signed_maxima_alt[std_int_enum_max];
 
 	const unsigned short char_bit;
 	const unsigned short sizeof_short;

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2010-01-05 07:17:07 UTC (rev 323)
+++ trunk/MakeMake.cfg	2010-01-06 04:15:00 UTC (rev 324)
@@ -1,6 +1,6 @@
 ########
-ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','filesystem','uchar_blob','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
-				'zcc':('zcc','errors','langroute','AtomicString','str_aux','filesystem','uchar_blob','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
+ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
+				'zcc':('zcc','errors','langroute','AtomicString','str_aux','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
 MainPrograms = ['z_cpp','zcc']
 
 # process control

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-01-05 07:17:07 UTC (rev 323)
+++ trunk/POSIX.dep	2010-01-06 04:15:00 UTC (rev 324)
@@ -1,23 +1,24 @@
-OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o uchar_blob.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
-OBJECTS_Z_CPP_LINK_PRIORITY = uchar_blob.o struct_type.o CSupport.o type_spec.o CPreproc_autogen.o z_cpp.o CPreproc.o load_src.o errors.o ParseTree.o type_system.o str_aux.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
+OBJECTS_Z_CPP_LINK_PRIORITY = unsigned_var_int.o CPUInfo.o unsigned_aux.o uchar_blob.o struct_type.o CSupport.o type_spec.o CPreproc_autogen.o z_cpp.o CPreproc.o load_src.o errors.o ParseTree.o type_system.o str_aux.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o AtomicString.o langroute.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
-OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o uchar_blob.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = uchar_blob.o struct_type.o CSupport.o type_spec.o CPreproc_autogen.o zcc.o CPreproc.o load_src.o errors.o ParseTree.o type_system.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
+OBJECTS_ZCC_LINK_PRIORITY = unsigned_var_int.o CPUInfo.o unsigned_aux.o uchar_blob.o struct_type.o CSupport.o type_spec.o CPreproc_autogen.o zcc.o CPreproc.o load_src.o errors.o ParseTree.o type_system.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o AtomicString.o langroute.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
 # dependencies
-z_cpp.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_aux.hpp
+z_cpp.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
 errors.o: errors.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 langroute.o: langroute.hpp CSupport.hpp Zaimoni.STL/Logging.h Zaimoni.STL/POD.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp
 AtomicString.o: AtomicString.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 str_aux.o: str_aux.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 filesystem.o: filesystem.h Zaimoni.STL/Compiler.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h
 uchar_blob.o: uchar_blob.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp
-CPUInfo.o: CPUInfo.hpp unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
+unsigned_var_int.o: unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp
+CPUInfo.o: CPUInfo.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp
 struct_type.o: struct_type.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp
 type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport.o: CSupport.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp uchar_blob.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport.o: CSupport.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_ut!
 il.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -28,7 +29,7 @@
 Trigraph.o: Trigraph.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 Flat_UNI.o: Flat_UNI.hpp CSupport.hpp Zaimoni.STL/MetaRAM2.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/comptest.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
-CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
-CPreproc_autogen.o: CPreproc.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
-zcc.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp weak_token.hpp uchar_blob.hpp Zaimoni.STL/Lexparse/std.h
+CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+CPreproc_autogen.o: CPreproc.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
+zcc.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
 ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp



From zaimoni at mail.berlios.de  Sun Jan 10 10:37:58 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 10 Jan 2010 10:37:58 +0100
Subject: [Zcplusplus-commits] r325 - trunk
Message-ID: <201001100937.o0A9bwsZ002591@sheep.berlios.de>

Author: zaimoni
Date: 2010-01-10 10:37:43 +0100 (Sun, 10 Jan 2010)
New Revision: 325

Added:
   trunk/unsigned_var_int.cpp
   trunk/unsigned_var_int.hpp
Modified:
   trunk/CPUInfo.cpp
   trunk/CPUInfo.hpp
   trunk/CPreproc_autogen.cpp
   trunk/CSupport.cpp
Log:
internal fork: ZCC_LEGACY_FIXED_INT macro controls fallback to old target unsigned long long implementation.  Also, fix SVN build

Modified: trunk/CPUInfo.cpp
===================================================================
--- trunk/CPUInfo.cpp	2010-01-06 04:15:00 UTC (rev 324)
+++ trunk/CPUInfo.cpp	2010-01-10 09:37:43 UTC (rev 325)
@@ -1,5 +1,5 @@
 // CPUInfo.cpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #include "CPUInfo.hpp"
 #include <algorithm>
@@ -10,29 +10,25 @@
 
 void CPUInfo::_init()
 {
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM+1> tmp;
-	unsigned_var_int tmp2;
 
 #define SET_MAXIMUM(A)	\
 	tmp.clear();	\
 	tmp.set((SUCCEED_OR_DIE(VM_MAX_BIT_PLATFORM>=C_char_bit()*C_sizeof_##A()),C_char_bit()*C_sizeof_##A()));	\
 	tmp -= 1;	\
 	unsigned_maxima[std_int_##A-1] = tmp
+#else
+	unsigned_var_int tmp;
 
-	SET_MAXIMUM(char);
-	SET_MAXIMUM(short);
-	SET_MAXIMUM(int);
-	SET_MAXIMUM(long);
-	SET_MAXIMUM(long_long);
-
-#undef SET_MAXIMUM
 #define SET_MAXIMUM(A)	\
-	tmp2.set_bitcount(VM_MAX_BIT_PLATFORM+1);	\
-	tmp2.clear();	\
-	tmp2.set((SUCCEED_OR_DIE(VM_MAX_BIT_PLATFORM>=C_char_bit()*C_sizeof_##A()),C_char_bit()*C_sizeof_##A()));	\
-	tmp2 -= 1;	\
-	tmp2.set_bitcount(VM_MAX_BIT_PLATFORM);	\
-	tmp2.MoveInto(unsigned_maxima_alt[std_int_##A-1])
+	tmp.set_bitcount(VM_MAX_BIT_PLATFORM+1);	\
+	tmp.clear();	\
+	tmp.set((SUCCEED_OR_DIE(VM_MAX_BIT_PLATFORM>=C_char_bit()*C_sizeof_##A()),C_char_bit()*C_sizeof_##A()));	\
+	tmp -= 1;	\
+	tmp.set_bitcount(VM_MAX_BIT_PLATFORM);	\
+	tmp.MoveInto(unsigned_maxima[std_int_##A-1])
+#endif
 
 	SET_MAXIMUM(char);
 	SET_MAXIMUM(short);
@@ -45,12 +41,9 @@
 	size_t i = 0;
 	do	(signed_maxima[i] = unsigned_maxima[i]) >>= 1;
 	while(std_int_long_long> ++i);
-
-	i = 0;
-	do	(signed_maxima_alt[i] = unsigned_maxima_alt[i]) >>= 1;
-	while(std_int_long_long> ++i);
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 bool CPUInfo::trap_int(const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type) const
 {
 	switch(machine_type)
@@ -86,7 +79,45 @@
 	}
 	return false;
 }
+#else
+bool CPUInfo::trap_int(const unsigned_var_int& src_int,std_int_enum machine_type) const
+{
+	switch(machine_type)
+	{
+	default: return false;
+	case std_int_int:
+	case std_int_long:
+	case std_int_long_long:;
+	}
+	const unsigned int bitcount = C_bit(machine_type);
+	const int target_bytecount = bitcount/CHAR_BIT;
+	const unsigned int target_bitcount = bitcount%CHAR_BIT;
+	assert(VM_MAX_BIT_PLATFORM>=bitcount && 1<=bitcount);
 
+	switch(C_signed_int_representation())
+	{
+	case ones_complement:	{	// bitwise all-ones may be trap (-0)
+							if (0<target_bytecount && target_bytecount>std::count(src_int.data(),src_int.data()+target_bytecount,UCHAR_MAX)) return false;
+							return 0==target_bitcount || (UCHAR_MAX>>(CHAR_BIT-target_bitcount))==((UCHAR_MAX>>(CHAR_BIT-target_bitcount)) & src_int.data()[target_bytecount]);
+							}
+	case twos_complement:		// sign bit only set may be trap -(2^N)
+	case sign_and_magnitude:{	// sign bit only set may be trap (-0)
+							if (0==target_bitcount)
+								{
+								if (1<target_bytecount && target_bytecount-1>std::count(src_int.data(),src_int.data()+(target_bytecount-1U),0)) return false;
+								return (1U<<(CHAR_BIT-1))==src_int.data()[target_bytecount-1];
+								}
+							else{
+								if (0<target_bytecount && target_bytecount>std::count(src_int.data(),src_int.data()+target_bytecount,0)) return false;
+								return (1U<<(CHAR_BIT-1-target_bitcount))==((UCHAR_MAX>>(CHAR_BIT-target_bitcount)) & src_int.data()[target_bytecount]);
+								}
+							}
+	}
+	return false;
+}
+#endif
+
+#ifdef ZCC_LEGACY_FIXED_INT
 void CPUInfo::signed_additive_inverse(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type) const
 {
 	assert(machine_type);
@@ -105,7 +136,28 @@
 		}
 	src_int = tmp;
 }
+#else
+void CPUInfo::signed_additive_inverse(unsigned_var_int& src_int,std_int_enum machine_type) const
+{
+	assert(machine_type);
+	const int signed_int_rep = C_signed_int_representation();
+	if (sign_and_magnitude==signed_int_rep)
+		{
+		src_int.toggle(C_bit(machine_type)-1);
+		return;
+		}
+	unsigned_var_int tmp(unsigned_max(machine_type));
+	tmp -= src_int;
+	if (twos_complement==signed_int_rep)
+		{
+		tmp += 1;
+		tmp.mask_to(C_bit(machine_type));
+		}
+	tmp.MoveInto(src_int);
+}
+#endif
 
+#ifdef ZCC_LEGACY_FIXED_INT
 void CPUInfo::unsigned_additive_inverse(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type) const
 {
 	assert(machine_type);
@@ -115,7 +167,20 @@
 	tmp.mask_to(C_bit(machine_type));
 	src_int = tmp;
 }
+#else
+void CPUInfo::unsigned_additive_inverse(unsigned_var_int& src_int,std_int_enum machine_type) const
+{
+	assert(machine_type);
+	assert(src_int<=unsigned_max(machine_type));
+	unsigned_var_int tmp(0);
+	tmp.resize(src_int.size());
+	tmp -= src_int;
+	tmp.mask_to(C_bit(machine_type));
+	tmp.MoveInto(src_int);
+}
+#endif
 
+#ifdef ZCC_LEGACY_FIXED_INT
 bool CPUInfo::C_promote_integer(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& x,const promotion_info& src_type, const promotion_info& dest_type) const
 {
 	if (src_type.is_signed && x.test(src_type.bitcount-1))
@@ -128,6 +193,20 @@
 		};
 	return dest_type.is_signed && x.test(dest_type.bitcount-1);
 }
+#else
+bool CPUInfo::C_promote_integer(unsigned_var_int& x,const promotion_info& src_type, const promotion_info& dest_type) const
+{
+	if (src_type.is_signed && x.test(src_type.bitcount-1))
+		{
+		if (!dest_type.is_signed)
+			// unsigned integer result: C99 6.3.1.3p2 dictates modulo conversion to unsigned
+			C_cast_signed_to_unsigned(x,src_type.machine_type);
+		else if (dest_type.bitcount>src_type.bitcount)
+			sign_extend(x,src_type.machine_type,dest_type.machine_type);
+		};
+	return dest_type.is_signed && x.test(dest_type.bitcount-1);
+}
+#endif
 
 }	// end namespace virtual_machine
 

Modified: trunk/CPUInfo.hpp
===================================================================
--- trunk/CPUInfo.hpp	2010-01-06 04:15:00 UTC (rev 324)
+++ trunk/CPUInfo.hpp	2010-01-10 09:37:43 UTC (rev 325)
@@ -1,11 +1,14 @@
 // CPUInfo.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #ifndef CPUINFO_HPP
 #define CPUINFO_HPP
 
+#ifdef ZCC_LEGACY_FIXED_INT
 #include "unsigned_fixed_int.hpp"
+#else
 #include "unsigned_var_int.hpp"
+#endif
 
 namespace virtual_machine {
 
@@ -66,10 +69,13 @@
 	CPUInfo(const CPUInfo& src);		// disable copy-construction
 	void operator=(const CPUInfo& src);
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> unsigned_maxima[std_int_enum_max];
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> signed_maxima[std_int_enum_max];
-	unsigned_var_int unsigned_maxima_alt[std_int_enum_max];
-	unsigned_var_int signed_maxima_alt[std_int_enum_max];
+#else
+	unsigned_var_int unsigned_maxima[std_int_enum_max];
+	unsigned_var_int signed_maxima[std_int_enum_max];
+#endif
 
 	const unsigned short char_bit;
 	const unsigned short sizeof_short;
@@ -113,15 +119,26 @@
 																	(std_int_long==x) ? C_char_bit()*C_sizeof_long() : C_char_bit()*C_sizeof_long_long() ;}
 
 	signed_int_rep C_signed_int_representation() const {return (signed_int_rep)(signed_int_representation & 3U);};
+#ifdef ZCC_LEGACY_FIXED_INT
 	bool trap_int(const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type) const;
 	void signed_additive_inverse(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type) const;
 	void unsigned_additive_inverse(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type) const;
 	void sign_extend(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type_from,std_int_enum machine_type_to) const
+#else
+	bool trap_int(const unsigned_var_int& src_int,std_int_enum machine_type) const;
+	void signed_additive_inverse(unsigned_var_int& src_int,std_int_enum machine_type) const;
+	void unsigned_additive_inverse(unsigned_var_int& src_int,std_int_enum machine_type) const;
+	void sign_extend(unsigned_var_int& src_int,std_int_enum machine_type_from,std_int_enum machine_type_to) const
+#endif
 		{
 		signed_additive_inverse(src_int,machine_type_from);
 		signed_additive_inverse(src_int,machine_type_to);
 		};
+#ifdef ZCC_LEGACY_FIXED_INT
 	void C_cast_signed_to_unsigned(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type) const
+#else
+	void C_cast_signed_to_unsigned(unsigned_var_int& src_int,std_int_enum machine_type) const
+#endif
 		{	// C99 6.3.1.3p2 dictates modulo conversion to unsigned
 		if (twos_complement!=C_signed_int_representation() && src_int.test(C_bit(machine_type)-1))
 			{
@@ -136,13 +153,24 @@
 	// use different functions for ptrdiff_t and size_t to future-proof (e.g., DOS has ptrdiff 2 bytes but can go larger than that in object size in some memory models)
 	std_int_enum ptrdiff_t_type() const {return (std_int_enum)((signed_int_representation>>7) & 7U);};
 	std_int_enum size_t_type() const {return (std_int_enum)((signed_int_representation>>7) & 7U);};
+#ifdef ZCC_LEGACY_FIXED_INT
 	const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& unsigned_max(std_int_enum x) const {return unsigned_maxima[x-1];};
 	template<std_int_enum x> const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& unsigned_max() const {return unsigned_maxima[x-1];}
 	const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& signed_max(std_int_enum x) const {return signed_maxima[x-1];};
 	template<std_int_enum x> const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& signed_max() const {return signed_maxima[x-1];}
+#else
+	const unsigned_var_int& unsigned_max(std_int_enum x) const {return unsigned_maxima[x-1];};
+	template<std_int_enum x> const unsigned_var_int& unsigned_max() const {return unsigned_maxima[x-1];}
+	const unsigned_var_int& signed_max(std_int_enum x) const {return signed_maxima[x-1];};
+	template<std_int_enum x> const unsigned_var_int& signed_max() const {return signed_maxima[x-1];}
+#endif
 
 	// return value is weird...it's true iff the promoted x is a negative numeral
+#ifdef ZCC_LEGACY_FIXED_INT
 	bool C_promote_integer(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& x,const promotion_info& src_type, const promotion_info& dest_type) const;
+#else
+	bool C_promote_integer(unsigned_var_int& x,const promotion_info& src_type, const promotion_info& dest_type) const;
+#endif
 };
 
 #undef SELECT_TARGET_WCHAR_T

Modified: trunk/CPreproc_autogen.cpp
===================================================================
--- trunk/CPreproc_autogen.cpp	2010-01-06 04:15:00 UTC (rev 324)
+++ trunk/CPreproc_autogen.cpp	2010-01-10 09:37:43 UTC (rev 325)
@@ -1,5 +1,5 @@
 // CPreproc_autogen.cpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 // class CPreprocessor support for autogenerating headers for arbitrary machine targets.
 
 #include "CPreproc.hpp"
@@ -441,7 +441,11 @@
 		if (1==target_machine.C_sizeof_int()) tmp[LIMITS_CHAR_MAX_LINE]->append('U');
 		}
 	// signed character limits
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> s_max(target_machine.signed_max<virtual_machine::std_int_char>());
+#else
+	unsigned_var_int s_max(target_machine.signed_max<virtual_machine::std_int_char>());
+#endif
 	tmp[LIMITS_SCHAR_MAX_LINE]->append(z_ucharint_toa(s_max,buf+1,10)-1);
 	if (target_machine.char_is_signed_char()) tmp[LIMITS_CHAR_MAX_LINE]->append(buf);
 	const bool twos_complement_non_trapping = virtual_machine::twos_complement==target_machine.C_signed_int_representation() && !bool_options[boolopt::int_traps];
@@ -711,7 +715,11 @@
 	const bool target_is_twos_complement = virtual_machine::twos_complement==target_machine.C_signed_int_representation();
 	char signed_min_metabuf[virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+4)] = "";
 	char* signed_min_buf[virtual_machine::std_int_enum_max] = {signed_min_metabuf, signed_min_metabuf+(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+2*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+3*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+4*(2+(VM_MAX_BIT_PLATFORM/3)+2)};
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp_VM;
+#else
+	unsigned_var_int tmp_VM;
+#endif
 	if (target_is_twos_complement && !bool_options[boolopt::int_traps])
 		{
 		*signed_min_buf[0] = '-';

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-01-06 04:15:00 UTC (rev 324)
+++ trunk/CSupport.cpp	2010-01-10 09:37:43 UTC (rev 325)
@@ -2450,13 +2450,26 @@
 	return (ub<hex_len) ? ub : hex_len;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static unsigned_fixed_int<VM_MAX_BIT_PLATFORM> eval_hex_escape(const char* src, size_t src_len)
+#else
+static unsigned_var_int eval_hex_escape(const char* src, size_t src_len)
+#endif
 {
 	assert(NULL!=src);
 	assert(0<src_len);
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp(0);
+#else
+	unsigned_var_int tmp;
+	tmp.set_bitcount(VM_MAX_BIT_PLATFORM);
+#endif
 #ifndef NDEBUG
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> uchar_max(target_machine->unsigned_max<virtual_machine::std_int_long_long>());
+#else
+	unsigned_var_int uchar_max(target_machine->unsigned_max<virtual_machine::std_int_long_long>());
+#endif
 	uchar_max >>= 4;
 #endif
 	do	{
@@ -2626,7 +2639,11 @@
 		}
 	if ('"' != *(x++)) return false;
 	if (0 == --x_len) return true;	// empty string is legal
+#ifdef ZCC_LEGACY_FIXED_INT
 	const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& uchar_max = target_machine->unsigned_max((wide_string) ? target_machine->UNICODE_wchar_t() : virtual_machine::std_int_char);
+#else
+	const unsigned_var_int& uchar_max = target_machine->unsigned_max((wide_string) ? target_machine->UNICODE_wchar_t() : virtual_machine::std_int_char);
+#endif
 
 	size_t i = 0;
 	do	{
@@ -2653,7 +2670,11 @@
 		}
 	if ('\'' != *(x++)) return false;
 	if (0 == --x_len) return false;	// empty character literal is illegal
+#ifdef ZCC_LEGACY_FIXED_INT
 	const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& uchar_max = target_machine->unsigned_max((wide_string) ? target_machine->UNICODE_wchar_t() : virtual_machine::std_int_char);
+#else
+	const unsigned_var_int& uchar_max = target_machine->unsigned_max((wide_string) ? target_machine->UNICODE_wchar_t() : virtual_machine::std_int_char);
+#endif
 
 	size_t i = 0;
 	do	{
@@ -2967,13 +2988,23 @@
 	{
 	default: return false;
 	case virtual_machine::ones_complement:		{
+#ifdef ZCC_LEGACY_FIXED_INT
 												unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp(0);
+#else
+												unsigned_var_int tmp;
+												tmp.set_bitcount(VM_MAX_BIT_PLATFORM);
+#endif
 												if (VM_MAX_BIT_PLATFORM>target_machine->C_char_bit()) tmp.set(target_machine->C_char_bit());
 												tmp -= 1;
 												return tmp==result;
 												}
 	case virtual_machine::sign_and_magnitude:	{
+#ifdef ZCC_LEGACY_FIXED_INT
 												unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp(0);
+#else
+												unsigned_var_int tmp;
+												tmp.set_bitcount(VM_MAX_BIT_PLATFORM);
+#endif
 												tmp.set(target_machine->C_char_bit()-1);
 												return tmp==result;
 												}
@@ -4095,13 +4126,24 @@
 	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 bool convert_to(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& dest,const C_PPIntCore& src)
+#else
+bool convert_to(unsigned_var_int& dest,const C_PPIntCore& src)
+#endif
 {
 	assert(8==src.radix || 10==src.radix || 16==src.radix);
 	assert(NULL!=src.ptr && 0<src.digit_span);
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	const unsigned_fixed_int<VM_MAX_BIT_PLATFORM> alt_radix(src.radix);
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> strict_ub;
+#else
+	unsigned_var_int alt_radix(src.radix);
+	unsigned_var_int strict_ub;
+	strict_ub.set_bitcount(VM_MAX_BIT_PLATFORM);
+	alt_radix.set_bitcount(VM_MAX_BIT_PLATFORM);
+#endif
 	const char* target = src.ptr;
 	size_t target_len = src.digit_span;
 
@@ -4119,6 +4161,7 @@
 		}
 
 	const char* const end = target+target_len;
+	dest.set_bitcount(VM_MAX_BIT_PLATFORM);
 	dest.clear();
 	dest += InterpretHexadecimalDigit(*target);
 	while(++target!=end)
@@ -4131,9 +4174,17 @@
 }
 
 // forward-declare to handle recursion
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool C99_intlike_literal_to_VM(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& dest, const parse_tree& src);
+#else
+static bool C99_intlike_literal_to_VM(unsigned_var_int& dest, const parse_tree& src);
+#endif
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool _C99_intlike_literal_to_VM(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& dest, const parse_tree& src)
+#else
+static bool _C99_intlike_literal_to_VM(unsigned_var_int& dest, const parse_tree& src)
+#endif
 {
 	assert(C_TYPE::INTEGERLIKE!=src.type_code.base_type_index);
 
@@ -4148,8 +4199,13 @@
 			assert(old.bitcount>=lhs.bitcount);
 			if (lhs.is_signed)
 				{
+#ifdef ZCC_LEGACY_FIXED_INT
 				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_int;
 				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+#else
+				unsigned_var_int lhs_int;
+				unsigned_var_int rhs_int;
+#endif
 				if (	C99_intlike_literal_to_VM(lhs_int,*src.data<1>())
 					&&	C99_intlike_literal_to_VM(rhs_int,*src.data<2>()))
 					{
@@ -4179,6 +4235,7 @@
 	if (C_TESTFLAG_CHAR_LITERAL & src.index_tokens[0].flags)
 		{
 		dest = EvalCharacterLiteral(src.index_tokens[0].token.first,src.index_tokens[0].token.second);
+		dest.set_bitcount(VM_MAX_BIT_PLATFORM);
 		return true;
 		}	
 
@@ -4189,18 +4246,24 @@
 	return true;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool _CPP_intlike_literal_to_VM(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& dest, const parse_tree& src)
+#else
+static bool _CPP_intlike_literal_to_VM(unsigned_var_int& dest, const parse_tree& src)
+#endif
 {
 	//! \todo: similar code for handling LLONG_MIN as above.  Need that only for zcc; can't test in preprocessor as the true reserved word won't make it this far.
 	if (!src.is_atomic()) return false;
 	// intercept true, false
 	if 		(token_is_string<4>(src.index_tokens[0].token,"true"))
 		{
+		dest.set_bitcount(VM_MAX_BIT_PLATFORM);
 		dest = 1;
 		return true;
 		}
 	else if (token_is_string<5>(src.index_tokens[0].token,"false"))
 		{
+		dest.set_bitcount(VM_MAX_BIT_PLATFORM);
 		dest.clear();
 		return true;
 		};
@@ -4232,7 +4295,11 @@
 	return ret;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool C99_intlike_literal_to_VM(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& dest, const parse_tree& src)
+#else
+static bool C99_intlike_literal_to_VM(unsigned_var_int& dest, const parse_tree& src)
+#endif
 {
 	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src);
 
@@ -4251,7 +4318,11 @@
 	return true;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool CPP_intlike_literal_to_VM(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& dest, const parse_tree& src)
+#else
+static bool CPP_intlike_literal_to_VM(unsigned_var_int& dest, const parse_tree& src)
+#endif
 {
 	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src);
 
@@ -4279,10 +4350,18 @@
  * \return -1 : can't decide quickly whether this is a null 
  *         pointer constant
  */
+#ifdef ZCC_LEGACY_FIXED_INT
 int is_null_pointer_constant(const parse_tree& src, func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+int is_null_pointer_constant(const parse_tree& src, func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (!converts_to_integerlike(src.type_code)) return 0;
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp;
+#else
+	unsigned_var_int tmp;
+#endif
 	if (intlike_literal_to_VM(tmp,src)) return tmp==0;
 	return -1;
 }
@@ -4311,7 +4390,11 @@
 			src.type_code.set_type(C_TYPE::INTEGERLIKE);
 			C_PPIntCore parse_tmp;
 			ZAIMONI_PASSTHROUGH_ASSERT(C_PPIntCore::is(src.index_tokens[0].token.first,src.index_tokens[0].token.second,parse_tmp));
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp;
+#else
+			unsigned_var_int tmp;
+#endif
 			const unsigned char type_hint = parse_tmp.hinted_type;
 			const bool no_signed = 1==type_hint%2;
 			const bool no_unsigned = !no_signed && 10==parse_tmp.radix;
@@ -5147,7 +5230,11 @@
 // can't do much syntax-checking or immediate-evaluation here because of binary +/-
 // unary +/- syntax checking out out of place as it's needed by all of the unary operators
 // return code is true for success, false for memory failure
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool VM_to_token(const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
+#else
+static bool VM_to_token(const unsigned_var_int& src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
+#endif
 {
 	const char* const suffix = literal_suffix(base_type_index);
 	char buf[(VM_MAX_BIT_PLATFORM/3)+4];	// null-termination: 1 byte; 3 bytes for type hint
@@ -5165,7 +5252,11 @@
 }
 
 // return code is true for success, false for memory failure
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool VM_to_literal(parse_tree& dest, const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,const parse_tree& src,const type_system& types)
+#else
+static bool VM_to_literal(parse_tree& dest, const unsigned_var_int& src_int,const parse_tree& src,const type_system& types)
+#endif
 {
 	POD_pair<char*,lex_flags> new_token;
 	if (!VM_to_token(src_int,src.type_code.base_type_index,new_token)) return false;
@@ -5224,7 +5315,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_unary_minus(parse_tree& src, const type_system& types,func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_unary_minus(parse_tree& src, const type_system& types,func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(is_C99_unary_operator_expression<'-'>(src));
 	bool is_true = false;
@@ -5240,7 +5335,11 @@
 		{	// unsigned...we're fine
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
 		const type_spec old_type = src.type_code;
+#ifdef ZCC_LEGACY_FIXED_INT
 		unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
+#else
+		unsigned_var_int res_int;
+#endif
 		intlike_literal_to_VM(res_int,*src.data<2>());
 		target_machine->unsigned_additive_inverse(res_int,machine_type);
 
@@ -5543,7 +5642,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool int_has_trapped(parse_tree& src,const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,bool hard_error)
+#else
+static bool int_has_trapped(parse_tree& src,const unsigned_var_int& src_int,bool hard_error)
+#endif
 {
 	assert(C_TYPE::INT<=src.type_code.base_type_index && C_TYPE::INTEGERLIKE>src.type_code.base_type_index);
 	// check for trap representation for signed types
@@ -5653,7 +5756,11 @@
 // eventually recover enough memory for this to complete.
 static bool construct_twos_complement_int_min(parse_tree& dest, const type_system& types, const virtual_machine::std_int_enum machine_type, const parse_tree& src_loc)
 {
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp_int(target_machine->signed_max(machine_type));
+#else
+	unsigned_var_int tmp_int(target_machine->signed_max(machine_type));	// of course, throwing constructor gets in the way
+#endif
 	parse_tree* const tmp = _new_buffer<parse_tree>(1);	// XXX we recycle this variable later
 	if (NULL==tmp) return false;
 	if (!VM_to_literal(*tmp,tmp_int,src_loc,types)) return false;
@@ -5705,11 +5812,19 @@
 	return true;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_bitwise_compl(parse_tree& src, const type_system& types,bool hard_error,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_bitwise_compl(parse_tree& src, const type_system& types,bool hard_error,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(is_bitwise_complement_expression(src));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
+#else
+	unsigned_var_int res_int;
+#endif
 	if (intlike_literal_to_VM(res_int,*src.data<2>())) 
 		{
 		const type_spec old_type = src.type_code;
@@ -6134,7 +6249,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_mult_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_mult_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(is_C99_mult_operator_expression<'*'>(src));
 
@@ -6163,8 +6282,13 @@
 		return true;
 		};
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+#else
+	unsigned_var_int res_int;
+	unsigned_var_int rhs_int;
+#endif
 	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
 	if (lhs_converted && 1==res_int)
@@ -6192,9 +6316,15 @@
 		const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
 		if (old.is_signed)
 			{	// signed integer result: overflow is undefined
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
+#else
+			unsigned_var_int lhs_test(res_int);
+			unsigned_var_int rhs_test(rhs_int);
+			unsigned_var_int ub(target_machine->signed_max(old.machine_type));
+#endif
 			const bool tweak_ub = rhs_negative!=lhs_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation() && !bool_options[boolopt::int_traps];
 			if (rhs_negative) target_machine->signed_additive_inverse(rhs_test,old.machine_type);
 			if (lhs_negative) target_machine->signed_additive_inverse(lhs_test,old.machine_type);
@@ -6247,7 +6377,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(is_C99_mult_operator_expression<'/'>(src));
 
@@ -6285,8 +6419,13 @@
 		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
 		};
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+#else
+	unsigned_var_int res_int;
+	unsigned_var_int rhs_int;
+#endif
 	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
 	if (rhs_converted && rhs_int==1)
@@ -6311,9 +6450,15 @@
 		const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
 		if (old.is_signed)
 			{	// signed integer result
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
+#else
+			unsigned_var_int lhs_test(res_int);
+			unsigned_var_int rhs_test(rhs_int);
+			unsigned_var_int ub(target_machine->signed_max(old.machine_type));
+#endif
 			if (rhs_negative) target_machine->signed_additive_inverse(rhs_test,old.machine_type);
 			if (lhs_negative) target_machine->signed_additive_inverse(lhs_test,old.machine_type);
 			if (rhs_negative!=lhs_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation()) ub += 1;
@@ -6341,7 +6486,11 @@
 			bool round_away = false;
 			if (rhs_negative!=lhs_negative && bool_options[boolopt::int_neg_div_rounds_away_from_zero])
 				{
+#ifdef ZCC_LEGACY_FIXED_INT
 				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_mod_test(lhs_test);
+#else
+				unsigned_var_int lhs_mod_test(lhs_test);
+#endif
 				lhs_mod_test %= rhs_test;
 				round_away = 0!=lhs_mod_test;
 				}
@@ -6384,7 +6533,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_mod_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_mod_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(is_C99_mult_operator_expression<'%'>(src));
 
@@ -6422,8 +6575,13 @@
 		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
 		};
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+#else
+	unsigned_var_int res_int;
+	unsigned_var_int rhs_int;
+#endif
 	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
 	if (rhs_converted && rhs_int==1)
@@ -6450,9 +6608,15 @@
 		const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
 		if (old.is_signed)
 			{	// signed integer result
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
+#else
+			unsigned_var_int lhs_test(res_int);
+			unsigned_var_int rhs_test(rhs_int);
+			unsigned_var_int ub(target_machine->signed_max(old.machine_type));
+#endif
 			if (rhs_negative) target_machine->signed_additive_inverse(rhs_test,old.machine_type);
 			if (lhs_negative) target_machine->signed_additive_inverse(lhs_test,old.machine_type);
 			if (rhs_negative!=lhs_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation()) ub += 1;
@@ -6745,7 +6909,11 @@
 
 // this one hides a slight inefficiency: negative literals take 2 dynamic memory allocations, positive literals take one
 // return code is true for success, false for memory failure
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool VM_to_signed_literal(parse_tree& x,const bool is_negative, const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,const parse_tree& src,const type_system& types)
+#else
+static bool VM_to_signed_literal(parse_tree& x,const bool is_negative, const unsigned_var_int& src_int,const parse_tree& src,const type_system& types)
+#endif
 {
 	if (is_negative)
 		{
@@ -6759,7 +6927,11 @@
 	return true;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_add_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_add_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(is_C99_add_operator_expression<'+'>(src));
 
@@ -6791,8 +6963,13 @@
 				src.type_code = old_type;
 				return true;
 				};
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+#else
+			unsigned_var_int res_int;
+			unsigned_var_int rhs_int;
+#endif
 			const promote_aux old(old_type.base_type_index);
 			const promote_aux lhs(src.data<1>()->type_code.base_type_index);
 			assert(old.bitcount>=lhs.bitcount);
@@ -6806,9 +6983,15 @@
 				{
 				if (old.is_signed)
 					{	// signed integer result
+#ifdef ZCC_LEGACY_FIXED_INT
 					unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
 					unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
 					unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
+#else
+					unsigned_var_int lhs_test(res_int);
+					unsigned_var_int rhs_test(rhs_int);
+					unsigned_var_int ub(target_machine->signed_max(old.machine_type));
+#endif
 					bool result_is_negative = false;
 					if (rhs_negative) target_machine->signed_additive_inverse(rhs_test,old.machine_type);
 					if (lhs_negative) target_machine->signed_additive_inverse(lhs_test,old.machine_type);
@@ -6905,7 +7088,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(is_C99_add_operator_expression<'-'>(src));
 
@@ -6941,8 +7128,13 @@
 				src.type_code = old_type;
 				return true;
 				}
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+#else
+			unsigned_var_int res_int;
+			unsigned_var_int rhs_int;
+#endif
 			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
 			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
 			if (lhs_converted && rhs_converted)
@@ -6958,9 +7150,15 @@
 				const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
 				if (old.is_signed)
 					{	// signed integer result
+#ifdef ZCC_LEGACY_FIXED_INT
 					unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
 					unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
 					unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
+#else
+					unsigned_var_int lhs_test(res_int);
+					unsigned_var_int rhs_test(rhs_int);
+					unsigned_var_int ub(target_machine->signed_max(old.machine_type));
+#endif
 					bool result_is_negative = false;
 					if (rhs_negative) target_machine->signed_additive_inverse(rhs_test,old.machine_type);
 					if (lhs_negative) target_machine->signed_additive_inverse(lhs_test,old.machine_type);
@@ -7059,7 +7257,11 @@
 
 // +: either both are arithmetic, or one is raw pointer and one is integer
 // -: either both are arithmetic, or both are compatible raw pointer, or left is raw pointer and right is integer
+#ifdef ZCC_LEGACY_FIXED_INT
 static void C_CPP_add_expression_easy_syntax_check(parse_tree& src,const type_system& types,func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+static void C_CPP_add_expression_easy_syntax_check(parse_tree& src,const type_system& types,func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert((C99_ADD_SUBTYPE_PLUS==src.subtype && is_C99_add_operator_expression<'+'>(src)) || (C99_ADD_SUBTYPE_MINUS==src.subtype && is_C99_add_operator_expression<'-'>(src)));
 	BOOST_STATIC_ASSERT(1==C99_ADD_SUBTYPE_MINUS-C99_ADD_SUBTYPE_PLUS);
@@ -7304,7 +7506,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_shift(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_shift(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -7329,7 +7535,11 @@
 			}
 		};
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+#else
+	unsigned_var_int rhs_int;
+#endif
 	if (intlike_literal_to_VM(rhs_int,*src.data<2>()))
 		{
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(old_type.base_type_index);
@@ -7350,7 +7560,11 @@
 			};
 		if (undefined_behavior) return false;
 
+#ifdef ZCC_LEGACY_FIXED_INT
 		unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
+#else
+		unsigned_var_int res_int;
+#endif
 		if (intlike_literal_to_VM(res_int,*src.data<1>()))
 			{
 			// note that incoming negative signed integers are not handled by this code path
@@ -7475,14 +7689,23 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_relation_expression(parse_tree& src, const type_system& types,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_relation_expression(parse_tree& src, const type_system& types,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_GT-C99_RELATION_SUBTYPE_LT);
 	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_LTE-C99_RELATION_SUBTYPE_GT);
 	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_GTE-C99_RELATION_SUBTYPE_LTE);
 	assert(C99_RELATION_SUBTYPE_LT<=src.subtype && C99_RELATION_SUBTYPE_GTE>=src.subtype);
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_int;
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+#else
+	unsigned_var_int lhs_int;
+	unsigned_var_int rhs_int;
+#endif
 
 	const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>());
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
@@ -7664,12 +7887,21 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_equality_expression(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_equality_expression(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {	
 	BOOST_STATIC_ASSERT(1==C99_EQUALITY_SUBTYPE_NEQ-C99_EQUALITY_SUBTYPE_EQ);
 	assert(C99_EQUALITY_SUBTYPE_EQ<=src.subtype && C99_EQUALITY_SUBTYPE_NEQ>=src.subtype);
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_int;
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+#else
+	unsigned_var_int lhs_int;
+	unsigned_var_int rhs_int;
+#endif
 	const unsigned int integer_literal_case = 	  converts_to_integer(src.data<1>()->type_code)
 											+	2*converts_to_integer(src.data<2>()->type_code);
 	const bool is_equal_op = src.subtype==C99_EQUALITY_SUBTYPE_EQ;
@@ -7892,7 +8124,11 @@
 	return false;
 }
 
+#if ZCC_LEGACY_FIXED_INT
 static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -7921,12 +8157,21 @@
 		return true;
 		};
 
+#if ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_int;
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+#else
+	unsigned_var_int lhs_int;
+	unsigned_var_int rhs_int;
+#endif
 	if (intlike_literal_to_VM(lhs_int,*src.data<1>()) && intlike_literal_to_VM(rhs_int,*src.data<2>()))
 		{
 		const promote_aux old(old_type.base_type_index);
+#if ZCC_LEGACY_FIXED_INT
 		unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int(lhs_int);
+#else
+		unsigned_var_int res_int(lhs_int);
+#endif
 		res_int &= rhs_int;
 
 		// check for trap representation for signed types
@@ -8067,7 +8312,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -8096,13 +8345,22 @@
 			}
 		};
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_int;
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+#else
+	unsigned_var_int lhs_int;
+	unsigned_var_int rhs_int;
+#endif
 	if (intlike_literal_to_VM(lhs_int,*src.data<1>()) && intlike_literal_to_VM(rhs_int,*src.data<2>()))
 		{
 		const type_spec old_type = src.type_code;
 		const promote_aux old(old_type.base_type_index);
+#ifdef ZCC_LEGACY_FIXED_INT
 		unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int(lhs_int);
+#else
+		unsigned_var_int res_int(lhs_int);
+#endif
 		res_int ^= rhs_int;
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
 
@@ -8235,7 +8493,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_bitwise_OR(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_bitwise_OR(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -8264,13 +8526,22 @@
 			}
 		};
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_int;
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+#else
+	unsigned_var_int lhs_int;
+	unsigned_var_int rhs_int;
+#endif
 	if (intlike_literal_to_VM(lhs_int,*src.data<1>()) && intlike_literal_to_VM(rhs_int,*src.data<2>()))
 		{
 		const type_spec old_type = src.type_code;
 
+#ifdef ZCC_LEGACY_FIXED_INT
 		unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int(lhs_int);
+#else
+		unsigned_var_int res_int(lhs_int);
+#endif
 		res_int |= rhs_int;
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
 		if 		(res_int==lhs_int)
@@ -9355,7 +9626,11 @@
 #endif
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static void eval_string_literal_deref(parse_tree& src,const type_system& types,const POD_pair<const char*,size_t>& str_lit,const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& tmp,bool is_negative,bool index_src_is_char)
+#else
+static void eval_string_literal_deref(parse_tree& src,const type_system& types,const POD_pair<const char*,size_t>& str_lit,const unsigned_var_int& tmp,bool is_negative,bool index_src_is_char)
+#endif
 {
 	const size_t strict_ub = LengthOfCStringLiteral(str_lit.first,str_lit.second);
 	// C99 6.2.6.2p3 -0 is not actually allowed to generate the bitpattern -0, so no trapping
@@ -9416,7 +9691,11 @@
 eval_array_deref(parse_tree& src,const type_system& types,
 				 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 				 func_traits<bool (*)(const parse_tree&)>::function_ref_type literal_converts_to_integer,
+#ifdef ZCC_LEGACY_FIXED_INT
 				 func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+				 func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (!is_array_deref(src)) return false;
 	// crunch __[...]
@@ -9429,7 +9708,11 @@
 										(C_TESTFLAG_STRING_LITERAL==src.data<1>()->index_tokens[0].flags) ? 1 : UINT_MAX;
 		if (UINT_MAX>str_index)
 			{
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp; 
+#else
+			unsigned_var_int tmp; 
+#endif
 			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index))) return false;
 			const size_t promoted_type = default_promote_type(src.type_code.base_type_index);
 			const virtual_machine::std_int_enum machine_type = (virtual_machine::std_int_enum)((promoted_type-C_TYPE::INT)/2+virtual_machine::std_int_int);
@@ -9454,7 +9737,11 @@
 			//! \test default/Pass_if_zero.h
 			//! \test default/Pass_if_nonzero.hpp
 			//! \test default/Pass_if_nonzero.h
+#ifdef ZCC_LEGACY_FIXED_INT
 			eval_string_literal_deref(src,types,src.data<2>()->index_tokens[0].token,unsigned_fixed_int<VM_MAX_BIT_PLATFORM>(0),false,false);
+#else
+			eval_string_literal_deref(src,types,src.data<2>()->index_tokens[0].token,unsigned_var_int(0),false,false);
+#endif
 			return true;
 			}
 		}
@@ -9477,7 +9764,11 @@
 static bool eval_bitwise_compl(	parse_tree& src, const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,
+#ifdef ZCC_LEGACY_FIXED_INT
 								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+								func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_bitwise_complement_expression(src))
 		{
@@ -9501,7 +9792,11 @@
 static bool eval_unary_minus(parse_tree& src, const type_system& types,
 							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							 func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							 func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+							 func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_unary_operator_expression<'-'>(src))
 		{
@@ -9514,7 +9809,11 @@
 static bool eval_mult_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+								func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_mult_operator_expression<'*'>(src))
 		{
@@ -9528,7 +9827,11 @@
 static bool eval_div_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+								func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_mult_operator_expression<'/'>(src))
 		{
@@ -9542,7 +9845,11 @@
 static bool eval_mod_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+								func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_mult_operator_expression<'%'>(src))
 		{
@@ -9553,10 +9860,15 @@
 	return false;
 }
 
+
 static bool eval_add_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_add_operator_expression<'+'>(src))
 		{
@@ -9570,7 +9882,11 @@
 static bool eval_sub_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_add_operator_expression<'-'>(src))
 		{
@@ -9584,7 +9900,11 @@
 static bool eval_shift(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_shift_expression(src))
 		{
@@ -9597,7 +9917,11 @@
 
 static bool eval_relation_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_relation_expression(src))
 		{
@@ -9612,7 +9936,11 @@
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_equality_expression,
 							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_equality_expression(src))
 		{
@@ -9627,7 +9955,11 @@
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_AND_expression,
 							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_bitwise_AND_expression(src))
 		{
@@ -9642,7 +9974,11 @@
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_XOR_expression,
 							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_bitwise_XOR_expression(src))
 		{
@@ -9657,7 +9993,11 @@
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_OR_expression,
 							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_bitwise_OR_expression(src))
 		{
@@ -9817,8 +10157,13 @@
 			};
 		if (non_representable_int_min)
 			{
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+#else
+			unsigned_var_int res_int;
+			unsigned_var_int rhs_int;
+#endif
 			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data<1>());
 			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data<2>());
 			if (lhs_converted && rhs_converted)
@@ -9839,9 +10184,15 @@
 				target_machine->C_promote_integer(rhs_int,rhs,old);
 #endif
 				assert(lhs_negative && !rhs_negative);
+#ifdef ZCC_LEGACY_FIXED_INT
 				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
 				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
 				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
+#else
+				unsigned_var_int lhs_test(res_int);
+				unsigned_var_int rhs_test(rhs_int);
+				unsigned_var_int ub(target_machine->signed_max(old.machine_type));
+#endif
 				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
 				ub += 1;
 				assert(ub>=lhs_test && ub>=rhs_test);
@@ -9885,8 +10236,13 @@
 			};
 		if (non_representable_int_min)
 			{
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+#else
+			unsigned_var_int res_int;
+			unsigned_var_int rhs_int;
+#endif
 			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data<1>());
 			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data<2>());
 			if (lhs_converted && rhs_converted)
@@ -9907,9 +10263,15 @@
 				target_machine->C_promote_integer(rhs_int,rhs,old);
 #endif
 				assert(lhs_negative && !rhs_negative);
+#ifdef ZCC_LEGACY_FIXED_INT
 				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
 				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
 				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
+#else
+				unsigned_var_int lhs_test(res_int);
+				unsigned_var_int rhs_test(rhs_int);
+				unsigned_var_int ub(target_machine->signed_max(old.machine_type));
+#endif
 				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
 				ub += 1;
 				assert(ub>=lhs_test && ub>=rhs_test);

Added: trunk/unsigned_var_int.cpp
===================================================================
--- trunk/unsigned_var_int.cpp	2010-01-06 04:15:00 UTC (rev 324)
+++ trunk/unsigned_var_int.cpp	2010-01-10 09:37:43 UTC (rev 325)
@@ -0,0 +1,211 @@
+// unsigned_var_int.cpp
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#include "unsigned_var_int.hpp"
+
+static size_t bytes_to_represent(uintmax_t src)
+{
+	size_t n = 1;
+	while(UCHAR_MAX<src)
+		{
+		++n;
+		src /= UCHAR_MAX;
+		};
+	return n;
+}
+
+unsigned_var_int::unsigned_var_int(const unsigned_var_int& src)
+{
+	_data.init(src._data.size());
+	memmove(_data.c_array(),src._data.data(),src._data.size());
+}
+
+unsigned_var_int::unsigned_var_int(uintmax_t src)
+{
+	const size_t n = bytes_to_represent(src);
+	_data.init(n);
+	unsigned_copy(_data.c_array(),src,n);
+}
+
+unsigned_var_int& unsigned_var_int::operator=(const unsigned_var_int& src)
+{
+	_data.resize(src._data.size());
+	memmove(_data.c_array(),src._data.data(),src._data.size());
+	return *this;
+}
+
+unsigned_var_int& unsigned_var_int::operator=(uintmax_t src)
+{
+	const size_t n = bytes_to_represent(src);
+	if (n> _data.size()) _data.resize(n);
+	unsigned_copy(_data.c_array(),src,n);
+	if (n<_data.size()) memset(_data.c_array()+n,0,_data.size()-n);
+	return *this;
+}
+
+void unsigned_var_int::MoveInto(unsigned_var_int& dest)
+{
+	dest._data.resize(0);
+	dest._data = _data;
+	_data.init(0);
+}
+
+unsigned_var_int& unsigned_var_int::operator+=(const unsigned_var_int& rhs)
+{
+	if (size()<=rhs.size())
+		{
+		unsigned_sum(c_array(),size(),rhs.data());
+		}
+	else{	// need to zero-extend rhs
+		unsigned_var_int tmp(rhs);
+		tmp._data.resize(size());
+		unsigned_sum(c_array(),size(),tmp.data());
+		}
+	return *this;
+}
+
+unsigned_var_int operator+(const unsigned_var_int& lhs,const unsigned_var_int& rhs)
+{
+	const bool lhs_larger = lhs.size()>=rhs.size();
+	unsigned_var_int tmp(lhs_larger ? lhs : rhs);
+	tmp += (lhs_larger ? rhs : lhs);
+	return tmp;
+}
+
+
+unsigned_var_int& unsigned_var_int::operator-=(const unsigned_var_int& rhs)
+{
+	if (size()<=rhs.size())
+		unsigned_diff(c_array(),size(),rhs.data());
+	else{	// need to zero-extend rhs
+		unsigned_var_int tmp(rhs);
+		tmp.resize(size());
+		unsigned_diff(c_array(),size(),tmp.data());
+		}
+	return *this;
+}
+
+unsigned_var_int operator-(const unsigned_var_int& lhs,const unsigned_var_int& rhs)
+{
+	unsigned_var_int tmp(lhs);
+	if (tmp.size()<rhs.size()) tmp.resize(rhs.size());
+	tmp -= rhs;
+	return tmp;	// uses NRVO
+}
+
+unsigned_var_int& unsigned_var_int::operator*=(const unsigned_var_int& rhs)
+{
+	unsigned_var_int tmp(0);;
+	tmp.resize(size());
+	unsigned_mult(tmp.c_array(),tmp.size(),data(),size(),rhs.data(),rhs.size());
+	return *this = tmp;
+}
+
+unsigned_var_int& unsigned_var_int::operator&=(const unsigned_var_int& rhs)
+{
+	if (size()<=rhs.size())
+		bitwise_and(c_array(),size(),rhs.data());
+	else{
+		unsigned_var_int tmp(rhs);
+		tmp.resize(size());
+		bitwise_and(c_array(),size(),tmp.data());
+		}
+	return *this;
+}
+
+unsigned_var_int& unsigned_var_int::operator^=(const unsigned_var_int& rhs)
+{
+	if (size()<=rhs.size())
+		bitwise_xor(c_array(),size(),rhs.data());
+	else
+		bitwise_xor(c_array(),rhs.size(),rhs.data());
+	return *this;
+}
+
+unsigned_var_int& unsigned_var_int::operator|=(const unsigned_var_int& rhs)
+{
+	if (size()<=rhs.size())
+		bitwise_or(c_array(),size(),rhs.data());
+	else
+		bitwise_or(c_array(),rhs.size(),rhs.data());
+	return *this;
+}
+
+void unsigned_var_int::div_op(const unsigned_var_int& divisor, unsigned_var_int& quotient)
+{
+	if (divisor.size()==quotient.size())
+		{
+		const size_t cur_size = size();
+		if (cur_size==divisor.size())
+			{
+			remainder_quotient(size(),c_array(),divisor.data(),quotient.c_array());
+			return;
+			}
+		resize(divisor.size());
+		remainder_quotient(size(),c_array(),divisor.data(),quotient.c_array());
+		resize(cur_size);
+		return;
+		}
+	FATAL("unsigned_var_int::div_op not fully implemented yet.");
+}
+
+unsigned_var_int operator/(unsigned_var_int lhs,const unsigned_var_int& rhs)
+{
+	unsigned_var_int quotient(0);
+	quotient.resize(rhs.size());
+	lhs.div_op(rhs,quotient);
+	return quotient;
+}
+
+unsigned_var_int& unsigned_var_int::operator/=(const unsigned_var_int& rhs)
+{
+	unsigned_var_int quotient(0);
+	quotient.resize(rhs.size());
+	div_op(rhs,quotient);
+	quotient.MoveInto(*this);
+	return *this;
+}
+
+unsigned_var_int& unsigned_var_int::operator%=(const unsigned_var_int& rhs)
+{
+	unsigned_var_int quotient(0);
+	quotient.resize(rhs.size());
+	div_op(rhs,quotient);
+	return *this;
+}
+
+signed int cmp(const unsigned_var_int& lhs, const unsigned_var_int& rhs)
+{
+	size_t lhs_size = lhs.size();
+	size_t rhs_size = rhs.size();
+
+	// normalize representation being checked
+	while(1<lhs_size && !lhs.data()[lhs_size-1]) --lhs_size;
+	while(1<rhs_size && !rhs.data()[rhs_size-1]) --rhs_size;
+	
+	if (lhs_size<rhs_size) return -1;
+	if (lhs_size>rhs_size) return 1;
+
+	return unsigned_cmp(lhs.data(),lhs_size,rhs.data());
+}
+
+char* z_ucharint_toa(unsigned_var_int target,char* const buf,unsigned int radix)
+{
+	char* ret = buf;
+	unsigned_var_int radix_copy(radix);
+	radix_copy.resize(target.size());
+	unsigned_var_int power_up(1);
+	power_up.resize(target.size());
+	while(power_up<=target/radix_copy) power_up *= radix_copy;
+	do	{
+		unsigned char tmp = (unsigned char)((target/power_up).to_uint());
+		tmp += (10>tmp) ? (unsigned char)('0') : (unsigned char)('A')-10U;	// ahem...assumes ASCII linear A-Z
+		*ret++ = tmp;
+		target %= power_up;
+		power_up /= radix_copy;
+		}
+	while(0<power_up);
+	*ret = '\0';
+	return buf;
+}
+

Added: trunk/unsigned_var_int.hpp
===================================================================
--- trunk/unsigned_var_int.hpp	2010-01-06 04:15:00 UTC (rev 324)
+++ trunk/unsigned_var_int.hpp	2010-01-10 09:37:43 UTC (rev 325)
@@ -0,0 +1,147 @@
+// unsigned_var_int.hpp
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#ifndef UNSIGNED_VAR_INT_HPP
+#define UNSIGNED_VAR_INT_HPP 1
+
+#include "unsigned_aux.hpp"
+#include "uchar_blob.hpp"
+
+// the main class
+// this does implement C/C++ modulo wraparound; change the size beforehand if this is an issue.
+class unsigned_var_int
+{
+private:
+	uchar_blob _data;
+public:
+	unsigned_var_int() {_data.init(0);};
+	explicit unsigned_var_int(uintmax_t src);
+	unsigned_var_int(const unsigned_var_int& src);
+
+	unsigned_var_int& operator=(const unsigned_var_int& src);
+	unsigned_var_int& operator=(uintmax_t src);
+	unsigned_var_int& operator=(const uchar_blob& src) {value_copy(_data,src); return *this;};
+	void MoveInto(unsigned_var_int& dest);
+
+	unsigned_var_int& operator~() {bitwise_compl(_data.c_array(),_data.size()); return *this;};
+	void auto_bitwise_complement() {bitwise_compl(_data.c_array(),_data.size());};
+	unsigned_var_int& operator+=(const unsigned_var_int& rhs);
+	unsigned_var_int& operator+=(uintmax_t rhs) {unsigned_sum(_data.c_array(),_data.size(),rhs); return *this;};
+	unsigned_var_int& operator-=(const unsigned_var_int& rhs);
+	unsigned_var_int& operator-=(uintmax_t rhs) {unsigned_diff(_data.c_array(),_data.size(),rhs); return *this;};
+	unsigned_var_int& operator*=(const unsigned_var_int& rhs);
+	unsigned_var_int& operator&=(const unsigned_var_int& rhs);
+	unsigned_var_int& operator^=(const unsigned_var_int& rhs);
+	unsigned_var_int& operator|=(const unsigned_var_int& rhs);
+	unsigned_var_int& operator>>=(uintmax_t rhs) {unsigned_right_shift(_data.c_array(),_data.size(),rhs); return *this;};
+	unsigned_var_int& operator<<=(uintmax_t rhs) {unsigned_left_shift(_data.c_array(),_data.size(),rhs); return *this;};
+
+	void div_op(const unsigned_var_int& divisor, unsigned_var_int& quotient);
+
+	unsigned_var_int& operator/=(const unsigned_var_int& rhs);
+	unsigned_var_int& operator%=(const unsigned_var_int& rhs);
+
+	unsigned int int_log2() const {return ::int_log2(_data.data(),_data.size());};
+
+	void set(size_t n)
+		{
+		assert(_data.size()>n/CHAR_BIT);
+		_data.c_array()[n/CHAR_BIT] |= ((unsigned char)(1U))<<(n%CHAR_BIT);
+		};
+	void set(size_t n,bool x)
+		{
+		assert(_data.size()>n/CHAR_BIT);
+		if (x)
+			_data.c_array()[n/CHAR_BIT] |= ((unsigned char)(1U))<<(n%CHAR_BIT);
+		else
+			_data.c_array()[n/CHAR_BIT] &= ~(((unsigned char)(1U))<<(n%CHAR_BIT));
+		};
+	void reset(size_t n)
+		{
+		assert(_data.size()>n/CHAR_BIT);
+		_data.c_array()[n/CHAR_BIT] &= ~(((unsigned char)(1U))<<(n%CHAR_BIT));
+		};
+
+	bool test(size_t n) const
+		{
+		assert(_data.size()>n/CHAR_BIT);
+		return _data.data()[n/CHAR_BIT] & (((unsigned char)(1U))<<(n%CHAR_BIT));
+		}
+
+	void toggle(size_t n)
+		{
+		assert(_data.size()>n/CHAR_BIT);
+		_data.c_array()[n/CHAR_BIT] ^= (((unsigned char)(1U))<<(n%CHAR_BIT));
+		};
+
+	bool representable_as_uint() const
+		{	//! \todo remove assumption host has no padding bits in uintmax_t
+		size_t i = _data.size();
+		if (sizeof(uintmax_t)>=i) return true;
+		do	if ((unsigned char)('\0')!=_data.data()[--i]) return false;
+		while(sizeof(uintmax_t)<i);
+		return true;
+		};
+
+	void resize(size_t n) {_data.resize(n);};
+	void set_bitcount(size_t n) {_data.resize(n/CHAR_BIT+(0<n%CHAR_BIT));};
+	void mask_to(size_t bitcount) {assert(bitcount<=CHAR_BIT*_data.size());return ::mask_to(_data.c_array(),_data.size(),bitcount);};
+	uintmax_t to_uint() const {return ::to_uint(_data.data(),_data.size());};
+	void set_max() {memset(_data.c_array(),UCHAR_MAX,_data.size());};
+
+	// STL glue
+	void clear() {memset(_data.c_array(),0,_data.size());};
+
+	const unsigned char* data() const {return _data.data();};
+	unsigned char* c_array() {return _data.c_array();};
+	size_t size() const {return _data.size();};
+	bool empty() const {return _data.empty();};
+
+	const unsigned char* begin() const {return _data.begin();};
+	unsigned char* begin() {return _data.begin();};
+	const unsigned char* end() const {return _data.end();};
+	unsigned char* end() {return _data.end();};
+
+	unsigned char front() const {return _data.front();};
+	unsigned char& front() {return _data.front();};
+	unsigned char back() const {return _data.back();};
+	unsigned char& back() {return _data.back();};
+};
+
+// render as C string
+char* z_ucharint_toa(unsigned_var_int target,char* const buf,unsigned int radix);
+
+// the larger size of lhs and rhs is used here
+unsigned_var_int operator+(const unsigned_var_int& lhs,const unsigned_var_int& rhs);
+unsigned_var_int operator-(const unsigned_var_int& lhs,const unsigned_var_int& rhs);
+unsigned_var_int operator/(unsigned_var_int lhs,const unsigned_var_int& rhs);
+
+// classic cmp: -1 for less than, 0 for equal, 1 for greater than.
+signed int cmp(const unsigned_var_int& lhs, const unsigned_var_int& rhs);
+
+// comparison operators
+inline bool operator==(const unsigned_var_int& lhs, const unsigned_var_int& rhs) {return 0==cmp(lhs,rhs);}
+inline bool operator==(const unsigned_var_int& lhs, uintmax_t rhs) {return 0==unsigned_cmp(lhs.data(),lhs.size(),rhs);}
+inline bool operator==(uintmax_t lhs, const unsigned_var_int& rhs) {return 0==unsigned_cmp(rhs.data(),rhs.size(),lhs);}
+
+inline bool operator!=(const unsigned_var_int& lhs, const unsigned_var_int& rhs) {return 0!=cmp(lhs,rhs);}
+inline bool operator!=(const unsigned_var_int& lhs, uintmax_t rhs) {return 0==unsigned_cmp(lhs.data(),lhs.size(),rhs);}
+inline bool operator!=(uintmax_t lhs, const unsigned_var_int& rhs) {return 0==unsigned_cmp(rhs.data(),rhs.size(),lhs);}
+
+inline bool operator<(const unsigned_var_int& lhs, const unsigned_var_int& rhs) {return -1==cmp(lhs,rhs);}
+inline bool operator<(const unsigned_var_int& lhs, uintmax_t rhs) {return -1==unsigned_cmp(lhs.data(),lhs.size(),rhs);}
+inline bool operator<(uintmax_t lhs, const unsigned_var_int& rhs) {return 1==unsigned_cmp(rhs.data(),rhs.size(),lhs);}
+
+inline bool operator>(const unsigned_var_int& lhs, const unsigned_var_int& rhs) {return 1==cmp(lhs,rhs);}
+inline bool operator>(const unsigned_var_int& lhs, uintmax_t rhs) {return 1==unsigned_cmp(lhs.data(),lhs.size(),rhs);}
+inline bool operator>(uintmax_t lhs, const unsigned_var_int& rhs) {return -1==unsigned_cmp(rhs.data(),rhs.size(),lhs);}
+
+inline bool operator<=(const unsigned_var_int& lhs, const unsigned_var_int& rhs) {return 1!=cmp(lhs,rhs);}
+inline bool operator<=(const unsigned_var_int& lhs, uintmax_t rhs) {return 0>=unsigned_cmp(lhs.data(),lhs.size(),rhs);}
+inline bool operator<=(uintmax_t lhs, const unsigned_var_int& rhs) {return 0<=unsigned_cmp(rhs.data(),rhs.size(),lhs);}
+
+inline bool operator>=(const unsigned_var_int& lhs, const unsigned_var_int& rhs) {return -1!=cmp(lhs,rhs);}
+inline bool operator>=(const unsigned_var_int& lhs, uintmax_t rhs) {return 0<=unsigned_cmp(lhs.data(),lhs.size(),rhs);}
+inline bool operator>=(uintmax_t lhs, const unsigned_var_int& rhs) {return 0>=unsigned_cmp(rhs.data(),rhs.size(),lhs);}
+
+#endif



From zaimoni at mail.berlios.de  Mon Jan 11 00:02:01 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 11 Jan 2010 00:02:01 +0100
Subject: [Zcplusplus-commits] r326 - trunk
Message-ID: <201001102302.o0AN215C032173@sheep.berlios.de>

Author: zaimoni
Date: 2010-01-11 00:01:56 +0100 (Mon, 11 Jan 2010)
New Revision: 326

Modified:
   trunk/CPUInfo.cpp
   trunk/CSupport.cpp
   trunk/unsigned_var_int.cpp
   trunk/unsigned_var_int.hpp
Log:
new constructor for unsigned_var_int

Modified: trunk/CPUInfo.cpp
===================================================================
--- trunk/CPUInfo.cpp	2010-01-10 09:37:43 UTC (rev 325)
+++ trunk/CPUInfo.cpp	2010-01-10 23:01:56 UTC (rev 326)
@@ -172,8 +172,7 @@
 {
 	assert(machine_type);
 	assert(src_int<=unsigned_max(machine_type));
-	unsigned_var_int tmp(0);
-	tmp.resize(src_int.size());
+	unsigned_var_int tmp(0,src_int.size());
 	tmp -= src_int;
 	tmp.mask_to(C_bit(machine_type));
 	tmp.MoveInto(src_int);

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-01-10 09:37:43 UTC (rev 325)
+++ trunk/CSupport.cpp	2010-01-10 23:01:56 UTC (rev 326)
@@ -2461,8 +2461,7 @@
 #ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp(0);
 #else
-	unsigned_var_int tmp;
-	tmp.set_bitcount(VM_MAX_BIT_PLATFORM);
+	unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 #endif
 #ifndef NDEBUG
 #ifdef ZCC_LEGACY_FIXED_INT
@@ -2991,8 +2990,7 @@
 #ifdef ZCC_LEGACY_FIXED_INT
 												unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp(0);
 #else
-												unsigned_var_int tmp;
-												tmp.set_bitcount(VM_MAX_BIT_PLATFORM);
+												unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 #endif
 												if (VM_MAX_BIT_PLATFORM>target_machine->C_char_bit()) tmp.set(target_machine->C_char_bit());
 												tmp -= 1;
@@ -3002,8 +3000,7 @@
 #ifdef ZCC_LEGACY_FIXED_INT
 												unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp(0);
 #else
-												unsigned_var_int tmp;
-												tmp.set_bitcount(VM_MAX_BIT_PLATFORM);
+												unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 #endif
 												tmp.set(target_machine->C_char_bit()-1);
 												return tmp==result;
@@ -4139,10 +4136,8 @@
 	const unsigned_fixed_int<VM_MAX_BIT_PLATFORM> alt_radix(src.radix);
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> strict_ub;
 #else
-	unsigned_var_int alt_radix(src.radix);
-	unsigned_var_int strict_ub;
-	strict_ub.set_bitcount(VM_MAX_BIT_PLATFORM);
-	alt_radix.set_bitcount(VM_MAX_BIT_PLATFORM);
+	const unsigned_var_int alt_radix(src.radix,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
+	unsigned_var_int strict_ub(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 #endif
 	const char* target = src.ptr;
 	size_t target_len = src.digit_span;

Modified: trunk/unsigned_var_int.cpp
===================================================================
--- trunk/unsigned_var_int.cpp	2010-01-10 09:37:43 UTC (rev 325)
+++ trunk/unsigned_var_int.cpp	2010-01-10 23:01:56 UTC (rev 326)
@@ -27,6 +27,14 @@
 	unsigned_copy(_data.c_array(),src,n);
 }
 
+unsigned_var_int::unsigned_var_int(uintmax_t src,size_t bytecount)
+{
+	const size_t n = bytes_to_represent(src);
+	_data.init(bytecount < n ? n : bytecount);
+	unsigned_copy(_data.c_array(),src,n);
+	if (bytecount<n) _data.resize(bytecount);
+}
+
 unsigned_var_int& unsigned_var_int::operator=(const unsigned_var_int& src)
 {
 	_data.resize(src._data.size());
@@ -53,9 +61,7 @@
 unsigned_var_int& unsigned_var_int::operator+=(const unsigned_var_int& rhs)
 {
 	if (size()<=rhs.size())
-		{
 		unsigned_sum(c_array(),size(),rhs.data());
-		}
 	else{	// need to zero-extend rhs
 		unsigned_var_int tmp(rhs);
 		tmp._data.resize(size());
@@ -95,8 +101,7 @@
 
 unsigned_var_int& unsigned_var_int::operator*=(const unsigned_var_int& rhs)
 {
-	unsigned_var_int tmp(0);;
-	tmp.resize(size());
+	unsigned_var_int tmp(0,size());
 	unsigned_mult(tmp.c_array(),tmp.size(),data(),size(),rhs.data(),rhs.size());
 	return *this = tmp;
 }
@@ -151,16 +156,14 @@
 
 unsigned_var_int operator/(unsigned_var_int lhs,const unsigned_var_int& rhs)
 {
-	unsigned_var_int quotient(0);
-	quotient.resize(rhs.size());
+	unsigned_var_int quotient(0,rhs.size());
 	lhs.div_op(rhs,quotient);
 	return quotient;
 }
 
 unsigned_var_int& unsigned_var_int::operator/=(const unsigned_var_int& rhs)
 {
-	unsigned_var_int quotient(0);
-	quotient.resize(rhs.size());
+	unsigned_var_int quotient(0,rhs.size());
 	div_op(rhs,quotient);
 	quotient.MoveInto(*this);
 	return *this;
@@ -168,8 +171,7 @@
 
 unsigned_var_int& unsigned_var_int::operator%=(const unsigned_var_int& rhs)
 {
-	unsigned_var_int quotient(0);
-	quotient.resize(rhs.size());
+	unsigned_var_int quotient(0,rhs.size());
 	div_op(rhs,quotient);
 	return *this;
 }
@@ -192,10 +194,8 @@
 char* z_ucharint_toa(unsigned_var_int target,char* const buf,unsigned int radix)
 {
 	char* ret = buf;
-	unsigned_var_int radix_copy(radix);
-	radix_copy.resize(target.size());
-	unsigned_var_int power_up(1);
-	power_up.resize(target.size());
+	const unsigned_var_int radix_copy(radix,target.size());
+	unsigned_var_int power_up(1,target.size());
 	while(power_up<=target/radix_copy) power_up *= radix_copy;
 	do	{
 		unsigned char tmp = (unsigned char)((target/power_up).to_uint());

Modified: trunk/unsigned_var_int.hpp
===================================================================
--- trunk/unsigned_var_int.hpp	2010-01-10 09:37:43 UTC (rev 325)
+++ trunk/unsigned_var_int.hpp	2010-01-10 23:01:56 UTC (rev 326)
@@ -16,6 +16,7 @@
 public:
 	unsigned_var_int() {_data.init(0);};
 	explicit unsigned_var_int(uintmax_t src);
+	unsigned_var_int(uintmax_t src,size_t bytecount);
 	unsigned_var_int(const unsigned_var_int& src);
 
 	unsigned_var_int& operator=(const unsigned_var_int& src);
@@ -84,6 +85,7 @@
 		};
 
 	void resize(size_t n) {_data.resize(n);};
+	static size_t bytes_from_bits(size_t n) {return n/CHAR_BIT+(0<n%CHAR_BIT);};
 	void set_bitcount(size_t n) {_data.resize(n/CHAR_BIT+(0<n%CHAR_BIT));};
 	void mask_to(size_t bitcount) {assert(bitcount<=CHAR_BIT*_data.size());return ::mask_to(_data.c_array(),_data.size(),bitcount);};
 	uintmax_t to_uint() const {return ::to_uint(_data.data(),_data.size());};



From zaimoni at mail.berlios.de  Mon Jan 11 20:12:20 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 11 Jan 2010 20:12:20 +0100
Subject: [Zcplusplus-commits] r327 - trunk
Message-ID: <201001111912.o0BJCKs1009664@sheep.berlios.de>

Author: zaimoni
Date: 2010-01-11 20:12:14 +0100 (Mon, 11 Jan 2010)
New Revision: 327

Modified:
   trunk/CPUInfo.cpp
   trunk/CPUInfo.hpp
   trunk/CPreproc_autogen.cpp
   trunk/CSupport.cpp
Log:
switch unsigned_var_int usage to get its maximum target size from CPUInfo rather a compile-time constant

Modified: trunk/CPUInfo.cpp
===================================================================
--- trunk/CPUInfo.cpp	2010-01-10 23:01:56 UTC (rev 326)
+++ trunk/CPUInfo.cpp	2010-01-11 19:12:14 UTC (rev 327)
@@ -22,11 +22,11 @@
 	unsigned_var_int tmp;
 
 #define SET_MAXIMUM(A)	\
-	tmp.set_bitcount(VM_MAX_BIT_PLATFORM+1);	\
+	tmp.set_bitcount(C_bit<std_int_long_long>()+1);	\
 	tmp.clear();	\
-	tmp.set((SUCCEED_OR_DIE(VM_MAX_BIT_PLATFORM>=C_char_bit()*C_sizeof_##A()),C_char_bit()*C_sizeof_##A()));	\
+	tmp.set((SUCCEED_OR_DIE(C_bit<std_int_long_long>()>=C_char_bit()*C_sizeof_##A()),C_char_bit()*C_sizeof_##A()));	\
 	tmp -= 1;	\
-	tmp.set_bitcount(VM_MAX_BIT_PLATFORM);	\
+	tmp.set_bitcount(C_bit<std_int_long_long>());	\
 	tmp.MoveInto(unsigned_maxima[std_int_##A-1])
 #endif
 
@@ -92,7 +92,7 @@
 	const unsigned int bitcount = C_bit(machine_type);
 	const int target_bytecount = bitcount/CHAR_BIT;
 	const unsigned int target_bitcount = bitcount%CHAR_BIT;
-	assert(VM_MAX_BIT_PLATFORM>=bitcount && 1<=bitcount);
+	assert(C_bit<std_int_long_long>()>=bitcount && 1<=bitcount);
 
 	switch(C_signed_int_representation())
 	{

Modified: trunk/CPUInfo.hpp
===================================================================
--- trunk/CPUInfo.hpp	2010-01-10 23:01:56 UTC (rev 326)
+++ trunk/CPUInfo.hpp	2010-01-11 19:12:14 UTC (rev 327)
@@ -41,8 +41,15 @@
 	bool is_signed;	// as in std::numeric_limits
 };
 
+#ifdef ZCC_LEGACY_FIXED_INT
 // adjust this upwards as needed
 #define VM_MAX_BIT_PLATFORM 64
+#else
+// as the implementation, we are free to not provide a larger type than
+// C long long.  Yhis macro doesn't work so well outside of the language 
+// support files, which are expected to declare a CPUInfo* target_machine
+#define VM_MAX_BIT_PLATFORM target_machine->C_bit<virtual_machine::std_int_long_long>()
+#endif
 
 // names of macro parameters match names of constructor variables
 // target wchar_t is assumed to be an unsigned integral type

Modified: trunk/CPreproc_autogen.cpp
===================================================================
--- trunk/CPreproc_autogen.cpp	2010-01-10 23:01:56 UTC (rev 326)
+++ trunk/CPreproc_autogen.cpp	2010-01-11 19:12:14 UTC (rev 327)
@@ -9,6 +9,13 @@
 #include "Zaimoni.STL/LexParse/Token.hpp"
 #include "Zaimoni.STL/pure.C/format_util.h"
 
+#ifndef ZCC_LEGACY_FIXED_INT
+// XXX adjust VM_MAX_BIT_PLATFORM to work inside of CPreprocessor XXX
+#undef VM_MAX_BIT_PLATFORM
+#define VM_MAX_BIT_PLATFORM target_machine.C_bit<virtual_machine::std_int_long_long>()
+#endif
+
+
 //! \bug Once And Only Once violation
 #define DICT_STRUCT(A) { (A), sizeof(A)-1 }
 
@@ -408,9 +415,15 @@
 void
 CPreprocessor::create_limits_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
+	// 2 for: leading space, trailing null-termination
+	// (VM_MAX_BIT_PLATFORM/3) for: digits (using octal rather than decimal count because that's easy to do at compile-time)
+#ifdef ZCC_LEGACY_FIXED_INT
 	// currently, worst-case platform we support has a 64-bit two's-complenent long long
-	char buf[2+(VM_MAX_BIT_PLATFORM/3)] = " ";	// 2 for: leading space, trailing null-termination
-												// (VM_MAX_BIT_PLATFORM/3) for: digits (using octal rather than decimal count because that's easy to do at compile-time)
+	char buf[2+(VM_MAX_BIT_PLATFORM/3)] = " ";
+#else
+	zaimoni::autovalarray_ptr_throws<char> buf(2+(VM_MAX_BIT_PLATFORM/3));
+	buf[0] = ' ';
+#endif
 	assert(NULL!=header_name);
 	TokenList.clear();
 	TokenList.resize(STATIC_SIZE(limits_h_core));
@@ -653,6 +666,17 @@
 	strcpy(dest,src);
 }
 
+template<size_t offset>
+static void memset_strcpy(char* dest,const char* src,size_t buf_size)
+{
+	assert(offset<buf_size);
+	assert(NULL!=dest);
+	assert(NULL!=src);
+	assert(buf_size-offset>strlen(src));
+	memset(dest += offset,0,buf_size-offset);
+	strcpy(dest,src);
+}
+
 /*! 
  * Improvises the C99 stdint.h header from target information.  Can throw std::bad_alloc.
  * This is not the most memory-efficient implementation possible.
@@ -665,9 +689,14 @@
 CPreprocessor::create_stdint_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
 	assert(NULL!=header_name);
+	// 2 for: leading space, trailing null-termination
+	// (VM_MAX_BIT_PLATFORM/3) for: digits (using octal rather than decimal count because that's easy to do at compile-time)
+#ifdef ZCC_LEGACY_FIXED_INT
 	// currently, worst-case platform we support has a 64-bit two's-complenent long long
-	char buf[2+(VM_MAX_BIT_PLATFORM/3)] = " ";	// 2 for: leading space, trailing null-termination
-												// (VM_MAX_BIT_PLATFORM/3) for: digits (using octal rather than decimal count because that's easy to do at compile-time)
+	char buf[2+(VM_MAX_BIT_PLATFORM/3)] = " ";
+#else
+	zaimoni::autovalarray_ptr_throws<char> buf(2+(VM_MAX_BIT_PLATFORM/3));
+#endif
 	TokenList.clear();
 	TokenList.resize(STATIC_SIZE(stdint_h_core));
 	zaimoni::Token<char>** tmp = TokenList.c_array();
@@ -679,7 +708,11 @@
 	while(0<i);
 
 	// set up some result strings
+#ifdef ZCC_LEGACY_FIXED_INT
 	char signed_max_metabuf[virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+4)] = "";
+#else
+	zaimoni::autovalarray_ptr_throws<char> signed_max_metabuf(virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+4));
+#endif
 	char* signed_max_buf[virtual_machine::std_int_enum_max] = {signed_max_metabuf, signed_max_metabuf+(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_max_metabuf+2*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_max_metabuf+3*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_max_metabuf+4*(2+(VM_MAX_BIT_PLATFORM/3)+2)};
 	*signed_max_buf[0] = ' ';
 	*signed_max_buf[1] = ' ';
@@ -694,7 +727,11 @@
 	strcat(signed_max_buf[virtual_machine::std_int_long-1],"L");
 	strcat(signed_max_buf[virtual_machine::std_int_long_long-1],"LL");
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	char unsigned_max_metabuf[virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+3)] = "";
+#else
+	zaimoni::autovalarray_ptr_throws<char> unsigned_max_metabuf(virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+3));
+#endif
 	char* unsigned_max_buf[virtual_machine::std_int_enum_max] = {unsigned_max_metabuf, unsigned_max_metabuf+(2+(VM_MAX_BIT_PLATFORM/3)+2), unsigned_max_metabuf+2*(2+(VM_MAX_BIT_PLATFORM/3)+2), unsigned_max_metabuf+3*(2+(VM_MAX_BIT_PLATFORM/3)+2), unsigned_max_metabuf+4*(2+(VM_MAX_BIT_PLATFORM/3)+2)};
 	*unsigned_max_buf[0] = ' ';
 	*unsigned_max_buf[1] = ' ';
@@ -713,7 +750,11 @@
 	strcat(unsigned_max_buf[virtual_machine::std_int_long_long-1],"ULL");
 
 	const bool target_is_twos_complement = virtual_machine::twos_complement==target_machine.C_signed_int_representation();
+#ifdef ZCC_LEGACY_FIXED_INT
 	char signed_min_metabuf[virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+4)] = "";
+#else
+	zaimoni::autovalarray_ptr_throws<char> signed_min_metabuf(virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+4));
+#endif
 	char* signed_min_buf[virtual_machine::std_int_enum_max] = {signed_min_metabuf, signed_min_metabuf+(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+2*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+3*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+4*(2+(VM_MAX_BIT_PLATFORM/3)+2)};
 #ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp_VM;
@@ -746,8 +787,13 @@
 		strcat(signed_min_buf[virtual_machine::std_int_long_long-1],"LL)");
 		}
 	else{
+#ifdef ZCC_LEGACY_FIXED_INT
 		BOOST_STATIC_ASSERT(sizeof(signed_min_metabuf)==sizeof(signed_max_metabuf));
 		memmove(signed_min_metabuf,signed_max_metabuf,sizeof(signed_max_metabuf));
+#else
+		assert(signed_min_metabuf.size()==signed_max_metabuf.size());
+		memmove(signed_min_metabuf,signed_max_metabuf,signed_max_metabuf.size());
+#endif
 		*signed_min_buf[0] = '-';
 		*signed_min_buf[1] = '-';
 		*signed_min_buf[2] = '-';
@@ -958,7 +1004,7 @@
 	}
 
 	// limits macros cleanup
-	char lock_buf[sizeof("#pragma ZCC lock INT_LEAST_MIN INT_LEAST_MAX UINT_LEAST_MAX INT_FAST_MIN INT_FAST_MAX UINT_FAST_MAX INT_C UINT_C")+8*2] = "#pragma ZCC lock ";	// should be dependent on base 10 logarithm of VM_MAX_BIT_PLATFORM: fix auto_int.h
+	char lock_buf[sizeof("#pragma ZCC lock INT_LEAST_MIN INT_LEAST_MAX UINT_LEAST_MAX INT_FAST_MIN INT_FAST_MAX UINT_FAST_MAX INT_C UINT_C")+8*2] = "#pragma ZCC lock ";
 	if (suppress[virtual_machine::std_int_long_long-2])
 		{
 		TokenList.DeleteNSlotsAt(3,STDINT_EXACT_LLONG_LIMITS_LINEORIGIN);
@@ -1209,7 +1255,12 @@
 		}
 	while(0<i);
 
-	char define_buf[sizeof("#define UINT_LEAST_MAX")+2+VM_MAX_BIT_PLATFORM/3+5] = "#define ";	// should be dependent on base 10 logarithm of VM_MAX_BIT_PLATFORM: fix auto_int.h
+#ifdef ZCC_LEGACY_FIXED_INT
+	char define_buf[sizeof("#define UINT_LEAST_MAX")+2+VM_MAX_BIT_PLATFORM/3+5] = "#define ";
+#else
+	zaimoni::autovalarray_ptr_throws<char> define_buf(sizeof("#define UINT_LEAST_MAX")+2+VM_MAX_BIT_PLATFORM/3+5);
+	strcpy(define_buf,"#define ");
+#endif
 	i = 13*bitspan_types;
 	TokenList.InsertNSlotsAt(i,inject_C_index);
 	tmp = TokenList.c_array()+inject_C_index;
@@ -1244,7 +1295,7 @@
 		strcat(lock_buf,"_C");
 		tmp[i--] = new zaimoni::Token<char>(lock_buf,0,strlen(lock_buf),0);
 		// UINT_C
-		memset_strcpy<sizeof("#define ")-1,sizeof(define_buf)>(define_buf,"UINT");
+		memset_strcpy<sizeof("#define ")-1>(define_buf,"UINT",define_buf.size());
 		strcat(define_buf,buf+1);
 		strcat(define_buf,"_C(A) A");
 		const char* int_suffix = unsigned_suffix_from_machine(least_type,target_machine);
@@ -1255,7 +1306,7 @@
 			};
 		tmp[i--] = new zaimoni::Token<char>(define_buf,0,strlen(define_buf),0);
 		// INT_C
-		memset_strcpy<sizeof("#define ")-1,sizeof(define_buf)>(define_buf,"INT");
+		memset_strcpy<sizeof("#define ")-1>(define_buf,"INT",define_buf.size());
 		strcat(define_buf,buf+1);
 		strcat(define_buf,"_C(A) A");
 		int_suffix = signed_suffix_from_machine(least_type);
@@ -1266,37 +1317,37 @@
 			};
 		tmp[i--] = new zaimoni::Token<char>(define_buf,0,strlen(define_buf),0);
 		// UINT_FAST_MAX
-		memset_strcpy<sizeof("#define ")-1,sizeof(define_buf)>(define_buf,"UINT_FAST");
+		memset_strcpy<sizeof("#define ")-1>(define_buf,"UINT_FAST",define_buf.size());
 		strcat(define_buf,buf+1);
 		strcat(define_buf,"_MAX");
 		strcat(define_buf,unsigned_max_buf[fast_type-1]);
 		tmp[i--] = new zaimoni::Token<char>(define_buf,0,strlen(define_buf),0);
 		// INT_FAST_MAX
-		memset_strcpy<sizeof("#define ")-1,sizeof(define_buf)>(define_buf,"INT_FAST");
+		memset_strcpy<sizeof("#define ")-1>(define_buf,"INT_FAST",define_buf.size());
 		strcat(define_buf,buf+1);
 		strcat(define_buf,"_MAX");
 		strcat(define_buf,signed_max_buf[fast_type-1]);
 		tmp[i--] = new zaimoni::Token<char>(define_buf,0,strlen(define_buf),0);
 		// INT_FAST_MIN
-		memset_strcpy<sizeof("#define ")-1,sizeof(define_buf)>(define_buf,"INT_FAST");
+		memset_strcpy<sizeof("#define ")-1>(define_buf,"INT_FAST",define_buf.size());
 		strcat(define_buf,buf+1);
 		strcat(define_buf,"_MIN ");
 		strcat(define_buf,signed_min_buf[fast_type-1]);
 		tmp[i--] = new zaimoni::Token<char>(define_buf,0,strlen(define_buf),0);
 		// UINT_LEAST_MAX
-		memset_strcpy<sizeof("#define ")-1,sizeof(define_buf)>(define_buf,"UINT_LEAST");
+		memset_strcpy<sizeof("#define ")-1>(define_buf,"UINT_LEAST",define_buf.size());
 		strcat(define_buf,buf+1);
 		strcat(define_buf,"_MAX");
 		strcat(define_buf,unsigned_max_buf[least_type-1]);
 		tmp[i--] = new zaimoni::Token<char>(define_buf,0,strlen(define_buf),0);
 		// INT_LEAST_MAX
-		memset_strcpy<sizeof("#define ")-1,sizeof(define_buf)>(define_buf,"INT_LEAST");
+		memset_strcpy<sizeof("#define ")-1>(define_buf,"INT_LEAST",define_buf.size());
 		strcat(define_buf,buf+1);
 		strcat(define_buf,"_MAX");
 		strcat(define_buf,signed_max_buf[least_type-1]);
 		tmp[i--] = new zaimoni::Token<char>(define_buf,0,strlen(define_buf),0);
 		// INT_LEAST_MIN
-		memset_strcpy<sizeof("#define ")-1,sizeof(define_buf)>(define_buf,"INT_LEAST");
+		memset_strcpy<sizeof("#define ")-1>(define_buf,"INT_LEAST",define_buf.size());
 		strcat(define_buf,buf+1);
 		strcat(define_buf,"_MIN ");
 		strcat(define_buf,signed_min_buf[least_type-1]);

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-01-10 23:01:56 UTC (rev 326)
+++ trunk/CSupport.cpp	2010-01-11 19:12:14 UTC (rev 327)
@@ -5232,7 +5232,12 @@
 #endif
 {
 	const char* const suffix = literal_suffix(base_type_index);
+#ifdef ZCC_LEGACY_FIXED_INT
 	char buf[(VM_MAX_BIT_PLATFORM/3)+4];	// null-termination: 1 byte; 3 bytes for type hint
+#else
+	char* buf = _new_buffer<char>((VM_MAX_BIT_PLATFORM/3)+4);
+	if (!buf) return false;
+#endif
 	dest.second = literal_flags(base_type_index);
 	dest.second |= C_TESTFLAG_DECIMAL;
 	z_ucharint_toa(src_int,buf,10);
@@ -5241,8 +5246,19 @@
 	if (suffix) strcat(buf,suffix);
 
 	dest.first = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(strlen(buf)));
+#ifdef ZCC_LEGACY_FIXED_INT
 	if (!dest.first) return false;
+#else
+	if (!dest.first)
+		{
+		free(buf);
+		return false;
+		}
+#endif
 	strcpy(dest.first,buf);
+#ifndef ZCC_LEGACY_FIXED_INT
+	free(buf);
+#endif
 	return true;
 }
 



From zaimoni at mail.berlios.de  Fri Jan 15 07:22:20 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 15 Jan 2010 07:22:20 +0100
Subject: [Zcplusplus-commits] r328 - trunk
Message-ID: <201001150622.o0F6MKd1022377@sheep.berlios.de>

Author: zaimoni
Date: 2010-01-15 07:22:09 +0100 (Fri, 15 Jan 2010)
New Revision: 328

Modified:
   trunk/POSIX.dep
   trunk/errors.cpp
   trunk/errors.hpp
   trunk/z_cpp.cpp
   trunk/zcc.cpp
Log:
target-control options (some combinations may not be that functional yet)

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-01-11 19:12:14 UTC (rev 327)
+++ trunk/POSIX.dep	2010-01-15 06:22:09 UTC (rev 328)
@@ -1,12 +1,12 @@
 OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
-OBJECTS_Z_CPP_LINK_PRIORITY = unsigned_var_int.o CPUInfo.o unsigned_aux.o uchar_blob.o struct_type.o CSupport.o type_spec.o CPreproc_autogen.o z_cpp.o CPreproc.o load_src.o errors.o ParseTree.o type_system.o str_aux.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o AtomicString.o langroute.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_Z_CPP_LINK_PRIORITY = z_cpp.o errors.o CPreproc_autogen.o CSupport.o CPUInfo.o unsigned_var_int.o CPreproc.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o ParseTree.o type_system.o str_aux.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o AtomicString.o langroute.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
 OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = unsigned_var_int.o CPUInfo.o unsigned_aux.o uchar_blob.o struct_type.o CSupport.o type_spec.o CPreproc_autogen.o zcc.o CPreproc.o load_src.o errors.o ParseTree.o type_system.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o AtomicString.o langroute.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_ZCC_LINK_PRIORITY = zcc.o errors.o CPreproc_autogen.o CSupport.o CPUInfo.o unsigned_var_int.o CPreproc.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o ParseTree.o type_system.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o AtomicString.o langroute.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
 # dependencies
-z_cpp.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
-errors.o: errors.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
+z_cpp.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
+errors.o: errors.hpp langroute.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 langroute.o: langroute.hpp CSupport.hpp Zaimoni.STL/Logging.h Zaimoni.STL/POD.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp
 AtomicString.o: AtomicString.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 str_aux.o: str_aux.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -31,5 +31,5 @@
 load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/comptest.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
 CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
-zcc.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
+zcc.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
 ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp

Modified: trunk/errors.cpp
===================================================================
--- trunk/errors.cpp	2010-01-11 19:12:14 UTC (rev 327)
+++ trunk/errors.cpp	2010-01-15 06:22:09 UTC (rev 328)
@@ -1,10 +1,12 @@
 // errors.cpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #include "errors.hpp"
+#include "langroute.hpp"
 #include "Zaimoni.STL/OS/mutex.hpp"
 #include "Zaimoni.STL/POD.hpp"
 #include "Zaimoni.STL/Logging.h"
+#include "Zaimoni.STL/Pure.C/format_util.h"
 
 const bool bool_options_default[MAX_OPT_BOOL]
 	= 	{	default_option(boolean_option(0)),
@@ -41,9 +43,111 @@
 			default_option(string_option(1))
 		};
 
+/*! 
+ * If the given string is recognized as a language, set stringopt::lang.
+ * Otherwise, be ACID and don't update anything.
+ *
+ * \pre string is safe to pin for program duration
+ *
+ * \param x candidate language string
+ * 
+ * \return true iff language was accepted
+ */
+bool interpret_stringopt_lang(const char* x)
+{
+	const char* test = echo_valid_lang(x);
+	if (NULL==test) return false;
+	string_options[stringopt::lang] = test;
+	return true;
+}
+
+/*! 
+ * just pass through the proposed header name with only minimal reality checking
+ * 
+ * \param x system header name to check
+ * 
+ * \return bool (always true)
+ */
+static bool interpret_stringopt_system_include(const char* x)
+{
+	string_options[stringopt::system_include] = x;
+	return true;
+}
+
+string_opt_handler* option_handler_string[MAX_OPT_STRING]
+	=	{	default_handler(string_option(0)),
+			default_handler(string_option(1))
+		};
+
 int int_options[MAX_OPT_INT]
-	= {default_option(int_option(0))};
+	= 	{	default_option(int_option(0)),
+			default_option(int_option(1)),
+			default_option(int_option(2)),
+			default_option(int_option(3)),
+			default_option(int_option(4)),
+			default_option(int_option(5))
+		};
 
+
+static bool interpret_intopt_error_ub(const char* x)
+{
+	uintmax_t tmp = z_atoumax(x,10);
+	if (0>=tmp || INT_MAX<tmp) return false;
+	int_options[intopt::error_ub] = tmp;
+	return true;
+}
+
+static bool interpret_intopt_target_char_bit(const char* x)
+{
+	uintmax_t tmp = z_atoumax(x,10);
+	if (0>=tmp || (USHRT_MAX<INT_MAX ? USHRT_MAX : INT_MAX)<tmp) return false;
+	int_options[intopt::target_char_bit] = tmp;
+	return true;
+}
+
+static bool interpret_intopt_target_short_size(const char* x)
+{
+	uintmax_t tmp = z_atoumax(x,10);
+	if (0>=tmp || (USHRT_MAX<INT_MAX ? USHRT_MAX : INT_MAX)<tmp) return false;
+	int_options[intopt::target_char_bit] = tmp;
+	return true;
+}
+
+static bool interpret_intopt_target_int_size(const char* x)
+{
+	uintmax_t tmp = z_atoumax(x,10);
+	if (0>=tmp || (USHRT_MAX<INT_MAX ? USHRT_MAX : INT_MAX)<tmp) return false;
+	int_options[intopt::target_char_bit] = tmp;
+	return true;
+}
+
+static bool interpret_intopt_target_long_size(const char* x)
+{
+	uintmax_t tmp = z_atoumax(x,10);
+	if (0>=tmp || (USHRT_MAX<INT_MAX ? USHRT_MAX : INT_MAX)<tmp) return false;
+	int_options[intopt::target_char_bit] = tmp;
+	return true;
+}
+
+static bool interpret_intopt_target_long_long_size(const char* x)
+{
+	uintmax_t tmp = z_atoumax(x,10);
+	if (0>=tmp || (USHRT_MAX<INT_MAX ? USHRT_MAX : INT_MAX)<tmp) return false;
+	int_options[intopt::target_char_bit] = tmp;
+	return true;
+}
+
+string_opt_handler* option_handler_int[MAX_OPT_INT]
+	=	{	default_handler(int_option(0)),
+			default_handler(int_option(1)),
+			default_handler(int_option(2)),
+			default_handler(int_option(3)),
+			default_handler(int_option(4)),
+			default_handler(int_option(5))
+		};
+
+// unsigned short _char_bit, unsigned short _sizeof_short, unsigned short _sizeof_int, unsigned short _sizeof_long, unsigned short _sizeof_long_long
+
 zaimoni::OS::mutex errno_mutex;
 
 #ifndef NDEBUG
@@ -85,16 +189,53 @@
 	// platform-specific goo
 	// for now, go with Intel
 	// this should be overridable by command-line options
+	bool unreal_config = false;
 	// deal with the int-format options
 	{	// handle integer representation trait options
 	const unsigned int int_opt_count = bool_options[boolopt::int_sign_magnitude]+bool_options[boolopt::int_ones_complement]+bool_options[boolopt::int_twos_complement];
-	if (2<=int_opt_count) FATAL("error: the integer format options are mutually exclusive");
+	if (2<=int_opt_count)
+		{
+		INFORM("error: the integer format options are mutually exclusive");
+		unreal_config = true;
+		}
 	if (0==int_opt_count) bool_options[boolopt::int_twos_complement] = true;	// go with intel for now
 	}
 	{	// handle char as signed/unsigned char
 	const unsigned int char_opt_count = bool_options[boolopt::char_is_signed]+bool_options[boolopt::char_is_unsigned];
-	if (2<=char_opt_count) FATAL("error: the character format options are mutually exclusive");
+	if (2<=char_opt_count)
+		{
+		INFORM("error: the character format options are mutually exclusive");
+		unreal_config = true;
+		};
 	if (0==char_opt_count) bool_options[boolopt::char_is_unsigned] = true;	// unsigned makes our life easier
 	}
+	// target defaults: Win32 for now
+	// referencing C/C++ is intentional
+	if (!int_options[intopt::target_char_bit])
+		int_options[intopt::target_char_bit] = 8;
+	if (!int_options[intopt::target_short_size])
+		int_options[intopt::target_short_size] = 2;
+	if (!int_options[intopt::target_int_size])
+		int_options[intopt::target_int_size] = int_options[intopt::target_short_size]>4 ? int_options[intopt::target_short_size] : 4;
+	if (!int_options[intopt::target_long_size])
+		int_options[intopt::target_long_size] = int_options[intopt::target_int_size]>4 ? int_options[intopt::target_int_size] : 4;
+	if (!int_options[intopt::target_long_long_size])
+		int_options[intopt::target_long_long_size] = int_options[intopt::target_long_size]>8 ? int_options[intopt::target_long_size] : 8;
+	if (int_options[intopt::target_short_size]>int_options[intopt::target_int_size])
+		{
+		INFORM("C/C++ short must be at least as large as C/C++ int");
+		unreal_config = true;
+		}
+	if (int_options[intopt::target_int_size]>int_options[intopt::target_long_size])
+		{
+		INFORM("C/C++ int must be at least as large as C/C++ long");
+		unreal_config = true;
+		}
+	if (int_options[intopt::target_long_size]>int_options[intopt::target_long_long_size])
+		{
+		INFORM("C/C++ long must be at least as large as C/C++ long long");
+		unreal_config = true;
+		}
+	if (unreal_config) _fatal("Cannot target an unreal machine.");
 }
 

Modified: trunk/errors.hpp
===================================================================
--- trunk/errors.hpp	2010-01-11 19:12:14 UTC (rev 327)
+++ trunk/errors.hpp	2010-01-15 06:22:09 UTC (rev 328)
@@ -1,5 +1,5 @@
 // errors.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #ifndef ERRORS_HPP
 #define ERRORS_HPP 1
@@ -14,6 +14,8 @@
 template<class T1, class T2, class T3> struct POD_triple;
 }
 
+typedef bool string_opt_handler(const char* const);
+
 #define default_option2(A) DEFAULT_##A
 #define default_option(A) default_option2(A)
 #define default_handler2(A) HANDLER_##A
@@ -99,16 +101,40 @@
 
 namespace intopt {
 enum int_options {
-	error_ub = 0
+	error_ub = 0,
 #define int_option_0 error_ub
 #define int_option_error_ub 0
 #define DEFAULT_error_ub 100
 #define HANDLER_error_ub interpret_intopt_error_ub
-
+	target_char_bit,
+#define int_option_1 target_char_bit
+#define int_option_target_char_bit 1
+#define DEFAULT_target_char_bit 0
+#define HANDLER_target_char_bit interpret_intopt_target_char_bit
+	target_short_size,
+#define int_option_2 target_short_size
+#define int_option_target_short_size 2
+#define DEFAULT_target_short_size 0
+#define HANDLER_target_short_size interpret_intopt_target_short_size
+	target_int_size,
+#define int_option_3 target_int_size
+#define int_option_target_int_size 3
+#define DEFAULT_target_int_size 0
+#define HANDLER_target_int_size interpret_intopt_target_int_size
+	target_long_size,
+#define int_option_4 target_long_size
+#define int_option_target_long_size 4
+#define DEFAULT_target_long_size 0
+#define HANDLER_target_long_size interpret_intopt_target_long_size
+	target_long_long_size
+#define int_option_5 target_long_long_size
+#define int_option_target_long_long_size 5
+#define DEFAULT_target_long_long_size 0
+#define HANDLER_target_long_long_size interpret_intopt_target_long_long_size
 };
 
 #define int_option(A) int_option_##A
-#define MAX_OPT_INT (intopt::error_ub+1)
+#define MAX_OPT_INT (intopt::target_long_long_size+1)
 
 }
 
@@ -116,7 +142,9 @@
 extern const bool bool_options_default[MAX_OPT_BOOL];
 extern bool bool_options[MAX_OPT_BOOL];
 extern const char* string_options[MAX_OPT_STRING];
+extern string_opt_handler* option_handler_string[MAX_OPT_STRING];
 extern int int_options[MAX_OPT_INT];
+extern string_opt_handler* option_handler_int[MAX_OPT_INT];
 
 extern zaimoni::OS::mutex errno_mutex;
 
@@ -127,6 +155,8 @@
 int recognize_bool_option(const char* const x,const zaimoni::POD_triple<const char*, size_t, const char*>* option_map,size_t j);
 int recognize_parameter_option(const char* const x,const zaimoni::POD_triple<const char*, size_t, const char*>* option_map,size_t j);
 
+bool interpret_stringopt_lang(const char* x);
+
 void message_header(const char* const filename, size_t line_number);
 void enforce_mutually_exclusive_exhaustive_options(void);
 

Modified: trunk/z_cpp.cpp
===================================================================
--- trunk/z_cpp.cpp	2010-01-11 19:12:14 UTC (rev 327)
+++ trunk/z_cpp.cpp	2010-01-15 06:22:09 UTC (rev 328)
@@ -15,7 +15,6 @@
 #include "errcount.hpp"
 
 #include "Zaimoni.STL/POD.hpp"
-#include "Zaimoni.STL/Pure.C/format_util.h"
 
 #include <stdio.h>
 
@@ -36,35 +35,20 @@
 		{ "--int-neg-div-rounds-away-from-zero",	boolopt::int_neg_div_rounds_away_from_zero, 	"make -3/-2==-2 contrary to C99 recommendation\n"}
 	};
 
-typedef bool string_opt_handler(const char* const);
-
 static const POD_triple<const char*, size_t, const char*> option_map_string[]
 	=	{	{ "-x",	stringopt::lang, "language override\n"},		// GCC compatibility
 			{ "--system-include",	stringopt::system_include, "unpreprocessed #include<...> to stdout\n"}
 		};
 
 static const POD_triple<const char*, size_t, const char*> option_map_int[]
-=	{	{ "-fmax-errors",		intopt::error_ub, 					"how many errors are too many (default 100)\n"}	// GFortran compatibility
-	};
+=	{	{ "-fmax-errors",		intopt::error_ub, 					"how many errors are too many (default 100)\n"},	// GFortran compatibility
+		{"--target-char-bit",	intopt::target_char_bit,	"target CHAR_BIT\n"},
+		{"--target-sizeof-short",	intopt::target_short_size,	"target sizeof(short), sizeof(unsigned short)\n"},
+		{"--target-sizeof-int",	intopt::target_int_size,	"target sizeof(int), sizeof(unsigned int)\n"},
+		{"--target-sizeof-long",	intopt::target_long_size,	"target sizeof(long), sizeof(unsigned long)\n"},
+		{"--target-sizeof-long-long",	intopt::target_long_long_size,	"target sizeof(long long), sizeof(unsigned long long)\n"}
+	}; 
 
-/*! 
- * If the given string is recognized as a language, set stringopt::lang.
- * Otherwise, be ACID and don't update anything.
- *
- * \pre string is safe to pin for program duration
- *
- * \param x candidate language string
- * 
- * \return true iff language was accepted
- */
-static bool interpret_stringopt_lang(const char* x)
-{
-	const char* test = echo_valid_lang(x);
-	if (NULL==test) return false;
-	string_options[stringopt::lang] = test;
-	return true;
-}
-
 void guess_lang_from_filename(const char* const x)
 {
 	if (!x || !*x) return;
@@ -92,35 +76,6 @@
 		}
 }
 
-/*! 
- * just pass through the proposed header name with only minimal reality checking
- * 
- * \param x system header name to check
- * 
- * \return bool (always true)
- */
-bool interpret_stringopt_system_include(const char* x)
-{
-	string_options[stringopt::system_include] = x;
-	return true;
-}
-
-static string_opt_handler* option_handler_string[MAX_OPT_STRING]
-	=	{	default_handler(string_option(0)),
-			default_handler(string_option(1))
-		};
-
-static bool interpret_intopt_error_ub(const char* x)
-{
-	uintmax_t tmp = z_atoumax(x,10);
-	if (0>=tmp || INT_MAX<tmp) return false;
-	int_options[intopt::error_ub] = tmp;
-	return true;
-}
-
-static string_opt_handler* option_handler_int[MAX_OPT_STRING]
-	=	{default_handler(int_option(0))};
-
 static bool process_options(const size_t argc, char* argv[])
 {
 	size_t last_arg_used_in_option = 0;
@@ -239,18 +194,16 @@
 	// error count enforcement
 	zcc_errors.set_error_ub(int_options[intopt::error_ub]);
 
-	virtual_machine::CPUInfo target_machine(8,2,4,4,8,(bool_options[boolopt::int_twos_complement]) ? virtual_machine::twos_complement : (bool_options[boolopt::int_ones_complement]) ? virtual_machine::ones_complement : virtual_machine::sign_and_magnitude,bool_options[boolopt::char_is_signed],virtual_machine::std_int_int);
+	virtual_machine::CPUInfo target_machine(int_options[intopt::target_char_bit],
+											int_options[intopt::target_short_size],
+											int_options[intopt::target_int_size],
+											int_options[intopt::target_long_size],
+											int_options[intopt::target_long_long_size],
+											(bool_options[boolopt::int_twos_complement]) ? virtual_machine::twos_complement : (bool_options[boolopt::int_ones_complement]) ? virtual_machine::ones_complement : virtual_machine::sign_and_magnitude,
+											bool_options[boolopt::char_is_signed],
+											virtual_machine::std_int_int);
 
 	// check that we actually can preprocess for this machine
-	//! \todo remove these limitations at some point
-	if (CHAR_BIT<target_machine.C_char_bit())
-		{
-		INC_INFORM("error: target machine has larger CHAR_BIT than ours [");
-		INC_INFORM(target_machine.C_char_bit());
-		INC_INFORM(" vs ");
-		INC_INFORM((uintmax_t)(CHAR_BIT));
-		FATAL("]");
-		};
 	if (7>target_machine.C_char_bit())
 		{
 		INC_INFORM("error: target machine CHAR_BIT<7 cannot represent C source character set");
@@ -259,14 +212,6 @@
 		INC_INFORM((uintmax_t)(CHAR_BIT));
 		FATAL("]");
 		};
-	if (C_UNICODE_MAX<target_machine.unsigned_max(target_machine.UNICODE_wchar_t()))
-		{
-		INC_INFORM("error: target machine has larger unsigned WCHAR_MAX than ours [");
-		INC_INFORM(target_machine.unsigned_max(target_machine.UNICODE_wchar_t()).to_uint());
-		INC_INFORM(" vs ");
-		INC_INFORM((uintmax_t)(C_UNICODE_MAX));
-		FATAL("]");
-		};
 
 	try	{
 		autovalarray_ptr<Token<char>* > TokenList;

Modified: trunk/zcc.cpp
===================================================================
--- trunk/zcc.cpp	2010-01-11 19:12:14 UTC (rev 327)
+++ trunk/zcc.cpp	2010-01-15 06:22:09 UTC (rev 328)
@@ -17,7 +17,6 @@
 #include "ZParser.hpp"
 
 #include "Zaimoni.STL/POD.hpp"
-#include "Zaimoni.STL/Pure.C/format_util.h"
 
 #include <stdio.h>
 
@@ -40,35 +39,20 @@
 		{ "-Wbackport",	boolopt::warn_backport,	"Warn when something legal would be an error under an older standard\n"}
 	};
 
-typedef bool string_opt_handler(const char* const);
-
 static const POD_triple<const char*, size_t, const char*> option_map_string[]
 	=	{	{ "-x",	stringopt::lang, "language override\n"},		// GCC compatibility
 			{ "--system-include",	stringopt::system_include, "unpreprocessed #include<...> to stdout\n"}
 		};
 
 static const POD_triple<const char*, size_t, const char*> option_map_int[]
-=	{	{ "-fmax-errors",		intopt::error_ub, 					"how many errors are too many (default 100)\n"}	// GFortran compatibility
-	};
+=	{	{ "-fmax-errors",		intopt::error_ub, 					"how many errors are too many (default 100)\n"},	// GFortran compatibility
+		{"--target-char-bit",	intopt::target_char_bit,	"target CHAR_BIT\n"},
+		{"--target-sizeof-short",	intopt::target_short_size,	"target sizeof(short), sizeof(unsigned short)\n"},
+		{"--target-sizeof-int",	intopt::target_int_size,	"target sizeof(int), sizeof(unsigned int)\n"},
+		{"--target-sizeof-long",	intopt::target_long_size,	"target sizeof(long), sizeof(unsigned long)\n"},
+		{"--target-sizeof-long-long",	intopt::target_long_long_size,	"target sizeof(long long), sizeof(unsigned long long)\n"}
+	}; 
 
-/*! 
- * If the given string is recognized as a language, set stringopt::lang.
- * Otherwise, be ACID and don't update anything.
- *
- * \pre string is safe to pin for program duration
- *
- * \param x candidate language string
- * 
- * \return true iff language was accepted
- */
-static bool interpret_stringopt_lang(const char* x)
-{
-	const char* test = echo_valid_lang(x);
-	if (NULL==test) return false;
-	string_options[stringopt::lang] = test;
-	return true;
-}
-
 void guess_lang_from_filename(const char* const x)
 {
 	if (!x || !*x) return;
@@ -96,35 +80,6 @@
 		}
 }
 
-/*! 
- * just pass through the proposed header name with only minimal reality checking
- * 
- * \param x system header name to check
- * 
- * \return bool (always true)
- */
-bool interpret_stringopt_system_include(const char* x)
-{
-	string_options[stringopt::system_include] = x;
-	return true;
-}
-
-static string_opt_handler* option_handler_string[MAX_OPT_STRING]
-	=	{	default_handler(string_option(0)),
-			default_handler(string_option(1))
-		};
-
-static bool interpret_intopt_error_ub(const char* x)
-{
-	uintmax_t tmp = z_atoumax(x,10);
-	if (0>=tmp || INT_MAX<tmp) return false;
-	int_options[intopt::error_ub] = tmp;
-	return true;
-}
-
-static string_opt_handler* option_handler_int[MAX_OPT_STRING]
-	=	{default_handler(int_option(0))};
-
 static bool process_options(const size_t argc, char* argv[])
 {
 	size_t last_arg_used_in_option = 0;
@@ -243,18 +198,16 @@
 	// error count enforcement
 	zcc_errors.set_error_ub(int_options[intopt::error_ub]);
 
-	virtual_machine::CPUInfo target_machine(8,2,4,4,8,(bool_options[boolopt::int_twos_complement]) ? virtual_machine::twos_complement : (bool_options[boolopt::int_ones_complement]) ? virtual_machine::ones_complement : virtual_machine::sign_and_magnitude,bool_options[boolopt::char_is_signed],virtual_machine::std_int_int);
+	virtual_machine::CPUInfo target_machine(int_options[intopt::target_char_bit],
+											int_options[intopt::target_short_size],
+											int_options[intopt::target_int_size],
+											int_options[intopt::target_long_size],
+											int_options[intopt::target_long_long_size],
+											(bool_options[boolopt::int_twos_complement]) ? virtual_machine::twos_complement : (bool_options[boolopt::int_ones_complement]) ? virtual_machine::ones_complement : virtual_machine::sign_and_magnitude,
+											bool_options[boolopt::char_is_signed],
+											virtual_machine::std_int_int);
 
 	// check that we actually can preprocess for this machine
-	//! \todo remove these limitations at some point
-	if (CHAR_BIT<target_machine.C_char_bit())
-		{
-		INC_INFORM("error: target machine has larger CHAR_BIT than ours [");
-		INC_INFORM(target_machine.C_char_bit());
-		INC_INFORM(" vs ");
-		INC_INFORM((uintmax_t)(CHAR_BIT));
-		FATAL("]");
-		};
 	if (7>target_machine.C_char_bit())
 		{
 		INC_INFORM("error: target machine CHAR_BIT<7 cannot represent C source character set");
@@ -263,14 +216,6 @@
 		INC_INFORM((uintmax_t)(CHAR_BIT));
 		FATAL("]");
 		};
-	if (C_UNICODE_MAX<target_machine.unsigned_max(target_machine.UNICODE_wchar_t()))
-		{
-		INC_INFORM("error: target machine has larger unsigned WCHAR_MAX than ours [");
-		INC_INFORM(target_machine.unsigned_max(target_machine.UNICODE_wchar_t()).to_uint());
-		INC_INFORM(" vs ");
-		INC_INFORM((uintmax_t)(C_UNICODE_MAX));
-		FATAL("]");
-		};
 
 	try	{
 		autovalarray_ptr<Token<char>*> TokenList;



From zaimoni at mail.berlios.de  Thu Jan 21 05:08:26 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 21 Jan 2010 05:08:26 +0100
Subject: [Zcplusplus-commits] r329 - trunk
Message-ID: <201001210408.o0L48QdA022420@sheep.berlios.de>

Author: zaimoni
Date: 2010-01-21 05:08:20 +0100 (Thu, 21 Jan 2010)
New Revision: 329

Modified:
   trunk/CSupport.cpp
   trunk/type_system.cpp
   trunk/type_system.hpp
Log:
formally bring up the enumerator support, but don't take it live yet; new #if 0 code should be leaky

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-01-15 06:22:09 UTC (rev 328)
+++ trunk/CSupport.cpp	2010-01-21 04:08:20 UTC (rev 329)
@@ -10864,16 +10864,17 @@
 	src.DeleteNSlotsAt<0>(j-i+1,i);
 }
 
-static bool record_enum_values(parse_tree& src, type_system& types, const char* const enum_name, const char* const active_namespace,bool allow_empty,func_traits<const char* (*)(const char*, size_t)>::function_ref_type echo_reserved_keyword)
+static bool record_enum_values(parse_tree& src, type_system& types, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits<const char* (*)(const char*, size_t)>::function_ref_type echo_reserved_keyword)
 {
-	assert(!enum_name || *enum_name);
+	assert(enum_type_index);
 	assert(!active_namespace || *active_namespace);
 	assert(is_naked_brace_pair(src));
 	// enumeration idea:
 	// * identifer [= ...] ,
 	// terminal , is optional (and in fact should trigger a warning for -Wbackport)
 	// empty collection of enumerators is fine for C++, rejected by C (should be error in C and -Wc-c++-compat for C++)
-	// values would be unsigned_fixed_int<VM_MAX_BIT_PLATFORM>
+	// XXX use allow_empty to signal C vs. C++ language
+	// values would be unsigned_var_int
 	if (src.empty<0>())
 		{
 		if (!allow_empty)
@@ -10974,8 +10975,8 @@
 		}
 	//! \todo actually record enumerator matchings
 #if 0
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> latest_value(0);
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> prior_value;
+	unsigned_var_int latest_value(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
+	unsigned_var_int prior_value(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 	i = 0;
 	while(src.size<0>()>i)
 		{	// require identifier that is neither keyword nor a primitive type
@@ -10989,14 +10990,21 @@
 		assert(!echo_reserved_keyword(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].token.second));
 		char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[0].token.first,active_namespace,"::") : NULL;
 		const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[0].token.first;
-
-		if (types.enumerator_already_defined(fullname,prior_value))
+		{
+		const type_system::enumerator_info* tmp = types.get_enumerator(fullname);
+		if (tmp)
 			{	// --do-what-i-mean could recover if the prior definition were identical
 				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined
 				// C++: One Definition Rule wipes out
+			message_header(src.data<0>()[i].index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM("enumerator is already defined (C99 6.7.2.2p3/C++98 3.2)");
+			zcc_errors.inc_error();
 			free(namespace_name);
 			return false;
 			};
+		}
+#if 0
 		// next proposed function call is a bit handwavish right now...
 		// C++0X 3.3.1p4: enumerator gets to hide class names and enum names, nothing else [in particular dies against typedefs and functions]
 		if (types.enum_already_defined(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
@@ -11011,15 +11019,32 @@
 		if (types.typedef_already_defined(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
 			{	// C++: One Definition Rule
 			};
+#endif
+		// The type and representation of an enumeration varies by language
+		// C: values are type int; actual representation can be decided after seeing all enumeration values.
+		// C++: if the underlying type is fixed, then the enumerator is of that type.  Othewise,
+		// each enumerator has the same type as its initializing expression, and the underlying type of
+		// the enumeration is large enough to represent all values.
+		// So, for the default-update cases
+		// C: type int, hard-error if going above INT_MAX
+		// C++: type per language specification,
+		// * hard-error if going above ULONG_MAX
+		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
 		if (1>=src.size<0>()-i)
 			{	// default-update
-			types.register_enum(enum_name,active_namespace,src.data<0>()[i].index_tokens[0].token.first,latest_value);
+			// if (active_namespace)
+			//		types.set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,unsigned char representation,latest_value,enum_type_index)
+			// else
+			//		types.set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,unsigned char representation,latest_value,enum_type_index);
 			break;
 			}
 		// complete conversion
+		// C: type int, hard-error if not within INT_MIN..INT_MAX
+		// C++: type per language specification
+		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
 		if (robust_token_is_char<','>(src.data<0>()[i+1]))
 			{	// would default-update
-			types.register_enum(enum_name,active_namespace,src.data<0>()[i].index_tokens[0].token.first,latest_value);
+			// ...
 			i += 2;
 			continue;
 			};
@@ -11038,8 +11063,9 @@
 		// probably have this already....
 		if (!eval_expression(src,origin,i,latest_value))
 			return false;
-		types.register_enum(enum_name,active_namespace,src.data<0>()[i].index_tokens[0].token.first,latest_value);
+		// ...
 		}
+	// now ok to crunch underlying type/machine representation
 #endif
 	return true;
 }
@@ -11168,7 +11194,7 @@
 			//! \test zcc\decl.C99\Pass_enum_def.h
 			const type_system::type_index tmp2 = types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			assert(types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,false,C99_echo_reserved_keyword))
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp2,NULL,false,C99_echo_reserved_keyword))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;
@@ -11178,7 +11204,7 @@
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 			const type_system::type_index tmp = types.register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,NULL,NULL,false,C99_echo_reserved_keyword))
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp,NULL,false,C99_echo_reserved_keyword))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;
@@ -11686,7 +11712,7 @@
 			// enum-specifier doesn't have a specific declaration mode
 			const type_system::type_index tmp2 = types.register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			assert(types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp2,NULL,true,CPP_echo_reserved_keyword))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;
@@ -11696,7 +11722,7 @@
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 			const type_system::type_index tmp = types.register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp,NULL,true,CPP_echo_reserved_keyword))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2010-01-15 06:22:09 UTC (rev 328)
+++ trunk/type_system.cpp	2010-01-21 04:08:20 UTC (rev 329)
@@ -317,21 +317,21 @@
 
 const zaimoni::POD_triple<type_spec,const char*,size_t>* type_system::_get_typedef_CPP(const char* const alias) const
 {
-	errr tmp = binary_find(alias,strlen(alias),typedef_registry.data(),typedef_registry.size());
-	if (0<=tmp) return &typedef_registry[tmp].second;
+	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = get_typedef(alias);
+	if (tmp) return tmp;
+
 	// hmm...not an exact match
 	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(alias);
-	if (0<=tmp2.first)
-		{	// it was remapped
-		while(tmp2.first<tmp2.second)
-			{
-			tmp = binary_find(inline_namespace_alias_map.data()[tmp2.first].second,strlen(inline_namespace_alias_map.data()[tmp2.first].second),typedef_registry.data(),typedef_registry.size());
-			if (0<=tmp) return &typedef_registry[tmp].second;
-			}
-		tmp = binary_find(inline_namespace_alias_map.data()[tmp2.first].second,strlen(inline_namespace_alias_map.data()[tmp2.first].second),typedef_registry.data(),typedef_registry.size());
-		if (0<=tmp) return &typedef_registry[tmp].second;
+	if (0>tmp2.first) return NULL;
+
+	// it was remapped
+	while(tmp2.first<tmp2.second)
+		{
+		tmp = get_typedef(inline_namespace_alias_map.data()[tmp2.first].second);
+		if (tmp) return tmp;
+		++tmp2.first;
 		}
-	return NULL;
+	return get_typedef(inline_namespace_alias_map.data()[tmp2.first].second);
 }
 
 const zaimoni::POD_triple<type_spec,const char*,size_t>* type_system::get_typedef_CPP(const char* alias,const char* active_namespace) const
@@ -373,8 +373,105 @@
 	return _get_typedef_CPP(alias);
 }
 
+void type_system::set_enumerator_def(const char* const alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename,unsigned char representation,const uchar_blob& src,type_index type)
+{
+	assert(alias && *alias);
+	assert(src_filename && *src_filename);
+	errr tmp = binary_find(alias,strlen(alias),enumerator_registry.data(),enumerator_registry.size());
+	assert(0>tmp);		// error to call with conflicting prior definition
+	if (0<=tmp) return;	// conflicting prior definition
+#if UINTMAX_MAX==SIZE_MAX
+	if (-1==tmp) _fatal("implementation limit exceeded (enumerators registered at once)");
+#endif
+	enumerator_info tmp2 = {alias, { {type, representation, src}, {src_filename, logical_line} } };
+	if (!enumerator_registry.InsertSlotAt(BINARY_SEARCH_DECODE_INSERTION_POINT(tmp),tmp2)) throw std::bad_alloc();
+}
+
+void type_system::set_enumerator_def_CPP(const char* name, const char* const active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename,unsigned char representation,const uchar_blob& src,type_index type)
+{
+	assert(name && *name);
+	assert(src_filename && *src_filename);
+
+	// use active namespace if present
+	if (active_namespace && *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	set_enumerator_def(name,logical_line,src_filename,representation,src,type);
+}
+
+const type_system::enumerator_info* type_system::get_enumerator(const char* const alias) const
+{
+	assert(alias && *alias);
+	//! \todo: strip off trailing inline namespaces
+	// <unknown> is the hack for anonymous namespaces taken from GCC, it's always inline
+	errr tmp = binary_find(alias,strlen(alias),enumerator_registry.data(),enumerator_registry.size());
+	if (0<=tmp) return &enumerator_registry[tmp];
+	return NULL;
+}
+
+const type_system::enumerator_info* type_system::_get_enumerator_CPP(const char* const alias) const
+{
+	const enumerator_info* tmp = get_enumerator(alias);
+	if (tmp) return tmp;
+
+	// hmm...not an exact match
+	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(alias);
+	if (0>tmp2.first) return NULL;
+
+	// it was remapped
+	while(tmp2.first<tmp2.second)
+		{
+		tmp = get_enumerator(inline_namespace_alias_map.data()[tmp2.first].second);
+		if (tmp) return tmp;
+		++tmp2.first;
+		}
+	return get_enumerator(inline_namespace_alias_map.data()[tmp2.first].second);
+}
+
+const type_system::enumerator_info* type_system::get_enumerator_CPP(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+
+	if (!strncmp(alias,"::",2))
+		{	// fully-qualified typedef name
+			// cheat: pretend not fully qualified but no surrounding namespace
+		alias += 2;
+		active_namespace = NULL;
+		};
+	if (active_namespace && *active_namespace)
+		{
+		// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		if (is_string_registered(tmp_alias))
+			{	// registered, so could be indexed
+			const enumerator_info* tmp2 = _get_enumerator_CPP(tmp_alias);
+			if (tmp2) return (free(tmp_alias),tmp2);
+			}
+
+		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
+		if (extra_namespaces)
+			{
+			zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
+			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				--i;
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,"::");
+				const enumerator_info* tmp2 = _get_enumerator_CPP(tmp_alias);
+				if (tmp2) return (free(tmp_alias),tmp2);
+				}
+			while(0<i);
+			}
+		free(tmp_alias);
+		}
+	return _get_enumerator_CPP(alias);
+}
+
 char* type_system::_namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len)
-{
+{	// remove comment after other seven wrapper variants implemented
+//	assert(active_namespace && *active_namespace && 0<active_namespace_len && active_namespace_len<=strlen(active_namespace));
+//	assert(name && *name && 0<name_len && name_len<=strlen(name));
+//	assert(namespace_separator && *namespace_separator && 0<namespace_separator_len && namespace_separator_len<=strlen(namespace_separator));
 	char* const actual_name = zaimoni::_new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(active_namespace_len+2+name_len));
 	strncpy(actual_name,active_namespace,active_namespace_len);
 	strncpy(actual_name+active_namespace_len,namespace_separator,namespace_separator_len);
@@ -383,7 +480,11 @@
 }
 
 void type_system::_namespace_concatenate(char* buf, const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len)
-{
+{	// remove comment after other seven wrapper variants implemented
+//	assert(buf)
+//	assert(active_namespace && *active_namespace && 0<active_namespace_len && active_namespace_len<=strlen(active_namespace));
+//	assert(name && *name && 0<name_len && name_len<=strlen(name));
+//	assert(namespace_separator && *namespace_separator && 0<namespace_separator_len && namespace_separator_len<=strlen(namespace_separator));
 	strncpy(buf,active_namespace,active_namespace_len);
 	strncpy(buf+active_namespace_len,namespace_separator,namespace_separator_len);
 	strncpy(buf+active_namespace_len+namespace_separator_len,name,name_len);

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2010-01-15 06:22:09 UTC (rev 328)
+++ trunk/type_system.hpp	2010-01-21 04:08:20 UTC (rev 329)
@@ -17,6 +17,9 @@
 {
 public:
 	typedef size_t type_index;
+	// { {type, representation, value}, {filename, location }}
+	// uchar_blob is a POD backing store for unsigned_var_int here
+	typedef zaimoni::POD_pair<const char*,zaimoni::POD_pair<zaimoni::POD_triple<type_index,unsigned char,uchar_blob>, zaimoni::POD_pair<const char*,zaimoni::POD_pair<size_t,size_t> > > > enumerator_info;
 
 	const zaimoni::POD_pair<const char* const,size_t>* const core_types;
 	const type_index* const int_priority;
@@ -28,6 +31,7 @@
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> > > typedef_registry;
 	zaimoni::weakautovalarray_ptr<const char*> inline_namespace_alias_targets;
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,const char*> > inline_namespace_alias_map;
+	zaimoni::autovalarray_ptr<enumerator_info> enumerator_registry;
 	// uncopyable
 	type_system(const type_system& src);
 	void operator=(const type_system& src);
@@ -97,6 +101,11 @@
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* get_typedef(const char* const alias) const;
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* get_typedef_CPP(const char* alias,const char* active_namespace) const;
 
+	void set_enumerator_def(const char* alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename,unsigned char representation,const uchar_blob& src,type_index type);
+	void set_enumerator_def_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename,unsigned char representation,const uchar_blob& src,type_index type);
+	const enumerator_info* get_enumerator(const char* alias) const;
+	const enumerator_info* get_enumerator_CPP(const char* alias,const char* active_namespace) const;
+
 	type_index register_functype(const char* const alias, function_type*& src);
 	type_index register_functype_CPP(const char* name, const char* active_namespace, function_type*& src);
 //	keyword actually should be type union_struct_decl::keywords, but that increases coupling unacceptably
@@ -122,6 +131,7 @@
 	const char* _name(type_index id) const;
 	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> dealias_inline_namespace_index(const char* alias) const;
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* _get_typedef_CPP(const char* alias) const;
+	const enumerator_info* _get_enumerator_CPP(const char* alias) const;
 
 	bool is_inline_namespace_CPP(const char* active_namespace, size_t active_namespace_len) const;
 	const char* canonical_name_is_inline_namespace_alias_target(const char* name, size_t name_len, const char* active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len) const;



From zaimoni at mail.berlios.de  Tue Jan 26 09:21:49 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 26 Jan 2010 09:21:49 +0100
Subject: [Zcplusplus-commits] r330 - in trunk: . tools
Message-ID: <201001260821.o0Q8Ln41006830@sheep.berlios.de>

Author: zaimoni
Date: 2010-01-26 09:21:44 +0100 (Tue, 26 Jan 2010)
New Revision: 330

Added:
   trunk/tools/selective_cut.py
Modified:
   trunk/CSupport.cpp
   trunk/unsigned_var_int.hpp
Log:
default-initialize enums; new utility script selective_cut.py

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-01-21 04:08:20 UTC (rev 329)
+++ trunk/CSupport.cpp	2010-01-26 08:21:44 UTC (rev 330)
@@ -10864,6 +10864,50 @@
 	src.DeleteNSlotsAt<0>(j-i+1,i);
 }
 
+static bool default_enumerator_init_legal(const bool allow_empty, unsigned char& current_enumerator_type, const unsigned_var_int& prior_value, const weak_token& src)
+{
+	if (allow_empty)
+		{
+		if (prior_value==target_machine->signed_max<virtual_machine::std_int_int>())
+			{	// signed integer overflow
+				//! \bug need test case
+			message_header(src);
+			INC_INFORM(ERR_STR);
+			INFORM("default-initialization of enumerator requires signed int overflow: undefined behavior (C99 6.7.2.2p3)");
+			zcc_errors.inc_error();
+			return false;
+			}
+		}
+	else{	//! \todo research how to rewrite this without the goto
+cpp_enum_was_retyped:
+		const promote_aux test(current_enumerator_type);
+		if (test.is_signed)
+			{
+			if (prior_value==target_machine->signed_max(test.machine_type))
+				{
+				++current_enumerator_type;	// smallest type that can handle this
+				goto cpp_enum_was_retyped;
+				}
+			}
+		else{
+			if (prior_value==target_machine->unsigned_max(test.machine_type))
+				{
+				if (C_TYPE::INTEGERLIKE == ++current_enumerator_type)	// smallest type that can handle this
+					{	// unsigned long long overflow, fact it's defined doesn't save us
+					//! \bug need test case
+					message_header(src);
+					INC_INFORM(ERR_STR);
+					INFORM("default-initialization of enumerator requires uintmax_t overflow (C++0X 7.2p5)");
+					zcc_errors.inc_error();
+					return false;
+					}
+				goto cpp_enum_was_retyped;
+				}
+			}
+		}
+	return true;
+}
+
 static bool record_enum_values(parse_tree& src, type_system& types, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits<const char* (*)(const char*, size_t)>::function_ref_type echo_reserved_keyword)
 {
 	assert(enum_type_index);
@@ -10974,9 +11018,9 @@
 		src.DeleteIdx<0>(src.size<0>()-1); // clean up anyway
 		}
 	//! \todo actually record enumerator matchings
-#if 0
 	unsigned_var_int latest_value(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 	unsigned_var_int prior_value(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
+	unsigned char current_enumerator_type = C_TYPE::INT;
 	i = 0;
 	while(src.size<0>()>i)
 		{	// require identifier that is neither keyword nor a primitive type
@@ -10988,6 +11032,7 @@
 		assert(C_TESTFLAG_IDENTIFIER==src.data<0>()[i].index_tokens[0].flags);
 		assert(!(PARSE_TYPE & src.data<0>()[i].flags));
 		assert(!echo_reserved_keyword(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].token.second));
+		{
 		char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[0].token.first,active_namespace,"::") : NULL;
 		const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[0].token.first;
 		{
@@ -10996,6 +11041,7 @@
 			{	// --do-what-i-mean could recover if the prior definition were identical
 				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined
 				// C++: One Definition Rule wipes out
+				//! \bug need test case
 			message_header(src.data<0>()[i].index_tokens[0]);
 			INC_INFORM(ERR_STR);
 			INFORM("enumerator is already defined (C99 6.7.2.2p3/C++98 3.2)");
@@ -11004,6 +11050,8 @@
 			return false;
 			};
 		}
+		free(namespace_name);
+		}
 #if 0
 		// next proposed function call is a bit handwavish right now...
 		// C++0X 3.3.1p4: enumerator gets to hide class names and enum names, nothing else [in particular dies against typedefs and functions]
@@ -11020,6 +11068,7 @@
 			{	// C++: One Definition Rule
 			};
 #endif
+
 		// The type and representation of an enumeration varies by language
 		// C: values are type int; actual representation can be decided after seeing all enumeration values.
 		// C++: if the underlying type is fixed, then the enumerator is of that type.  Othewise,
@@ -11030,12 +11079,37 @@
 		// C++: type per language specification,
 		// * hard-error if going above ULONG_MAX
 		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
+		// in any case, do not react if the default-init isn't used
+		value_copy(prior_value,latest_value);
+		bool value_is_nonnegative_or_twos_complement = true;
+		if (virtual_machine::twos_complement!=target_machine->C_signed_int_representation())
+			{
+			const promote_aux test(current_enumerator_type);
+			if (test.is_signed && latest_value.test(test.bitcount-1))
+				{
+				target_machine->signed_additive_inverse(latest_value,test.machine_type);
+				if (0<latest_value)
+					{
+					latest_value -= 1;
+					if (0<latest_value) target_machine->signed_additive_inverse(latest_value,test.machine_type);
+					value_is_nonnegative_or_twos_complement = false;
+					}
+				}
+			}
+		if (value_is_nonnegative_or_twos_complement) latest_value += 1;
+
 		if (1>=src.size<0>()-i)
 			{	// default-update
-			// if (active_namespace)
-			//		types.set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,unsigned char representation,latest_value,enum_type_index)
-			// else
-			//		types.set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,unsigned char representation,latest_value,enum_type_index);
+			// handle type errors
+			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0]))
+				return false;
+			uchar_blob latest_value_copy;
+			latest_value_copy.init(0);
+			value_copy(latest_value_copy,latest_value);
+			if (active_namespace)
+				types.set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+			else
+				types.set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			break;
 			}
 		// complete conversion
@@ -11044,7 +11118,15 @@
 		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
 		if (robust_token_is_char<','>(src.data<0>()[i+1]))
 			{	// would default-update
-			// ...
+			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0]))
+				return false;
+			uchar_blob latest_value_copy;
+			latest_value_copy.init(0);
+			value_copy(latest_value_copy,latest_value);
+			if (active_namespace)
+				types.set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+			else
+				types.set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			i += 2;
 			continue;
 			};
@@ -11060,13 +11142,14 @@
 				break;
 				}
 			};
+#if 0
 		// probably have this already....
 		if (!eval_expression(src,origin,i,latest_value))
 			return false;
+#endif
 		// ...
 		}
 	// now ok to crunch underlying type/machine representation
-#endif
 	return true;
 }
 

Added: trunk/tools/selective_cut.py
===================================================================
--- trunk/tools/selective_cut.py	2010-01-21 04:08:20 UTC (rev 329)
+++ trunk/tools/selective_cut.py	2010-01-26 08:21:44 UTC (rev 330)
@@ -0,0 +1,39 @@
+#!/usr/bin/python
+# designed for Python 2.6, may work with other versions
+# (C)2010 Kenneth Boyd, license: MIT.txt
+
+from sys import argv,exit;
+
+#   This is inspired by Perl's Plain Old Documentation format, but 
+# works generically with languages that use shell one-line comments
+# (e.g.: Python, Perl, PHP, Ruby, C/C++
+#   Idea is that lines #/* cut-cut_id */ act like =cut in Perl.
+#   C,C++ are fine because the C-comment becomes whitespace, leaving behind 
+# a null preprocessing directive which is removed by the preprocessor.
+#   Languages with native shell comments just treat these lines as comments
+
+def SelectiveCut(cut_id,srcfile,destfile):
+	test_lines = []
+	old_line_ok = 1
+	line_ok = 1
+	TargetFile = open(destfile,'w')	# *.sh
+	with open(srcfile,'r') as f:
+		for line in f:
+			line_proxy = line.strip()
+			if line_proxy=='#/*cut-'+cut_id+'*/':
+				line_ok = 1-line_ok
+			if line_ok and old_line_ok:
+				TargetFile.write(line)
+			old_line_ok = line_ok
+	TargetFile.close()
+
+
+if __name__ == '__main__':
+	# online help
+	if 4!=len(argv):
+		print "Usage: cut_id srcfile destfile"
+		print "\texcises text lines contained between #cut-cut_id comments"
+		exit(0)
+
+	SelectiveCut(argv[1],argv[2],argv[3])
+

Modified: trunk/unsigned_var_int.hpp
===================================================================
--- trunk/unsigned_var_int.hpp	2010-01-21 04:08:20 UTC (rev 329)
+++ trunk/unsigned_var_int.hpp	2010-01-26 08:21:44 UTC (rev 330)
@@ -21,8 +21,10 @@
 
 	unsigned_var_int& operator=(const unsigned_var_int& src);
 	unsigned_var_int& operator=(uintmax_t src);
-	unsigned_var_int& operator=(const uchar_blob& src) {value_copy(_data,src); return *this;};
+	unsigned_var_int& operator=(const uchar_blob& src) {uchar_blob::value_copy(_data,src); return *this;};
 	void MoveInto(unsigned_var_int& dest);
+	static void value_copy(uchar_blob& dest, const unsigned_var_int& src) {uchar_blob::value_copy(dest,src._data);};
+	static void value_copy(unsigned_var_int& dest, const unsigned_var_int& src) {uchar_blob::value_copy(dest._data,src._data);};
 
 	unsigned_var_int& operator~() {bitwise_compl(_data.c_array(),_data.size()); return *this;};
 	void auto_bitwise_complement() {bitwise_compl(_data.c_array(),_data.size());};
@@ -110,6 +112,9 @@
 	unsigned char& back() {return _data.back();};
 };
 
+inline void value_copy(uchar_blob& dest, const unsigned_var_int& src) {unsigned_var_int::value_copy(dest,src);}
+inline void value_copy(unsigned_var_int& dest, const unsigned_var_int& src) {unsigned_var_int::value_copy(dest,src);}
+
 // render as C string
 char* z_ucharint_toa(unsigned_var_int target,char* const buf,unsigned int radix);
 



From zaimoni at mail.berlios.de  Wed Jan 27 09:15:30 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 27 Jan 2010 09:15:30 +0100
Subject: [Zcplusplus-commits] r331 - in trunk: . tests/zcc/decl.C99
Message-ID: <201001270815.o0R8FU1e023152@sheep.berlios.de>

Author: zaimoni
Date: 2010-01-27 09:15:17 +0100 (Wed, 27 Jan 2010)
New Revision: 331

Added:
   trunk/tests/zcc/decl.C99/Error_enum_overflow.h
   trunk/tests/zcc/decl.C99/Error_enum_overflow.hpp
   trunk/tests/zcc/decl.C99/Error_enum_overflow2.h
Modified:
   trunk/CSupport.cpp
   trunk/ParseTree.cpp
   trunk/ParseTree.hpp
Log:
full enumeration parsing support

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-01-26 08:21:44 UTC (rev 330)
+++ trunk/CSupport.cpp	2010-01-27 08:15:17 UTC (rev 331)
@@ -10867,20 +10867,11 @@
 static bool default_enumerator_init_legal(const bool allow_empty, unsigned char& current_enumerator_type, const unsigned_var_int& prior_value, const weak_token& src)
 {
 	if (allow_empty)
-		{
-		if (prior_value==target_machine->signed_max<virtual_machine::std_int_int>())
-			{	// signed integer overflow
-				//! \bug need test case
-			message_header(src);
-			INC_INFORM(ERR_STR);
-			INFORM("default-initialization of enumerator requires signed int overflow: undefined behavior (C99 6.7.2.2p3)");
-			zcc_errors.inc_error();
-			return false;
-			}
-		}
-	else{	//! \todo research how to rewrite this without the goto
+		{	// C++
+		//! \todo research how to rewrite this without the goto
 cpp_enum_was_retyped:
 		const promote_aux test(current_enumerator_type);
+		//! \bug need -Wc-c++-compat to go off here
 		if (test.is_signed)
 			{
 			if (prior_value==target_machine->signed_max(test.machine_type))
@@ -10894,7 +10885,7 @@
 				{
 				if (C_TYPE::INTEGERLIKE == ++current_enumerator_type)	// smallest type that can handle this
 					{	// unsigned long long overflow, fact it's defined doesn't save us
-					//! \bug need test case
+					//! \test decl.C99/Error_enum_overflow.hpp
 					message_header(src);
 					INC_INFORM(ERR_STR);
 					INFORM("default-initialization of enumerator requires uintmax_t overflow (C++0X 7.2p5)");
@@ -10905,10 +10896,21 @@
 				}
 			}
 		}
+	else{	// C
+		if (prior_value==target_machine->signed_max<virtual_machine::std_int_int>())
+			{	// signed integer overflow
+				//! \test decl.C99/Error_enum_overflow.h
+			message_header(src);
+			INC_INFORM(ERR_STR);
+			INFORM("default-initialization of enumerator requires signed int overflow (C99 6.7.2.2p3)");
+			zcc_errors.inc_error();
+			return false;
+			}
+		}
 	return true;
 }
 
-static bool record_enum_values(parse_tree& src, type_system& types, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits<const char* (*)(const char*, size_t)>::function_ref_type echo_reserved_keyword)
+static bool record_enum_values(parse_tree& src, type_system& types, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits<const char* (*)(const char*, size_t)>::function_ref_type echo_reserved_keyword, func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type CondenseParseTree, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
 {
 	assert(enum_type_index);
 	assert(!active_namespace || *active_namespace);
@@ -11021,6 +11023,8 @@
 	unsigned_var_int latest_value(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 	unsigned_var_int prior_value(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 	unsigned char current_enumerator_type = C_TYPE::INT;
+//	bool cpp_using_negative = false;
+//	bool cpp_using_above_LLONG_MAX = false;
 	i = 0;
 	while(src.size<0>()>i)
 		{	// require identifier that is neither keyword nor a primitive type
@@ -11132,23 +11136,79 @@
 			};
 		assert(robust_token_is_char<'='>(src.data<0>()[i+1]));
 		i += 2;
+		const size_t origin = i;
 		assert(src.size<0>()>i && !robust_token_is_char<','>(src.data<0>()[i]));
-		size_t origin = i;
+		bool comma_overextended = false;
 		while(++i < src.size<0>())
 			{
 			if (robust_token_is_char<','>(src.data<0>()[i]))
 				{
 				++i;
+				comma_overextended = true;
 				break;
 				}
 			};
+		{	// see if it's a compile-time constant
+		parse_tree_class tmp(src,origin,i-comma_overextended,0);
+		if (tmp.is_raw_list() && !CondenseParseTree(tmp,types)) return false;
+		if (!EvalParseTree(tmp,types)) return false;
+		if (!intlike_literal_to_VM(latest_value,tmp))
+			{	//! \bug need test case
+			message_header(src.data<0>()[origin-2].index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM("enumerator can only be explicitly initialized by a compile-time constant (C99 6.7.2.2p3/C++98 7.2p1)");
+			zcc_errors.inc_error();
+			return false;
+			}
+		// range checks
+		if (allow_empty)
+			{	// C++
+			current_enumerator_type = tmp.type_code.base_type_index;
+			}
+		else{	// C
+			const promote_aux test(tmp.type_code.base_type_index);
+			const promote_aux dest_type(C_TYPE::INT);
+			const bool is_negative = test.is_signed && latest_value.test(test.bitcount-1);
+			if (is_negative)
+				target_machine->signed_additive_inverse(latest_value,test.machine_type);
+			bool out_of_range = latest_value>target_machine->signed_max<virtual_machine::std_int_int>();
+			if (out_of_range && is_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation())
+				{	// handle two's complement INT_MIN
+				latest_value -= 1;
+				if (latest_value<=target_machine->signed_max<virtual_machine::std_int_int>()) 
+					out_of_range = false;
+				latest_value += 1;
+				}
+			if (out_of_range)
+				{	//! \test decl.C99/Error_enum_overflow2.h
+					//! \bug need -Wc-c++-compat to go off here
+				message_header(src.data<0>()[origin-2].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("initializer of enumerator not representable as signed int (C99 6.7.2.2p3)");
+				zcc_errors.inc_error();
+				return false;
+				}
+			if (is_negative)
+				target_machine->signed_additive_inverse(latest_value,dest_type.machine_type);
+			tmp.type_code.base_type_index = C_TYPE::INT;
+			}
 #if 0
-		// probably have this already....
-		if (!eval_expression(src,origin,i,latest_value))
-			return false;
+		if (origin+1<i-comma_overextended)
+			{	// net token reduction, do source code optimization?
+			}
 #endif
-		// ...
 		}
+
+		{	// actually register the enumerator
+		uchar_blob latest_value_copy;
+		latest_value_copy.init(0);
+		value_copy(latest_value_copy,latest_value);
+		if (active_namespace)
+			types.set_enumerator_def_CPP(src.data<0>()[origin-2].index_tokens[0].token.first, active_namespace,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+		else
+			types.set_enumerator_def(src.data<0>()[origin-2].index_tokens[0].token.first,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+		}
+		}
 	// now ok to crunch underlying type/machine representation
 	return true;
 }
@@ -11277,7 +11337,7 @@
 			//! \test zcc\decl.C99\Pass_enum_def.h
 			const type_system::type_index tmp2 = types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			assert(types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp2,NULL,false,C99_echo_reserved_keyword))
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;
@@ -11287,7 +11347,7 @@
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 			const type_system::type_index tmp = types.register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp,NULL,false,C99_echo_reserved_keyword))
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;
@@ -11795,7 +11855,7 @@
 			// enum-specifier doesn't have a specific declaration mode
 			const type_system::type_index tmp2 = types.register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			assert(types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp2,NULL,true,CPP_echo_reserved_keyword))
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp2,NULL,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;
@@ -11805,7 +11865,7 @@
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 			const type_system::type_index tmp = types.register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp,NULL,true,CPP_echo_reserved_keyword))
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp,NULL,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2010-01-26 08:21:44 UTC (rev 330)
+++ trunk/ParseTree.cpp	2010-01-27 08:15:17 UTC (rev 331)
@@ -342,3 +342,29 @@
 #undef USER_MASK
 }
 
+// slicing copy constructor
+parse_tree_class::parse_tree_class(const parse_tree& src,size_t begin,size_t end,size_t dest_idx)
+{
+	assert(STATIC_SIZE(args)>dest_idx);
+	assert(begin<src.size(dest_idx));
+	assert(end<=src.size(dest_idx));
+	this->clear();
+	if (begin<end)
+		{
+		if (begin+1==end)
+			{
+			value_copy(*this,src.data(dest_idx)[begin]);
+			}
+		else{
+			size_t i = end-begin;
+			if (!resize(dest_idx,end-begin)) throw std::bad_alloc();
+			do	{
+				--i;
+				value_copy(c_array(dest_idx)[i],src.data(dest_idx)[i+begin]);
+				}
+			while(0<i);
+			}
+		}
+}
+
+

Modified: trunk/ParseTree.hpp
===================================================================
--- trunk/ParseTree.hpp	2010-01-26 08:21:44 UTC (rev 330)
+++ trunk/ParseTree.hpp	2010-01-27 08:15:17 UTC (rev 331)
@@ -207,6 +207,11 @@
 		BOOST_STATIC_ASSERT(STATIC_SIZE(index_tokens)>i);
 		(flags &= ~((zaimoni::lex_flags)(1)<<i)) |= ((zaimoni::lex_flags)(have_it)<<i);
 		}
+	bool resize(size_t arg_idx,size_t n)
+		{
+		assert(STATIC_SIZE(args)>arg_idx);
+		return _resize(arg_idx,n);
+		}
 	template<size_t arg_idx> bool resize(size_t n)
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
@@ -376,6 +381,8 @@
 		this->clear();
 		value_copy(*this,src);
 		};
+	// slicing copy constructor
+	parse_tree_class(const parse_tree& src,size_t begin,size_t end,size_t dest_idx);
 	~parse_tree_class() {this->destroy();};
 	const parse_tree_class& operator=(const parse_tree_class& src)
 		{

Added: trunk/tests/zcc/decl.C99/Error_enum_overflow.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_overflow.h	2010-01-26 08:21:44 UTC (rev 330)
+++ trunk/tests/zcc/decl.C99/Error_enum_overflow.h	2010-01-27 08:15:17 UTC (rev 331)
@@ -0,0 +1,10 @@
+// decl.C99\Error_enum_overflow.h
+// overflowing enum doesn't work
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#include <limits.h>
+
+enum bad_enum {
+	x = INT_MAX,
+	y
+}

Added: trunk/tests/zcc/decl.C99/Error_enum_overflow.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_overflow.hpp	2010-01-26 08:21:44 UTC (rev 330)
+++ trunk/tests/zcc/decl.C99/Error_enum_overflow.hpp	2010-01-27 08:15:17 UTC (rev 331)
@@ -0,0 +1,10 @@
+// decl.C99\Error_enum_overflow.hpp
+// overflowing enum doesn't work
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#include <cstdint>
+
+enum bad_enum {
+	x = UINTMAX_MAX,
+	y
+}

Added: trunk/tests/zcc/decl.C99/Error_enum_overflow2.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_overflow2.h	2010-01-26 08:21:44 UTC (rev 330)
+++ trunk/tests/zcc/decl.C99/Error_enum_overflow2.h	2010-01-27 08:15:17 UTC (rev 331)
@@ -0,0 +1,14 @@
+// decl.C99\Error_enum_overflow2.h
+// overflowing enum doesn't work
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#include <limits.h>
+#include <stdint.h>
+
+#if INT_MAX<UINTMAX_MAX
+enum bad_enum {
+	x = INT_MAX+UINTMAX_C(1)
+}
+#else
+#error test not meaningful for exotic target (INT_MAX==UINTMAX_MAX)
+#endif



