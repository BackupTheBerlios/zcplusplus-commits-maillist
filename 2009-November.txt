From zaimoni at mail.berlios.de  Thu Nov  5 05:44:16 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 5 Nov 2009 05:44:16 +0100
Subject: [Zcplusplus-commits] r272 - in trunk: . Zaimoni.STL
Message-ID: <200911050444.nA54iGPa016331@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-05 05:44:12 +0100 (Thu, 05 Nov 2009)
New Revision: 272

Modified:
   trunk/CSupport.cpp
   trunk/Zaimoni.STL/POD.hpp
Log:
more reasonable Koenig lookup for typedefs; augment POD support in Zaimoni.STL

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-10-18 05:34:07 UTC (rev 271)
+++ trunk/CSupport.cpp	2009-11-05 04:44:12 UTC (rev 272)
@@ -10043,8 +10043,21 @@
 		// handle typedefs
 		if (check_for_typedef(base_type,x.index_tokens[0].token.first,types)) return true;
 		//! \todo handle other known types
-		// note: we have to handle typedefs of unions/structs, anonymous or otherwise ....
-		// worse, the typedef need not be *before* the union/struct declaration
+#if 0
+		// we must accept any specifier here: C99 6.7.2p1
+		if (   is_C99_anonymous_specifier(x,"enum")
+			|| is_C99_named_specifier(x,"enum")
+			|| is_C99_named_specifier_definition(x,"enum"))
+			return true;
+		if (   is_C99_anonymous_specifier(x,"struct")
+			|| is_C99_named_specifier(x,"struct")
+			|| is_C99_named_specifier_definition(x,"struct"))
+			return true;
+		if (   is_C99_anonymous_specifier(x,"union")
+			|| is_C99_named_specifier(x,"union")
+			|| is_C99_named_specifier_definition(x,"union"))
+			return true;
+#endif
 		return false;
 		};
 	bool analyze_flags_global(parse_tree& x, size_t i, size_t& decl_count)
@@ -10113,8 +10126,8 @@
 //! \todo belongs elsewhere
 size_t count_disjoint_substring_instances(const char* const src,const char* const match)
 {
-	assert(NULL!=src && *src);
-	assert(NULL!=match && *match);
+	assert(src && *src);
+	assert(match && *match);
 	const size_t src_len = strlen(src);
 	const size_t match_len = strlen(match);
 	size_t n = 0;
@@ -10128,7 +10141,7 @@
 }
 
 //! \todo belongs elsewhere
-void report_disjoint_substring_instances(const char* const src,const char* const match,const char**& namespace_break_stack,const size_t namespace_break_stack_size)
+void report_disjoint_substring_instances(const char* const src,const char* const match,const char** const namespace_break_stack,const size_t namespace_break_stack_size)
 {
 	assert(NULL!=src && *src);
 	assert(NULL!=match && *match);
@@ -10153,12 +10166,26 @@
 	uintmax_t flags;
 	type_spec base_type;
 	const type_system& types;
+	// these two might belong in a koenig_lookup object
 	const char* const active_namespace;
+	autovalarray_ptr_throws<char*> koenig_lookup;
 public:
-	CPP0X_decl_specifier_scanner(const type_system& _types,const char* const _active_namespace) : flags(0),types(_types),active_namespace(_active_namespace)
+	CPP0X_decl_specifier_scanner(const type_system& _types,const char* const _active_namespace) : flags(0),types(_types),active_namespace(_active_namespace),koenig_lookup((_active_namespace && *_active_namespace) ? count_disjoint_substring_instances(_active_namespace,"::") : 0)
 		{
 		clear(decl_count);
 		base_type.clear();
+		if (!koenig_lookup.empty())
+			{
+			size_t namespace_break_stack_size = koenig_lookup.size();
+			weakautovalarray_ptr_throws<const char*> namespace_break_stack(namespace_break_stack_size);
+			report_disjoint_substring_instances(active_namespace,"::",namespace_break_stack.c_array(),namespace_break_stack_size);
+			do	{
+				size_t offset = namespace_break_stack[--namespace_break_stack_size]-active_namespace;
+				koenig_lookup[namespace_break_stack_size] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(offset));
+				strncpy(koenig_lookup[namespace_break_stack_size],active_namespace,offset);
+				}
+			while(0<namespace_break_stack_size);
+			}
 		}
 	// trivial destructor, copy constructor, assignment fine
 	bool operator()(parse_tree& x,const size_t i)
@@ -10203,7 +10230,7 @@
 				char* tmp2 = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(active_namespace_len+2+x.data<0>()[i].index_tokens[0].token.second));
 				strcpy(tmp2,active_namespace);
 				strcpy(tmp2+active_namespace_len,"::");
-				strncpy(tmp2+active_namespace_len+2,x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second);
+				strcpy(tmp2+active_namespace_len+2,x.data<0>()[i].index_tokens[0].token.first);
 				const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(tmp2);
 				if (NULL!=tmp)
 					{	//! \todo check for access-control if source is a class or struct
@@ -10211,29 +10238,24 @@
 					value_copy(base_type,tmp->first);
 					return true;
 					};
-				size_t namespace_break_stack_size = count_disjoint_substring_instances(active_namespace,"::");
-				if (0<namespace_break_stack_size)
-					{	//! \todo this wastes a calloc/free, but odds are the code cost of special-casing is larger
-					const char** namespace_break_stack = _new_buffer_nonNULL_throws<const char*>(namespace_break_stack_size);
-					report_disjoint_substring_instances(active_namespace,"::",namespace_break_stack,namespace_break_stack_size);
+				if (!koenig_lookup.empty())
+					{
+					size_t i = koenig_lookup.size();
 					do	{
-						size_t offset = namespace_break_stack[--namespace_break_stack_size]-active_namespace;
-						strncpy(tmp2,active_namespace,offset);
+						--i;
+						size_t offset = strlen(koenig_lookup[i]);
+						strcpy(tmp2,koenig_lookup[i]);
 						strcpy(tmp2+offset,"::");
-						offset += 2;
-						strncpy(tmp2+offset,x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second);
-						tmp2[offset+x.data<0>()[i].index_tokens[0].token.second] = '\0';
+						strcpy(tmp2+offset+2,x.data<0>()[i].index_tokens[0].token.first);
 						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(tmp2);
 						if (NULL!=tmp)
 							{	//! \todo check for access-control if source is a class or struct
-							free(namespace_break_stack);
 							free(tmp2);
 							value_copy(base_type,tmp->first);
 							return true;
 							};
 						}
-					while(0<namespace_break_stack_size);
-					free(namespace_break_stack);
+					while(0<i);
 					};
 				free(tmp2);
 				}
@@ -10242,6 +10264,25 @@
 			}
 		}
 		//! \todo handle other known types
+#if 0
+		// we must accept any specifier here: C++0X 7.1.6.2p1
+		if (   is_C99_anonymous_specifier(x,"enum")
+			|| is_C99_named_specifier(x,"enum")
+			|| is_C99_named_specifier_definition(x,"enum"))
+			return true;
+		if (   is_C99_anonymous_specifier(x,"struct")
+			|| is_C99_named_specifier(x,"struct")
+			|| is_C99_named_specifier_definition(x,"struct"))
+			return true;
+		if (   is_C99_anonymous_specifier(x,"union")
+			|| is_C99_named_specifier(x,"union")
+			|| is_C99_named_specifier_definition(x,"union"))
+			return true;
+		if (   is_C99_anonymous_specifier(x,"class")
+			|| is_C99_named_specifier(x,"class")
+			|| is_C99_named_specifier_definition(x,"class"))
+			return true;
+#endif
 		return false;
 		};
 	bool analyze_flags_global(parse_tree& x, size_t i, size_t& decl_count)

Modified: trunk/Zaimoni.STL/POD.hpp
===================================================================
--- trunk/Zaimoni.STL/POD.hpp	2009-10-18 05:34:07 UTC (rev 271)
+++ trunk/Zaimoni.STL/POD.hpp	2009-11-05 04:44:12 UTC (rev 272)
@@ -121,6 +121,16 @@
 	T4 fourth;
 };
 
+template<class T1, class T2, class T3, class T4, class T5>
+union union_quintet
+{
+	T1 first;
+	T2 second;
+	T3 third;
+	T4 fourth;
+	T5 fifth;
+};
+
 template<class T1,class T2,class T3,class T4,class T5,class T6,class T7>
 union union_heptuple
 {
@@ -161,6 +171,24 @@
 #undef ZAIMONI_CLASS_SPEC
 #undef ZAIMONI_TEMPLATE_SPEC
 
+#define ZAIMONI_TEMPLATE_SPEC template<typename _T1,typename _T2,typename _T3,typename _T4>
+#define ZAIMONI_CLASS_SPEC zaimoni::union_quartet<_T1,_T2,_T3,_T4>
+ZAIMONI_POD_STRUCT(ZAIMONI_TEMPLATE_SPEC,ZAIMONI_CLASS_SPEC,_T1)
+#undef ZAIMONI_CLASS_SPEC
+#undef ZAIMONI_TEMPLATE_SPEC
+
+#define ZAIMONI_TEMPLATE_SPEC template<typename _T1,typename _T2,typename _T3,typename _T4,typename _T5>
+#define ZAIMONI_CLASS_SPEC zaimoni::union_quintet<_T1,_T2,_T3,_T4,_T5>
+ZAIMONI_POD_STRUCT(ZAIMONI_TEMPLATE_SPEC,ZAIMONI_CLASS_SPEC,_T1)
+#undef ZAIMONI_CLASS_SPEC
+#undef ZAIMONI_TEMPLATE_SPEC
+
+#define ZAIMONI_TEMPLATE_SPEC template<typename _T1,typename _T2,typename _T3,typename _T4,typename _T5,typename _T6,typename _T7>
+#define ZAIMONI_CLASS_SPEC zaimoni::union_heptuple<_T1,_T2,_T3,_T4,_T5,_T6,_T7>
+ZAIMONI_POD_STRUCT(ZAIMONI_TEMPLATE_SPEC,ZAIMONI_CLASS_SPEC,_T1)
+#undef ZAIMONI_CLASS_SPEC
+#undef ZAIMONI_TEMPLATE_SPEC
+
 }
 
 



From zaimoni at mail.berlios.de  Mon Nov 23 09:18:23 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 23 Nov 2009 09:18:23 +0100
Subject: [Zcplusplus-commits] r273 - trunk
Message-ID: <200911230818.nAN8INvG024870@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-23 09:18:16 +0100 (Mon, 23 Nov 2009)
New Revision: 273

Added:
   trunk/struct_type.cpp
   trunk/struct_type.hpp
Modified:
   trunk/type_system.cpp
   trunk/type_system.hpp
Log:
infrastructure changes

Added: trunk/struct_type.cpp
===================================================================
--- trunk/struct_type.cpp	2009-11-05 04:44:12 UTC (rev 272)
+++ trunk/struct_type.cpp	2009-11-23 08:18:16 UTC (rev 273)
@@ -0,0 +1,93 @@
+// struct_type.cpp
+
+#include "struct_type.hpp"
+#include "Zaimoni.STL/Pure.C/auto_int.h"
+
+C_union_struct_def::C_union_struct_def(const union_struct_decl& src,const zaimoni::POD_pair<size_t,size_t>& logical_line,const char* src_filename)
+:	_logical_line(logical_line),
+	_src_filename(((src_filename && *src_filename) ? src_filename : NULL)),
+	_decl(src)
+{
+	assert(syntax_ok());
+}
+
+C_union_struct_def::C_union_struct_def(union_struct_decl::keywords keyword, const char* tag,const zaimoni::POD_pair<size_t,size_t>& logical_line, const char* src_filename)
+:	_logical_line(logical_line),
+	_src_filename(((src_filename && *src_filename) ? src_filename : NULL)),
+	_decl(keyword,tag)
+{
+	assert(syntax_ok());
+}
+
+C_union_struct_def::C_union_struct_def(const C_union_struct_def& src)
+:	_decl(src._decl),
+	data_field_spec(src.data_field_spec.size()),
+	data_field_names(src.data_field_names)
+{
+#ifndef ZAIMONI_NULL_REALLY_IS_ZERO
+#error must implement proper clearing for data_field_spec
+#endif
+	zaimoni::autotransform_n(data_field_spec.c_array(),src.data_field_spec.data(),data_field_spec.size(),value_copy);
+	assert(syntax_ok());
+}
+
+C_union_struct_def::~C_union_struct_def()
+{
+	size_t i = data_field_spec.size();
+	while(0<i) data_field_spec[--i].destroy();
+}
+
+const C_union_struct_def& C_union_struct_def::operator=(const C_union_struct_def& src)
+{
+	zaimoni::autovalarray_ptr_throws<type_spec> data_field_spec;
+	
+	const size_t src_field_count = src.data_field_spec.size();
+	const size_t now_field_count = data_field_spec.size();
+	if (0==src_field_count)
+		{
+		if (0<now_field_count)
+			{
+			size_t i = now_field_count;
+			while(0<i) data_field_spec[--i].destroy();
+			data_field_spec.reset();
+			data_field_names.reset();
+			}
+		}
+	else{
+		zaimoni::autovalarray_ptr_throws<type_spec> tmp_data_field_spec(src_field_count);
+#ifndef ZAIMONI_NULL_REALLY_IS_ZERO
+#error must implement proper clearing for tmp_data_field_spec
+#endif
+		zaimoni::autotransform_n(tmp_data_field_spec.c_array(),src.data_field_spec.data(),src_field_count,value_copy);
+
+		if (src_field_count<=now_field_count)
+			data_field_names = src.data_field_names;
+		else{
+			zaimoni::weakautovalarray_ptr<const char*> tmp_data_field_names(src.data_field_names);
+			if (tmp_data_field_names.empty())
+				{
+				size_t i = src_field_count;
+				while(0<i) tmp_data_field_spec[--i].destroy();
+				throw std::bad_alloc();
+				}
+			tmp_data_field_names.MoveInto(data_field_names);
+			}
+
+		size_t i = now_field_count;
+		while(0<i) data_field_spec[--i].destroy();
+		tmp_data_field_spec.MoveInto(data_field_spec);
+		}
+
+	_decl = src._decl;
+	_logical_line = src._logical_line;
+	_src_filename = src._src_filename;
+	assert(syntax_ok());
+	return *this;
+}
+
+#ifndef NDEBUG
+bool C_union_struct_def::syntax_ok() const
+{
+	return data_field_spec.size()==data_field_names.size();
+}
+#endif

Added: trunk/struct_type.hpp
===================================================================
--- trunk/struct_type.hpp	2009-11-05 04:44:12 UTC (rev 272)
+++ trunk/struct_type.hpp	2009-11-23 08:18:16 UTC (rev 273)
@@ -0,0 +1,54 @@
+// struct_type.hpp
+
+#ifndef STRUCT_TYPE_HPP
+#define STRUCT_TYPE_HPP 1
+
+#include "Zaimoni.STL/AutoPtr.hpp"
+#include "type_spec.hpp"
+
+class union_struct_decl
+{
+private:
+	const char* _tag;	// NULL or ends in :: for anonymous
+	unsigned char _keyword;
+public:
+	enum keywords {
+		decl_none = 0,
+		decl_union = 1,		// global public access; all entries are at the same machine address
+		decl_struct = 2,	// default public access in C++; entries are in sequence (calculating layout requires target information)
+		decl_class = 3		// default private access in C++; entries are in sequence (calculating layout requires target information)
+	};
+
+	union_struct_decl(keywords keyword, const char* tag) : _tag((tag && *tag ? tag : NULL)),_keyword((assert(keyword),keyword)) {};
+	// defaults ok for: copy constructor, destructor, assignment operator
+
+	const char* tag() const {return _tag;};
+	keywords keyword() const {return (keywords)(_keyword & 3U);};
+	friend bool operator==(const union_struct_decl& lhs,const union_struct_decl& rhs) {
+		return lhs._tag==rhs._tag && lhs._keyword==rhs._keyword;
+	};
+};
+
+class C_union_struct_def
+{
+private:
+	zaimoni::POD_pair<size_t,size_t> _logical_line;
+	const char* _src_filename;
+public:
+	union_struct_decl _decl;
+	zaimoni::autovalarray_ptr_throws<type_spec> data_field_spec;
+	zaimoni::weakautovalarray_ptr_throws<const char*> data_field_names;	// using registered strings
+
+	C_union_struct_def(const union_struct_decl& src,const zaimoni::POD_pair<size_t,size_t>& logical_line, const char* src_filename);
+	C_union_struct_def(union_struct_decl::keywords keyword, const char* tag,const zaimoni::POD_pair<size_t,size_t>& logical_line, const char* src_filename);
+	C_union_struct_def(const C_union_struct_def& src);
+	~C_union_struct_def();
+	const C_union_struct_def& operator=(const C_union_struct_def& src);
+
+#ifndef NDEBUG
+	bool syntax_ok() const;
+#endif
+};
+
+
+#endif

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2009-11-05 04:44:12 UTC (rev 272)
+++ trunk/type_system.cpp	2009-11-23 08:18:16 UTC (rev 273)
@@ -2,26 +2,97 @@
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
 #include "type_system.hpp"
+#include "struct_type.hpp"
 #include "Zaimoni.STL/search.hpp"
 
 // macros to help out dynamic registration
 #define DYNAMIC_FUNCTYPE 1
 #define DYNAMIC_STRUCTDECL 2
 #define DYNAMIC_C_STRUCTDEF 3
+#define DYNAMIC_ENUMDEF 4
 
 type_system::type_index
 type_system::_get_id(const char* const x,size_t x_len) const
 {
 	errr tmp = linear_find_lencached(x,x_len,core_types,core_types_size);
 	if (0<=tmp) return tmp+1;
-	if (!dynamic_types.empty())
+	tmp = linear_find_lencached(x,x_len,dynamic_types);
+	if (0<=tmp) return tmp+1+core_types_size;
+	return 0;
+}
+
+type_system::type_index
+type_system::_get_id_union(const char* const x,size_t x_len) const
+{
+	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
+	while(0<=tmp)
 		{
-		tmp = linear_find_lencached(x,x_len,dynamic_types);
-		if (0<=tmp) return tmp+1+core_types_size;
+		if (DYNAMIC_STRUCTDECL==dynamic_types[tmp].third.second)
+			{
+			if (union_struct_decl::decl_union==dynamic_types[tmp].third.first.second->keyword())
+				return tmp+1+core_types_size;
+			return 0;
+			};
+		if (DYNAMIC_C_STRUCTDEF==dynamic_types[tmp].third.second)
+			{
+			if (union_struct_decl::decl_union==dynamic_types[tmp].third.first.third->_decl.keyword())
+				return tmp+1+core_types_size;
+			return 0;
+			}
+		// in a different tag space...retry
+		if (1>=dynamic_types.size()-tmp) break;
+		errr tmp2 = linear_find_lencached(x,x_len,dynamic_types.data()+tmp+1,dynamic_types.size()-(tmp+1));
+		if (0>tmp2) break;
+		tmp += 1+tmp2;
 		}
 	return 0;
 }
 
+type_system::type_index
+type_system::_get_id_struct_class(const char* const x,size_t x_len) const
+{
+	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
+	while(0<=tmp)
+		{
+		if (DYNAMIC_STRUCTDECL==dynamic_types[tmp].third.second)
+			{
+			if (union_struct_decl::decl_union!=dynamic_types[tmp].third.first.second->keyword())
+				return tmp+1+core_types_size;
+			return 0;
+			};
+		if (DYNAMIC_C_STRUCTDEF==dynamic_types[tmp].third.second)
+			{
+			if (union_struct_decl::decl_union!=dynamic_types[tmp].third.first.third->_decl.keyword())
+				return tmp+1+core_types_size;
+			return 0;
+			}
+		// in a different tag space...retry
+		if (1>=dynamic_types.size()-tmp) break;
+		errr tmp2 = linear_find_lencached(x,x_len,dynamic_types.data()+tmp+1,dynamic_types.size()-(tmp+1));
+		if (0>tmp2) break;
+		tmp += 1+tmp2;
+		}
+	return 0;
+}
+
+type_system::type_index
+type_system::_get_id_enum(const char* const x,size_t x_len) const
+{
+	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
+	while(0<=tmp)
+		{
+		if (DYNAMIC_ENUMDEF==dynamic_types[tmp].third.second)
+			return tmp+1+core_types_size;
+
+		// in a different tag space...retry
+		if (1>=dynamic_types.size()-tmp) break;
+		errr tmp2 = linear_find_lencached(x,x_len,dynamic_types.data()+tmp+1,dynamic_types.size()-(tmp+1));
+		if (0>tmp2) break;
+		tmp += 1+tmp2;
+		}
+	return 0;
+}
+
 const char* type_system::_name(size_t id) const
 {
 	if (0==id) return "(?)";
@@ -103,7 +174,7 @@
 {
 	assert(alias && *alias);
 	assert(src);
-	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_STRUCTDECL}};
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_C_STRUCTDEF}};
 	tmp.third.first.third = src;
 
 	type_index result = get_id(alias);
@@ -119,10 +190,31 @@
 	return dynamic_types_size+2+core_types_size;
 }
 
+type_system::type_index type_system::register_enum_def(const char* const alias, enum_def*& src)
+{
+	assert(alias && *alias);
+	assert(src);
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_ENUMDEF}};
+	tmp.third.first.fourth = src;
+
+	type_index result = get_id(alias);
+	if (result) return result;
+
+	const size_t dynamic_types_size = dynamic_types.size();
+	const size_t dynamic_types_max_size = dynamic_types.max_size();
+	if (	dynamic_types_max_size<2+core_types_size
+		|| 	dynamic_types_max_size-(2+core_types_size)<dynamic_types_size)
+		FATAL("Host implementation limit exceeded: cannot record enum type used in program");
+	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
+	src = NULL;
+	return dynamic_types_size+2+core_types_size;
+}
+
 const function_type* type_system::get_functype(type_system::type_index i)
 {
 	if (core_types_size>=i) return NULL;
 	i -= core_types_size;
+	--i;
 	if (dynamic_types.size()<=i) return NULL;
 	const dynamic_type_format& tmp = dynamic_types[i];
 	if (DYNAMIC_FUNCTYPE!=tmp.third.second) return NULL;
@@ -133,6 +225,7 @@
 {
 	if (core_types_size>=i) return NULL;
 	i -= core_types_size;
+	--i;
 	if (dynamic_types.size()<=i) return NULL;
 	const dynamic_type_format& tmp = dynamic_types[i];
 	if (DYNAMIC_STRUCTDECL!=tmp.third.second) return NULL;
@@ -143,9 +236,37 @@
 {
 	if (core_types_size>=i) return NULL;
 	i -= core_types_size;
+	--i;
 	if (dynamic_types.size()<=i) return NULL;
 	const dynamic_type_format& tmp = dynamic_types[i];
 	if (DYNAMIC_C_STRUCTDEF!=tmp.third.second) return NULL;
 	return tmp.third.first.third;
 }
 
+const enum_def* type_system::get_enum_def(type_index i)
+{
+	if (core_types_size>=i) return NULL;
+	i -= core_types_size;
+	--i;
+	if (dynamic_types.size()<=i) return NULL;
+	const dynamic_type_format& tmp = dynamic_types[i];
+	if (DYNAMIC_ENUMDEF!=tmp.third.second) return NULL;
+	return tmp.third.first.fourth;
+}
+
+void type_system::upgrade_decl_to_def(type_index i,C_union_struct_def*& src)
+{	// cf. get_structdecl
+	assert(src);
+	assert(core_types_size<i);
+	i -= core_types_size;
+	--i;
+	assert(dynamic_types.size()>i);
+	dynamic_type_format& tmp = dynamic_types[i];
+	assert(DYNAMIC_STRUCTDECL==tmp.third.second);
+	assert(*tmp.third.first.second==src->_decl);
+	tmp.third.second = DYNAMIC_C_STRUCTDEF;
+	delete tmp.third.first.second;
+	tmp.third.first.third = src;
+	src = NULL;
+}
+

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2009-11-05 04:44:12 UTC (rev 272)
+++ trunk/type_system.hpp	2009-11-23 08:18:16 UTC (rev 273)
@@ -11,6 +11,7 @@
 class function_type;
 class union_struct_decl;
 class C_union_struct_def;
+class enum_def;
 
 class type_system
 {
@@ -22,7 +23,7 @@
 	const size_t core_types_size;
 	const size_t int_priority_size;
 private:
-	typedef zaimoni::POD_triple<const char*,size_t,zaimoni::POD_pair<zaimoni::union_triple<function_type*,union_struct_decl*,C_union_struct_def*>, unsigned char> > dynamic_type_format;
+	typedef zaimoni::POD_triple<const char*,size_t,zaimoni::POD_pair<zaimoni::union_quartet<function_type*,union_struct_decl*,C_union_struct_def*,enum_def*>, unsigned char> > dynamic_type_format;
 	zaimoni::autovalarray_ptr<dynamic_type_format> dynamic_types;
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> > > typedef_registry;
 	// uncopyable
@@ -37,16 +38,52 @@
 
 	type_index get_id(const char* x,size_t x_len) const
 		{
-		assert(NULL!=x && '\0'!= *x);
+		assert(x && *x);
 		assert(0<x_len);
 		assert(x_len<=strlen(x));
 		return _get_id(x,x_len);
 		}
 	type_index get_id(const char* x) const
 		{
-		assert(NULL!=x && '\0'!= *x);
+		assert(x && *x);
 		return _get_id(x,strlen(x));
 		}
+	type_index get_id_union(const char* x,size_t x_len) const
+		{
+		assert(x && *x);
+		assert(0<x_len);
+		assert(x_len<=strlen(x));
+		return _get_id_union(x,x_len);
+		}
+	type_index get_id_union(const char* x) const
+		{
+		assert(x && *x);
+		return _get_id_union(x,strlen(x));
+		}
+	type_index get_id_struct_class(const char* x,size_t x_len) const
+		{
+		assert(x && *x);
+		assert(0<x_len);
+		assert(x_len<=strlen(x));
+		return _get_id_struct_class(x,x_len);
+		}
+	type_index get_id_struct_class(const char* x) const
+		{
+		assert(x && *x);
+		return _get_id_struct_class(x,strlen(x));
+		}
+	type_index get_id_enum(const char* x,size_t x_len) const
+		{
+		assert(x && *x);
+		assert(0<x_len);
+		assert(x_len<=strlen(x));
+		return _get_id_enum(x,x_len);
+		}
+	type_index get_id_enum(const char* x) const
+		{
+		assert(x && *x);
+		return _get_id_enum(x,strlen(x));
+		}
 	const char* name(type_index id) const
 		{
 		assert(core_types_size+dynamic_types.size()>=id);
@@ -59,11 +96,17 @@
 	type_index register_functype(const char* const alias, function_type*& src);
 	type_index register_structdecl(const char* const alias, union_struct_decl*& src);
 	type_index register_C_structdef(const char* const alias, C_union_struct_def*& src);
+	type_index register_enum_def(const char* const alias, enum_def*& src);
 	const function_type* get_functype(type_index i);
 	const union_struct_decl* get_structdecl(type_index i);
 	const C_union_struct_def* get_C_structdef(type_index i);
+	const enum_def* get_enum_def(type_index i);
+	void upgrade_decl_to_def(type_index i,C_union_struct_def*& src);
 private:
 	type_index _get_id(const char* const x,size_t x_len) const;
+	type_index _get_id_union(const char* const x,size_t x_len) const;
+	type_index _get_id_enum(const char* const x,size_t x_len) const;
+	type_index _get_id_struct_class(const char* const x,size_t x_len) const;
 	const char* _name(type_index id) const;
 };
 #endif



From zaimoni at mail.berlios.de  Mon Nov 23 09:19:27 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 23 Nov 2009 09:19:27 +0100
Subject: [Zcplusplus-commits] r274 - trunk
Message-ID: <200911230819.nAN8JRu7024919@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-23 09:19:23 +0100 (Mon, 23 Nov 2009)
New Revision: 274

Modified:
   trunk/MakeMake.cfg
   trunk/POSIX.dep
Log:
build system tweaks

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2009-11-23 08:18:16 UTC (rev 273)
+++ trunk/MakeMake.cfg	2009-11-23 08:19:23 UTC (rev 274)
@@ -1,6 +1,6 @@
 ########
-ProgObjects = {	'z_cpp':('z_cpp','langroute','AtomicString','filesystem','CPUInfo','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
-				'zcc':('zcc','langroute','AtomicString','filesystem','CPUInfo','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
+ProgObjects = {	'z_cpp':('z_cpp','langroute','AtomicString','filesystem','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
+				'zcc':('zcc','langroute','AtomicString','filesystem','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
 MainPrograms = ['z_cpp','zcc']
 
 # process control

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2009-11-23 08:18:16 UTC (rev 273)
+++ trunk/POSIX.dep	2009-11-23 08:19:23 UTC (rev 274)
@@ -1,8 +1,8 @@
-OBJECTS_Z_CPP = z_cpp.o langroute.o AtomicString.o filesystem.o CPUInfo.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
-OBJECTS_Z_CPP_LINK_PRIORITY = CPreproc_autogen.o unsigned_aux.o type_spec.o AtomicString.o z_cpp.o CPreproc.o CSupport.o CPUInfo.o type_system.o ParseTree.o langroute.o load_src.o C_PPHexInteger.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_Z_CPP = z_cpp.o langroute.o AtomicString.o filesystem.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
+OBJECTS_Z_CPP_LINK_PRIORITY = CSupport.o type_system.o struct_type.o ParseTree.o type_spec.o CPreproc.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o z_cpp.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
-OBJECTS_ZCC = zcc.o langroute.o AtomicString.o filesystem.o CPUInfo.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = CPreproc_autogen.o unsigned_aux.o type_spec.o AtomicString.o zcc.o CPreproc.o CSupport.o CPUInfo.o type_system.o ParseTree.o ZParser.o langroute.o load_src.o C_PPHexInteger.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_ZCC = zcc.o langroute.o AtomicString.o filesystem.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
+OBJECTS_ZCC_LINK_PRIORITY = CSupport.o type_system.o struct_type.o ParseTree.o type_spec.o ZParser.o CPreproc.o zcc.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
 # dependencies
 z_cpp.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/OS/mutex.hpp unsigned_fixed_int.hpp unsigned_aux.hpp
@@ -10,10 +10,11 @@
 AtomicString.o: AtomicString.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 filesystem.o: filesystem.h Zaimoni.STL/Compiler.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h
 CPUInfo.o: CPUInfo.hpp unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
-type_system.o: type_system.hpp Zaimoni.STL/search.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
+struct_type.o: struct_type.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
+type_system.o: type_system.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport.o: CSupport.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/OS/mutex.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport.o: CSupport.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp struct_type.hpp CheckReturn.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/OS/mutex.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -24,7 +25,7 @@
 Trigraph.o: Trigraph.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 Flat_UNI.o: Flat_UNI.hpp CSupport.hpp Zaimoni.STL/MetaRAM2.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/OS/mutex.hpp
-CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/OS/mutex.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/OS/mutex.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 zcc.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/OS/mutex.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
-ZParser.o: ZParser.hpp CSupport.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp



From zaimoni at mail.berlios.de  Mon Nov 23 09:22:54 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 23 Nov 2009 09:22:54 +0100
Subject: [Zcplusplus-commits] r275 - in trunk: . tests/zcc/decl.C99
	tests/zcc.in/decl.C99
Message-ID: <200911230822.nAN8Ms0F025119@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-23 09:22:29 +0100 (Mon, 23 Nov 2009)
New Revision: 275

Added:
   trunk/tests/zcc.in/decl.C99/Error_struct_multidef.in
   trunk/tests/zcc.in/decl.C99/Error_union_multidef.in
   trunk/tests/zcc.in/decl.C99/Pass_struct_def.in
   trunk/tests/zcc.in/decl.C99/Pass_union_def.in
   trunk/tests/zcc.in/decl.C99/Warn_inaccessible_struct.in
   trunk/tests/zcc.in/decl.C99/Warn_inaccessible_union.in
   trunk/tests/zcc/decl.C99/Error_class_multidef.hpp
   trunk/tests/zcc/decl.C99/Error_struct_multidef.h
   trunk/tests/zcc/decl.C99/Error_struct_multidef.hpp
   trunk/tests/zcc/decl.C99/Error_union_multidef.h
   trunk/tests/zcc/decl.C99/Error_union_multidef.hpp
   trunk/tests/zcc/decl.C99/Pass_class_def.hpp
   trunk/tests/zcc/decl.C99/Pass_struct_def.h
   trunk/tests/zcc/decl.C99/Pass_struct_def.hpp
   trunk/tests/zcc/decl.C99/Pass_union_def.h
   trunk/tests/zcc/decl.C99/Pass_union_def.hpp
   trunk/tests/zcc/decl.C99/Warn_inaccessible_class.hpp
   trunk/tests/zcc/decl.C99/Warn_inaccessible_struct.h
   trunk/tests/zcc/decl.C99/Warn_inaccessible_struct.hpp
   trunk/tests/zcc/decl.C99/Warn_inaccessible_union.h
   trunk/tests/zcc/decl.C99/Warn_inaccessible_union.hpp
Modified:
   trunk/CSupport.cpp
Log:
recognize when top-level non-template struct/union/class is defined, but do not actually parse definitions.  Don't handle namespaces in C++.

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/CSupport.cpp	2009-11-23 08:22:29 UTC (rev 275)
@@ -23,6 +23,7 @@
 #include "C_PPOctalInteger.hpp"
 #include "C_PPDecimalFloat.hpp"
 #include "C_PPHexFloat.hpp"
+#include "struct_type.hpp"
 #include "CheckReturn.hpp"
 
 using namespace zaimoni;
@@ -3845,7 +3846,7 @@
 			&&	NULL==src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	src.empty<1>()
-			&&	1==src.size<2>() && is_naked_brace_pair(src));
+			&&	1==src.size<2>() && is_naked_brace_pair(*src.data<2>()))
 		return true;
 	return false;
 }
@@ -3859,7 +3860,7 @@
 			&&	NULL!=src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	src.empty<1>()
-			&&	src.empty<2>());
+			&&	src.empty<2>())
 		return true;
 	return false;
 }
@@ -3873,7 +3874,7 @@
 			&&	NULL!=src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	src.empty<1>()
-			&&	1==src.size<2>() && is_naked_brace_pair(src));
+			&&	1==src.size<2>() && is_naked_brace_pair(*src.data<2>()))
 		return true;
 	return false;
 }
@@ -4064,7 +4065,7 @@
 			src.c_array<0>()[i+1].clear();
 			if (2<src.size<0>()-(i+offset) && is_naked_brace_pair(src.data<0>()[i+2]))
 				{
-				make_target_postfix_arg(src,offset,i,i+1);
+				make_target_postfix_arg(src,offset,i,i+2);
 				src.DestroyNAtAndRotateTo<0>(2,i+1,src.size<0>()-offset);
 				offset += 2;
 				assert(is_C99_named_specifier_definition(src.data<0>()[i],tmp2));
@@ -10579,6 +10580,173 @@
 			C99_CPP_handle_static_assertion(src,types,*CLexer->pp_support,i," : control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)");
 			continue;
 			};
+		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
+		// check naked declarations first
+		if (is_C99_named_specifier(src.data<0>()[i],"union"))
+			{
+			type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
+			src.c_array<0>()[i].type_code.set_type(tmp);
+			}
+		else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
+			{
+			type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+			src.c_array<0>()[i].type_code.set_type(tmp);
+			}
+		else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
+			{	// can only define once
+			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+			if (tmp)
+				{	//! \test zcc/decl.C99/Error_union_multidef.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("'union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+				INFORM("' already defined (C99 6.7.2.3p1)");
+				zcc_errors.inc_error();
+				// now it's gone
+				// remove trailing semicolon if present
+				src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
+				continue;
+				}
+			}
+		else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
+			{	// can only define once
+			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+			if (tmp)
+				{	//! \test zcc/decl.C99/Error_struct_multidef.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("'struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+				INFORM("' already defined (C99 6.7.2.3p1)");
+				zcc_errors.inc_error();
+				// now it's gone
+				// remove trailing semicolon if present
+				src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
+				continue;
+				}
+			}
+
+		if (	1<src.size<0>()-i
+			&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
+			{	// is_C99_named_specifier(src.data<0>()[i],"enum") will cause an error later, in variable parsing
+			if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_union.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous union declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_struct.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous struct declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			else if (is_C99_named_specifier(src.data<0>()[i],"union"))
+				{	// forward-declare, fine
+				if (types.get_id_union(src.data<0>()[i].index_tokens[1].token.first))
+					{	// but if already (forward-)declared then this is a no-op
+						// think this is common enough to not warrant OAOO/DRY treatment
+					//! \bug needs test case
+					// remove from parse
+					src.DeleteNSlotsAt<0>(2,i);
+					continue;					
+					}
+				// forward-declare
+				//! \bug needs test case
+				union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first);
+				types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
+				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				assert(types.get_structdecl(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)));
+				i += 2;
+				continue;
+				}
+			else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
+				{	// forward-declare, fine
+				if (types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
+					{	// but if already (forward-)declared then this is a no-op
+						// think this is common enough to not warrant OAOO/DRY treatment
+					//! \bug needs test case
+					// remove from parse
+					src.DeleteNSlotsAt<0>(2,i);
+					continue;					
+					}
+				// forward-declare
+				//! \bug needs test case
+				union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first);
+				types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(types.get_structdecl(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+				i += 2;
+				continue;
+				}
+			else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
+				{	// definitions...fine
+				type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
+				C_union_struct_def* tmp2 = NULL;
+				if (tmp)
+					{	// promoting forward-declare to definition
+						//! \bug needs test case
+					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
+					assert(tmp3);
+					tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+					//! \todo record field structure, etc.
+					types.upgrade_decl_to_def(tmp,tmp2);
+					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+					assert(types.get_C_structdef(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)));
+					}
+				else{	// definition
+						//! \test zcc/decl.C99/Pass_union_def.h
+					tmp2 = new C_union_struct_def(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+					//! \todo record field structure, etc.
+					types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,tmp2);
+					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+					assert(types.get_C_structdef(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)));
+					}
+				i += 2;
+				continue;
+				}
+			else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
+				{	// definitions...fine
+				type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+				C_union_struct_def* tmp2 = NULL;
+				if (tmp)
+					{	// promoting forward-declare to definition
+						//! \bug needs test case
+					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
+					assert(tmp3);
+					tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+					//! \todo record field structure, etc.
+					types.upgrade_decl_to_def(tmp,tmp2);
+					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+					assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+					}
+				else{	// definition
+						//! \test zcc/decl.C99/Pass_struct_def.h
+					tmp2 = new C_union_struct_def(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+					//! \todo record field structure, etc.
+					types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,tmp2);
+					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+					assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+					}
+				i += 2;
+				continue;
+				};
+			};
 		// general declaration scanner 
 		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
 		// intercept declarations as follows
@@ -10820,6 +10988,256 @@
 			C99_CPP_handle_static_assertion(src,types,*CPlusPlusLexer->pp_support,i," : control expression for static assertion must be a constant convertible to bool (C++0X 7p4)");
 			continue;
 			};
+		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
+		// check naked declarations first; handle namespaces later
+		if (NULL==active_namespace)
+			{
+			if (is_C99_named_specifier(src.data<0>()[i],"union"))
+				{
+				type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
+				src.c_array<0>()[i].type_code.set_type(tmp);
+				}
+			else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
+				{
+				type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+				src.c_array<0>()[i].type_code.set_type(tmp);
+				}
+			else if (is_C99_named_specifier(src.data<0>()[i],"class"))
+				{
+				type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+				src.c_array<0>()[i].type_code.set_type(tmp);
+				}
+			else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
+				{	// can only define once
+				const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				if (tmp)
+					{	//! \test zcc/decl.C99/Error_union_multidef.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'union ");
+					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INFORM("' already defined (C++0X 9.1p1)");
+					zcc_errors.inc_error();
+					// now it's gone
+					// remove trailing semicolon if present
+					src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
+					continue;
+					}
+				}
+			else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
+				{	// can only define once
+				const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				if (tmp)
+					{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'struct ");
+					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INFORM("' already defined (C++0X 9.1p1)");
+					zcc_errors.inc_error();
+					// now it's gone
+					// remove trailing semicolon if present
+					src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
+					continue;
+					}
+				}
+			else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
+				{	// can only define once
+				const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				if (tmp)
+					{	//! \test zcc/decl.C99/Error_class_multidef.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'class ");
+					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INFORM("' already defined (C++0X 9.1p1)");
+					zcc_errors.inc_error();
+					// now it's gone
+					// remove trailing semicolon if present
+					src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
+					continue;
+					}
+				}
+
+			if (	1<src.size<0>()-i
+				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// is_C99_named_specifier(src.data<0>()[i],"enum") will cause an error later, in variable parsing
+				if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
+					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+						//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+						//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("unreferenceable anonymous union declaration");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// remove from parse
+					src.DeleteNSlotsAt<0>(2,i);
+					continue;
+					}
+				else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
+					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+						//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+						//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("unreferenceable anonymous struct declaration");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// remove from parse
+					src.DeleteNSlotsAt<0>(2,i);
+					continue;
+					}
+				else if (is_C99_anonymous_specifier(src.data<0>()[i],"class"))
+					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+						//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+						//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("unreferenceable anonymous class declaration");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// remove from parse
+					src.DeleteNSlotsAt<0>(2,i);
+					continue;
+					}
+				else if (is_C99_named_specifier(src.data<0>()[i],"union"))
+					{	// forward-declare, fine
+					if (types.get_id_union(src.data<0>()[i].index_tokens[1].token.first))
+						{	// but if already (forward-)declared then this is a no-op
+							// think this is common enough to not warrant OAOO/DRY treatment
+						//! \bug needs test case
+						// remove from parse
+						src.DeleteNSlotsAt<0>(2,i);
+						continue;					
+						}
+					// forward-declare
+					//! \bug needs test case
+					union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first);
+					types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
+					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+					assert(types.get_structdecl(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)));
+					i += 2;
+					continue;
+					}
+				else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
+					{	// forward-declare, fine
+					if (types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
+						{	// but if already (forward-)declared then this is a no-op
+							// think this is common enough to not warrant OAOO/DRY treatment
+						//! \bug needs test case
+						// remove from parse
+						src.DeleteNSlotsAt<0>(2,i);
+						continue;					
+						}
+					// forward-declare
+					//! \bug needs test case
+					union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first);
+					types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
+					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+					assert(types.get_structdecl(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+					i += 2;
+					continue;
+					}
+				else if (is_C99_named_specifier(src.data<0>()[i],"class"))
+					{	// forward-declare, fine
+					if (types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
+						{	// but if already (forward-)declared then this is a no-op
+							// think this is common enough to not warrant OAOO/DRY treatment
+						//! \bug needs test case
+						// remove from parse
+						src.DeleteNSlotsAt<0>(2,i);
+						continue;					
+						}
+					// forward-declare
+					//! \bug needs test case
+					union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].token.first);
+					types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
+					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+					assert(types.get_structdecl(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+					i += 2;
+					continue;
+					}
+				else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
+					{	// definitions...fine
+					type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
+					C_union_struct_def* tmp2 = NULL;
+					if (tmp)
+						{	// promoting forward-declare to definition
+							//! \bug needs test case
+						const union_struct_decl* tmp3 = types.get_structdecl(tmp);
+						assert(tmp3);
+						tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+						//! \todo record field structure, etc.
+						types.upgrade_decl_to_def(tmp,tmp2);
+						assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+						assert(types.get_C_structdef(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)));
+						}
+					else{	// definition
+							//! \test zcc/decl.C99/Pass_union_def.hpp
+						tmp2 = new C_union_struct_def(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+						//! \todo record field structure, etc.
+						types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,tmp2);
+						assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+						assert(types.get_C_structdef(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)));
+						}
+					i += 2;
+					continue;
+					}
+				else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
+					{	// definitions...fine
+					type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+					C_union_struct_def* tmp2 = NULL;
+					if (tmp)
+						{	// promoting forward-declare to definition
+							//! \bug needs test case
+						const union_struct_decl* tmp3 = types.get_structdecl(tmp);
+						assert(tmp3);
+						tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+						//! \todo record field structure, etc.
+						types.upgrade_decl_to_def(tmp,tmp2);
+						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+						assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+						}
+					else{	// definition
+							//! \test zcc/decl.C99/Pass_struct_def.hpp
+						tmp2 = new C_union_struct_def(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+						//! \todo record field structure, etc.
+						types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,tmp2);
+						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+						assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+						}
+					i += 2;
+					continue;
+					}
+				else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
+					{	// definitions...fine
+					type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+					C_union_struct_def* tmp2 = NULL;
+					if (tmp)
+						{	// promoting forward-declare to definition
+							//! \bug needs test case
+						const union_struct_decl* tmp3 = types.get_structdecl(tmp);
+						assert(tmp3);
+						tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+						//! \todo record field structure, etc.
+						types.upgrade_decl_to_def(tmp,tmp2);
+						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+						assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+						}
+					else{	// definition
+							//! \test zcc/decl.C99/Pass_class_def.hpp
+						tmp2 = new C_union_struct_def(union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+						//! \todo record field structure, etc.
+						types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,tmp2);
+						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+						assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+						}
+					i += 2;
+					continue;
+					};
+				};
+			}
 		// namespace scanner
 		// need some scheme to handle unnamed namespaces (probably alphabetical counter after something illegal so unmatchable)
 		// C++0X has inline namespaces; ignore these for now (well, maybe not: consuming the inline will prevent problems)

Added: trunk/tests/zcc/decl.C99/Error_class_multidef.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_multidef.hpp	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc/decl.C99/Error_class_multidef.hpp	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,12 @@
+// decl.C99\Error_class_multidef.hpp
+// using multiply defined struct
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+class bad_test {
+	int x_factor;
+};
+
+class bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_struct_multidef.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_multidef.h	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc/decl.C99/Error_struct_multidef.h	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,12 @@
+// decl.C99\Error_struct_multidef.h
+// using multiply defined struct
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+struct bad_test {
+	int x_factor;
+};
+
+struct bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_struct_multidef.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_multidef.hpp	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc/decl.C99/Error_struct_multidef.hpp	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,12 @@
+// decl.C99\Error_struct_multidef.hpp
+// using multiply defined struct
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+struct bad_test {
+	int x_factor;
+};
+
+struct bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_union_multidef.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_multidef.h	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc/decl.C99/Error_union_multidef.h	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,12 @@
+// decl.C99\Error_union_multidef.h
+// using multiply defined union
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+union bad_test {
+	int x_factor;
+};
+
+union bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_union_multidef.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_multidef.hpp	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc/decl.C99/Error_union_multidef.hpp	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,12 @@
+// decl.C99\Error_union_multidef.hpp
+// using multiply defined union
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+union bad_test {
+	int x_factor;
+};
+
+union bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Pass_class_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_class_def.hpp	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc/decl.C99/Pass_class_def.hpp	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,8 @@
+// decl.C99\Pass_class_def.hpp
+// using singly defined struct
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+class good_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Pass_struct_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_struct_def.h	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc/decl.C99/Pass_struct_def.h	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,8 @@
+// decl.C99\Pass_struct_def.h
+// using singly defined struct
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+struct good_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Pass_struct_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_struct_def.hpp	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc/decl.C99/Pass_struct_def.hpp	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,8 @@
+// decl.C99\Pass_struct_def.hpp
+// using singly defined struct
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+struct good_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Pass_union_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_union_def.h	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc/decl.C99/Pass_union_def.h	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,8 @@
+// decl.C99\Pass_union_def.h
+// using singly defined union
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+union good_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Pass_union_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_union_def.hpp	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc/decl.C99/Pass_union_def.hpp	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,8 @@
+// decl.C99\Pass_union_def.hpp
+// using singly defined union
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+union good_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Warn_inaccessible_class.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_inaccessible_class.hpp	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc/decl.C99/Warn_inaccessible_class.hpp	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_inaccessible_class.hpp
+// inaccessible struct
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+class {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Warn_inaccessible_struct.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_inaccessible_struct.h	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc/decl.C99/Warn_inaccessible_struct.h	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_inaccessible_struct.h
+// inaccessible struct
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+struct {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Warn_inaccessible_struct.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_inaccessible_struct.hpp	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc/decl.C99/Warn_inaccessible_struct.hpp	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_inaccessible_struct.hpp
+// inaccessible struct
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+struct {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Warn_inaccessible_union.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_inaccessible_union.h	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc/decl.C99/Warn_inaccessible_union.h	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_inaccessible_union.h
+// inaccessible union
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+union {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Warn_inaccessible_union.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_inaccessible_union.hpp	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc/decl.C99/Warn_inaccessible_union.hpp	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_inaccessible_union.hpp
+// inaccessible union
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+union {
+	int x_factor;
+};
+

Added: trunk/tests/zcc.in/decl.C99/Error_struct_multidef.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_struct_multidef.in	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc.in/decl.C99/Error_struct_multidef.in	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,12 @@
+SUFFIXES h hpp
+// using multiply defined struct
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+struct bad_test {
+	int x_factor;
+};
+
+struct bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc.in/decl.C99/Error_union_multidef.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_union_multidef.in	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc.in/decl.C99/Error_union_multidef.in	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,12 @@
+SUFFIXES h hpp
+// using multiply defined union
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+union bad_test {
+	int x_factor;
+};
+
+union bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc.in/decl.C99/Pass_struct_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_struct_def.in	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc.in/decl.C99/Pass_struct_def.in	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+// using singly defined struct
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+struct good_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc.in/decl.C99/Pass_union_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_union_def.in	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc.in/decl.C99/Pass_union_def.in	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+// using singly defined union
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+union good_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc.in/decl.C99/Warn_inaccessible_struct.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Warn_inaccessible_struct.in	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc.in/decl.C99/Warn_inaccessible_struct.in	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+// inaccessible struct
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+struct {
+	int x_factor;
+};
+

Added: trunk/tests/zcc.in/decl.C99/Warn_inaccessible_union.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Warn_inaccessible_union.in	2009-11-23 08:19:23 UTC (rev 274)
+++ trunk/tests/zcc.in/decl.C99/Warn_inaccessible_union.in	2009-11-23 08:22:29 UTC (rev 275)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+// inaccessible union
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+union {
+	int x_factor;
+};
+



From zaimoni at mail.berlios.de  Tue Nov 24 06:42:29 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 24 Nov 2009 06:42:29 +0100
Subject: [Zcplusplus-commits] r276 - in trunk/tests: zcc zcc.in
Message-ID: <200911240542.nAO5gTiw001365@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-24 06:42:13 +0100 (Tue, 24 Nov 2009)
New Revision: 276

Modified:
   trunk/tests/zcc.in/run_tests.in
   trunk/tests/zcc.in/run_tests_C99.in
   trunk/tests/zcc/run_tests.bat
   trunk/tests/zcc/run_tests.sh
   trunk/tests/zcc/run_tests_C99.bat
   trunk/tests/zcc/run_tests_C99.sh
Log:
make test driver *.sh, *.bat cover pass/warn tests in decl.C99

Modified: trunk/tests/zcc/run_tests.bat
===================================================================
--- trunk/tests/zcc/run_tests.bat	2009-11-23 08:22:29 UTC (rev 275)
+++ trunk/tests/zcc/run_tests.bat	2009-11-24 05:42:13 UTC (rev 276)
@@ -27,6 +27,12 @@
 
 @echo Checking ZCC warnings on ISO-accepted code
 @echo ====
+ at for %%f in (decl.C99\Warn*.h) do @echo %CPP_ISO% -Werror %%f & @%CPP_ISO% -Werror %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (decl.C99\Warn*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (decl.C99\Warn*.h) do @(set /a ACCEPT_TEST=ACCEPT_TEST+1 & set /a REJECT_TEST=REJECT_TEST+1)
+ at for %%f in (decl.C99\Warn*.hpp) do @echo %CPP_ISO% -Werror %%f & @%CPP_ISO% -Werror %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (decl.C99\Warn*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (decl.C99\Warn*.hpp) do @(set /a ACCEPT_TEST=ACCEPT_TEST+1 & set /a REJECT_TEST=REJECT_TEST+1)
 @for %%f in (namespace.CPP\Warn*.hpp) do @echo %CPP_ISO% -Werror %%f & @%CPP_ISO% -Werror %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
 @for %%f in (namespace.CPP\Warn*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
 @for %%f in (namespace.CPP\Warn*.hpp) do @(set /a ACCEPT_TEST=ACCEPT_TEST+1 & set /a REJECT_TEST=REJECT_TEST+1)
@@ -37,6 +43,10 @@
 @for %%f in (Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
 @for %%f in (Pass*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
 @for %%f in (Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (decl.C99\Pass*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (decl.C99\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (decl.C99\Pass*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (decl.C99\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
 @for %%f in (staticassert.C1X\Pass*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
 @for %%f in (staticassert.C1X\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
 @for %%f in (staticassert.C1X\Pass*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)

Modified: trunk/tests/zcc/run_tests.sh
===================================================================
--- trunk/tests/zcc/run_tests.sh	2009-11-23 08:22:29 UTC (rev 275)
+++ trunk/tests/zcc/run_tests.sh	2009-11-24 05:42:13 UTC (rev 276)
@@ -29,6 +29,10 @@
 
 	echo Checking ZCC warnings on ISO-accepted code
 	echo ====
+	for F in decl.C99/Warn*.h; do let ++REJECT_TEST; echo $CPP_ISO -Werror $F; if $CPP_ISO -Werror $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in decl.C99/Warn*.h; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in decl.C99/Warn*.hpp; do let ++REJECT_TEST; echo $CPP_ISO -Werror $F; if $CPP_ISO -Werror $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in decl.C99/Warn*.hpp; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 	for F in namespace.CPP/Warn*.hpp; do let ++REJECT_TEST; echo $CPP_ISO -Werror $F; if $CPP_ISO -Werror $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
 	for F in namespace.CPP/Warn*.hpp; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 
@@ -36,6 +40,8 @@
 	echo ====
 	for F in Pass*.h; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 	for F in Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in decl.C99/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in decl.C99/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 	for F in staticassert.C1X/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 	for F in staticassert.C1X/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 

Modified: trunk/tests/zcc/run_tests_C99.bat
===================================================================
--- trunk/tests/zcc/run_tests_C99.bat	2009-11-23 08:22:29 UTC (rev 275)
+++ trunk/tests/zcc/run_tests_C99.bat	2009-11-24 05:42:13 UTC (rev 276)
@@ -19,6 +19,8 @@
 @echo ====
 @for %%f in (Pass*.h) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
 @for %%f in (Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (decl.C99\Pass*.h) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (decl.C99\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
 
 @echo %BAD_PASS% of %REJECT_TEST% rejection tests accepted
 @if not "%BAD_PASS_NAME%"=="LastAccepted:" @echo %BAD_PASS_NAME%

Modified: trunk/tests/zcc/run_tests_C99.sh
===================================================================
--- trunk/tests/zcc/run_tests_C99.sh	2009-11-23 08:22:29 UTC (rev 275)
+++ trunk/tests/zcc/run_tests_C99.sh	2009-11-24 05:42:13 UTC (rev 276)
@@ -24,6 +24,7 @@
 	echo Checking ISO acceptance requirements
 	echo ====
 	for F in Pass*.h; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in decl.C99/Pass*.h; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 
 	echo -E $BAD_PASS of $REJECT_TEST rejection tests accepted
 	if test -n "$BAD_PASS_NAME"; then echo -E $BAD_PASS_NAME; fi

Modified: trunk/tests/zcc.in/run_tests.in
===================================================================
--- trunk/tests/zcc.in/run_tests.in	2009-11-23 08:22:29 UTC (rev 275)
+++ trunk/tests/zcc.in/run_tests.in	2009-11-24 05:42:13 UTC (rev 276)
@@ -12,10 +12,12 @@
 ERROR CPP_ISO staticassert.C1X/Error*
 
 ECHO Checking ZCC warnings on ISO-accepted code
+WARN CPP_ISO decl.C99/Warn*
 WARN CPP_ISO namespace.CPP/Warn*
 
 ECHO Checking ISO acceptance requirements
 PASS CPP_ISO Pass*
+PASS CPP_ISO decl.C99/Pass*
 PASS CPP_ISO staticassert.C1X/Pass*
 
 EPILOG

Modified: trunk/tests/zcc.in/run_tests_C99.in
===================================================================
--- trunk/tests/zcc.in/run_tests_C99.in	2009-11-23 08:22:29 UTC (rev 275)
+++ trunk/tests/zcc.in/run_tests_C99.in	2009-11-24 05:42:13 UTC (rev 276)
@@ -9,5 +9,6 @@
 
 ECHO Checking ISO acceptance requirements
 PASS CPP Pass*
+PASS CPP decl.C99/Pass*
 
 EPILOG



From zaimoni at mail.berlios.de  Tue Nov 24 08:15:05 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 24 Nov 2009 08:15:05 +0100
Subject: [Zcplusplus-commits] r277 - trunk
Message-ID: <200911240715.nAO7F5Hc021819@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-24 08:14:57 +0100 (Tue, 24 Nov 2009)
New Revision: 277

Added:
   trunk/enum_type.cpp
   trunk/enum_type.hpp
Modified:
   trunk/CSupport.cpp
   trunk/MakeMake.cfg
   trunk/POSIX.dep
Log:
recognize top-level unscoped enumerations (no namespaces, enum bases, or scoped enums)

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-11-24 05:42:13 UTC (rev 276)
+++ trunk/CSupport.cpp	2009-11-24 07:14:57 UTC (rev 277)
@@ -23,6 +23,7 @@
 #include "C_PPOctalInteger.hpp"
 #include "C_PPDecimalFloat.hpp"
 #include "C_PPHexFloat.hpp"
+#include "enum_type.hpp"
 #include "struct_type.hpp"
 #include "CheckReturn.hpp"
 
@@ -10626,6 +10627,49 @@
 				continue;
 				}
 			}
+		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
+		else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
+			{	// C99 6.7.2.3: allowed only after name is defined
+			type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+			src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
+			if (!tmp && !(src.c_array<0>()[i].flags & parse_tree::INVALID))
+				{	//! \test zcc\decl.C99\Error_enum_undef.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("'enum ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+				INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].flags |= parse_tree::INVALID;
+				}
+			}
+		else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
+			{	// can only define once
+			if (types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc\decl.C99\Error_enum_multidef.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("'enum ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+				INFORM("' already defined (C99 6.7.2.3p1)");
+				zcc_errors.inc_error();
+				// now it's gone
+				src.DeleteNSlotsAt<0>(1,i);
+				continue;
+				};
+			// enum-specifier doesn't have a specific declaration mode
+			//! \test zcc\decl.C99\Pass_enum_def.h
+			enum_def* tmp = new enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record enum values
+			types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,tmp);
+			}
+		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
+			{	// enum-specifier doesn't have a specific declaration mode
+				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
+			enum_def* tmp = new enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
+			//! \todo record enum values
+			types.register_enum_def("<unknown>",tmp);
+			}
 
 		if (	1<src.size<0>()-i
 			&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -10661,13 +10705,13 @@
 				if (types.get_id_union(src.data<0>()[i].index_tokens[1].token.first))
 					{	// but if already (forward-)declared then this is a no-op
 						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \bug needs test case
+					//! \test zcc/decl.C99/Pass_union_forward_def.h
 					// remove from parse
 					src.DeleteNSlotsAt<0>(2,i);
 					continue;					
 					}
 				// forward-declare
-				//! \bug needs test case
+				//! \test zcc/decl.C99/Pass_union_forward_def.h
 				union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first);
 				types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
 				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
@@ -10680,13 +10724,13 @@
 				if (types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
 					{	// but if already (forward-)declared then this is a no-op
 						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \bug needs test case
+					//! \test zcc/decl.C99/Pass_struct_forward_def.h
 					// remove from parse
 					src.DeleteNSlotsAt<0>(2,i);
 					continue;					
 					}
 				// forward-declare
-				//! \bug needs test case
+				//! \test zcc/decl.C99/Pass_struct_forward_def.h
 				union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first);
 				types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
 				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
@@ -10700,7 +10744,7 @@
 				C_union_struct_def* tmp2 = NULL;
 				if (tmp)
 					{	// promoting forward-declare to definition
-						//! \bug needs test case
+						//! \test zcc/decl.C99/Pass_union_forward_def.h
 					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
 					assert(tmp3);
 					tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
@@ -10726,7 +10770,7 @@
 				C_union_struct_def* tmp2 = NULL;
 				if (tmp)
 					{	// promoting forward-declare to definition
-						//! \bug needs test case
+						//! \test zcc/decl.C99/Pass_struct_forward_def.h
 					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
 					assert(tmp3);
 					tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
@@ -11016,7 +11060,7 @@
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'union ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' already defined (C++0X 9.1p1)");
+					INFORM("' already defined (C++98 3.2p1)");
 					zcc_errors.inc_error();
 					// now it's gone
 					// remove trailing semicolon if present
@@ -11033,7 +11077,7 @@
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'struct ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' already defined (C++0X 9.1p1)");
+					INFORM("' already defined (C++98 3.2p1)");
 					zcc_errors.inc_error();
 					// now it's gone
 					// remove trailing semicolon if present
@@ -11050,7 +11094,7 @@
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'class ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' already defined (C++0X 9.1p1)");
+					INFORM("' already defined (C++98 3.2p1)");
 					zcc_errors.inc_error();
 					// now it's gone
 					// remove trailing semicolon if present
@@ -11058,6 +11102,52 @@
 					continue;
 					}
 				}
+			// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
+			//! \todo actually, we can try forward-declare both scoped enums and enum-based enums (C++0X 7.2p3, these have enough size information); but other parts of the standard get in the way
+			else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
+				{
+				type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+				src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
+				if (!tmp && !(src.c_array<0>()[i].flags & parse_tree::INVALID))
+					{	// this belongs elsewhere
+						//! \test zcc\decl.C99\Error_enum_undef.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'enum ");
+					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
+					zcc_errors.inc_error();
+					src.c_array<0>()[i].flags |= parse_tree::INVALID;
+					}
+				//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
+				}
+			else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
+				{	// can only define once
+				if (types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
+					{	//! \test zcc\decl.C99\Error_enum_multidef.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'enum ");
+					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INFORM("' already defined (C++98 3.2p1)");
+					zcc_errors.inc_error();
+					// now it's gone
+					src.DeleteNSlotsAt<0>(1,i);
+					continue;
+					};
+				//! \test zcc\decl.C99\Pass_enum_def.hpp
+				// enum-specifier doesn't have a specific declaration mode
+				enum_def* tmp = new enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+				//! \todo record enum values
+				types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,tmp);
+				}
+			else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
+				{	// enum-specifier doesn't have a specific declaration mode
+					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
+				enum_def* tmp = new enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
+				//! \todo record enum values
+				types.register_enum_def("<unknown>",tmp);
+				}
 
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -11106,13 +11196,13 @@
 					if (types.get_id_union(src.data<0>()[i].index_tokens[1].token.first))
 						{	// but if already (forward-)declared then this is a no-op
 							// think this is common enough to not warrant OAOO/DRY treatment
-						//! \bug needs test case
+						//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 						// remove from parse
 						src.DeleteNSlotsAt<0>(2,i);
 						continue;					
 						}
 					// forward-declare
-					//! \bug needs test case
+					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 					union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first);
 					types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
 					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
@@ -11125,13 +11215,13 @@
 					if (types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
 						{	// but if already (forward-)declared then this is a no-op
 							// think this is common enough to not warrant OAOO/DRY treatment
-						//! \bug needs test case
+						//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 						// remove from parse
 						src.DeleteNSlotsAt<0>(2,i);
 						continue;					
 						}
 					// forward-declare
-					//! \bug needs test case
+					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 					union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first);
 					types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
 					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
@@ -11164,7 +11254,7 @@
 					C_union_struct_def* tmp2 = NULL;
 					if (tmp)
 						{	// promoting forward-declare to definition
-							//! \bug needs test case
+							//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 						const union_struct_decl* tmp3 = types.get_structdecl(tmp);
 						assert(tmp3);
 						tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
@@ -11190,7 +11280,7 @@
 					C_union_struct_def* tmp2 = NULL;
 					if (tmp)
 						{	// promoting forward-declare to definition
-							//! \bug needs test case
+							//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 						const union_struct_decl* tmp3 = types.get_structdecl(tmp);
 						assert(tmp3);
 						tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2009-11-24 05:42:13 UTC (rev 276)
+++ trunk/MakeMake.cfg	2009-11-24 07:14:57 UTC (rev 277)
@@ -1,6 +1,6 @@
 ########
-ProgObjects = {	'z_cpp':('z_cpp','langroute','AtomicString','filesystem','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
-				'zcc':('zcc','langroute','AtomicString','filesystem','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
+ProgObjects = {	'z_cpp':('z_cpp','langroute','AtomicString','filesystem','CPUInfo','enum_type','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
+				'zcc':('zcc','langroute','AtomicString','filesystem','CPUInfo','enum_type','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
 MainPrograms = ['z_cpp','zcc']
 
 # process control

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2009-11-24 05:42:13 UTC (rev 276)
+++ trunk/POSIX.dep	2009-11-24 07:14:57 UTC (rev 277)
@@ -1,8 +1,8 @@
-OBJECTS_Z_CPP = z_cpp.o langroute.o AtomicString.o filesystem.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
-OBJECTS_Z_CPP_LINK_PRIORITY = CSupport.o type_system.o struct_type.o ParseTree.o type_spec.o CPreproc.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o z_cpp.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_Z_CPP = z_cpp.o langroute.o AtomicString.o filesystem.o CPUInfo.o enum_type.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
+OBJECTS_Z_CPP_LINK_PRIORITY = enum_type.o CSupport.o type_system.o struct_type.o ParseTree.o type_spec.o CPreproc.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o z_cpp.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
-OBJECTS_ZCC = zcc.o langroute.o AtomicString.o filesystem.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = CSupport.o type_system.o struct_type.o ParseTree.o type_spec.o ZParser.o CPreproc.o zcc.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_ZCC = zcc.o langroute.o AtomicString.o filesystem.o CPUInfo.o enum_type.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
+OBJECTS_ZCC_LINK_PRIORITY = enum_type.o CSupport.o type_system.o struct_type.o ParseTree.o type_spec.o ZParser.o CPreproc.o zcc.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
 # dependencies
 z_cpp.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/OS/mutex.hpp unsigned_fixed_int.hpp unsigned_aux.hpp
@@ -10,11 +10,12 @@
 AtomicString.o: AtomicString.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 filesystem.o: filesystem.h Zaimoni.STL/Compiler.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h
 CPUInfo.o: CPUInfo.hpp unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
+enum_type.o: enum_type.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp CPUInfo.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_aux.hpp
 struct_type.o: struct_type.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
 type_system.o: type_system.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport.o: CSupport.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp struct_type.hpp CheckReturn.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/OS/mutex.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport.o: CSupport.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/OS/mutex.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h

Added: trunk/enum_type.cpp
===================================================================
--- trunk/enum_type.cpp	2009-11-24 05:42:13 UTC (rev 276)
+++ trunk/enum_type.cpp	2009-11-24 07:14:57 UTC (rev 277)
@@ -0,0 +1,36 @@
+// enum_type.cpp
+
+#include "enum_type.hpp"
+
+const enum_def& enum_def::operator=(const enum_def& src)
+{
+	if (src.enum_names.empty())
+		{
+		enum_names.reset();
+		enum_values.reset();
+		}
+	else if (src.enum_names.size()<=enum_names.size())
+		{
+		enum_names = src.enum_names;
+		enum_values = src.enum_values;
+		}
+	else{
+		zaimoni::autovalarray_ptr_throws<unsigned_fixed_int<VM_MAX_BIT_PLATFORM> > tmp_enum_values(src.enum_values);
+		enum_names = src.enum_names;
+		tmp_enum_values.MoveInto(enum_values);
+		}
+	_tag = src._tag;
+	_logical_line = src._logical_line;
+	_src_filename = src._src_filename;
+	represent_as = src.represent_as;
+	assert(syntax_ok());
+	return *this;
+}
+
+#ifndef NDEBUG
+bool enum_def::syntax_ok() const
+{
+	return enum_names.size()==enum_values.size();
+}
+#endif
+

Added: trunk/enum_type.hpp
===================================================================
--- trunk/enum_type.hpp	2009-11-24 05:42:13 UTC (rev 276)
+++ trunk/enum_type.hpp	2009-11-24 07:14:57 UTC (rev 277)
@@ -0,0 +1,30 @@
+// enum_type.hpp
+#ifndef ENUM_TYPE_HPP
+#define ENUM_TYPE_HPP 1
+
+#include "Zaimoni.STL/POD.hpp"
+#include "Zaimoni.STL/AutoPtr.hpp"
+#include "CPUInfo.hpp"
+
+class enum_def
+{
+private:
+	const char* _tag;
+	zaimoni::POD_pair<size_t,size_t> _logical_line;
+	const char* _src_filename;
+public:
+	zaimoni::weakautovalarray_ptr_throws<const char*> enum_names;	// using registered strings
+	zaimoni::autovalarray_ptr_throws<unsigned_fixed_int<VM_MAX_BIT_PLATFORM> > enum_values;
+	unsigned char represent_as;
+
+	enum_def(const char* tag,zaimoni::POD_pair<size_t,size_t> logical_line,const char* src_filename): _tag((tag && *tag ? tag : NULL)),_logical_line(logical_line),_src_filename((src_filename && *src_filename ? src_filename : NULL)),represent_as(0) {};
+	// default ok for: copy constructor, destructor
+	const enum_def& operator=(const enum_def& src);	// ACID/strong guarantee
+
+	const char* tag() const {return _tag;};
+#ifndef NDEBUG
+	bool syntax_ok() const;
+#endif
+};
+
+#endif



From zaimoni at mail.berlios.de  Tue Nov 24 08:16:32 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 24 Nov 2009 08:16:32 +0100
Subject: [Zcplusplus-commits] r278 - in trunk/tests: zcc/decl.C99
	zcc.in/decl.C99
Message-ID: <200911240716.nAO7GWso021872@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-24 08:16:13 +0100 (Tue, 24 Nov 2009)
New Revision: 278

Added:
   trunk/tests/zcc.in/decl.C99/Error_enum_multidef.in
   trunk/tests/zcc.in/decl.C99/Error_enum_undef.in
   trunk/tests/zcc.in/decl.C99/Pass_anonymous_enum_def.in
   trunk/tests/zcc.in/decl.C99/Pass_enum_def.in
   trunk/tests/zcc.in/decl.C99/Pass_struct_forward_def.in
   trunk/tests/zcc.in/decl.C99/Pass_union_forward_def.in
   trunk/tests/zcc/decl.C99/Error_enum_multidef.h
   trunk/tests/zcc/decl.C99/Error_enum_multidef.hpp
   trunk/tests/zcc/decl.C99/Error_enum_undef.h
   trunk/tests/zcc/decl.C99/Error_enum_undef.hpp
   trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.h
   trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.hpp
   trunk/tests/zcc/decl.C99/Pass_class_forward_def.hpp
   trunk/tests/zcc/decl.C99/Pass_enum_def.h
   trunk/tests/zcc/decl.C99/Pass_enum_def.hpp
   trunk/tests/zcc/decl.C99/Pass_struct_forward_def.h
   trunk/tests/zcc/decl.C99/Pass_struct_forward_def.hpp
   trunk/tests/zcc/decl.C99/Pass_union_forward_def.h
   trunk/tests/zcc/decl.C99/Pass_union_forward_def.hpp
Log:
more test cases for code coverage

Added: trunk/tests/zcc/decl.C99/Error_enum_multidef.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_multidef.h	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc/decl.C99/Error_enum_multidef.h	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,12 @@
+// decl.C99\Error_enum_multidef.h
+// using multiply defined enum
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+}
+
+enum bad_test {
+	x_factor = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Error_enum_multidef.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_multidef.hpp	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc/decl.C99/Error_enum_multidef.hpp	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,12 @@
+// decl.C99\Error_enum_multidef.hpp
+// using multiply defined enum
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+}
+
+enum bad_test {
+	x_factor = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Error_enum_undef.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_undef.h	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc/decl.C99/Error_enum_undef.h	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,6 @@
+// decl.C99\Error_enum_undef.h
+// using undefined enum
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test
+

Added: trunk/tests/zcc/decl.C99/Error_enum_undef.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_undef.hpp	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc/decl.C99/Error_enum_undef.hpp	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,6 @@
+// decl.C99\Error_enum_undef.hpp
+// using undefined enum
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test
+

Added: trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.h	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.h	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,8 @@
+// decl.C99\Pass_anonymous_enum_def.h
+// using singly defined enum
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum {
+	x_factor = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.hpp	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc/decl.C99/Pass_anonymous_enum_def.hpp	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,8 @@
+// decl.C99\Pass_anonymous_enum_def.hpp
+// using singly defined enum
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum {
+	x_factor = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Pass_class_forward_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_class_forward_def.hpp	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc/decl.C99/Pass_class_forward_def.hpp	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,11 @@
+// decl.C99\Pass_class_forward_def.hpp
+// using singly defined class
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+class good_test;
+class good_test;
+
+class good_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Pass_enum_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_def.h	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc/decl.C99/Pass_enum_def.h	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,8 @@
+// decl.C99\Pass_enum_def.h
+// using singly defined enum
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum good_test {
+	x_factor = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Pass_enum_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_def.hpp	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc/decl.C99/Pass_enum_def.hpp	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,8 @@
+// decl.C99\Pass_enum_def.hpp
+// using singly defined enum
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum good_test {
+	x_factor = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Pass_struct_forward_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_struct_forward_def.h	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc/decl.C99/Pass_struct_forward_def.h	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,11 @@
+// decl.C99\Pass_struct_forward_def.h
+// using singly defined struct
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+struct good_test;
+struct good_test;
+
+struct good_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Pass_struct_forward_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_struct_forward_def.hpp	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc/decl.C99/Pass_struct_forward_def.hpp	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,11 @@
+// decl.C99\Pass_struct_forward_def.hpp
+// using singly defined struct
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+struct good_test;
+struct good_test;
+
+struct good_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Pass_union_forward_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_union_forward_def.h	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc/decl.C99/Pass_union_forward_def.h	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,11 @@
+// decl.C99\Pass_union_forward_def.h
+// using singly defined union
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+union good_test;
+union good_test;
+
+union good_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Pass_union_forward_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_union_forward_def.hpp	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc/decl.C99/Pass_union_forward_def.hpp	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,11 @@
+// decl.C99\Pass_union_forward_def.hpp
+// using singly defined union
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+union good_test;
+union good_test;
+
+union good_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc.in/decl.C99/Error_enum_multidef.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_multidef.in	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_multidef.in	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,12 @@
+SUFFIXES h hpp
+// using multiply defined enum
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+}
+
+enum bad_test {
+	x_factor = 1
+}
+

Added: trunk/tests/zcc.in/decl.C99/Error_enum_undef.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_undef.in	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_undef.in	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,6 @@
+SUFFIXES h hpp
+// using undefined enum
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test
+

Added: trunk/tests/zcc.in/decl.C99/Pass_anonymous_enum_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_anonymous_enum_def.in	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc.in/decl.C99/Pass_anonymous_enum_def.in	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+// using singly defined enum
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum {
+	x_factor = 1
+}
+

Added: trunk/tests/zcc.in/decl.C99/Pass_enum_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_enum_def.in	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc.in/decl.C99/Pass_enum_def.in	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+// using singly defined enum
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum good_test {
+	x_factor = 1
+}
+

Added: trunk/tests/zcc.in/decl.C99/Pass_struct_forward_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_struct_forward_def.in	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc.in/decl.C99/Pass_struct_forward_def.in	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,11 @@
+SUFFIXES h hpp
+// using singly defined struct
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+struct good_test;
+struct good_test;
+
+struct good_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc.in/decl.C99/Pass_union_forward_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_union_forward_def.in	2009-11-24 07:14:57 UTC (rev 277)
+++ trunk/tests/zcc.in/decl.C99/Pass_union_forward_def.in	2009-11-24 07:16:13 UTC (rev 278)
@@ -0,0 +1,11 @@
+SUFFIXES h hpp
+// using singly defined union
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+union good_test;
+union good_test;
+
+union good_test {
+	int x_factor;
+};
+



From zaimoni at mail.berlios.de  Wed Nov 25 05:40:53 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 25 Nov 2009 05:40:53 +0100
Subject: [Zcplusplus-commits] r279 - trunk
Message-ID: <200911250440.nAP4erPU023043@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-25 05:40:45 +0100 (Wed, 25 Nov 2009)
New Revision: 279

Modified:
   trunk/errors.hpp
   trunk/z_cpp.cpp
   trunk/zcc.cpp
Log:
new options for zcc: -Wc-c++-compat, -Wbackport

Modified: trunk/errors.hpp
===================================================================
--- trunk/errors.hpp	2009-11-24 07:16:13 UTC (rev 278)
+++ trunk/errors.hpp	2009-11-25 04:40:45 UTC (rev 279)
@@ -50,14 +50,22 @@
 #define boolean_option_8 char_is_unsigned
 #define boolean_option_char_is_unsigned 8
 #define DEFAULT_char_is_unsigned false
-	int_neg_div_rounds_away_from_zero
+	int_neg_div_rounds_away_from_zero,
 #define boolean_option_9 int_neg_div_rounds_away_from_zero
 #define boolean_option_int_neg_div_rounds_away_from_zero 9
 #define DEFAULT_int_neg_div_rounds_away_from_zero false
+	warn_crosslang_compatibility,
+#define boolean_option_10 warn_crosslang_compatibility
+#define boolean_option_warn_crosslang_compatibility 10
+#define DEFAULT_warn_crosslang_compatibility false
+	warn_backport
+#define boolean_option_11 warn_backport
+#define boolean_option_warn_backport 11
+#define DEFAULT_warn_backport false
 };
 
 #define boolean_option(A) boolean_option_##A
-#define MAX_OPT_BOOL (boolopt::int_neg_div_rounds_away_from_zero+1)
+#define MAX_OPT_BOOL (boolopt::warn_backport+1)
 
 }
 

Modified: trunk/z_cpp.cpp
===================================================================
--- trunk/z_cpp.cpp	2009-11-24 07:16:13 UTC (rev 278)
+++ trunk/z_cpp.cpp	2009-11-25 04:40:45 UTC (rev 279)
@@ -50,7 +50,9 @@
 			default_option(boolean_option(6)),
 			default_option(boolean_option(7)),
 			default_option(boolean_option(8)),
-			default_option(boolean_option(9))
+			default_option(boolean_option(9)),
+			default_option(boolean_option(10)),
+			default_option(boolean_option(11))
 		};
 
 // exposed in errors.hpp
@@ -63,7 +65,10 @@
 			default_option(boolean_option(5)),
 			default_option(boolean_option(6)),
 			default_option(boolean_option(7)),
-			default_option(boolean_option(8))
+			default_option(boolean_option(8)),
+			default_option(boolean_option(9)),
+			default_option(boolean_option(10)),
+			default_option(boolean_option(11))
 		};
 
 typedef bool string_opt_handler(const char* const);

Modified: trunk/zcc.cpp
===================================================================
--- trunk/zcc.cpp	2009-11-24 07:16:13 UTC (rev 278)
+++ trunk/zcc.cpp	2009-11-25 04:40:45 UTC (rev 279)
@@ -39,7 +39,9 @@
 		{ "--int-traps",	boolopt::int_traps, 	"signed int has a trap representation (-0 for sign-magnitude and one's complement, -(2^CHAR_BIT) for two's complement\n"},
 		{ "-fsigned-char",	boolopt::char_is_signed, 	"char acts like signed char\n"},		// GCC compatibility
 		{ "-funsigned-char",	boolopt::char_is_unsigned, 	"char acts like unsigned char (default)\n"},	// GCC compatibility
-		{ "--int-neg-div-rounds-away-from-zero",	boolopt::int_neg_div_rounds_away_from_zero, 	"make -3/-2==-2 contrary to C99 recommendation\n"}
+		{ "--int-neg-div-rounds-away-from-zero",	boolopt::int_neg_div_rounds_away_from_zero, 	"make -3/-2==-2 contrary to C99 recommendation\n"},
+		{ "-Wc-c++-compat",	boolopt::warn_crosslang_compatibility,	"Warn when something legal in C/C++ would be an error in C++/C for C/C++\n"},
+		{ "-Wbackport",	boolopt::warn_backport,	"Warn when something legal would be an error under an older standard\n"}
 	};
 
 const bool bool_options_default[MAX_OPT_BOOL]
@@ -52,7 +54,9 @@
 			default_option(boolean_option(6)),
 			default_option(boolean_option(7)),
 			default_option(boolean_option(8)),
-			default_option(boolean_option(9))
+			default_option(boolean_option(9)),
+			default_option(boolean_option(10)),
+			default_option(boolean_option(11))
 		};
 
 // exposed in errors.hpp
@@ -65,7 +69,10 @@
 			default_option(boolean_option(5)),
 			default_option(boolean_option(6)),
 			default_option(boolean_option(7)),
-			default_option(boolean_option(8))
+			default_option(boolean_option(8)),
+			default_option(boolean_option(9)),
+			default_option(boolean_option(10)),
+			default_option(boolean_option(11))
 		};
 
 typedef bool string_opt_handler(const char* const);



From zaimoni at mail.berlios.de  Wed Nov 25 07:52:51 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 25 Nov 2009 07:52:51 +0100
Subject: [Zcplusplus-commits] r280 - trunk
Message-ID: <200911250652.nAP6qpYV019177@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-25 07:52:47 +0100 (Wed, 25 Nov 2009)
New Revision: 280

Modified:
   trunk/ParseTree.hpp
Log:
parse_tree will need back().  Implement front(), back() and then use the preprocessor to compress the header.

Modified: trunk/ParseTree.hpp
===================================================================
--- trunk/ParseTree.hpp	2009-11-25 04:40:45 UTC (rev 279)
+++ trunk/ParseTree.hpp	2009-11-25 06:52:47 UTC (rev 280)
@@ -51,41 +51,35 @@
 
 	void MoveInto(parse_tree& dest);
 
+#ifdef ZAIMONI_FORCE_ISO
+#define	ZCC_PARSETREE_CARRAY(I) args[I].first
+#define	ZCC_PARSETREE_END(I) (args[I].first ? args[I].first+args[I].second : NULL)
+#define ZCC_PARSETREE_BACK(I) (*(args[I].first+args[I].second-1))
+#else
+#define	ZCC_PARSETREE_CARRAY(I) args[I]
+#define	ZCC_PARSETREE_END(I) (args[I] ? args[I]+zaimoni::ArraySize(args[I]) : NULL)
+#define ZCC_PARSETREE_BACK(I) (*(args[I]+zaimoni::ArraySize(args[I])-1))
+#endif
+
 	parse_tree* c_array(size_t arg_idx)
 		{
 		assert(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return args[arg_idx].first;
-#else
-		return args[arg_idx];
-#endif
+		return ZCC_PARSETREE_CARRAY(arg_idx);
 		};
 	template<size_t arg_idx> parse_tree* c_array()
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return args[arg_idx].first;
-#else
-		return args[arg_idx];
-#endif
+		return ZCC_PARSETREE_CARRAY(arg_idx);
 		}
 	const parse_tree* data(size_t arg_idx) const
 		{
 		assert(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return args[arg_idx].first;
-#else
-		return args[arg_idx];
-#endif
+		return ZCC_PARSETREE_CARRAY(arg_idx);
 		}
 	template<size_t arg_idx> const parse_tree* data() const
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return args[arg_idx].first;
-#else
-		return args[arg_idx];
-#endif
+		return ZCC_PARSETREE_CARRAY(arg_idx);
 		}
 	size_t size(size_t arg_idx) const
 		{
@@ -108,92 +102,100 @@
 	parse_tree* begin(size_t arg_idx)
 		{
 		assert(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return args[arg_idx].first;
-#else
-		return args[arg_idx];
-#endif
+		return ZCC_PARSETREE_CARRAY(arg_idx);
 		};
 	template<size_t arg_idx> parse_tree* begin()
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return args[arg_idx].first;
-#else
-		return args[arg_idx];
-#endif
+		return ZCC_PARSETREE_CARRAY(arg_idx);
 		}
 	const parse_tree* begin(size_t arg_idx) const
 		{
 		assert(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return args[arg_idx].first;
-#else
-		return args[arg_idx];
-#endif
+		return ZCC_PARSETREE_CARRAY(arg_idx);
 		}
 	template<size_t arg_idx> const parse_tree* begin() const
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return args[arg_idx].first;
-#else
-		return args[arg_idx];
-#endif
+		return ZCC_PARSETREE_CARRAY(arg_idx);
 		}
 	parse_tree* end(size_t arg_idx)
 		{
 		assert(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return (NULL==args[arg_idx].first) ? NULL : args[arg_idx].first+args[arg_idx].second;
-#else
-		return (NULL==args[arg_idx]) ? NULL : args[arg_idx]+zaimoni::ArraySize(args[arg_idx]);
-#endif
+		return ZCC_PARSETREE_END(arg_idx);
 		};
 	template<size_t arg_idx> parse_tree* end()
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return (NULL==args[arg_idx].first) ? NULL : args[arg_idx].first+args[arg_idx].second;
-#else
-		return (NULL==args[arg_idx]) ? NULL : args[arg_idx]+zaimoni::ArraySize(args[arg_idx]);
-#endif
+		return ZCC_PARSETREE_END(arg_idx);
 		}
 	const parse_tree* end(size_t arg_idx) const
 		{
 		assert(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return (NULL==args[arg_idx].first) ? NULL : args[arg_idx].first+args[arg_idx].second;
-#else
-		return (NULL==args[arg_idx]) ? NULL : args[arg_idx]+zaimoni::ArraySize(args[arg_idx]);
-#endif
+		return ZCC_PARSETREE_END(arg_idx);
 		}
 	template<size_t arg_idx> const parse_tree* end() const
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return (NULL==args[arg_idx].first) ? NULL : args[arg_idx].first+args[arg_idx].second;
-#else
-		return (NULL==args[arg_idx]) ? NULL : args[arg_idx]+zaimoni::ArraySize(args[arg_idx]);
-#endif
+		return ZCC_PARSETREE_END(arg_idx);
 		}
+	parse_tree& front(size_t arg_idx)
+		{
+		assert(STATIC_SIZE(args)>arg_idx);
+		assert(ZCC_PARSETREE_CARRAY(arg_idx));
+		return *ZCC_PARSETREE_CARRAY(arg_idx);
+		};
+	template<size_t arg_idx> parse_tree& front()
+		{
+		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
+		assert(ZCC_PARSETREE_CARRAY(arg_idx));
+		return *ZCC_PARSETREE_CARRAY(arg_idx);
+		}
+	const parse_tree& front(size_t arg_idx) const
+		{
+		assert(STATIC_SIZE(args)>arg_idx);
+		assert(ZCC_PARSETREE_CARRAY(arg_idx));
+		return *ZCC_PARSETREE_CARRAY(arg_idx);
+		}
+	template<size_t arg_idx> const parse_tree& front() const
+		{
+		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
+		assert(ZCC_PARSETREE_CARRAY(arg_idx));
+		return *ZCC_PARSETREE_CARRAY(arg_idx);
+		}
+	parse_tree& back(size_t arg_idx)
+		{
+		assert(STATIC_SIZE(args)>arg_idx);
+		assert(ZCC_PARSETREE_CARRAY(arg_idx));
+		return ZCC_PARSETREE_BACK(arg_idx);
+		};
+	template<size_t arg_idx> parse_tree& back()
+		{
+		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
+		assert(ZCC_PARSETREE_CARRAY(arg_idx));
+		return ZCC_PARSETREE_BACK(arg_idx);
+		}
+	const parse_tree& back(size_t arg_idx) const
+		{
+		assert(STATIC_SIZE(args)>arg_idx);
+		assert(ZCC_PARSETREE_CARRAY(arg_idx));
+		return ZCC_PARSETREE_BACK(arg_idx);
+		}
+	template<size_t arg_idx> const parse_tree& back() const
+		{
+		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
+		assert(ZCC_PARSETREE_CARRAY(arg_idx));
+		return ZCC_PARSETREE_BACK(arg_idx);
+		}
 	bool empty(size_t arg_idx) const
 		{
 		assert(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return NULL==args[arg_idx].first;
-#else
-		return NULL==args[arg_idx];
-#endif
+		return !ZCC_PARSETREE_CARRAY(arg_idx);
 		}
-	template<size_t arg_idx> size_t empty() const
+	template<size_t arg_idx> bool empty() const
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return NULL==args[arg_idx].first;
-#else
-		return NULL==args[arg_idx];
-#endif
+		return !ZCC_PARSETREE_CARRAY(arg_idx);
 		}
 	template<size_t i> bool own_index_token() const
 		{
@@ -223,13 +225,11 @@
 		assert(size<arg_idx>()-i>=n);
 		assert(0<n);
 		size_t idx = n;
+		do	ZCC_PARSETREE_CARRAY(arg_idx)[i+ --idx].destroy();
+		while(0<idx);
 #ifdef ZAIMONI_FORCE_ISO
-		do	args[arg_idx].first[i+ --idx].destroy();
-		while(0<idx);
 		zaimoni::_delete_n_slots_at(args[arg_idx].first,args[arg_idx].second,n,i);
 #else
-		do	args[arg_idx][i+ --idx].destroy();
-		while(0<idx);
 		zaimoni::_delete_n_slots_at(args[arg_idx],n,i);
 #endif
 		}
@@ -237,11 +237,10 @@
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
 		assert(size<arg_idx>()>i);
+		ZCC_PARSETREE_CARRAY(arg_idx)[i].destroy();
 #ifdef ZAIMONI_FORCE_ISO
-		args[arg_idx].first[i].destroy();
 		zaimoni::_delete_idx(args[arg_idx].first,args[arg_idx].second,i);
 #else
-		args[arg_idx][i].destroy();
 		zaimoni::_delete_idx(args[arg_idx],i);
 #endif
 		}
@@ -276,16 +275,17 @@
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>dest_idx);
 		assert(NULL!=src);
+		assert(NULL==ZCC_PARSETREE_CARRAY(dest_idx));
+		ZCC_PARSETREE_CARRAY(dest_idx) = src;
 #ifdef ZAIMONI_FORCE_ISO
-		assert(NULL==args[dest_idx].first);
-		args[dest_idx].first = src;
 		args[dest_idx].second = 1;
-#else
-		assert(NULL==args[dest_idx]);
-		args[dest_idx] = src;
 #endif
 		}
 
+#undef ZCC_PARSETREE_CARRAY
+#undef ZCC_PARSETREE_END
+#undef ZCC_PARSETREE_BACK
+
 	static bool collapse_matched_pair(parse_tree& src, const zaimoni::POD_pair<size_t,size_t>& target);
 	template<size_t dest_idx,size_t src_idx> void grab_index_token_location_from(const parse_tree& tmp)
 		{



From zaimoni at mail.berlios.de  Thu Nov 26 06:45:41 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 26 Nov 2009 06:45:41 +0100
Subject: [Zcplusplus-commits] r281 - in trunk: . tests/zcc
	tests/zcc/backport tests/zcc/compat tests/zcc/decl.C99
	tests/zcc.in tests/zcc.in/backport tests/zcc.in/decl.C99
Message-ID: <200911260545.nAQ5jf3x010582@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-26 06:44:44 +0100 (Thu, 26 Nov 2009)
New Revision: 281

Added:
   trunk/tests/zcc.in/backport/
   trunk/tests/zcc.in/backport/Warn_enum_trailing_comma.in
   trunk/tests/zcc.in/decl.C99/Error_enum_brace.in
   trunk/tests/zcc.in/decl.C99/Error_enum_init_truncated.in
   trunk/tests/zcc.in/decl.C99/Error_enum_keyword.in
   trunk/tests/zcc.in/decl.C99/Error_enum_no_init.in
   trunk/tests/zcc.in/decl.C99/Error_enum_symbol.in
   trunk/tests/zcc.in/decl.C99/Error_enum_type.in
   trunk/tests/zcc.in/decl.C99/Pass_enum_trailing_comma.in
   trunk/tests/zcc/backport/
   trunk/tests/zcc/backport/Warn_enum_trailing_comma.h
   trunk/tests/zcc/backport/Warn_enum_trailing_comma.hpp
   trunk/tests/zcc/compat/
   trunk/tests/zcc/compat/Warn_enum_empty.hpp
   trunk/tests/zcc/decl.C99/Error_enum_brace.h
   trunk/tests/zcc/decl.C99/Error_enum_brace.hpp
   trunk/tests/zcc/decl.C99/Error_enum_empty.h
   trunk/tests/zcc/decl.C99/Error_enum_init_truncated.h
   trunk/tests/zcc/decl.C99/Error_enum_init_truncated.hpp
   trunk/tests/zcc/decl.C99/Error_enum_keyword.h
   trunk/tests/zcc/decl.C99/Error_enum_keyword.hpp
   trunk/tests/zcc/decl.C99/Error_enum_no_init.h
   trunk/tests/zcc/decl.C99/Error_enum_no_init.hpp
   trunk/tests/zcc/decl.C99/Error_enum_symbol.h
   trunk/tests/zcc/decl.C99/Error_enum_symbol.hpp
   trunk/tests/zcc/decl.C99/Error_enum_type.h
   trunk/tests/zcc/decl.C99/Error_enum_type.hpp
   trunk/tests/zcc/decl.C99/Pass_enum_empty.hpp
   trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.h
   trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.hpp
Modified:
   trunk/CSupport.cpp
   trunk/tests/zcc.in/run_tests.in
   trunk/tests/zcc/run_tests.bat
   trunk/tests/zcc/run_tests.sh
Log:
check errors in enumeration definitions that do not require evaluating expressions

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/CSupport.cpp	2009-11-26 05:44:44 UTC (rev 281)
@@ -10549,6 +10549,118 @@
 	src.DeleteNSlotsAt<0>(j-i+1,i);
 }
 
+static bool record_enum_values(parse_tree& src, type_system& types, const char* const enum_name, const char* const active_namespace,bool allow_empty,func_traits<const char* (*)(const char*, size_t)>::function_ref_type echo_reserved_keyword)
+{
+	assert(!enum_name || *enum_name);
+	assert(!active_namespace || *active_namespace);
+	assert(is_naked_brace_pair(src));
+	// enumeration idea:
+	// * identifer [= ...] ,
+	// terminal , is optional (and in fact should trigger a warning for -Wbackport)
+	// empty collection of enumerators is fine for C++, rejected by C (should be error in C and -Wc-c++-compat for C++)
+	// values would be unsigned_fixed_int<VM_MAX_BIT_PLATFORM>
+	if (src.empty<0>())
+		{
+		if (!allow_empty)
+			{	//! \test zcc/decl.C99/Error_enum_empty.h
+			message_header(src.index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM("enumeration has no enumerators (C99 6.7.2.2p1)");
+			zcc_errors.inc_error();
+			return false;
+			}
+		else if (bool_options[boolopt::warn_crosslang_compatibility])
+			{	//! \test zcc/compat/Warn_enum_empty.hpp
+			message_header(src.index_tokens[0]);
+			INC_INFORM(WARN_STR);
+			INFORM("enumeration with no enumerators is an error in C90/C99/C1X");
+			if (bool_options[boolopt::warnings_are_errors])
+				{
+				zcc_errors.inc_error();
+				return false;
+				}
+			}
+		//! \test zcc/decl.C99/Pass_enum_empty.hpp
+		return true;
+		};
+	// determine if format generally there
+	// stage 1: top-level comma check
+	// * terminal comma is optional, zap it and warn if -Wbackport
+	// * one more enumerator possible than surviving commas; use this to construct buffers
+	size_t i = 0;
+	while(src.size<0>()>i)
+		{	// require identifier that is neither keyword nor a primitive type
+			// C++ will have problems with enum/struct/class/union names, verify status of both of these (could be -Wc-c++-compat issue if legal in C)
+			// if identifier, verify next is = or ,
+			// if next is =, locate comma afterwards (do not do expression parsing yet)
+			//! \todo: enforce One Definition Rule for C++ vs types; determine how much of the effect is in C as well
+		if (   !src.data<0>()[i].is_atomic()
+			||  C_TESTFLAG_IDENTIFIER!=src.data<0>()[i].index_tokens[0].flags
+			|| (PARSE_TYPE & src.data<0>()[i].flags)
+			|| echo_reserved_keyword(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].token.second))
+			{	//! \test zcc/decl.C99/Error_enum_brace.h, zcc/decl.C99/Error_enum_brace.hpp
+				//! \test zcc/decl.C99/Error_enum_symbol.h, zcc/decl.C99/Error_enum_symbol.hpp
+				//! \test zcc/decl.C99/Error_enum_type.h, zcc/decl.C99/Error_enum_type.hpp
+				//! \test zcc/decl.C99/Error_enum_keyword.h, zcc/decl.C99/Error_enum_keyword.hpp
+			message_header(0==i ? src.index_tokens[0] : src.data<0>()[i-i].index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM("non-keyword identifier expected as enumerator (C99 6.4.4.3p1/C++0X 7.2p1)");
+			zcc_errors.inc_error();
+			return false;
+			}
+		if (1>=src.size<0>()-i) break;	// fine, would default-update
+		if (robust_token_is_char<','>(src.data<0>()[i+1]))
+			{	// would default-update
+			i += 2;
+			continue;
+			};
+		if (!robust_token_is_char<'='>(src.data<0>()[i+1]))
+			{	//! \test zcc/decl.C99/Error_enum_no_init.h, zcc/decl.C99/Error_enum_no_init.hpp
+			message_header(src.data<0>()[i].index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM("enumerator neither explicitly initialized nor default-initialized (C99 6.4.4.3p1/C++0X 7.2p1)");
+			zcc_errors.inc_error();
+			return false;
+			};
+		i += 2;
+		if (src.size<0>()<=i || robust_token_is_char<','>(src.data<0>()[i]))
+			{	//! \test zcc/decl.C99/Error_enum_init_truncated.h, zcc/decl.C99/Error_enum_init_truncated.hpp
+			message_header(src.data<0>()[i].index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM("enumerator initializer cut off by , (C99 6.4.4.3p1/C++0X 7.2p1)");
+			zcc_errors.inc_error();
+			return false;
+			};
+		while(++i < src.size<0>())
+			{
+			if (robust_token_is_char<','>(src.data<0>()[i]))
+				{
+				++i;
+				break;
+				}
+			};
+		}
+	if (robust_token_is_char<','>(src.back<0>()))
+		{	// warn for -Wbackport
+			//! \test zcc/decl.C99/Pass_enum_trailing_comma.h, zcc/decl.C99/Pass_enum_trailing_comma.hpp
+			//! \test zcc/backport/Warn_enum_trailing_comma.h, zcc/backport/Warn_enum_trailing_comma.hpp
+		if (bool_options[boolopt::warn_backport])
+			{
+			message_header(src.back<0>().index_tokens[0]);
+			INC_INFORM(WARN_STR);
+			INFORM("trailing , in enumeration definition would be an error in C90/C++98");
+			if (bool_options[boolopt::warnings_are_errors])
+				{
+				zcc_errors.inc_error();
+				return false;
+				}
+			}
+		src.DeleteIdx<0>(src.size<0>()-1); // clean up anyway
+		}
+	//! \todo actually record enumerator matchings
+	return true;
+}
+
 // will need: "function-type vector"
 // return: 1 typespec record (for now, other languages may have more demanding requirements)
 // incoming: n typespec records, flag for trailing ...
@@ -10660,15 +10772,24 @@
 			// enum-specifier doesn't have a specific declaration mode
 			//! \test zcc\decl.C99\Pass_enum_def.h
 			enum_def* tmp = new enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			//! \todo record enum values
 			types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,tmp);
+			assert(types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first));
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,false,C99_echo_reserved_keyword))
+				{
+				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+				return;
+				}
 			}
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 			enum_def* tmp = new enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			//! \todo record enum values
 			types.register_enum_def("<unknown>",tmp);
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,NULL,NULL,false,C99_echo_reserved_keyword))
+				{
+				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+				return;
+				}
 			}
 
 		if (	1<src.size<0>()-i
@@ -11138,15 +11259,23 @@
 				//! \test zcc\decl.C99\Pass_enum_def.hpp
 				// enum-specifier doesn't have a specific declaration mode
 				enum_def* tmp = new enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-				//! \todo record enum values
 				types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,tmp);
+				if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
+					{
+					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+					return;
+					}
 				}
 			else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 				enum_def* tmp = new enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-				//! \todo record enum values
 				types.register_enum_def("<unknown>",tmp);
+				if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
+					{
+					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+					return;
+					}
 				}
 
 			if (	1<src.size<0>()-i

Added: trunk/tests/zcc/backport/Warn_enum_trailing_comma.h
===================================================================
--- trunk/tests/zcc/backport/Warn_enum_trailing_comma.h	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/backport/Warn_enum_trailing_comma.h	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+// backport\Warn_enum_trailing_comma.h
+// trailing comma would fail in C89/C++98
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum weird_test {
+	x_factor = 1,
+}
+

Added: trunk/tests/zcc/backport/Warn_enum_trailing_comma.hpp
===================================================================
--- trunk/tests/zcc/backport/Warn_enum_trailing_comma.hpp	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/backport/Warn_enum_trailing_comma.hpp	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+// backport\Warn_enum_trailing_comma.hpp
+// trailing comma would fail in C89/C++98
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum weird_test {
+	x_factor = 1,
+}
+

Added: trunk/tests/zcc/compat/Warn_enum_empty.hpp
===================================================================
--- trunk/tests/zcc/compat/Warn_enum_empty.hpp	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/compat/Warn_enum_empty.hpp	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,6 @@
+// decl.C99\Pass_enum_empty.hpp
+// no-enumerator enum fails in C, not in C++; warn with -Wc-c++-compat
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum good_test {
+}

Added: trunk/tests/zcc/decl.C99/Error_enum_brace.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_brace.h	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Error_enum_brace.h	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+// decl.C99\Error_enum_brace.h
+// ZCC-specific check that non-atomic internal representation fails
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	{} = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Error_enum_brace.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_brace.hpp	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Error_enum_brace.hpp	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+// decl.C99\Error_enum_brace.hpp
+// ZCC-specific check that non-atomic internal representation fails
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	{} = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Error_enum_empty.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_empty.h	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Error_enum_empty.h	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,6 @@
+// decl.C99\Error_enum_empty.h
+// no-enumerator enum fails in C, not in C++
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+}

Added: trunk/tests/zcc/decl.C99/Error_enum_init_truncated.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_init_truncated.h	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Error_enum_init_truncated.h	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,9 @@
+// decl.C99\Error_enum_init_truncated.h
+// comma-truncated initializer
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = ,
+	x_factor2 = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Error_enum_init_truncated.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_init_truncated.hpp	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Error_enum_init_truncated.hpp	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,9 @@
+// decl.C99\Error_enum_init_truncated.hpp
+// comma-truncated initializer
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = ,
+	x_factor2 = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Error_enum_keyword.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_keyword.h	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Error_enum_keyword.h	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+// decl.C99\Error_enum_keyword.h
+// keyword as enumerator fails
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	return = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Error_enum_keyword.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_keyword.hpp	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Error_enum_keyword.hpp	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+// decl.C99\Error_enum_keyword.hpp
+// keyword as enumerator fails
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	return = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Error_enum_no_init.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_no_init.h	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Error_enum_no_init.h	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+// decl.C99\Error_enum_no_init.h
+// enum without initializer of any kind
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor &
+}
+

Added: trunk/tests/zcc/decl.C99/Error_enum_no_init.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_no_init.hpp	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Error_enum_no_init.hpp	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+// decl.C99\Error_enum_no_init.hpp
+// enum without initializer of any kind
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor &
+}
+

Added: trunk/tests/zcc/decl.C99/Error_enum_symbol.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_symbol.h	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Error_enum_symbol.h	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+// decl.C99\Error_enum_symbol.h
+// preprocessing punctuation as enumerator fails
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	& = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Error_enum_symbol.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_symbol.hpp	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Error_enum_symbol.hpp	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+// decl.C99\Error_enum_symbol.hpp
+// preprocessing punctuation as enumerator fails
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	& = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Error_enum_type.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_type.h	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Error_enum_type.h	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+// decl.C99\Error_enum_type.h
+// primitive type as enumerator fails
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	unsigned int = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Error_enum_type.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_type.hpp	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Error_enum_type.hpp	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+// decl.C99\Error_enum_type.hpp
+// primitive type as enumerator fails
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	unsigned int = 1
+}
+

Added: trunk/tests/zcc/decl.C99/Pass_enum_empty.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_empty.hpp	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Pass_enum_empty.hpp	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,6 @@
+// decl.C99\Pass_enum_empty.hpp
+// no-enumerator enum fails in C, not in C++
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum good_test {
+}

Added: trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.h	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.h	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+// decl.C99\Pass_enum_trailing_comma.h
+// trailing comma would fail in C89/C++98
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum weird_test {
+	x_factor = 1,
+}
+

Added: trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.hpp	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/decl.C99/Pass_enum_trailing_comma.hpp	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+// decl.C99\Pass_enum_trailing_comma.hpp
+// trailing comma would fail in C89/C++98
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum weird_test {
+	x_factor = 1,
+}
+

Modified: trunk/tests/zcc/run_tests.bat
===================================================================
--- trunk/tests/zcc/run_tests.bat	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/run_tests.bat	2009-11-26 05:44:44 UTC (rev 281)
@@ -11,6 +11,8 @@
 @set ACCEPT_TEST=0
 @set CPP=..\..\zcc
 @set CPP_ISO=..\..\zcc --pedantic
+ at set CPP_BACKPORT=..\..\zcc -Wbackport
+ at set CPP_COMPAT=..\..\zcc -Wc-c++-compat
 
 @echo Checking ISO error requirements
 @echo ====
@@ -27,6 +29,15 @@
 
 @echo Checking ZCC warnings on ISO-accepted code
 @echo ====
+ at for %%f in (backport\Warn*.h) do @echo %CPP_BACKPORT% -Werror %%f & @%CPP_BACKPORT% -Werror %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (backport\Warn*.h) do @echo %CPP_BACKPORT% %%f & @%CPP_BACKPORT% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (backport\Warn*.h) do @(set /a ACCEPT_TEST=ACCEPT_TEST+1 & set /a REJECT_TEST=REJECT_TEST+1)
+ at for %%f in (backport\Warn*.hpp) do @echo %CPP_BACKPORT% -Werror %%f & @%CPP_BACKPORT% -Werror %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (backport\Warn*.hpp) do @echo %CPP_BACKPORT% %%f & @%CPP_BACKPORT% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (backport\Warn*.hpp) do @(set /a ACCEPT_TEST=ACCEPT_TEST+1 & set /a REJECT_TEST=REJECT_TEST+1)
+ at for %%f in (compat\Warn*.hpp) do @echo %CPP_COMPAT% -Werror %%f & @%CPP_COMPAT% -Werror %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (compat\Warn*.hpp) do @echo %CPP_COMPAT% %%f & @%CPP_COMPAT% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (compat\Warn*.hpp) do @(set /a ACCEPT_TEST=ACCEPT_TEST+1 & set /a REJECT_TEST=REJECT_TEST+1)
 @for %%f in (decl.C99\Warn*.h) do @echo %CPP_ISO% -Werror %%f & @%CPP_ISO% -Werror %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
 @for %%f in (decl.C99\Warn*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
 @for %%f in (decl.C99\Warn*.h) do @(set /a ACCEPT_TEST=ACCEPT_TEST+1 & set /a REJECT_TEST=REJECT_TEST+1)

Modified: trunk/tests/zcc/run_tests.sh
===================================================================
--- trunk/tests/zcc/run_tests.sh	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc/run_tests.sh	2009-11-26 05:44:44 UTC (rev 281)
@@ -18,6 +18,8 @@
 	local ACCEPT_TEST=0
 	local CPP=../../zcc
 	local CPP_ISO="../../zcc --pedantic"
+	local CPP_BACKPORT="../../zcc -Wbackport"
+	local CPP_COMPAT="../../zcc -Wc-c++-compat"
 
 	echo Checking ISO error requirements
 	echo ====
@@ -29,6 +31,12 @@
 
 	echo Checking ZCC warnings on ISO-accepted code
 	echo ====
+	for F in backport/Warn*.h; do let ++REJECT_TEST; echo $CPP_BACKPORT -Werror $F; if $CPP_BACKPORT -Werror $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in backport/Warn*.h; do let ++ACCEPT_TEST; echo $CPP_BACKPORT $F; if $CPP_BACKPORT $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in backport/Warn*.hpp; do let ++REJECT_TEST; echo $CPP_BACKPORT -Werror $F; if $CPP_BACKPORT -Werror $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in backport/Warn*.hpp; do let ++ACCEPT_TEST; echo $CPP_BACKPORT $F; if $CPP_BACKPORT $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in compat/Warn*.hpp; do let ++REJECT_TEST; echo $CPP_COMPAT -Werror $F; if $CPP_COMPAT -Werror $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in compat/Warn*.hpp; do let ++ACCEPT_TEST; echo $CPP_COMPAT $F; if $CPP_COMPAT $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 	for F in decl.C99/Warn*.h; do let ++REJECT_TEST; echo $CPP_ISO -Werror $F; if $CPP_ISO -Werror $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
 	for F in decl.C99/Warn*.h; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 	for F in decl.C99/Warn*.hpp; do let ++REJECT_TEST; echo $CPP_ISO -Werror $F; if $CPP_ISO -Werror $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;

Added: trunk/tests/zcc.in/backport/Warn_enum_trailing_comma.in
===================================================================
--- trunk/tests/zcc.in/backport/Warn_enum_trailing_comma.in	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc.in/backport/Warn_enum_trailing_comma.in	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+// trailing comma would fail in C89/C++98
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum weird_test {
+	x_factor = 1,
+}
+

Added: trunk/tests/zcc.in/decl.C99/Error_enum_brace.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_brace.in	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_brace.in	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+// ZCC-specific check that non-atomic internal representation fails
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	{} = 1
+}
+

Added: trunk/tests/zcc.in/decl.C99/Error_enum_init_truncated.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_init_truncated.in	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_init_truncated.in	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,9 @@
+SUFFIXES h hpp
+// comma-truncated initializer
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = ,
+	x_factor2 = 1
+}
+

Added: trunk/tests/zcc.in/decl.C99/Error_enum_keyword.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_keyword.in	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_keyword.in	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+// keyword as enumerator fails
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	return = 1
+}
+

Added: trunk/tests/zcc.in/decl.C99/Error_enum_no_init.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_no_init.in	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_no_init.in	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+// enum without initializer of any kind
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor &
+}
+

Added: trunk/tests/zcc.in/decl.C99/Error_enum_symbol.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_symbol.in	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_symbol.in	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+// preprocessing punctuation as enumerator fails
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	& = 1
+}
+

Added: trunk/tests/zcc.in/decl.C99/Error_enum_type.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_type.in	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_type.in	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+// primitive type as enumerator fails
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	unsigned int = 1
+}
+

Added: trunk/tests/zcc.in/decl.C99/Pass_enum_trailing_comma.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_enum_trailing_comma.in	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc.in/decl.C99/Pass_enum_trailing_comma.in	2009-11-26 05:44:44 UTC (rev 281)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+// trailing comma would fail in C89/C++98
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum weird_test {
+	x_factor = 1,
+}
+

Modified: trunk/tests/zcc.in/run_tests.in
===================================================================
--- trunk/tests/zcc.in/run_tests.in	2009-11-25 06:52:47 UTC (rev 280)
+++ trunk/tests/zcc.in/run_tests.in	2009-11-26 05:44:44 UTC (rev 281)
@@ -5,6 +5,8 @@
 PROLOG
 VAR CPP ../../zcc
 VAR CPP_ISO ../../zcc --pedantic
+VAR CPP_BACKPORT ../../zcc -Wbackport
+VAR CPP_COMPAT ../../zcc -Wc-c++-compat
 
 ECHO Checking ISO error requirements
 ERROR CPP_ISO decl.C99/Error*
@@ -12,6 +14,8 @@
 ERROR CPP_ISO staticassert.C1X/Error*
 
 ECHO Checking ZCC warnings on ISO-accepted code
+WARN CPP_BACKPORT backport/Warn*
+WARN CPP_COMPAT compat/Warn*
 WARN CPP_ISO decl.C99/Warn*
 WARN CPP_ISO namespace.CPP/Warn*
 



From zaimoni at mail.berlios.de  Thu Nov 26 21:46:59 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 26 Nov 2009 21:46:59 +0100
Subject: [Zcplusplus-commits] r282 - trunk
Message-ID: <200911262046.nAQKkxPU000634@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-26 21:46:53 +0100 (Thu, 26 Nov 2009)
New Revision: 282

Modified:
   trunk/CPreproc.cpp
   trunk/MakeMake.cfg
   trunk/POSIX.dep
   trunk/errors.hpp
   trunk/z_cpp.cpp
   trunk/zcc.cpp
Log:
centralize error and option code

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2009-11-26 05:44:44 UTC (rev 281)
+++ trunk/CPreproc.cpp	2009-11-26 20:46:53 UTC (rev 282)
@@ -24,6 +24,7 @@
 #include "Zaimoni.STL/LexParse/Token.hpp"
 #include "Zaimoni.STL/LexParse/LangConf.hpp"
 #include "Zaimoni.STL/search.hpp"
+#include "Zaimoni.STL/OS/mutex.hpp"
 #include "Zaimoni.STL/Pure.C/format_util.h"
 
 #include "DebugCSupport.h"

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2009-11-26 05:44:44 UTC (rev 281)
+++ trunk/MakeMake.cfg	2009-11-26 20:46:53 UTC (rev 282)
@@ -1,6 +1,6 @@
 ########
-ProgObjects = {	'z_cpp':('z_cpp','langroute','AtomicString','filesystem','CPUInfo','enum_type','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
-				'zcc':('zcc','langroute','AtomicString','filesystem','CPUInfo','enum_type','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
+ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','filesystem','CPUInfo','enum_type','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
+				'zcc':('zcc','errors','langroute','AtomicString','filesystem','CPUInfo','enum_type','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
 MainPrograms = ['z_cpp','zcc']
 
 # process control

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2009-11-26 05:44:44 UTC (rev 281)
+++ trunk/POSIX.dep	2009-11-26 20:46:53 UTC (rev 282)
@@ -1,11 +1,12 @@
-OBJECTS_Z_CPP = z_cpp.o langroute.o AtomicString.o filesystem.o CPUInfo.o enum_type.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
-OBJECTS_Z_CPP_LINK_PRIORITY = enum_type.o CSupport.o type_system.o struct_type.o ParseTree.o type_spec.o CPreproc.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o z_cpp.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o filesystem.o CPUInfo.o enum_type.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
+OBJECTS_Z_CPP_LINK_PRIORITY = z_cpp.o errors.o CPreproc.o CSupport.o enum_type.o type_system.o struct_type.o ParseTree.o type_spec.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
-OBJECTS_ZCC = zcc.o langroute.o AtomicString.o filesystem.o CPUInfo.o enum_type.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = enum_type.o CSupport.o type_system.o struct_type.o ParseTree.o type_spec.o ZParser.o CPreproc.o zcc.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o filesystem.o CPUInfo.o enum_type.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
+OBJECTS_ZCC_LINK_PRIORITY = zcc.o errors.o CPreproc.o CSupport.o enum_type.o type_system.o struct_type.o ParseTree.o type_spec.o ZParser.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
 # dependencies
-z_cpp.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/OS/mutex.hpp unsigned_fixed_int.hpp unsigned_aux.hpp
+z_cpp.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_aux.hpp
+errors.o: errors.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 langroute.o: langroute.hpp CSupport.hpp Zaimoni.STL/Logging.h Zaimoni.STL/POD.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp
 AtomicString.o: AtomicString.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 filesystem.o: filesystem.h Zaimoni.STL/Compiler.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h
@@ -15,7 +16,7 @@
 type_system.o: type_system.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport.o: CSupport.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/OS/mutex.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport.o: CSupport.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -25,8 +26,8 @@
 unsigned_aux.o: unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 Trigraph.o: Trigraph.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 Flat_UNI.o: Flat_UNI.hpp CSupport.hpp Zaimoni.STL/MetaRAM2.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
-load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/OS/mutex.hpp
-CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/OS/mutex.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
-CPreproc_autogen.o: CPreproc.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
-zcc.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/OS/mutex.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
-ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
+CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+CPreproc_autogen.o: CPreproc.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
+zcc.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
+ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp

Modified: trunk/errors.hpp
===================================================================
--- trunk/errors.hpp	2009-11-26 05:44:44 UTC (rev 281)
+++ trunk/errors.hpp	2009-11-26 20:46:53 UTC (rev 282)
@@ -4,8 +4,16 @@
 #ifndef ERRORS_HPP
 #define ERRORS_HPP 1
 
-#include "Zaimoni.STL/OS/mutex.hpp"
+#include <stddef.h>
+//#include "Zaimoni.STL/OS/mutex.hpp"
+namespace zaimoni {
+namespace OS {
+	class mutex;
+}
 
+template<class T1, class T2, class T3> struct POD_triple;
+}
+
 #define default_option2(A) DEFAULT_##A
 #define default_option(A) default_option2(A)
 #define default_handler2(A) HANDLER_##A
@@ -104,6 +112,8 @@
 
 }
 
+// declare globals of interest
+extern const bool bool_options_default[MAX_OPT_BOOL];
 extern bool bool_options[MAX_OPT_BOOL];
 extern const char* string_options[MAX_OPT_STRING];
 extern int int_options[MAX_OPT_INT];
@@ -114,4 +124,7 @@
 extern bool debug_tracer;
 #endif
 
+int recognize_bool_option(const char* const x,const zaimoni::POD_triple<const char*, size_t, const char*>* option_map,size_t j);
+int recognize_parameter_option(const char* const x,const zaimoni::POD_triple<const char*, size_t, const char*>* option_map,size_t j);
+
 #endif

Modified: trunk/z_cpp.cpp
===================================================================
--- trunk/z_cpp.cpp	2009-11-26 05:44:44 UTC (rev 281)
+++ trunk/z_cpp.cpp	2009-11-26 20:46:53 UTC (rev 282)
@@ -19,14 +19,8 @@
 
 error_counter<size_t> zcc_errors(100,"FATAL: too many preprocessing errors");
 
-#ifndef NDEBUG
-bool debug_tracer = false;
-#endif
-
 using namespace zaimoni;
 
-zaimoni::OS::mutex errno_mutex;
-
 static const POD_triple<const char*, size_t, const char*> option_map_bool[]
 =	{	{ "--test",		boolopt::test, 					"final internal state to stderr\n"},
 		{ "-Werror",	boolopt::warnings_are_errors, 	"all warnings are now errors\n"},						// GCC compatibility, need for POSIX testing standards
@@ -40,37 +34,6 @@
 		{ "--int-neg-div-rounds-away-from-zero",	boolopt::int_neg_div_rounds_away_from_zero, 	"make -3/-2==-2 contrary to C99 recommendation\n"}
 	};
 
-const bool bool_options_default[MAX_OPT_BOOL]
-	= 	{	default_option(boolean_option(0)),
-			default_option(boolean_option(1)),
-			default_option(boolean_option(2)),
-			default_option(boolean_option(3)),
-			default_option(boolean_option(4)),
-			default_option(boolean_option(5)),
-			default_option(boolean_option(6)),
-			default_option(boolean_option(7)),
-			default_option(boolean_option(8)),
-			default_option(boolean_option(9)),
-			default_option(boolean_option(10)),
-			default_option(boolean_option(11))
-		};
-
-// exposed in errors.hpp
-bool bool_options[MAX_OPT_BOOL]
-	= 	{	default_option(boolean_option(0)),
-			default_option(boolean_option(1)),
-			default_option(boolean_option(2)),
-			default_option(boolean_option(3)),
-			default_option(boolean_option(4)),
-			default_option(boolean_option(5)),
-			default_option(boolean_option(6)),
-			default_option(boolean_option(7)),
-			default_option(boolean_option(8)),
-			default_option(boolean_option(9)),
-			default_option(boolean_option(10)),
-			default_option(boolean_option(11))
-		};
-
 typedef bool string_opt_handler(const char* const);
 
 static const POD_triple<const char*, size_t, const char*> option_map_string[]
@@ -78,54 +41,10 @@
 			{ "--system-include",	stringopt::system_include, "unpreprocessed #include<...> to stdout\n"}
 		};
 
-// exposed in errors.hpp
-const char* string_options[MAX_OPT_STRING]
-	= 	{	default_option(string_option(0)),
-			default_option(string_option(1))
-		};
-
-
 static const POD_triple<const char*, size_t, const char*> option_map_int[]
 =	{	{ "-fmax-errors",		intopt::error_ub, 					"how many errors are too many (default 100)\n"}	// GFortran compatibility
 	};
 
-// exposed in errors.hpp
-int int_options[MAX_OPT_INT]
-	= {default_option(int_option(0))};
-
-static int recognize_bool_opt(const char* const x)
-{
-	if (zaimoni::is_empty_string(x)) return -1;
-	size_t j = STATIC_SIZE(option_map_bool);
-	do if (!strcmp(option_map_bool[--j].first,x)) return j;
-	while(0<j);
-	return -1;
-}
-
-static int recognize_string_opt(const char* const x)
-{
-	if (zaimoni::is_empty_string(x)) return -1;
-	size_t j = STATIC_SIZE(option_map_string);
-	do	{
-		--j;
-		if (!strncmp(option_map_string[j].first,x,strlen(option_map_string[j].first))) return j;
-		}
-	while(0<j);
-	return -1;
-}
-
-static int recognize_int_opt(const char* const x)
-{
-	if (zaimoni::is_empty_string(x)) return -1;
-	size_t j = STATIC_SIZE(option_map_int);
-	do	{
-		--j;
-		if (!strncmp(option_map_int[j].first,x,strlen(option_map_int[j].first))) return j;
-		}
-	while(0<j);
-	return -1;
-}
-
 /*! 
  * If the given string is recognized as a language, set stringopt::lang.
  * Otherwise, be ACID and don't update anything.
@@ -136,7 +55,7 @@
  * 
  * \return true iff language was accepted
  */
-bool interpret_stringopt_lang(const char* x)
+static bool interpret_stringopt_lang(const char* x)
 {
 	const char* test = echo_valid_lang(x);
 	if (NULL==test) return false;
@@ -216,7 +135,7 @@
 	size_t i = 0;
 	while(argc > ++i)
 		{
-		int index = recognize_bool_opt(argv[i]);
+		int index = recognize_bool_option(argv[i],option_map_bool,STATIC_SIZE(option_map_bool));
 		if (0<=index)
 			{	// handle directly
 			assert(STATIC_SIZE(option_map_bool)>(size_t)index);
@@ -226,7 +145,7 @@
 			last_arg_used_in_option = i;
 			continue;
 			}
-		index = recognize_string_opt(argv[i]);
+		index = recognize_parameter_option(argv[i],option_map_string,STATIC_SIZE(option_map_string));
 		if (0<=index)
 			{	// several flavors of string options; use language override as an example
 				// -x C++
@@ -250,7 +169,7 @@
 			INFORM(option_map_string[index].first);
 			continue;
 			}
-		index = recognize_int_opt(argv[i]);
+		index = recognize_parameter_option(argv[i],option_map_int,STATIC_SIZE(option_map_int));
 		if (0<=index)
 			{
 			assert(STATIC_SIZE(option_map_int)>(size_t)index);

Modified: trunk/zcc.cpp
===================================================================
--- trunk/zcc.cpp	2009-11-26 05:44:44 UTC (rev 281)
+++ trunk/zcc.cpp	2009-11-26 20:46:53 UTC (rev 282)
@@ -21,14 +21,8 @@
 
 error_counter<size_t> zcc_errors(100,"FATAL: too many errors");
 
-#ifndef NDEBUG
-bool debug_tracer = false;
-#endif
-
 using namespace zaimoni;
 
-zaimoni::OS::mutex errno_mutex;
-
 static const POD_triple<const char*, size_t, const char*> option_map_bool[]
 =	{	{ "--test",		boolopt::test, 					"final internal state to stderr\n"},
 		{ "-Werror",	boolopt::warnings_are_errors, 	"all warnings are now errors\n"},						// GCC compatibility, need for POSIX testing standards
@@ -44,37 +38,6 @@
 		{ "-Wbackport",	boolopt::warn_backport,	"Warn when something legal would be an error under an older standard\n"}
 	};
 
-const bool bool_options_default[MAX_OPT_BOOL]
-	= 	{	default_option(boolean_option(0)),
-			default_option(boolean_option(1)),
-			default_option(boolean_option(2)),
-			default_option(boolean_option(3)),
-			default_option(boolean_option(4)),
-			default_option(boolean_option(5)),
-			default_option(boolean_option(6)),
-			default_option(boolean_option(7)),
-			default_option(boolean_option(8)),
-			default_option(boolean_option(9)),
-			default_option(boolean_option(10)),
-			default_option(boolean_option(11))
-		};
-
-// exposed in errors.hpp
-bool bool_options[MAX_OPT_BOOL]
-	= 	{	default_option(boolean_option(0)),
-			default_option(boolean_option(1)),
-			default_option(boolean_option(2)),
-			default_option(boolean_option(3)),
-			default_option(boolean_option(4)),
-			default_option(boolean_option(5)),
-			default_option(boolean_option(6)),
-			default_option(boolean_option(7)),
-			default_option(boolean_option(8)),
-			default_option(boolean_option(9)),
-			default_option(boolean_option(10)),
-			default_option(boolean_option(11))
-		};
-
 typedef bool string_opt_handler(const char* const);
 
 static const POD_triple<const char*, size_t, const char*> option_map_string[]
@@ -82,54 +45,10 @@
 			{ "--system-include",	stringopt::system_include, "unpreprocessed #include<...> to stdout\n"}
 		};
 
-// exposed in errors.hpp
-const char* string_options[MAX_OPT_STRING]
-	= 	{	default_option(string_option(0)),
-			default_option(string_option(1))
-		};
-
-
 static const POD_triple<const char*, size_t, const char*> option_map_int[]
 =	{	{ "-fmax-errors",		intopt::error_ub, 					"how many errors are too many (default 100)\n"}	// GFortran compatibility
 	};
 
-// exposed in errors.hpp
-int int_options[MAX_OPT_INT]
-	= {default_option(int_option(0))};
-
-static int recognize_bool_opt(const char* const x)
-{
-	if (zaimoni::is_empty_string(x)) return -1;
-	size_t j = STATIC_SIZE(option_map_bool);
-	do if (!strcmp(option_map_bool[--j].first,x)) return j;
-	while(0<j);
-	return -1;
-}
-
-static int recognize_string_opt(const char* const x)
-{
-	if (zaimoni::is_empty_string(x)) return -1;
-	size_t j = STATIC_SIZE(option_map_string);
-	do	{
-		--j;
-		if (!strncmp(option_map_string[j].first,x,strlen(option_map_string[j].first))) return j;
-		}
-	while(0<j);
-	return -1;
-}
-
-static int recognize_int_opt(const char* const x)
-{
-	if (zaimoni::is_empty_string(x)) return -1;
-	size_t j = STATIC_SIZE(option_map_int);
-	do	{
-		--j;
-		if (!strncmp(option_map_int[j].first,x,strlen(option_map_int[j].first))) return j;
-		}
-	while(0<j);
-	return -1;
-}
-
 /*! 
  * If the given string is recognized as a language, set stringopt::lang.
  * Otherwise, be ACID and don't update anything.
@@ -140,7 +59,7 @@
  * 
  * \return true iff language was accepted
  */
-bool interpret_stringopt_lang(const char* x)
+static bool interpret_stringopt_lang(const char* x)
 {
 	const char* test = echo_valid_lang(x);
 	if (NULL==test) return false;
@@ -220,7 +139,7 @@
 	size_t i = 0;
 	while(argc > ++i)
 		{
-		int index = recognize_bool_opt(argv[i]);
+		int index = recognize_bool_option(argv[i],option_map_bool,STATIC_SIZE(option_map_bool));
 		if (0<=index)
 			{	// handle directly
 			assert(STATIC_SIZE(option_map_bool)>(size_t)index);
@@ -230,7 +149,7 @@
 			last_arg_used_in_option = i;
 			continue;
 			}
-		index = recognize_string_opt(argv[i]);
+		index = recognize_parameter_option(argv[i],option_map_string,STATIC_SIZE(option_map_string));
 		if (0<=index)
 			{	// several flavors of string options; use language override as an example
 				// -x C++
@@ -254,7 +173,7 @@
 			INFORM(option_map_string[index].first);
 			continue;
 			}
-		index = recognize_int_opt(argv[i]);
+		index = recognize_parameter_option(argv[i],option_map_int,STATIC_SIZE(option_map_int));
 		if (0<=index)
 			{
 			assert(STATIC_SIZE(option_map_int)>(size_t)index);



From zaimoni at mail.berlios.de  Fri Nov 27 04:33:38 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 27 Nov 2009 04:33:38 +0100
Subject: [Zcplusplus-commits] r283 - trunk
Message-ID: <200911270333.nAR3XcxV022841@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-27 04:33:32 +0100 (Fri, 27 Nov 2009)
New Revision: 283

Modified:
   trunk/CPreproc.cpp
   trunk/CSupport.cpp
   trunk/errors.hpp
Log:
centralize key part of message_header(); theoretical optimization to enum error reporting

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2009-11-26 20:46:53 UTC (rev 282)
+++ trunk/CPreproc.cpp	2009-11-27 03:33:32 UTC (rev 283)
@@ -520,11 +520,8 @@
 
 static void message_header(const Token<char>& src)
 {
-	assert(NULL!=src.src_filename);
-	INC_INFORM(src.src_filename);
-	INC_INFORM(':');
-	INC_INFORM(src.logical_line.first);
-	INC_INFORM(": ");
+	assert(src.src_filename && *src.src_filename);
+	message_header(src.src_filename,src.logical_line.first);
 }
 
 static void message_header2(const Token<char>& src,size_t where)

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-11-26 20:46:53 UTC (rev 282)
+++ trunk/CSupport.cpp	2009-11-27 03:33:32 UTC (rev 283)
@@ -1062,11 +1062,8 @@
 /* XXX this may belong with weak_token XXX */
 static void message_header(const weak_token& src)
 {
-	assert(NULL!=src.src_filename);
-	INC_INFORM(src.src_filename);
-	INC_INFORM(':');
-	INC_INFORM(src.logical_line.first);
-	INC_INFORM(": ");
+	assert(src.src_filename && *src.src_filename);
+	message_header(src.src_filename,src.logical_line.first);
 }
 
 // balanced character count
@@ -10742,22 +10739,26 @@
 		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
 		else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
 			{	// C99 6.7.2.3: allowed only after name is defined
-			type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
-			src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
-			if (!tmp && !(src.c_array<0>()[i].flags & parse_tree::INVALID))
-				{	//! \test zcc\decl.C99\Error_enum_undef.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'enum ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-				INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].flags |= parse_tree::INVALID;
+			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
+				{
+				type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
+				if (!tmp)
+					{	//! \test zcc\decl.C99\Error_enum_undef.h
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'enum ");
+					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
+					zcc_errors.inc_error();
+					src.c_array<0>()[i].flags |= parse_tree::INVALID;
+					}
 				}
 			}
 		else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
 			{	// can only define once
-			if (types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
+			type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+			if (tmp)
 				{	//! \test zcc\decl.C99\Error_enum_multidef.h
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
@@ -10771,8 +10772,8 @@
 				};
 			// enum-specifier doesn't have a specific declaration mode
 			//! \test zcc\decl.C99\Pass_enum_def.h
-			enum_def* tmp = new enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,tmp);
+			enum_def* tmp2 = new enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,tmp2);
 			assert(types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first));
 			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,false,C99_echo_reserved_keyword))
 				{
@@ -11227,24 +11228,28 @@
 			//! \todo actually, we can try forward-declare both scoped enums and enum-based enums (C++0X 7.2p3, these have enough size information); but other parts of the standard get in the way
 			else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
 				{
-				type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
-				src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
-				if (!tmp && !(src.c_array<0>()[i].flags & parse_tree::INVALID))
-					{	// this belongs elsewhere
-						//! \test zcc\decl.C99\Error_enum_undef.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'enum ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
-					zcc_errors.inc_error();
-					src.c_array<0>()[i].flags |= parse_tree::INVALID;
+				if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
+					{
+					type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+					src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
+					if (!tmp)
+						{	// this belongs elsewhere
+							//! \test zcc\decl.C99\Error_enum_undef.hpp
+						message_header(src.data<0>()[i].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("'enum ");
+						INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+						INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
+						zcc_errors.inc_error();
+						src.c_array<0>()[i].flags |= parse_tree::INVALID;
+						}
 					}
 				//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
 				}
 			else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
 				{	// can only define once
-				if (types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
+				type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+				if (tmp)
 					{	//! \test zcc\decl.C99\Error_enum_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -11258,8 +11263,8 @@
 					};
 				//! \test zcc\decl.C99\Pass_enum_def.hpp
 				// enum-specifier doesn't have a specific declaration mode
-				enum_def* tmp = new enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-				types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,tmp);
+				enum_def* tmp2 = new enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+				types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,tmp2);
 				if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
 					{
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");

Modified: trunk/errors.hpp
===================================================================
--- trunk/errors.hpp	2009-11-26 20:46:53 UTC (rev 282)
+++ trunk/errors.hpp	2009-11-27 03:33:32 UTC (rev 283)
@@ -127,4 +127,6 @@
 int recognize_bool_option(const char* const x,const zaimoni::POD_triple<const char*, size_t, const char*>* option_map,size_t j);
 int recognize_parameter_option(const char* const x,const zaimoni::POD_triple<const char*, size_t, const char*>* option_map,size_t j);
 
+void message_header(const char* const filename, size_t line_number);
+
 #endif



From zaimoni at mail.berlios.de  Fri Nov 27 04:35:37 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 27 Nov 2009 04:35:37 +0100
Subject: [Zcplusplus-commits] r284 - trunk
Message-ID: <200911270335.nAR3ZbxW022950@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-27 04:35:33 +0100 (Fri, 27 Nov 2009)
New Revision: 284

Added:
   trunk/errors.cpp
Log:
unbreak SVN

Added: trunk/errors.cpp
===================================================================
--- trunk/errors.cpp	2009-11-27 03:33:32 UTC (rev 283)
+++ trunk/errors.cpp	2009-11-27 03:35:33 UTC (rev 284)
@@ -0,0 +1,82 @@
+// errors.cpp
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+#include "errors.hpp"
+#include "Zaimoni.STL/OS/mutex.hpp"
+#include "Zaimoni.STL/POD.hpp"
+#include "Zaimoni.STL/Logging.h"
+
+const bool bool_options_default[MAX_OPT_BOOL]
+	= 	{	default_option(boolean_option(0)),
+			default_option(boolean_option(1)),
+			default_option(boolean_option(2)),
+			default_option(boolean_option(3)),
+			default_option(boolean_option(4)),
+			default_option(boolean_option(5)),
+			default_option(boolean_option(6)),
+			default_option(boolean_option(7)),
+			default_option(boolean_option(8)),
+			default_option(boolean_option(9)),
+			default_option(boolean_option(10)),
+			default_option(boolean_option(11))
+		};
+
+bool bool_options[MAX_OPT_BOOL]
+	= 	{	default_option(boolean_option(0)),
+			default_option(boolean_option(1)),
+			default_option(boolean_option(2)),
+			default_option(boolean_option(3)),
+			default_option(boolean_option(4)),
+			default_option(boolean_option(5)),
+			default_option(boolean_option(6)),
+			default_option(boolean_option(7)),
+			default_option(boolean_option(8)),
+			default_option(boolean_option(9)),
+			default_option(boolean_option(10)),
+			default_option(boolean_option(11))
+		};
+
+const char* string_options[MAX_OPT_STRING]
+	= 	{	default_option(string_option(0)),
+			default_option(string_option(1))
+		};
+
+int int_options[MAX_OPT_INT]
+	= {default_option(int_option(0))};
+
+zaimoni::OS::mutex errno_mutex;
+
+#ifndef NDEBUG
+bool debug_tracer = false;
+#endif
+
+int recognize_bool_option(const char* const x,const zaimoni::POD_triple<const char*, size_t, const char*>* option_map,size_t j)
+{
+	assert(option_map && 0<j);
+	if (x && *x)
+		while(0<j)
+			if (!strcmp(option_map[--j].first,x)) return j;
+	return -1;
+}
+
+int recognize_parameter_option(const char* const x,const zaimoni::POD_triple<const char*, size_t, const char*>* option_map,size_t j)
+{
+	assert(option_map && 0<j);
+	if (x && *x)
+		while(0<j)
+			{
+			--j;
+			if (!strncmp(option_map[j].first,x,strlen(option_map[j].first))) return j;
+			}
+	return -1;
+}
+
+void message_header(const char* const filename, size_t line_number)
+{
+	assert(filename && *filename);
+	INC_INFORM(filename);
+	INC_INFORM(':');
+	INC_INFORM(line_number);
+	INC_INFORM(": ");
+}
+



From zaimoni at mail.berlios.de  Fri Nov 27 05:16:07 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 27 Nov 2009 05:16:07 +0100
Subject: [Zcplusplus-commits] r285 - trunk
Message-ID: <200911270416.nAR4G7cw000179@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-27 05:16:02 +0100 (Fri, 27 Nov 2009)
New Revision: 285

Modified:
   trunk/CSupport.cpp
   trunk/enum_type.hpp
   trunk/struct_type.hpp
Log:
report location of prior definition for enum/union/struct/class

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-11-27 03:35:33 UTC (rev 284)
+++ trunk/CSupport.cpp	2009-11-27 04:16:02 UTC (rev 285)
@@ -1066,6 +1066,20 @@
 	message_header(src.src_filename,src.logical_line.first);
 }
 
+/* XXX this may belong with enum_type XXX */
+static void message_header(const enum_def& src)
+{
+	assert(src.filename() && *src.filename());
+	message_header(src.filename(),src.loc().first);
+}
+
+/* XXX this may belong with C_union_struct_def XXX */
+static void message_header(const C_union_struct_def& src)
+{
+	assert(src.filename() && *src.filename());
+	message_header(src.filename(),src.loc().first);
+}
+
 // balanced character count
 static POD_pair<size_t,size_t>
 _balanced_character_count(const weak_token* tokenlist,size_t tokenlist_len,const char l_match,const char r_match)
@@ -10712,6 +10726,8 @@
 				INC_INFORM("'union ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 				INFORM("' already defined (C99 6.7.2.3p1)");
+				message_header(*tmp);
+				INFORM("prior definition here");
 				zcc_errors.inc_error();
 				// now it's gone
 				// remove trailing semicolon if present
@@ -10729,6 +10745,8 @@
 				INC_INFORM("'struct ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 				INFORM("' already defined (C99 6.7.2.3p1)");
+				message_header(*tmp);
+				INFORM("prior definition here");
 				zcc_errors.inc_error();
 				// now it's gone
 				// remove trailing semicolon if present
@@ -10765,6 +10783,10 @@
 				INC_INFORM("'enum ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 				INFORM("' already defined (C99 6.7.2.3p1)");
+				const enum_def* const tmp2 = types.get_enum_def(tmp);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
 				zcc_errors.inc_error();
 				// now it's gone
 				src.DeleteNSlotsAt<0>(1,i);
@@ -11183,6 +11205,8 @@
 					INC_INFORM("'union ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 					INFORM("' already defined (C++98 3.2p1)");
+					message_header(*tmp);
+					INFORM("prior definition here");
 					zcc_errors.inc_error();
 					// now it's gone
 					// remove trailing semicolon if present
@@ -11200,6 +11224,8 @@
 					INC_INFORM("'struct ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 					INFORM("' already defined (C++98 3.2p1)");
+					message_header(*tmp);
+					INFORM("prior definition here");
 					zcc_errors.inc_error();
 					// now it's gone
 					// remove trailing semicolon if present
@@ -11217,6 +11243,8 @@
 					INC_INFORM("'class ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 					INFORM("' already defined (C++98 3.2p1)");
+					message_header(*tmp);
+					INFORM("prior definition here");
 					zcc_errors.inc_error();
 					// now it's gone
 					// remove trailing semicolon if present
@@ -11256,6 +11284,10 @@
 					INC_INFORM("'enum ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 					INFORM("' already defined (C++98 3.2p1)");
+					const enum_def* const tmp2 = types.get_enum_def(tmp);
+					assert(tmp2);
+					message_header(*tmp2);
+					INFORM("prior definition here");
 					zcc_errors.inc_error();
 					// now it's gone
 					src.DeleteNSlotsAt<0>(1,i);

Modified: trunk/enum_type.hpp
===================================================================
--- trunk/enum_type.hpp	2009-11-27 03:35:33 UTC (rev 284)
+++ trunk/enum_type.hpp	2009-11-27 04:16:02 UTC (rev 285)
@@ -21,7 +21,10 @@
 	// default ok for: copy constructor, destructor
 	const enum_def& operator=(const enum_def& src);	// ACID/strong guarantee
 
+	// accessors are to make editing difficult
 	const char* tag() const {return _tag;};
+	const char* filename() const {return _src_filename;};
+	zaimoni::POD_pair<size_t,size_t> loc() const {return _logical_line;};
 #ifndef NDEBUG
 	bool syntax_ok() const;
 #endif

Modified: trunk/struct_type.hpp
===================================================================
--- trunk/struct_type.hpp	2009-11-27 03:35:33 UTC (rev 284)
+++ trunk/struct_type.hpp	2009-11-27 04:16:02 UTC (rev 285)
@@ -45,6 +45,9 @@
 	~C_union_struct_def();
 	const C_union_struct_def& operator=(const C_union_struct_def& src);
 
+	const char* filename() const {return _src_filename;};
+	zaimoni::POD_pair<size_t,size_t> loc() const {return _logical_line;};
+
 #ifndef NDEBUG
 	bool syntax_ok() const;
 #endif



From zaimoni at mail.berlios.de  Sat Nov 28 06:28:57 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 28 Nov 2009 06:28:57 +0100
Subject: [Zcplusplus-commits] r286 - in trunk: . tests/cpp tests/cpp/default
	tests/cpp/default/has_include tests/cpp.in
	tests/cpp.in/default tests/cpp.in/default/has_include
Message-ID: <200911280528.nAS5Sv4f013466@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-28 06:28:36 +0100 (Sat, 28 Nov 2009)
New Revision: 286

Added:
   trunk/tests/cpp.in/default/has_include/
   trunk/tests/cpp.in/default/has_include/Error_angle_in_angle1.in
   trunk/tests/cpp.in/default/has_include/Error_angle_in_angle2.in
   trunk/tests/cpp.in/default/has_include/Error_angle_in_angle3.in
   trunk/tests/cpp.in/default/has_include/Error_angle_in_angle4.in
   trunk/tests/cpp.in/default/has_include/Error_quote_in_quote.in
   trunk/tests/cpp.in/default/has_include/Pass_typical_uses.in
   trunk/tests/cpp/default/has_include/
   trunk/tests/cpp/default/has_include/Error_angle_in_angle1.h
   trunk/tests/cpp/default/has_include/Error_angle_in_angle1.hpp
   trunk/tests/cpp/default/has_include/Error_angle_in_angle2.h
   trunk/tests/cpp/default/has_include/Error_angle_in_angle2.hpp
   trunk/tests/cpp/default/has_include/Error_angle_in_angle3.h
   trunk/tests/cpp/default/has_include/Error_angle_in_angle3.hpp
   trunk/tests/cpp/default/has_include/Error_angle_in_angle4.h
   trunk/tests/cpp/default/has_include/Error_angle_in_angle4.hpp
   trunk/tests/cpp/default/has_include/Error_quote_in_quote.h
   trunk/tests/cpp/default/has_include/Error_quote_in_quote.hpp
   trunk/tests/cpp/default/has_include/Pass_typical_uses.h
   trunk/tests/cpp/default/has_include/Pass_typical_uses.hpp
Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc.hpp
   trunk/tests/cpp.in/run_tests.in
   trunk/tests/cpp/run_tests.bat
   trunk/tests/cpp/run_tests.sh
Log:
bring up CLang preprocessor extension __has_include

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/CPreproc.cpp	2009-11-28 05:28:36 UTC (rev 286)
@@ -219,6 +219,7 @@
 		DICT_STRUCT("__TIMESTAMP__"),			// lock down our extension macros
 		DICT_STRUCT("__COUNTER__"),				// lock down our extension macros
 		DICT_STRUCT("__INCLUDE_LEVEL__"),		// lock down our extension macros
+		DICT_STRUCT("__has_include"),			// lock down our extension macros
 		DICT_STRUCT("__ZCC__"),					// lock down our identity
 		DICT_STRUCT("__ZCC_MINOR__"),			// lock down our identity
 		DICT_STRUCT("__ZCC_PATCHLEVEL__")		// lock down our identity
@@ -832,6 +833,38 @@
 	while(0<j);
 }
 
+/*! 
+ * returns code for hardcoded system header not in the file system
+ * 
+ * \param look_for header name
+ * \param lang_code language code from preprocessor object
+ * 
+ * \return unsigned int
+ */
+static unsigned int
+detect_hardcoded_system_header(const char* const look_for,size_t lang_code)
+{
+	// C,C++: limits.h is hardcoded
+	// C++: climits is hardcoded
+	if (	(!strcmp(look_for,"limits.h") && (Lang::C==lang_code || Lang::CPlusPlus==lang_code))
+		||	(!strcmp(look_for,"climits") && Lang::CPlusPlus==lang_code))
+		return 1;
+
+	// C,C++: stddef.h is hardcoded
+	// C++: cstddef is hardcoded
+	if (	(!strcmp(look_for,"stddef.h") && (Lang::C==lang_code || Lang::CPlusPlus==lang_code))
+		||	(!strcmp(look_for,"cstddef") && Lang::CPlusPlus==lang_code))
+		return 2;
+
+	// C,C++: stdint.h is hardcoded
+	// C++: cstdint is hardcoded
+	if (	(!strcmp(look_for,"stdint.h") && (Lang::C==lang_code || Lang::CPlusPlus==lang_code))
+		||	(!strcmp(look_for,"cstdint") && Lang::CPlusPlus==lang_code))
+		return 3;
+
+	return 0;
+}
+
 void
 CPreprocessor::_preprocess(autovalarray_ptr<Token<char>* >& TokenList, autovalarray_ptr<char*>& locked_macros, autovalarray_ptr<char*>& macros_object, autovalarray_ptr<Token<char>*>& macros_object_expansion, autovalarray_ptr<Token<char>*>& macros_object_expansion_pre_eval, autovalarray_ptr<char*>& macros_function, autovalarray_ptr<Token<char>*>& macros_function_arglist, autovalarray_ptr<Token<char>*>& macros_function_expansion, autovalarray_ptr<Token<char>*>& macros_function_expansion_pre_eval, autovalarray_ptr<POD_triple<const char*, const char*,uintptr_t> >& include_file_index, autovalarray_ptr<POD_pair<const char*,autovalarray_ptr<Token<char>*>* > >& include_file_cache, const type_system& min_types)
 {
@@ -1921,7 +1954,7 @@
 			char buf[FILENAME_MAX];
 			const char* main_index_name = NULL;
 			// note: local_include needs to know where to start...
-			bool found_file = local_include && find_local_include(look_for, buf, ((NULL==TokenList[include_where]->parent_dir) ? "." : TokenList[include_where]->parent_dir));
+			bool found_file = local_include && find_local_include(look_for, buf, (TokenList[include_where]->parent_dir ? TokenList[include_where]->parent_dir : "."));
 			bool hardcoded_header = false;
 			if (found_file)
 				{	// filepath known; local includes use the calculated path for information
@@ -1974,38 +2007,35 @@
 				if (Lang::C==lang_code && 0<lang.pp_support->LengthOfSystemHeader(look_for))
 					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
 
-				// C,C++: limits.h is hardcoded
-				// C++: climits is hardcoded
-				if (	(!strcmp(look_for,"limits.h") && (Lang::C==lang_code || Lang::CPlusPlus==lang_code))
-					||	(!strcmp(look_for,"climits") && Lang::CPlusPlus==lang_code))
-					{	// header is limits.h
+				const unsigned int hardcoded_header_idx = detect_hardcoded_system_header(look_for,lang_code);
+				switch(hardcoded_header_idx)
+				{
+#ifndef NDEBUG
+				default: FATAL("hardcoded_header_idx out of range");
+#endif
+				case 3:	{	// stdint.h/cstdint
 					hardcoded_header = true;
 					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
-					if (0>binary_find("__LIMITS_H__",sizeof("__LIMITS_H__")-1,macros_object))	
-						create_limits_header(IncludeTokenList,look_for);	// not included yet
-					};
-
-				// C,C++: stddef.h is hardcoded
-				// C++: cstddef is hardcoded
-				if (	(!strcmp(look_for,"stddef.h") && (Lang::C==lang_code || Lang::CPlusPlus==lang_code))
-					||	(!strcmp(look_for,"cstddef") && Lang::CPlusPlus==lang_code))
-					{	// header is stddef.h
+					if (0>binary_find("__STDINT_H__",sizeof("__STDINT_H__")-1,macros_object))	
+						create_stdint_header(IncludeTokenList,look_for);	// not included yet
+					break;
+					}
+				case 2:	{	// stddef.h/cstddef
 					hardcoded_header = true;
 					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
 					if (0>binary_find("__STDDEF_H__",sizeof("__STDDEF_H__")-1,macros_object))	
 						create_stddef_header(IncludeTokenList,look_for);	// not included yet
-					};
-
-				// C,C++: stdint.h is hardcoded
-				// C++: cstdint is hardcoded
-				if (	(!strcmp(look_for,"stdint.h") && (Lang::C==lang_code || Lang::CPlusPlus==lang_code))
-					||	(!strcmp(look_for,"cstdint") && Lang::CPlusPlus==lang_code))
-					{	// header is stdint.h
+					break;
+					}
+				case 1:	{	// limits.h/climits
 					hardcoded_header = true;
 					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
-					if (0>binary_find("__STDINT_H__",sizeof("__STDINT_H__")-1,macros_object))	
-						create_stdint_header(IncludeTokenList,look_for);	// not included yet
-					};
+					if (0>binary_find("__LIMITS_H__",sizeof("__LIMITS_H__")-1,macros_object))	
+						create_limits_header(IncludeTokenList,look_for);	// not included yet
+					break;
+					}
+				case 0:;
+				}
 
 				found_file = !hardcoded_header && find_system_include(look_for, buf);
 				if (found_file)
@@ -2483,6 +2513,8 @@
 	assert(NULL!=x);
 	assert(0<x_len);
 	if (0<=linear_find(x, x_len, macro_identifier_default, macro_identifier_default_count)) return 1;
+	// report "magic macros" as defined if the master preprocessor does
+	if (sizeof("__has_include")-1==x_len && !strncmp(x,"__has_include",x_len)) return 1;	// CLang says predefined
 	if (hard_locked_macro(x,x_len)) return -1;
 	return 0;
 }
@@ -2839,6 +2871,38 @@
 	return true;
 }
 
+/*! 
+ * 
+ * 
+ * \param x overall directive
+ * \param pretokenized token index for overall directive
+ * \param src
+ * \param i start token
+ * \param delta last token offset included in range to be substituted
+ * 
+ * \return bool true if and only if directive obviously completely substituted
+ */
+bool
+CPreprocessor::replace_char_into_directive(Token<char>& x,const autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized,const char src,const size_t i,const size_t delta)
+{
+	if (0==i && delta+1==pretokenized.size())
+		{
+		x.replace_once(std::nothrow,pretokenized[0].first,x.size()-pretokenized[0].first,src);
+		return true;
+		};
+
+	size_t buffer_used = 0;
+	char Buffer[4] = "";
+	if (0<pretokenized[i].first && require_padding(x.data()[pretokenized[i].first-1],src))
+		Buffer[buffer_used++] = ' ';
+	Buffer[buffer_used++] = src;
+	if (x.size()>pretokenized[i+delta].first+pretokenized[i+delta].second && require_padding(src,x.data()[pretokenized[i+delta].first+pretokenized[i+delta].second]))
+		Buffer[buffer_used++] = ' ';
+
+	x.replace_once(std::nothrow,pretokenized[i].first,(pretokenized[i+delta].first-pretokenized[i].first)+pretokenized[i+delta].second,Buffer);
+	return false;
+}
+
 /*
  * we use goto in CPreprocessor::if_elif_syntax_ok contrary to readable style guidelines
  *	RetryStringMerge: restart the string-merge stage (should happen only if running short on memory
@@ -2895,21 +2959,7 @@
 				if (0==know_it_now)
 					know_it_now = (macro_is_defined(x.data()+pretokenized[i+1].first, pretokenized[i+1].second, macros_object, macros_function)) ? 1 : -1;
 				const char subst_dest = (0<know_it_now) ? '1' : '0';
-				if (0==i && 2==pretokenized.size())
-					{
-					x.replace_once(std::nothrow,pretokenized[0].first,x.size()-pretokenized[0].first,subst_dest);
-					return true;
-					};
-
-				size_t buffer_used = 0;
-				char Buffer[4] = "";
-				if (0<pretokenized[i].first && require_padding(x.data()[pretokenized[i].first-1],subst_dest))
-					Buffer[buffer_used++] = ' ';
-				Buffer[buffer_used++] = subst_dest;
-				if (x.size()>pretokenized[i+1].first+pretokenized[i+1].second && require_padding(subst_dest,x.data()[pretokenized[i+1].first+pretokenized[i+1].second]))
-					Buffer[buffer_used++] = ' ';
-
-				x.replace_once(std::nothrow,pretokenized[i].first,(pretokenized[i+1].first-pretokenized[i].first)+pretokenized[i+1].second,Buffer);
+				if (replace_char_into_directive(x,pretokenized,subst_dest,i,1)) return true;
 				lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
 				STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
 				continue;
@@ -2935,21 +2985,7 @@
 						know_it_now = (macro_is_defined(x.data()+pretokenized[i+2].first, pretokenized[i+2].second, macros_object, macros_function)) ? 1 : -1;
 
 					const char subst_dest = (0<know_it_now) ? '1' : '0';
-					if (0==i && 4==pretokenized.size())
-						{
-						x.replace_once(std::nothrow,pretokenized[0].first,x.size()-pretokenized[0].first,subst_dest);
-						return true;
-						};
-
-					size_t buffer_used = 0;
-					char Buffer[4] = "";
-					if (0<pretokenized[i].first && require_padding(x.data()[pretokenized[i].first-1],subst_dest))
-						Buffer[buffer_used++] = ' ';
-					Buffer[buffer_used++] = subst_dest;
-					if (x.size()>pretokenized[i+3].first+pretokenized[i+3].second && require_padding(subst_dest,x.data()[pretokenized[i+3].first+pretokenized[i+3].second]))
-						Buffer[buffer_used++] = ' ';
-
-					x.replace_once(std::nothrow,pretokenized[i].first,(pretokenized[i+3].first-pretokenized[i].first)+pretokenized[i+3].second,Buffer);
+					if (replace_char_into_directive(x,pretokenized,subst_dest,i,3)) return true;
 					lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
 					STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
 					continue;
@@ -2978,6 +3014,99 @@
 	// if any identifiers survive, we have to do macro preprocessing to get further
 	if (bad_control) return false;	// but if we discard the block anyway it doesn't matter
 
+	// analyze the __has_include() extension operator (from CLang)
+	i = 0;
+	do	if ((sizeof("__has_include")-1)==pretokenized[i].second && !strncmp(x.data()+pretokenized[i].first,"__has_include",(sizeof("__has_include")-1)))
+			{
+			// if no space for extension, let default flush-to-zero happen silently
+			if (4>pretokenized.size()-i) break;
+			if (!token_is_char<'('>(x.data(),pretokenized[i+1]))
+				// do not trigger __has_include extension
+				continue;
+			// we want: __has_include("...") or __has_include(<...>)
+			if (   C_TESTFLAG_STRING_LITERAL==pretokenized[i+2].third
+				&& '"'==x.data()[pretokenized[i+2].first]
+				&& token_is_char<')'>(x.data(),pretokenized[i+3]))
+				{	// __has_include("...")
+					//! \todo need test cases
+				if (0==pretokenized[i+2].second-2)
+					{	// empty, automatic failure
+					if (replace_char_into_directive(x,pretokenized,'0',i,3)) return true;
+					lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+					STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+					continue;
+					}
+
+				char buf[FILENAME_MAX];
+				char* const look_for = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(pretokenized[i+2].second-2));
+				strncpy(look_for,x.data()+pretokenized[i+2].first+1,pretokenized[i+2].second-2);
+				if (strchr(look_for,'"'))
+					{
+					message_header(x);
+					INFORM("__has_include(\"...\") contains \"; preprocessing per standards rather than invoking extension __has_include");
+					free(look_for);
+					i += 2;
+					continue;
+					};
+				const char subst_dest = (detect_hardcoded_system_header(look_for,lang_code) || find_local_include(look_for, buf, (x.parent_dir ? x.parent_dir : ".")) || find_system_include(look_for, buf)) ? '1' : '0';
+				free(look_for);
+				if (replace_char_into_directive(x,pretokenized,subst_dest,i,3)) return true;
+				lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+				STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+				continue;
+				}
+			//! \todo: optimization check: does testing for < and > by leading/trailing character reduce code size
+			else if (token_is_char<'<'>(x.data(),pretokenized[i+2]))
+				{
+				size_t j = i+2;
+				while(pretokenized.size()-1 > ++j)
+					if (token_is_char<'>'>(x.data(),pretokenized[j]))
+						{	//! \todo need test cases
+						if (!token_is_char<')'>(x.data(),pretokenized[j+1])) break;
+						// __has_include(<...>)
+						if (0==pretokenized[j].first-pretokenized[i+2].first+pretokenized[j].second-2)
+							{	// empty, automatic failure
+							if (replace_char_into_directive(x,pretokenized,'0',i,j+1-i)) return true;
+							lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+							STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+							continue;
+							}
+						char buf[FILENAME_MAX];
+						char* const look_for = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(pretokenized[j].first-pretokenized[i+2].first+pretokenized[j].second-2));
+						strncpy(look_for,x.data()+pretokenized[i+2].first+1,pretokenized[j].first-pretokenized[i+2].first+pretokenized[j].second-2);
+						if (strchr(look_for,'<'))
+							{
+							message_header(x);
+							INFORM("__has_include(<...>) contains <; preprocessing per standards rather than invoking extension __has_include");
+							free(look_for);
+							i += 2;
+							continue;
+							};
+						if (strchr(look_for,'>'))
+							{
+							message_header(x);
+							INFORM("__has_include(<...>) contains >; preprocessing per standards rather than invoking extension __has_include");
+							free(look_for);
+							i += 2;
+							continue;
+							};
+						const char subst_dest = (detect_hardcoded_system_header(look_for,lang_code) || find_system_include(look_for, buf)) ? '1' : '0';
+						free(look_for);
+						if (replace_char_into_directive(x,pretokenized,subst_dest,i,j+1-i)) return true;
+						lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+						STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+						continue;
+						}
+				++i;
+				continue;
+				}
+			// not recognized as __has_include directive, preprocess per standards
+			}
+	while(pretokenized.size() > ++i);
+
+	// if any identifiers survive, we have to do macro preprocessing to get further
+	if (bad_control) return false;	// but if we discard the block anyway it doesn't matter
+
 	intradirective_preprocess(x,valid_directives[if_directive].second+2,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion);
 
 	// if we went invalid do not proceed further

Modified: trunk/CPreproc.hpp
===================================================================
--- trunk/CPreproc.hpp	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/CPreproc.hpp	2009-11-28 05:28:36 UTC (rev 286)
@@ -90,6 +90,7 @@
 	void normalize_macro_expansion(zaimoni::Token<char>& x, const zaimoni::Token<char>& src, size_t critical_offset, size_t first_token_len);
 	void intradirective_preprocess(zaimoni::Token<char>& x, size_t critical_offset, const zaimoni::autovalarray_ptr<char*>& macros_object, const zaimoni::autovalarray_ptr<zaimoni::Token<char>*>& macros_object_expansion, const zaimoni::autovalarray_ptr<char*>& macros_function, const zaimoni::autovalarray_ptr<zaimoni::Token<char>*>& macros_function_arglist, const zaimoni::autovalarray_ptr<zaimoni::Token<char>*>& macros_function_expansion,zaimoni::autovalarray_ptr<char*>* const used_macro_stack = NULL);
 	void intradirective_flush_identifiers_to_zero(zaimoni::Token<char>& x, size_t critical_offset) const;
+	bool replace_char_into_directive(zaimoni::Token<char>& x,const zaimoni::autovalarray_ptr<zaimoni::POD_triple<size_t,size_t,zaimoni::lex_flags> >& pretokenized,const char subst_dest,const size_t i,const size_t delta);
 
 	// macro locking
 	bool hard_locked_macro(const char* const x,const size_t identifier_len) const;

Added: trunk/tests/cpp/default/has_include/Error_angle_in_angle1.h
===================================================================
--- trunk/tests/cpp/default/has_include/Error_angle_in_angle1.h	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp/default/has_include/Error_angle_in_angle1.h	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,7 @@
+// default\has_include\Error_angle_in_angle1.h
+// invalid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+#if __has_include(<a<b>)
+#endif
+

Added: trunk/tests/cpp/default/has_include/Error_angle_in_angle1.hpp
===================================================================
--- trunk/tests/cpp/default/has_include/Error_angle_in_angle1.hpp	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp/default/has_include/Error_angle_in_angle1.hpp	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,7 @@
+// default\has_include\Error_angle_in_angle1.hpp
+// invalid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+#if __has_include(<a<b>)
+#endif
+

Added: trunk/tests/cpp/default/has_include/Error_angle_in_angle2.h
===================================================================
--- trunk/tests/cpp/default/has_include/Error_angle_in_angle2.h	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp/default/has_include/Error_angle_in_angle2.h	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,7 @@
+// default\has_include\Error_angle_in_angle2.h
+// invalid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+#if __has_include(<a>b>)
+#endif
+

Added: trunk/tests/cpp/default/has_include/Error_angle_in_angle2.hpp
===================================================================
--- trunk/tests/cpp/default/has_include/Error_angle_in_angle2.hpp	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp/default/has_include/Error_angle_in_angle2.hpp	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,7 @@
+// default\has_include\Error_angle_in_angle2.hpp
+// invalid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+#if __has_include(<a>b>)
+#endif
+

Added: trunk/tests/cpp/default/has_include/Error_angle_in_angle3.h
===================================================================
--- trunk/tests/cpp/default/has_include/Error_angle_in_angle3.h	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp/default/has_include/Error_angle_in_angle3.h	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,7 @@
+// default\has_include\Error_angle_in_angle3.h
+// invalid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+#if __has_include(<<>)
+#endif
+

Added: trunk/tests/cpp/default/has_include/Error_angle_in_angle3.hpp
===================================================================
--- trunk/tests/cpp/default/has_include/Error_angle_in_angle3.hpp	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp/default/has_include/Error_angle_in_angle3.hpp	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,7 @@
+// default\has_include\Error_angle_in_angle3.hpp
+// invalid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+#if __has_include(<<>)
+#endif
+

Added: trunk/tests/cpp/default/has_include/Error_angle_in_angle4.h
===================================================================
--- trunk/tests/cpp/default/has_include/Error_angle_in_angle4.h	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp/default/has_include/Error_angle_in_angle4.h	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,7 @@
+// default\has_include\Error_angle_in_angle4.h
+// invalid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+#if __has_include(<>>)
+#endif
+

Added: trunk/tests/cpp/default/has_include/Error_angle_in_angle4.hpp
===================================================================
--- trunk/tests/cpp/default/has_include/Error_angle_in_angle4.hpp	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp/default/has_include/Error_angle_in_angle4.hpp	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,7 @@
+// default\has_include\Error_angle_in_angle4.hpp
+// invalid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+#if __has_include(<>>)
+#endif
+

Added: trunk/tests/cpp/default/has_include/Error_quote_in_quote.h
===================================================================
--- trunk/tests/cpp/default/has_include/Error_quote_in_quote.h	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp/default/has_include/Error_quote_in_quote.h	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,7 @@
+// default\has_include\Error_quote_in_quote.h
+// invalid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+#if __has_include("\"")
+#endif
+

Added: trunk/tests/cpp/default/has_include/Error_quote_in_quote.hpp
===================================================================
--- trunk/tests/cpp/default/has_include/Error_quote_in_quote.hpp	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp/default/has_include/Error_quote_in_quote.hpp	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,7 @@
+// default\has_include\Error_quote_in_quote.hpp
+// invalid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+#if __has_include("\"")
+#endif
+

Added: trunk/tests/cpp/default/has_include/Pass_typical_uses.h
===================================================================
--- trunk/tests/cpp/default/has_include/Pass_typical_uses.h	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp/default/has_include/Pass_typical_uses.h	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,38 @@
+// default\has_include\Pass_typical_uses.h
+// exercise valid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+// these should behave like CLang
+#if __has_include("")
+#error __has_include("") is true
+#endif
+#if __has_include(<>)
+#error __has_include(<>) is true
+#endif
+#if __has_include("bad_include")
+#error __has_include("bad_include") is true
+#endif
+#if __has_include(<bad_include>)
+#error __has_include(<bad_include>) is true
+#endif
+#if __has_include("stddef.h")
+#else
+#error __has_include("stddef.h") is false
+#endif
+#if __has_include(<stddef.h>)
+#else
+#error __has_include(<stddef.h>) is false
+#endif
+#if __has_include("stdbool.h")
+#else
+#error __has_include("stdbool.h") is false
+#endif
+#if __has_include(<stdbool.h>)
+#else
+#error __has_include(<stdbool.h>) is false
+#endif
+
+// this should be processed like C99
+#if __has_include
+#error __has_include is true
+#endif

Added: trunk/tests/cpp/default/has_include/Pass_typical_uses.hpp
===================================================================
--- trunk/tests/cpp/default/has_include/Pass_typical_uses.hpp	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp/default/has_include/Pass_typical_uses.hpp	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,38 @@
+// default\has_include\Pass_typical_uses.hpp
+// exercise valid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+// these should behave like CLang
+#if __has_include("")
+#error __has_include("") is true
+#endif
+#if __has_include(<>)
+#error __has_include(<>) is true
+#endif
+#if __has_include("bad_include")
+#error __has_include("bad_include") is true
+#endif
+#if __has_include(<bad_include>)
+#error __has_include(<bad_include>) is true
+#endif
+#if __has_include("stddef.h")
+#else
+#error __has_include("stddef.h") is false
+#endif
+#if __has_include(<stddef.h>)
+#else
+#error __has_include(<stddef.h>) is false
+#endif
+#if __has_include("stdbool.h")
+#else
+#error __has_include("stdbool.h") is false
+#endif
+#if __has_include(<stdbool.h>)
+#else
+#error __has_include(<stdbool.h>) is false
+#endif
+
+// this should be processed like C99
+#if __has_include
+#error __has_include is true
+#endif

Modified: trunk/tests/cpp/run_tests.bat
===================================================================
--- trunk/tests/cpp/run_tests.bat	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp/run_tests.bat	2009-11-28 05:28:36 UTC (rev 286)
@@ -87,6 +87,14 @@
 @for %%f in (default\keywords\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
 @for %%f in (default\keywords\Error*.hpp) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
 @for %%f in (default\keywords\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (default\has_include\Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default\has_include\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (default\has_include\Error*.hpp) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default\has_include\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (default\has_include\Pass*.h) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\has_include\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\has_include\Pass*.hpp) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\has_include\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
 @for %%f in (default\Pass*.h) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
 @for %%f in (default\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
 @for %%f in (default\Pass*.hpp) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)

Modified: trunk/tests/cpp/run_tests.sh
===================================================================
--- trunk/tests/cpp/run_tests.sh	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp/run_tests.sh	2009-11-28 05:28:36 UTC (rev 286)
@@ -66,6 +66,10 @@
 	for F in default/Error*.hpp; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
 	for F in default/keywords/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
 	for F in default/keywords/Error*.hpp; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in default/has_include/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in default/has_include/Error*.hpp; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in default/has_include/Pass*.h; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/has_include/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 	for F in default/Pass*.h; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 	for F in default/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 	for F in default/signmag.core/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_SIGNMAG_NOTRAP $F; if $CPP_SIGNMAG_NOTRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;

Added: trunk/tests/cpp.in/default/has_include/Error_angle_in_angle1.in
===================================================================
--- trunk/tests/cpp.in/default/has_include/Error_angle_in_angle1.in	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp.in/default/has_include/Error_angle_in_angle1.in	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,6 @@
+SUFFIXES h hpp
+// invalid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+VALID_EXPRESSION __has_include(<a<b>)
+

Added: trunk/tests/cpp.in/default/has_include/Error_angle_in_angle2.in
===================================================================
--- trunk/tests/cpp.in/default/has_include/Error_angle_in_angle2.in	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp.in/default/has_include/Error_angle_in_angle2.in	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,6 @@
+SUFFIXES h hpp
+// invalid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+VALID_EXPRESSION __has_include(<a>b>)
+

Added: trunk/tests/cpp.in/default/has_include/Error_angle_in_angle3.in
===================================================================
--- trunk/tests/cpp.in/default/has_include/Error_angle_in_angle3.in	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp.in/default/has_include/Error_angle_in_angle3.in	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,6 @@
+SUFFIXES h hpp
+// invalid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+VALID_EXPRESSION __has_include(<<>)
+

Added: trunk/tests/cpp.in/default/has_include/Error_angle_in_angle4.in
===================================================================
--- trunk/tests/cpp.in/default/has_include/Error_angle_in_angle4.in	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp.in/default/has_include/Error_angle_in_angle4.in	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,6 @@
+SUFFIXES h hpp
+// invalid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+VALID_EXPRESSION __has_include(<>>)
+

Added: trunk/tests/cpp.in/default/has_include/Error_quote_in_quote.in
===================================================================
--- trunk/tests/cpp.in/default/has_include/Error_quote_in_quote.in	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp.in/default/has_include/Error_quote_in_quote.in	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,6 @@
+SUFFIXES h hpp
+// invalid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+VALID_EXPRESSION __has_include("\"")
+

Added: trunk/tests/cpp.in/default/has_include/Pass_typical_uses.in
===================================================================
--- trunk/tests/cpp.in/default/has_include/Pass_typical_uses.in	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp.in/default/has_include/Pass_typical_uses.in	2009-11-28 05:28:36 UTC (rev 286)
@@ -0,0 +1,16 @@
+SUFFIXES h hpp
+// exercise valid __has_include variant
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+// these should behave like CLang
+FALSE_EXPRESSION __has_include("")
+FALSE_EXPRESSION __has_include(<>)
+FALSE_EXPRESSION __has_include("bad_include")
+FALSE_EXPRESSION __has_include(<bad_include>)
+TRUE_EXPRESSION __has_include("stddef.h")
+TRUE_EXPRESSION __has_include(<stddef.h>)
+TRUE_EXPRESSION __has_include("stdbool.h")
+TRUE_EXPRESSION __has_include(<stdbool.h>)
+
+// this should be processed like C99
+FALSE_EXPRESSION __has_include

Modified: trunk/tests/cpp.in/run_tests.in
===================================================================
--- trunk/tests/cpp.in/run_tests.in	2009-11-27 04:16:02 UTC (rev 285)
+++ trunk/tests/cpp.in/run_tests.in	2009-11-28 05:28:36 UTC (rev 286)
@@ -33,6 +33,8 @@
 ECHO Checking ZCC implementation-defined errors and features
 ERROR CPP default/Error*
 ERROR CPP default/keywords/Error*
+ERROR CPP default/has_include/Error*
+PASS CPP default/has_include/Pass*
 PASS CPP default/Pass*
 PASS CPP_SIGNMAG_NOTRAP default/signmag.core/Pass*
 PASS CPP_SIGNMAG_NOTRAP default/signmag.notrap/Pass*



From zaimoni at mail.berlios.de  Sat Nov 28 18:31:09 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 28 Nov 2009 18:31:09 +0100
Subject: [Zcplusplus-commits] r287 - trunk
Message-ID: <200911281731.nASHV9aU014001@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-28 18:31:00 +0100 (Sat, 28 Nov 2009)
New Revision: 287

Modified:
   trunk/CSupport.cpp
   trunk/type_system.cpp
   trunk/type_system.hpp
Log:
relocate namespace concatenation to type_system

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-11-28 05:28:36 UTC (rev 286)
+++ trunk/CSupport.cpp	2009-11-28 17:31:00 UTC (rev 287)
@@ -10239,11 +10239,7 @@
 			// Don't use the check_for_typedef function in this block (conflicts with dynamic RAM loading minimization)
 			if (NULL!=active_namespace)
 				{
-				const size_t active_namespace_len = strlen(active_namespace);
-				char* tmp2 = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(active_namespace_len+2+x.data<0>()[i].index_tokens[0].token.second));
-				strcpy(tmp2,active_namespace);
-				strcpy(tmp2+active_namespace_len,"::");
-				strcpy(tmp2+active_namespace_len+2,x.data<0>()[i].index_tokens[0].token.first);
+				char* tmp2 = type_system::namespace_concatenate(x.data<0>()[i].index_tokens[0].token.first,active_namespace,"::");
 				const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(tmp2);
 				if (NULL!=tmp)
 					{	//! \todo check for access-control if source is a class or struct
@@ -10256,10 +10252,7 @@
 					size_t i = koenig_lookup.size();
 					do	{
 						--i;
-						size_t offset = strlen(koenig_lookup[i]);
-						strcpy(tmp2,koenig_lookup[i]);
-						strcpy(tmp2+offset,"::");
-						strcpy(tmp2+offset+2,x.data<0>()[i].index_tokens[0].token.first);
+						type_system::namespace_concatenate(tmp2,x.data<0>()[i].index_tokens[0].token.first,koenig_lookup[i],"::");
 						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(tmp2);
 						if (NULL!=tmp)
 							{	//! \todo check for access-control if source is a class or struct
@@ -11599,10 +11592,7 @@
 				}
 			else{	// nested
 					//! \todo expand namespace aliases
-				char* const new_active_namespace = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(strlen(active_namespace)+2+src.c_array<0>()[i].c_array<2>()[0].index_tokens[0].token.second));
-				strcpy(new_active_namespace,active_namespace);
-				strcat(new_active_namespace,"::");
-				strncat(new_active_namespace,src.c_array<0>()[i].c_array<2>()[0].index_tokens[0].token.first,src.c_array<0>()[i].c_array<2>()[0].index_tokens[0].token.second);
+				char* const new_active_namespace = type_system::namespace_concatenate(src.c_array<0>()[i].c_array<2>()[0].index_tokens[0].token.first,active_namespace,"::");
 				CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[1],types,new_active_namespace);
 				free(new_active_namespace);
 				}
@@ -11730,10 +11720,7 @@
 						// deal with namespaces
 						if (NULL!=active_namespace)
 							{
-							char* const actual_name = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(strlen(active_namespace)+2+strlen(fullname)));
-							strcpy(actual_name,active_namespace);
-							strcat(actual_name,"::");
-							strcat(actual_name,fullname);
+							char* const actual_name = type_system::namespace_concatenate(fullname,active_namespace,"::");
 							fullname = register_string(actual_name);	//! \todo would like to use "consume string" to avoid frivolous memory allocation
 							free(actual_name);
 							}

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2009-11-28 05:28:36 UTC (rev 286)
+++ trunk/type_system.cpp	2009-11-28 17:31:00 UTC (rev 287)
@@ -130,6 +130,23 @@
 	return NULL;
 }
 
+char* type_system::_namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len)
+{
+	char* const actual_name = zaimoni::_new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(active_namespace_len+2+name_len));
+	strncpy(actual_name,active_namespace,active_namespace_len);
+	strncpy(actual_name+active_namespace_len,namespace_separator,namespace_separator_len);
+	strncpy(actual_name+active_namespace_len+namespace_separator_len,name,name_len);
+	return actual_name;
+}
+
+void type_system::_namespace_concatenate(char* buf, const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len)
+{
+	strncpy(buf,active_namespace,active_namespace_len);
+	strncpy(buf+active_namespace_len,namespace_separator,namespace_separator_len);
+	strncpy(buf+active_namespace_len+namespace_separator_len,name,name_len);
+	ZAIMONI_NULL_TERMINATE(buf[active_namespace_len+namespace_separator_len+name_len]);
+}
+
 type_system::type_index type_system::register_functype(const char* const alias, function_type*& src)
 {
 	assert(alias && *alias);

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2009-11-28 05:28:36 UTC (rev 286)
+++ trunk/type_system.hpp	2009-11-28 17:31:00 UTC (rev 287)
@@ -90,6 +90,27 @@
 		return _name(id);
 		}
 
+	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
+	// defer seven other variants for now (YAGNI) but catch them all at once if one is pragmatic
+	static char* namespace_concatenate(const char* const name, const char* const active_namespace,const char* namespace_separator)
+		{
+		assert(name && *name);
+		assert(active_namespace && *active_namespace);
+		assert(namespace_separator && *namespace_separator);
+		return _namespace_concatenate(name,strlen(name),active_namespace,strlen(active_namespace),namespace_separator,strlen(namespace_separator));
+		}
+
+	// defer seven other variants for now (YAGNI) but catch them all at once if one is pragmatic
+	static void namespace_concatenate(char* buf, const char* const name, const char* const active_namespace,const char* namespace_separator)
+		{
+		assert(buf);
+		assert(name && *name);
+		assert(active_namespace && *active_namespace);
+		assert(namespace_separator && *namespace_separator);
+		_namespace_concatenate(buf,name,strlen(name),active_namespace,strlen(active_namespace),namespace_separator,strlen(namespace_separator));
+		}
+
+
 	void set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec& src);	// invalidates src
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* get_typedef(const char* const alias) const;
 
@@ -108,5 +129,8 @@
 	type_index _get_id_enum(const char* const x,size_t x_len) const;
 	type_index _get_id_struct_class(const char* const x,size_t x_len) const;
 	const char* _name(type_index id) const;
+	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
+	static char* _namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
+	static void _namespace_concatenate(char* buf, const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
 };
 #endif



From zaimoni at mail.berlios.de  Sun Nov 29 18:52:56 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 29 Nov 2009 18:52:56 +0100
Subject: [Zcplusplus-commits] r288 - trunk
Message-ID: <200911291752.nATHqufW023533@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-29 18:52:41 +0100 (Sun, 29 Nov 2009)
New Revision: 288

Added:
   trunk/str_aux.cpp
   trunk/str_aux.h
Modified:
   trunk/CSupport.cpp
   trunk/MakeMake.cfg
   trunk/POSIX.dep
Log:
relocate a couple of generic C string analysis functions.  (It looks like type_system is the place to handle C++ namespace lookup, so it will need access to these functions.)

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-11-28 17:31:00 UTC (rev 287)
+++ trunk/CSupport.cpp	2009-11-29 17:52:41 UTC (rev 288)
@@ -9,6 +9,7 @@
 #include "Zaimoni.STL/LexParse/LangConf.hpp"
 #include "Zaimoni.STL/search.hpp"
 #include "AtomicString.h"
+#include "str_aux.h"
 #include "Trigraph.hpp"
 #include "Flat_UNI.hpp"
 #include "errors.hpp"
@@ -10136,42 +10137,6 @@
 	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
 };
 
-//! \todo belongs elsewhere
-size_t count_disjoint_substring_instances(const char* const src,const char* const match)
-{
-	assert(src && *src);
-	assert(match && *match);
-	const size_t src_len = strlen(src);
-	const size_t match_len = strlen(match);
-	size_t n = 0;
-	const char* test = strstr(src,match);
-	while(NULL!=test)
-		{
-		++n;
-		test = (2*match_len<=src_len-(test-src)) ? strstr(test+match_len,match) : NULL;
-		};
-	return n;
-}
-
-//! \todo belongs elsewhere
-void report_disjoint_substring_instances(const char* const src,const char* const match,const char** const namespace_break_stack,const size_t namespace_break_stack_size)
-{
-	assert(NULL!=src && *src);
-	assert(NULL!=match && *match);
-	assert(NULL!=namespace_break_stack);
-	const size_t src_len = strlen(src);
-	const size_t match_len = strlen(match);
-	size_t n = 0;
-	const char* test = strstr(src,match);
-	while(NULL!=test)
-		{
-		assert(namespace_break_stack_size>n);
-		namespace_break_stack[n++] = test;
-		test = (2*match_len<=src_len-(test-src)) ? strstr(test+match_len,match) : NULL;
-		};
-	assert(0<n);
-}
-
 class CPP0X_decl_specifier_scanner
 {
 private:

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2009-11-28 17:31:00 UTC (rev 287)
+++ trunk/MakeMake.cfg	2009-11-29 17:52:41 UTC (rev 288)
@@ -1,6 +1,6 @@
 ########
-ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','filesystem','CPUInfo','enum_type','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
-				'zcc':('zcc','errors','langroute','AtomicString','filesystem','CPUInfo','enum_type','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
+ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','filesystem','CPUInfo','enum_type','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
+				'zcc':('zcc','errors','langroute','AtomicString','str_aux','filesystem','CPUInfo','enum_type','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
 MainPrograms = ['z_cpp','zcc']
 
 # process control

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2009-11-28 17:31:00 UTC (rev 287)
+++ trunk/POSIX.dep	2009-11-29 17:52:41 UTC (rev 288)
@@ -1,14 +1,15 @@
-OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o filesystem.o CPUInfo.o enum_type.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
-OBJECTS_Z_CPP_LINK_PRIORITY = z_cpp.o errors.o CPreproc.o CSupport.o enum_type.o type_system.o struct_type.o ParseTree.o type_spec.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o CPUInfo.o enum_type.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
+OBJECTS_Z_CPP_LINK_PRIORITY = str_aux.o CSupport.o type_system.o CPreproc.o errors.o z_cpp.o enum_type.o struct_type.o ParseTree.o type_spec.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
-OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o filesystem.o CPUInfo.o enum_type.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = zcc.o errors.o CPreproc.o CSupport.o enum_type.o type_system.o struct_type.o ParseTree.o type_spec.o ZParser.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o CPUInfo.o enum_type.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
+OBJECTS_ZCC_LINK_PRIORITY = str_aux.o CSupport.o type_system.o CPreproc.o errors.o zcc.o enum_type.o struct_type.o ParseTree.o type_spec.o ZParser.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
 # dependencies
 z_cpp.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_aux.hpp
 errors.o: errors.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 langroute.o: langroute.hpp CSupport.hpp Zaimoni.STL/Logging.h Zaimoni.STL/POD.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp
 AtomicString.o: AtomicString.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
+str_aux.o: str_aux.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 filesystem.o: filesystem.h Zaimoni.STL/Compiler.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h
 CPUInfo.o: CPUInfo.hpp unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 enum_type.o: enum_type.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp CPUInfo.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_aux.hpp
@@ -16,7 +17,7 @@
 type_system.o: type_system.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport.o: CSupport.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport.o: CSupport.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h

Added: trunk/str_aux.cpp
===================================================================
--- trunk/str_aux.cpp	2009-11-28 17:31:00 UTC (rev 287)
+++ trunk/str_aux.cpp	2009-11-29 17:52:41 UTC (rev 288)
@@ -0,0 +1,46 @@
+// str_aux.cpp
+
+#include "str_aux.h"
+
+#include <string.h>
+#include "Zaimoni.STL/Logging.h"
+
+EXTERN_C size_t count_disjoint_substring_instances(const char* const src,const char* const match)
+{
+	assert(src && *src);
+	assert(match && *match);
+	const size_t src_len = strlen(src);
+	const size_t match_len = strlen(match);
+	size_t n = 0;
+	if (src_len/2>=match_len)
+		{
+		const ptrdiff_t can_fit_threshold = src_len-2*match_len;
+		const char* test = strstr(src,match);
+		while(test)
+			{
+			++n;
+			test = (test-src<=can_fit_threshold) ? strstr(test+match_len,match) : NULL;
+			};
+		}
+	return n;
+}
+
+EXTERN_C void report_disjoint_substring_instances(const char* const src,const char* const match,const char** const index_stack,const size_t index_stack_size)
+{
+	assert(src && *src);
+	assert(match && *match);
+	assert(index_stack);
+	assert(count_disjoint_substring_instances(src,match)==index_stack_size);
+	const size_t match_len = strlen(match);
+	const ptrdiff_t can_fit_threshold = strlen(src)-2*match_len;
+	size_t n = 0;
+	const char* test = strstr(src,match);
+	while(test)
+		{
+		assert(index_stack_size>n);
+		index_stack[n++] = test;
+		test = (test-src<=can_fit_threshold) ? strstr(test+match_len,match) : NULL;
+		};
+	assert(0<n);
+}
+

Added: trunk/str_aux.h
===================================================================
--- trunk/str_aux.h	2009-11-28 17:31:00 UTC (rev 287)
+++ trunk/str_aux.h	2009-11-29 17:52:41 UTC (rev 288)
@@ -0,0 +1,37 @@
+// str_aux.h
+
+#ifndef STR_AUX_H
+#define STR_AUX_H 1
+
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/*! 
+ * reports how many disjoint copies of the C string match are in the C string src
+ * 
+ * \param src string to count matches in
+ * \param match string to match
+ * 
+ * \return size_t count of matches
+ */
+size_t count_disjoint_substring_instances(const char* src,const char* match);
+
+/*! 
+ * populate namespace_break_stack with the indexes of the disjoint copies of C string match in C string src
+ * 
+ * \param src string to count matches in
+ * \param match string to match
+ * \param index_stack array of string match indexes to populate
+ * \param index_stack_size size of above array
+ */
+void report_disjoint_substring_instances(const char* src,const char* match,const char** index_stack,size_t index_stack_size);
+
+#ifdef __cplusplus
+}	/* extern "C" */
+#endif
+
+#endif



From zaimoni at mail.berlios.de  Mon Nov 30 03:39:35 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 30 Nov 2009 03:39:35 +0100
Subject: [Zcplusplus-commits] r289 - trunk
Message-ID: <200911300239.nAU2dZVN011272@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-30 03:39:30 +0100 (Mon, 30 Nov 2009)
New Revision: 289

Modified:
   trunk/type_system.cpp
   trunk/type_system.hpp
Log:
remove get_id and support functions (dead outside of type_system class, no foreseeable use)

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2009-11-29 17:52:41 UTC (rev 288)
+++ trunk/type_system.cpp	2009-11-30 02:39:30 UTC (rev 289)
@@ -12,16 +12,6 @@
 #define DYNAMIC_ENUMDEF 4
 
 type_system::type_index
-type_system::_get_id(const char* const x,size_t x_len) const
-{
-	errr tmp = linear_find_lencached(x,x_len,core_types,core_types_size);
-	if (0<=tmp) return tmp+1;
-	tmp = linear_find_lencached(x,x_len,dynamic_types);
-	if (0<=tmp) return tmp+1+core_types_size;
-	return 0;
-}
-
-type_system::type_index
 type_system::_get_id_union(const char* const x,size_t x_len) const
 {
 	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
@@ -154,9 +144,6 @@
 	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_FUNCTYPE}};
 	tmp.third.first.first = src;
 
-	type_index result = get_id(alias);
-	if (result) return result;
-
 	const size_t dynamic_types_size = dynamic_types.size();
 	const size_t dynamic_types_max_size = dynamic_types.max_size();
 	if (	dynamic_types_max_size<1+core_types_size
@@ -174,9 +161,6 @@
 	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_STRUCTDECL}};
 	tmp.third.first.second = src;
 
-	type_index result = get_id(alias);
-	if (result) return result;
-
 	const size_t dynamic_types_size = dynamic_types.size();
 	const size_t dynamic_types_max_size = dynamic_types.max_size();
 	if (	dynamic_types_max_size<2+core_types_size
@@ -194,9 +178,6 @@
 	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_C_STRUCTDEF}};
 	tmp.third.first.third = src;
 
-	type_index result = get_id(alias);
-	if (result) return result;
-
 	const size_t dynamic_types_size = dynamic_types.size();
 	const size_t dynamic_types_max_size = dynamic_types.max_size();
 	if (	dynamic_types_max_size<2+core_types_size
@@ -214,9 +195,6 @@
 	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_ENUMDEF}};
 	tmp.third.first.fourth = src;
 
-	type_index result = get_id(alias);
-	if (result) return result;
-
 	const size_t dynamic_types_size = dynamic_types.size();
 	const size_t dynamic_types_max_size = dynamic_types.max_size();
 	if (	dynamic_types_max_size<2+core_types_size

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2009-11-29 17:52:41 UTC (rev 288)
+++ trunk/type_system.hpp	2009-11-30 02:39:30 UTC (rev 289)
@@ -36,18 +36,6 @@
 		core_types_size((assert(0<_core_types_size),_core_types_size)),
 		int_priority_size((assert(0<_int_priority_size),_int_priority_size)) {};
 
-	type_index get_id(const char* x,size_t x_len) const
-		{
-		assert(x && *x);
-		assert(0<x_len);
-		assert(x_len<=strlen(x));
-		return _get_id(x,x_len);
-		}
-	type_index get_id(const char* x) const
-		{
-		assert(x && *x);
-		return _get_id(x,strlen(x));
-		}
 	type_index get_id_union(const char* x,size_t x_len) const
 		{
 		assert(x && *x);
@@ -124,7 +112,6 @@
 	const enum_def* get_enum_def(type_index i);
 	void upgrade_decl_to_def(type_index i,C_union_struct_def*& src);
 private:
-	type_index _get_id(const char* const x,size_t x_len) const;
 	type_index _get_id_union(const char* const x,size_t x_len) const;
 	type_index _get_id_enum(const char* const x,size_t x_len) const;
 	type_index _get_id_struct_class(const char* const x,size_t x_len) const;



From zaimoni at mail.berlios.de  Mon Nov 30 04:54:14 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 30 Nov 2009 04:54:14 +0100
Subject: [Zcplusplus-commits] r290 - trunk
Message-ID: <200911300354.nAU3sEh2020108@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-30 04:54:09 +0100 (Mon, 30 Nov 2009)
New Revision: 290

Modified:
   trunk/CSupport.cpp
   trunk/type_system.cpp
   trunk/type_system.hpp
Log:
preliminary change for handling typedefs in anonymous/inline namespaces

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-11-30 02:39:30 UTC (rev 289)
+++ trunk/CSupport.cpp	2009-11-30 03:54:09 UTC (rev 290)
@@ -9989,7 +9989,7 @@
 }
 
 //! \todo should this be a type_system member?
-bool check_for_typedef(type_spec& dest,const char* const src,const type_system& types)
+static bool check_for_typedef(type_spec& dest,const char* const src,const type_system& types)
 {
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(src);
 	if (NULL!=tmp)
@@ -10000,6 +10000,18 @@
 	return false;
 }
 
+//! \todo should this be a type_system member?
+static bool check_for_typedef(type_spec& dest,const char* const src,const char* const active_namespace,const type_system& types)
+{
+	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef_CPP(src,active_namespace);
+	if (NULL!=tmp)
+		{	//! \todo C++: check for access control if source ends up being a class or struct
+		value_copy(dest,tmp->first);
+		return true;
+		}
+	return false;
+}
+
 //! \todo does this need to be in ParseTree.hpp?
 static size_t 
 flush_token(parse_tree& x, const size_t i, const size_t n, const char* const target)
@@ -10146,24 +10158,11 @@
 	const type_system& types;
 	// these two might belong in a koenig_lookup object
 	const char* const active_namespace;
-	autovalarray_ptr_throws<char*> koenig_lookup;
 public:
-	CPP0X_decl_specifier_scanner(const type_system& _types,const char* const _active_namespace) : flags(0),types(_types),active_namespace(_active_namespace),koenig_lookup((_active_namespace && *_active_namespace) ? count_disjoint_substring_instances(_active_namespace,"::") : 0)
+	CPP0X_decl_specifier_scanner(const type_system& _types,const char* const _active_namespace) : flags(0),types(_types),active_namespace(_active_namespace)
 		{
 		clear(decl_count);
 		base_type.clear();
-		if (!koenig_lookup.empty())
-			{
-			size_t namespace_break_stack_size = koenig_lookup.size();
-			weakautovalarray_ptr_throws<const char*> namespace_break_stack(namespace_break_stack_size);
-			report_disjoint_substring_instances(active_namespace,"::",namespace_break_stack.c_array(),namespace_break_stack_size);
-			do	{
-				size_t offset = namespace_break_stack[--namespace_break_stack_size]-active_namespace;
-				koenig_lookup[namespace_break_stack_size] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(offset));
-				strncpy(koenig_lookup[namespace_break_stack_size],active_namespace,offset);
-				}
-			while(0<namespace_break_stack_size);
-			}
 		}
 	// trivial destructor, copy constructor, assignment fine
 	bool operator()(parse_tree& x,const size_t i)
@@ -10191,47 +10190,8 @@
 			&& !(PARSE_TYPE & x.data<0>()[i].flags)
 			&& !CPP_echo_reserved_keyword(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second)
 			&& (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags))
-			{
-			if (!strncmp(x.data<0>()[i].index_tokens[0].token.first,"::",2))
-				{	// fully-qualified
-				assert(2<x.data<0>()[i].index_tokens[0].token.second);
-				return check_for_typedef(base_type,x.data<0>()[i].index_tokens[0].token.first+2,types);
-				};
-			// ahem...Koenig lookup
-			// work backwards until we find something
-			// if the result ends up being from a struct/class, access control will cut in
-			// in any case, the types object is responsible for handling aliases and using directives
-			// Don't use the check_for_typedef function in this block (conflicts with dynamic RAM loading minimization)
-			if (NULL!=active_namespace)
-				{
-				char* tmp2 = type_system::namespace_concatenate(x.data<0>()[i].index_tokens[0].token.first,active_namespace,"::");
-				const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(tmp2);
-				if (NULL!=tmp)
-					{	//! \todo check for access-control if source is a class or struct
-					free(tmp2);
-					value_copy(base_type,tmp->first);
-					return true;
-					};
-				if (!koenig_lookup.empty())
-					{
-					size_t i = koenig_lookup.size();
-					do	{
-						--i;
-						type_system::namespace_concatenate(tmp2,x.data<0>()[i].index_tokens[0].token.first,koenig_lookup[i],"::");
-						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(tmp2);
-						if (NULL!=tmp)
-							{	//! \todo check for access-control if source is a class or struct
-							free(tmp2);
-							value_copy(base_type,tmp->first);
-							return true;
-							};
-						}
-					while(0<i);
-					};
-				free(tmp2);
-				}
-			// last case: just try it as-is
-			return check_for_typedef(base_type,x.data<0>()[i].index_tokens[0].token.first,types);
+			{	// shove Koenig lookup into type_system
+			return check_for_typedef(base_type,x.data<0>()[i].index_tokens[0].token.first,active_namespace,types);
 			}
 		}
 		//! \todo handle other known types

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2009-11-30 02:39:30 UTC (rev 289)
+++ trunk/type_system.cpp	2009-11-30 03:54:09 UTC (rev 290)
@@ -4,6 +4,8 @@
 #include "type_system.hpp"
 #include "struct_type.hpp"
 #include "Zaimoni.STL/search.hpp"
+#include "AtomicString.h"
+#include "str_aux.h"
 
 // macros to help out dynamic registration
 #define DYNAMIC_FUNCTYPE 1
@@ -97,8 +99,6 @@
 {
 	assert(alias && *alias);
 	assert(filename && *filename);
-	//! \todo: strip off trailing inline namespaces
-	// <unknown> is the hack for anonymous namespaces taken from GCC, it's always inline
 	errr tmp = binary_find(alias,strlen(alias),typedef_registry.data(),typedef_registry.size());
 	assert(0>tmp);		// error to call with conflicting prior definition
 	if (0<=tmp) return;	// conflicting prior definition
@@ -120,6 +120,64 @@
 	return NULL;
 }
 
+const zaimoni::POD_triple<type_spec,const char*,size_t>* type_system::_get_typedef_CPP(const char* const alias) const
+{
+	errr tmp = binary_find(alias,strlen(alias),typedef_registry.data(),typedef_registry.size());
+	if (0<=tmp) return &typedef_registry[tmp].second;
+	// hmm...not an exact match
+	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(alias);
+	if (0<=tmp2.first)
+		{	// it was remapped
+		while(tmp2.first<tmp2.second)
+			{
+			tmp = binary_find(inline_namespace_alias_map.data()[tmp2.first].second,strlen(inline_namespace_alias_map.data()[tmp2.first].second),typedef_registry.data(),typedef_registry.size());
+			if (0<=tmp) return &typedef_registry[tmp].second;
+			}
+		tmp = binary_find(inline_namespace_alias_map.data()[tmp2.first].second,strlen(inline_namespace_alias_map.data()[tmp2.first].second),typedef_registry.data(),typedef_registry.size());
+		if (0<=tmp) return &typedef_registry[tmp].second;
+		}
+	return NULL;
+}
+
+const zaimoni::POD_triple<type_spec,const char*,size_t>* type_system::get_typedef_CPP(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+
+	if (!strncmp(alias,"::",2))
+		{	// fully-qualified typedef name
+			// cheat: pretend not fully qualified but no surrounding namespace
+		alias += 2;
+		active_namespace = NULL;
+		};
+	if (active_namespace && *active_namespace)
+		{
+		// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		if (is_string_registered(tmp_alias))
+			{	// registered, so could be indexed
+			const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp2 = _get_typedef_CPP(tmp_alias);
+			if (tmp2) return (free(tmp_alias),tmp2);
+			}
+
+		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
+		if (extra_namespaces)
+			{
+			zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
+			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				--i;
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,"::");
+				const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp2 = _get_typedef_CPP(tmp_alias);
+				if (tmp2) return (free(tmp_alias),tmp2);
+				}
+			while(0<i);
+			}
+		free(tmp_alias);
+		}
+	return _get_typedef_CPP(alias);
+}
+
 char* type_system::_namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len)
 {
 	char* const actual_name = zaimoni::_new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(active_namespace_len+2+name_len));
@@ -137,6 +195,41 @@
 	ZAIMONI_NULL_TERMINATE(buf[active_namespace_len+namespace_separator_len+name_len]);
 }
 
+zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> type_system::dealias_inline_namespace_index(const char* const alias) const
+{
+	assert(alias && *alias);
+	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp = {-1,-1};
+	size_t strict_ub = inline_namespace_alias_map.size();
+	size_t lb = 0;
+	// binary search
+	// is inline_namespace_alias_map.data() a code size optimization target?
+	while(strict_ub>lb)
+		{
+		const size_t midpoint = lb+(strict_ub-lb)/2;
+		switch(strcmp(inline_namespace_alias_map.data()[midpoint].first,alias))
+		{
+#ifndef NDEBUG
+		default: FATAL("strcmp out of range -1,0,1");
+#endif
+		case 0: {
+			tmp.first = midpoint;
+			tmp.second = midpoint;
+			while(lb<(size_t)tmp.first && !strcmp(inline_namespace_alias_map.data()[tmp.first-1].first,alias)) --tmp.first;
+			while(strict_ub-1>(size_t)tmp.second && !strcmp(inline_namespace_alias_map.data()[tmp.second+1].first,alias)) ++tmp.second;
+			return tmp;
+			}
+		case 1: {
+			strict_ub = midpoint;
+			break;
+			}
+		case -1:{
+			lb = midpoint+1;
+			}
+		}
+		}
+	return tmp;
+}
+
 type_system::type_index type_system::register_functype(const char* const alias, function_type*& src)
 {
 	assert(alias && *alias);

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2009-11-30 02:39:30 UTC (rev 289)
+++ trunk/type_system.hpp	2009-11-30 03:54:09 UTC (rev 290)
@@ -26,6 +26,7 @@
 	typedef zaimoni::POD_triple<const char*,size_t,zaimoni::POD_pair<zaimoni::union_quartet<function_type*,union_struct_decl*,C_union_struct_def*,enum_def*>, unsigned char> > dynamic_type_format;
 	zaimoni::autovalarray_ptr<dynamic_type_format> dynamic_types;
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> > > typedef_registry;
+	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,const char*> > inline_namespace_alias_map;
 	// uncopyable
 	type_system(const type_system& src);
 	void operator=(const type_system& src);
@@ -79,16 +80,16 @@
 		}
 
 	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
-	// defer seven other variants for now (YAGNI) but catch them all at once if one is pragmatic
+	// defer seven other variants for now (YAGNI)
 	static char* namespace_concatenate(const char* const name, const char* const active_namespace,const char* namespace_separator)
 		{
 		assert(name && *name);
 		assert(active_namespace && *active_namespace);
 		assert(namespace_separator && *namespace_separator);
 		return _namespace_concatenate(name,strlen(name),active_namespace,strlen(active_namespace),namespace_separator,strlen(namespace_separator));
-		}
+		};
 
-	// defer seven other variants for now (YAGNI) but catch them all at once if one is pragmatic
+	// defer six other variants for now (YAGNI)
 	static void namespace_concatenate(char* buf, const char* const name, const char* const active_namespace,const char* namespace_separator)
 		{
 		assert(buf);
@@ -96,11 +97,21 @@
 		assert(active_namespace && *active_namespace);
 		assert(namespace_separator && *namespace_separator);
 		_namespace_concatenate(buf,name,strlen(name),active_namespace,strlen(active_namespace),namespace_separator,strlen(namespace_separator));
-		}
+		};
+	static void namespace_concatenate(char* buf, const char* const name, const char* const active_namespace,size_t active_namespace_len,const char* namespace_separator)
+		{
+		assert(buf);
+		assert(name && *name);
+		assert(active_namespace && *active_namespace);
+		assert(0<active_namespace_len && active_namespace_len<=strlen(active_namespace));
+		assert(namespace_separator && *namespace_separator);
+		_namespace_concatenate(buf,name,strlen(name),active_namespace,active_namespace_len,namespace_separator,strlen(namespace_separator));
+		};
 
 
 	void set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec& src);	// invalidates src
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* get_typedef(const char* const alias) const;
+	const zaimoni::POD_triple<type_spec,const char*,size_t>* get_typedef_CPP(const char* alias,const char* active_namespace) const;
 
 	type_index register_functype(const char* const alias, function_type*& src);
 	type_index register_structdecl(const char* const alias, union_struct_decl*& src);
@@ -116,6 +127,8 @@
 	type_index _get_id_enum(const char* const x,size_t x_len) const;
 	type_index _get_id_struct_class(const char* const x,size_t x_len) const;
 	const char* _name(type_index id) const;
+	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> dealias_inline_namespace_index(const char* alias) const;
+	const zaimoni::POD_triple<type_spec,const char*,size_t>* _get_typedef_CPP(const char* alias) const;
 	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
 	static char* _namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
 	static void _namespace_concatenate(char* buf, const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);



From zaimoni at mail.berlios.de  Mon Nov 30 07:03:22 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 30 Nov 2009 07:03:22 +0100
Subject: [Zcplusplus-commits] r291 - trunk
Message-ID: <200911300603.nAU63MRh003529@sheep.berlios.de>

Author: zaimoni
Date: 2009-11-30 07:03:15 +0100 (Mon, 30 Nov 2009)
New Revision: 291

Modified:
   trunk/CSupport.cpp
   trunk/type_system.cpp
   trunk/type_system.hpp
Log:
actually be able to create typedefs in anonymous namespaces (need test cases)

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-11-30 03:54:09 UTC (rev 290)
+++ trunk/CSupport.cpp	2009-11-30 06:03:15 UTC (rev 291)
@@ -11651,6 +11651,7 @@
 							}
 
 						// verify that there is no prior definition
+						// we're fine redeclaring at a different level, so do not use full C++ typedef lookup
 						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(fullname);
 						if (NULL!=tmp)
 							{
@@ -11684,7 +11685,7 @@
 							// do not re-register if there is a prior definition
 							}
 						else	// register this with types object
-							types.set_typedef(fullname,src.data<0>()[initdecl_identifier_idx].index_tokens[0].src_filename,src.data<0>()[initdecl_identifier_idx].index_tokens[0].logical_line.first,bootstrap);
+							types.set_typedef_CPP(src.c_array<0>()[initdecl_identifier_idx].index_tokens[0].token.first,active_namespace,src.data<0>()[initdecl_identifier_idx].index_tokens[0].src_filename,src.data<0>()[initdecl_identifier_idx].index_tokens[0].logical_line.first,bootstrap);
 						}
 #if 0
 					else{	// something else

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2009-11-30 03:54:09 UTC (rev 290)
+++ trunk/type_system.cpp	2009-11-30 06:03:15 UTC (rev 291)
@@ -4,6 +4,7 @@
 #include "type_system.hpp"
 #include "struct_type.hpp"
 #include "Zaimoni.STL/search.hpp"
+#include "Zaimoni.STL/Pure.C/auto_int.h"
 #include "AtomicString.h"
 #include "str_aux.h"
 
@@ -110,6 +111,19 @@
 	src.clear();
 }
 
+void type_system::set_typedef_CPP(const char* const name, const char* const active_namespace, const char* filename, const size_t lineno, type_spec& src)
+{
+	assert(name && *name);
+	assert(filename && *filename);
+
+	// if no active namespace, treat as C
+	if (!active_namespace || !*active_namespace)
+		return set_typedef(name,filename,lineno,src);
+
+	const char* const alias = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+	return set_typedef(alias,filename,lineno,src);
+}
+
 const zaimoni::POD_triple<type_spec,const char*,size_t>* type_system::get_typedef(const char* const alias) const
 {
 	assert(alias && *alias);
@@ -230,6 +244,155 @@
 	return tmp;
 }
 
+bool type_system::is_inline_namespace_CPP(const char* const active_namespace, const size_t active_namespace_len) const
+{
+	assert(active_namespace && *active_namespace && 0<active_namespace_len);
+	assert(strncmp(active_namespace,"::",2));
+	
+	// ::<unknown>, our hack for anonymous namespaces, is always an inline namespace 
+	if (sizeof("<unknown>")-1==active_namespace_len && !strncmp(active_namespace,"<unknown>",sizeof("<unknown>")-1)) return true;
+	if (sizeof("::<unknown>")-1<active_namespace_len && !strncmp(active_namespace+(active_namespace_len-(sizeof("::<unknown>")-1)),"::<unknown>",sizeof("::<unknown>")-1)) return true;
+
+	//! \todo check for C++0X inline namespaces
+	// should be fine with binary search against canonical names
+	return false;
+}
+
+const char* type_system::canonical_name_is_inline_namespace_alias_target(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len) const
+{
+	assert(active_namespace && *active_namespace && 0<active_namespace_len);
+	assert(name && *name && 0<name_len);
+	assert(namespace_separator && *namespace_separator && 0<namespace_separator_len);
+	size_t strict_ub = inline_namespace_alias_targets.size();
+	size_t lb = 0;
+	// classic binary search.
+	// is inline_namespace_alias_targets.data() a code-size optimization target?
+	while(strict_ub>lb)
+		{
+		const size_t midpoint = lb+(strict_ub-lb)/2;
+		int tmp = strncmp(inline_namespace_alias_targets.data()[midpoint],active_namespace,active_namespace_len);
+		if (!tmp) tmp = strncmp(inline_namespace_alias_targets.data()[midpoint]+active_namespace_len,namespace_separator,namespace_separator_len);
+		if (!tmp) tmp = strncmp(inline_namespace_alias_targets.data()[midpoint]+active_namespace_len+namespace_separator_len,name,name_len);
+		switch(tmp)
+		{
+#ifndef NDEBUG
+		default: FATAL("strncmp out of range -1,0,1");
+#endif
+		case 0: return  inline_namespace_alias_targets.data()[midpoint];
+		case 1: {
+			strict_ub = midpoint;
+			break;
+			}
+		case -1:{
+			lb = midpoint+1;
+			}
+		}
+		}
+	return NULL;
+}
+
+const char* type_system::construct_canonical_name_and_aliasing_CPP(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len)
+{
+	assert(active_namespace && *active_namespace && 0<active_namespace_len);
+	assert(name && *name && 0<name_len);
+	assert(strncmp(active_namespace,"::",2));
+	// check for whether we already are aliased
+	const char* retval = canonical_name_is_inline_namespace_alias_target(name,name_len,active_namespace,active_namespace_len,"::",2);
+	if (NULL!=retval) return retval;
+
+	// canonical name is simply active_namespace::name
+	zaimoni::autoval_ptr<char> retval_tmp;
+	retval_tmp = _namespace_concatenate(name,name_len,active_namespace,active_namespace_len,"::",2);
+
+	// aliasing is built by removing trailing inline namespaces incrementally
+	const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
+	if (is_inline_namespace_CPP(active_namespace,active_namespace_len))
+		{
+		zaimoni::autovalarray_ptr_throws<char*> namespace_tmp(extra_namespaces);
+#ifndef ZAIMONI_NULL_REALLY_IS_ZERO
+#error need to null-initialize pointers for namespace_tmp
+#endif
+		bool can_be_completely_gone = false;
+		{
+		zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
+		if (extra_namespaces)
+			{
+			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				if (!is_inline_namespace_CPP(active_namespace,i==extra_namespaces ? active_namespace_len : intra_namespace[i]-active_namespace))
+					break;
+				--i;
+				namespace_tmp[i] = _namespace_concatenate(name,name_len,active_namespace,intra_namespace[i]-active_namespace,"::",2);
+				}
+			while(0<i);
+			can_be_completely_gone = (0==i && is_inline_namespace_CPP(active_namespace,intra_namespace[0]-active_namespace));
+			if (0<i) namespace_tmp.DeleteNSlotsAt(i,0);
+			}
+		else{
+			can_be_completely_gone = true;
+			}
+		}
+		assert(can_be_completely_gone || !namespace_tmp.empty());
+
+		size_t origin = inline_namespace_alias_map.size();
+		size_t origin2 = inline_namespace_alias_targets.size();
+		inline_namespace_alias_targets.resize(origin2+1);
+		try	{
+			inline_namespace_alias_map.resize(origin+namespace_tmp.size()+can_be_completely_gone);
+			}
+		catch(std::bad_alloc& e)
+			{
+			inline_namespace_alias_targets.resize(origin2);
+			throw;
+			}
+
+		retval = register_string(retval_tmp);	//! \todo would prefer to consume the string; changes reset() to NULLPtr() to be safe
+		retval_tmp.reset();
+		/* do a downward insertsort against the second index*/
+		while(origin2 && 1==strcmp(inline_namespace_alias_targets.c_array()[origin2-1],retval))
+			{
+			inline_namespace_alias_targets.c_array()[origin2] = inline_namespace_alias_targets.c_array()[origin2-1];
+			--origin2;
+			};
+		inline_namespace_alias_targets.c_array()[origin2] = retval;
+
+		size_t i = namespace_tmp.size();
+		while(0<i)
+			{
+			const zaimoni::POD_pair<const char*,const char*> tmp = {register_string(namespace_tmp[--i]), retval};
+			size_t j = origin;
+			while(j && 1==strcmp(inline_namespace_alias_map.c_array()[j-1].first,tmp.first))
+				{
+				inline_namespace_alias_map.c_array()[j] = inline_namespace_alias_map.c_array()[j-1];
+				--j;
+				};
+			inline_namespace_alias_map.c_array()[origin++] = tmp;
+			free(namespace_tmp[i]);
+			namespace_tmp[i] = NULL;
+			};
+		if (can_be_completely_gone)
+			{
+			const zaimoni::POD_pair<const char*,const char*> tmp = {register_substring(name,name_len), retval};
+			size_t j = origin;
+			while(j && 1==strcmp(inline_namespace_alias_map.c_array()[j-1].first,tmp.first))
+				{
+				inline_namespace_alias_map.c_array()[j] = inline_namespace_alias_map.c_array()[j-1];
+				--j;
+				};
+			inline_namespace_alias_map.c_array()[origin++] = tmp;
+			}
+		}
+
+	if (!retval)
+		{
+		retval = register_string(retval_tmp);	//! \todo would prefer to consume the string; changes reset() to NULLPtr() to be safe
+		retval_tmp.reset();
+		};
+	// return the canonical name
+	return retval;
+}
+
 type_system::type_index type_system::register_functype(const char* const alias, function_type*& src)
 {
 	assert(alias && *alias);

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2009-11-30 03:54:09 UTC (rev 290)
+++ trunk/type_system.hpp	2009-11-30 06:03:15 UTC (rev 291)
@@ -26,6 +26,7 @@
 	typedef zaimoni::POD_triple<const char*,size_t,zaimoni::POD_pair<zaimoni::union_quartet<function_type*,union_struct_decl*,C_union_struct_def*,enum_def*>, unsigned char> > dynamic_type_format;
 	zaimoni::autovalarray_ptr<dynamic_type_format> dynamic_types;
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> > > typedef_registry;
+	zaimoni::weakautovalarray_ptr<const char*> inline_namespace_alias_targets;
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,const char*> > inline_namespace_alias_map;
 	// uncopyable
 	type_system(const type_system& src);
@@ -110,6 +111,7 @@
 
 
 	void set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec& src);	// invalidates src
+	void set_typedef_CPP(const char* const name, const char* const active_namespace, const char* filename, const size_t lineno, type_spec& src);	// invalidates src
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* get_typedef(const char* const alias) const;
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* get_typedef_CPP(const char* alias,const char* active_namespace) const;
 
@@ -129,6 +131,11 @@
 	const char* _name(type_index id) const;
 	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> dealias_inline_namespace_index(const char* alias) const;
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* _get_typedef_CPP(const char* alias) const;
+
+	bool is_inline_namespace_CPP(const char* active_namespace, size_t active_namespace_len) const;
+	const char* canonical_name_is_inline_namespace_alias_target(const char* name, size_t name_len, const char* active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len) const;
+	const char* construct_canonical_name_and_aliasing_CPP(const char* name, size_t name_len, const char* active_namespace, size_t active_namespace_len);
+
 	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
 	static char* _namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
 	static void _namespace_concatenate(char* buf, const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);



