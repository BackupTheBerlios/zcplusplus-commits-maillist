<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Zcplusplus-commits] r307 - trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/zcplusplus-commits/2009-December/index.html" >
   <LINK REL="made" HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r307%20-%20trunk&In-Reply-To=%3C200912102148.nBALmoR8003665%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000073.html">
   <LINK REL="Next"  HREF="000075.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Zcplusplus-commits] r307 - trunk</H1>
    <B>zaimoni at mail.berlios.de</B> 
    <A HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r307%20-%20trunk&In-Reply-To=%3C200912102148.nBALmoR8003665%40sheep.berlios.de%3E"
       TITLE="[Zcplusplus-commits] r307 - trunk">zaimoni at mail.berlios.de
       </A><BR>
    <I>Thu Dec 10 22:48:50 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000073.html">[Zcplusplus-commits] r306 - in trunk/Zaimoni.STL: . LexParse
</A></li>
        <LI>Next message: <A HREF="000075.html">[Zcplusplus-commits] r308 - in trunk/Zaimoni.STL: . Pure.C
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#74">[ date ]</a>
              <a href="thread.html#74">[ thread ]</a>
              <a href="subject.html#74">[ subject ]</a>
              <a href="author.html#74">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zaimoni
Date: 2009-12-10 22:48:47 +0100 (Thu, 10 Dec 2009)
New Revision: 307

Modified:
   trunk/CSupport.cpp
Log:
object file size reduction, some format tweaks

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-12-09 11:37:37 UTC (rev 306)
+++ trunk/CSupport.cpp	2009-12-10 21:48:47 UTC (rev 307)
@@ -5154,6 +5154,7 @@
 
 // can't do much syntax-checking or immediate-evaluation here because of binary +/-
 // unary +/- syntax checking out out of place as it's needed by all of the unary operators
+// return code is true for success, false for memory failure
 static bool VM_to_token(const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; src_int,const size_t base_type_index,POD_pair&lt;char*,lex_flags&gt;&amp; dest)
 {
 	const char* const suffix = literal_suffix(base_type_index);
@@ -5171,6 +5172,7 @@
 	return true;
 }
 
+// return code is true for success, false for memory failure
 static bool VM_to_literal(parse_tree&amp; dest, const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; src_int,const parse_tree&amp; src,const type_system&amp; types)
 {
 	POD_pair&lt;char*,lex_flags&gt; new_token;
@@ -6029,7 +6031,7 @@
 {
 	assert(1&lt;=i &amp;&amp; 2&lt;=src.size&lt;0&gt;()-i);
 	{
-	parse_tree* tmp_c_array = src.c_array&lt;0&gt;()+(i-1);
+	parse_tree* const tmp_c_array = src.c_array&lt;0&gt;()+(i-1);
 	parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
 	*tmp = tmp_c_array[0];
 	parse_tree* const tmp2 = repurpose_inner_parentheses(tmp_c_array[2]);	// RAM conservation
@@ -6053,7 +6055,7 @@
 {
 	assert(1&lt;=i);
 	{
-	parse_tree* tmp_c_array = src.c_array&lt;0&gt;()+(i-1);
+	parse_tree* const tmp_c_array = src.c_array&lt;0&gt;()+(i-1);
 	parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
 	*tmp = tmp_c_array[0];
 
@@ -6635,6 +6637,7 @@
 		CPP_mult_expression_easy_syntax_check(src.c_array&lt;0&gt;()[i],types);
 }
 
+// Law of Demeter conversion is object-size neutral [Dec. 9 2009], so don't do it
 static bool C_string_literal_equal_content(const parse_tree&amp; lhs, const parse_tree&amp; rhs,bool&amp; is_equal)
 {
 	if (C_TESTFLAG_STRING_LITERAL==lhs.index_tokens[0].flags &amp;&amp; C_TESTFLAG_STRING_LITERAL==rhs.index_tokens[0].flags)
@@ -6730,15 +6733,17 @@
 	if (add_subtype)
 		{
 		if (1&gt;i || 2&gt;src.size&lt;0&gt;()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i+1]);
-		if (	(PARSE_ADD_EXPRESSION &amp; src.data&lt;0&gt;()[i-1].flags)
-			&amp;&amp;	(PARSE_MULT_EXPRESSION &amp; src.data&lt;0&gt;()[i+1].flags))
+		parse_tree* const tmp_c_array = src.c_array&lt;0&gt;()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_ADD_EXPRESSION &amp; tmp_c_array[0].flags)
+			&amp;&amp;	(PARSE_MULT_EXPRESSION &amp; tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_ADD_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_ADD_EXPRESSION);	// tmp_c_array goes invalid here
 			assert(is_C99_add_operator_expression(src.data&lt;0&gt;()[i]));
-			src.c_array&lt;0&gt;()[i].subtype = add_subtype;
-			src.c_array&lt;0&gt;()[i].type_code.set_type(0);	// handle type inference later
+			parse_tree&amp; tmp = src.c_array&lt;0&gt;()[i];
+			tmp.subtype = add_subtype;
+			tmp.type_code.set_type(0);	// handle type inference later
 			assert(is_C99_add_operator_expression(src.data&lt;0&gt;()[i]));
 			return true;
 			}
@@ -6747,6 +6752,7 @@
 }
 
 // this one hides a slight inefficiency: negative literals take 2 dynamic memory allocations, positive literals take one
+// return code is true for success, false for memory failure
 static bool VM_to_signed_literal(parse_tree&amp; x,const bool is_negative, const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; src_int,const parse_tree&amp; src,const type_system&amp; types)
 {
 	if (is_negative)
@@ -7288,15 +7294,17 @@
 	if (shift_subtype)
 		{
 		if (1&gt;i || 2&gt;src.size&lt;0&gt;()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i+1]);
-		if (	(PARSE_SHIFT_EXPRESSION &amp; src.data&lt;0&gt;()[i-1].flags)
-			&amp;&amp;	(PARSE_ADD_EXPRESSION &amp; src.data&lt;0&gt;()[i+1].flags))
+		parse_tree* const tmp_c_array = src.c_array&lt;0&gt;()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_SHIFT_EXPRESSION &amp; tmp_c_array[0].flags)
+			&amp;&amp;	(PARSE_ADD_EXPRESSION &amp; tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_SHIFT_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_SHIFT_EXPRESSION);	// tmp_c_array goes invalid here
 			assert(is_C99_shift_expression(src.data&lt;0&gt;()[i]));
-			src.c_array&lt;0&gt;()[i].subtype = shift_subtype;
-			src.c_array&lt;0&gt;()[i].type_code.set_type(0);	// handle type inference later
+			parse_tree&amp; tmp = src.c_array&lt;0&gt;()[i];
+			tmp.subtype = shift_subtype;
+			tmp.type_code.set_type(0);	// handle type inference later
 			assert(is_C99_shift_expression(src.data&lt;0&gt;()[i]));
 			return true;
 			}
@@ -7457,15 +7465,17 @@
 	if (rel_subtype)
 		{
 		if (1&gt;i || 2&gt;src.size&lt;0&gt;()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i+1]);
-		if (	(PARSE_SHIFT_EXPRESSION &amp; src.data&lt;0&gt;()[i-1].flags)
-			&amp;&amp;	(PARSE_ADD_EXPRESSION &amp; src.data&lt;0&gt;()[i+1].flags))
+		parse_tree* const tmp_c_array = src.c_array&lt;0&gt;()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_SHIFT_EXPRESSION &amp; tmp_c_array[0].flags)
+			&amp;&amp;	(PARSE_ADD_EXPRESSION &amp; tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_RELATIONAL_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_RELATIONAL_EXPRESSION);	// tmp_c_array goes invalid here
 			assert(is_C99_relation_expression(src.data&lt;0&gt;()[i]));
-			src.c_array&lt;0&gt;()[i].subtype = rel_subtype;
-			src.c_array&lt;0&gt;()[i].type_code.set_type(C_TYPE::BOOL);
+			parse_tree&amp; tmp = src.c_array&lt;0&gt;()[i];
+			tmp.subtype = rel_subtype;
+			tmp.type_code.set_type(C_TYPE::BOOL);
 			assert(is_C99_relation_expression(src.data&lt;0&gt;()[i]));
 			return true;
 			}
@@ -7613,15 +7623,17 @@
 	if (eq_subtype)
 		{
 		if (1&gt;i || 2&gt;src.size&lt;0&gt;()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i+1]);
-		if (	(PARSE_EQUALITY_EXPRESSION &amp; src.data&lt;0&gt;()[i-1].flags)
-			&amp;&amp;	(PARSE_RELATIONAL_EXPRESSION &amp; src.data&lt;0&gt;()[i+1].flags))
+		parse_tree* const tmp_c_array = src.c_array&lt;0&gt;()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_EQUALITY_EXPRESSION &amp; tmp_c_array[0].flags)
+			&amp;&amp;	(PARSE_RELATIONAL_EXPRESSION &amp; tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_EQUALITY_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_EQUALITY_EXPRESSION);	// tmp_c_array becomes invalid here
 			assert(is_C99_equality_expression(src.data&lt;0&gt;()[i]));
-			src.c_array&lt;0&gt;()[i].subtype = eq_subtype;
-			src.c_array&lt;0&gt;()[i].type_code.set_type(C_TYPE::BOOL);
+			parse_tree&amp; tmp = src.c_array&lt;0&gt;()[i];
+			tmp.subtype = eq_subtype;
+			tmp.type_code.set_type(C_TYPE::BOOL);
 			assert(is_C99_equality_expression(src.data&lt;0&gt;()[i]));
 			return true;
 			}
@@ -7642,15 +7654,17 @@
 	if (eq_subtype)
 		{
 		if (1&gt;i || 2&gt;src.size&lt;0&gt;()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i+1]);
-		if (	(PARSE_EQUALITY_EXPRESSION &amp; src.data&lt;0&gt;()[i-1].flags)
-			&amp;&amp;	(PARSE_RELATIONAL_EXPRESSION &amp; src.data&lt;0&gt;()[i+1].flags))
+		parse_tree* const tmp_c_array = src.c_array&lt;0&gt;()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_EQUALITY_EXPRESSION &amp; tmp_c_array[0].flags)
+			&amp;&amp;	(PARSE_RELATIONAL_EXPRESSION &amp; tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_EQUALITY_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_EQUALITY_EXPRESSION);	// tmp_c_array becomes invalid here
 			assert(is_CPP_equality_expression(src.data&lt;0&gt;()[i]));
-			src.c_array&lt;0&gt;()[i].subtype = eq_subtype;
-			src.c_array&lt;0&gt;()[i].type_code.set_type(C_TYPE::BOOL);
+			parse_tree&amp; tmp = src.c_array&lt;0&gt;()[i];
+			tmp.subtype = eq_subtype;
+			tmp.type_code.set_type(C_TYPE::BOOL);
 			assert(is_CPP_equality_expression(src.data&lt;0&gt;()[i]));
 			return true;
 			}
@@ -7731,10 +7745,13 @@
 			assert(old.bitcount&gt;=rhs.bitcount);
 			const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data&lt;1&gt;());
 			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;());
-			const bool lhs_negative = lhs_converted &amp;&amp; target_machine-&gt;C_promote_integer(lhs_int,lhs,old);
-			const bool rhs_negative = rhs_converted &amp;&amp; target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
+			// general case here in case we try to do with converted/not converted mixed cases
+//			if (lhs_converted) target_machine-&gt;C_promote_integer(lhs_int,lhs,old);
+//			if (rhs_converted) target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
 			if (lhs_converted &amp;&amp; rhs_converted)
 				{
+				target_machine-&gt;C_promote_integer(lhs_int,lhs,old);
+				target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
 				force_decimal_literal(src,(lhs_int==rhs_int)==is_equal_op ? &quot;1&quot; : &quot;0&quot;,types);
 				return true;
 				};
@@ -7839,15 +7856,16 @@
 	assert(src.data&lt;0&gt;()[i].is_atomic());
 
 	//! \todo deal with unary &amp; parses
-	if (token_is_char&lt;'&amp;'&gt;(src.data&lt;0&gt;()[i].index_tokens[0].token))
+	parse_tree* const tmp_c_array = src.c_array&lt;0&gt;()+(i-1);
+	if (token_is_char&lt;'&amp;'&gt;(tmp_c_array[1].index_tokens[0].token))
 		{
 		if (1&gt;i || 2&gt;src.size&lt;0&gt;()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i+1]);
-		if (	(PARSE_BITAND_EXPRESSION &amp; src.data&lt;0&gt;()[i-1].flags)
-			&amp;&amp;	(PARSE_EQUALITY_EXPRESSION &amp; src.data&lt;0&gt;()[i+1].flags))
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_BITAND_EXPRESSION &amp; tmp_c_array[0].flags)
+			&amp;&amp;	(PARSE_EQUALITY_EXPRESSION &amp; tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITAND_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITAND_EXPRESSION);	// tmp_c_array becomes invalid here
 			assert(is_C99_bitwise_AND_expression(src.data&lt;0&gt;()[i]));
 			src.c_array&lt;0&gt;()[i].type_code.set_type(0);	// handle type inference later
 			assert(is_C99_bitwise_AND_expression(src.data&lt;0&gt;()[i]));
@@ -8013,15 +8031,16 @@
 	assert(!(PARSE_OBVIOUS &amp; src.data&lt;0&gt;()[i].flags));
 	assert(src.data&lt;0&gt;()[i].is_atomic());
 
-	if (token_is_char&lt;'^'&gt;(src.data&lt;0&gt;()[i].index_tokens[0].token))
+	parse_tree* const tmp_c_array = src.c_array&lt;0&gt;()+(i-1);
+	if (token_is_char&lt;'^'&gt;(tmp_c_array[1].index_tokens[0].token))
 		{
 		if (1&gt;i || 2&gt;src.size&lt;0&gt;()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i+1]);
-		if (	(PARSE_BITXOR_EXPRESSION &amp; src.data&lt;0&gt;()[i-1].flags)
-			&amp;&amp;	(PARSE_BITAND_EXPRESSION &amp; src.data&lt;0&gt;()[i+1].flags))
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_BITXOR_EXPRESSION &amp; tmp_c_array[0].flags)
+			&amp;&amp;	(PARSE_BITAND_EXPRESSION &amp; tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITXOR_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITXOR_EXPRESSION);	// tmp_c_array becomes invalid here
 			assert(is_C99_bitwise_XOR_expression(src.data&lt;0&gt;()[i]));
 			src.c_array&lt;0&gt;()[i].type_code.set_type(0);	// handle type inference later
 			assert(is_C99_bitwise_XOR_expression(src.data&lt;0&gt;()[i]));
@@ -8180,15 +8199,16 @@
 	assert(!(PARSE_OBVIOUS &amp; src.data&lt;0&gt;()[i].flags));
 	assert(src.data&lt;0&gt;()[i].is_atomic());
 
-	if (token_is_char&lt;'|'&gt;(src.data&lt;0&gt;()[i].index_tokens[0].token))
+	parse_tree* const tmp_c_array = src.c_array&lt;0&gt;()+(i-1);
+	if (token_is_char&lt;'|'&gt;(tmp_c_array[1].index_tokens[0].token))
 		{
 		if (1&gt;i || 2&gt;src.size&lt;0&gt;()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i+1]);
-		if (	(PARSE_BITOR_EXPRESSION &amp; src.data&lt;0&gt;()[i-1].flags)
-			&amp;&amp;	(PARSE_BITXOR_EXPRESSION &amp; src.data&lt;0&gt;()[i+1].flags))
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_BITOR_EXPRESSION &amp; tmp_c_array[0].flags)
+			&amp;&amp;	(PARSE_BITXOR_EXPRESSION &amp; tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITOR_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITOR_EXPRESSION);	// tmp_c_array becomes invalid here
 			assert(is_C99_bitwise_OR_expression(src.data&lt;0&gt;()[i]));
 			src.c_array&lt;0&gt;()[i].type_code.set_type(0);	// handle type inference later
 			assert(is_C99_bitwise_OR_expression(src.data&lt;0&gt;()[i]));
@@ -8323,7 +8343,8 @@
 		|| !src.data&lt;0&gt;()[i].is_atomic())
 		return;
 
-	if (terse_locate_C99_bitwise_OR(src,i)) C_bitwise_OR_easy_syntax_check(src.c_array&lt;0&gt;()[i],types);
+	if (terse_locate_C99_bitwise_OR(src,i))
+		C_bitwise_OR_easy_syntax_check(src.c_array&lt;0&gt;()[i],types);
 }
 
 /*
@@ -8370,15 +8391,16 @@
 	assert(!(PARSE_OBVIOUS &amp; src.data&lt;0&gt;()[i].flags));
 	assert(src.data&lt;0&gt;()[i].is_atomic());
 
-	if (token_is_string&lt;2&gt;(src.data&lt;0&gt;()[i].index_tokens[0].token,&quot;&amp;&amp;&quot;))
+	parse_tree* const tmp_c_array = src.c_array&lt;0&gt;()+(i-1);
+	if (token_is_string&lt;2&gt;(tmp_c_array[1].index_tokens[0].token,&quot;&amp;&amp;&quot;))
 		{
 		if (1&gt;i || 2&gt;src.size&lt;0&gt;()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i+1]);
-		if (	(PARSE_LOGICAND_EXPRESSION &amp; src.data&lt;0&gt;()[i-1].flags)
-			&amp;&amp;	(PARSE_BITOR_EXPRESSION &amp; src.data&lt;0&gt;()[i+1].flags))
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_LOGICAND_EXPRESSION &amp; tmp_c_array[0].flags)
+			&amp;&amp;	(PARSE_BITOR_EXPRESSION &amp; tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_LOGICAND_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_LOGICAND_EXPRESSION);	// tmp_c_array becomes invalid here
 			assert(is_C99_logical_AND_expression(src.data&lt;0&gt;()[i]));
 			src.c_array&lt;0&gt;()[i].type_code.set_type(C_TYPE::BOOL);	// technically wrong, but range is correct
 			assert(is_C99_logical_AND_expression(src.data&lt;0&gt;()[i]));
@@ -8484,7 +8506,8 @@
 		|| !src.data&lt;0&gt;()[i].is_atomic())
 		return;
 
-	if (terse_locate_C99_logical_AND(src,i)) C_logical_AND_easy_syntax_check(src.c_array&lt;0&gt;()[i],types);
+	if (terse_locate_C99_logical_AND(src,i))
+		C_logical_AND_easy_syntax_check(src.c_array&lt;0&gt;()[i],types);
 }
 
 /*
@@ -8512,15 +8535,16 @@
 	assert(!(PARSE_OBVIOUS &amp; src.data&lt;0&gt;()[i].flags));
 	assert(src.data&lt;0&gt;()[i].is_atomic());
 
-	if (token_is_string&lt;2&gt;(src.data&lt;0&gt;()[i].index_tokens[0].token,&quot;||&quot;))
+	parse_tree* const tmp_c_array = src.c_array&lt;0&gt;()+(i-1);
+	if (token_is_string&lt;2&gt;(tmp_c_array[1].index_tokens[0].token,&quot;||&quot;))
 		{
 		if (1&gt;i || 2&gt;src.size&lt;0&gt;()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i+1]);
-		if (	(PARSE_LOGICOR_EXPRESSION &amp; src.data&lt;0&gt;()[i-1].flags)
-			&amp;&amp;	(PARSE_LOGICAND_EXPRESSION &amp; src.data&lt;0&gt;()[i+1].flags))
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_LOGICOR_EXPRESSION &amp; tmp_c_array[0].flags)
+			&amp;&amp;	(PARSE_LOGICAND_EXPRESSION &amp; tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_LOGICOR_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_LOGICOR_EXPRESSION);	// tmp_c_array becomes invalid here
 			assert(is_C99_logical_OR_expression(src.data&lt;0&gt;()[i]));
 			src.c_array&lt;0&gt;()[i].type_code.set_type(C_TYPE::BOOL);	// technically wrong, but range is correct
 			assert(is_C99_logical_OR_expression(src.data&lt;0&gt;()[i]));
@@ -8657,39 +8681,41 @@
 		{
 		// ? as first might be space deficiency (check uniqueness of construction)
 		if (1&gt;i || 3&gt;src.size&lt;0&gt;()-i) return false;
-		if (	src.data&lt;0&gt;()[i+2].is_atomic()
-			&amp;&amp;	token_is_char&lt;':'&gt;(src.data&lt;0&gt;()[i+2].index_tokens[0].token))
+		parse_tree* const tmp_c_array = src.c_array&lt;0&gt;()+(i-1);
+		if (	tmp_c_array[3].is_atomic()
+			&amp;&amp;	token_is_char&lt;':'&gt;(tmp_c_array[3].index_tokens[0].token))
 			{
-			inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i-1]);
-			inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i+1]);
-			inspect_potential_paren_primary_expression(src.c_array&lt;0&gt;()[i+3]);
+			inspect_potential_paren_primary_expression(tmp_c_array[0]);
+			inspect_potential_paren_primary_expression(tmp_c_array[2]);
+			inspect_potential_paren_primary_expression(tmp_c_array[4]);
 			if (	(PARSE_LOGICOR_EXPRESSION &amp; src.data&lt;0&gt;()[i-1].flags)
 				&amp;&amp;	(PARSE_EXPRESSION &amp; src.data&lt;0&gt;()[i+1].flags)
 				&amp;&amp;	(PARSE_CONDITIONAL_EXPRESSION &amp; src.data&lt;0&gt;()[i+3].flags))
 				{
-				parse_tree* const tmp = repurpose_inner_parentheses(src.c_array&lt;0&gt;()[i-1]);	// RAM conservation
-				*tmp = src.data&lt;0&gt;()[i-1];
-				parse_tree* const tmp2 = repurpose_inner_parentheses(src.c_array&lt;0&gt;()[i+1]);	// RAM conservation
-				*tmp2 = src.data&lt;0&gt;()[i+1];
-				parse_tree* const tmp3 = repurpose_inner_parentheses(src.c_array&lt;0&gt;()[i+3]);	// RAM conservation
-				*tmp3 = src.data&lt;0&gt;()[i+3];
-				src.c_array&lt;0&gt;()[i].grab_index_token_from&lt;1,0&gt;(src.c_array&lt;0&gt;()[i+2]);
-				src.c_array&lt;0&gt;()[i].grab_index_token_location_from&lt;1,0&gt;(src.c_array&lt;0&gt;()[i+2]);
-				src.c_array&lt;0&gt;()[i].fast_set_arg&lt;0&gt;(tmp2);
-				src.c_array&lt;0&gt;()[i].fast_set_arg&lt;1&gt;(tmp);
-				src.c_array&lt;0&gt;()[i].fast_set_arg&lt;2&gt;(tmp3);
-				src.c_array&lt;0&gt;()[i].core_flag_update();
-				src.c_array&lt;0&gt;()[i].flags |= PARSE_STRICT_CONDITIONAL_EXPRESSION;
-				src.c_array&lt;0&gt;()[i-1].clear();
-				src.c_array&lt;0&gt;()[i+1].clear();
-				src.c_array&lt;0&gt;()[i+2].clear();
-				src.c_array&lt;0&gt;()[i+3].clear();
-				src.DeleteNSlotsAt&lt;0&gt;(3,i+1);
+				parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
+				*tmp = tmp_c_array[0];
+				parse_tree* const tmp2 = repurpose_inner_parentheses(tmp_c_array[2]);	// RAM conservation
+				*tmp2 = tmp_c_array[2];
+				parse_tree* const tmp3 = repurpose_inner_parentheses(tmp_c_array[4]);	// RAM conservation
+				*tmp3 = tmp_c_array[4];
+				tmp_c_array[1].grab_index_token_from&lt;1,0&gt;(tmp_c_array[3]);
+				tmp_c_array[1].grab_index_token_location_from&lt;1,0&gt;(tmp_c_array[3]);
+				tmp_c_array[1].fast_set_arg&lt;0&gt;(tmp2);
+				tmp_c_array[1].fast_set_arg&lt;1&gt;(tmp);
+				tmp_c_array[1].fast_set_arg&lt;2&gt;(tmp3);
+				tmp_c_array[1].core_flag_update();
+				tmp_c_array[1].flags |= PARSE_STRICT_CONDITIONAL_EXPRESSION;
+				tmp_c_array[0].clear();
+				tmp_c_array[2].clear();
+				tmp_c_array[3].clear();
+				tmp_c_array[4].clear();
+				src.DeleteNSlotsAt&lt;0&gt;(3,i+1);	// tmp_c_array becomes invalid here
 				src.DeleteIdx&lt;0&gt;(--i);
 				assert(is_C99_conditional_operator_expression_strict(src.data&lt;0&gt;()[i]));
-				cancel_outermost_parentheses(src.c_array&lt;0&gt;()[i].c_array&lt;0&gt;()[0]);
-				cancel_outermost_parentheses(src.c_array&lt;0&gt;()[i].c_array&lt;1&gt;()[0]);
-				cancel_outermost_parentheses(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0]);
+				parse_tree&amp; tmp4 = src.c_array&lt;0&gt;()[i];
+				cancel_outermost_parentheses(tmp4.front&lt;0&gt;());
+				cancel_outermost_parentheses(tmp4.front&lt;1&gt;());
+				cancel_outermost_parentheses(tmp4.front&lt;2&gt;());
 				assert(is_C99_conditional_operator_expression(src.data&lt;0&gt;()[i]));
 				return true;
 				}
@@ -8921,46 +8947,6 @@
 	if (terse_locate_conditional_op(src,i)) CPP_conditional_op_easy_syntax_check(src.c_array&lt;0&gt;()[i],types);
 }
 
-#if 0
-static bool terse_locate_x(parse_tree&amp; src, size_t&amp; i)
-{
-	assert(!src.empty&lt;0&gt;());
-	assert(i&lt;src.size&lt;0&gt;());
-	assert(!(PARSE_OBVIOUS &amp; src.data&lt;0&gt;()[i].flags));
-	assert(src.data&lt;0&gt;()[i].is_atomic());
-}
-
-static void C_x_easy_syntax_check(parse_tree&amp; src,const type_system&amp; types)
-{
-}
-
-static void CPP_x_easy_syntax_check(parse_tree&amp; src,const type_system&amp; types)
-{
-}
-
-static void locate_C99_x(parse_tree&amp; src, size_t&amp; i, const type_system&amp; types)
-{
-	assert(!src.empty&lt;0&gt;());
-	assert(i&lt;src.size&lt;0&gt;());
-	if (   (PARSE_OBVIOUS &amp; src.data&lt;0&gt;()[i].flags)
-		|| !src.data&lt;0&gt;()[i].is_atomic())
-		return;
-
-	if (terse_locate_x(src,i)) C_x_easy_syntax_check(src.c_array&lt;0&gt;()[i],types);
-}
-
-static void locate_CPP_x(parse_tree&amp; src, size_t&amp; i, const type_system&amp; types)
-{
-	assert(!src.empty&lt;0&gt;());
-	assert(i&lt;src.size&lt;0&gt;());
-	if (   (PARSE_OBVIOUS &amp; src.data&lt;0&gt;()[i].flags)
-		|| !src.data&lt;0&gt;()[i].is_atomic())
-		return;
-
-	if (terse_locate_x(src,i)) CPP_x_easy_syntax_check(src.c_array&lt;0&gt;()[i],types);
-}
-#endif
-
 template&lt;class T&gt;
 static void parse_forward(parse_tree&amp; src,const type_system&amp; types, T parse_handler)
 {
@@ -9208,7 +9194,7 @@
 	return false;
 }
 
-void CPP_notice_scope_glue(parse_tree&amp; src)
+static void CPP_notice_scope_glue(parse_tree&amp; src)
 {
 	assert(!src.empty&lt;0&gt;());
 	size_t i = 0;
@@ -9301,23 +9287,24 @@
 	i = 0;
 	while(i&lt;src.size&lt;0&gt;())
 		{
-		if (is_naked_parentheses_pair(src.data&lt;0&gt;()[i]))
+		parse_tree&amp; tmp = src.c_array&lt;0&gt;()[i];
+		if (is_naked_parentheses_pair(tmp))
 			{
-			if (!src.data&lt;0&gt;()[i].empty&lt;0&gt;())
+			if (!tmp.empty&lt;0&gt;())
 				// recurse into (...)
-				CPP_notice_scope_glue(src.c_array&lt;0&gt;()[i]);
+				CPP_notice_scope_glue(tmp);
 			}
-		else if (is_naked_brace_pair(src.data&lt;0&gt;()[i]))
+		else if (is_naked_brace_pair(tmp))
 			{
-			if (!src.data&lt;0&gt;()[i].empty&lt;0&gt;())
+			if (!tmp.empty&lt;0&gt;())
 				// recurse into {...}
-				CPP_notice_scope_glue(src.c_array&lt;0&gt;()[i]);
+				CPP_notice_scope_glue(tmp);
 			}
-		else if (is_naked_bracket_pair(src.data&lt;0&gt;()[i]))
+		else if (is_naked_bracket_pair(tmp))
 			{
-			if (!src.data&lt;0&gt;()[i].empty&lt;0&gt;())
+			if (!tmp.empty&lt;0&gt;())
 				// recurse into [...]
-				CPP_notice_scope_glue(src.c_array&lt;0&gt;()[i]);
+				CPP_notice_scope_glue(tmp);
 			}
 		++i;
 		};
@@ -11114,72 +11101,6 @@
 					return;
 					};
 				//! \todo function declarations can be self-terminating
-#if 0
-				if (   initdecl_identifier_idx==i+decl_count+decl_offset-1
-					&amp;&amp; is_naked_parentheses_pair(src.data&lt;0&gt;()[i+decl_count+decl_offset]))
-					{	// function declaration or function definition intended
-					if (src.size&lt;0&gt;()-(i+decl_count+decl_offset)&lt;=1)
-						{	// unterminated declaration
-							//! \bug needs test case
-						if (src.size&lt;0&gt;()&gt;i) message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-						INC_INFORM(ERR_STR);
-						INFORM(&quot;declaration cut off by end of scope (C99 6.7p1)&quot;);
-						zcc_errors.inc_error();
-						// remove from parse
-						if (src.size&lt;0&gt;()&gt;i)
-							src.DeleteNSlotsAt&lt;0&gt;(decl_count+decl_offset,i);
-						return;
-						};
-					// build function type here
-					size_t j = src.data&lt;0&gt;()[i+decl_count+decl_offset].size&lt;0&gt;();
-					const bool is_varadic = !j || (src.data&lt;0&gt;()[i+decl_count+decl_offset].back&lt;0&gt;().is_atomic()
-												&amp;&amp; token_is_string&lt;3&gt;(src.data&lt;0&gt;()[i+decl_count+decl_offset].back&lt;0&gt;(),&quot;...&quot;));
-					const bool is_zeroary = 1==j &amp;&amp; src.data&lt;0&gt;()[i+decl_count+decl_offset].back&lt;0&gt;().is_atomic() &amp;&amp; token_is_string&lt;4&gt;(src.data&lt;0&gt;()[i+decl_count+decl_offset].back&lt;0&gt;(),&quot;void&quot;);
-					const bool have_identifier_list = is_identifier_list(src.data&lt;0&gt;()[i+decl_count+decl_offset]);
-					size_t comma_count = 0;
-					{
-					while(0&lt;j) comma_count += robust_token_is_char&lt;','&gt;(src.data&lt;0&gt;()[i+decl_count+decl_offset].data&lt;0&gt;()[--j].index_tokens[0].token);
-					}
-					zaimoni::autovalarray_ptr_throws&lt;size_t&gt; comma_positions(comma_count);
-					if (0&lt;comma_count)
-						{
-						size_t offset = comma_count;
-						j = src.data&lt;0&gt;()[i+decl_count+decl_offset].size&lt;0&gt;();
-						while(0&lt;j)
-							if (robust_token_is_char&lt;','&gt;(src.data&lt;0&gt;()[i+decl_count+decl_offset].data&lt;0&gt;()[--j].index_tokens[0].token))
-								comma_positions[--offset] = j;
-						assert(0==offset);
-						assert(0&lt;comma_positions.front());
-						assert(2&lt;=src.data&lt;0&gt;()[i+decl_count+decl_offset].size&lt;0&gt;()-comma_positions.back());
-						}
-					// identifier-lists are disallowed outside of full definitions
-
-					function_type want_this_type(is_zeroary ? 0 : is_varadic ? comma_count : comma_count+1,is_varadic);
-					{
-					type_spec tmp;
-					tmp.clear();
-					declFind.value_copy_type(tmp);
-					//! \bug need to reject function types and arrays as return type
-					want_this_type.movein_result_type(tmp);
-					}
-					// other parameter types; note that the parameter names have to be isolated for later
-					j = want_this_type.size();
-					zaimoni::weakautoarray_ptr_throws&lt;size_t&gt; names_temp(j+is_varadic);
-					if (is_varadic) names_temp.back() = &quot;...&quot;;
-					while(0&lt;j)
-						{
-						};
-
-					// function attributes would go here
-					if (robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+decl_count+decl_offset+1]))
-						{	// function declaration; discard names_temp
-							// check that any prior declarations are consistent
-						};
-					if (is_naked_brace_pair(src.data&lt;0&gt;()[i+decl_count+decl_offset+1]))
-						{	// function definition; need names_temp; also must locate any prior declarations
-						};					
-					}
-#endif
 				// ;: done
 				if (robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+decl_count+decl_offset]))
 					{
@@ -11267,367 +11188,364 @@
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// check naked declarations first; handle namespaces later
 		//! \bug indentation fixup needed (stage 3)
-//		if (NULL==active_namespace)
-//			{
-			if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
+		if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
+			{
+			type_system::type_index tmp = types.get_id_union_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
+			}
+		else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
+			{
+			type_system::type_index tmp = types.get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
+			}
+		else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;class&quot;))
+			{
+			type_system::type_index tmp = types.get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
+			}
+		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;union&quot;))
+			{	// can only define once
+			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
+			const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
+			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_union(fullname));
+			if (tmp)
+				{	//! \test zcc/decl.C99/Error_union_multidef.hpp
+				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM(&quot;'union &quot;);
+				INC_INFORM(fullname);
+				free(namespace_name);
+				INFORM(&quot;' already defined (C++98 3.2p1)&quot;);
+				message_header(*tmp);
+				INFORM(&quot;prior definition here&quot;);
+				zcc_errors.inc_error();
+				// now it's gone
+				// remove trailing semicolon if present
+				src.DeleteNSlotsAt&lt;0&gt;((1&lt;src.size&lt;0&gt;()-i &amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1])) ? 2 : 1,i);
+				continue;
+				}
+			free(namespace_name);
+			}
+		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;struct&quot;))
+			{	// can only define once
+			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
+			const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
+			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(fullname));
+			if (tmp)
+				{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
+				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM(&quot;'struct &quot;);
+				INC_INFORM(fullname);
+				free(namespace_name);
+				INFORM(&quot;' already defined (C++98 3.2p1)&quot;);
+				message_header(*tmp);
+				INFORM(&quot;prior definition here&quot;);
+				zcc_errors.inc_error();
+				// now it's gone
+				// remove trailing semicolon if present
+				src.DeleteNSlotsAt&lt;0&gt;((1&lt;src.size&lt;0&gt;()-i &amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1])) ? 2 : 1,i);
+				continue;
+				}
+			free(namespace_name);
+			}
+		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;class&quot;))
+			{	// can only define once
+			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
+			const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
+			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(fullname));
+			if (tmp)
+				{	//! \test zcc/decl.C99/Error_class_multidef.hpp
+				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM(&quot;'class &quot;);
+				INC_INFORM(fullname);
+				free(namespace_name);
+				INFORM(&quot;' already defined (C++98 3.2p1)&quot;);
+				message_header(*tmp);
+				INFORM(&quot;prior definition here&quot;);
+				zcc_errors.inc_error();
+				// now it's gone
+				// remove trailing semicolon if present
+				src.DeleteNSlotsAt&lt;0&gt;((1&lt;src.size&lt;0&gt;()-i &amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1])) ? 2 : 1,i);
+				continue;
+				}
+			free(namespace_name);
+			}
+		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
+		//! \todo actually, we can try forward-declare both scoped enums and enum-based enums (C++0X 7.2p3, these have enough size information); but other parts of the standard get in the way
+		else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;))
+			{
+			if (!(src.c_array&lt;0&gt;()[i].flags &amp; parse_tree::INVALID))
 				{
-				type_system::type_index tmp = types.get_id_union_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
-				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
+				type_system::type_index tmp = types.get_id_enum_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);	// C++: enums are own type
+				if (!tmp)
+					{	// this belongs elsewhere
+						//! \test zcc\decl.C99\Error_enum_undef.hpp
+					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM(&quot;'enum &quot;);
+					INC_INFORM(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].token.second);
+					INFORM(&quot;' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)&quot;);
+					zcc_errors.inc_error();
+					src.c_array&lt;0&gt;()[i].flags |= parse_tree::INVALID;
+					}
 				}
-			else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
+			//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
+			}
+		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;enum&quot;))
+			{	// can only define once
+			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
+			const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
+			type_system::type_index tmp = types.get_id_enum(fullname);
+			if (tmp)
+				{	//! \test zcc\decl.C99\Error_enum_multidef.hpp
+				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM(&quot;'enum &quot;);
+				INC_INFORM(fullname);
+				free(namespace_name);
+				INFORM(&quot;' already defined (C++98 3.2p1)&quot;);
+				const enum_def* const tmp2 = types.get_enum_def(tmp);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM(&quot;prior definition here&quot;);
+				zcc_errors.inc_error();
+				// now it's gone
+				src.DeleteNSlotsAt&lt;0&gt;(1,i);
+				continue;
+				};
+			free(namespace_name);
+			//! \test zcc\decl.C99\Pass_enum_def.hpp
+			// enum-specifier doesn't have a specific declaration mode
+			const type_system::type_index tmp2 = types.register_enum_def_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
+			assert(types.get_id_enum_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,src.data&lt;0&gt;()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
 				{
-				type_system::type_index tmp = types.get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
-				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
+				INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
+				return;
 				}
-			else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;class&quot;))
+			}
+		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;))
+			{	// enum-specifier doesn't have a specific declaration mode
+				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
+			const type_system::type_index tmp = types.register_enum_def_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
+			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,src.data&lt;0&gt;()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
 				{
-				type_system::type_index tmp = types.get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
-				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
+				INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
+				return;
 				}
-			else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;union&quot;))
-				{	// can only define once
+			}
+
+		if (	1&lt;src.size&lt;0&gt;()-i
+			&amp;&amp; 	robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
+			{	// is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;) will cause an error later, in variable parsing
+			if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
+				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM(&quot;unreferenceable anonymous union declaration&quot;);
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt&lt;0&gt;(2,i);
+				continue;
+				}
+			else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
+				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM(&quot;unreferenceable anonymous struct declaration&quot;);
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt&lt;0&gt;(2,i);
+				continue;
+				}
+			else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;class&quot;))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
+				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM(&quot;unreferenceable anonymous class declaration&quot;);
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt&lt;0&gt;(2,i);
+				continue;
+				}
+			else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
+				{	// forward-declare, fine
 				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
 				const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-				const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_union(fullname));
-				if (tmp)
-					{	//! \test zcc/decl.C99/Error_union_multidef.hpp
-					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM(&quot;'union &quot;);
-					INC_INFORM(fullname);
+				if (types.get_id_union(fullname))
+					{	// but if already (forward-)declared then this is a no-op
+						// think this is common enough to not warrant OAOO/DRY treatment
+					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+					// remove from parse
 					free(namespace_name);
-					INFORM(&quot;' already defined (C++98 3.2p1)&quot;);
-					message_header(*tmp);
-					INFORM(&quot;prior definition here&quot;);
-					zcc_errors.inc_error();
-					// now it's gone
-					// remove trailing semicolon if present
-					src.DeleteNSlotsAt&lt;0&gt;((1&lt;src.size&lt;0&gt;()-i &amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1])) ? 2 : 1,i);
-					continue;
+					src.DeleteNSlotsAt&lt;0&gt;(2,i);
+					continue;					
 					}
 				free(namespace_name);
+				// forward-declare
+				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+				//! \todo fix up fully-qualified name
+				const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
+				i += 2;
+				continue;
 				}
-			else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;struct&quot;))
-				{	// can only define once
+			else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
+				{	// forward-declare, fine
 				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
 				const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-				const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(fullname));
-				if (tmp)
-					{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
-					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM(&quot;'struct &quot;);
-					INC_INFORM(fullname);
+				if (types.get_id_struct_class(fullname))
+					{	// but if already (forward-)declared then this is a no-op
+						// think this is common enough to not warrant OAOO/DRY treatment
+					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+					// remove from parse
 					free(namespace_name);
-					INFORM(&quot;' already defined (C++98 3.2p1)&quot;);
-					message_header(*tmp);
-					INFORM(&quot;prior definition here&quot;);
-					zcc_errors.inc_error();
-					// now it's gone
-					// remove trailing semicolon if present
-					src.DeleteNSlotsAt&lt;0&gt;((1&lt;src.size&lt;0&gt;()-i &amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1])) ? 2 : 1,i);
-					continue;
+					src.DeleteNSlotsAt&lt;0&gt;(2,i);
+					continue;					
 					}
 				free(namespace_name);
+				// forward-declare
+				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+				//! \todo fix up fully-qualified name
+				const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
+				i += 2;
+				continue;
 				}
-			else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;class&quot;))
-				{	// can only define once
+			else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;class&quot;))
+				{	// forward-declare, fine
 				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
 				const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-				const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(fullname));
-				if (tmp)
-					{	//! \test zcc/decl.C99/Error_class_multidef.hpp
-					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM(&quot;'class &quot;);
-					INC_INFORM(fullname);
+				if (types.get_id_struct_class(fullname))
+					{	// but if already (forward-)declared then this is a no-op
+						// think this is common enough to not warrant OAOO/DRY treatment
+					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+					// remove from parse
 					free(namespace_name);
-					INFORM(&quot;' already defined (C++98 3.2p1)&quot;);
-					message_header(*tmp);
-					INFORM(&quot;prior definition here&quot;);
-					zcc_errors.inc_error();
-					// now it's gone
-					// remove trailing semicolon if present
-					src.DeleteNSlotsAt&lt;0&gt;((1&lt;src.size&lt;0&gt;()-i &amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1])) ? 2 : 1,i);
-					continue;
+					src.DeleteNSlotsAt&lt;0&gt;(2,i);
+					continue;					
 					}
 				free(namespace_name);
+				// forward-declare
+				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+				//! \todo fix up fully-qualified name
+				const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
+				i += 2;
+				continue;
 				}
-			// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
-			//! \todo actually, we can try forward-declare both scoped enums and enum-based enums (C++0X 7.2p3, these have enough size information); but other parts of the standard get in the way
-			else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;))
-				{
-				if (!(src.c_array&lt;0&gt;()[i].flags &amp; parse_tree::INVALID))
-					{
-					type_system::type_index tmp = types.get_id_enum_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
-					src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);	// C++: enums are own type
-					if (!tmp)
-						{	// this belongs elsewhere
-							//! \test zcc\decl.C99\Error_enum_undef.hpp
-						message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-						INC_INFORM(ERR_STR);
-						INC_INFORM(&quot;'enum &quot;);
-						INC_INFORM(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].token.second);
-						INFORM(&quot;' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)&quot;);
-						zcc_errors.inc_error();
-						src.c_array&lt;0&gt;()[i].flags |= parse_tree::INVALID;
-						}
-					}
-				//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
-				}
-			else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;enum&quot;))
-				{	// can only define once
+			else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;union&quot;))
+				{	// definitions...fine
 				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
 				const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-				type_system::type_index tmp = types.get_id_enum(fullname);
-				if (tmp)
-					{	//! \test zcc\decl.C99\Error_enum_multidef.hpp
-					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM(&quot;'enum &quot;);
-					INC_INFORM(fullname);
-					free(namespace_name);
-					INFORM(&quot;' already defined (C++98 3.2p1)&quot;);
-					const enum_def* const tmp2 = types.get_enum_def(tmp);
-					assert(tmp2);
-					message_header(*tmp2);
-					INFORM(&quot;prior definition here&quot;);
-					zcc_errors.inc_error();
-					// now it's gone
-					src.DeleteNSlotsAt&lt;0&gt;(1,i);
-					continue;
-					};
+				const type_system::type_index tmp = types.get_id_union(fullname);
 				free(namespace_name);
-				//! \test zcc\decl.C99\Pass_enum_def.hpp
-				// enum-specifier doesn't have a specific declaration mode
-				const type_system::type_index tmp2 = types.register_enum_def_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
-				assert(types.get_id_enum_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-				if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,src.data&lt;0&gt;()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
-					{
-					INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
-					return;
-					}
-				}
-			else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;))
-				{	// enum-specifier doesn't have a specific declaration mode
-					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-				const type_system::type_index tmp = types.register_enum_def_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
-				if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,src.data&lt;0&gt;()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
-					{
-					INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
-					return;
-					}
-				}
-
-			if (	1&lt;src.size&lt;0&gt;()-i
-				&amp;&amp; 	robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
-				{	// is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;) will cause an error later, in variable parsing
-				if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
-					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-						//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-						//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
-					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM(&quot;unreferenceable anonymous union declaration&quot;);
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// remove from parse
-					src.DeleteNSlotsAt&lt;0&gt;(2,i);
-					continue;
-					}
-				else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
-					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-						//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-						//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
-					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM(&quot;unreferenceable anonymous struct declaration&quot;);
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// remove from parse
-					src.DeleteNSlotsAt&lt;0&gt;(2,i);
-					continue;
-					}
-				else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;class&quot;))
-					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-						//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-						//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
-					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM(&quot;unreferenceable anonymous class declaration&quot;);
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// remove from parse
-					src.DeleteNSlotsAt&lt;0&gt;(2,i);
-					continue;
-					}
-				else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
-					{	// forward-declare, fine
-					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-					const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-					if (types.get_id_union(fullname))
-						{	// but if already (forward-)declared then this is a no-op
-							// think this is common enough to not warrant OAOO/DRY treatment
+				C_union_struct_def* tmp2 = NULL;
+				if (tmp)
+					{	// promoting forward-declare to definition
 						//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-						// remove from parse
-						free(namespace_name);
-						src.DeleteNSlotsAt&lt;0&gt;(2,i);
-						continue;					
-						}
-					free(namespace_name);
-					// forward-declare
-					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-					//! \todo fix up fully-qualified name
-					const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
+					assert(tmp3);
+					tmp2 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
+					//! \todo record field structure, etc.
+					types.upgrade_decl_to_def(tmp,tmp2);
+					assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp);
+					assert(types.get_C_structdef(tmp));
+					}
+				else{	// definition
+						//! \test zcc/decl.C99/Pass_union_def.hpp
+					//! \todo record field structure, etc.
+					const type_system::type_index tmp3 = types.register_C_structdef(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename,union_struct_decl::decl_union);
 					assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-					assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-					assert(types.get_structdecl(tmp2));
-					src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
-					i += 2;
-					continue;
+					assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp3);
+					assert(types.get_C_structdef(tmp3));
+					src.c_array&lt;0&gt;()[i].type_code.set_type(tmp3);
 					}
-				else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
-					{	// forward-declare, fine
-					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-					const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-					if (types.get_id_struct_class(fullname))
-						{	// but if already (forward-)declared then this is a no-op
-							// think this is common enough to not warrant OAOO/DRY treatment
+				i += 2;
+				continue;
+				}
+			else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;struct&quot;))
+				{	// definitions...fine
+				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
+				const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
+				const type_system::type_index tmp = types.get_id_struct_class(fullname);
+				free(namespace_name);
+				C_union_struct_def* tmp2 = NULL;
+				if (tmp)
+					{	// promoting forward-declare to definition
 						//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-						// remove from parse
-						free(namespace_name);
-						src.DeleteNSlotsAt&lt;0&gt;(2,i);
-						continue;					
-						}
-					free(namespace_name);
-					// forward-declare
-					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-					//! \todo fix up fully-qualified name
-					const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
+					assert(tmp3);
+					tmp2 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
+					//! \todo record field structure, etc.
+					types.upgrade_decl_to_def(tmp,tmp2);
+					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp);
+					assert(types.get_C_structdef(tmp));
+					}
+				else{	// definition
+						//! \test zcc/decl.C99/Pass_struct_def.hpp
+					//! \todo record field structure, etc.
+					const type_system::type_index tmp3 = types.register_C_structdef(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename,union_struct_decl::decl_struct);
 					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-					assert(types.get_structdecl(tmp2));
-					src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
-					i += 2;
-					continue;
+					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp3);
+					assert(types.get_C_structdef(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)));
+					src.c_array&lt;0&gt;()[i].type_code.set_type(tmp3);
 					}
-				else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;class&quot;))
-					{	// forward-declare, fine
-					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-					const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-					if (types.get_id_struct_class(fullname))
-						{	// but if already (forward-)declared then this is a no-op
-							// think this is common enough to not warrant OAOO/DRY treatment
+				i += 2;
+				continue;
+				}
+			else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;class&quot;))
+				{	// definitions...fine
+				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
+				const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
+				const type_system::type_index tmp = types.get_id_struct_class(fullname);
+				free(namespace_name);
+				C_union_struct_def* tmp2 = NULL;
+				if (tmp)
+					{	// promoting forward-declare to definition
 						//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-						// remove from parse
-						free(namespace_name);
-						src.DeleteNSlotsAt&lt;0&gt;(2,i);
-						continue;					
-						}
-					free(namespace_name);
-					// forward-declare
-					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-					//! \todo fix up fully-qualified name
-					const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
+					assert(tmp3);
+					tmp2 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
+					//! \todo record field structure, etc.
+					types.upgrade_decl_to_def(tmp,tmp2);
+					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp);
+					assert(types.get_C_structdef(tmp));
+					}
+				else{	// definition
+						//! \test zcc/decl.C99/Pass_class_def.hpp
+					//! \todo record field structure, etc.
+					const type_system::type_index tmp3 = types.register_C_structdef(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename,union_struct_decl::decl_class);
 					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-					assert(types.get_structdecl(tmp2));
-					src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
-					i += 2;
-					continue;
+					assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp3);
+					assert(types.get_C_structdef(tmp3));
+					src.c_array&lt;0&gt;()[i].type_code.set_type(tmp3);
 					}
-				else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;union&quot;))
-					{	// definitions...fine
-					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-					const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-					const type_system::type_index tmp = types.get_id_union(fullname);
-					free(namespace_name);
-					C_union_struct_def* tmp2 = NULL;
-					if (tmp)
-						{	// promoting forward-declare to definition
-							//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-						const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-						assert(tmp3);
-						tmp2 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
-						//! \todo record field structure, etc.
-						types.upgrade_decl_to_def(tmp,tmp2);
-						assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp);
-						assert(types.get_C_structdef(tmp));
-						}
-					else{	// definition
-							//! \test zcc/decl.C99/Pass_union_def.hpp
-						//! \todo record field structure, etc.
-						const type_system::type_index tmp3 = types.register_C_structdef(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename,union_struct_decl::decl_union);
-						assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-						assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp3);
-						assert(types.get_C_structdef(tmp3));
-						src.c_array&lt;0&gt;()[i].type_code.set_type(tmp3);
-						}
-					i += 2;
-					continue;
-					}
-				else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;struct&quot;))
-					{	// definitions...fine
-					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-					const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-					const type_system::type_index tmp = types.get_id_struct_class(fullname);
-					free(namespace_name);
-					C_union_struct_def* tmp2 = NULL;
-					if (tmp)
-						{	// promoting forward-declare to definition
-							//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-						const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-						assert(tmp3);
-						tmp2 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
-						//! \todo record field structure, etc.
-						types.upgrade_decl_to_def(tmp,tmp2);
-						assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp);
-						assert(types.get_C_structdef(tmp));
-						}
-					else{	// definition
-							//! \test zcc/decl.C99/Pass_struct_def.hpp
-						//! \todo record field structure, etc.
-						const type_system::type_index tmp3 = types.register_C_structdef(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename,union_struct_decl::decl_struct);
-						assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-						assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp3);
-						assert(types.get_C_structdef(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)));
-						src.c_array&lt;0&gt;()[i].type_code.set_type(tmp3);
-						}
-					i += 2;
-					continue;
-					}
-				else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;class&quot;))
-					{	// definitions...fine
-					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
-					const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-					const type_system::type_index tmp = types.get_id_struct_class(fullname);
-					free(namespace_name);
-					C_union_struct_def* tmp2 = NULL;
-					if (tmp)
-						{	// promoting forward-declare to definition
-							//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-						const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-						assert(tmp3);
-						tmp2 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
-						//! \todo record field structure, etc.
-						types.upgrade_decl_to_def(tmp,tmp2);
-						assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp);
-						assert(types.get_C_structdef(tmp));
-						}
-					else{	// definition
-							//! \test zcc/decl.C99/Pass_class_def.hpp
-						//! \todo record field structure, etc.
-						const type_system::type_index tmp3 = types.register_C_structdef(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename,union_struct_decl::decl_class);
-						assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-						assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp3);
-						assert(types.get_C_structdef(tmp3));
-						src.c_array&lt;0&gt;()[i].type_code.set_type(tmp3);
-						}
-					i += 2;
-					continue;
-					};
+				i += 2;
+				continue;
 				};
-//			}
+			};
 		// namespace scanner
 		// need some scheme to handle unnamed namespaces (probably alphabetical counter after something illegal so unmatchable)
 		// C++0X has inline namespaces; ignore these for now (well, maybe not: consuming the inline will prevent problems)
@@ -11933,9 +11851,8 @@
 					INC_INFORM(ERR_STR);
 					INFORM(&quot;declaration disoriented by missing , (C++98 7p1)&quot;);
 					// find the next semicolon
-					size_t j = i+decl_count+decl_offset;
-					while(!robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[j]) &amp;&amp; src.size&lt;0&gt;()&gt; ++j);
-					src.DeleteNSlotsAt&lt;0&gt;(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
+					const size_t span = span_to_semicolon(src.begin&lt;0&gt;()+(i+decl_count+decl_offset),src.end&lt;0&gt;());
+					src.DeleteNSlotsAt&lt;0&gt;(span,i+decl_count+decl_offset);
 					continue;
 					}
 				++decl_offset;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000073.html">[Zcplusplus-commits] r306 - in trunk/Zaimoni.STL: . LexParse
</A></li>
	<LI>Next message: <A HREF="000075.html">[Zcplusplus-commits] r308 - in trunk/Zaimoni.STL: . Pure.C
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#74">[ date ]</a>
              <a href="thread.html#74">[ thread ]</a>
              <a href="subject.html#74">[ subject ]</a>
              <a href="author.html#74">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/zcplusplus-commits">More information about the Zcplusplus-commits
mailing list</a><br>
</body></html>
