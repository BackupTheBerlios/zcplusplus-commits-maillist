<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Zcplusplus-commits] r507 - trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/zcplusplus-commits/2010-October/index.html" >
   <LINK REL="made" HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r507%20-%20trunk&In-Reply-To=%3C20101028181840.B6639480C84%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000273.html">
   <LINK REL="Next"  HREF="000275.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Zcplusplus-commits] r507 - trunk</H1>
    <B>zaimoni at mail.berlios.de</B> 
    <A HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r507%20-%20trunk&In-Reply-To=%3C20101028181840.B6639480C84%40sheep.berlios.de%3E"
       TITLE="[Zcplusplus-commits] r507 - trunk">zaimoni at mail.berlios.de
       </A><BR>
    <I>Thu Oct 28 20:18:40 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="000273.html">[Zcplusplus-commits] r506 - trunk
</A></li>
        <LI>Next message: <A HREF="000275.html">[Zcplusplus-commits] r508 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#274">[ date ]</a>
              <a href="thread.html#274">[ thread ]</a>
              <a href="subject.html#274">[ subject ]</a>
              <a href="author.html#274">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zaimoni
Date: 2010-10-28 20:18:40 +0200 (Thu, 28 Oct 2010)
New Revision: 507

Added:
   trunk/type_system.cpp.in
Modified:
   trunk/POSIX.dep
   trunk/type_system.cpp
Log:
build system tweak

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-10-27 01:12:51 UTC (rev 506)
+++ trunk/POSIX.dep	2010-10-28 18:18:40 UTC (rev 507)
@@ -35,7 +35,7 @@
 CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operat
 or.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h type_system.hpp Zaimoni.STL/Perl_localize.hpp
-type_system.o: type_system.hpp type_system_pp.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
+type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 CSupport.o: CSupport.hpp _CSupport3.hpp _CSupport4.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp kleene_star.hpp cond_act.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_l
 t.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp _CSupport3.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/lo
 gic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2010-10-27 01:12:51 UTC (rev 506)
+++ trunk/type_system.cpp	2010-10-28 18:18:40 UTC (rev 507)
@@ -1,11 +1,7 @@
 // type_system.cpp
 // (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
-#/*cut-cpp*/
 #include &quot;type_system.hpp&quot;
-#/*cut-cpp*/
-#include &quot;type_system_pp.hpp&quot;
-#/*cut-cpp*/
 #include &quot;enum_type.hpp&quot;
 #include &quot;struct_type.hpp&quot;
 #include &quot;Zaimoni.STL/search.hpp&quot;
@@ -265,19 +261,15 @@
 		}
 	return _get_id_enum_CPP(alias);
 }
-#/*cut-cpp*/
 
 const char* type_system::_name(size_t id) const
 {
 	if (0==id) return &quot;(?)&quot;;
 	if (core_types_size&gt; --id) return core_types[id].first;
-#/*cut-cpp*/
 	if (dynamic_types.size() &gt; (id -= core_types_size))
 		return dynamic_types[id].first;
-#/*cut-cpp*/
 	return &quot;(?)&quot;;
 }
-#/*cut-cpp*/
 
 // implement C/C++ typedef system
 void type_system::set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec&amp; src)
@@ -869,5 +861,4 @@
 	tmp.third.first.third = src;
 	src = NULL;
 }
-#/*cut-cpp*/
 

Added: trunk/type_system.cpp.in
===================================================================
--- trunk/type_system.cpp.in	                        (rev 0)
+++ trunk/type_system.cpp.in	2010-10-28 18:18:40 UTC (rev 507)
@@ -0,0 +1,875 @@
+// type_system.cpp
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+
+#/*cut-cpp*/
+#include &quot;type_system.hpp&quot;
+#/*cut-cpp*/
+#/*cut-nocpp*/
+#include &quot;type_system_pp.hpp&quot;
+#/*cut-nocpp*/
+#/*cut-cpp*/
+#include &quot;enum_type.hpp&quot;
+#include &quot;struct_type.hpp&quot;
+#include &quot;Zaimoni.STL/search.hpp&quot;
+#include &quot;Zaimoni.STL/Pure.C/auto_int.h&quot;
+#include &quot;AtomicString.h&quot;
+#include &quot;str_aux.h&quot;
+
+// macros to help out dynamic registration
+#define DYNAMIC_FUNCTYPE 1
+#define DYNAMIC_STRUCTDECL 2
+#define DYNAMIC_C_STRUCTDEF 3
+#define DYNAMIC_ENUMDEF 4
+
+type_system::type_index type_system::_get_id_union(const char* const x) const
+{
+	const size_t x_len = strlen(x);
+	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
+	while(0&lt;=tmp)
+		{
+		if (DYNAMIC_STRUCTDECL==dynamic_types[tmp].third.second)
+			{
+			if (union_struct_decl::decl_union==dynamic_types[tmp].third.first.second-&gt;keyword())
+				return tmp+1+core_types_size;
+			return 0;
+			};
+		if (DYNAMIC_C_STRUCTDEF==dynamic_types[tmp].third.second)
+			{
+			if (union_struct_decl::decl_union==dynamic_types[tmp].third.first.third-&gt;_decl.keyword())
+				return tmp+1+core_types_size;
+			return 0;
+			}
+		// in a different tag space...retry
+		if (1&gt;=dynamic_types.size()-tmp) break;
+		errr tmp2 = linear_find_lencached(x,x_len,dynamic_types.data()+tmp+1,dynamic_types.size()-(tmp+1));
+		if (0&gt;tmp2) break;
+		tmp += 1+tmp2;
+		}
+	return 0;
+}
+
+type_system::type_index
+type_system::_get_id_union_CPP(const char* const x) const
+{
+	errr tmp = _get_id_union(x);
+	if (0&lt;tmp) return tmp;
+
+	// hmm...not an exact match
+	zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; tmp2 = dealias_inline_namespace_index(x);
+	if (0&gt;tmp2.first) return 0;
+
+	// it was remapped
+	while(tmp2.first&lt;tmp2.second)
+		{
+		tmp = _get_id_union(inline_namespace_alias_map.data()[tmp2.first++].second);
+		if (0&lt;tmp) return tmp;
+		}
+	return _get_id_union(inline_namespace_alias_map.data()[tmp2.first].second);
+}
+
+type_system::type_index
+type_system::get_id_union_CPP(const char* alias,const char* active_namespace) const
+{
+	assert(alias &amp;&amp; *alias);
+
+	if (!strncmp(alias,&quot;::&quot;,2))
+		{	// fully-qualified
+		// pretend not fully qualified, but no surrounding namespace
+		alias += 2;
+		active_namespace = NULL;
+		};
+	if (active_namespace &amp;&amp; *active_namespace)
+		{
+		// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,&quot;::&quot;);
+		if (is_string_registered(tmp_alias))
+			{	// registered, so could be indexed
+			const type_index tmp2 = _get_id_union_CPP(tmp_alias);
+			if (tmp2) return (free(tmp_alias),tmp2);
+			}
+
+		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,&quot;::&quot;);
+		if (extra_namespaces)
+			{
+			zaimoni::weakautovalarray_ptr_throws&lt;const char*&gt; intra_namespace(extra_namespaces);
+			report_disjoint_substring_instances(active_namespace,&quot;::&quot;,intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[--i]-active_namespace,&quot;::&quot;);
+				const type_index tmp2 = _get_id_union_CPP(tmp_alias);
+				if (tmp2) return (free(tmp_alias),tmp2);
+				}
+			while(0&lt;i);
+			}
+		free(tmp_alias);
+		}
+	return _get_id_union_CPP(alias);
+}
+
+type_system::type_index
+type_system::_get_id_struct_class(const char* const x) const
+{
+	const size_t x_len = strlen(x);
+	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
+	while(0&lt;=tmp)
+		{
+		if (DYNAMIC_STRUCTDECL==dynamic_types[tmp].third.second)
+			{
+			if (union_struct_decl::decl_union!=dynamic_types[tmp].third.first.second-&gt;keyword())
+				return tmp+1+core_types_size;
+			return 0;
+			};
+		if (DYNAMIC_C_STRUCTDEF==dynamic_types[tmp].third.second)
+			{
+			if (union_struct_decl::decl_union!=dynamic_types[tmp].third.first.third-&gt;_decl.keyword())
+				return tmp+1+core_types_size;
+			return 0;
+			}
+		// in a different tag space...retry
+		if (1&gt;=dynamic_types.size()-tmp) break;
+		errr tmp2 = linear_find_lencached(x,x_len,dynamic_types.data()+tmp+1,dynamic_types.size()-(tmp+1));
+		if (0&gt;tmp2) break;
+		tmp += 1+tmp2;
+		}
+	return 0;
+}
+
+type_system::type_index
+type_system::_get_id_struct_class_CPP(const char* const x) const
+{
+	errr tmp = _get_id_struct_class(x);
+	if (0&lt;tmp) return tmp;
+
+	// hmm...not an exact match
+	zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; tmp2 = dealias_inline_namespace_index(x);
+	if (0&gt;tmp2.first) return 0;
+
+	// it was remapped
+	while(tmp2.first&lt;tmp2.second)
+		{
+		tmp = _get_id_struct_class(inline_namespace_alias_map.data()[tmp2.first++].second);
+		if (0&lt;tmp) return tmp;
+		}
+	return _get_id_struct_class(inline_namespace_alias_map.data()[tmp2.first].second);
+}
+
+type_system::type_index
+type_system::get_id_struct_class_CPP(const char* alias,const char* active_namespace) const
+{
+	assert(alias &amp;&amp; *alias);
+
+	if (!strncmp(alias,&quot;::&quot;,2))
+		{	// fully-qualified
+		// pretend not fully qualified, but no surrounding namespace
+		alias += 2;
+		active_namespace = NULL;
+		};
+	if (active_namespace &amp;&amp; *active_namespace)
+		{
+		// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,&quot;::&quot;);
+		if (is_string_registered(tmp_alias))
+			{	// registered, so could be indexed
+			const type_index tmp2 = _get_id_struct_class_CPP(tmp_alias);
+			if (tmp2) return (free(tmp_alias),tmp2);
+			}
+
+		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,&quot;::&quot;);
+		if (extra_namespaces)
+			{
+			zaimoni::weakautovalarray_ptr_throws&lt;const char*&gt; intra_namespace(extra_namespaces);
+			report_disjoint_substring_instances(active_namespace,&quot;::&quot;,intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[--i]-active_namespace,&quot;::&quot;);
+				const type_index tmp2 = _get_id_struct_class_CPP(tmp_alias);
+				if (tmp2) return (free(tmp_alias),tmp2);
+				}
+			while(0&lt;i);
+			}
+		free(tmp_alias);
+		}
+	return _get_id_struct_class_CPP(alias);
+}
+
+type_system::type_index type_system::_get_id_enum(const char* const x) const
+{
+	const size_t x_len = strlen(x);
+	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
+	while(0&lt;=tmp)
+		{
+		if (DYNAMIC_ENUMDEF==dynamic_types[tmp].third.second)
+			return tmp+1+core_types_size;
+
+		// in a different tag space...retry
+		if (1&gt;=dynamic_types.size()-tmp) break;
+		errr tmp2 = linear_find_lencached(x,x_len,dynamic_types.data()+tmp+1,dynamic_types.size()-(tmp+1));
+		if (0&gt;tmp2) break;
+		tmp += 1+tmp2;
+		}
+	return 0;
+}
+
+type_system::type_index
+type_system::_get_id_enum_CPP(const char* const x) const
+{
+	errr tmp = _get_id_enum(x);
+	if (0&lt;tmp) return tmp;
+
+	// hmm...not an exact match
+	zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; tmp2 = dealias_inline_namespace_index(x);
+	if (0&gt;tmp2.first) return 0;
+
+	// it was remapped
+	while(tmp2.first&lt;tmp2.second)
+		{
+		tmp = _get_id_enum(inline_namespace_alias_map.data()[tmp2.first++].second);
+		if (0&lt;tmp) return tmp;
+		}
+	return _get_id_enum(inline_namespace_alias_map.data()[tmp2.first].second);
+}
+
+type_system::type_index
+type_system::get_id_enum_CPP(const char* alias,const char* active_namespace) const
+{
+	assert(alias &amp;&amp; *alias);
+
+	if (!strncmp(alias,&quot;::&quot;,2))
+		{	// fully-qualified
+		// pretend not fully qualified, but no surrounding namespace
+		alias += 2;
+		active_namespace = NULL;
+		};
+	if (active_namespace &amp;&amp; *active_namespace)
+		{
+		// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,&quot;::&quot;);
+		if (is_string_registered(tmp_alias))
+			{	// registered, so could be indexed
+			const type_index tmp2 = _get_id_enum_CPP(tmp_alias);
+			if (tmp2) return (free(tmp_alias),tmp2);
+			}
+
+		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,&quot;::&quot;);
+		if (extra_namespaces)
+			{
+			zaimoni::weakautovalarray_ptr_throws&lt;const char*&gt; intra_namespace(extra_namespaces);
+			report_disjoint_substring_instances(active_namespace,&quot;::&quot;,intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[--i]-active_namespace,&quot;::&quot;);
+				const type_index tmp2 = _get_id_enum_CPP(tmp_alias);
+				if (tmp2) return (free(tmp_alias),tmp2);
+				}
+			while(0&lt;i);
+			}
+		free(tmp_alias);
+		}
+	return _get_id_enum_CPP(alias);
+}
+#/*cut-cpp*/
+
+const char* type_system::_name(size_t id) const
+{
+	if (0==id) return &quot;(?)&quot;;
+	if (core_types_size&gt; --id) return core_types[id].first;
+#/*cut-cpp*/
+	if (dynamic_types.size() &gt; (id -= core_types_size))
+		return dynamic_types[id].first;
+#/*cut-cpp*/
+	return &quot;(?)&quot;;
+}
+#/*cut-cpp*/
+
+// implement C/C++ typedef system
+void type_system::set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec&amp; src)
+{
+	assert(alias &amp;&amp; *alias);
+	assert(filename &amp;&amp; *filename);
+	errr tmp = binary_find(alias,strlen(alias),typedef_registry.data(),typedef_registry.size());
+	assert(0&gt;tmp);		// error to call with conflicting prior definition
+	if (0&lt;=tmp) return;	// conflicting prior definition
+#if UINTMAX_MAX==SIZE_MAX
+	if (-1==tmp) _fatal(&quot;implementation limit exceeded (typedefs registered at once)&quot;);
+#endif
+	zaimoni::POD_pair&lt;const char*,zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt; &gt; tmp2 = {alias, {src, filename, lineno}};
+	if (!typedef_registry.InsertSlotAt(BINARY_SEARCH_DECODE_INSERTION_POINT(tmp),tmp2)) throw std::bad_alloc();
+	src.clear();
+}
+
+void type_system::set_typedef_CPP(const char* name, const char* const active_namespace, const char* filename, const size_t lineno, type_spec&amp; src)
+{
+	assert(name &amp;&amp; *name);
+	assert(filename &amp;&amp; *filename);
+
+	// use active namespace if present
+	if (active_namespace &amp;&amp; *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	return set_typedef(name,filename,lineno,src);
+}
+
+const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* type_system::get_typedef(const char* const alias) const
+{
+	assert(alias &amp;&amp; *alias);
+	//! \todo: strip off trailing inline namespaces
+	// &lt;unknown&gt; is the hack for anonymous namespaces taken from GCC, it's always inline
+	errr tmp = binary_find(alias,strlen(alias),typedef_registry.data(),typedef_registry.size());
+	if (0&lt;=tmp) return &amp;typedef_registry[tmp].second;
+	return NULL;
+}
+
+const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* type_system::_get_typedef_CPP(const char* const alias) const
+{
+	const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp = get_typedef(alias);
+	if (tmp) return tmp;
+
+	// hmm...not an exact match
+	zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; tmp2 = dealias_inline_namespace_index(alias);
+	if (0&gt;tmp2.first) return NULL;
+
+	// it was remapped
+	while(tmp2.first&lt;tmp2.second)
+		{
+		tmp = get_typedef(inline_namespace_alias_map.data()[tmp2.first++].second);
+		if (tmp) return tmp;
+		}
+	return get_typedef(inline_namespace_alias_map.data()[tmp2.first].second);
+}
+
+const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* type_system::get_typedef_CPP(const char* alias,const char* active_namespace) const
+{
+	assert(alias &amp;&amp; *alias);
+
+	if (!strncmp(alias,&quot;::&quot;,2))
+		{	// fully-qualified typedef name
+			// cheat: pretend not fully qualified but no surrounding namespace
+		alias += 2;
+		active_namespace = NULL;
+		};
+	if (active_namespace &amp;&amp; *active_namespace)
+		{
+		// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,&quot;::&quot;);
+		if (is_string_registered(tmp_alias))
+			{	// registered, so could be indexed
+			const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp2 = _get_typedef_CPP(tmp_alias);
+			if (tmp2) return (free(tmp_alias),tmp2);
+			}
+
+		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,&quot;::&quot;);
+		if (extra_namespaces)
+			{
+			zaimoni::weakautovalarray_ptr_throws&lt;const char*&gt; intra_namespace(extra_namespaces);
+			report_disjoint_substring_instances(active_namespace,&quot;::&quot;,intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[--i]-active_namespace,&quot;::&quot;);
+				const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp2 = _get_typedef_CPP(tmp_alias);
+				if (tmp2) return (free(tmp_alias),tmp2);
+				}
+			while(0&lt;i);
+			}
+		free(tmp_alias);
+		}
+	return _get_typedef_CPP(alias);
+}
+
+void type_system::set_enumerator_def(const char* const alias, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* const src_filename,unsigned char representation,const uchar_blob&amp; src,type_index type)
+{
+	assert(alias &amp;&amp; *alias);
+	assert(src_filename &amp;&amp; *src_filename);
+	assert(type);
+	assert(get_enum_def(type));
+	errr tmp = binary_find(alias,strlen(alias),enumerator_registry.data(),enumerator_registry.size());
+	assert(0&gt;tmp);		// error to call with conflicting prior definition
+	if (0&lt;=tmp) return;	// conflicting prior definition
+#if UINTMAX_MAX==SIZE_MAX
+	if (-1==tmp) _fatal(&quot;implementation limit exceeded (enumerators registered at once)&quot;);
+#endif
+	enumerator_info tmp2 = {alias, { {type, representation, src}, {src_filename, logical_line} } };
+	if (!enumerator_registry.InsertSlotAt(BINARY_SEARCH_DECODE_INSERTION_POINT(tmp),tmp2)) throw std::bad_alloc();
+}
+
+void type_system::set_enumerator_def_CPP(const char* name, const char* const active_namespace, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* const src_filename,unsigned char representation,const uchar_blob&amp; src,type_index type)
+{
+	assert(name &amp;&amp; *name);
+	assert(src_filename &amp;&amp; *src_filename);
+	assert(type);
+
+	// use active namespace if present
+	if (active_namespace &amp;&amp; *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	set_enumerator_def(name,logical_line,src_filename,representation,src,type);
+}
+
+const type_system::enumerator_info* type_system::get_enumerator(const char* const alias) const
+{
+	assert(alias &amp;&amp; *alias);
+	//! \todo: strip off trailing inline namespaces
+	// &lt;unknown&gt; is the hack for anonymous namespaces taken from GCC, it's always inline
+	errr tmp = binary_find(alias,strlen(alias),enumerator_registry.data(),enumerator_registry.size());
+	if (0&lt;=tmp)
+		{
+		assert(get_enum_def(enumerator_registry[tmp].second.first.first));
+		return &amp;enumerator_registry[tmp];
+		}
+	return NULL;
+}
+
+const type_system::enumerator_info* type_system::_get_enumerator_CPP(const char* const alias) const
+{
+	const enumerator_info* tmp = get_enumerator(alias);
+	if (tmp) return tmp;
+
+	// hmm...not an exact match
+	zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; tmp2 = dealias_inline_namespace_index(alias);
+	if (0&gt;tmp2.first) return NULL;
+
+	// it was remapped
+	while(tmp2.first&lt;tmp2.second)
+		{
+		tmp = get_enumerator(inline_namespace_alias_map.data()[tmp2.first++].second);
+		if (tmp) return tmp;
+		}
+	return get_enumerator(inline_namespace_alias_map.data()[tmp2.first].second);
+}
+
+const type_system::enumerator_info* type_system::get_enumerator_CPP(const char* alias,const char* active_namespace) const
+{
+	assert(alias &amp;&amp; *alias);
+
+	if (!strncmp(alias,&quot;::&quot;,2))
+		{	// fully-qualified typedef name
+			// cheat: pretend not fully qualified but no surrounding namespace
+		alias += 2;
+		active_namespace = NULL;
+		};
+	if (active_namespace &amp;&amp; *active_namespace)
+		{
+		// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,&quot;::&quot;);
+		if (is_string_registered(tmp_alias))
+			{	// registered, so could be indexed
+			const enumerator_info* tmp2 = _get_enumerator_CPP(tmp_alias);
+			if (tmp2) return (free(tmp_alias),tmp2);
+			}
+
+		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,&quot;::&quot;);
+		if (extra_namespaces)
+			{
+			zaimoni::weakautovalarray_ptr_throws&lt;const char*&gt; intra_namespace(extra_namespaces);
+			report_disjoint_substring_instances(active_namespace,&quot;::&quot;,intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[--i]-active_namespace,&quot;::&quot;);
+				const enumerator_info* tmp2 = _get_enumerator_CPP(tmp_alias);
+				if (tmp2) return (free(tmp_alias),tmp2);
+				}
+			while(0&lt;i);
+			}
+		free(tmp_alias);
+		}
+	return _get_enumerator_CPP(alias);
+}
+
+char* type_system::_namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len)
+{	// remove comment after other seven wrapper variants implemented
+//	assert(active_namespace &amp;&amp; *active_namespace &amp;&amp; 0&lt;active_namespace_len &amp;&amp; active_namespace_len&lt;=strlen(active_namespace));
+//	assert(name &amp;&amp; *name &amp;&amp; 0&lt;name_len &amp;&amp; name_len&lt;=strlen(name));
+//	assert(namespace_separator &amp;&amp; *namespace_separator &amp;&amp; 0&lt;namespace_separator_len &amp;&amp; namespace_separator_len&lt;=strlen(namespace_separator));
+	char* const actual_name = zaimoni::_new_buffer_nonNULL_throws&lt;char&gt;(ZAIMONI_LEN_WITH_NULL(active_namespace_len+2+name_len));
+	strncpy(actual_name,active_namespace,active_namespace_len);
+	strncpy(actual_name+active_namespace_len,namespace_separator,namespace_separator_len);
+	strncpy(actual_name+active_namespace_len+namespace_separator_len,name,name_len);
+	return actual_name;
+}
+
+void type_system::_namespace_concatenate(char* buf, const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len)
+{	// remove comment after other seven wrapper variants implemented
+//	assert(buf)
+//	assert(active_namespace &amp;&amp; *active_namespace &amp;&amp; 0&lt;active_namespace_len &amp;&amp; active_namespace_len&lt;=strlen(active_namespace));
+//	assert(name &amp;&amp; *name &amp;&amp; 0&lt;name_len &amp;&amp; name_len&lt;=strlen(name));
+//	assert(namespace_separator &amp;&amp; *namespace_separator &amp;&amp; 0&lt;namespace_separator_len &amp;&amp; namespace_separator_len&lt;=strlen(namespace_separator));
+	strncpy(buf,active_namespace,active_namespace_len);
+	strncpy(buf+active_namespace_len,namespace_separator,namespace_separator_len);
+	strncpy(buf+active_namespace_len+namespace_separator_len,name,name_len);
+	ZAIMONI_NULL_TERMINATE(buf[active_namespace_len+namespace_separator_len+name_len]);
+}
+
+zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; type_system::dealias_inline_namespace_index(const char* const alias) const
+{
+	assert(alias &amp;&amp; *alias);
+	zaimoni::POD_pair&lt;ptrdiff_t,ptrdiff_t&gt; tmp = {-1,-1};
+	size_t strict_ub = inline_namespace_alias_map.size();
+	size_t lb = 0;
+	// binary search
+	// is inline_namespace_alias_map.data() a code size optimization target?
+	while(strict_ub&gt;lb)
+		{
+		const size_t midpoint = lb+(strict_ub-lb)/2;
+		switch(strcmp(inline_namespace_alias_map.data()[midpoint].first,alias))
+		{
+#ifndef NDEBUG
+		default: FATAL(&quot;strcmp out of range -1,0,1&quot;);
+#endif
+		case 0: {
+			tmp.first = midpoint;
+			tmp.second = midpoint;
+			while(lb&lt;(size_t)tmp.first &amp;&amp; !strcmp(inline_namespace_alias_map.data()[tmp.first-1].first,alias)) --tmp.first;
+			while(strict_ub-1&gt;(size_t)tmp.second &amp;&amp; !strcmp(inline_namespace_alias_map.data()[tmp.second+1].first,alias)) ++tmp.second;
+			return tmp;
+			}
+		case 1: {
+			strict_ub = midpoint;
+			break;
+			}
+		case -1:{
+			lb = midpoint+1;
+			}
+		}
+		}
+	return tmp;
+}
+
+bool type_system::is_inline_namespace_CPP(const char* const active_namespace, const size_t active_namespace_len) const
+{
+	assert(active_namespace &amp;&amp; *active_namespace &amp;&amp; 0&lt;active_namespace_len);
+	assert(strncmp(active_namespace,&quot;::&quot;,2));
+	
+	// ::&lt;unknown&gt;, our hack for anonymous namespaces, is always an inline namespace 
+	if (sizeof(&quot;&lt;unknown&gt;&quot;)-1==active_namespace_len &amp;&amp; !strncmp(active_namespace,&quot;&lt;unknown&gt;&quot;,sizeof(&quot;&lt;unknown&gt;&quot;)-1)) return true;
+	if (sizeof(&quot;::&lt;unknown&gt;&quot;)-1&lt;active_namespace_len &amp;&amp; !strncmp(active_namespace+(active_namespace_len-(sizeof(&quot;::&lt;unknown&gt;&quot;)-1)),&quot;::&lt;unknown&gt;&quot;,sizeof(&quot;::&lt;unknown&gt;&quot;)-1)) return true;
+
+	//! \todo check for C++0X inline namespaces
+	// should be fine with binary search against canonical names
+	return false;
+}
+
+const char* type_system::canonical_name_is_inline_namespace_alias_target(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len) const
+{
+	assert(active_namespace &amp;&amp; *active_namespace &amp;&amp; 0&lt;active_namespace_len);
+	assert(name &amp;&amp; *name &amp;&amp; 0&lt;name_len);
+	assert(namespace_separator &amp;&amp; *namespace_separator &amp;&amp; 0&lt;namespace_separator_len);
+	size_t strict_ub = inline_namespace_alias_targets.size();
+	size_t lb = 0;
+	// classic binary search.
+	// is inline_namespace_alias_targets.data() a code-size optimization target?
+	while(strict_ub&gt;lb)
+		{
+		const size_t midpoint = lb+(strict_ub-lb)/2;
+		int tmp = strncmp(inline_namespace_alias_targets.data()[midpoint],active_namespace,active_namespace_len);
+		if (!tmp) tmp = strncmp(inline_namespace_alias_targets.data()[midpoint]+active_namespace_len,namespace_separator,namespace_separator_len);
+		if (!tmp) tmp = strncmp(inline_namespace_alias_targets.data()[midpoint]+active_namespace_len+namespace_separator_len,name,name_len);
+		switch(tmp)
+		{
+#ifndef NDEBUG
+		default: FATAL(&quot;strncmp out of range -1,0,1&quot;);
+#endif
+		case 0: return  inline_namespace_alias_targets.data()[midpoint];
+		case 1: {
+			strict_ub = midpoint;
+			break;
+			}
+		case -1:{
+			lb = midpoint+1;
+			}
+		}
+		}
+	return NULL;
+}
+
+const char* type_system::construct_canonical_name_and_aliasing_CPP(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len)
+{
+	assert(active_namespace &amp;&amp; *active_namespace &amp;&amp; 0&lt;active_namespace_len);
+	assert(name &amp;&amp; *name &amp;&amp; 0&lt;name_len);
+	assert(strncmp(active_namespace,&quot;::&quot;,2));
+	// check for whether we already are aliased
+	const char* retval = canonical_name_is_inline_namespace_alias_target(name,name_len,active_namespace,active_namespace_len,&quot;::&quot;,2);
+	if (NULL!=retval) return retval;
+
+	// canonical name is simply active_namespace::name
+	zaimoni::autoval_ptr&lt;char&gt; retval_tmp;
+	retval_tmp = _namespace_concatenate(name,name_len,active_namespace,active_namespace_len,&quot;::&quot;,2);
+
+	// aliasing is built by removing trailing inline namespaces incrementally
+	const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,&quot;::&quot;);
+	if (is_inline_namespace_CPP(active_namespace,active_namespace_len))
+		{
+		zaimoni::autovalarray_ptr_throws&lt;char*&gt; namespace_tmp(extra_namespaces);
+#ifndef ZAIMONI_NULL_REALLY_IS_ZERO
+#error need to null-initialize pointers for namespace_tmp
+#endif
+		bool can_be_completely_gone = false;
+		{
+		zaimoni::weakautovalarray_ptr_throws&lt;const char*&gt; intra_namespace(extra_namespaces);
+		if (extra_namespaces)
+			{
+			report_disjoint_substring_instances(active_namespace,&quot;::&quot;,intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				if (!is_inline_namespace_CPP(active_namespace,i==extra_namespaces ? active_namespace_len : intra_namespace[i]-active_namespace))
+					break;
+				--i;
+				namespace_tmp[i] = _namespace_concatenate(name,name_len,active_namespace,intra_namespace[i]-active_namespace,&quot;::&quot;,2);
+				}
+			while(0&lt;i);
+			can_be_completely_gone = (0==i &amp;&amp; is_inline_namespace_CPP(active_namespace,intra_namespace[0]-active_namespace));
+			if (0&lt;i) namespace_tmp.DeleteNSlotsAt(i,0);
+			}
+		else{
+			can_be_completely_gone = true;
+			}
+		}
+		assert(can_be_completely_gone || !namespace_tmp.empty());
+
+		size_t origin = inline_namespace_alias_map.size();
+		size_t origin2 = inline_namespace_alias_targets.size();
+		inline_namespace_alias_targets.resize(origin2+1);
+		try	{
+			inline_namespace_alias_map.resize(origin+namespace_tmp.size()+can_be_completely_gone);
+			}
+		catch(std::bad_alloc&amp; e)
+			{
+			inline_namespace_alias_targets.resize(origin2);
+			throw;
+			}
+
+		retval = register_string(retval_tmp);	//! \todo would prefer to consume the string; changes reset() to NULLPtr() to be safe
+		retval_tmp.reset();
+		/* do a downward insertsort against the second index*/
+		while(origin2 &amp;&amp; 1==strcmp(inline_namespace_alias_targets.c_array()[origin2-1],retval))
+			{
+			inline_namespace_alias_targets.c_array()[origin2] = inline_namespace_alias_targets.c_array()[origin2-1];
+			--origin2;
+			};
+		inline_namespace_alias_targets.c_array()[origin2] = retval;
+
+		size_t i = namespace_tmp.size();
+		while(0&lt;i)
+			{
+			const zaimoni::POD_pair&lt;const char*,const char*&gt; tmp = {register_string(namespace_tmp[--i]), retval};
+			size_t j = origin;
+			while(j &amp;&amp; 1==strcmp(inline_namespace_alias_map.c_array()[j-1].first,tmp.first))
+				{
+				inline_namespace_alias_map.c_array()[j] = inline_namespace_alias_map.c_array()[j-1];
+				--j;
+				};
+			inline_namespace_alias_map.c_array()[origin++] = tmp;
+			free(namespace_tmp[i]);
+			namespace_tmp[i] = NULL;
+			};
+		if (can_be_completely_gone)
+			{
+			const zaimoni::POD_pair&lt;const char*,const char*&gt; tmp = {register_substring(name,name_len), retval};
+			size_t j = origin;
+			while(j &amp;&amp; 1==strcmp(inline_namespace_alias_map.c_array()[j-1].first,tmp.first))
+				{
+				inline_namespace_alias_map.c_array()[j] = inline_namespace_alias_map.c_array()[j-1];
+				--j;
+				};
+			inline_namespace_alias_map.c_array()[origin++] = tmp;
+			}
+		}
+
+	if (!retval)
+		{
+		retval = register_string(retval_tmp);	//! \todo would prefer to consume the string; changes reset() to NULLPtr() to be safe
+		retval_tmp.reset();
+		};
+	// return the canonical name
+	return retval;
+}
+
+type_system::type_index type_system::register_functype(const char* const alias, function_type*&amp; src)
+{
+	assert(alias &amp;&amp; *alias);
+	assert(src);
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_FUNCTYPE}};
+	tmp.third.first.first = src;
+
+	const size_t dynamic_types_size = dynamic_types.size();
+	const size_t dynamic_types_max_size = dynamic_types.max_size();
+	if (	dynamic_types_max_size&lt;1+core_types_size
+		|| 	dynamic_types_max_size-(1+core_types_size)&lt;dynamic_types_size)
+		FATAL(&quot;Host implementation limit exceeded: cannot record function type used in program&quot;);
+	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
+	src = NULL;
+	return dynamic_types_size+1+core_types_size;
+}
+
+type_system::type_index type_system::register_functype_CPP(const char* name, const char* const active_namespace, function_type*&amp; src)
+{
+	assert(name &amp;&amp; *name);
+	assert(src);
+
+	// use active namespace if present
+	if (active_namespace &amp;&amp; *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	return register_functype(name,src);
+}
+
+type_system::type_index type_system::register_structdecl(const char* const alias, int keyword)
+{
+	assert(alias &amp;&amp; *alias);
+	const size_t dynamic_types_size = dynamic_types.size();
+	const size_t dynamic_types_max_size = dynamic_types.max_size();
+	if (	dynamic_types_max_size&lt;2+core_types_size
+		|| 	dynamic_types_max_size-(2+core_types_size)&lt;dynamic_types_size)
+		FATAL(&quot;Host implementation limit exceeded: cannot record union/struct type used in program&quot;);
+
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_STRUCTDECL}};
+	tmp.third.first.second = new union_struct_decl((union_struct_decl::keywords)keyword,alias);
+
+	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp))
+		{
+		delete tmp.third.first.second;
+		throw std::bad_alloc();
+		}
+	return dynamic_types_size+1+core_types_size;
+}
+
+type_system::type_index type_system::register_structdecl_CPP(const char* name, const char* const active_namespace, int keyword)
+{
+	assert(name &amp;&amp; *name);
+
+	// use active namespace if present
+	if (active_namespace &amp;&amp; *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	return register_structdecl(name,keyword);
+}
+
+type_system::type_index type_system::register_C_structdef(const char* const alias, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* const src_filename, int keyword)
+{
+	assert(alias &amp;&amp; *alias);
+	assert(src_filename &amp;&amp; *src_filename);
+	const size_t dynamic_types_size = dynamic_types.size();
+	const size_t dynamic_types_max_size = dynamic_types.max_size();
+	if (	dynamic_types_max_size&lt;2+core_types_size
+		|| 	dynamic_types_max_size-(2+core_types_size)&lt;dynamic_types_size)
+		FATAL(&quot;Host implementation limit exceeded: cannot record union/struct type used in program&quot;);
+
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_C_STRUCTDEF}};
+	tmp.third.first.third = new C_union_struct_def((union_struct_decl::keywords)keyword,alias,logical_line,src_filename);
+
+	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp))
+		{
+		delete tmp.third.first.third;
+		throw std::bad_alloc();
+		}
+	return dynamic_types_size+1+core_types_size;
+}
+
+type_system::type_index type_system::register_C_structdef_CPP(const char* name, const char* const active_namespace, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* const src_filename, int keyword)
+{
+	assert(name &amp;&amp; *name);
+	assert(src_filename &amp;&amp; *src_filename);
+
+	// use active namespace if present
+	if (active_namespace &amp;&amp; *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	return register_C_structdef(name,logical_line,src_filename,keyword);
+}
+
+type_system::type_index type_system::register_enum_def(const char* const alias, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* const src_filename)
+{
+	assert(alias &amp;&amp; *alias);
+	assert(src_filename &amp;&amp; *src_filename);
+	const size_t dynamic_types_size = dynamic_types.size();
+	const size_t dynamic_types_max_size = dynamic_types.max_size();
+	if (	dynamic_types_max_size&lt;2+core_types_size
+		|| 	dynamic_types_max_size-(2+core_types_size)&lt;dynamic_types_size)
+		FATAL(&quot;Host implementation limit exceeded: cannot record enum type used in program&quot;);
+
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_ENUMDEF}};
+	tmp.third.first.fourth = new enum_def(alias,logical_line,src_filename);
+
+	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp))
+		{
+		delete tmp.third.first.fourth;
+		throw std::bad_alloc();
+		}
+	return dynamic_types_size+1+core_types_size;
+}
+
+type_system::type_index type_system::register_enum_def_CPP(const char* name, const char* const active_namespace, zaimoni::POD_pair&lt;size_t,size_t&gt; logical_line, const char* const src_filename)
+{
+	assert(name &amp;&amp; *name);
+	assert(src_filename &amp;&amp; *src_filename);
+
+	// use active namespace if present
+	if (active_namespace &amp;&amp; *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	return register_enum_def(name,logical_line,src_filename);
+}
+
+const function_type* type_system::get_functype(type_system::type_index i)  const
+{
+	if (core_types_size&gt;=i) return NULL;
+	i -= core_types_size;
+	if (dynamic_types.size()&lt;= --i) return NULL;
+	const dynamic_type_format&amp; tmp = dynamic_types[i];
+	if (DYNAMIC_FUNCTYPE!=tmp.third.second) return NULL;
+	return tmp.third.first.first;
+}
+
+const union_struct_decl* type_system::get_structdecl(type_system::type_index i)  const
+{
+	if (core_types_size&gt;=i) return NULL;
+	i -= core_types_size;
+	if (dynamic_types.size()&lt;= --i) return NULL;
+	const dynamic_type_format&amp; tmp = dynamic_types[i];
+	if (DYNAMIC_STRUCTDECL!=tmp.third.second) return NULL;
+	return tmp.third.first.second;
+}
+
+const C_union_struct_def* type_system::get_C_structdef(type_system::type_index i)  const
+{
+	if (core_types_size&gt;=i) return NULL;
+	i -= core_types_size;
+	if (dynamic_types.size()&lt;= --i) return NULL;
+	const dynamic_type_format&amp; tmp = dynamic_types[i];
+	if (DYNAMIC_C_STRUCTDEF!=tmp.third.second) return NULL;
+	return tmp.third.first.third;
+}
+
+enum_def* type_system::_get_enum_def(type_index i) const
+{
+	if (core_types_size&gt;=i) return NULL;
+	i -= core_types_size;
+	if (dynamic_types.size()&lt;= --i) return NULL;
+	const dynamic_type_format&amp; tmp = dynamic_types[i];
+	if (DYNAMIC_ENUMDEF!=tmp.third.second) return NULL;
+	return tmp.third.first.fourth;
+}
+
+void type_system::set_enum_underlying_type(type_index i,size_t new_type)
+{
+	assert(UCHAR_MAX&gt;=new_type);
+	enum_def* const tmp = _get_enum_def(i);
+	assert(tmp);
+	tmp-&gt;represent_as = new_type;
+}
+
+void type_system::upgrade_decl_to_def(type_index i,C_union_struct_def*&amp; src)
+{	// cf. get_structdecl
+	assert(src);
+	assert(core_types_size&lt;i);
+	i -= core_types_size;
+	--i;
+	assert(dynamic_types.size()&gt;i);
+	dynamic_type_format&amp; tmp = dynamic_types[i];
+	assert(DYNAMIC_STRUCTDECL==tmp.third.second);
+	assert(*tmp.third.first.second==src-&gt;_decl);
+	tmp.third.second = DYNAMIC_C_STRUCTDEF;
+	delete tmp.third.first.second;
+	tmp.third.first.third = src;
+	src = NULL;
+}
+#/*cut-cpp*/
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000273.html">[Zcplusplus-commits] r506 - trunk
</A></li>
	<LI>Next message: <A HREF="000275.html">[Zcplusplus-commits] r508 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#274">[ date ]</a>
              <a href="thread.html#274">[ thread ]</a>
              <a href="subject.html#274">[ subject ]</a>
              <a href="author.html#274">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/zcplusplus-commits">More information about the Zcplusplus-commits
mailing list</a><br>
</body></html>
