<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Zcplusplus-commits] r518 - trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/zcplusplus-commits/2010-October/index.html" >
   <LINK REL="made" HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r518%20-%20trunk&In-Reply-To=%3C20101030092523.3B6C0480E99%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000284.html">
   <LINK REL="Next"  HREF="000286.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Zcplusplus-commits] r518 - trunk</H1>
    <B>zaimoni at mail.berlios.de</B> 
    <A HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r518%20-%20trunk&In-Reply-To=%3C20101030092523.3B6C0480E99%40sheep.berlios.de%3E"
       TITLE="[Zcplusplus-commits] r518 - trunk">zaimoni at mail.berlios.de
       </A><BR>
    <I>Sat Oct 30 11:25:23 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="000284.html">[Zcplusplus-commits] r517 - in trunk: . tools
</A></li>
        <LI>Next message: <A HREF="000286.html">[Zcplusplus-commits] r519 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#285">[ date ]</a>
              <a href="thread.html#285">[ thread ]</a>
              <a href="subject.html#285">[ subject ]</a>
              <a href="author.html#285">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zaimoni
Date: 2010-10-30 11:25:23 +0200 (Sat, 30 Oct 2010)
New Revision: 518

Added:
   trunk/CPreproc.cpp.in
Log:
build system adjust

Added: trunk/CPreproc.cpp.in
===================================================================
--- trunk/CPreproc.cpp.in	                        (rev 0)
+++ trunk/CPreproc.cpp.in	2010-10-30 09:25:23 UTC (rev 518)
@@ -0,0 +1,6122 @@
+// CPreproc.cpp
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+
+#/*cut-cpp*/
+#include &quot;CPreproc.hpp&quot;
+#/*cut-cpp*/
+#/*cut-nocpp*/
+#include &quot;CPreproc_pp.hpp&quot;
+#/*cut-nocpp*/
+
+#include &lt;limits.h&gt;
+#include &lt;time.h&gt;
+#include &lt;stdexcept&gt;
+#include &lt;unistd.h&gt;
+
+#include &quot;AtomicString.h&quot;
+#/*cut-cpp*/
+#include &quot;CSupport.hpp&quot;
+#include &quot;_CSupport3.hpp&quot;
+#/*cut-cpp*/
+#/*cut-nocpp*/
+#include &quot;CSupport_pp.hpp&quot;
+#/*cut-nocpp*/
+#include &quot;C_PPDecimalInteger.hpp&quot;
+#include &quot;CPUInfo.hpp&quot;
+#include &quot;errors.hpp&quot;
+#include &quot;errcount.hpp&quot;
+#include &quot;filesystem.h&quot;
+#include &quot;langroute.hpp&quot;
+#include &quot;load_src.hpp&quot;
+#include &quot;ParseTree.hpp&quot;
+#/*cut-cpp*/
+#include &quot;type_system.hpp&quot;
+#/*cut-cpp*/
+#/*cut-nocpp*/
+#include &quot;type_system_pp.hpp&quot;
+#/*cut-nocpp*/
+#include &quot;weak_token.hpp&quot;
+#include &quot;_version.h&quot;
+#include &quot;Zaimoni.STL/POD.hpp&quot;
+#include &quot;Zaimoni.STL/LexParse/Token.hpp&quot;
+#include &quot;Zaimoni.STL/LexParse/LangConf.hpp&quot;
+#include &quot;Zaimoni.STL/search.hpp&quot;
+#include &quot;Zaimoni.STL/OS/mutex.hpp&quot;
+#include &quot;Zaimoni.STL/Pure.C/format_util.h&quot;
+
+#include &quot;DebugCSupport.h&quot;
+
+using namespace zaimoni;
+
+// beginning of multilingual support
+#define ERR_STR &quot;error: &quot;
+#define WARN_STR &quot;warning: &quot;
+
+#define INSTALL_TO &quot;\\CPP_App\\Z.C++&quot;
+
+//! \todo this should be language-sensitive; LangConf not a good location
+static const char* const fixed_system_include_search[] = {
+	// C++-only install paths
+	INSTALL_TO ZAIMONI_PATH_SEP &quot;lib&quot; ZAIMONI_PATH_SEP &quot;zc++-&quot; ZCC_VERSION ZAIMONI_PATH_SEP &quot;include&quot;,
+	INSTALL_TO ZAIMONI_PATH_SEP &quot;lib&quot; ZAIMONI_PATH_SEP &quot;zc++&quot; ZAIMONI_PATH_SEP &quot;include&quot;,
+	// C++-only relative paths
+	&quot;..&quot; ZAIMONI_PATH_SEP &quot;lib&quot; ZAIMONI_PATH_SEP &quot;zc++-&quot; ZCC_VERSION ZAIMONI_PATH_SEP &quot;include&quot;,
+	&quot;..&quot; ZAIMONI_PATH_SEP &quot;lib&quot; ZAIMONI_PATH_SEP &quot;zc++&quot; ZAIMONI_PATH_SEP &quot;include&quot;,
+	// install path
+	INSTALL_TO ZAIMONI_PATH_SEP &quot;lib&quot; ZAIMONI_PATH_SEP &quot;zcc-&quot; ZCC_VERSION ZAIMONI_PATH_SEP &quot;include&quot;,
+	INSTALL_TO ZAIMONI_PATH_SEP &quot;lib&quot; ZAIMONI_PATH_SEP &quot;zcc&quot; ZAIMONI_PATH_SEP &quot;include&quot;,
+	INSTALL_TO ZAIMONI_PATH_SEP &quot;include&quot;,
+	// relative paths
+	&quot;..&quot; ZAIMONI_PATH_SEP &quot;lib&quot; ZAIMONI_PATH_SEP &quot;zcc-&quot; ZCC_VERSION ZAIMONI_PATH_SEP &quot;include&quot;,
+	&quot;..&quot; ZAIMONI_PATH_SEP &quot;lib&quot; ZAIMONI_PATH_SEP &quot;zcc&quot; ZAIMONI_PATH_SEP &quot;include&quot;,
+	&quot;..&quot; ZAIMONI_PATH_SEP &quot;include&quot;
+};
+
+static const char* actual_system_include_search[] =	{
+	// C++-only install paths
+	NULL,
+	NULL,
+	// C++-only relative paths
+	NULL,
+	NULL,
+	// install path
+	NULL,
+	NULL,
+	NULL,
+	// relative paths
+	NULL,
+	NULL,
+	NULL
+};
+
+BOOST_STATIC_ASSERT(STATIC_SIZE(fixed_system_include_search)==STATIC_SIZE(actual_system_include_search));
+
+#define START_CPP_ONLY_PATHS 4
+
+#undef INSTALL_TO
+
+static bool fixed_system_include_exists_init = false;
+
+static void init_fixed_system_include_search(void)
+{
+	if (fixed_system_include_exists_init) return;
+	char filepath[FILENAME_MAX];
+	char workpath[FILENAME_MAX];
+	size_t i = STATIC_SIZE(fixed_system_include_search);
+	do	{
+		--i;
+		assert(!is_empty_string(fixed_system_include_search[i]));
+		if ('.'==fixed_system_include_search[i][0] &amp;&amp; FILENAME_MAX&gt;strlen(self_path)+strlen(fixed_system_include_search[i])+1)
+			{	// obviously relative path
+			z_dirname(workpath,self_path);
+			strcat(workpath,ZAIMONI_PATH_SEP);
+			strcat(workpath,fixed_system_include_search[i]);
+			char* exists = z_realpath(filepath,workpath);
+			if (exists &amp;&amp; !access(exists,F_OK))
+				actual_system_include_search[i] = register_string(filepath);
+			}
+		else if (ZAIMONI_PATH_SEP[0]==fixed_system_include_search[i][0])
+			{	// absolute path, current drive
+			char* exists = z_realpath(filepath,fixed_system_include_search[i]);
+			if (exists &amp;&amp; !access(exists,F_OK))
+				actual_system_include_search[i] = register_string(filepath);
+			};
+		}
+	while(0&lt;i);
+}
+
+#define LEXER_STRICT_UB (Lexer::CPlusPlus+1)
+
+/* C99
+1 The following macro names151) shall be defined by the implementation:
+_ _DATE_ _ The date of translation of the preprocessing translation unit: a character
+string literal of the form &quot;Mmm dd yyyy&quot;, where the names of the
+months are the same as those generated by the asctime function, and the
+first character of dd is a space character if the value is less than 10. If the
+date of translation is not available, an implementation-defined valid date
+shall be supplied.
+_ _FILE_ _ The presumed name of the current source file (a character string literal).152)
+_ _LINE_ _ The presumed line number (within the current source file) of the current
+source line (an integer constant).152)
+_ _STDC_ _ The integer constant 1, intended to indicate a conforming implementation.
+_ _STDC_HOSTED_ _ The integer constant 1 if the implementation is a hosted
+implementation or the integer constant 0 if it is not.
+_ _STDC_VERSION_ _ The integer constant 199901L.153)
+_ _TIME_ _ The time of translation of the preprocessing translation unit: a character
+string literal of the form &quot;hh:mm:ss&quot; as in the time generated by the
+asctime function. If the time of translation is not available, an
+implementation-defined valid time shall be supplied.
+2 The following macro names are conditionally defined by the implementation:
+_ _STDC_IEC_559_ _ The integer constant 1, intended to indicate conformance to the
+specifications in annex F (IEC 60559 floating-point arithmetic).
+
+_ _STDC_IEC_559_COMPLEX_ _ The integer constant 1, intended to indicate
+adherence to the specifications in informative annex G (IEC 60559
+compatible complex arithmetic).
+_ _STDC_ISO_10646_ _ An integer constant of the form yyyymmL (for example,
+199712L). If this symbol is defined, then every character in the Unicode
+required set, when stored in an object of type wchar_t, has the same
+value as the short identifier of that character. The Unicode required set
+consists of all the characters that are defined by ISO/IEC 10646, along with
+all amendments and technical corrigenda, as of the specified year and
+month.
+3 The values of the predefined macros (except for _ _FILE_ _ and _ _LINE_ _) remain
+constant throughout the translation unit.
+4 None of these macro names, nor the identifier defined, shall be the subject of a
+#define or a #undef preprocessing directive. Any other predefined macro names
+shall begin with a leading underscore followed by an uppercase letter or a second
+underscore.
+5 The implementation shall not predefine the macro _ _cplusplus, nor shall it define it
+in any standard header.
+*/
+
+/* C++0x
+1 The following macro names shall be defined by the implementation:
+_ _ cplusplus
+The name _ _ cplusplus is defined to the value [tbd] when compiling a C++ translation unit.146)
+_ _ DATE _ _
+The date of translation of the source file (a character string literal of the form &quot;Mmm dd yyyy&quot;, where the names
+of the months are the same as those generated by the asctime function, and the first character of dd is a space
+character if the value is less than 10). If the date of translation is not available, an implementation-defined valid
+date is supplied.
+_ _ FILE _ _
+The presumed name of the source file (a character string literal).
+_ _ LINE _ _
+The line number of the current source line (a decimal constant).
+_ _ STDC_HOSTED _ _
+The integer constant 1 if the implementation is a hosted implementation or the integer constant 0 if it is not.
+_ _ TIME _ _
+The time of translation of the source file (a character string literal of the form &quot;hh:mm:ss&quot; as in the time generated
+by the asctime function). If the time of translation is not available, an implementation-defined valid time is
+supplied.
+2 The following macro names are conditionally defined by the implementation:
+_ _ STDC _ _
+Whether _ _ STDC _ _ is predefined and if so, what its value is, are implementation-defined.
+
+_ _ STDC_VERSION _ _
+Whether _ _ STDC_VERSION _ _ is predefined and if so, what its value is, are implementation-defined.
+_ _ STDC_ISO_10646 _ _
+An integer constant of the form yyyymmL (for example, 199712L), intended to indicate that values of type
+wchar_t are the coded representations of the characters defined by ISO/IEC 10646, along with all amendments
+and technical corrigenda as of the specified year and month.
+
+3 The values of the predefined macros (except for _ _ LINE _ _ and _ _ FILE _ _) remain constant throughout the translation
+unit.
+4 If any of the pre-defined macro names in this subclause, or the identifier defined, is the subject of a #define or
+a #undef preprocessing directive, the behavior is undefined. Any other predefined macro names shall begin with a
+leading underscore followed by an uppercase letter or a second underscore.
+*/
+
+#define DICT_STRUCT(A) { (A), sizeof(A)-1 }
+
+// design decision: make this consistent across both C, C++
+// design decision: make this consistent across all versions of C, C++
+static const POD_pair&lt;const char*,size_t&gt; C99_CPP0x_locked_macros_default[]
+ =	{	DICT_STRUCT(&quot;__DATE__&quot;),				// determine in realtime at start of translation
+		DICT_STRUCT(&quot;__TIME__&quot;),				// determine in realtime at start of translation
+		DICT_STRUCT(&quot;__FILE__&quot;),				// special handling
+		DICT_STRUCT(&quot;__LINE__&quot;),				// special handling
+		DICT_STRUCT(&quot;__VA_ARGS__&quot;),				// disallowed as identifier anywhere except variadic function macro replacement list, C99/C++0x
+		// __STDC_ macros are locked anyway, as they are reserved by the C/C++ standards
+//		DICT_STRUCT(&quot;__STDC__&quot;),				// define to 1 for both (GCC, note that K&amp;R prototype-compatibility code uses this)
+//		DICT_STRUCT(&quot;__STDC_HOSTED__&quot;),			// define to 1 for now
+//		DICT_STRUCT(&quot;__STDC_VERSION__&quot;),		// define to 1 for now (as we don't really implement much of anything yet)
+//		DICT_STRUCT(&quot;__STDC_IEC_559__&quot;),		// undefined
+//		DICT_STRUCT(&quot;__STDC_IEC_559_COMPLEX__&quot;),// mentioned in C99 only; undefined
+//		DICT_STRUCT(&quot;__STDC_IEC_10646__&quot;),		// mentioned in C99 only; undefined
+		DICT_STRUCT(&quot;__cplusplus&quot;),				// undefined/C99, define to 1 for C++0x
+		DICT_STRUCT(&quot;defined&quot;),					// must be undefined or else undefined behavior, even not considering C99 6.10.8 p4
+		DICT_STRUCT(&quot;_Pragma&quot;),					// considering the syntactical role of the _Pragma operator, lock it even though the standards don't require us to. 
+		DICT_STRUCT(&quot;__TIMESTAMP__&quot;),			// lock down our extension macros
+		DICT_STRUCT(&quot;__COUNTER__&quot;),				// lock down our extension macros
+		DICT_STRUCT(&quot;__INCLUDE_LEVEL__&quot;),		// lock down our extension macros
+		DICT_STRUCT(&quot;__has_include&quot;),			// lock down our extension macros
+		DICT_STRUCT(&quot;__ZCC__&quot;),					// lock down our identity
+		DICT_STRUCT(&quot;__ZCC_MINOR__&quot;),			// lock down our identity
+		DICT_STRUCT(&quot;__ZCC_PATCHLEVEL__&quot;)		// lock down our identity
+	};
+
+static const POD_pair&lt;const char*,const char*&gt; C99_macro_identifier_default[]
+ =	{	{&quot;__DATE__&quot;, NULL},			// start standard-mandated macros
+		{&quot;__TIME__&quot;, NULL},
+		{&quot;__FILE__&quot;, NULL},
+		{&quot;__LINE__&quot;, NULL},
+		{&quot;__STDC__&quot;, &quot;1&quot;},
+		{&quot;__STDC_HOSTED__&quot;, &quot;1&quot;},
+		{&quot;__STDC_VERSION__&quot;, &quot;1&quot;},		// end standard-mandated macros
+		{&quot;__TIMESTAMP__&quot;, NULL},		// extension: GCC, CLang, MSVC
+		{&quot;__COUNTER__&quot;, NULL},			// extension: GCC, CLang, MSVC
+		{&quot;__INCLUDE_LEVEL__&quot;, NULL},	// extension: GCC, CLang
+		{&quot;__ZCC__&quot;, DEEP_STRINGIZE(ZCC_VERSION_MAJOR)},				// identity : major version
+		{&quot;__ZCC_MINOR__&quot;, DEEP_STRINGIZE(ZCC_VERSION_MINOR)},		// minor version
+		{&quot;__ZCC_PATCHLEVEL__&quot;, DEEP_STRINGIZE(ZCC_VERSION_PATCH)}	// patchlevel
+	};
+
+static const POD_pair&lt;const char*,const char*&gt; CPP0x_macro_identifier_default[]
+ =	{	{&quot;__TIMESTAMP__&quot;, NULL},		// extension: GCC, CLang, MSVC
+		{&quot;__COUNTER__&quot;, NULL},			// extension: GCC, CLang, MSVC
+		{&quot;__INCLUDE_LEVEL__&quot;, NULL},	// extension: GCC, CLang
+		{&quot;__DATE__&quot;, NULL},			// start standard-mandated macros
+		{&quot;__TIME__&quot;, NULL},
+		{&quot;__FILE__&quot;, NULL},
+		{&quot;__LINE__&quot;, NULL},
+		{&quot;__STDC__&quot;, &quot;1&quot;},
+		{&quot;__STDC_HOSTED__&quot;, &quot;1&quot;},
+		{&quot;__STDC_VERSION__&quot;, &quot;1&quot;},
+		{&quot;__cplusplus&quot;, &quot;1&quot;},		// end standard-mandated macros
+		{&quot;__ZCC__&quot;, DEEP_STRINGIZE(ZCC_VERSION_MAJOR)},				// identity : major version
+		{&quot;__ZCC_MINOR__&quot;, DEEP_STRINGIZE(ZCC_VERSION_MINOR)},		// minor version
+		{&quot;__ZCC_PATCHLEVEL__&quot;, DEEP_STRINGIZE(ZCC_VERSION_PATCH)}	// patchlevel
+	};
+
+CPreprocessor::CPreprocessor(const virtual_machine::CPUInfo&amp; _target_machine, const char* const _lang)
+:	counter_macro(0),
+	include_level(0),
+	lang_code(lang_index(_lang)),
+	lang(lexer_from_lang(lang_code)),
+	target_machine(_target_machine),
+	macro_identifier_default(NULL),
+	macro_locked_default(C99_CPP0x_locked_macros_default),
+	macro_identifier_default_count(0),
+	macro_locked_default_count(STATIC_SIZE(C99_CPP0x_locked_macros_default)),
+	debug_mode(false)
+{
+	switch(lang_code)
+	{
+	case Lang::C: {
+			macro_identifier_default = C99_macro_identifier_default;
+			macro_identifier_default_count = STATIC_SIZE(C99_macro_identifier_default);
+			break;
+		};
+	case Lang::CPlusPlus: {
+			macro_identifier_default = CPP0x_macro_identifier_default;
+			macro_identifier_default_count = STATIC_SIZE(CPP0x_macro_identifier_default);
+			break;
+		};
+	default: FATAL(&quot;Invalid language code&quot;);
+	}
+	init_fixed_system_include_search();
+	// reality checks on the language
+	assert(NULL!=lang.EscapeStringLength);
+	assert(NULL!=lang.EscapeString);
+	assert(NULL!=lang.UnescapeStringLength);
+	assert(NULL!=lang.UnescapeString);
+	assert(NULL!=lang.pp_support);
+	assert(NULL!=lang.InvariantKeywords);
+	assert(0&lt;lang.len_InvariantKeywords);
+}
+
+static const POD_pair&lt;const char*,size_t&gt; valid_directives[]
+	=	{	DICT_STRUCT(&quot;if&quot;),
+			DICT_STRUCT(&quot;ifdef&quot;),
+			DICT_STRUCT(&quot;ifndef&quot;),
+			DICT_STRUCT(&quot;elif&quot;),
+			DICT_STRUCT(&quot;else&quot;),
+			DICT_STRUCT(&quot;endif&quot;),
+			DICT_STRUCT(&quot;include&quot;),
+			DICT_STRUCT(&quot;define&quot;),
+			DICT_STRUCT(&quot;undef&quot;),
+			DICT_STRUCT(&quot;line&quot;),
+			DICT_STRUCT(&quot;error&quot;),
+			DICT_STRUCT(&quot;pragma&quot;)
+		};
+
+static const POD_pair&lt;const char*,size_t&gt; accept_pragma_leading_tokens[]
+	=	{	DICT_STRUCT(&quot;STDC&quot;),	// C99
+			DICT_STRUCT(&quot;ZCC&quot;),		// our own
+			DICT_STRUCT(&quot;GCC&quot;),		// we also pay attention to GCC pragmas
+			DICT_STRUCT(&quot;message&quot;)	// #pragma message(&quot;...&quot;)
+		};
+
+// yes, enum would be better style
+#define PRAGMA_LEADING_STDC 0
+#define PRAGMA_LEADING_ZCC 1
+// #define PRAGMA_LEADING_GCC 2
+#define PRAGMA_MESSAGE 3
+
+static const POD_pair&lt;const char*,size_t&gt; pragma_STDC_on_off_switch[]	// C99 6.10.5p2
+	=	{	DICT_STRUCT(&quot;OFF&quot;),
+			DICT_STRUCT(&quot;DEFAULT&quot;),
+			DICT_STRUCT(&quot;ON&quot;)
+		};
+
+#define ON_OFF_SWITCH_OFF 0
+#define ON_OFF_SWITCH_DEFAULT 1
+#define ON_OFF_SWITCH_ON 2
+
+static const POD_pair&lt;const char*,size_t&gt; pragma_STDC_keywords[]
+	=	{	DICT_STRUCT(&quot;FP_CONTRACT&quot;),
+			DICT_STRUCT(&quot;FENV_ACCESS&quot;),
+			DICT_STRUCT(&quot;CX_LIMITED_RANGE&quot;)
+		};
+
+#define PRAGMA_STDC_FP_CONTRACT 0
+#define PRAGMA_STDC_FENV_ACCESS 1
+#define PRAGMA_STDC_CX_LIMITED_RANGE 2
+
+static const POD_pair&lt;const char*,size_t&gt; pragma_ZCC_keywords[]
+	=	{	DICT_STRUCT(&quot;lock&quot;),
+			DICT_STRUCT(&quot;enable_typeid&quot;)
+		};
+
+#define PRAGMA_ZCC_LOCK 0
+#define PRAGMA_ZCC_ENABLE_TYPEID 1
+#/*cut-cpp*/
+
+const POD_pair&lt;const char*,size_t&gt; pragma_relay_keywords[]
+	=	{	DICT_STRUCT(&quot;_ZCC_FP_CONTRACT_OFF&quot;),
+			DICT_STRUCT(&quot;_ZCC_FP_CONTRACT_DEFAULT&quot;),
+			DICT_STRUCT(&quot;_ZCC_FP_CONTRACT_ON&quot;),
+			DICT_STRUCT(&quot;_ZCC_FENV_ACCESS_OFF&quot;),
+			DICT_STRUCT(&quot;_ZCC_FENV_ACCESS_DEFAULT&quot;),
+			DICT_STRUCT(&quot;_ZCC_FENV_ACCESS_ON&quot;),
+			DICT_STRUCT(&quot;_ZCC_CX_LIMITED_RANGE_OFF&quot;),
+			DICT_STRUCT(&quot;_ZCC_CX_LIMITED_RANGE_DEFAULT&quot;),
+			DICT_STRUCT(&quot;_ZCC_CX_LIMITED_RANGE_ON&quot;),
+			DICT_STRUCT(&quot;_ZCC_enable_typeid&quot;)
+		};
+
+BOOST_STATIC_ASSERT(PRAGMA_RELAY_KEYWORDS_STRICT_UB==STATIC_SIZE(pragma_relay_keywords));		
+#/*cut-cpp*/
+#undef DICT_STRUCT
+
+static void _init_weak_token(weak_token&amp; dest, const Token&lt;char&gt;&amp; x,const POD_triple&lt;size_t,size_t,lex_flags&gt;&amp; pretoken)
+{
+	dest.token.first = x.data()+pretoken.first;
+	dest.token.second = pretoken.second;
+	dest.flags = pretoken.third;
+	dest.logical_line.first = x.original_line.first;
+	dest.logical_line.second = x.original_line.second+pretoken.first;
+	dest.src_filename = x.src_filename;
+}
+
+static void _weak_tokenize_aux(const Token&lt;char&gt;&amp; x,const autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt;&amp; pretokenized, autovalarray_ptr&lt;weak_token&gt;&amp; weaktoken_list)
+{
+	assert(!x.empty());
+	assert(!pretokenized.empty());
+	weaktoken_list.resize(pretokenized.size());
+	size_t j = pretokenized.size();
+	do	{
+		--j;
+		_init_weak_token(weaktoken_list[j],x,pretokenized[j]);
+		}
+	while(0&lt;j);
+}
+
+static void _parsetreeize_aux(const Token&lt;char&gt;&amp; x,const autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt;&amp; pretokenized, parse_tree&amp; parsetree)
+{
+	assert(!x.empty());
+	assert(!pretokenized.empty());
+	if (1==pretokenized.size())
+		{
+		_init_weak_token(parsetree.index_tokens[0],x,pretokenized.front());
+		return;
+		}
+	if (!parsetree.resize&lt;0&gt;(pretokenized.size())) throw std::bad_alloc();
+	size_t j = pretokenized.size();
+	do	{
+		--j;
+		_init_weak_token(parsetree.c_array&lt;0&gt;()[j].index_tokens[0],x,pretokenized[j]);
+		}
+	while(0&lt;j);
+}
+
+static void _flush_duplicated_ws(Token&lt;char&gt;&amp; x, const LangConf&amp; lang)
+{
+	lex_flags scratch_flags;
+	size_t offset2 = lang.UnfilteredNextToken(x.data(),scratch_flags);
+	while(offset2&lt;x.size())
+		{
+		const size_t skip_ws = strspn(x.data()+offset2,lang.WhiteSpace);
+		if (0&lt;skip_ws)
+			{
+			if (skip_ws&gt;=x.size()-offset2)
+				{
+				x.lslice(offset2);
+				return;
+				};
+			if (strchr(lang.AtomicSymbols,x.data()[offset2-1]) || strchr(lang.AtomicSymbols,x.data()[offset2+skip_ws]))
+				x.intradelete(offset2,skip_ws);
+			else{
+				x.replace_once(std::nothrow,offset2,skip_ws,' ');
+				++offset2;
+				}
+			}
+		offset2 += lang.UnfilteredNextToken(x.data()+offset2,scratch_flags);
+		}
+}
+
+template&lt;class IntType,class Iterator&gt;
+void
+STL_translate_first(IntType origin, Iterator iter, const Iterator iter_end)
+{
+	while(iter_end!=iter) (iter++)-&gt;first += origin;
+}
+
+template&lt;class IntType,class T&gt;
+inline void STL_translate_first(IntType origin, T&amp; x)
+{
+	assert(!x.empty());
+	STL_translate_first(origin,x.begin(),x.end());
+}
+
+template&lt;class IntType,class Iterator&gt;
+void
+STL_translate_second(IntType origin, Iterator iter, const Iterator iter_end)
+{
+	while(iter_end!=iter) (iter++)-&gt;second += origin;
+}
+
+//! \todo use lang.AtomicSymbols to get further compression
+static bool _flush_token_gaps(Token&lt;char&gt;&amp; x, autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt;&amp; pretokenized, const LangConf&amp; lang)
+{
+	assert(!x.empty());
+	assert(!pretokenized.empty());
+	bool acted = false;
+	if (x.size()&gt;pretokenized.back().first+pretokenized.back().second)
+		{
+		x.lslice(pretokenized.back().first+pretokenized.back().second);
+		acted = true;
+		};
+	if (1&lt;pretokenized.size())
+		{
+		size_t i = pretokenized.size()-1;
+		bool old_atomic = 1==pretokenized[i].second &amp;&amp; strchr(lang.AtomicSymbols,x.data()[pretokenized[i].first]);
+		do	{
+			--i;
+			const bool new_atomic = 1==pretokenized[i].second &amp;&amp; strchr(lang.AtomicSymbols,x.data()[pretokenized[i].first]);
+			if (new_atomic || old_atomic)
+				{
+				if (pretokenized[i+1].first&gt;pretokenized[i].first+pretokenized[i].second)
+					{
+					const size_t delta = pretokenized[i+1].first-(pretokenized[i].first+pretokenized[i].second);
+					x.intradelete(pretokenized[i].first+pretokenized[i].second,delta);
+					STL_translate_first(-delta,pretokenized.begin()+i+1,pretokenized.end());	// unsigned modulo arithmetic makes this work
+					acted = true;
+					}
+				}
+			else if (pretokenized[i+1].first-1&gt;pretokenized[i].first+pretokenized[i].second)
+				{
+				const size_t delta = pretokenized[i+1].first-(pretokenized[i].first+pretokenized[i].second)-1;
+				x.replace_once(std::nothrow,pretokenized[i].first+pretokenized[i].second,delta+1,' ');
+				STL_translate_first(-delta,pretokenized.begin()+i+1,pretokenized.end());	// unsigned modulo arithmetic makes this work
+				acted = true;
+				};
+			old_atomic = new_atomic;
+			}
+		while(0&lt;i);
+		}
+	// do *not* remove space before the first token; CPreprocessor::if_elif_syntax_ok will break, as that's where the #if/#elif is
+	return acted;
+}
+
+namespace PP {
+
+enum directive_indexes	{	IF = 0,
+							IFDEF,
+							IFNDEF,
+							ELIF,
+							ELSE,
+							ENDIF,
+							INCLUDE,
+							DEFINE,
+							UNDEF,
+							LINE,
+							ERROR,
+							PRAGMA
+						};
+
+}
+
+#define MAX_PP_DIRECTIVE (PP::PRAGMA+1)
+#define PP_INVALID 15
+
+// we assume that it takes exactly 4 bits to numerically represent the above enum
+// we assume that 15 is available to flag invalid
+BOOST_STATIC_ASSERT((1&lt;&lt;4)&gt;=MAX_PP_DIRECTIVE &amp;&amp; ((1&lt;&lt;3)&lt;MAX_PP_DIRECTIVE));
+
+static errr find_directive(const char* const Text, const LangConf&amp; lang)
+{
+	assert(!is_empty_string(Text));
+	size_t i = STATIC_SIZE(valid_directives);
+	do	{
+		--i;
+		if (!strncmp(valid_directives[i].first,Text,valid_directives[i].second)
+			&amp;&amp; (valid_directives[i].second==strlen(Text) || lang.IsWS(Text[valid_directives[i].second])))
+			return i;
+		}
+	while(0&lt;i);
+	return -1;
+}
+
+static void message_header(const Token&lt;char&gt;&amp; src)
+{
+	assert(src.src_filename &amp;&amp; *src.src_filename);
+	message_header(src.src_filename,src.logical_line.first);
+}
+
+static void message_header2(const Token&lt;char&gt;&amp; src,size_t where)
+{
+	assert(NULL!=src.src_filename);
+	INC_INFORM(src.src_filename);
+	INC_INFORM(':');
+	INC_INFORM(src.logical_line.first);
+	INC_INFORM('.');
+	INC_INFORM(where);
+	INC_INFORM(&quot;: &quot;);
+}
+
+void CPreprocessor::detailed_UNICODE_syntax(Token&lt;char&gt;&amp; x) const
+{
+	assert(!x.empty());
+	const char* UNICODE_escape = strstr(x.data(),&quot;\\U&quot;);
+	while(NULL!=UNICODE_escape)
+		{
+		const size_t tail = x.size()-(UNICODE_escape-x.data());
+		if (10U&gt;tail)
+			{	//! \test UNICODE.C99/Error_AstralTruncate.h
+				//! \test UNICODE.C99/Error_AstralTruncate.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INFORM(&quot;C99 6.4.3p1/C++98 2.2p2: astral UNICODE escape prematurely terminated by end of line&quot;);
+			zcc_errors.inc_error();
+			break;
+			}
+		if (!and_range_n(IsHexadecimalDigit,UNICODE_escape+2,8))
+			{	//! \test UNICODE.C99/Error_AstralNonhex.h
+				//! \test UNICODE.C99/Error_AstralNonhex.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INFORM(&quot;C99 6.4.3p1/C++98 2.2p2: astral UNICODE escape contains non-hexadecimal digits&quot;);
+			zcc_errors.inc_error();
+			}
+		else
+			assert(4&gt;std::count(UNICODE_escape+2,UNICODE_escape+6,'0'));	// should have caught this in pre-filtration
+		UNICODE_escape = (12U&lt;=tail) ? strstr(UNICODE_escape+10,&quot;\\U&quot;) : NULL;
+		};
+	UNICODE_escape = strstr(x.data(),&quot;\\u&quot;);
+	while(NULL!=UNICODE_escape)
+		{
+		const size_t tail = x.size()-(UNICODE_escape-x.data());
+		if (6U&gt;tail)
+			{	//! \test UNICODE.C99/Error_Truncate.h
+				//! \test UNICODE.C99/Error_Truncate.hpp
+				//! \test UNICODE.C99/Error_Truncate2.h
+				//! \test UNICODE.C99/Error_Truncate2.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INFORM(&quot;UNICODE escape prematurely terminated by end of line (C99 6.4.3p1/C++0x 2.2p2)&quot;);
+			zcc_errors.inc_error();
+			break;
+			}
+		if (!and_range_n(IsHexadecimalDigit,UNICODE_escape+2,4))
+			{	//! \test UNICODE.C99/Error_Nonhex.h
+				//! \test UNICODE.C99/Error_Nonhex.hpp
+				//! \test UNICODE.C99/Error_Nonhex2.h
+				//! \test UNICODE.C99/Error_Nonhex2.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INFORM(&quot;UNICODE escape contains non-hexadecimal digits (C99 6.4.3p1/C++0x 2.2p2)&quot;);
+			zcc_errors.inc_error();
+			}
+		else if ('D'==UNICODE_escape[2] &amp;&amp; strchr(list_hexadecimal_digits+8,UNICODE_escape[3]))
+			{	//! \test UNICODE.C99/Error_SZone.h
+				//! \test UNICODE.C99/Error_SZone.hpp
+				//! \test UNICODE.C99/Error_SZone2.h
+				//! \test UNICODE.C99/Error_SZone2.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INFORM(&quot;UNICODE escape is in S-zone (D800-DFFF), reserved for UTF-16 (C99 6.4.3p1/C++0x 2.2p2)&quot;);
+			zcc_errors.inc_error();
+			}
+		else if (2==std::count(UNICODE_escape+2,UNICODE_escape+4,'0'))
+			{	//! \todo fix assumption that CHAR_BIT==8
+			const unsigned char tmp = (unsigned char)(16*InterpretHexadecimalDigit(UNICODE_escape[4])+InterpretHexadecimalDigit(UNICODE_escape[5]));
+			bool down_convert = true;
+			assert(160U&gt;tmp);	// should have caught this already
+			// C++98 is &quot;anything goes&quot;, but don't worry about that for now
+			// C99 and C++0x agree that these are bad
+			if ((unsigned char)(32U)&gt;tmp || ((unsigned char)('\x7F')&lt;=tmp &amp;&amp; (unsigned char)('\x9F')&gt;=tmp))
+				{	//! \test UNICODE.C99/Error_CTRL_low.h
+					//! \test UNICODE.C99/Error_CTRL_low.hpp
+					//! \test UNICODE.C99/Error_CTRL_low2.h
+					//! \test UNICODE.C99/Error_CTRL_low2.hpp
+					//! \test UNICODE.C99/Error_CTRL_high.h
+					//! \test UNICODE.C99/Error_CTRL_high.hpp
+					//! \test UNICODE.C99/Error_CTRL_high2.h
+					//! \test UNICODE.C99/Error_CTRL_high2.hpp
+				message_header(x);
+				INC_INFORM(ERR_STR);
+				INFORM(&quot;UNICODE escape is in a control character range (C99 6.4.3p1/C++0x 2.2p2)&quot;);
+				zcc_errors.inc_error();
+				down_convert = false;
+				}
+			else if (Lang::C==lang_code)
+				{	// C rejects anything escapeish, or in the source character set
+					//! \test UNICODE.C99/Error_Source.h
+					//! \test UNICODE.C99/Error_Source2.h
+				if ('$'!=tmp &amp;&amp; '@'!=tmp &amp;&amp; '`'!=tmp)	//! \todo deal with ASCII dependence
+					{
+					message_header(x);
+					INC_INFORM(ERR_STR);
+					INFORM(&quot;UNICODE escape is in the source character set (C99 6.4.3p1)&quot;);
+					zcc_errors.inc_error();
+					down_convert = false;
+					}
+				};
+			if (down_convert)
+				{	//! \test cpp/default/Preprocess_UNICODE_deastral.hpp, cpp/default/Preprocess_UNICODE_deastral.h
+				const size_t offset = UNICODE_escape-x.data();
+				x.replace_once(std::nothrow,offset,6,tmp);
+				UNICODE_escape = (8U&lt;=tail) ? strstr(x.data()+offset+1,&quot;\\u&quot;) : NULL;
+				continue;
+				}
+			}
+		UNICODE_escape = (8U&lt;=tail) ? strstr(UNICODE_escape+10,&quot;\\u&quot;) : NULL;
+		};
+}
+
+// flags type in Token is unsigned long
+//! \todo consider hooking into POSIX (replace ULONG_BIT with LONG_BIT)
+#define ULONG_BIT (sizeof(unsigned long)*CHAR_BIT)
+#define PREPROCESSING_DIRECTIVE_FLAG (1UL&lt;&lt;(ULONG_BIT-1))
+#define PACK_DIRECTIVE(A,B) {(A) &amp;= ~((15UL)&lt;&lt;(ULONG_BIT-5)); (A) |= ((B)&lt;&lt;(ULONG_BIT-5));}
+#define UNPACK_DIRECTIVE(A) (((A) &amp; ~PREPROCESSING_DIRECTIVE_FLAG)&gt;&gt;(ULONG_BIT-5))
+#define SYNTAX_CHECKED_FLAG (1UL&lt;&lt;(ULONG_BIT-6))
+#define INVALID_DIRECTIVE_FLAG (1UL&lt;&lt;(ULONG_BIT-7))
+
+/*! 
+ * Preprocesses a file with the C preprocessor, using the lexer lang specified at preprocessor construction.
+ * 
+ * \param TokenList : tokens to be preprocessed.
+ * 
+ * \return bool
+ */
+bool CPreprocessor::preprocess(autovalarray_ptr&lt;Token&lt;char&gt;* &gt;&amp; TokenList)
+{
+	autovalarray_ptr&lt;char*&gt; locked_macros;
+	autovalarray_ptr&lt;char*&gt; macros_object;
+	autovalarray_ptr&lt;Token&lt;char&gt;*&gt; macros_object_expansion;
+	autovalarray_ptr&lt;Token&lt;char&gt;*&gt; macros_object_expansion_pre_eval;
+	autovalarray_ptr&lt;char*&gt; macros_function;
+	autovalarray_ptr&lt;Token&lt;char&gt;*&gt; macros_function_arglist;
+	autovalarray_ptr&lt;Token&lt;char&gt;*&gt; macros_function_expansion;
+	autovalarray_ptr&lt;Token&lt;char&gt;*&gt; macros_function_expansion_pre_eval;
+	autovalarray_ptr&lt;POD_triple&lt;const char*, const char*,uintptr_t&gt; &gt; include_file_index;
+	autovalarray_ptr&lt;POD_pair&lt;const char*,autovalarray_ptr&lt;Token&lt;char&gt;*&gt;* &gt; &gt; include_file_cache;
+	const type_system min_types((Lang::C==lang_code) ? C_atomic_types : CPP_atomic_types,(Lang::C==lang_code) ? C_TYPE_MAX : CPP_TYPE_MAX,C_int_priority+C_PP_INT_PRIORITY_ORIGIN,C_INT_PRIORITY_SIZE-C_PP_INT_PRIORITY_ORIGIN);
+
+	// this is subject to the Y10K bug, per standard.
+	// construct __DATE__, __TIME__ macro targets
+	{
+	time_date_buffer[0] = '&quot;';
+	time_buffer[0]='&quot;';
+	date_buffer[0]='&quot;';
+	time_t start_time = time(NULL);
+	strcpy(time_date_buffer+1,ctime(&amp;start_time));
+	strcpy(time_date_buffer+1+24,&quot;\&quot;&quot;);
+	// have base buffer, construct time
+	strncpy(time_buffer+1,time_date_buffer+12,8);
+	time_buffer[0]='&quot;';
+	strcpy(time_buffer+9,&quot;\&quot;&quot;);
+	// construct date
+	strncpy(date_buffer+1,time_date_buffer+5,7);
+	strncpy(date_buffer+8,time_date_buffer+21,4);
+	date_buffer[0]='&quot;';
+	strcpy(date_buffer+12,&quot;\&quot;&quot;);
+	}
+
+	{	// do detailed UNICODE error trapping here: S-zone [\uD800-\uDFFF], sub-\u00A0 processing (latter is language-sensitive), syntax
+	const autovalarray_ptr&lt;Token&lt;char&gt;* &gt;::iterator iter_end = TokenList.end();
+	autovalarray_ptr&lt;Token&lt;char&gt;* &gt;::iterator iter = TokenList.begin();
+	while(iter!=iter_end) detailed_UNICODE_syntax(**iter++);
+	}
+
+	_preprocess(TokenList, locked_macros, macros_object, macros_object_expansion, macros_object_expansion_pre_eval, macros_function, macros_function_arglist, macros_function_expansion, macros_function_expansion_pre_eval, include_file_index, include_file_cache, min_types);
+#/*cut-cpp*/
+#/*cut-nocpp*/
+//	_preprocess_alt(TokenList, locked_macros, macros_object, macros_object_expansion, macros_object_expansion_pre_eval, macros_function, macros_function_arglist, macros_function_expansion, macros_function_expansion_pre_eval, include_file_index, include_file_cache, min_types);
+#/*cut-nocpp*/
+#/*cut-cpp*/
+
+	// need whitespace tokens here to force pretty-printing
+	debug_to_stderr(TokenList,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,locked_macros);
+	die_on_pp_errors();
+	if (TokenList.empty())
+		{	//! \todo make this more efficient by providing a global flush-all
+		const char* atom_string = string_from_index(0);
+		while(NULL!=atom_string)
+			{
+			deregister_index(0);
+			atom_string = string_from_index(0);
+			};
+		return true;
+		}
+
+	// Reset internal flags
+	// for this to work, #pragma must be converted to _Pragma operators
+	// do not flush whitespace tokens here, as the standalone will need them
+	{
+	const autovalarray_ptr&lt;Token&lt;char&gt;* &gt;::iterator iter_end = TokenList.end();
+	autovalarray_ptr&lt;Token&lt;char&gt;* &gt;::iterator iter = TokenList.begin();
+	if (iter!=iter_end)
+		do	{
+			(*iter)-&gt;flags &amp;= ~PREPROCESSING_DIRECTIVE_FLAG;
+			PACK_DIRECTIVE((*iter)-&gt;flags,0);
+			}
+		while(++iter!=iter_end);
+	}
+
+	// invoke GC on include_file_cache
+	size_t i = include_file_cache.size();
+	while(0&lt;i)
+		{
+		delete include_file_cache[--i].second;
+		include_file_cache[i].second = NULL;	// for style reasons
+		};
+	include_file_cache.reset();	// remove
+	include_file_index.reset();	// remove
+
+	// check for unused atomic strings
+	{
+	size_t x = 0;
+	const char* atom_string = string_from_index(x);
+	while(NULL!=atom_string)
+		{
+		bool string_used = false;
+		i = TokenList.size();
+		do	if (	atom_string==TokenList[--i]-&gt;src_filename
+				|| 	atom_string==TokenList[i]-&gt;parent_dir)
+				{
+				string_used = true;
+				break;
+				}
+		while(0&lt;i);
+		if (string_used)
+			++x;
+		else
+			deregister_index(x);
+		atom_string = string_from_index(x);
+		};
+	}
+	return true;
+}
+
+static inline bool
+pragma_locked_macro(const char* const x,const size_t x_len,const autovalarray_ptr&lt;char*&gt;&amp; locked_macros)
+{
+	assert(!is_empty_string(x));
+	assert(0&lt;x_len);
+	return 0&lt;=binary_find(x,x_len,locked_macros);
+}
+
+static bool line_is_preprocessing_directive(Token&lt;char&gt;&amp; x)
+{	// normalize leading %: to # to handle equivalency of these tokens
+	//! \test cpp/Error_error_directive2.hpp
+	if ((sizeof(&quot;%:&quot;)-1)&lt;=x.size() &amp;&amp; !strncmp(x.data(),&quot;%:&quot;,sizeof(&quot;%:&quot;)-1)) x.replace_once(std::nothrow,0,sizeof(&quot;%:&quot;)-1,&quot;#&quot;);
+	return '#'==x.front();
+}
+
+static void discard_locked_macro(autovalarray_ptr&lt;Token&lt;char&gt;* &gt;&amp; TokenList, const size_t i,const int directive_type,const size_t first_token_len)
+{
+	message_header(*TokenList[i]);
+	INC_INFORM(ERR_STR);
+	INC_INFORM(&quot;#&quot;);
+	INC_INFORM(valid_directives[directive_type].first);
+	INC_INFORM(&quot; applied to locked macro &quot;);
+	INC_INFORM(TokenList[i]-&gt;data()+valid_directives[directive_type].second+2,first_token_len);
+	INFORM(&quot;; discarding directive. (ZCPP pragma effect)&quot;);
+	TokenList.DeleteIdx(i);
+	zcc_errors.inc_error();
+}
+
+static void C99_reject_keyword_macros(autovalarray_ptr&lt;Token&lt;char&gt;* &gt;&amp; TokenList, size_t include_where, const char* look_for, const LangConf&amp; lang, autovalarray_ptr&lt;char*&gt;&amp; macros_object, autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_object_expansion, autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_object_expansion_pre_eval, autovalarray_ptr&lt;char*&gt;&amp; macros_function, autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_arglist, autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_expansion, autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_expansion_pre_eval)
+{
+	assert(NULL!=look_for);
+	size_t j = lang.len_InvariantKeywords;
+	do	{
+		--j;
+		const errr object_macro_index = binary_find(lang.InvariantKeywords[j].first,lang.InvariantKeywords[j].second,macros_object);
+		const errr function_macro_index = binary_find(lang.InvariantKeywords[j].first,lang.InvariantKeywords[j].second,macros_function);
+		assert(0&gt;object_macro_index || 0&gt;function_macro_index);
+		if (0&lt;=object_macro_index || 0&lt;=function_macro_index)
+			{
+			message_header(*TokenList[include_where]);
+			INC_INFORM(ERR_STR);
+			INC_INFORM(&quot;keyword '&quot;);
+			INC_INFORM(0&lt;=object_macro_index ? macros_object[object_macro_index] : macros_function[function_macro_index]);
+			INC_INFORM(&quot;' defined as a macro when including system header &lt;&quot;);
+			INC_INFORM(look_for);
+			INFORM(&quot;&gt;.  Defining undefined behavior as undefining macro and proceeding.  (C99 7.1.2p4)&quot;);
+			zcc_errors.inc_error();
+			if (0&lt;=object_macro_index)
+				{
+				macros_object.DeleteIdx(object_macro_index);
+				macros_object_expansion.DeleteIdx(object_macro_index);
+				macros_object_expansion_pre_eval.DeleteIdx(object_macro_index);
+				};
+			if (0&lt;=function_macro_index)
+				{
+				macros_function.DeleteIdx(function_macro_index);
+				macros_function_arglist.DeleteIdx(function_macro_index);
+				macros_function_expansion.DeleteIdx(function_macro_index);
+				macros_function_expansion_pre_eval.DeleteIdx(function_macro_index);
+				};
+			return;
+			}
+		}
+	while(0&lt;j);
+}
+
+/*! 
+ * returns code for hardcoded system header not in the file system
+ * 
+ * \param look_for header name
+ * \param lang_code language code from preprocessor object
+ * 
+ * \return unsigned int
+ */
+static unsigned int
+detect_hardcoded_system_header(const char* const look_for,size_t lang_code)
+{
+	switch(lang_code)
+	{
+	case Lang::CPlusPlus:	// C++ hard-coded system headers
+		if (!strcmp(look_for,&quot;climits&quot;)) return 1;
+		if (!strcmp(look_for,&quot;cstddef&quot;)) return 2;
+		if (!strcmp(look_for,&quot;cstdint&quot;)) return 3;
+	case Lang::C:	// C, C++ hard-coded system headers
+		if (!strcmp(look_for,&quot;limits.h&quot;)) return 1;
+		if (!strcmp(look_for,&quot;stddef.h&quot;)) return 2;
+		if (!strcmp(look_for,&quot;stdint.h&quot;)) return 3;
+	}
+	return 0;
+}
+
+void
+CPreprocessor::_preprocess(autovalarray_ptr&lt;Token&lt;char&gt;* &gt;&amp; TokenList, autovalarray_ptr&lt;char*&gt;&amp; locked_macros, autovalarray_ptr&lt;char*&gt;&amp; macros_object, autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_object_expansion, autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_object_expansion_pre_eval, autovalarray_ptr&lt;char*&gt;&amp; macros_function, autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_arglist, autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_expansion, autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_expansion_pre_eval, autovalarray_ptr&lt;POD_triple&lt;const char*, const char*,uintptr_t&gt; &gt;&amp; include_file_index, autovalarray_ptr&lt;POD_pair&lt;const char*,autovalarray_ptr&lt;Token&lt;char&gt;*&gt;* &gt; &gt;&amp; include_file_cache, const type_system&amp; min_types)
+{
+Restart:
+	size_t i = 0;
+RestartAfterInclude:
+	if (TokenList.empty()) return;
+	size_t if_depth = 0;
+	size_t if_where = 0;			// origin 0
+	size_t else_where = 0;			// origin 1; 0 is not triggered
+	size_t include_where = 0;		// origin 1; 0 is not triggered
+	size_t restart_full_scan = 0;	// origin 1; 0 is not triggered
+	do	{
+		if (line_is_preprocessing_directive(*TokenList[i]))
+			{	// directive
+			{	// scoping brace
+			const size_t token_size = TokenList[i]-&gt;size();
+			if (1==token_size)
+				{
+				TokenList.DeleteIdx(i);	// Null directive #, delete
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+			const size_t whitespace_size = strspn(TokenList[i]-&gt;data()+1,lang.WhiteSpace+1);
+			if (token_size-1 == whitespace_size)
+				{
+				TokenList.DeleteIdx(i);	// Null directive #, delete
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+
+			TokenList[i]-&gt;flags |= PREPROCESSING_DIRECTIVE_FLAG;
+			if (0&lt;whitespace_size)
+				{	// normalize
+				TokenList[i]-&gt;c_array()[whitespace_size] = '#';
+				TokenList[i]-&gt;ltrim(whitespace_size);
+				assert(!TokenList[i]-&gt;empty());
+				assert('#'==TokenList[i]-&gt;front());
+				};
+			}	// end scoping brace
+			const errr directive_type = find_directive(TokenList[i]-&gt;data()+1,lang);
+			if (0&gt;directive_type &amp;&amp; 0==if_depth)
+				{	//! \test Warn_unrecognized_directive.hpp : naked unrecognized directive
+				message_header(*TokenList[i]);
+				INC_INFORM(&quot;warning: unrecognized preprocessing directive '&quot;);
+				size_t j = 0;
+				while(++j&lt;TokenList[i]-&gt;size() &amp;&amp; !lang.IsWS_NotFirst(TokenList[i]-&gt;data()[j]))
+					INC_INFORM(TokenList[i]-&gt;data()[j]);
+				INFORM(&quot;' (C99 6.10p1/C++98 16.1p1)&quot;);
+				if (bool_options[boolopt::warnings_are_errors]) zcc_errors.inc_error();
+				TokenList.DeleteIdx(i);
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+
+			// stripping trailing spaces damages incomplete string and character literals.
+			switch(directive_type)
+			{
+			case PP::IF:		
+			case PP::IFDEF:		
+			case PP::IFNDEF:	
+			case PP::ELIF:		
+			case PP::ELSE:		
+			case PP::ENDIF:		
+			case PP::INCLUDE:	
+			case PP::DEFINE:	
+			case PP::UNDEF:		
+			case PP::LINE:		
+			case PP::ERROR:		
+			case PP::PRAGMA:	{	// normalize the whitespace; allowed to shove directive left to do it
+								size_t critical_offset = valid_directives[directive_type].second+1;
+								if (TokenList[i]-&gt;size()&gt;critical_offset)
+									{
+									const size_t intra_WS = strspn(TokenList[i]-&gt;data()+critical_offset,lang.WhiteSpace+1);
+									if (0==intra_WS)
+										//! \todo really should be a bit more clever about this
+										TokenList[i]-&gt;replace_once(critical_offset,0,' ');
+									else if (TokenList[i]-&gt;size()-critical_offset&lt;=intra_WS)
+										{
+										if (PP::PRAGMA==directive_type)
+											{
+											TokenList.DeleteIdx(i);	// empty pragma is legal, but Z.C++ says it has no effect
+											if (0==i) goto Restart;
+											--i;
+											continue;
+											};
+										TokenList[i]-&gt;rtrim(intra_WS);
+										}
+									else if (1&lt;intra_WS)
+										TokenList[i]-&gt;replace_once(std::nothrow,critical_offset,intra_WS,' ');
+									else
+										TokenList[i]-&gt;c_array()[critical_offset] = ' ';
+									}
+								PACK_DIRECTIVE(TokenList[i]-&gt;flags,directive_type);
+								assert(TokenList[i]-&gt;size()&gt;=valid_directives[directive_type].second+1);
+								break;
+								};
+			default:			{	// Unrecognized.  Warn-and-delete when we know it's going to be executed (not within any conditional blocks.
+								PACK_DIRECTIVE(TokenList[i]-&gt;flags,PP_INVALID);
+								break;
+								};
+			};
+
+			// #if nesting-depth 0 processing
+			if (0==if_depth)
+				{
+				lex_flags first_token_flags = 0;
+				size_t first_token_len = 0;
+				if (PP::ERROR==directive_type)
+					{	// an error by fiat
+						//! \test cpp/Error_error_directive.hpp
+						//! \test cpp/Error_error_directive2.hpp
+					message_header(*TokenList[i]);
+					INC_INFORM(ERR_STR);
+					INFORM(TokenList[i]-&gt;data()+(sizeof(&quot;#error &quot;)-1));
+					TokenList.DeleteIdx(i);
+					zcc_errors.inc_error();
+					if (0==i) goto Restart;
+					--i;
+					continue;
+					};
+				if (   PP::ELSE ==directive_type
+					|| PP::ELIF ==directive_type
+					|| PP::ENDIF==directive_type)
+					{	// no prior #if/#ifdef/#ifndef is an error
+					//! \test Error_naked_else.hpp : #else without #if/#ifdef/#ifndef
+					//! \test Error_naked_elif.hpp : #elif without #if/#ifdef/#ifndef
+					//! \test Error_naked_endif.hpp : #endif without #if/#ifdef/#ifndef
+					//! \test Error_elif_after_else.hpp : #elif after #else
+					//! \test Error_else_after_else.hpp : #else after #else
+					message_header(*TokenList[i]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM(&quot;#&quot;);
+					INC_INFORM(valid_directives[directive_type].first);
+					INFORM(&quot; without paired #if/#ifdef/#ifndef (C99 6.10p1/C++98 16.1p1)&quot;);
+					TokenList.DeleteIdx(i);
+					zcc_errors.inc_error();
+					if (0==i) goto Restart;
+					--i;
+					continue;
+					};
+				if (   PP::DEFINE ==directive_type
+					|| PP::UNDEF  ==directive_type
+					|| PP::INCLUDE==directive_type
+					|| PP::LINE   ==directive_type)
+					{	// these must have preprocessing tokens to be meaningful
+					//! \test Error_no_token_define.hpp : #define no tokens
+					//! \test Error_no_token_undef.hpp : #undef no tokens
+					//! \test Error_no_token_include.hpp : #include no tokens
+					//! \test Error_no_token_line.hpp : #line no tokens
+					if (TokenList[i]-&gt;size()==valid_directives[directive_type].second+1)
+						{
+						message_header(*TokenList[i]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM(&quot;#&quot;);
+						INC_INFORM(valid_directives[directive_type].first);
+						INFORM(&quot; must have preprocessing tokens afterwards (allowing for macro substitution); discarding. (C99 6.10p1/C++98 16.1p1)&quot;);
+						TokenList.DeleteIdx(i);
+						zcc_errors.inc_error();
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					}
+				if (   PP::DEFINE ==directive_type
+					|| PP::UNDEF  ==directive_type)
+					{	// do basic legality checks now: C identifier, not locked
+					const size_t critical_offset = valid_directives[directive_type].second+2;
+					if (TokenList[i]-&gt;size()&gt;critical_offset) first_token_len = lang.UnfilteredNextToken(TokenList[i]-&gt;data()+critical_offset,first_token_flags);
+					if (C_TESTFLAG_IDENTIFIER!=first_token_flags)
+						{	//! \test Error_undef_no_identifier.hpp : #undef without identifier
+						message_header(*TokenList[i]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM(&quot;#&quot;);
+						INC_INFORM(valid_directives[directive_type].first);
+						INFORM(&quot; does not have an identifier afterwards; discarding. (C99 6.10p1/C++98 16.1p1)&quot;);
+						TokenList.DeleteIdx(i);
+						zcc_errors.inc_error();
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+
+					// want to catch illegal tokens before ditching a #undef of a locked macro
+					//! \test Error_undef_illegal_tokens.hpp : #undef illegal tokens
+					if (PP::UNDEF==directive_type) truncate_illegal_tokens(*TokenList[i],directive_type,critical_offset+first_token_len);
+
+					if (hard_locked_macro(TokenList[i]-&gt;data()+critical_offset,first_token_len))
+						{	//! \test Error_undef_STDC.hpp : #undef __STDC__
+						discard_locked_macro(TokenList,i,directive_type,first_token_len);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					if (	0==include_where &amp;&amp; 0==restart_full_scan
+						&amp;&amp;	pragma_locked_macro(TokenList[i]-&gt;data()+critical_offset,first_token_len,locked_macros))
+						{	// here so we don't recalculate the above
+						//! \test cpp/Error_undef_locked_macro.hpp
+						discard_locked_macro(TokenList,i,directive_type,first_token_len);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					if (PP::DEFINE==directive_type &amp;&amp; TokenList[i]-&gt;size()&gt;critical_offset+first_token_len)
+						{	// standardize silently
+						const size_t intra_WS = strspn(TokenList[i]-&gt;data()+critical_offset+first_token_len,lang.WhiteSpace+1);
+						if (TokenList[i]-&gt;size()-(critical_offset+first_token_len)&lt;=intra_WS)
+							TokenList[i]-&gt;rtrim(intra_WS);	// normalize -- null-def object-like macro
+						else if (1&lt;intra_WS)
+							TokenList[i]-&gt;replace_once(std::nothrow,critical_offset+first_token_len,intra_WS,' ');
+						}
+					};
+				if (PP::PRAGMA==directive_type)
+					{
+					const size_t critical_offset = valid_directives[directive_type].second+2;
+					assert(TokenList[i]-&gt;size()&gt;critical_offset);
+					if (C99_VA_ARGS_flinch(*TokenList[i],sizeof(&quot;pragma &quot;)-1))
+						{	//! \test Error_pragma_VA_ARGS.hpp
+						message_header(*TokenList[i]);
+						INFORM(&quot;discarding pragma&quot;);
+						TokenList.DeleteIdx(i);	// ignore the pragma
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					first_token_len = lang.UnfilteredNextToken(TokenList[i]-&gt;data()+critical_offset,first_token_flags);
+					if (0&gt;linear_find_lencached(TokenList[i]-&gt;data()+critical_offset, first_token_len, accept_pragma_leading_tokens, STATIC_SIZE(accept_pragma_leading_tokens)))
+						{
+						TokenList.DeleteIdx(i);	// ignore the pragma
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					}
+				if (PP::INCLUDE==directive_type &amp;&amp; 0==include_where)
+					{	// we have an include; postpone inclusion
+						// don't think memory conservation is ISO
+					if (0==restart_full_scan)
+						intradirective_preprocess(*TokenList[i], sizeof(&quot;#include &quot;)-1,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval);
+					include_where = i+1;
+					};
+				if (0==include_where &amp;&amp; 0==restart_full_scan)
+					{
+					if (PP::LINE==directive_type)
+						{
+						if (C99_VA_ARGS_flinch(*TokenList[i],sizeof(&quot;#line &quot;)-1))
+							{	//! \test cpp/line.C99/Error_VA_ARGS.h, cpp/line.C99/Error_VA_ARGS.hpp
+							message_header(*TokenList[i]);
+							INFORM(&quot;discarding #line directive&quot;);
+							TokenList.DeleteIdx(i);
+							if (0==i) goto Restart;
+							--i;
+							continue;
+							};
+
+						intradirective_preprocess(*TokenList[i], sizeof(&quot;#line &quot;)-1,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval);
+						use_line_directive_and_discard(TokenList,i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					if (PP::UNDEF==directive_type)
+						{
+						const size_t critical_offset = valid_directives[directive_type].second+2;
+						assert(0&lt;first_token_len);
+						assert(TokenList[i]-&gt;size()&gt;=critical_offset+first_token_len);
+						// apply undef
+						const errr object_macro_index = binary_find(TokenList[i]-&gt;data()+critical_offset,first_token_len,macros_object);
+						const errr function_macro_index = binary_find(TokenList[i]-&gt;data()+critical_offset,first_token_len,macros_function);
+						assert(0&gt;object_macro_index || 0&gt;function_macro_index);
+						if (0&lt;=object_macro_index)
+							{
+							macros_object.DeleteIdx(object_macro_index);
+							macros_object_expansion.DeleteIdx(object_macro_index);
+							macros_object_expansion_pre_eval.DeleteIdx(object_macro_index);
+							};
+						if (0&lt;=function_macro_index)
+							{
+							macros_function.DeleteIdx(function_macro_index);
+							macros_function_arglist.DeleteIdx(function_macro_index);
+							macros_function_expansion.DeleteIdx(function_macro_index);
+							macros_function_expansion_pre_eval.DeleteIdx(function_macro_index);
+							}
+						TokenList.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					if (PP::DEFINE==directive_type)
+						{
+						const size_t critical_offset = valid_directives[directive_type].second+2;
+						assert(0&lt;first_token_len);
+						assert(TokenList[i]-&gt;size()&gt;=critical_offset+first_token_len);
+						const errr object_macro_index = binary_find(TokenList[i]-&gt;data()+critical_offset,first_token_len,macros_object);
+						const errr function_macro_index = binary_find(TokenList[i]-&gt;data()+critical_offset,first_token_len,macros_function);
+						assert(0&gt;object_macro_index || 0&gt;function_macro_index);
+						if (TokenList[i]-&gt;size()==critical_offset+first_token_len)
+							{	// object-like, empty string
+ObjectLikeMacroEmptyString:
+							if (	 0&lt;=function_macro_index
+								|| 	(0&lt;=object_macro_index &amp;&amp; NULL!=macros_object_expansion[object_macro_index]))
+								{	//! \test define.C99/Error_dup1.hpp, define.C99/Error_dup1.h
+									//! \test define.C99/Error_dup2.hpp, define.C99/Error_dup2.h
+								discard_duplicate_define(TokenList,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (0&lt;=object_macro_index)
+								{	// already present: discard silently
+									//! \test define.C99/Pass_dup1.hpp, define.C99/Pass_dup1.h
+								TokenList.DeleteIdx(i);	// discard silently
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							const size_t object_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(object_macro_index);
+							macros_object.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion_pre_eval.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object[object_macro_insertion_index] = _new_buffer_nonNULL_throws&lt;char&gt;(ZAIMONI_LEN_WITH_NULL(first_token_len));
+							strncpy(macros_object[object_macro_insertion_index],TokenList[i]-&gt;data()+critical_offset,first_token_len);
+							ZAIMONI_NULL_TERMINATE(macros_object[object_macro_insertion_index][first_token_len]);
+							}
+						else if (lang.IsWS_NotFirst(TokenList[i]-&gt;data()[critical_offset+first_token_len]))
+							{	// object-like, not empty string
+							if (	0&lt;=function_macro_index
+								|| 	(0&lt;=object_macro_index &amp;&amp; NULL==macros_object_expansion[object_macro_index]))
+								{	//! \test define.C99/Error_dup3.hpp, define.C99/Error_dup3.h
+									//! \test define.C99/Error_dup4.hpp, define.C99/Error_dup4.h
+									//! \test define.C99/Pass_dup2.hpp, define.C99/Pass_dup2.h
+								discard_duplicate_define(TokenList,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+							Token&lt;char&gt; expansion(*TokenList[i],critical_offset+first_token_len,TokenList[i]-&gt;size()-(critical_offset+first_token_len),0);
+							normalize_macro_expansion(expansion,*TokenList[i],critical_offset,first_token_len);
+							//! \test define.C99/Pass_dup2.hpp, define.C99/Pass_dup2.h
+							//! \test define.C99/Error_concatenate1.hpp, define.C99/Error_concatenate1.h
+							//! \test define.C99/Error_concatenate2.hpp, define.C99/Error_concatenate2.h
+							if (discard_leading_trailing_concatenate_op(expansion))
+								goto ObjectLikeMacroEmptyString;
+							if (0&lt;=object_macro_index)
+								{	//! \test define.C99/Error_dup5.hpp, define.C99/Error_dup5.h
+									//! \test define.C99/Pass_dup2.hpp, define.C99/Pass_dup2.h
+								if (strcmp(expansion.data(),macros_object_expansion[object_macro_index]-&gt;data()))
+									discard_duplicate_define(TokenList,i,critical_offset,first_token_len);
+								else
+									TokenList.DeleteIdx(i);	// discard silently even if it matches
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (C99_VA_ARGS_flinch(expansion,0))
+								{	//! \test define.C99/Error_VA_ARGS.hpp, define.C99/Error_VA_ARGS.h
+								message_header(expansion);
+								INFORM(&quot;discarding macro&quot;);
+								TokenList.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+
+							// DO NOT check for context free errors here; could legitimately want to deep-stringize every invocation of the macro
+							const size_t object_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(object_macro_index);
+							macros_object.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion_pre_eval.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object[object_macro_insertion_index] = _new_buffer_nonNULL_throws&lt;char&gt;(ZAIMONI_LEN_WITH_NULL(first_token_len));
+
+							strncpy(macros_object[object_macro_insertion_index],TokenList[i]-&gt;data()+critical_offset,first_token_len);
+							ZAIMONI_NULL_TERMINATE(macros_object[object_macro_insertion_index][first_token_len]);
+							macros_object_expansion_pre_eval[object_macro_insertion_index] = new Token&lt;char&gt;(expansion);
+							macros_object_expansion[object_macro_insertion_index] = new Token&lt;char&gt;;
+							expansion.MoveInto(*macros_object_expansion[object_macro_insertion_index]);
+							object_macro_concatenate(*macros_object_expansion_pre_eval[object_macro_insertion_index]);
+							if (C99_VA_ARGS_flinch(*macros_object_expansion_pre_eval[object_macro_insertion_index],0))
+								{	//! \test define.C99/Error_concatenate5.hpp, define.C99/Error_concatenate5.h
+								message_header(*macros_object_expansion_pre_eval[object_macro_insertion_index]);
+								INFORM(&quot;discarding macro&quot;);
+								macros_object.DeleteIdx(object_macro_insertion_index);
+								macros_object_expansion.DeleteIdx(object_macro_insertion_index);
+								macros_object_expansion_pre_eval.DeleteIdx(object_macro_insertion_index);
+								TokenList.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							//! \todo should do locked macros [not __FILE__ or __LINE__] that are not first or last identifiers on speculation
+							}
+						else if ('('==TokenList[i]-&gt;data()[critical_offset+first_token_len])
+							{	// function-like
+							const size_t argspan = function_macro_argument_span(TokenList[i]-&gt;data()+critical_offset+first_token_len);
+							if (0==argspan)
+								{
+								message_header(*TokenList[i]);
+								INC_INFORM(ERR_STR);
+								INC_INFORM(TokenList[i]-&gt;data()+critical_offset,first_token_len);
+								INFORM(&quot; has an invalid argument list.  Discarding. (C99 6.10.3p/C++0x 16.3p10)&quot;);
+								TokenList.DeleteIdx(i);
+								zcc_errors.inc_error();
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (0&lt;=object_macro_index)
+								{	//! \test define.C99/Error_dup6.hpp, define.C99/Error_dup6.h
+								discard_duplicate_define(TokenList,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							Token&lt;char&gt; arglist(*TokenList[i],critical_offset+first_token_len,argspan,0);
+							normalize_macro_expansion(arglist,*TokenList[i],critical_offset,first_token_len);	// should be no string literals here, so should be no errors here
+							if (0&lt;=function_macro_index &amp;&amp; strcmp(arglist.data(),macros_function_arglist[function_macro_index]-&gt;data()))
+								{	//! \test define.C99/Error_dup7.hpp, define.C99/Error_dup7.h
+								discard_duplicate_define(TokenList,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (TokenList[i]-&gt;size()-(critical_offset+first_token_len)&gt;argspan)
+								{
+								const size_t skip_ws = strspn(TokenList[i]-&gt;data()+critical_offset+first_token_len+argspan,lang.WhiteSpace+1);
+								if (TokenList[i]-&gt;size()-(critical_offset+first_token_len+argspan)&lt;=skip_ws)
+									TokenList[i]-&gt;rtrim(skip_ws);
+								};
+							if (TokenList[i]-&gt;size()-(critical_offset+first_token_len)&lt;=argspan)
+								{	// empty expansion
+FunctionLikeMacroEmptyString:	if (0&lt;=function_macro_index)
+									{	//! \test define.C99/Error_dup9.hpp, define.C99/Error_dup9.h
+										//! \test define.C99/Pass_dup4.h, define.C99/Pass_dup4.h
+									if (NULL!=macros_function_expansion[function_macro_index])
+										discard_duplicate_define(TokenList,i,critical_offset,first_token_len);
+									else
+										TokenList.DeleteIdx(i);	// ignore silently if exactly agreed
+									if (0==i) goto Restart;
+									--i;
+									continue;
+									}
+								const size_t function_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(function_macro_index);
+								macros_function.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_arglist.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_expansion.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_expansion_pre_eval.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function[function_macro_insertion_index] = _new_buffer_nonNULL_throws&lt;char&gt;(ZAIMONI_LEN_WITH_NULL(first_token_len));
+
+								strncpy(macros_function[function_macro_insertion_index],TokenList[i]-&gt;data()+critical_offset,first_token_len);
+								ZAIMONI_NULL_TERMINATE(macros_function[function_macro_insertion_index][first_token_len]);
+								macros_function_arglist[function_macro_insertion_index] = new Token&lt;char&gt;;
+								arglist.MoveInto(*macros_function_arglist[function_macro_insertion_index]);
+
+								TokenList.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							Token&lt;char&gt; expansion(*TokenList[i],critical_offset+first_token_len+argspan,TokenList[i]-&gt;size()-(critical_offset+first_token_len+argspan),0);
+							normalize_macro_expansion(expansion,*TokenList[i],critical_offset,first_token_len);
+							// white-box test policy: cases above will work
+							if (discard_leading_trailing_concatenate_op(expansion))
+								goto FunctionLikeMacroEmptyString;
+							if (0&lt;=function_macro_index)
+								{	//! \test define.C99/Error_dup8.hpp, define.C99/Error_dup8.h
+									//! \test define.C99/Pass_dup3.h, define.C99/Pass_dup3.h
+								if (strcmp(expansion.data(),macros_function_expansion[function_macro_index]-&gt;data()))
+									discard_duplicate_define(TokenList,i,critical_offset,first_token_len);
+								else
+									TokenList.DeleteIdx(i);	// discard silently even if it matches
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if ((5&gt;arglist.size() || strcmp(arglist.end()-(sizeof(&quot;...)&quot;)-1),&quot;...)&quot;)) &amp;&amp; C99_VA_ARGS_flinch(expansion,0))
+								{	//! \test define.C99/Error_VA_ARGS2.hpp, define.C99/Error_VA_ARGS2.h
+									//! \test define.C99/Pass_VA_ARGS.hpp, define.C99/Pass_VA_ARGS.h
+								message_header(expansion);
+								INFORM(&quot;discarding macro&quot;);
+								TokenList.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+
+							// DO NOT check for context free errors here; could legitimately want to deep-stringize every invocation of the macro
+							const size_t function_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(function_macro_index);
+							macros_function.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_arglist.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_expansion.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_expansion_pre_eval.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function[function_macro_insertion_index] = _new_buffer_nonNULL_throws&lt;char&gt;(ZAIMONI_LEN_WITH_NULL(first_token_len));
+
+							strncpy(macros_function[function_macro_insertion_index],TokenList[i]-&gt;data()+critical_offset,first_token_len);
+							ZAIMONI_NULL_TERMINATE(macros_function[function_macro_insertion_index][first_token_len]);
+							macros_function_arglist[function_macro_insertion_index] = new Token&lt;char&gt;;
+							macros_function_expansion[function_macro_insertion_index] = new Token&lt;char&gt;;
+							macros_function_expansion_pre_eval[function_macro_insertion_index] = new Token&lt;char&gt;(expansion);
+							arglist.MoveInto(*macros_function_arglist[function_macro_insertion_index]);
+							expansion.MoveInto(*macros_function_expansion[function_macro_insertion_index]);
+							if (flush_bad_stringize(*macros_function_expansion_pre_eval[function_macro_insertion_index],*macros_function_arglist[function_macro_insertion_index]))
+								{
+								delete macros_function_expansion_pre_eval[function_macro_insertion_index];
+								macros_function_expansion_pre_eval[function_macro_insertion_index] = NULL;
+								};
+							if (NULL!=macros_function_expansion_pre_eval[function_macro_insertion_index])
+								{
+								function_macro_concatenate_novars(*macros_function_expansion_pre_eval[function_macro_insertion_index], *macros_function_arglist[function_macro_insertion_index]);
+								if ((5&gt;macros_function_arglist[function_macro_insertion_index]-&gt;size() || strcmp(macros_function_arglist[function_macro_insertion_index]-&gt;end()-(sizeof(&quot;...)&quot;)-1),&quot;...)&quot;)) &amp;&amp; C99_VA_ARGS_flinch(*macros_function_expansion_pre_eval[function_macro_insertion_index],0))
+									{	//! \test define.C99/Error_concatenate6.hpp, define.C99/Error_concatenate6.h
+										//! \test define.C99/Pass_concatenate3.hpp, define.C99/Pass_concatenate3.h
+									message_header(*macros_function_expansion_pre_eval[function_macro_insertion_index]);
+									INFORM(&quot;discarding macro&quot;);
+									macros_function.DeleteIdx(function_macro_insertion_index);
+									macros_function_arglist.DeleteIdx(function_macro_insertion_index);
+									macros_function_expansion.DeleteIdx(function_macro_insertion_index);
+									macros_function_expansion_pre_eval.DeleteIdx(function_macro_insertion_index);
+									TokenList.DeleteIdx(i);
+									if (0==i) goto Restart;
+									--i;
+									continue;
+									}
+								};
+							//! \todo should do locked macros [not __FILE__ or __LINE__] that are not first or last identifiers on speculation
+							};
+						TokenList.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					// should use #pragma directives
+					// all three STDC pragmas are scoped: they have to be around until fairly late in the compilation sequence
+					// we are required to ignore unrecognized pragmas -- no warnings
+					// want immediately: #pragma ZCC lock ___
+					// * locks macros
+					if (PP::PRAGMA==directive_type)
+						{
+						const size_t critical_offset = valid_directives[directive_type].second+2;
+#/*cut-cpp*/
+						const unsigned int pragma_code =
+#/*cut-cpp*/
+						interpret_pragma(TokenList[i]-&gt;data()+critical_offset,TokenList[i]-&gt;size()-critical_offset,locked_macros);
+#/*cut-cpp*/
+						switch(pragma_code)
+						{
+						default:
+#/*cut-cpp*/
+						TokenList.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+#/*cut-cpp*/
+						case RELAY_ZCC_ENABLE_TYPEID+1:
+							TokenList[i]-&gt;replace_once(0,TokenList[i]-&gt;size(),pragma_relay_keywords[pragma_code-1].first,pragma_relay_keywords[pragma_code-1].second);
+							continue;
+						}
+#/*cut-cpp*/
+						}
+					}
+				}
+
+			if (   PP::IF    ==directive_type
+				|| PP::IFDEF ==directive_type
+				|| PP::IFNDEF==directive_type)
+				{
+				if (1 == ++if_depth)
+					{
+					if_where = i;
+					else_where = 0;
+					// front-load syntax checking
+					// only report errors once
+					if (!(TokenList[i]-&gt;flags &amp; INVALID_DIRECTIVE_FLAG) &amp;&amp; 0==include_where)
+						{
+						if (PP::IF==directive_type)
+							{
+							if (!if_elif_syntax_ok(*TokenList[i],macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,min_types))
+								TokenList[i]-&gt;flags |= INVALID_DIRECTIVE_FLAG;
+							}
+						else{
+							if (!ifdef_ifndef_syntax_ok(*TokenList[i],macros_object,macros_function))
+								TokenList[i]-&gt;flags |= INVALID_DIRECTIVE_FLAG;
+							else
+								assert(PP::IF==UNPACK_DIRECTIVE(TokenList[i]-&gt;flags));
+							}
+						}
+					if (0==restart_full_scan)
+						{
+						restart_full_scan = i+1;
+						//! \todo do it all, have complete information
+						};
+					//! \todo front-load syntax checking, etc. when safe [0==include_where &amp;&amp; if_where+1==restart_full_scan]
+					//! can detect gross-invalidity anyway, but anything requiring authoritiatively knowing macro (un)defined-ness won't go through
+					}
+				}
+			else if (   PP::ELSE ==directive_type
+					 || PP::ELIF ==directive_type
+					 || PP::ENDIF==directive_type)
+				{
+				assert(0&lt;if_depth);
+				if (1==if_depth)
+					{
+					if (PP::ELIF!=directive_type)
+						//! test Error_else_with_tokens.hpp : #else with tokens
+						//! test Error_endif_with_tokens.hpp : #endif with tokens
+						truncate_illegal_tokens(*TokenList[i],directive_type,valid_directives[directive_type].second+1);
+					else if (	!(TokenList[i]-&gt;flags &amp; INVALID_DIRECTIVE_FLAG)
+							 &amp;&amp; !if_elif_syntax_ok(*TokenList[i],macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,min_types))
+						TokenList[i]-&gt;flags |= INVALID_DIRECTIVE_FLAG;
+					};
+
+				if (PP::ENDIF==directive_type)
+					{
+					if (0 == --if_depth)
+						{	// trigger conditional preprocessing here
+						assert(TokenList[if_where]-&gt;flags &amp; PREPROCESSING_DIRECTIVE_FLAG);
+						assert(0==else_where || (TokenList[else_where-1]-&gt;flags &amp; PREPROCESSING_DIRECTIVE_FLAG));
+						assert(0==else_where || (if_where&lt;=else_where &amp;&amp; else_where&lt;=i));
+						if (TokenList[if_where]-&gt;flags &amp; INVALID_DIRECTIVE_FLAG)
+							{	// already tagged as invalid
+							message_header(*TokenList[if_where]);
+							INFORM(&quot;Ignoring entire block controlled by flawed directive&quot;);
+							TokenList.DeleteNSlotsAt(i-if_where+1,if_where);
+							i = if_where;
+							if (0==i) goto Restart;
+							if (restart_full_scan&gt;=i+1) restart_full_scan = 0;	// very possible
+							if (include_where&gt;=i+1) include_where = 0;			// failsafing
+							--i;
+							continue;
+							};
+
+						// inject reductions here
+						const unsigned int else_directive = (0==else_where) ? PP_INVALID : UNPACK_DIRECTIVE(TokenList[else_where-1]-&gt;flags);
+						assert(0==else_where || PP::ELSE==else_directive || PP::ELIF==else_directive);
+						if (!strcmp(TokenList[if_where]-&gt;data(),&quot;#if 0&quot;))
+							{
+							if (0==else_where)
+								{
+								TokenList.DeleteNSlotsAt(i-if_where+1,if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan&gt;=i+1) restart_full_scan = 0;	// very possible
+								if (include_where&gt;=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							if (PP::ELSE==else_directive)
+								{
+								TokenList.DeleteIdx(i);
+//								TokenList.DeleteNSlotsAt((else_where-1)-if_where+1,if_where);
+								TokenList.DeleteNSlotsAt(else_where-if_where,if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan&gt;=i+1) restart_full_scan = 0;	// very possible
+								if (include_where&gt;=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							if (TokenList[else_where-1]-&gt;flags &amp; INVALID_DIRECTIVE_FLAG)
+								{	//! \test Error8.hpp : #elif no control expression, critical
+								message_header(*TokenList[else_where-1]);
+								INFORM(&quot;Ignoring all lines from invalid #elif to matching #endif&quot;);
+								TokenList.DeleteNSlotsAt(i-if_where+1,if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan&gt;=i+1) restart_full_scan = 0;	// very possible
+								if (include_where&gt;=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							//! \todo do full reduction here to make errors read #elif rather than #if
+							// recurse it
+							TokenList[else_where-1]-&gt;c_array()[2] = '#';
+							TokenList[else_where-1]-&gt;ltrim(2);
+							PACK_DIRECTIVE(TokenList[else_where-1]-&gt;flags,PP::IF);
+//							TokenList.DeleteNSlotsAt((else_where-1)-if_where+1,if_where);
+							TokenList.DeleteNSlotsAt(else_where-if_where+2,if_where);
+							i = if_where;
+							if (0==i) goto Restart;
+							if (restart_full_scan&gt;=i+1) restart_full_scan = 0;	// very possible
+							if (include_where&gt;=i+1) include_where = 0;			// failsafing
+							--i;
+							continue;
+							};
+						if (!strcmp(TokenList[if_where]-&gt;data(),&quot;#if 1&quot;))
+							{
+							if (0==else_where)
+								{
+								TokenList.DeleteIdx(i);
+								TokenList.DeleteIdx(if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan&gt;=i+1) restart_full_scan = 0;	// very possible
+								if (include_where&gt;=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							if (PP::ELIF==else_directive &amp;&amp; (TokenList[else_where-1]-&gt;flags &amp; INVALID_DIRECTIVE_FLAG))
+								{	//! \test Error9.hpp : #elif no control expression, non-critical
+								message_header(*TokenList[else_where-1]);
+								INFORM(&quot;Continuing as expression for invalid #elif not needed.&quot;);
+								};
+//							TokenList.DeleteNSlotsAt(i-(else_where-1)+1,else_where-1);
+							TokenList.DeleteNSlotsAt(i-else_where+2,else_where-1);
+							TokenList.DeleteIdx(if_where);
+							i = if_where;
+							if (0==i) goto Restart;
+							if (restart_full_scan&gt;=i+1) restart_full_scan = 0;	// very possible
+							if (include_where&gt;=i+1) include_where = 0;			// failsafing
+							--i;
+							continue;
+							};
+						}
+					}
+				else if (1==if_depth &amp;&amp; 0==else_where)
+					else_where = i+1;
+				}
+			}
+		// non-directive; lex, and check for macros and _Pragma operators
+		// remember to convert whitespace to single-space tokens, and flush those later
+		else if (0==include_where &amp;&amp; 0==restart_full_scan)
+			{
+			if (!tokenize_line(TokenList,i))
+				{
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+			if (C_TESTFLAG_PP_OP_PUNC &amp; TokenList[i]-&gt;flags)
+				{	// check for categorically illegal tokens
+				const signed int old_pp_code = C_PP_DECODE(TokenList[i]-&gt;flags);
+				const signed int pp_code = (old_pp_code) ? old_pp_code : lang.pp_support-&gt;EncodePPOpPunc(TokenList[i]-&gt;data(),TokenList[i]-&gt;size());
+				assert(0&lt;pp_code);
+				if (C_DISALLOW_POSTPROCESSED_SOURCE &amp; lang.pp_support-&gt;GetPPOpPuncFlags(pp_code))
+					{	//! \todo need test cases
+						// actually, this might need to be language-sensitive (e.g., Perl)
+					message_header(*TokenList[i]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM(&quot;Forbidden token '&quot;);
+					INC_INFORM(TokenList[i]-&gt;data(),TokenList[i]-&gt;size());
+					INFORM(&quot;' in postprocessed source.  Discarding.&quot;);
+					zcc_errors.inc_error();
+					TokenList.DeleteIdx(i);
+					if (0==i) goto Restart;
+					--i;
+					continue;
+					}
+				C_PP_ENCODE(TokenList[i]-&gt;flags,pp_code);
+				}
+			else if (C_TESTFLAG_IDENTIFIER==TokenList[i]-&gt;flags)
+				{
+				if (!strcmp(TokenList[i]-&gt;data(),&quot;_Pragma&quot;))
+					{	// could be pragma operator; syntax _Pragma ( C-string )
+					while(TokenList.size()&gt;i+1 &amp;&amp; !tokenize_line(TokenList,i+1));
+					if (        TokenList.size()&lt;=i+1
+						||   1!=TokenList[i+1]-&gt;size()
+						|| '('!=TokenList[i+1]-&gt;front())
+						{	//! \test cpp/Pragma.C99/Error_op1.hpp, cpp/Pragma.C99/Error_op1.h
+							//! \test cpp/Pragma.C99/Error_op2.hpp, cpp/Pragma.C99/Error_op2.h
+						message_header2(*TokenList[i],TokenList[i]-&gt;logical_line.second);
+						INC_INFORM(ERR_STR);
+						INFORM(&quot;Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)&quot;);
+						zcc_errors.inc_error();
+						TokenList.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					while(TokenList.size()&gt;i+2 &amp;&amp; !tokenize_line(TokenList,i+2));
+					if (   TokenList.size()&lt;=i+2
+						|| C_TESTFLAG_STRING_LITERAL!=TokenList[i+2]-&gt;flags)
+						{	//! \test cpp/Pragma.C99/Error_op3.hpp, cpp/Pragma.C99/Error_op3.h
+							//! \test cpp/Pragma.C99/Error_op4.hpp, cpp/Pragma.C99/Error_op4.h
+						message_header2(*TokenList[i],TokenList[i]-&gt;logical_line.second);
+						INC_INFORM(ERR_STR);
+						INFORM(&quot;Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)&quot;);
+						zcc_errors.inc_error();
+						TokenList.DeleteNSlotsAt(2,i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					while(TokenList.size()&gt;i+3 &amp;&amp; !tokenize_line(TokenList,i+3));
+					if (        TokenList.size()&lt;=i+3
+						||   1!=TokenList[i+3]-&gt;size()
+						|| ')'!=TokenList[i+3]-&gt;front())
+						{	//! \test cpp/Pragma.C99/Error_op5.hpp, cpp/Pragma.C99/Error_op5.h
+							//! \test cpp/Pragma.C99/Error_op6.hpp, cpp/Pragma.C99/Error_op6.h
+						message_header2(*TokenList[i],TokenList[i]-&gt;logical_line.second);
+						INC_INFORM(ERR_STR);
+						INFORM(&quot;Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)&quot;);
+						zcc_errors.inc_error();
+						TokenList.DeleteNSlotsAt(3,i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					if ('L'==TokenList[i+2]-&gt;front())
+						TokenList[i+2]-&gt;ltrim(1);
+					if (2&lt;TokenList[i+2]-&gt;size())
+						{	//! \test Pass_pragma_STDC.hpp
+						autovalarray_ptr_throws&lt;char&gt; pragma_string(lang.UnescapeStringLength(TokenList[i+2]-&gt;data()+1,TokenList[i+2]-&gt;size()-2));
+						lang.UnescapeString(pragma_string.c_array(),TokenList[i+2]-&gt;data()+1,TokenList[i+2]-&gt;size()-2);
+#/*cut-cpp*/
+						const unsigned int pragma_code =
+#/*cut-cpp*/
+						interpret_pragma(pragma_string.data(),pragma_string.size(),locked_macros);
+#/*cut-cpp*/
+						switch(pragma_code)
+						{
+						case RELAY_ZCC_ENABLE_TYPEID+1:
+							TokenList[i]-&gt;replace_once(0,TokenList[i]-&gt;size(),pragma_relay_keywords[pragma_code-1].first,pragma_relay_keywords[pragma_code-1].second);
+							TokenList.DeleteNSlotsAt(3,i+1);
+							continue;
+						}
+#/*cut-cpp*/
+						};
+					TokenList.DeleteNSlotsAt(4,i);
+					if (0==i) goto Restart;
+					--i;
+					continue;
+					}
+
+				const errr object_macro_index = binary_find(TokenList[i]-&gt;data(),TokenList[i]-&gt;size(),macros_object);
+				const errr function_macro_index = binary_find(TokenList[i]-&gt;data(),TokenList[i]-&gt;size(),macros_function);
+				assert(0&gt;object_macro_index || 0&gt;function_macro_index);
+				if (0&lt;=object_macro_index)
+					{	// object-like macro
+					if (!macros_object_expansion_pre_eval[object_macro_index])
+						{	// expands to nothing
+							//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
+						TokenList.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					assert(!macros_object_expansion_pre_eval[object_macro_index]-&gt;empty());
+					{	//! \test cpp/default/Preprocess_*.h/hpp
+					size_t discard = 0;
+					dynamic_macro_replace_once(*TokenList[i],discard,TokenList[i]-&gt;size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
+					}
+					size_t actual_tokens = tokenize_line(TokenList,i);
+					assert(0&lt;actual_tokens);
+					i += actual_tokens-1;
+					}
+				else if (0&lt;=function_macro_index)
+					{	// could be function-like macro
+					if (	TokenList.size()&gt;i+1 &amp;&amp; TokenList[i]-&gt;logical_line.first==TokenList[i+1]-&gt;logical_line.first
+						&amp;&amp; 	TokenList[i]-&gt;logical_line.second+TokenList[i]-&gt;size()==TokenList[i+1]-&gt;logical_line.second
+						&amp;&amp;	'('==TokenList[i+1]-&gt;front())
+						{
+						size_t paren_depth = 1;
+						size_t comma_count = 0;
+						size_t j = i+1;
+						do	{
+							if (TokenList.size()&lt;=j+1)
+								{	//! \test cpp/Error_macro_arglist4.hpp
+									// error out, incomplete function-like macro
+								message_header2(*TokenList[i],TokenList[i]-&gt;logical_line.second);
+								INC_INFORM(ERR_STR);
+								INC_INFORM(&quot;macro &quot;);
+								INC_INFORM(TokenList[i]-&gt;data(),TokenList[i]-&gt;size());
+								INFORM(&quot; did not close its argument list in time. (C99 6.10p1/C++98 16.1p1)&quot;);
+								zcc_errors.inc_error();
+								i = j;
+								break;
+								}
+							if (TokenList[j]-&gt;logical_line.first&lt;TokenList[j+1]-&gt;logical_line.first)
+								{	// line advance; check for pp-directives (undefined behavior), then tokenize
+								if (line_is_preprocessing_directive(*TokenList[j+1]))
+									{	//! \test cpp/Error_macro_arglist7.hpp
+										// error out, undefined behavior
+									message_header2(*TokenList[i],TokenList[i]-&gt;logical_line.second);
+									INC_INFORM(ERR_STR);
+									INFORM(&quot;macro invocation contains preprocessing directive.  Defining undefined behavior as ignoring macro invocation. (C99 6.10.3p11/C++98 16.3p10)&quot;);
+									zcc_errors.inc_error();
+									i = j;
+									break;
+									}
+								if (!tokenize_line(TokenList,j+1)) continue;
+								}
+							if (1==TokenList[++j]-&gt;size())
+								switch(TokenList[j]-&gt;front())
+								{
+								case '(':
+									++paren_depth;
+									break;
+								case ',':
+									++comma_count;
+									break;
+								case ')':
+									--paren_depth;
+									//	break;
+								};
+							}
+						while(0&lt;paren_depth);
+						if (0==paren_depth)
+							{
+							assert(macros_function_arglist[function_macro_index]);
+							assert('('==macros_function_arglist[function_macro_index]-&gt;front());
+							assert(')'==macros_function_arglist[function_macro_index]-&gt;back());
+							const size_t formal_arg_span = macros_function_arglist[function_macro_index]-&gt;size();
+							const size_t formal_arg_count = (2&lt;formal_arg_span) ? std::count(macros_function_arglist[function_macro_index]-&gt;begin(),macros_function_arglist[function_macro_index]-&gt;end(),',')+1 : 0;
+							const bool formal_varadic = 5&lt;=formal_arg_span &amp;&amp; !strncmp(macros_function_arglist[function_macro_index]-&gt;data()+(formal_arg_span-4),&quot;...&quot;,sizeof(&quot;...&quot;)-1);
+							const size_t arg_count = (i+2==j) ? 0 : comma_count+1;
+							if (arg_count&lt;formal_arg_count || (arg_count&gt;formal_arg_count &amp;&amp; !formal_varadic))
+								{	//! \test cpp/Error_macro_arglist5.hpp
+									//! \test cpp/Error_macro_arglist6.hpp
+								message_header2(*TokenList[i],TokenList[i]-&gt;logical_line.second);
+								INC_INFORM(ERR_STR);
+								INC_INFORM(&quot;macro &quot;);
+								INC_INFORM(TokenList[i]-&gt;data(),TokenList[i]-&gt;size());
+								INC_INFORM(&quot; had &quot;);
+								INC_INFORM(arg_count);
+								INC_INFORM(&quot; argument&quot;);
+								INC_INFORM((1==arg_count) ? &quot;&quot; : &quot;s&quot;);
+								INC_INFORM(&quot;, needed &quot;);
+								if (formal_varadic) INC_INFORM(&quot;at least &quot;);
+								INC_INFORM(formal_arg_count);
+								INFORM(&quot;. (C99 6.10p1/C++0x 16.1p1)&quot;);
+								zcc_errors.inc_error();
+								i = j;
+								continue;
+								}
+							if (!macros_function_expansion_pre_eval[function_macro_index])
+								{	// expands to nothing
+									//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
+								TokenList.DeleteNSlotsAt(j-i+1,i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+							assert(!macros_function_expansion_pre_eval[function_macro_index]-&gt;empty());
+							{	//! \test default/Preprocess_*.h/hpp 
+							Token&lt;char&gt;* Tmp = new Token&lt;char&gt;(*macros_function_expansion_pre_eval[function_macro_index]);
+							Tmp-&gt;logical_line = TokenList[i]-&gt;logical_line;
+							if (!nonrecursive_macro_replacement_list(Tmp-&gt;data()))
+								{	// XXX trashes line information to reuse intrapreprocessing stuff
+								size_t discard = i;
+								Token&lt;char&gt;* Tmp2 = new Token&lt;char&gt;(*TokenList[i]);
+								while(++discard &lt;= j) Tmp2-&gt;append(TokenList[discard]-&gt;data());
+								discard = 0;
+								dynamic_macro_replace_once(*Tmp2,discard,TokenList[i]-&gt;size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
+								delete Tmp;
+								Tmp = Tmp2;
+								}
+							TokenList.DeleteNSlotsAt(j-i,i+1);
+							delete TokenList[i];
+							TokenList[i] = Tmp;
+							}
+							size_t actual_tokens = tokenize_line(TokenList,i);
+							assert(0&lt;actual_tokens);
+							i += actual_tokens-1;
+							};
+						}
+					}
+				else{	// replace predefined macros, if they are here
+						//! \test cpp/default/Preprocess_STDC_defines.hpp, cpp/default/Preprocess_STDC_defines.h
+					predefined_macro_replacement(*TokenList[i],0);
+					}
+				}
+			}
+		}
+	while(++i&lt;TokenList.size());
+
+	if (0&lt;if_depth)
+		{	//! \test Error_naked_if.hpp
+		message_header(*TokenList[if_where]);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(if_depth);
+		INC_INFORM(&quot; #if/#ifdef/#ifndef&quot;);
+		if (1&lt;if_depth) INC_INFORM(&quot;'s&quot;);
+		INFORM(&quot; without matching #endif directives (first one here).  (C99 6.10p1/C++98 16.1p1)&quot;);
+		zcc_errors.inc_error();
+		}
+	assert(0==include_where || 0==restart_full_scan || include_where&lt;restart_full_scan);
+
+	if (0&lt;include_where)
+		{	// Need to find the file....
+		--include_where;
+		assert(PP::INCLUDE == UNPACK_DIRECTIVE(TokenList[include_where]-&gt;flags));
+		if (TokenList[include_where]-&gt;size()&lt;=(sizeof(&quot;#include &lt;&gt;&quot;)-1))
+			{	//! \test Error_include_tiny1.hpp
+				//! \test Error_include_tiny2.hpp
+			message_header(*TokenList[include_where]);
+			INC_INFORM(ERR_STR);
+			INFORM(&quot;#include is too small to contain a valid filename; discarding and continuing (C99 6.10.2p2,3/C++98 16.2p2,3)&quot;);
+			TokenList.DeleteIdx(include_where);
+			zcc_errors.inc_error();
+			i = include_where;
+			if (i&lt;TokenList.size()) goto RestartAfterInclude;
+			return;
+			}
+		// already preprocessed, fortunately
+		bool local_include = false;
+		size_t filename_len = TokenList[include_where]-&gt;size()-(sizeof(&quot;#include &lt;&gt;&quot;)-1);
+		switch(TokenList[include_where]-&gt;data()[sizeof(&quot;#include &quot;)-1])
+		{
+		case '&quot;':	{	// local-include
+					if ('&quot;'!=TokenList[include_where]-&gt;back())
+						{	//! \test Error_include_unterminated2.hpp
+						message_header(*TokenList[include_where]);
+						INC_INFORM(ERR_STR);
+						INFORM(&quot;#include \&quot;... does not terminate properly; discarding and continuing (C99 6.10.2p3/C++98 16.2p3)&quot;);
+						TokenList.DeleteIdx(include_where);
+						zcc_errors.inc_error();
+						i = include_where;
+						if (i&lt;TokenList.size()) goto RestartAfterInclude;
+						return;
+						};
+					local_include = true;
+					break;
+					}
+		case '&lt;':	{	// system-include
+					if ('&gt;'!=TokenList[include_where]-&gt;back())
+						{	//! \test Error_include_unterminated1.hpp
+						message_header(*TokenList[include_where]);
+						INC_INFORM(ERR_STR);
+						INFORM(&quot;#include &lt;... does not terminate properly; discarding and continuing (C99 6.10.2p2/C++98 16.2p2)&quot;);
+						TokenList.DeleteIdx(include_where);
+						zcc_errors.inc_error();
+						i = include_where;
+						if (i&lt;TokenList.size()) goto RestartAfterInclude;
+						return;
+						};
+					break;
+					}
+		default:	{	// neither
+					message_header(*TokenList[include_where]);
+					INC_INFORM(ERR_STR);
+					INFORM(&quot;#include has bad format; discarding and continuing (C99 6.10.2p2,3/C++98 16.2p2,3)&quot;);
+					TokenList.DeleteIdx(include_where);
+					zcc_errors.inc_error();
+					i = include_where;
+					if (i&lt;TokenList.size()) goto RestartAfterInclude;
+					return;
+					}
+		};
+		// iterate through search path until something found matching
+		// need to map following
+		// * filename given from #include
+		// * full path that actually finds the file, or positive failure to find (AtomicString)
+		// * cached content (probably separate indexing on full-path), if not include-guarded
+		// * whether include-guarded #define; if so, what the include-guard macro is...
+		// * whether the subject of a pragma-once
+		// We need a de-facto stack for the &quot;most recent include dirctory&quot; to deal with local includes
+#define CPP_INCLUDE_NOT_FOUND 1U
+
+		autovalarray_ptr&lt;Token&lt;char&gt;* &gt; IncludeTokenList;
+		const char* const look_for = register_substring(TokenList[include_where]-&gt;data()+sizeof(&quot;#include &lt;&quot;)-1,filename_len);
+		assert(filename_len==strlen(look_for));
+		if (local_include)
+			{	// #include &quot;...&quot; prohibits interior &quot;
+			if (strchr(look_for,'&quot;'))
+				{	//! \test Error_include_multiterminated2.hpp
+				message_header(*TokenList[include_where]);
+				INC_INFORM(ERR_STR);
+				INFORM(&quot;#include \&quot;...\&quot; contains \&quot;; discarding and continuing (C99 6.10.2p3/C++98 16.2p3)&quot;);
+				TokenList.DeleteIdx(include_where);
+				zcc_errors.inc_error();
+				i = include_where;
+				if (i&lt;TokenList.size()) goto RestartAfterInclude;
+				return;
+				}
+			}
+		else if (strchr(look_for,'&gt;')) // #include &lt;...&gt; prohibits interior &gt;
+			{	//! \test Error_include_multiterminated1.hpp
+			message_header(*TokenList[include_where]);
+			INC_INFORM(ERR_STR);
+			INFORM(&quot;#include &lt;...&gt; contains &gt;; discarding and continuing (C99 6.10.2p2/C++98 16.2p2)&quot;);
+			TokenList.DeleteIdx(include_where);
+			zcc_errors.inc_error();
+			i = include_where;
+			if (i&lt;TokenList.size()) goto RestartAfterInclude;
+			return;
+			};
+
+		errr have_file_index = binary_find(look_for, filename_len, include_file_index);
+		// system includes use their handle for information.
+		//! \todo rewrite this to support the #include_next extension?
+		if (0&lt;=have_file_index)
+			{	// already have this one....
+			if (CPP_INCLUDE_NOT_FOUND==include_file_index[have_file_index].third)
+				{	// don't error again....
+				TokenList.DeleteIdx(include_where);
+				i = include_where;
+				if (i&lt;TokenList.size()) goto RestartAfterInclude;
+				return;
+				}
+			assert(NULL!=include_file_index[have_file_index].second);
+			const errr cache_index = binary_find(include_file_index[have_file_index].second, strlen(include_file_index[have_file_index].second),include_file_cache);
+			assert(0&lt;=cache_index);
+			IncludeTokenList = *include_file_cache[cache_index].second;
+		 	}
+		else{
+			char buf[FILENAME_MAX];
+			const char* main_index_name = NULL;
+			// note: local_include needs to know where to start...
+			bool found_file = local_include &amp;&amp; find_local_include(look_for, buf, (TokenList[include_where]-&gt;parent_dir ? TokenList[include_where]-&gt;parent_dir : &quot;.&quot;));
+			bool hardcoded_header = false;
+			if (found_file)
+				{	// filepath known; local includes use the calculated path for information
+				main_index_name = register_string(buf);
+				have_file_index = binary_find(main_index_name, strlen(main_index_name), include_file_index);
+				if (0&lt;=have_file_index)
+					{
+					assert(CPP_INCLUDE_NOT_FOUND!=include_file_index[have_file_index].third);
+					const errr cache_index = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
+					assert(0&lt;=cache_index);
+					IncludeTokenList = *include_file_cache[cache_index].second;
+					}
+				else{	// filepath known; inhale and set up cache
+					if (!load_sourcefile(IncludeTokenList,buf,lang)) throw std::bad_alloc();
+					// backfit SourceFile... to look_for; parent_dir to parent directory of file in buf
+					if (!IncludeTokenList.empty())
+						{
+						char parent_path[FILENAME_MAX];
+						z_dirname(parent_path,buf);
+						const char* const parent_dir = register_string(parent_path);
+						size_t j = IncludeTokenList.size();
+						do	{
+							IncludeTokenList[--j]-&gt;src_filename = look_for;
+							IncludeTokenList[j]-&gt;parent_dir = parent_dir;
+							}
+						while(0&lt;j);
+						};
+					// set up include_file_index, include_file_cache
+					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(have_file_index);
+					const errr cache_index = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
+					const size_t include_file_cache_target = BINARY_SEARCH_DECODE_INSERTION_POINT(cache_index);
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_cache.insertNSlotsAt(1,include_file_cache_target);
+					include_file_cache[include_file_cache_target].second = new autovalarray_ptr&lt;Token&lt;char&gt;* &gt;(IncludeTokenList);
+					include_file_cache[include_file_cache_target].first = main_index_name;
+					include_file_index[include_file_index_target].first = main_index_name;
+					include_file_index[include_file_index_target].second = main_index_name;
+					include_file_index[include_file_index_target].third = 0;
+					}
+				}
+			else{	// we're having to process it as a system include.
+				errr tmp = 0;
+				// C99 7.1.2p4 and C++98 17.3.3.1.1p2 both prohibit having any keywords defined as macros when including a library header.
+				// C++0x 17.4.3.2.2 goes further and simply prohibits defining any keywords as macros.  Oops.
+				// C0x appears to be conserving C99 exactly.
+				// We undefine the offending macros as well as erroring, mainly to prevent duplicate error messages
+				// C99 doesn't care about such defines *after* the header; C++98 does.
+				//! \test cpp/default/keywords/Error_*.h
+				if (Lang::C==lang_code &amp;&amp; 0&lt;lang.pp_support-&gt;LengthOfSystemHeader(look_for))
+					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+
+				const unsigned int hardcoded_header_idx = detect_hardcoded_system_header(look_for,lang_code);
+				switch(hardcoded_header_idx)
+				{
+#ifndef NDEBUG
+				default: FATAL(&quot;hardcoded_header_idx out of range&quot;);
+#endif
+				case 3:	{	// stdint.h/cstdint
+					hardcoded_header = true;
+					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+					if (0&gt;binary_find(&quot;__STDINT_H__&quot;,sizeof(&quot;__STDINT_H__&quot;)-1,macros_object))	
+						create_stdint_header(IncludeTokenList,look_for);	// not included yet
+					break;
+					}
+				case 2:	{	// stddef.h/cstddef
+					hardcoded_header = true;
+					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+					if (0&gt;binary_find(&quot;__STDDEF_H__&quot;,sizeof(&quot;__STDDEF_H__&quot;)-1,macros_object))	
+						create_stddef_header(IncludeTokenList,look_for);	// not included yet
+					break;
+					}
+				case 1:	{	// limits.h/climits
+					hardcoded_header = true;
+					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+					if (0&gt;binary_find(&quot;__LIMITS_H__&quot;,sizeof(&quot;__LIMITS_H__&quot;)-1,macros_object))	
+						create_limits_header(IncludeTokenList,look_for);	// not included yet
+					break;
+					}
+				case 0:;
+				}
+
+				found_file = !hardcoded_header &amp;&amp; find_system_include(look_for, buf);
+				if (found_file)
+					{	// filepath known; inhale and set up cache
+					if (!load_sourcefile(IncludeTokenList,buf,lang)) throw std::bad_alloc();
+					// backfit SourceFile... to look_for; parent_dir to parent directory of file in buf
+					if (!IncludeTokenList.empty())
+						{
+						char parent_path[FILENAME_MAX];
+						z_dirname(parent_path,buf);
+						const char* const parent_dir = (!strcmp(parent_path,origin_dir)) ? origin_dir : register_string(parent_path);
+						size_t j = IncludeTokenList.size();
+						do	{
+							IncludeTokenList[--j]-&gt;src_filename = look_for;
+							IncludeTokenList[j]-&gt;parent_dir = parent_dir;
+							}
+						while(0&lt;j);
+						};
+					main_index_name = register_string(buf);
+					// set up include_file_index, include_file_cache
+					tmp = binary_find(look_for,filename_len,include_file_index);
+					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
+					tmp = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
+					const size_t include_file_cache_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_cache.insertNSlotsAt(1,include_file_cache_target);
+					include_file_cache[include_file_cache_target].second = new autovalarray_ptr&lt;Token&lt;char&gt;* &gt;(IncludeTokenList);
+					include_file_cache[include_file_cache_target].first = main_index_name;
+					include_file_index[include_file_index_target].first = look_for;
+					include_file_index[include_file_index_target].second = main_index_name;
+					include_file_index[include_file_index_target].third = 0;
+					}
+				else if (!hardcoded_header)
+					{	// not there at all...
+					// set up include_file_index
+					tmp = binary_find(look_for,filename_len,include_file_index);
+					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_index[include_file_index_target].first = look_for;
+					include_file_index[include_file_index_target].second = NULL;
+					include_file_index[include_file_index_target].third = CPP_INCLUDE_NOT_FOUND;
+
+					message_header(*TokenList[include_where]);
+					INC_INFORM(ERR_STR);
+					INFORM(&quot;#include'd file not found; discarding and continuing&quot;);
+					TokenList.DeleteIdx(include_where);
+					zcc_errors.inc_error();
+					i = include_where;
+					if (i&lt;TokenList.size()) goto RestartAfterInclude;
+					return;
+					}
+				}
+			}
+#undef CPP_INCLUDE_NOT_FOUND
+		//! also tested in a number of data transform tests
+		//! \test Pass_include_local.hpp
+		if (!IncludeTokenList.empty())
+			{	// not sure whether C99 5.1.1.2 4 requires preprocessing the whole header before pasting, but it permits it
+				// this implies:
+				// * conditional-compilation directives must be balanced for each file
+				// * #line directives never escape files anyway
+			++include_level;
+			_preprocess(IncludeTokenList, locked_macros, macros_object, macros_object_expansion, macros_object_expansion_pre_eval, macros_function, macros_function_arglist, macros_function_expansion, macros_function_expansion_pre_eval, include_file_index, include_file_cache, min_types);
+			--include_level;
+			if (!IncludeTokenList.empty())
+				{
+				size_t j = IncludeTokenList.size();
+				TokenList.insertNSlotsAt(j,include_where+1);
+				memmove(TokenList.c_array()+include_where+1,IncludeTokenList.data(),j*sizeof(Token&lt;char*&gt;*));
+#ifdef ZAIMONI_NULL_REALLY_IS_ZERO
+				memset(IncludeTokenList.c_array(),0,j*sizeof(Token&lt;char*&gt;*));
+#else
+				std::fill(IncludeTokenList.begin(),IncludeTokenList.end(),NULL)
+#endif
+				}
+			}
+
+		// XXX fallthrough hack XXX
+		TokenList.DeleteIdx(include_where);
+		i = include_where;
+		if (i&lt;TokenList.size()) goto RestartAfterInclude;
+//		return;
+		}
+}
+
+bool
+CPreprocessor::raw_system_include(const char* const look_for, autovalarray_ptr&lt;Token&lt;char&gt;* &gt;&amp; IncludeTokenList) const
+{
+	char buf[FILENAME_MAX];
+	// raw system include has minimal macro context, so don't worry about legality check
+
+	switch(detect_hardcoded_system_header(look_for,lang_code))
+	{
+#ifndef NDEBUG
+	default: FATAL(&quot;detect_hardcoded_system_header() return value out of 0..3 range&quot;);
+#endif
+	case 1:	// header is limits.h/climits
+		create_limits_header(IncludeTokenList,look_for);	// not included yet
+		return true;
+	case 2:	// header is stddef.h/cstddef
+		create_stddef_header(IncludeTokenList,look_for);	// not included yet
+		return true;
+	case 3:	// header is stdint.h/cstdint
+		create_stdint_header(IncludeTokenList,look_for);	// not included yet
+		return true;
+	case 0:;
+	}
+
+	if (find_system_include(look_for, buf))
+		return load_raw_sourcefile(IncludeTokenList,buf);
+	return false;
+}
+
+unsigned int
+CPreprocessor::interpret_pragma(const char* const x, size_t x_len, autovalarray_ptr&lt;char*&gt;&amp; locked_macros)
+{
+	autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt; pretokenized;
+	lang.line_lex(x, x_len, pretokenized);
+
+	const errr valid_pragma_class = linear_find_lencached(x+pretokenized[0].first, pretokenized[0].second, accept_pragma_leading_tokens, STATIC_SIZE(accept_pragma_leading_tokens));
+	if (PRAGMA_LEADING_ZCC==valid_pragma_class)
+		{
+		if (1&lt;pretokenized.size())
+			{
+#/*cut-cpp*/
+			BOOST_STATIC_ASSERT(RELAY_ZCC_ENABLE_TYPEID==STATIC_SIZE(pragma_STDC_on_off_switch)*STATIC_SIZE(pragma_STDC_keywords));
+#/*cut-cpp*/
+			const errr ZCC_pragma =  linear_find_lencached(x+pretokenized[1].first, pretokenized[1].second, pragma_ZCC_keywords, STATIC_SIZE(pragma_ZCC_keywords));
+			switch(ZCC_pragma)
+			{
+#/*cut-cpp*/
+			// #pragma ZCC enable_typeid gets rewritten to the 
+			// reserved-to-the-implementation keyword 
+			// _ZCC_pragma_enable_typeid, which in turn turns off the syntax
+			// errors for typeid .  We use this convolution so that we don't
+			// instantly break other compilers inadvertently using our 
+			// #include &lt;typeinfo&gt;
+			case PRAGMA_ZCC_ENABLE_TYPEID: return STATIC_SIZE(pragma_STDC_on_off_switch)*STATIC_SIZE(pragma_STDC_keywords)+1;				
+#/*cut-cpp*/
+			case PRAGMA_ZCC_LOCK:
+				{	//! \test Error_undef_locked_macro.hpp
+				size_t j = pretokenized.size();
+				while(2&lt;j)
+					{
+					if (C_TESTFLAG_IDENTIFIER!=pretokenized[--j].third) continue;
+					char* tmp = _new_buffer_nonNULL_throws&lt;char&gt;(ZAIMONI_LEN_WITH_NULL(pretokenized[j].second));
+					strncpy(tmp,x+pretokenized[j].first,pretokenized[j].second);
+					if (!locked_macros.InsertSlotAt(locked_macros.size(),tmp))
+						{
+						_flush(tmp);
+						throw std::bad_alloc();
+						}
+					}
+				}
+			}
+			}
+		return 0;
+		}
+	else if (PRAGMA_LEADING_STDC==valid_pragma_class)
+		{
+		if (1&lt;pretokenized.size())
+			{
+			const errr STDC_pragma =  linear_find_lencached(x+pretokenized[1].first, pretokenized[1].second, pragma_STDC_keywords, STATIC_SIZE(pragma_STDC_keywords));
+			if (0&lt;=STDC_pragma)
+				{	// found something we know
+				switch(STDC_pragma)
+				{
+#ifndef NDEBUG
+				default:
+					{
+					INC_INFORM(ERR_STR);
+					INC_INFORM(&quot;unhandled STDC pragma &quot;);
+					INFORM(pragma_STDC_keywords[STDC_pragma].first);
+					zcc_errors.inc_error();
+					return 0;
+					};
+#endif
+				case PRAGMA_STDC_FP_CONTRACT:
+				case PRAGMA_STDC_FENV_ACCESS:
+				case PRAGMA_STDC_CX_LIMITED_RANGE:
+					{
+					//! \test cpp/Pragma.C99/Error_CX_LIMITED_RANGE1.hpp, cpp/Pragma.C99/Error_CX_LIMITED_RANGE1.h
+					//! \test cpp/Pragma.C99/Error_CX_LIMITED_RANGE2.hpp, cpp/Pragma.C99/Error_CX_LIMITED_RANGE2.h
+					//! \test cpp/Pragma.C99/Error_FENV_ACCESS1.hpp, cpp/Pragma.C99/Error_FENV_ACCESS1.h
+					//! \test cpp/Pragma.C99/Error_FENV_ACCESS2.hpp, cpp/Pragma.C99/Error_FENV_ACCESS2.h
+					//! \test cpp/Pragma.C99/Error_FP_CONTRACT1.hpp, cpp/Pragma.C99/Error_FP_CONTRACT1.h
+					//! \test cpp/Pragma.C99/Error_FP_CONTRACT2.hpp, cpp/Pragma.C99/Error_FP_CONTRACT2.h
+					const errr on_off_switch = (3==pretokenized.size()) ? linear_find_lencached(x+pretokenized[2].first, pretokenized[2].second, pragma_STDC_on_off_switch, STATIC_SIZE(pragma_STDC_on_off_switch)) : -2;
+					if (0&gt;on_off_switch)
+						{
+						INC_INFORM(ERR_STR);
+						INC_INFORM(&quot;invalid STDC pragma &quot;);
+						INFORM(x,x_len);
+						zcc_errors.inc_error();
+						return 0;
+						}
+					// valid STDC pragma: relay encoding out
+					return STATIC_SIZE(pragma_STDC_on_off_switch)*STDC_pragma+on_off_switch+1;
+					};
+				}
+			}
+			}
+		return 0;
+		}
+	else if (PRAGMA_MESSAGE==valid_pragma_class)
+		{
+		if (	4==pretokenized.size()
+			&amp;&amp;	1==pretokenized[1].second &amp;&amp; '('==x[pretokenized[1].first]
+			&amp;&amp;	1==pretokenized[3].second &amp;&amp; ')'==x[pretokenized[3].first]
+			&amp;&amp;	C_TESTFLAG_STRING_LITERAL==pretokenized[2].third)
+			{
+			// hmm...do we need to unescape anything...
+			const bool wide_str = 'L'==x[pretokenized[2].first];
+			if (0&lt;std::count(x+pretokenized[2].first,x+pretokenized[2].first+pretokenized[2].second,'\\'))
+				{	// no escapes
+				if (wide_str) return 0; //! \todo this should do a proper unescape to UNICODE, then use a wrapper library to push the UNICODE to whatever wide-char support there is
+
+				//! \todo change target, this only handles target CHAR_BIT&lt;=host CHAR_BIT
+				const size_t tmp_len = lang.UnescapeStringLength(x+pretokenized[2].first,pretokenized[2].second);
+				char* tmp = _new_buffer&lt;char&gt;(ZAIMONI_LEN_WITH_NULL(tmp_len));
+				if (NULL!=tmp)
+					{
+					lang.UnescapeString(tmp,x+pretokenized[2].first,pretokenized[2].second);
+					INFORM(tmp,tmp_len);
+					_flush(tmp);
+					return 0;
+					}
+				};
+			// no escapes, or formatting failed: do something
+			if (wide_str)
+				INFORM(x+pretokenized[2].first+2,pretokenized[2].second-3);
+			else
+				INFORM(x+pretokenized[2].first+1,pretokenized[2].second-2);
+			}
+		return 0;
+		}
+	return 0;
+}
+
+static void _complete_string_character_literal(Token&lt;char&gt;&amp; x,const char delim, const char* const end_error)
+{
+	if (delim==x.back()) return;
+	message_header2(x,x.original_line.second);
+	INC_INFORM(ERR_STR);
+	INC_INFORM(&quot;unterminated&quot;);
+	if ('L'==x.front()) INC_INFORM(&quot; wide&quot;);
+	INFORM(end_error);
+	zcc_errors.inc_error();
+	x.append(delim);
+}
+
+static void complete_string_character_literal(Token&lt;char&gt;&amp; x)
+{
+	if (C_TESTFLAG_STRING_LITERAL==x.flags)
+		//! \test Error_unterminated1.hpp
+		//! \test Error_unterminated2.hpp
+		_complete_string_character_literal(x,'&quot;',&quot; string literal.  Terminating. (C99 6.4.5p1/C++98 2.13.4)&quot;);
+	else if (C_TESTFLAG_CHAR_LITERAL==x.flags)
+		//! \test Error_unterminated3.hpp
+		//! \test Error_unterminated4.hpp
+		_complete_string_character_literal(x,'\'',&quot; character literal.  Terminating. (C99 6.4.4.4p1/C++98 2.13.2)&quot;);
+}
+
+size_t
+CPreprocessor::tokenize_line(autovalarray_ptr&lt;Token&lt;char&gt;* &gt;&amp; TokenList, size_t i) const
+{
+	assert(TokenList.size()&gt;i);
+	if (TokenList[i]-&gt;empty())
+		{
+		TokenList.DeleteIdx(i);
+		return 0;
+		};
+
+	// Not really (it's a preprocessing directive), but we don't want to damage it here
+	if ('#'==TokenList[i]-&gt;front()) return 1;
+
+	//! \test Error_naked_VA_ARGS.hpp
+	if (!TokenList[i]-&gt;flags) C99_VA_ARGS_flinch(*TokenList[i],0);
+
+	autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt; pretokenized;
+	lang.line_lex(TokenList[i]-&gt;data(),TokenList[i]-&gt;size(),pretokenized);
+	if (pretokenized.empty())
+		{
+		TokenList.DeleteIdx(i);
+		return 0;
+		}
+
+	size_t ub = pretokenized.size()-1;
+	if (0==ub)
+		{
+		if (!TokenList[i]-&gt;flags) TokenList[i]-&gt;flags = pretokenized[ub].third;
+		// handle trailing whitespace
+		if (ZAIMONI_LEN_WITH_NULL(pretokenized[ub].second)&lt;TokenList[i]-&gt;size())
+			TokenList[i]-&gt;lslice(pretokenized[ub].second);
+		complete_string_character_literal(*TokenList[i]);
+		}
+	else{
+		size_t lb = 0;
+		autovalarray_ptr_throws&lt;Token&lt;char&gt;* &gt; TokenListAlt(ub+1);
+		TokenList.insertNSlotsAt(ub,i+1);
+		{
+		const Token&lt;char&gt;&amp; tmp = *TokenList[i];
+		while(lb&lt;ub)
+			{
+			if (pretokenized[lb].second&lt;=pretokenized[ub].second)
+				{	// first token not longer
+				TokenListAlt[lb] = new Token&lt;char&gt;(tmp,pretokenized[lb].first,pretokenized[lb].second,pretokenized[lb].third);
+				complete_string_character_literal(*TokenListAlt[lb++]);
+				}
+			else{	// second token longer
+				TokenListAlt[ub] = new Token&lt;char&gt;(tmp,pretokenized[ub].first,pretokenized[ub].second,pretokenized[ub].third);
+				complete_string_character_literal(*TokenListAlt[ub--]);
+				}
+			}
+		}
+		// strip down TokenList[i] to a largest token
+		TokenListAlt[lb] = TokenList[i];
+		TokenList[i] = NULL;
+		TokenListAlt[lb]-&gt;trim(pretokenized[lb].first,TokenListAlt[lb]-&gt;size()-(pretokenized[lb].first+pretokenized[lb].second));
+		TokenListAlt[lb]-&gt;flags = pretokenized[lb].third;
+		complete_string_character_literal(*TokenListAlt[lb]);
+		memmove(TokenList.c_array()+i,TokenListAlt.data(),TokenListAlt.size()*sizeof(*TokenListAlt.data()));
+#ifdef ZAIMONI_NULL_REALLY_IS_ZERO
+		memset(TokenListAlt.c_array(),0,TokenListAlt.size()*sizeof(*TokenListAlt.data()));
+#else
+		std::fill(TokenListAlt.begin(),TokenListAlt.end(),NULL);
+#endif
+		}
+	return pretokenized.size();
+}
+
+/*! 
+ * finds a local include file
+ * 
+ * \param src : string describing file to find
+ * \param filepath_buf : pointer to character buffer of length FILENAME_MAX
+ * 
+ * \return true if and only if a filepath was found.
+ */
+bool
+CPreprocessor::find_local_include(const char* const src, char* const filepath_buf, const char* const local_root) const
+{
+	char image_filepath[FILENAME_MAX];
+	char test_filepath[FILENAME_MAX];
+
+	assert(!is_empty_string(src));
+	assert(!is_empty_string(local_root));
+	assert(NULL!=filepath_buf);
+	const size_t src_len = strlen(src);
+
+	// automatically fail anything that won't fit in FILENAME_MAX
+	//! \test Error_huge_path.hpp
+	if (FILENAME_MAX&lt;=src_len) return false;
+
+	if (NULL!=origin_dir)
+		{
+		size_t target_length = strlen(origin_dir);
+		assert(FILENAME_MAX&gt;target_length);
+		strcpy(test_filepath,origin_dir);
+		if (FILENAME_MAX&lt;=target_length+(sizeof(ZAIMONI_PATH_SEP)-1)+src_len) return false;	// safe only because FILENAME_MAX is small
+		strcpy(test_filepath+target_length,ZAIMONI_PATH_SEP);
+		target_length += (sizeof(ZAIMONI_PATH_SEP)-1);
+		strcpy(test_filepath+target_length,src);
+#if ZAIMONI_PATH_SEP_CHAR!='/'
+		// path separator not POSIX, Z.C++ requires POSIX path separator for #include
+		//! \todo: actively reject non-POSIX file separators?
+		std::replace(test_filepath+target_length,test_filepath+target_length+src_len,'/',ZAIMONI_PATH_SEP_CHAR);
+#endif
+		}
+	else{	// ahem...hope that we haven't relocated yet...
+		strncpy(test_filepath,src,src_len);
+#if ZAIMONI_PATH_SEP_CHAR!='/'
+		// path separator not POSIX, Z.C++ requires POSIX path separator for #include
+		//! \todo: actively reject non-POSIX file separators?
+		std::replace(test_filepath,test_filepath+src_len,'/',ZAIMONI_PATH_SEP_CHAR);
+#endif
+		}
+	const char* const canonical_path = z_realpath(image_filepath,test_filepath);
+	if (NULL!=canonical_path &amp;&amp; !access(canonical_path,F_OK))
+		{
+		strcpy(filepath_buf,canonical_path);
+		return true;
+		}
+	//! \todo react to local search path options as well
+	//! \test Error_include_nonexistent2.hpp
+	return false;
+}
+
+/*! 
+ * finds a system include file
+ * 
+ * \param src : string describing file to find
+ * \param filepath_buf : pointer to character buffer of length FILENAME_MAX
+ * 
+ * \return true if and only if a filepath was found.
+ */
+bool
+CPreprocessor::find_system_include(const char* const src, char* const filepath_buf) const
+{
+	char image_filepath[FILENAME_MAX];
+	char test_filepath[FILENAME_MAX];
+
+	assert(!is_empty_string(src));
+	assert(NULL!=filepath_buf);
+	const size_t src_len = strlen(src);
+	// automatically fail anything that won't fit in FILENAME_MAX
+	//! \test Error_huge_path.hpp
+	if (FILENAME_MAX&lt;=src_len) return false;
+
+	// we do casual chroot-jailing of system includes
+
+	// disallow change to parent directory.  *NIX system symlinks mean we can't tolerate them even when balanced properly for Windows.
+	if (sizeof(&quot;..&quot;)-1&lt;=src_len)
+		{
+		const char* parent_dir_candidate = strstr(src,&quot;..&quot;);
+		if (src==parent_dir_candidate)
+			{
+			//! \test Error_chroot_jail1.hpp
+			if (sizeof(&quot;..&quot;)-1==src_len) return false;
+			//! \test Error_chroot_jail2.hpp
+			if ('/'==src[sizeof(&quot;..&quot;)-1]) return false;
+			parent_dir_candidate = strstr(parent_dir_candidate+(sizeof(&quot;..&quot;)-1),&quot;..&quot;);
+			}
+		while(NULL!=parent_dir_candidate &amp;&amp; src_len&gt;=(parent_dir_candidate-src)+(sizeof(&quot;..&quot;)-1))
+			{
+			//! \test Error_chroot_jail3.hpp
+			if ('/'==parent_dir_candidate[-1]) return false;
+			parent_dir_candidate = (src_len==parent_dir_candidate-src+(sizeof(&quot;..&quot;)-1)) ? NULL : strstr(parent_dir_candidate+(sizeof(&quot;..&quot;)-1),&quot;..&quot;);
+			}
+		}	
+
+	//!\todo react to system search path options as well
+
+	// check hard-coded search path options
+	// \todo more robust multi-language architecture
+	//! \test Pass13.hpp
+	size_t i = (Lang::C==lang_code) ? START_CPP_ONLY_PATHS : 0;
+	do	if (actual_system_include_search[i])
+			{
+			size_t target_length = strlen(actual_system_include_search[i]);
+			assert(FILENAME_MAX&gt;target_length);
+			strcpy(test_filepath,actual_system_include_search[i]);
+			if (FILENAME_MAX&lt;=target_length+(sizeof(ZAIMONI_PATH_SEP)-1)+src_len) continue;	// safe only because FILENAME_MAX is small
+			strcpy(test_filepath+target_length,ZAIMONI_PATH_SEP);
+			target_length += (sizeof(ZAIMONI_PATH_SEP)-1);
+			strcpy(test_filepath+target_length,src);
+#if ZAIMONI_TARGET_FILESYSTEM!=ZAIMONI_TARGET_FILESYSTEM_POSIX
+			// path separator not POSIX, ZCC requires POSIX path separator for #include
+			//! \todo: actively reject non-POSIX file separators?
+			std::replace(test_filepath+target_length,test_filepath+target_length+src_len,'/',ZAIMONI_PATH_SEP_CHAR);
+#endif
+			const char* const canonical_path = z_realpath(image_filepath,test_filepath);
+			if (NULL!=canonical_path &amp;&amp; !access(canonical_path,F_OK))
+				{
+				strcpy(filepath_buf,canonical_path);
+				return true;
+				}
+			}
+	while(STATIC_SIZE(actual_system_include_search) &gt; ++i);
+
+	return false;	//! \test Error_include_nonexistent1.hpp
+}
+
+/*! 
+ * indicates whether the definedness of the macro is context-free
+ * 
+ * \param x C string to test for macro-hood
+ * \param x_len length of C string
+ * 
+ * \return 1 if unconditionally defined; -1 if unconditionally undefined; 0 if need to preprocess to find out
+ */
+int
+CPreprocessor::context_free_defined(const char* const x, size_t x_len) const
+{
+	assert(NULL!=x);
+	assert(0&lt;x_len);
+	if (0&lt;=linear_find(x, x_len, macro_identifier_default, macro_identifier_default_count)) return 1;
+	// report &quot;magic macros&quot; as defined if the master preprocessor does
+	if (sizeof(&quot;__has_include&quot;)-1==x_len &amp;&amp; !strncmp(x,&quot;__has_include&quot;,x_len)) return 1;	// CLang says predefined
+	if (hard_locked_macro(x,x_len)) return -1;
+	return 0;
+}
+
+static bool
+macro_is_defined(const char* const x, const size_t x_len, const autovalarray_ptr&lt;char*&gt;&amp; macros_object, const autovalarray_ptr&lt;char*&gt;&amp; macros_function)
+{
+	assert(NULL!=x);
+	assert(0&lt;x_len);
+#ifdef NDEBUG
+	return 0&lt;=binary_find(x,x_len,macros_object) || 0&lt;=binary_find(x,x_len,macros_function);
+#else
+	const errr object_macro_index = binary_find(x,x_len,macros_object);
+	const errr function_macro_index = binary_find(x,x_len,macros_function);
+	assert(0&gt;object_macro_index || 0&gt;function_macro_index);
+	return 0&lt;=object_macro_index || 0&lt;=function_macro_index;
+#endif
+}
+
+bool
+CPreprocessor::ifdef_ifndef_syntax_ok(Token&lt;char&gt;&amp; x, const autovalarray_ptr&lt;char*&gt;&amp; macros_object, const autovalarray_ptr&lt;char*&gt;&amp; macros_function)
+{
+	assert(3&lt;=x.size());
+	assert('#'==x.front());
+	const unsigned int if_directive = UNPACK_DIRECTIVE(x.flags);
+	assert(PP::IFDEF==if_directive || PP::IFNDEF==if_directive);
+	assert(!strncmp(x.data()+1,valid_directives[if_directive].first,valid_directives[if_directive].second));
+	lex_flags token_flags;
+
+	//! \test ifdef.C99/Error_noarg.hpp
+	//! \test ifdef.C99/Error_noarg2.hpp
+	if (!strcmp(x.data()+1,valid_directives[if_directive].first))
+		{
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(&quot;#&quot;);
+		INC_INFORM(valid_directives[if_directive].first);
+		INFORM(&quot; has no control expression. (C99 6.10p1/C++98 16p1)&quot;);
+		zcc_errors.inc_error();
+		return false;
+		};
+
+	const size_t critical_offset = valid_directives[if_directive].second+2;
+	assert(x.size()&gt;critical_offset);
+	//! \todo : let this slide as a warning with new --do-what-i-mean option
+	C99_VA_ARGS_flinch(x,critical_offset);	// __VA_ARGS__ is known to be undefined, result would be well-defined anyway
+
+	const size_t token_len = lang.UnfilteredNextToken(x.data()+critical_offset,token_flags);
+	if (C_TESTFLAG_IDENTIFIER!=token_flags)
+		{	//! \test ifdef.C99/Error_nonidentifer.h
+			//! \test ifdef.C99/Error_nonidentifer.hpp
+			//! \test ifdef.C99/Error_nonidentifer2.h
+			//! \test ifdef.C99/Error_nonidentifer2.hpp
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(&quot;#&quot;);
+		INC_INFORM(valid_directives[if_directive].first);
+		INFORM(&quot; is not applied to an identifier. (C99 6.10p1/C++98 16p1)&quot;);
+		zcc_errors.inc_error();
+		return false;
+		};
+	if (x.size()-critical_offset&gt;token_len)
+		{
+		const size_t skip_ws = strspn(x.data()+critical_offset+token_len,lang.WhiteSpace+1);
+		if (x.size()-(critical_offset+token_len)&gt;skip_ws)
+			{	//! \test ifdef.C99/Error_extra.h
+				//! \test ifdef.C99/Error_extra.hpp
+				//! \test ifdef.C99/Error_extra2.h
+				//! \test ifdef.C99/Error_extra2.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INC_INFORM(&quot;#&quot;);
+			INC_INFORM(valid_directives[if_directive].first);
+			INFORM(&quot; has illegal tokens following its identifier. (C99 6.10p1/C++98 16p1)&quot;);
+			zcc_errors.inc_error();
+			return false;
+			}
+		x.rtrim(skip_ws);
+		};
+
+	//! \test Pass_macro_STDC.h
+	//! \test Pass_macro_STDC.hpp
+	switch(context_free_defined(x.data()+critical_offset,token_len))
+	{
+	case 1:		{	// found it
+				x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? &quot;#if 1&quot; : &quot;#if 0&quot;);
+				PACK_DIRECTIVE(x.flags,PP::IF);
+				return true;
+				}
+	case -1:	{	// hard-locked, not defined : ergo, undefined
+				x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? &quot;#if 0&quot; : &quot;#if 1&quot;);
+				PACK_DIRECTIVE(x.flags,PP::IF);
+				return true;
+				}
+	};
+
+	// exercised heavily by the standard library include tests
+	if (macro_is_defined(x.data()+critical_offset, token_len,macros_object,macros_function))
+		{	// found it
+		x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? &quot;#if 1&quot; : &quot;#if 0&quot;);
+		PACK_DIRECTIVE(x.flags,PP::IF);
+		return true;
+		}
+	else{	// not found, not a predefined: not defined
+		x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? &quot;#if 0&quot; : &quot;#if 1&quot;);
+		PACK_DIRECTIVE(x.flags,PP::IF);
+		return true;
+		}
+}
+
+static POD_pair&lt;size_t,size_t&gt; balanced_character_count(const char* const x, const autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt;&amp; pretokenized,const char l_match,const char r_match)
+{
+	POD_pair&lt;size_t,size_t&gt; paren_depth = {0,0};
+	const autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt;::const_iterator iter_end = pretokenized.end();
+	autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt;::const_iterator iter = pretokenized.begin();
+	assert(NULL!=x);
+	if (iter!=iter_end)
+		do	if (1==iter-&gt;second)
+				{
+				if 		(l_match==x[iter-&gt;first]) ++paren_depth.first;
+				else if (r_match==x[iter-&gt;first]) ++paren_depth.second;
+				}
+		while(++iter!=iter_end);
+	return paren_depth;
+}
+
+// This should notice zero errors, thanks to a prior context-free check
+static void _construct_matched_pairs(const Token&lt;char&gt;&amp; x, const autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt;&amp; pretokenized, autovalarray_ptr&lt;POD_pair&lt;size_t,size_t&gt; &gt;&amp; pair_stack,const char l_match,const char r_match)
+{
+	POD_pair&lt;size_t,size_t&gt; depth = balanced_character_count(x.data(),pretokenized,l_match,r_match);	// pre-scan
+	DEBUG_STATEMENT(size_t err_count = 0;)
+	if (0&lt;depth.first &amp;&amp; 0&lt;depth.second)
+		{
+		// reality-check: balanced parentheses
+		autovalarray_ptr_throws&lt;size_t&gt; lparen_fixedstack(depth.first);
+		autovalarray_ptr_throws&lt;POD_pair&lt;size_t,size_t&gt; &gt; parenpair_fixedstack(depth.first&lt;depth.second ? depth.first : depth.second);
+		size_t balanced_paren = 0;
+		size_t i = 0;
+
+		depth.first = 0;
+		depth.second = 0;
+		do	if (1==pretokenized[i].second)
+				{
+				if 		(l_match==x.data()[pretokenized[i].first])
+					{
+					if (0&lt;depth.second)
+						{
+						depth.second = 0;
+						DEBUG_STATEMENT(++err_count;)
+						}
+					lparen_fixedstack[depth.first++] = i;
+					}
+				else if (r_match==x.data()[pretokenized[i].first])
+					{
+					if (0&lt;depth.first)
+						{
+						parenpair_fixedstack[balanced_paren].first = lparen_fixedstack[--depth.first];
+						parenpair_fixedstack[balanced_paren++].second = i;
+						}
+					else
+						++depth.second;
+					};
+				}
+		while(pretokenized.size() &gt; ++i);
+		if (0==depth.first &amp;&amp; 0==depth.second DEBUG_STATEMENT(&amp;&amp; 0==err_count))
+			{
+			assert(parenpair_fixedstack.size()==balanced_paren);
+			parenpair_fixedstack.MoveInto(pair_stack);
+			}
+		};
+
+	assert(0==depth.first || 0==depth.second);
+	DEBUG_STATEMENT(if (0&lt;depth.second) ++err_count;)
+	DEBUG_STATEMENT(if (0&lt;depth.first) ++err_count;)
+	assert(0==err_count);
+}
+
+template&lt;char l_match,char r_match&gt;
+inline static void construct_matched_pairs(const Token&lt;char&gt;&amp; x, const autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt;&amp; pretokenized, autovalarray_ptr&lt;POD_pair&lt;size_t,size_t&gt; &gt;&amp; pair_stack)
+{
+	_construct_matched_pairs(x,pretokenized,pair_stack,l_match,r_match);
+}
+
+template&lt;&gt;
+void construct_matched_pairs&lt;'[',']'&gt;(const Token&lt;char&gt;&amp; x, const autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt;&amp; pretokenized, autovalarray_ptr&lt;POD_pair&lt;size_t,size_t&gt; &gt;&amp; pair_stack)
+{
+	POD_pair&lt;size_t,size_t&gt; depth = balanced_character_count(x.data(),pretokenized,'[',']');	// pre-scan
+	DEBUG_STATEMENT(size_t err_count = 0;)
+	if (0&lt;depth.first &amp;&amp; 0&lt;depth.second)
+		{
+		// reality-check: balanced parentheses
+		autovalarray_ptr_throws&lt;size_t&gt; lparen_fixedstack(depth.first);
+		autovalarray_ptr_throws&lt;POD_pair&lt;size_t,size_t&gt; &gt; parenpair_fixedstack(depth.first&lt;depth.second ? depth.first : depth.second);
+		size_t balanced_paren = 0;
+		size_t i = 0;
+
+		depth.first = 0;
+		depth.second = 0;
+		do	if 		(detect_C_left_bracket_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+				{
+				if (0&lt;depth.second)
+					{
+					depth.second = 0;
+					DEBUG_STATEMENT(++err_count;)
+					}
+				lparen_fixedstack[depth.first++] = i;
+				}
+			else if (detect_C_right_bracket_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+				{
+				if (0&lt;depth.first)
+					{
+					parenpair_fixedstack[balanced_paren].first = lparen_fixedstack[--depth.first];
+					parenpair_fixedstack[balanced_paren++].second = i;
+					}
+				else
+					++depth.second;
+				}
+		while(pretokenized.size() &gt; ++i);
+		if (0==depth.first &amp;&amp; 0==depth.second DEBUG_STATEMENT(&amp;&amp; 0==err_count))
+			{
+			assert(parenpair_fixedstack.size()==balanced_paren);
+			parenpair_fixedstack.MoveInto(pair_stack);
+			}
+		};
+
+	assert(0==depth.first || 0==depth.second);
+	DEBUG_STATEMENT(if (0&lt;depth.second) ++err_count;)
+	DEBUG_STATEMENT(if (0&lt;depth.first) ++err_count;)
+	assert(0==err_count);
+}
+
+static void pairstack_clean(const POD_pair&lt;size_t,size_t&gt;&amp; target, autovalarray_ptr&lt;POD_pair&lt;size_t,size_t&gt; &gt;&amp; pair_stack)
+{
+	autovalarray_ptr&lt;POD_pair&lt;size_t,size_t&gt; &gt;::iterator iter = pair_stack.begin();
+	const autovalarray_ptr&lt;POD_pair&lt;size_t,size_t&gt; &gt;::iterator iter_end = pair_stack.end();
+	if (iter!=iter_end)
+		do	{
+			assert(iter-&gt;first&lt;iter-&gt;second);
+			if (target.first&lt;iter-&gt;first)
+				{
+				if (target.second&lt;iter-&gt;first) iter-&gt;first -= 1;
+				iter-&gt;first -= 1;
+				}
+			if (target.first&lt;iter-&gt;second)
+				{
+				if (target.second&lt;iter-&gt;second) iter-&gt;second -= 1;
+				iter-&gt;second -= 1;
+				}
+			}
+		while(++iter!=iter_end);
+}
+
+static void balanced_character_kill(Token&lt;char&gt;&amp; x, autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt;&amp; pretokenized, autovalarray_ptr&lt;POD_pair&lt;size_t,size_t&gt; &gt;&amp; parenpair_stack, size_t target_idx)
+{
+	assert(parenpair_stack.size()&gt;target_idx);
+	POD_pair&lt;size_t,size_t&gt; target	= parenpair_stack[target_idx];
+	assert(pretokenized.size()&gt;target.first);
+	assert(pretokenized.size()&gt;target.second);
+	assert(target.first&lt;target.second);
+	assert(1==pretokenized[target.first].second);
+	assert(1==pretokenized[target.second].second);
+	{
+	char* const tmp = x.c_array();
+	tmp[pretokenized[target.first].first] = ' ';
+	tmp[pretokenized[target.second].first] = ' ';
+	}
+	parenpair_stack.DeleteIdx(target_idx);
+	pretokenized.DeleteIdx(target.second);
+	pretokenized.DeleteIdx(target.first);
+	pairstack_clean(target,parenpair_stack);
+}
+
+template&lt;char c&gt;
+static inline bool
+token_is_char(const char* const x, const POD_triple&lt;size_t,size_t,lex_flags&gt;&amp; lexed_token)
+{
+	assert(NULL!=x);
+	return 1==lexed_token.second &amp;&amp; c==x[lexed_token.first];
+}
+
+template&lt;&gt;
+inline bool
+token_is_char&lt;'#'&gt;(const char* const x, const POD_triple&lt;size_t,size_t,lex_flags&gt;&amp; lexed_token)
+{
+	assert(NULL!=x);
+	return detect_C_stringize_op(x+lexed_token.first,lexed_token.second);
+}
+
+template&lt;&gt;
+inline bool
+token_is_char&lt;'['&gt;(const char* const x, const POD_triple&lt;size_t,size_t,lex_flags&gt;&amp; lexed_token)
+{
+	assert(NULL!=x);
+	return detect_C_left_bracket_op(x+lexed_token.first,lexed_token.second);
+}
+
+template&lt;&gt;
+inline bool
+token_is_char&lt;']'&gt;(const char* const x, const POD_triple&lt;size_t,size_t,lex_flags&gt;&amp; lexed_token)
+{
+	assert(NULL!=x);
+	return detect_C_right_bracket_op(x+lexed_token.first,lexed_token.second);
+}
+
+template&lt;&gt;
+inline bool
+token_is_char&lt;'{'&gt;(const char* const x, const POD_triple&lt;size_t,size_t,lex_flags&gt;&amp; lexed_token)
+{
+	assert(NULL!=x);
+	return detect_C_left_brace_op(x+lexed_token.first,lexed_token.second);
+}
+
+template&lt;&gt;
+inline bool
+token_is_char&lt;'}'&gt;(const char* const x, const POD_triple&lt;size_t,size_t,lex_flags&gt;&amp; lexed_token)
+{
+	assert(NULL!=x);
+	return detect_C_right_brace_op(x+lexed_token.first,lexed_token.second);
+}
+
+// Closely related to _C99_literal_converts_to_bool/CSupport.cpp
+/*! 
+ * examines a proposed token for whether it is suitable for an #if/#elif control expression, and if so 
+ * 
+ * \param x #if/#elif line
+ * \param lexed_token where the token is
+ * \param is_zero if suitable, set this to true iff token is 0 for purposes of preprocessing
+ * 
+ * \return true iff suitable for an #if/#elif control expression
+ */
+static bool if_elif_control_is_zero(const Token&lt;char&gt;&amp; x, const POD_triple&lt;size_t,size_t,lex_flags&gt;&amp; lexed_token, bool&amp; is_zero)
+{
+	const lex_flags flags = lexed_token.third;
+	if (C_TESTFLAG_CHAR_LITERAL==flags)
+		{	//! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
+			//! \test if.C99/Pass_nonzero.hpp, if.C99/Pass_nonzero.h
+		is_zero = CCharLiteralIsFalse(x.data()+lexed_token.first,lexed_token.second);
+		return true;
+		};
+
+	//! \todo --do-what-i-mean will handle floats as well
+	if (!(C_TESTFLAG_PP_NUMERAL &amp; flags)) return false;
+	C_REALITY_CHECK_PP_NUMERAL_FLAGS(flags);
+	if (C_TESTFLAG_FLOAT &amp; flags) return false;
+	// zeros go to zero, everything else canonicalizes to one
+	//! \test if.C99/Pass_if_zero.hpp, if.C99/Pass_if_zero.h
+	is_zero = C99_integer_literal_is_zero(x.data()+lexed_token.first,lexed_token.second,flags);
+	return true;
+}
+
+/*! 
+ * 
+ * 
+ * \param x overall directive
+ * \param pretokenized token index for overall directive
+ * \param src
+ * \param i start token
+ * \param delta last token offset included in range to be substituted
+ * 
+ * \return bool true if and only if directive obviously completely substituted
+ */
+bool
+CPreprocessor::replace_char_into_directive(Token&lt;char&gt;&amp; x,const autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt;&amp; pretokenized,const char src,const size_t i,const size_t delta)
+{
+	if (0==i &amp;&amp; delta+1==pretokenized.size())
+		{
+		x.replace_once(std::nothrow,pretokenized[0].first,x.size()-pretokenized[0].first,src);
+		return true;
+		};
+
+	size_t buffer_used = 0;
+	char Buffer[4] = &quot;&quot;;
+	if (0&lt;pretokenized[i].first &amp;&amp; require_padding(x.data()[pretokenized[i].first-1],src))
+		Buffer[buffer_used++] = ' ';
+	Buffer[buffer_used++] = src;
+	if (x.size()&gt;pretokenized[i+delta].first+pretokenized[i+delta].second &amp;&amp; require_padding(src,x.data()[pretokenized[i+delta].first+pretokenized[i+delta].second]))
+		Buffer[buffer_used++] = ' ';
+
+	x.replace_once(std::nothrow,pretokenized[i].first,(pretokenized[i+delta].first-pretokenized[i].first)+pretokenized[i+delta].second,Buffer);
+	return false;
+}
+
+/*
+ * we use goto in CPreprocessor::if_elif_syntax_ok contrary to readable style guidelines
+ *	RetryStringMerge: restart the string-merge stage (should happen only if running short on memory
+ *	OneTokenExit: centralize exit code when down to one token
+ */
+bool
+CPreprocessor::if_elif_syntax_ok(Token&lt;char&gt;&amp; x, const autovalarray_ptr&lt;char*&gt;&amp; macros_object, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_object_expansion, const autovalarray_ptr&lt;char*&gt;&amp; macros_function, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_arglist, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_expansion,const type_system&amp; min_types)
+{
+	const unsigned int if_directive = UNPACK_DIRECTIVE(x.flags);
+	assert(PP::IF==if_directive || PP::ELIF==if_directive);
+	//! \test if.C99/Error_no_arg.hpp, if.C99/Error_no_arg.h : #if no control expression
+	//! \test if.C99/Error_if0_no_arg_elif.hpp, if.C99/Error_if0_no_arg_elif.h : #elif no control expression, critical
+	//! \test if.C99/Error_if1_no_arg_elif.hpp, if.C99/Error_if1_no_arg_elif.h : #elif no control expression, non-critical; could allow this with a do-what-i-mean option
+	if (!strcmp(x.data()+1,valid_directives[if_directive].first))
+		{
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(&quot;#&quot;);
+		INC_INFORM(valid_directives[if_directive].first);
+		INFORM(&quot; has no control expression. (C99 6.10p1/C++98 16p1)&quot;);
+		zcc_errors.inc_error();
+		return false;
+		};
+
+	// tokenize the whole line
+	autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt; pretokenized;
+	const size_t critical_offset = valid_directives[if_directive].second+2;
+	//! \test if.C99/Error_control2.hpp, if.C99/Error_control2.h (#if)
+	//! \todo __VA_ARGS__ within defined operator should only be a warning with --do-what-i-mean option
+	bool bad_control = C99_VA_ARGS_flinch(x,critical_offset);
+
+	//! \todo decide what to do when more languages are available for preprocessing
+	lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+	STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+
+	// analyze the defined operators
+	size_t i = 0;
+	do	if ((sizeof(&quot;defined&quot;)-1)==pretokenized[i].second &amp;&amp; !strncmp(x.data()+pretokenized[i].first,&quot;defined&quot;,(sizeof(&quot;defined&quot;)-1)))
+			{
+			if (i+1&gt;=pretokenized.size())
+				{	//! \test cpp/defined.C99/Error_malformed1.hpp, cpp/defined.C99/Error_malformed1.h
+				message_header(x);
+				INC_INFORM(ERR_STR);
+				INC_INFORM(&quot;malformed defined operator application (C99 6.10.1p1/C++98 16.1p1)&quot;);
+				INC_INFORM(x.data()+pretokenized[i].first,pretokenized[i].second);
+				zcc_errors.inc_error();
+				bad_control = true;
+				break;
+				};
+			if (C_TESTFLAG_IDENTIFIER==pretokenized[i+1].third)
+				{	// defined IDENTIFIER -- will evaluate to 0 or 1
+					//! \test cpp/defined.C99/Pass_defined_op.hpp, cpp/defined.C99/Pass_defined_op.h
+				int know_it_now = context_free_defined(x.data()+pretokenized[i+1].first, pretokenized[i+1].second);
+				if (0==know_it_now)
+					know_it_now = (macro_is_defined(x.data()+pretokenized[i+1].first, pretokenized[i+1].second, macros_object, macros_function)) ? 1 : -1;
+				const char subst_dest = (0&lt;know_it_now) ? '1' : '0';
+				if (replace_char_into_directive(x,pretokenized,subst_dest,i,1)) return true;
+				lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+				STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+				continue;
+				}
+			else if (token_is_char&lt;'('&gt;(x.data(),pretokenized[i+1]))
+				{	// defined(IDENTIFIER) [hopefully]
+				if (i+3&gt;=pretokenized.size())
+					{	//! \test defined.C99/Error_malformed3.hpp, defined.C99/Error_malformed3.h
+					message_header(x);
+					INC_INFORM(ERR_STR);
+					INC_INFORM(&quot;malformed defined operator application  (C99 6.10.1p1/C++98 16.1p1)&quot;);
+					INC_INFORM(x.data()+pretokenized[i].first,pretokenized.back().second+(pretokenized.back().first-pretokenized[i].first));
+					zcc_errors.inc_error();
+					bad_control = true;
+					break;
+					}
+				if (   C_TESTFLAG_IDENTIFIER==pretokenized[i+2].third
+					&amp;&amp; token_is_char&lt;')'&gt;(x.data(),pretokenized[i+3]))
+					{	// defined(IDENTIFIER)
+						//! \test cpp/defined.C99/Pass_defined_op.hpp, cpp/defined.C99/Pass_defined_op.h
+					int know_it_now = context_free_defined(x.data()+pretokenized[i+2].first, pretokenized[i+2].second);
+					if (0==know_it_now)
+						know_it_now = (macro_is_defined(x.data()+pretokenized[i+2].first, pretokenized[i+2].second, macros_object, macros_function)) ? 1 : -1;
+
+					const char subst_dest = (0&lt;know_it_now) ? '1' : '0';
+					if (replace_char_into_directive(x,pretokenized,subst_dest,i,3)) return true;
+					lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+					STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+					continue;
+					};
+				//! \test defined.C99/Error_nonidentifier.hpp, defined.C99/Error_nonidentifier.h
+				//! \test defined.C99/Error_excess_tokens.hpp, defined.C99/Error_excess_tokens.h
+				message_header(x);
+				INC_INFORM(ERR_STR);
+				INC_INFORM(&quot;malformed defined operator application  (C99 6.10.1p1/C++98 16.1p1)&quot;);
+				INC_INFORM(x.data()+pretokenized[i].first,pretokenized[i+3].second+(pretokenized[i+3].first-pretokenized[i].first));
+				zcc_errors.inc_error();
+				bad_control = true;
+				continue;
+				};
+			//! \test defined.C99/Error_malformed2.hpp, defined.C99/Error_malformed2.h
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INC_INFORM(&quot;malformed defined operator application  (C99 6.10.1p1/C++98 16.1p1)&quot;);
+			INC_INFORM(x.data()+pretokenized[i].first,pretokenized[i+1].second+(pretokenized[i+1].first-pretokenized[i].first));
+			zcc_errors.inc_error();
+			bad_control = true;
+			continue;
+			}
+	while(pretokenized.size() &gt; ++i);
+
+	// if any identifiers survive, we have to do macro preprocessing to get further
+	if (bad_control) return false;	// but if we discard the block anyway it doesn't matter
+
+	// analyze the __has_include() extension operator (from CLang)
+	i = 0;
+	do	if ((sizeof(&quot;__has_include&quot;)-1)==pretokenized[i].second &amp;&amp; !strncmp(x.data()+pretokenized[i].first,&quot;__has_include&quot;,(sizeof(&quot;__has_include&quot;)-1)))
+			{
+			// if no space for extension, let default flush-to-zero happen silently
+			if (4&gt;pretokenized.size()-i) break;
+			if (!token_is_char&lt;'('&gt;(x.data(),pretokenized[i+1]))
+				// do not trigger __has_include extension
+				continue;
+			// we want: __has_include(&quot;...&quot;) or __has_include(&lt;...&gt;)
+			if (   C_TESTFLAG_STRING_LITERAL==pretokenized[i+2].third
+				&amp;&amp; '&quot;'==x.data()[pretokenized[i+2].first]
+				&amp;&amp; token_is_char&lt;')'&gt;(x.data(),pretokenized[i+3]))
+				{	// __has_include(&quot;...&quot;)
+					//! \todo need test cases
+				if (0==pretokenized[i+2].second-2)
+					{	// empty, automatic failure
+					if (replace_char_into_directive(x,pretokenized,'0',i,3)) return true;
+					lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+					STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+					continue;
+					}
+
+				char buf[FILENAME_MAX];
+				char* const look_for = _new_buffer_nonNULL_throws&lt;char&gt;(ZAIMONI_LEN_WITH_NULL(pretokenized[i+2].second-2));
+				strncpy(look_for,x.data()+pretokenized[i+2].first+1,pretokenized[i+2].second-2);
+				if (strchr(look_for,'&quot;'))
+					{
+					message_header(x);
+					INFORM(&quot;__has_include(\&quot;...\&quot;) contains \&quot;; preprocessing per standards rather than invoking extension __has_include&quot;);
+					free(look_for);
+					i += 2;
+					continue;
+					};
+				const char subst_dest = (detect_hardcoded_system_header(look_for,lang_code) || find_local_include(look_for, buf, (x.parent_dir ? x.parent_dir : &quot;.&quot;)) || find_system_include(look_for, buf)) ? '1' : '0';
+				free(look_for);
+				if (replace_char_into_directive(x,pretokenized,subst_dest,i,3)) return true;
+				lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+				STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+				continue;
+				}
+			//! \todo: optimization check: does testing for &lt; and &gt; by leading/trailing character reduce code size
+			else if (token_is_char&lt;'&lt;'&gt;(x.data(),pretokenized[i+2]))
+				{
+				size_t j = i+2;
+				while(pretokenized.size()-1 &gt; ++j)
+					if (token_is_char&lt;'&gt;'&gt;(x.data(),pretokenized[j]))
+						{	//! \todo need test cases
+						if (!token_is_char&lt;')'&gt;(x.data(),pretokenized[j+1])) break;
+						// __has_include(&lt;...&gt;)
+						if (0==pretokenized[j].first-pretokenized[i+2].first+pretokenized[j].second-2)
+							{	// empty, automatic failure
+							if (replace_char_into_directive(x,pretokenized,'0',i,j+1-i)) return true;
+							lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+							STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+							continue;
+							}
+						char buf[FILENAME_MAX];
+						char* const look_for = _new_buffer_nonNULL_throws&lt;char&gt;(ZAIMONI_LEN_WITH_NULL(pretokenized[j].first-pretokenized[i+2].first+pretokenized[j].second-2));
+						strncpy(look_for,x.data()+pretokenized[i+2].first+1,pretokenized[j].first-pretokenized[i+2].first+pretokenized[j].second-2);
+						if (strchr(look_for,'&lt;'))
+							{
+							message_header(x);
+							INFORM(&quot;__has_include(&lt;...&gt;) contains &lt;; preprocessing per standards rather than invoking extension __has_include&quot;);
+							free(look_for);
+							i += 2;
+							continue;
+							};
+						if (strchr(look_for,'&gt;'))
+							{
+							message_header(x);
+							INFORM(&quot;__has_include(&lt;...&gt;) contains &gt;; preprocessing per standards rather than invoking extension __has_include&quot;);
+							free(look_for);
+							i += 2;
+							continue;
+							};
+						const char subst_dest = (detect_hardcoded_system_header(look_for,lang_code) || find_system_include(look_for, buf)) ? '1' : '0';
+						free(look_for);
+						if (replace_char_into_directive(x,pretokenized,subst_dest,i,j+1-i)) return true;
+						lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+						STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+						continue;
+						}
+				++i;
+				continue;
+				}
+			// not recognized as __has_include directive, preprocess per standards
+			}
+	while(pretokenized.size() &gt; ++i);
+
+	// if any identifiers survive, we have to do macro preprocessing to get further
+	if (bad_control) return false;	// but if we discard the block anyway it doesn't matter
+
+	intradirective_preprocess(x,valid_directives[if_directive].second+2,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion);
+
+	// if we went invalid do not proceed further
+	if (x.flags &amp; INVALID_DIRECTIVE_FLAG) return false;
+
+	intradirective_flush_identifiers_to_zero(x,valid_directives[if_directive].second+2);
+
+	// ZCC should actually calculate the control expression completely to 0/1  Error reporting for this isn't particularly compatible with destructive-evaluate.
+	// this is for both #if and #elif directives at depth 1
+	// cf. USENET discussion with Eric Sosman @ sun.com on comp.lang.c at Rationale.XXX/comp.lang.c_must_fully_process_depth1_elif_20080827.htm
+	// note that integer literals are always parsed as of type intmax_t or uintmax_t
+	lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+	STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+
+	// error the illegal preprocessing tokens here
+	{
+	const size_t old_err_count = zcc_errors.err_count();
+	i = pretokenized.size();
+	do	{
+		--i;
+		lang.pp_support-&gt;AddPostLexFlags(x.data()+pretokenized[i].first, pretokenized[i].second, pretokenized[i].third, x.src_filename, x.original_line.first);
+		if (	(C_TESTFLAG_PP_OP_PUNC &amp; pretokenized[i].third)
+			&amp;&amp; 	((C_DISALLOW_POSTPROCESSED_SOURCE | C_DISALLOW_CONSTANT_EXPR | C_DISALLOW_IF_ELIF_CONTROL) &amp; lang.pp_support-&gt;GetPPOpPuncFlags(C_PP_DECODE(pretokenized[i].third))))
+			{
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INC_INFORM(&quot;Forbidden token &quot;);
+			INC_INFORM(x.data()+pretokenized[i].first, pretokenized[i].second);
+			INFORM(&quot; in control expression.&quot;);
+			zcc_errors.inc_error();
+			};
+		}
+	while(0&lt;i);
+	if (old_err_count!=zcc_errors.err_count()) return false;
+	}
+
+	// should be merging string literals at this point
+RetryStringMerge:
+	bool want_clean_ws = false;
+	bool str_concat_wants_RAM = false;
+	if (2&lt;=pretokenized.size())
+		{	//! \bug need test cases...lots of them
+		size_t i = 0;
+		while(i&lt;pretokenized.size())
+			{
+			if (C_TESTFLAG_STRING_LITERAL!=pretokenized[i+1].third)
+				{
+				i += 2;
+				continue;
+				}
+			if (C_TESTFLAG_STRING_LITERAL!=pretokenized[i].third)
+				{
+				++i;
+				continue;
+				}
+
+			char* test = NULL;
+			const int res_code = lang.pp_support-&gt;EscapedStringConcatenate(x.data()+pretokenized[i].first,pretokenized[i].second,x.data()+pretokenized[i+1].first,pretokenized[i+1].second,test);
+			assert(-5&lt;=res_code &amp;&amp; 1&gt;=res_code);
+			assert(1==res_code || NULL==test);
+			assert(1!=res_code || NULL!=test);
+			switch(res_code)
+			{
+			case -5:	{	// intermediate memory failed
+						str_concat_wants_RAM = true;
+			case 0:		++i;		// something exotic, mergence won't work
+						continue;
+						}
+			case -4:	{	// second string literal content, but wide
+						const size_t delta = pretokenized[i+1].first-(pretokenized[i].first+1U);
+						x.intradelete(pretokenized[i].first+1U,delta);
+						pretokenized[i].second = pretokenized[i+1].second+1;
+						pretokenized.DeleteIdx(i+1);
+						STL_translate_second(delta,pretokenized.begin()+i+1,pretokenized.end());
+						continue;
+						};
+			case -3:	{	// first string literal content, but wide
+							// convolution will handle UNICODE and raw strings as well
+						const char width_tag = x.data()[pretokenized[i+1].first];
+						memset(x.c_array()+pretokenized[i+1].first,' ',pretokenized[i+1].second);
+						pretokenized.DeleteIdx(i+1);
+						memmove(x.c_array()+pretokenized[i].first+1,x.c_array()+pretokenized[i].first,pretokenized[i].second);
+						x.c_array()[pretokenized[i].first] = width_tag;
+						++(pretokenized[i].first);
+						want_clean_ws = true;
+						continue;
+						};
+			case -2:	{	// second string literal is sufficient
+						memset(x.c_array()+pretokenized[i].first,' ',pretokenized[i].second);
+						pretokenized.DeleteIdx(i);
+						want_clean_ws = true;
+						continue;
+						};
+			case -1:	{	// first string literal is sufficient
+						memset(x.c_array()+pretokenized[i+1].first,' ',pretokenized[i+1].second);
+						pretokenized.DeleteIdx(i+1);
+						want_clean_ws = true;
+						continue;
+						};
+			case 1:		{	// no fancy memory conservation
+						const size_t replace_span = (pretokenized[i+1].first-pretokenized[i].first)+pretokenized[i+1].second;
+						const size_t core_str_target_len = strlen(test);
+						assert(IsLegalCString(test,core_str_target_len));
+						x.replace_once(std::nothrow,pretokenized[i].first,replace_span,test);
+						pretokenized.DeleteIdx(i+1);
+						if (core_str_target_len!=replace_span)
+							STL_translate_second(core_str_target_len-replace_span,pretokenized.begin()+i+1,pretokenized.end());	// C99 requires wraparound for unsigned ints, so this works
+						pretokenized[i].second = core_str_target_len;
+						free(test);
+						continue;
+						};
+			}
+			}
+		};
+	if (want_clean_ws)
+		{	// conserve memory
+		if (_flush_token_gaps(x,pretokenized,lang) &amp;&amp; str_concat_wants_RAM) goto RetryStringMerge;
+		want_clean_ws = false;
+		};
+
+	// if there is only one token: it should be a preprocessing number or a character literal.  Handle it or error here
+	if (1==pretokenized.size())
+		{
+oneTokenExit:
+		assert(!str_concat_wants_RAM);
+		bool is_zero = false;
+		if (!if_elif_control_is_zero(x,pretokenized.front(),is_zero))
+			{
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INC_INFORM(x.data()+pretokenized.front().first,pretokenized.front().second);
+			INFORM(&quot; : value of control expression for #if/#elif must be a valid preprocessing integer (C99 6.10.1p1/C++98 16.1p1)&quot;);
+			zcc_errors.inc_error();
+			return false;
+			}
+		//! \todo --do-what-i-mean doesn't call this to evoke an error
+		C99_literal_is_legal(x.data()+pretokenized.front().first,pretokenized.front().second,pretokenized.front().third,x.src_filename,x.logical_line.first,min_types);
+		x.replace_once(std::nothrow,critical_offset,x.size()-critical_offset,(is_zero) ? '0' : '1');
+		return true;
+		}
+
+	{	// check for balancing errors (slow)
+	autovalarray_ptr&lt;weak_token&gt; weaktoken_list;
+	_weak_tokenize_aux(x,pretokenized,weaktoken_list);
+	// do not process further if there are context-free errors
+	if (lang.pp_support-&gt;BalancingErrorCheck(weaktoken_list.data(),weaktoken_list.size(),true,true)) return false;
+	};
+
+	autovalarray_ptr&lt;POD_pair&lt;size_t,size_t&gt; &gt; parenpair_stack;
+	// context-free check should be intercepting when these are invalid
+	construct_matched_pairs&lt;'(',')'&gt;(x,pretokenized,parenpair_stack);
+
+	while(!parenpair_stack.empty() &amp;&amp; 0==parenpair_stack.back().first &amp;&amp; pretokenized.size()-1==parenpair_stack.back().second)
+		{
+		balanced_character_kill(x,pretokenized,parenpair_stack,parenpair_stack.size()-1);	// outermost parentheses pair: erase
+		want_clean_ws = true;
+		}
+
+	// directly nested parentheses cleanup
+	i = parenpair_stack.size();
+	while(1&lt;i)
+		{
+		--i;
+		if (   parenpair_stack[i-1].first   ==parenpair_stack[i].first+1
+			&amp;&amp; parenpair_stack[i-1].second+1==parenpair_stack[i].second)
+			{
+			balanced_character_kill(x,pretokenized,parenpair_stack,i);	// outer pair immediately contains inner pair
+			want_clean_ws = true;
+			}
+		};
+	// only-literal nested parentheses cleanup
+	// valid only because no functions present or macros present [no identifiers left]
+	i = parenpair_stack.size();
+	while(0&lt;i)
+		{
+		--i;
+		if (   2==parenpair_stack[i].second-parenpair_stack[i].first
+			&amp;&amp; ((C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_STRING_LITERAL | C_TESTFLAG_PP_NUMERAL) &amp; pretokenized[parenpair_stack[i].first+1].third))
+			{
+			balanced_character_kill(x,pretokenized,parenpair_stack,i);
+			want_clean_ws = true;
+			}
+		};
+
+	if (pretokenized.empty())
+		{	// if.C99/Error_control24.hpp, if.C99/Error_control24.h
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(x.data()+critical_offset,x.size()-critical_offset);
+		INFORM(&quot; : control expression for #if/#elif must evaluate to a single integer constant (C99 6.10.1p1/C++98 16.1p1)&quot;);
+		zcc_errors.inc_error();
+		return false;
+		}
+
+	// if there is only one token: it should be a preprocessing number or a character literal.  Handle it or error here
+	if (1==pretokenized.size()) goto oneTokenExit;
+
+	if (want_clean_ws)
+		{
+		if (_flush_token_gaps(x,pretokenized,lang) &amp;&amp; str_concat_wants_RAM) goto RetryStringMerge;
+		want_clean_ws = false;
+		}
+
+	{	// check for context-free errors
+	autovalarray_ptr&lt;weak_token&gt; weaktoken_list;
+	_weak_tokenize_aux(x,pretokenized,weaktoken_list);
+	// do not process further if there are context-free errors
+	if (lang.pp_support-&gt;ControlExpressionContextFreeErrorCheck(weaktoken_list.data(),weaktoken_list.size(),true,true)) return false;
+	};
+
+	// unfortunately, we need a parse tree even for this: the ternary operator ? : means we can't actually evaluate everything promiscuously
+	{
+	parse_tree_class parsetree;
+	_parsetreeize_aux(x,pretokenized,parsetree);
+	assert(parsetree.is_raw_list() || parsetree.is_atomic());
+	if (parsetree.is_raw_list() &amp;&amp; !lang.pp_support-&gt;CondenseParseTree(parsetree,min_types)) return false;
+	if (!parsetree.is_atomic() &amp;&amp; !lang.pp_support-&gt;EvalParseTree(parsetree,min_types)) return false;
+	lang.pp_support-&gt;PPHackTree(parsetree,min_types);
+	// final, when above is working properly
+	if (!parsetree.is_atomic())
+		{
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(x.data()+critical_offset,x.size()-critical_offset);
+		INFORM(&quot; : control expression for #if/#elif must evaluate to a single integer constant (C99 6.10.1p1/C++98 16.1p1)&quot;);
+		zcc_errors.inc_error();
+		return false;
+		}
+	x.replace_once(std::nothrow,critical_offset,x.size()-critical_offset,parsetree.index_tokens[0].token.first,parsetree.index_tokens[0].token.second);
+	lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+	STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+	i = pretokenized.size();
+	do	{
+		--i;
+		lang.pp_support-&gt;AddPostLexFlags(x.data()+pretokenized[i].first, pretokenized[i].second, pretokenized[i].third, x.src_filename, x.original_line.first);
+		}
+	while(0&lt;i);
+	str_concat_wants_RAM = false;
+	}
+	if (1==pretokenized.size()) goto oneTokenExit;
+	return true;
+}
+
+#/*cut-cpp*/
+#/*cut-nocpp*/
+// don't undef these when testing tokenize-flow preprocessing
+#/*cut-nocpp*/
+#/*cut-cpp*/
+#undef PREPROCESSING_DIRECTIVE_FLAG
+#undef PACK_DIRECTIVE
+#undef UNPACK_DIRECTIVE
+#undef MAX_PP_DIRECTIVE
+#undef PP_INVALID
+#undef SYNTAX_CHECKED_FLAG
+
+void
+CPreprocessor::predefined_macro_replacement(Token&lt;char&gt;&amp; x, size_t critical_offset)
+{
+	assert(x.size()&gt;critical_offset);
+	lex_flags token_flags;
+	while(x.size()&gt;critical_offset)
+		{
+		const size_t token_len = lang.UnfilteredNextToken(x.data()+critical_offset,token_flags);
+		if (    C_TESTFLAG_IDENTIFIER!=token_flags
+			|| !predefined_macro_replace_once(x,critical_offset,token_len))
+			critical_offset += token_len;
+		}
+}
+
+/*! 
+ * Replaces a predefined macro if it is at the exact location named.
+ * 
+ * \param x token containing candidate for predefined macro
+ * \param critical_offset where the candidate is
+ * \param token_len length of candidate
+ * 
+ * \return true iff replaced a predefined macro.  Updates critical_offset when returning true
+ */
+bool
+CPreprocessor::predefined_macro_replace_once(Token&lt;char&gt;&amp; x, size_t&amp; critical_offset, const size_t token_len)
+{
+	assert(x.size()&gt;critical_offset);
+	assert(x.size()&gt;=critical_offset+token_len);
+	const errr macro_index = linear_find(x.data()+critical_offset,token_len,macro_identifier_default,macro_identifier_default_count);
+	if (-1!=macro_index)
+		{
+		const char* macro_value = NULL;
+		char buf[10];
+		char file_buf[MAX_PATH+2];
+		if (NULL!=macro_identifier_default[macro_index].second)
+			// value known, substitute in
+			macro_value = macro_identifier_default[macro_index].second;
+		// special
+		else if (!strcmp(macro_identifier_default[macro_index].first,&quot;__FILE__&quot;))
+			{
+			assert(NULL!=x.src_filename);
+			file_buf[0] = '&quot;';
+			strcpy(file_buf+1,x.src_filename);
+			file_buf[1+strlen(x.src_filename)] = '&quot;';
+			file_buf[2+strlen(x.src_filename)] = '\0';
+			macro_value = file_buf;
+			}
+		else if (!strcmp(macro_identifier_default[macro_index].first,&quot;__LINE__&quot;))
+			macro_value = z_umaxtoa(x.logical_line.first,buf,10);
+		else if (!strcmp(macro_identifier_default[macro_index].first,&quot;__TIME__&quot;))
+			macro_value = time_buffer;
+		else if (!strcmp(macro_identifier_default[macro_index].first,&quot;__TIMESTAMP__&quot;))
+			macro_value = time_date_buffer;
+		else if (!strcmp(macro_identifier_default[macro_index].first,&quot;__COUNTER__&quot;))
+			macro_value = z_umaxtoa(counter_macro++,buf,10);
+		else if (!strcmp(macro_identifier_default[macro_index].first,&quot;__INCLUDE_LEVEL__&quot;))
+			macro_value = z_umaxtoa(include_level,buf,10);
+		else{
+			assert(!strcmp(macro_identifier_default[macro_index].first,&quot;__DATE__&quot;));
+			macro_value = date_buffer;
+			}
+		_macro_replace(x,critical_offset,token_len,macro_value);
+		return true;
+		}
+	return false;
+}
+
+void
+CPreprocessor::_macro_replace(Token&lt;char&gt;&amp; x, size_t&amp; critical_offset, const size_t token_len,const char* const macro_value) const
+{
+	assert(x.size()&gt;critical_offset);
+	assert(x.size()-critical_offset&gt;=token_len);
+	assert(0&lt;token_len);
+
+	if (is_empty_string(macro_value))
+		{
+		if (x.size()-critical_offset&lt;=token_len)
+			x.rtrim(token_len);
+		else if (0==critical_offset)
+			x.ltrim(token_len);
+		else if (require_padding(x.data()[critical_offset-1],x.data()[critical_offset+token_len]))
+			x.replace_once(std::nothrow,critical_offset,token_len,' ');
+		else
+			x.intradelete(critical_offset,token_len);
+		return;
+		}
+
+	const bool pad_left = 0&lt;critical_offset &amp;&amp; require_padding(x.data()[critical_offset-1],macro_value[0]);
+	const bool pad_right = x.size()&gt;critical_offset+token_len &amp;&amp; require_padding(macro_value[strlen(macro_value)-1],x.data()[critical_offset+token_len]);
+
+	if (pad_right) x.replace_once(critical_offset+token_len,0,' ');
+	x.replace_once(critical_offset,token_len,macro_value);
+	if (pad_left) x.replace_once(critical_offset,0,' ');
+
+	critical_offset += strlen(macro_value);
+	if (pad_right) ++critical_offset;
+	if (pad_left) ++critical_offset;
+}
+
+
+void
+CPreprocessor::instantiate_function_macro_arguments(autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; arguments, const Token&lt;char&gt;&amp; arglist, size_t arg_count) const
+{
+	lex_flags scratch_flags;
+	size_t paren_depth = 1;
+	size_t var_origin = 0;
+	size_t offset = 1;
+	size_t count_args = 0;
+	assert(2&lt;=arglist.size());
+	assert('('==arglist.front());
+	assert(')'==arglist.back());
+	if (2==arglist.size())
+		{
+		assert(0==arg_count);
+		arguments.reset();
+		return;
+		};
+	assert(0!=arg_count);
+	assert(arg_count&lt;arglist.size());
+	arguments.resize(arg_count);
+	while(offset&lt;arglist.size())
+		{
+		if 		('('==arglist.data()[offset])
+			{
+			++paren_depth;
+			++offset;
+			}
+		else if	(')'==arglist.data()[offset])
+			{
+			--paren_depth;
+			if (0==paren_depth)
+				{	// update var
+				if (var_origin+1&lt;offset)
+					{
+					const size_t skip_ws = strspn(arglist.data()+var_origin+1,lang.WhiteSpace);
+					if (offset-var_origin+1&gt;skip_ws)
+						{
+						arguments[count_args] = new Token&lt;char&gt;(arglist,var_origin+1+skip_ws,offset-var_origin-1-skip_ws,0);
+						_flush_duplicated_ws(*arguments[count_args],lang);
+						}
+					};
+				return;
+				}
+			++offset;
+			}
+		else if (','==arglist.data()[offset] &amp;&amp; 1==paren_depth &amp;&amp; count_args&lt;arg_count-1)
+			{	// update var
+			if (var_origin+1&lt;offset)
+				{
+				const size_t skip_ws = strspn(arglist.data()+var_origin+1,lang.WhiteSpace);
+				if (offset-var_origin+1&gt;skip_ws)
+					{
+					arguments[count_args] = new Token&lt;char&gt;(arglist,var_origin+1+skip_ws,offset-var_origin-1-skip_ws,0);
+					_flush_duplicated_ws(*arguments[count_args],lang);
+					}
+				};
+			var_origin = offset;
+			++offset;
+			++count_args;
+			}
+		else
+			offset += lang.UnfilteredNextToken(arglist.data()+offset,scratch_flags);
+		}
+}
+
+bool
+CPreprocessor::dynamic_macro_replace_once(Token&lt;char&gt;&amp; x, size_t&amp; critical_offset, size_t token_len, const autovalarray_ptr&lt;char*&gt;&amp; macros_object, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_object_expansion, const autovalarray_ptr&lt;char*&gt;&amp; macros_function, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_arglist, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_expansion, autovalarray_ptr&lt;char*&gt;* const used_macro_stack)
+{
+	assert(x.size()&gt;critical_offset);
+	assert(x.size()-critical_offset&gt;=token_len);
+	assert(macros_object.size()==macros_object_expansion.size());
+	assert(macros_function.size()==macros_function_expansion.size());
+	const errr object_macro_index = binary_find(x.data()+critical_offset,token_len,macros_object);
+	const errr function_macro_index = binary_find(x.data()+critical_offset,token_len,macros_function);
+	assert(0&gt;object_macro_index || 0&gt;function_macro_index);
+	if (0&lt;=object_macro_index)
+		{
+		if (NULL==macros_object_expansion[object_macro_index])
+			{
+			_macro_replace(x,critical_offset,token_len,&quot;&quot;);
+			return true;
+			};
+		if (nonrecursive_macro_replacement_list(macros_object_expansion[object_macro_index]-&gt;data()))
+			{
+			_macro_replace(x,critical_offset,token_len,macros_object_expansion[object_macro_index]-&gt;data());
+			return true;
+			};
+		size_t test_critical_offset = 0;
+		Token&lt;char&gt; Test(x);
+		Test.lslice(critical_offset+token_len);
+		Test.ltrim(critical_offset);
+		_macro_replace(Test,test_critical_offset,token_len,macros_object_expansion[object_macro_index]-&gt;data());
+		predefined_macro_replacement(Test,0);
+		if (NULL==used_macro_stack)
+			{
+			autovalarray_ptr&lt;char*&gt; macro_stack(1);
+			macro_stack[0] = _new_buffer_nonNULL_throws&lt;char&gt;(token_len);
+			memmove(macro_stack[0],x.data()+critical_offset,token_len);
+			intradirective_preprocess(Test,0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,&amp;macro_stack);
+			}
+		else{
+			used_macro_stack-&gt;insertNSlotsAt(1,used_macro_stack-&gt;size());
+			used_macro_stack-&gt;back() = _new_buffer_nonNULL_throws&lt;char&gt;(token_len);
+			memmove(used_macro_stack-&gt;back(),x.data()+critical_offset,token_len);
+			intradirective_preprocess(Test,0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack);
+			used_macro_stack-&gt;DeleteIdx(used_macro_stack-&gt;size()-1);
+			}
+		_macro_replace(x,critical_offset,token_len,Test.data());
+		return true;
+		};
+	if (0&lt;=function_macro_index &amp;&amp; x.size()&gt;critical_offset+token_len &amp;&amp; '('==x.data()[critical_offset+token_len])
+		{
+		assert(NULL!=macros_function_arglist[function_macro_index]);
+		assert('('==macros_function_arglist[function_macro_index]-&gt;front());
+		assert(')'==macros_function_arglist[function_macro_index]-&gt;back());
+		const size_t formal_arg_span = macros_function_arglist[function_macro_index]-&gt;size();
+		const size_t formal_arg_count = (2&lt;formal_arg_span) ? std::count(macros_function_arglist[function_macro_index]-&gt;begin(),macros_function_arglist[function_macro_index]-&gt;end(),',')+1 : 0;
+		const bool formal_varadic = 5&lt;=formal_arg_span &amp;&amp; !strncmp(macros_function_arglist[function_macro_index]-&gt;data()+(formal_arg_span-4),&quot;...&quot;,sizeof(&quot;...&quot;)-1);
+		size_t arg_count = 0;
+		const size_t arg_span = function_macro_invocation_argspan(x.data()+critical_offset+token_len,x.size()-(critical_offset+token_len),arg_count);
+		if (0==arg_span)
+			{	//! \test Error_macro_arglist1.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INC_INFORM(&quot;macro &quot;);
+			INC_INFORM(x.data()+critical_offset,token_len);
+			INFORM(&quot; did not close its argument list in time. (C99 6.10p1/C++98 16.1p1)&quot;);
+			zcc_errors.inc_error();
+			x.flags |= INVALID_DIRECTIVE_FLAG;
+			return false;
+			}
+		if (formal_arg_count&gt;arg_count || (formal_arg_count&lt;arg_count &amp;&amp; !formal_varadic))
+			{	//! \test Error_macro_arglist2.hpp
+				//! \test Error_macro_arglist3.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INC_INFORM(&quot;macro &quot;);
+			INC_INFORM(x.data()+critical_offset,token_len);
+			INC_INFORM(&quot; had &quot;);
+			INC_INFORM(arg_count);
+			INC_INFORM(&quot; argument&quot;);
+			INC_INFORM((1==arg_count) ? &quot;&quot; : &quot;s&quot;);
+			INC_INFORM(&quot;, needed &quot;);
+			if (formal_varadic) INC_INFORM(&quot;at least &quot;);
+			INC_INFORM(formal_arg_count);
+			INFORM(&quot;. (C99 6.10p1/C++0x 16.1p1)&quot;);
+			zcc_errors.inc_error();
+			x.flags |= INVALID_DIRECTIVE_FLAG;
+			return false;
+			}
+		if (NULL==macros_function_expansion[function_macro_index])
+			{
+			_macro_replace(x,critical_offset,token_len+arg_span,&quot;&quot;);
+			return true;
+			};
+		if (nonrecursive_macro_replacement_list(macros_function_expansion[function_macro_index]-&gt;data()))
+			{
+			_macro_replace(x,critical_offset,token_len+arg_span,macros_function_expansion[function_macro_index]-&gt;data());
+			return true;
+			};
+
+		autovalarray_ptr&lt;Token&lt;char&gt;*&gt; formal_arguments;
+		autovalarray_ptr&lt;Token&lt;char&gt;*&gt; actual_arguments;
+		{
+		Token&lt;char&gt; actual_pre_args(x,critical_offset+token_len,arg_span,0);
+		instantiate_function_macro_arguments(actual_arguments,actual_pre_args,formal_arg_count);
+		}
+		//! \todo consider calling this once on-demand (space vs. time trade)
+		instantiate_function_macro_arguments(formal_arguments,*macros_function_arglist[function_macro_index],formal_arg_count);
+		// arguments should already be normal-formed coming out, with as many as requested
+		assert(formal_arguments.size()==formal_arg_count);
+		assert(actual_arguments.size()==formal_arg_count);
+#ifndef NDEBUG
+		{	// reality-check the formal argument list
+		lex_flags identifier_flags;
+		size_t j = formal_arg_count;
+		do	{
+			--j;
+			assert(NULL!=formal_arguments[j]);
+			assert(0&lt;formal_arguments[j]-&gt;size());
+			const size_t identifier_len = lang.UnfilteredNextToken(formal_arguments[j]-&gt;data(),identifier_flags);
+			assert(C_TESTFLAG_IDENTIFIER==identifier_flags);
+			assert(identifier_len==formal_arguments[j]-&gt;size());
+			}
+		while(0&lt;j);
+		}
+#endif
+		// ... is used as parameter __VA_ARGS__
+		//! __VA_ARGS__ occurs only in the replacement list of varadic function-like macros, so it is the proper variable name for that ...
+		if (formal_varadic) formal_arguments.back()-&gt;replace_once(0,formal_arguments.back()-&gt;size(),&quot;__VA_ARGS__&quot;);
+		//! \todo should discard unused formal arguments and their parameter lists; not worth a warning, as there are a number of legitimate uses for discarding formal parameters
+		Token&lt;char&gt; Test(*macros_function_expansion[function_macro_index]);
+		if (NULL==used_macro_stack)
+			{
+			autovalarray_ptr&lt;char*&gt; macro_stack(1);
+			macro_stack[0] = _new_buffer_nonNULL_throws&lt;char&gt;(token_len);
+			memmove(macro_stack[0],x.data()+critical_offset,token_len);
+
+			dynamic_function_macro_prereplace_once(macros_object, macros_object_expansion, macros_function, macros_function_arglist, macros_function_expansion, &amp;macro_stack, formal_arguments, actual_arguments, Test);
+			}
+		else{
+			used_macro_stack-&gt;insertNSlotsAt(1,used_macro_stack-&gt;size());
+			used_macro_stack-&gt;back() = _new_buffer_nonNULL_throws&lt;char&gt;(token_len);
+			memmove(used_macro_stack-&gt;back(),x.data()+critical_offset,token_len);
+
+			dynamic_function_macro_prereplace_once(macros_object, macros_object_expansion, macros_function, macros_function_arglist, macros_function_expansion, used_macro_stack, formal_arguments, actual_arguments, Test);
+			used_macro_stack-&gt;DeleteIdx(used_macro_stack-&gt;size()-1);
+			}
+		_macro_replace(x,critical_offset,token_len+arg_span,Test.data());
+		return true;
+		};
+	return false;
+}
+
+/*! 
+ * Does a single concatenation of the tokens indicated
+ * 
+ * \param x : where concatenation is being done
+ * \param pretokenized : pointer into C array where tokenization info is
+ * 
+ * \return true if and only if concatenation happened
+ */
+static bool _concatenate_single(Token&lt;char&gt;&amp; x,const POD_triple&lt;size_t,size_t,lex_flags&gt;* pretokenized, LangConf&amp; lang)
+{
+	assert(NULL!=pretokenized);
+	autovalarray_ptr_throws&lt;char&gt; new_token(pretokenized[0].second+pretokenized[2].second);
+	strncpy(new_token.c_array(),x.data()+pretokenized[0].first,pretokenized[0].second);
+	strncpy(new_token.c_array()+pretokenized[0].second,x.data()+pretokenized[2].first,pretokenized[2].second);
+	lex_flags scratch_flags;
+	const size_t new_token_len = lang.UnfilteredNextToken(new_token.data(),scratch_flags);
+	if (new_token_len!=new_token.size())
+		{	//! \test define.C99/Error_concatenate3.hpp, define.C99/Error_concatenate3.h
+			//! \test define.C99/Error_concatenate4.hpp, define.C99/Error_concatenate4.h
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(&quot;## concatenation result &quot;);
+		INC_INFORM(new_token.data());
+		INFORM(&quot; is not a single token.  Defining undefined behavior as eliminating ## and continuing (C99 6.10.3.3p3/C++98 16.3.3p3)&quot;);
+		zcc_errors.inc_error();
+
+		const size_t offset = pretokenized[0].first+pretokenized[0].second;
+		if (new_token_len==pretokenized[0].second)
+			x.intradelete(offset,pretokenized[2].first-offset);
+		else
+			x.replace_once(offset,pretokenized[2].first-offset,' ');
+		return false;
+		};
+	// splice it
+	//! \test define.C99/Pass_concatenate1.hpp, define.C99/Pass_concatenate1.h
+	//! \test define.C99/Pass_concatenate2.hpp, define.C99/Pass_concatenate2.h
+	x.replace_once(pretokenized[0].first,(pretokenized[2].first-pretokenized[0].first)+pretokenized[2].second,new_token.data());
+	return true;
+}
+
+static void remove_ws_from_token(Token&lt;char&gt;&amp; x, const autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt;&amp; pretokenized)
+{
+	// truncate everything past last token
+	x.lslice(pretokenized.back().first+pretokenized.back().second);
+	size_t i = pretokenized.size();
+	if (2&lt;=i)
+		{
+		--i;
+		do	{
+			--i;
+			if (   pretokenized[i].first&lt;pretokenized[i+1].first
+				&amp;&amp; pretokenized[i].second&lt;pretokenized[i+1].first-pretokenized[i].first)
+				{
+				const size_t ws_origin = pretokenized[i].first+pretokenized[i].second;
+				x.replace_once(std::nothrow,ws_origin,pretokenized[i+1].first-ws_origin,' ');
+				}
+			}
+		while(0&lt;i);
+		}
+
+	// truncate before first token
+	x.ltrim(pretokenized.front().first);
+}
+
+void
+CPreprocessor::dynamic_function_macro_prereplace_once(const autovalarray_ptr&lt;char*&gt;&amp; macros_object, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_object_expansion, const autovalarray_ptr&lt;char*&gt;&amp; macros_function, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_arglist, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_expansion,autovalarray_ptr&lt;char*&gt;* const used_macro_stack, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; formal_arguments, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; actual_arguments, Token&lt;char&gt;&amp; x)
+{
+	// deal with # operators before macro-replacing arguments
+	autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt; pretokenized;
+	if (lang.line_lex_find(x.data(),x.size(),&quot;#&quot;,sizeof(&quot;#&quot;)-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),&quot;%:&quot;,sizeof(&quot;%:&quot;)-1,pretokenized))
+		{
+		size_t i = pretokenized.size();
+		do	{
+			--i;
+			if (detect_C_stringize_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+				{
+				assert(pretokenized.size()&gt;i+1);
+				assert(pretokenized[i].first+pretokenized[i].second==pretokenized[i+1].first);
+				const errr j = (C_TESTFLAG_IDENTIFIER==pretokenized[i].third) ? linear_find_STL_deref2(x.data()+pretokenized[i+1].first,pretokenized[i+1].second,formal_arguments) : -1;
+				assert(0&lt;=j);
+
+				{
+				autovalarray_ptr&lt;char&gt; stringized_actual;	//! \todo inefficient, should stringize any parameter only once and reuse
+				stringize(stringized_actual,actual_arguments[j]);
+				// safe because narrow string
+				x.replace_once(pretokenized[i].first,pretokenized[i+1].second+pretokenized[i].second,stringized_actual.data());
+				// XXX leave behind garbage in pretokenized
+				}
+				}
+			}
+		while(0&lt;i);
+		};
+
+	// deal with empty-var ## operators
+	size_t j = actual_arguments.size();
+	do if (NULL==actual_arguments[--j])
+			{	// have a genuinely empty argument
+			if (lang.line_lex_find(x.data(),x.size(),&quot;##&quot;,sizeof(&quot;##&quot;)-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),&quot;%:%:&quot;,sizeof(&quot;%:%:&quot;)-1,pretokenized))
+				{
+				assert(!detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second));
+				assert(!detect_C_concatenation_op(x.data()+pretokenized.back().first, pretokenized.back().second));
+				size_t k = pretokenized.size();
+				if (3&lt;=k)
+					{
+					do	if (C_TESTFLAG_NONATOMIC_PP_OP_PUNC==pretokenized[--k].third &amp;&amp; detect_C_concatenation_op(x.data()+pretokenized[k].first,pretokenized[k].second))
+							{
+							if (C_TESTFLAG_IDENTIFIER==pretokenized[k+1].third)
+								{
+								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k+1].first,pretokenized[k+1].second,formal_arguments);
+								if (0&lt;=j2 &amp;&amp; NULL==actual_arguments[j2])
+									{	// we matched an empty parameter (concatenation identity)
+									const size_t replace_start = pretokenized[k-1].first+pretokenized[k-1].second;
+									size_t replace_len = (pretokenized[k+1].first-replace_start)+pretokenized[k+1].second;
+									if (x.size()&gt;replace_start+replace_len)
+										replace_len += strspn(x.data()+replace_start+replace_len,lang.WhiteSpace+1);
+									x.replace_once(replace_start,replace_len,' ');
+									continue;
+									}
+								};
+							if (C_TESTFLAG_IDENTIFIER==pretokenized[k-1].third)
+								{	// don't need should_continue bypass for last check
+								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k-1].first,pretokenized[k-1].second,formal_arguments);
+								if (0&lt;=j2 &amp;&amp; NULL==actual_arguments[j2])
+									{
+									const size_t replace_start = (0&lt;k) ? pretokenized[k-2].first+pretokenized[k-2].second : 0U;
+									size_t replace_len = (pretokenized[k].first-replace_start)+pretokenized[k].second;
+									if (x.size()&gt;replace_start+replace_len)
+										replace_len += strspn(x.data()+replace_start+replace_len,lang.WhiteSpace+1);
+	
+									x.replace_once(pretokenized[k-1].first,(pretokenized[k].first-pretokenized[k-1].first)+pretokenized[k].second,' ');
+//									continue;
+									}
+								};
+							}
+					while(0&lt;k);
+					};
+				}
+			break;
+			}
+	while(0&lt;j);
+
+	// macro-replace all arguments
+	j = actual_arguments.size();
+	do	if (NULL!=actual_arguments[--j])
+			intradirective_preprocess(*actual_arguments[j],0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack);
+	while(0&lt;j);
+
+	lang.line_lex(x.data(),x.size(),pretokenized);
+	assert(!pretokenized.empty());
+	assert(!detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second));
+	assert(!detect_C_concatenation_op(x.data()+pretokenized.back().first,pretokenized.back().second));
+
+	j = pretokenized.size();
+	do	{
+		--j;
+		const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[j].first,pretokenized[j].second,formal_arguments);
+		if (0&lt;=j2)
+			{
+			assert(NULL!=actual_arguments[j2]);
+			_macro_replace(x,pretokenized[j].first,pretokenized[j].second,actual_arguments[j2]-&gt;data());
+			lang.line_lex(x.data(),x.size(),pretokenized);
+			}
+		else if (detect_C_concatenation_op(x.data()+pretokenized[j].first,pretokenized[j].second))
+			{	// hmm...
+			const errr j3 = linear_find_STL_deref2(x.data()+pretokenized[j-1].first,pretokenized[j-1].second,formal_arguments);
+			if (0&lt;=j3)
+				{	// oops....must do replacement *before* the ## concatenation
+				assert(NULL!=actual_arguments[j3]);
+				assert(!actual_arguments[j3]-&gt;empty());
+				autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt; pretokenized_alt;
+				lang.line_lex(actual_arguments[j3]-&gt;data(),actual_arguments[j3]-&gt;size(),pretokenized_alt);
+				_macro_replace(x,pretokenized[j-1].first,pretokenized[j-1].second,actual_arguments[j3]-&gt;data());
+				lang.line_lex(x.data(),x.size(),pretokenized);
+				j += pretokenized_alt.size()-1;
+				assert(detect_C_concatenation_op(x.data()+pretokenized[j].first,pretokenized[j].second));
+				};
+			if (_concatenate_single(x,pretokenized.data()+(j-1),lang)) --j;
+			}
+		}
+	while(0&lt;j);
+}
+
+static void _complete_string_character_literal_define(Token&lt;char&gt;&amp; x, const Token&lt;char&gt;&amp; src, size_t critical_offset, size_t first_token_len,const char delim, const char* const end_error)
+{
+	if (delim!=x.back())
+		{
+		message_header(src);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(&quot;#define &quot;);
+		INC_INFORM(src.data()+critical_offset,first_token_len);
+		INC_INFORM(&quot; ends in an unterminated&quot;);
+		if ('L'==x.front()) INC_INFORM(&quot; wide&quot;);
+		INFORM(end_error);
+		zcc_errors.inc_error();
+		x.append(delim);
+		}
+}
+
+/*! 
+ * Puts a macro expansion into a standardized form so that strcmp is sufficient to determine equivalence.
+ * 
+ * \param x macro expansion to be normalized in-place
+ * 
+ * \return false if the macro ends in an unterminated (wide?) string/character literal.  [We terminate it here, but the caller should react later on.]
+ */
+void
+CPreprocessor::normalize_macro_expansion(Token&lt;char&gt;&amp; x, const Token&lt;char&gt;&amp; src, size_t critical_offset, size_t first_token_len)
+{
+	if (x.empty()) return;
+	size_t offset = 0;
+	{	//! \test Pass5.hpp
+	const size_t skip_ws = strspn(x.data(),lang.WhiteSpace+1);
+	if (0&lt;skip_ws)
+		{
+		x.ltrim(skip_ws);
+		if (x.empty()) return;
+		}
+	}
+	while(offset&lt;x.size())
+		{
+		lex_flags token_flags;
+		offset += lang.UnfilteredNextToken(x.data()+offset,token_flags);
+		if (x.size()&lt;=offset)
+			{
+			if 		(C_TESTFLAG_STRING_LITERAL==token_flags)
+				//! \test define.C99/Error_unterminated3.hpp, define.C99/Error_unterminated3.h
+				//! \test define.C99/Error_unterminated4.hpp, define.C99/Error_unterminated4.h
+				_complete_string_character_literal_define(x,src,critical_offset,first_token_len,'&quot;',&quot; string literal.  Terminating. (C99 6.4.5p1/C++98 2.13.4)&quot;);
+			else if (C_TESTFLAG_CHAR_LITERAL  ==token_flags)
+				//! \test define.C99/Error_unterminated1.hpp, define.C99/Error_unterminated1.h
+				//! \test define.C99/Error_unterminated2.hpp, define.C99/Error_unterminated2.h
+				_complete_string_character_literal_define(x,src,critical_offset,first_token_len,'\'',&quot; character literal.  Terminating. (C99 6.4.4.4p1/C++98 2.13.2)&quot;);
+			return;
+			}
+		const size_t skip_ws = strspn(x.data()+offset,lang.WhiteSpace+1);
+		if (0&lt;skip_ws)
+			{
+			if (x.size()-offset&lt;=skip_ws)
+				{	//! \test define.C99/Pass_dup5.hpp, define.C99/Pass_dup5.h
+				x.lslice(offset);
+				return;
+				};
+			//! \test define.C99/Pass_dup6.hpp, define.C99/Pass_dup6.h
+			x.replace_once(std::nothrow,offset,skip_ws,' ');
+			++offset;
+			};
+		};
+	return;
+}
+
+void
+CPreprocessor::intradirective_preprocess(Token&lt;char&gt;&amp; x, size_t critical_offset, const autovalarray_ptr&lt;char*&gt;&amp; macros_object, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_object_expansion, const autovalarray_ptr&lt;char*&gt;&amp; macros_function, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_arglist, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_expansion,autovalarray_ptr&lt;char*&gt;* const used_macro_stack)
+{
+	while(x.size()&gt;critical_offset)
+		{
+		const size_t skip_ws = strspn(x.data()+critical_offset,lang.WhiteSpace+1);
+		if (0&lt;skip_ws)
+			{
+			x.replace_once(std::nothrow,critical_offset,skip_ws,' ');
+			++critical_offset;
+			continue;
+			};
+		lex_flags token_flags;
+		const size_t token_len = lang.UnfilteredNextToken(x.data()+critical_offset,token_flags);
+		if (    C_TESTFLAG_IDENTIFIER!=token_flags
+			|| (NULL!=used_macro_stack &amp;&amp; 0&lt;=binary_find(x.data()+critical_offset,token_len,*used_macro_stack))
+			|| (	!predefined_macro_replace_once(x,critical_offset,token_len)
+				&amp;&amp;	!dynamic_macro_replace_once(x,critical_offset,token_len,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack)))
+			{
+			critical_offset += token_len;
+			continue;
+			}
+		};
+}
+
+void
+CPreprocessor::intradirective_flush_identifiers_to_zero(Token&lt;char&gt;&amp; x, size_t critical_offset) const
+{	//! test if.C99/Error_if_control.hpp, if.C99/Error_if_control.h
+	//! test if.C99/Pass_if_control.hpp, if.C99/Pass_if_control.h
+	while(x.size()&gt;critical_offset)
+		{
+		const size_t skip_ws = strspn(x.data()+critical_offset,lang.WhiteSpace+1);
+		if (0&lt;skip_ws)
+			{
+			x.replace_once(std::nothrow,critical_offset,skip_ws,' ');
+			++critical_offset;
+			continue;
+			};
+		lex_flags token_flags;
+		const size_t token_len = lang.UnfilteredNextToken(x.data()+critical_offset,token_flags);
+		if (C_TESTFLAG_IDENTIFIER!=token_flags)
+			{
+			critical_offset += token_len;
+			continue;
+			}
+		_macro_replace(x,critical_offset,token_len,&quot;0&quot;);
+		critical_offset += 1;
+		};
+}
+
+void CPreprocessor::die_on_pp_errors() const
+{
+	if (0&gt;=zcc_errors.err_count()) return;
+	INC_INFORM(&quot;FATAL: &quot;);
+	INC_INFORM(zcc_errors.err_count());
+	INC_INFORM(&quot; preprocessing error&quot;);
+	INFORM((1==zcc_errors.err_count()) ? &quot;\n&quot; : &quot;s\n&quot;);
+	exit(EXIT_FAILURE);
+}
+
+void
+CPreprocessor::debug_to_stderr(const autovalarray_ptr&lt;Token&lt;char&gt;* &gt;&amp; TokenList,const autovalarray_ptr&lt;char*&gt;&amp; macros_object, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_object_expansion, const autovalarray_ptr&lt;char*&gt;&amp; macros_function, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_arglist, const autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_expansion,const autovalarray_ptr&lt;char*&gt;&amp; locked_macros) const
+{
+	// need whitespace tokens here to force pretty-printing
+	if (debug_mode)
+		{
+		const size_t list_size = TokenList.size();
+		size_t i = 0;
+		while(i&lt;list_size)
+			{
+			if (0&lt;i &amp;&amp; TokenList[i-1]-&gt;logical_line.first==TokenList[i]-&gt;logical_line.first &amp;&amp; !strcmp(TokenList[i-1]-&gt;src_filename,TokenList[i]-&gt;src_filename) &amp;&amp; require_padding(TokenList[i-1]-&gt;back(),TokenList[i]-&gt;front()))
+				INC_INFORM(' ');
+
+			if (list_size&lt;=i+1 || TokenList[i]-&gt;logical_line.first!=TokenList[i+1]-&gt;logical_line.first || strcmp(TokenList[i]-&gt;src_filename,TokenList[i+1]-&gt;src_filename))
+				INFORM(TokenList[i]-&gt;data());
+			else
+				INC_INFORM(TokenList[i]-&gt;data());
+			++i;
+			};
+		// dump macros and locked macros
+		INC_INFORM(&quot;#define __DATE__ &quot;);
+		INFORM(date_buffer);
+		INC_INFORM(&quot;#define __TIME__ &quot;);
+		INFORM(time_buffer);
+		INC_INFORM(&quot;#define __TIMESTAMP__ &quot;);
+		INFORM(time_date_buffer);
+		i = 7;
+		while(i&lt;macro_identifier_default_count)
+			{
+			INC_INFORM(&quot;#define &quot;);
+			INC_INFORM(macro_identifier_default[i].first);
+			INC_INFORM(&quot; &quot;);
+			INFORM(macro_identifier_default[i].second);
+			++i;
+			};
+		const size_t object_macro_size = macros_object.size();
+		i = 0;
+		while(i&lt;object_macro_size)
+			{
+			INC_INFORM(&quot;#define &quot;);
+			INC_INFORM(macros_object[i]);
+			if (NULL!=macros_object_expansion[i])
+				{
+				INC_INFORM(&quot; &quot;);
+				INFORM(macros_object_expansion[i]-&gt;data());
+				}
+			else
+				INC_INFORM(&quot;\n&quot;);
+			++i;
+			}
+		const size_t function_macro_size = macros_function.size();
+		i = 0;
+		while(i&lt;function_macro_size)
+			{
+			INC_INFORM(&quot;#define &quot;);
+			INC_INFORM(macros_function[i]);
+			INC_INFORM(macros_function_arglist[i]-&gt;data());
+			if (NULL!=macros_function_expansion[i])
+				{
+				INC_INFORM(&quot; &quot;);
+				INFORM(macros_function_expansion[i]-&gt;data());
+				}
+			else
+				INC_INFORM(&quot;\n&quot;);
+			++i;
+			}
+		const size_t locked_macro_size = locked_macros.size();
+		i = 0;
+		while(i&lt;locked_macro_size)
+			{
+			INC_INFORM(&quot;#pragma ZCC lock &quot;);
+			INFORM(locked_macros[i++]);
+			}
+		};
+}
+
+/*! 
+ * Causes a preprocessing error if the identifier __VA_ARGS__ is found.
+ * 
+ * \param x : token to examine for __VA_ARGS__
+ * \param critical_offset : start point of examination
+ * 
+ * \return bool if and only if an error was found.
+ */
+bool
+CPreprocessor::C99_VA_ARGS_flinch(const Token&lt;char&gt;&amp; x, const size_t critical_offset) const
+{	//! \todo option to bypass this
+	assert(x.size()&gt;critical_offset);
+	if (SIZE_MAX!=lang.lex_find(x.data()+critical_offset,x.size()-critical_offset,&quot;__VA_ARGS__&quot;,sizeof(&quot;__VA_ARGS__&quot;)-1))
+		{
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INFORM(&quot;identifier __VA_ARGS__ not allowed here.  Continuing. (C99 6.10.3p5/C++0x 16.3p5)&quot;);
+		zcc_errors.inc_error();
+		return true;
+		}
+	return false;
+}
+
+void
+CPreprocessor::discard_duplicate_define(autovalarray_ptr&lt;Token&lt;char&gt;* &gt;&amp; TokenList, const size_t i, const size_t critical_offset, const size_t first_token_len)
+{
+	message_header(*TokenList[i]);
+	INC_INFORM(ERR_STR);
+	INC_INFORM(TokenList[i]-&gt;data()+critical_offset,first_token_len);
+	INFORM(&quot; is already #define'd; discarding #define (C99 6.10.3p2/C++98 16.3p2,3)&quot;);
+	TokenList.DeleteIdx(i);
+	zcc_errors.inc_error();
+}
+
+/*! 
+ * Discards leading and trailing ## operators in macro expansion lists; errors but continues.
+ * 
+ * \param x : macro expansion
+ * 
+ * \return bool : true iff truncated to empty
+ */
+bool CPreprocessor::discard_leading_trailing_concatenate_op(Token&lt;char&gt;&amp; x)
+{
+	if ((sizeof(&quot;##&quot;)-1)&gt;x.size()) return false;
+	assert(!strpbrk(x.data(),lang.WhiteSpace+2));	// check for normalization
+	assert(!strchr(x.data(),'\n'));	// check for normalization
+	// tokenize the whole line
+	autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt; pretokenized;
+	lang.line_lex(x.data(),x.size(),pretokenized);
+
+	if (detect_C_concatenation_op(x.data()+pretokenized.back().first,pretokenized.back().second))
+		{
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INFORM(&quot;concatenation operator ## ending a macro replacement list: removing and continuing (C99 6.10.3.3p1/C++98 16.3.3p1)&quot;);
+		zcc_errors.inc_error();
+		if (1==pretokenized.size())
+			{
+			x.reset();
+			return true;
+			}
+		pretokenized.DeleteIdx(pretokenized.size()-1);
+		x.lslice(pretokenized.back().first+pretokenized.back().second);
+		}
+
+	if (detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second))
+		{
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INFORM(&quot;concatenation operator ## starting a macro replacement list: removing and continuing (C99 6.10.3.3p1/C++98 16.3.3p1)&quot;);
+		zcc_errors.inc_error();
+		if (1==pretokenized.size())
+			{
+			x.reset();
+			return true;
+			}
+		x.ltrim(pretokenized[1].first);
+		// XXX leave data structures in an inconsistent state: they'll be immediately destructed anyway
+		}
+	return false;
+}
+
+void
+CPreprocessor::use_line_directive_and_discard(autovalarray_ptr&lt;Token&lt;char&gt;* &gt;&amp; TokenList, const size_t i)
+{
+	assert(i&lt;TokenList.size());
+	assert(NULL!=TokenList[i]);
+	assert(!strncmp(TokenList[i]-&gt;data(),&quot;#line &quot;,sizeof(&quot;#line &quot;)-1));
+	if (TokenList[i]-&gt;flags &amp; INVALID_DIRECTIVE_FLAG)
+		{
+		TokenList.DeleteIdx(i);
+		return;
+		};
+	C_PPDecimalInteger line_number;
+	lex_flags first_token_flags;
+	lex_flags second_token_flags;
+	size_t critical_offset = sizeof(&quot;#line &quot;)-1;
+	// C99: check for decimal integer literal, then optional string literal; error if this is not found
+	{
+	const size_t first_token_len = lang.UnfilteredNextToken(TokenList[i]-&gt;data()+critical_offset,first_token_flags);
+	if (     C_TESTFLAG_PP_NUMERAL!=first_token_flags
+		||	!C_PPDecimalInteger::is(TokenList[i]-&gt;data()+critical_offset,first_token_len,line_number)
+		||	-1==cmp(line_number,&quot;1&quot;,sizeof(&quot;1&quot;)-1)
+		||	 1==cmp(line_number,&quot;2147483647&quot;,sizeof(&quot;2147483647&quot;)-1))	// constant should be stringized 2^31-1
+		{	//! \test cpp/line.C99/Error_badnum1.h, cpp/line.C99/Error_badnum1.hpp
+			//! \test cpp/line.C99/Error_badnum2.h, cpp/line.C99/Error_badnum2.hpp
+			//! \test cpp/line.C99/Error_badnum3.h, cpp/line.C99/Error_badnum3.hpp
+			//! \test cpp/line.C99/Error_badnum4.h, cpp/line.C99/Error_badnum4.hpp
+		message_header(*TokenList[i]);
+		INC_INFORM(ERR_STR);
+		INFORM(&quot;#line does not have a line number between 1 and 2147483647 inclusive (C99 6.10.4p3/C++0x 16.4p3)&quot;);
+		zcc_errors.inc_error();
+		TokenList.DeleteIdx(i);
+		return;
+		};
+	critical_offset += first_token_len;
+	}
+	if (i+1 &lt; TokenList.size())
+		{	//! \test cpp/line.C99/Preprocess_42.h, cpp/line.C99/Preprocess_42.hpp
+			// Behavior is undefined if the syntax is bad (line number with malformed filename string), so don't worry about this happening too early.
+		size_t numeric_line_number;
+		{	// don't worry about failure (pre-validated above), *but* as errno should be a synchronized global we have to lock it anyway
+		OS::scoped_lock tmp(errno_mutex);
+		numeric_line_number = line_number.to_umax();	//! \warning can catastrophically overflow if size_t isn't at least 32-bit
+		};
+		if (TokenList[i]-&gt;logical_line.first!=numeric_line_number)
+			{
+			size_t j = i+1;
+			//! \todo loops should stop at first (valid) #line directive
+			// remember that unsigned arithmetic is modulo
+			const size_t delta = numeric_line_number - TokenList[i]-&gt;logical_line.first;
+			while(j&lt;TokenList.size())
+				TokenList[j++]-&gt;logical_line.first += delta;
+			};
+		}
+
+	if (TokenList[i]-&gt;size()&lt;=critical_offset)
+		{	// just the line number needed updating
+		TokenList.DeleteIdx(i);
+		return;
+		}
+
+	{
+	const size_t skip_ws = strspn(TokenList[i]-&gt;data()+critical_offset,lang.WhiteSpace+1);
+	if (skip_ws&gt;=TokenList[i]-&gt;size()-critical_offset)
+		{	// only trailing whitespace
+		TokenList.DeleteIdx(i);
+		return;
+		}
+	critical_offset += skip_ws;
+	}
+
+	const size_t second_token_len = lang.UnfilteredNextToken(TokenList[i]-&gt;data()+critical_offset,second_token_flags);
+	//! \todo: extension?  C99 spec requires narrow string literals only
+	if (   C_TESTFLAG_STRING_LITERAL!=second_token_flags
+		|| 'L'==TokenList[i]-&gt;data()[critical_offset])
+		{	//! \test cpp/line.C99/Error_badfile1.h, cpp/line.C99/Error_badfile1.hpp
+			//! \test cpp/line.C99/Error_badfile2.h, cpp/line.C99/Error_badfile2.hpp
+		message_header(*TokenList[i]);
+		INC_INFORM(ERR_STR);
+		INFORM(&quot;#line wants a narrow string literal for the new __FILE__ (C99 6.10.4p1/C++98 16.4p1)&quot;);
+		zcc_errors.inc_error();
+		TokenList.DeleteIdx(i);
+		return;
+		}
+
+	if (i+1 &lt; TokenList.size())
+		{	//! \test cpp/line.C99/Preprocess_42.h, cpp/line.C99/Preprocess_42.hpp
+		//! \todo loops should stop at first (valid) #line directive with a filename
+		// unescape the string, if needed
+		const char* new_FILE = NULL;
+		const size_t escape_length = lang.UnescapeStringLength(TokenList[i]-&gt;data()+critical_offset+1,second_token_len-2);
+		if (escape_length&lt;second_token_len-2)
+			{
+			if (0==escape_length)
+				new_FILE = &quot;&quot;;
+			else{
+				autovalarray_ptr_throws&lt;char&gt; tmp(escape_length);
+				lang.UnescapeString(tmp.c_array(),TokenList[i]-&gt;data()+critical_offset+1,second_token_len-2);
+				new_FILE = register_string(tmp.data());
+				}
+			}
+		else
+			new_FILE = register_substring(TokenList[i]-&gt;data()+critical_offset+1,second_token_len-2);
+
+		size_t j = i+1;
+		if (new_FILE!=TokenList[j]-&gt;src_filename)
+			while(j&lt;TokenList.size())
+				TokenList[j++]-&gt;src_filename = new_FILE;
+		}
+
+	TokenList.DeleteIdx(i);
+}
+
+#/*cut-cpp*/
+#/*cut-nocpp*/
+// don't undef these when testing tokenize-flow preprocessing
+#/*cut-nocpp*/
+#/*cut-cpp*/
+#undef ULONG_BIT
+#undef INVALID_DIRECTIVE_FLAG
+
+void
+CPreprocessor::truncate_illegal_tokens(Token&lt;char&gt;&amp; x,const int directive_type,const size_t critical_offset)
+{
+	if (x.size()&lt;=critical_offset) return;
+	if (x.size()-critical_offset&gt;strspn(x.data()+critical_offset,lang.WhiteSpace+1))
+		{
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(&quot;#&quot;);
+		INC_INFORM(valid_directives[directive_type].first);
+		INFORM(&quot; is trailed by illegal preprocessing tokens; discarding them. (C99 6.10p1/C++98 16p1)&quot;);
+		zcc_errors.inc_error();
+		}
+	x.lslice(critical_offset);
+}
+
+bool
+CPreprocessor::hard_locked_macro(const char* const x,const size_t x_len) const
+{
+	assert(x &amp;&amp; *x);
+	assert(0&lt;x_len);
+// C99: 6.11.9 Predefined macro names
+// Macro names beginning with __STDC_ are reserved for future standardization.
+//! \bug should have positive test suite for named __STDC_ macros
+	if (7&lt;=x_len &amp;&amp; !strncmp(x,&quot;__STDC_&quot;,sizeof(&quot;__STDC_&quot;)-1)) return true;
+#/*cut-cpp*/
+// Lock down our relay identifiers. to be safe
+	if (0&lt;=linear_find_lencached(x,x_len,pragma_relay_keywords,STATIC_SIZE(pragma_relay_keywords))) return true;
+#/*cut-cpp*/
+// C++0x 17.4.3.2.2 simply prohibits all keywords as macros; prefer this to C++98.  C99/C0X is handled elsewhere, as it isn't so draconian.
+// follow C++0x when generalizing to non-standard languages, as that's more intuitive.
+	if (Lang::C!=lang_code &amp;&amp; 0&lt;=linear_find_lencached(x,x_len,lang.InvariantKeywords,lang.len_InvariantKeywords)) return true;
+	return 0&lt;=linear_find_lencached(x,x_len,macro_locked_default,macro_locked_default_count);
+}
+
+size_t
+CPreprocessor::function_macro_argument_span(const char* const x) const
+{
+	assert(!is_empty_string(x));
+	if ('('!=x[0]) return 0;
+	const size_t x_len = strlen(x);
+	size_t span = 1;
+	bool identifier_next = true;
+	bool any_identifier = false;
+	bool any_ellipsis = false;
+	while(x_len&gt;span)
+		{
+		if (lang.IsWS_NotFirst(x[span]))
+			{	//! \test define.C99/Error_arglist4.hpp, define.C99/Error_arglist4.h
+				//! \test define.C99/Error_arglist8.hpp, define.C99/Error_arglist8.h
+			span += strspn(x+span,lang.WhiteSpace+1);
+			continue;
+			};
+		if (')'==x[span])
+			{	//! \test define.C99/Error_arglist5.hpp, define.C99/Error_arglist5.h
+			if (!any_identifier || any_ellipsis || !identifier_next) return span+1;
+			INFORM(&quot;) after , in function-like macro argument list.&quot;);
+			return 0;
+			}
+		if (','==x[span])
+			{
+			if (identifier_next)
+				{	//! \test define.C99/Error_arglist6.hpp, define.C99/Error_arglist6.h
+				INFORM(&quot;, when identifier or ... expected in function-like macro argument list.&quot;);
+				return 0;
+				}
+			if (any_ellipsis)
+				{	//! \test define.C99/Error_arglist7.hpp, define.C99/Error_arglist7.h
+				INFORM(&quot;, after ... in function-like macro argument list.&quot;);
+				return 0;
+				}
+			identifier_next = true;
+			++span;
+			continue;
+			}
+
+
+		lex_flags scratch_flags;
+		const size_t token_len = lang.UnfilteredNextToken(x+span,scratch_flags);
+		if (C_TESTFLAG_IDENTIFIER==scratch_flags)
+			{
+			assert(0&lt;token_len);
+			if (identifier_next)
+				{
+				span += token_len;
+				identifier_next = false;
+				any_identifier = true;
+				continue;
+				};
+			//! \test define.C99/Error_arglist8.hpp, define.C99/Error_arglist8.h
+			INC_INFORM(&quot;Missing comma in function-like macro argument list before placeholder &quot;);
+			INC_INFORM(x+span,token_len);
+			INFORM(&quot;.&quot;);
+			return 0;
+			}
+		else if (C_TESTFLAG_NONATOMIC_PP_OP_PUNC==scratch_flags &amp;&amp; 3==token_len &amp;&amp; !strncmp(x+span,&quot;...&quot;,3))
+			{
+			if (identifier_next)
+				{	//! \test define.C99/Pass_arglist.hpp, define.C99/Pass_arglist.h
+				span += token_len;
+				identifier_next = false;
+				any_ellipsis = true;
+				continue;
+				};
+			//! \test define.C99/Error_arglist3.hpp, define.C99/Error_arglist3.h
+			//! \test define.C99/Error_arglist4.hpp, define.C99/Error_arglist4.h
+			INFORM(&quot;Missing comma in function-like macro argument list before ...&quot;);
+			return 0;
+			};
+		//! \test define.C99/Error_arglist2.hpp, define.C99/Error_arglist2.h
+		INC_INFORM(&quot;Unexpected token &quot;);
+		INC_INFORM(x+span,token_len);
+		INFORM(&quot; in function-like macro argument list.&quot;);
+		return 0;
+		};
+	//! \test define.C99/Error_arglist1.hpp, define.C99/Error_arglist1.h
+	return 0;
+}
+
+size_t
+CPreprocessor::defined_span(const Token&lt;char&gt;&amp; x, const size_t logical_offset, POD_pair&lt;size_t,size_t&gt;&amp; identifier)
+{	//! \todo more verbose error reporting
+	assert(!strncmp(x.data()+logical_offset,&quot;defined&quot;,(sizeof(&quot;defined&quot;)-1)));
+	size_t offset = logical_offset;
+	offset += (sizeof(&quot;defined&quot;)-1);
+	if (x.size()&lt;=offset) return 0;
+	const size_t skip_ws = strspn(x.data()+offset,lang.WhiteSpace+1);
+	offset += skip_ws;
+	if (x.size()&lt;=offset) return 0;
+	const bool paren_delimited = ('('==x.data()[offset]);
+	if (paren_delimited)
+		{
+		if (x.size()&lt;= ++offset) return 0;
+		}
+	else if (0==skip_ws)
+		return 0;
+
+	lex_flags scratch_flags;
+	const size_t token_len = lang.UnfilteredNextToken(x.data()+offset,scratch_flags);
+	if (C_TESTFLAG_IDENTIFIER!=scratch_flags) return 0;
+	identifier.first = offset;
+	identifier.second = token_len;
+	offset += token_len;
+	if (x.size()&lt;=offset) return 0;
+	if (!paren_delimited) return offset-logical_offset;
+	offset += strspn(x.data()+offset,lang.WhiteSpace+1);
+	if (x.size()&lt;=offset) return 0;
+	if (')'==x.data()[offset]) return (offset-logical_offset)+1;
+	return 0;
+}
+
+/*! 
+ * test whether two characters will glue two non-whitespace preprocessing tokens into one.
+ * This can tolerate false positives, but not false negatives.
+ * 
+ * \param lhs: left-hand character
+ * \param rhs: right-hand character
+ * 
+ * \return bool true iff they will glue tokens
+ */
+bool CPreprocessor::require_padding(char lhs, char rhs) const
+{
+	if (strchr(lang.WhiteSpace+1,lhs)) return false;	// whitespace is fine
+	if (strchr(lang.WhiteSpace+1,rhs)) return false;
+	if (strchr(lang.AtomicSymbols,lhs)) return false;	// atomic characters are fine
+	if (strchr(lang.AtomicSymbols,rhs)) return false;
+	if ('\''==lhs || '&quot;'==lhs) return false;	// string/character literals are fine
+	if ('\''==rhs || '&quot;'==rhs) return false;
+	// word-chars glue to word-chars
+	// symbol-chars glue to symbol-chars
+	// universal-char-names will glue as well as normal word-chars
+	if (lang.IsWordChar(lhs))
+		{
+		if ('\\'==rhs || lang.IsWordChar(rhs)) return true;
+		return false;
+		};
+	return !lang.IsWordChar(rhs);
+}
+
+/*! 
+ * Checks that a string has no identifiers within it.  That means no macro replacement can happen within it.
+ *
+ * \pre lang uses C_TESTFLAG_IDENTIFIER to indicate an identifier was lexed
+ * 
+ * \param x : string to be checked for identifiers
+ * 
+ * \return bool : true iff there are no identifiers within the string.
+ */
+bool
+CPreprocessor::nonrecursive_macro_replacement_list(const char* const x) const
+{
+	if (is_empty_string(x)) return true;
+	const size_t x_len = strlen(x);
+	size_t offset = 0;
+	lex_flags scratch_flags;
+	while(x_len&gt;offset)
+		{
+		const size_t token_len = lang.UnfilteredNextToken(x+offset,scratch_flags);
+		if (C_TESTFLAG_IDENTIFIER==scratch_flags) return false;
+		offset += token_len;
+		};
+	return true;
+}
+
+/*! 
+ * Calculates whether a function macro invocation completely fits on the given string.
+ * 
+ * \param src		string to examine for argument list
+ * \param src_span	length of string
+ * \param arg_count	if return value non-zero, actual number of arguments found.
+ * 
+ * \return size_t	length of macro invocation argument list
+ */
+size_t
+CPreprocessor::function_macro_invocation_argspan(const char* const src,const size_t src_span,size_t&amp; arg_count) const
+{
+	assert(!is_empty_string(src));
+	assert('('==src[0]);
+	assert(src_span==strlen(src));
+	if (2&gt;src_span) return 0;
+	if (')'==src[1])
+		{
+		arg_count = 0;
+		return 2;
+		}
+	lex_flags scratch_flags;
+	size_t test_arg_count = 1;
+	size_t paren_depth = 1;
+	size_t i = 1;
+	do	{
+		if ('('==src[i]) ++paren_depth;
+		else if (')'==src[i])
+			{
+			if (0== --paren_depth)
+				{
+				arg_count = test_arg_count;
+				return i+1;
+				};
+			}
+		else if (','==src[i])
+			{
+			if (1==paren_depth) ++test_arg_count;
+			}
+		else{
+			const size_t token_len = lang.UnfilteredNextToken(src+i,scratch_flags);
+			assert(0&lt;token_len);
+			i += (token_len-1);
+			}
+		}
+	while(src_span &gt; ++i);
+	return 0;
+}
+
+/*! 
+ * implements C preprocessor stringize operator.
+ * 
+ * \param dest valid C string representing src (postcondition)
+ * \param src to be stringized
+ */
+void
+CPreprocessor::stringize(autovalarray_ptr&lt;char&gt;&amp; dest,const Token&lt;char&gt;* const &amp; src)
+{
+	if (NULL==src || src-&gt;empty())
+		{	// empty string
+		dest.resize(2);
+		strcpy(dest.c_array(),&quot;\&quot;\&quot;&quot;);
+		return;
+		}
+	
+	dest.resize(2+lang.EscapeStringLength(src-&gt;data(),src-&gt;size()));
+	dest.front()='&quot;';
+	dest.back()='&quot;';
+
+	lang.EscapeString(dest.c_array()+1,src-&gt;data(),src-&gt;size());
+}
+
+/*! 
+ * errors and removes clearly bad stringize operators
+ * 
+ * \param x : macro replacement list to verify
+ * 
+ * \return bool true if macro was emptied (caller should complete the cleanup)
+ */
+bool
+CPreprocessor::flush_bad_stringize(Token&lt;char&gt;&amp; x, const Token&lt;char&gt;&amp; arglist)
+{
+	autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt; pretokenized;
+	if (lang.line_lex_find(x.data(),x.size(),&quot;#&quot;,sizeof(&quot;#&quot;)-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),&quot;%:&quot;,sizeof(&quot;%:&quot;)-1,pretokenized))
+		{
+		size_t i = 0;
+		bool created_ws = false;
+		while(pretokenized.size()-1&gt;i)
+			{
+			if (detect_C_stringize_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+				{
+				if (pretokenized[i].first+pretokenized[i].second!=pretokenized[i+1].first)
+					{	//! \test define.C99/Error_stringize2.hpp, define.C99/Error_stringize2.h
+					message_header(x);
+					INC_INFORM(ERR_STR);
+					INFORM(&quot;# followed by whitespace; excising and continuing (C99 6.10.3.2p1/C++98 16.3.2p1)&quot;);
+					zcc_errors.inc_error();
+					memset(x.c_array()+pretokenized[i].first,' ',pretokenized[i].second);
+					pretokenized.DeleteIdx(i);
+					created_ws = true;
+					continue;
+					}
+				if (   C_TESTFLAG_IDENTIFIER!=pretokenized[i+1].third
+					|| SIZE_MAX==lang.lex_find(arglist.data(),arglist.size(),x.data()+pretokenized[i+1].first,pretokenized[i+1].second))
+					{	//! \test define.C99/Error_stringize3.hpp, define.C99/Error_stringize3.h
+					message_header(x);
+					INC_INFORM(ERR_STR);
+					INFORM(&quot;# not followed by macro parameter; excising and continuing (C99 6.10.3.2p1/C++98 16.3.2p1)&quot;);
+					zcc_errors.inc_error();
+					memset(x.c_array()+pretokenized[i].first,' ',pretokenized[i].second);
+					pretokenized.DeleteIdx(i);
+					created_ws = true;
+					continue;
+					}
+				}
+			++i;
+			}
+
+		if (detect_C_stringize_op(x.data()+pretokenized.back().first,pretokenized.back().second))
+			{	//! \test define.C99/Error_stringize1.hpp, define.C99/Error_stringize1.h
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INFORM(&quot;# terminates macro replacement list; truncating and continuing (C99 6.10.3.2p1/C++98 16.3.2p1)&quot;);
+			zcc_errors.inc_error();
+			if (1==pretokenized.size())
+				{
+				x.reset();
+				return true;
+				};
+			pretokenized.DeleteIdx(pretokenized.size()-1);
+			};
+		remove_ws_from_token(x,pretokenized);
+		}
+	return false;
+}
+
+void
+CPreprocessor::object_macro_concatenate(Token&lt;char&gt;&amp; x)
+{	//! \pre: x is normalized
+	//! \test cpp/default/Preprocess_macro_novar_concatenate.hpp, cpp/default/Preprocess_macro_novar_concatenate.h
+	if (4&gt;x.size()) return;
+	assert(!strpbrk(x.data(),lang.WhiteSpace+2));	// check for normalization
+	assert(!strchr(x.data(),'\n'));					// check for normalization
+	autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt; pretokenized;
+	if (lang.line_lex_find(x.data(),x.size(),&quot;##&quot;,sizeof(&quot;##&quot;)-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),&quot;%:%:&quot;,sizeof(&quot;%:%:&quot;)-1,pretokenized))
+		{
+		assert(!pretokenized.empty());
+		assert(!detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second));
+		assert(!detect_C_concatenation_op(x.data()+pretokenized.back().first, pretokenized.back().second));
+		size_t i = pretokenized.size();
+		do	{
+			--i;
+			if (detect_C_concatenation_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+				{
+				assert(0&lt;i &amp;&amp; pretokenized.size()-1&gt;i);
+				if (_concatenate_single(x,pretokenized.data()+(i-1),lang)) --i;
+				}
+			}
+		while(0&lt;i);
+		}
+}
+
+void
+CPreprocessor::function_macro_concatenate_novars(Token&lt;char&gt;&amp; x, const Token&lt;char&gt;&amp; arglist)
+{	//! \pre: x is normalized
+	//! \test cpp/default/Preprocess_macro_novar_concatenate.hpp, cpp/default/Preprocess_macro_novar_concatenate.h
+	if (4&gt;x.size()) return;
+	assert(!strpbrk(x.data(),lang.WhiteSpace+2));	// check for normalization
+	assert(!strchr(x.data(),'\n'));	// check for normalization
+	autovalarray_ptr&lt;POD_triple&lt;size_t,size_t,lex_flags&gt; &gt; pretokenized;
+	if (lang.line_lex_find(x.data(),x.size(),&quot;##&quot;,sizeof(&quot;##&quot;)-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),&quot;%:%:&quot;,sizeof(&quot;%:%:&quot;)-1,pretokenized))
+		{
+		assert(!pretokenized.empty());
+		assert(!detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second));
+		assert(!detect_C_concatenation_op(x.data()+pretokenized.back().first, pretokenized.back().second));
+		size_t i = pretokenized.size();
+		do	{
+			--i;
+			if (detect_C_concatenation_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+				{
+				assert(0&lt;i &amp;&amp; pretokenized.size()-1&gt;i);
+				const bool before_token_is_parameter = (C_TESTFLAG_IDENTIFIER==pretokenized[i-1].third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x.data()+pretokenized[i-1].first,pretokenized[i-1].second) : false;
+
+				if (detect_C_stringize_op(x.data()+pretokenized[i+1].first,pretokenized[i+1].second))
+					{
+					message_header(x);
+					INFORM(&quot;warning: order of evaluation of # and ## operators is undefined; evaluating # first (C99 6.10.3.2p2/C++98 16.3.2p2)&quot;);
+					message_header(x);
+					// would like these to be errors, but C99 requires accepting
+					if (   !before_token_is_parameter						// not a parameter at all
+						|| (1U&lt;=pretokenized[i-1].first &amp;&amp; '#'==x.data()[pretokenized[i-1].first-1])
+						|| (2U&lt;=pretokenized[i-1].first &amp;&amp; '%'==x.data()[pretokenized[i-1].first-2] &amp;&amp; ':'==x.data()[pretokenized[i-1].first-1]))	// stringized parameter
+						{	//! \test Warn_autofail_concatenation1.hpp
+							//! \test default.nonconforming/Error_autofail_concatenation1.hpp
+							//! \test Warn_autofail_concatenation2.hpp
+							//! \test default.nonconforming/Error_autofail_concatenation2.hpp
+						INC_INFORM((bool_options[boolopt::pedantic]) ? WARN_STR : ERR_STR);
+						INC_INFORM(&quot;concatenation automatically fails at macro invocation.&quot;);
+						}
+					else{	//! \test Warn_empty_parameter_concatenation1.hpp
+							//! \test default.nonconforming/Error_empty_parameter_concatenation1.hpp
+						INC_INFORM((bool_options[boolopt::pedantic]) ? WARN_STR : ERR_STR);
+						INC_INFORM(&quot;concatenation fails at macro invocation if parameter &quot;);
+						INC_INFORM(x.data()+pretokenized[i-1].first,pretokenized[i-1].second);
+						INC_INFORM(&quot; is not empty.&quot;);
+						}
+					INFORM((bool_options[boolopt::pedantic]) ? &quot;&quot; : &quot; (ZCPP nonconforming pragmatism)&quot;);
+					// defer to here so we get the full messages out
+					if (bool_options[boolopt::warnings_are_errors]) zcc_errors.inc_error();										// for order-of-evaluation
+					if (bool_options[boolopt::warnings_are_errors] || !bool_options[boolopt::pedantic]) zcc_errors.inc_error();	// for wonky concatenation
+					continue;
+					}
+
+				// will not be be able to complete concatenation against a parameter, bail
+				// accept some inefficiency in a weird case to avoid code duplication
+				const bool after_token_is_parameter = (C_TESTFLAG_IDENTIFIER==pretokenized[i+1].third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x.data()+pretokenized[i+1].first,pretokenized[i+1].second) : false;
+
+				// Of course, C/C++ can't concatenate a string with anything except an empty parameter.
+				if (before_token_is_parameter)
+					{
+					if (	(1U&lt;=pretokenized[i-1].first &amp;&amp; '#'==x.data()[pretokenized[i-1].first-1])
+						|| 	(2U&lt;=pretokenized[i-1].first &amp;&amp; '%'==x.data()[pretokenized[i-1].first-2] &amp;&amp; ':'==x.data()[pretokenized[i-1].first-1]))
+						{	// stringized parameter
+						message_header(x);
+						INFORM(&quot;warning: order of evaluation of # and ## operators is undefined; evaluating # first (C99 6.10.3.2p2/C++98 16.3.2p2)&quot;);
+						message_header(x);
+						INC_INFORM((bool_options[boolopt::pedantic]) ? WARN_STR : ERR_STR);
+						if (after_token_is_parameter)
+							{	//! \test Warn_autofail_concatenation3.hpp
+								//! \test default.nonconforming/Error_autofail_concatenation3.hpp
+							INC_INFORM(&quot;concatenation fails at macro invocation if parameter &quot;);
+							INC_INFORM(x.data()+pretokenized[i+1].first,pretokenized[i+1].second);
+							INC_INFORM(&quot; is not empty.&quot;);
+							}
+						else	//! \test Warn_empty_parameter_concatenation2.hpp
+								//! \test default.nonconforming/Error_empty_parameter_concatenation2.hpp
+							INC_INFORM(&quot;concatenation automatically fails at macro invocation.&quot;);
+						INFORM((bool_options[boolopt::pedantic]) ? &quot;&quot; : &quot; (ZCPP nonconforming pragmatism)&quot;);
+						// defer to here so we get the full messages out
+						if (bool_options[boolopt::warnings_are_errors]) zcc_errors.inc_error();										// for order-of-evaluation
+						if (bool_options[boolopt::warnings_are_errors] || !bool_options[boolopt::pedantic]) zcc_errors.inc_error();	// for wonky concatenation
+						};
+					// will not be be able to complete concatenation against a parameter, bail
+					continue;
+					}
+
+				// will not be be able to complete concatenation against a parameter, bail
+				if (after_token_is_parameter) continue;
+
+				if (_concatenate_single(x,pretokenized.data()+(i-1),lang)) --i;
+				}
+			}
+		while(0&lt;i);
+		}
+}
+
+/*
+ * analyzing constant expressions that can actually make it to a control expression (we have to be self-contained)
+ ** no identifiers make it
+ ** possible primary constants
+ *** constant
+ *** string-literal (must allow for token-combination)
+ *** (expression)
+ ** no post-fix operators are valid: [] () . -&gt; postfix ++ postfix --
+ *** well...since a string-literal is a char array [] would be valid on a string.... (and then we have to deal with code points)
+ ** allowed unary operators: + - ~ ! (note that required integral type is one of the target's intmax_t or uintmax_t); this includes interpreting character constants.
+ *** disallowed: prefix ++ prefix -- &amp; * sizeof
+ *** sizeof won't survive identifier zeroing
+ *** * on a string-literal should dereference to a character, so allow &amp;* cancellation on string literals
+ *** allow *&amp; cancellation always?
+ ** no cast operators allowed
+ ** allowed multiplicative operators: * / %
+ ** allowed additive operators: + -
+ ** allowed bitwise shift operators: &lt;&lt; &gt;&gt;
+ ** allowed relational operators: &lt; &gt; &lt;= &gt;=
+ ** allowed equality operators: == !=
+ ** bitwise and operator: &amp;
+ ** bitwise exclusive or: ^
+ ** bitwise inclusive or: |
+ ** logical and: &amp;&amp;
+ ** logical or: ||
+ ** conditional operator: ? :
+ ** no assignment operators allowed
+ ** comma operator: , (although probably not incredibly useful...)
+
+ Since we need intmax_t and uintmax_t anyway to do this right: perhaps limits.h should be a virtual header generated from a target_info object
+ automatic header also could handle the &quot;no keywords defined when including a system header&quot;, but there probably is a more elegant way to do this
+
+ Also: C99 7.1.2p4 prohibits all keywords from having macro definitions at the time of including the standard headers
+&lt;assert.h&gt;
+&lt;complex.h&gt;
+&lt;ctype.h&gt;
+&lt;errno.h&gt;
+&lt;fenv.h&gt;
+&lt;float.h&gt;
+&lt;inttypes.h&gt;
+&lt;iso646.h&gt;
+&lt;limits.h&gt;
+&lt;locale.h&gt;
+&lt;math.h&gt;
+&lt;setjmp.h&gt;
+&lt;signal.h&gt;
+&lt;stdarg.h&gt;
+&lt;stdbool.h&gt;
+&lt;stddef.h&gt;
+&lt;stdint.h&gt;
+&lt;stdio.h&gt;
+&lt;stdlib.h&gt;
+&lt;string.h&gt;
+&lt;tgmath.h&gt;
+&lt;time.h&gt;
+&lt;wchar.h&gt;
+&lt;wctype.h&gt;
+
+C++98 17.3.3.1.1p2 goes further and prohibits defining macros for any names declared or defined in a library header.
+&lt;algorithm&gt; &lt;iomanip&gt; &lt;list&gt; &lt;ostream&gt; &lt;streambuf&gt;
+&lt;bitset&gt; &lt;ios&gt; &lt;locale&gt; &lt;queue&gt; &lt;string&gt;
+&lt;complex&gt; &lt;iosfwd&gt; &lt;map&gt; &lt;set&gt; &lt;typeinfo&gt;
+&lt;deque&gt; &lt;iostream&gt; &lt;memory&gt; &lt;sstream&gt; &lt;utility&gt;
+&lt;exception&gt; &lt;istream&gt; &lt;new&gt; &lt;stack&gt; &lt;valarray&gt;
+&lt;fstream&gt; &lt;iterator&gt; &lt;numeric&gt; &lt;stdexcept&gt; &lt;vector&gt;
+&lt;functional&gt; &lt;limits&gt;
+
+&lt;cassert&gt; &lt;ciso646&gt; &lt;csetjmp&gt; &lt;cstdio&gt; &lt;ctime&gt;
+&lt;cctype&gt; &lt;climits&gt; &lt;csignal&gt; &lt;cstdlib&gt; &lt;cwchar&gt;
+&lt;cerrno&gt; &lt;clocale&gt; &lt;cstdarg&gt; &lt;cstring&gt; &lt;cwctype&gt;
+&lt;cfloat&gt; &lt;cmath&gt; &lt;cstddef&gt;
+
+C++98 17.3.3.1.1p1 prohibits undefining any macro defined in a library header (watch out for assert.h)
+C99 7.1.3p1,3 prohibit defining macros for any identifier declared in a library header
+ */
+#/*cut-cpp*/
+#/*cut-nocpp*/
+#if 0
+void
+CPreprocessor::_preprocess_alt(autovalarray_ptr&lt;Token&lt;char&gt;* &gt;&amp; TokenList, autovalarray_ptr&lt;char*&gt;&amp; locked_macros, autovalarray_ptr&lt;char*&gt;&amp; macros_object, autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_object_expansion, autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_object_expansion_pre_eval, autovalarray_ptr&lt;char*&gt;&amp; macros_function, autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_arglist, autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_expansion, autovalarray_ptr&lt;Token&lt;char&gt;*&gt;&amp; macros_function_expansion_pre_eval, autovalarray_ptr&lt;POD_triple&lt;const char*, const char*,uintptr_t&gt; &gt;&amp; include_file_index, autovalarray_ptr&lt;POD_pair&lt;const char*,autovalarray_ptr&lt;Token&lt;char&gt;*&gt;* &gt; &gt;&amp; include_file_cache, const type_system&amp; min_types)
+{
+	TokenList.MoveInto(inbound_lines);
+Restart:
+	INFORM(&quot;===&quot;);
+	INFORM(inbound_lines.size());
+	INFORM(outbound_tokens.size());
+	size_t i = 0;
+	if (inbound_lines.empty())
+		{
+		outbound_tokens.MoveInto(TokenList);
+		return;
+		}
+	size_t if_depth = 0;
+	size_t if_where = 0;			// origin 0
+	size_t else_where = 0;			// origin 1; 0 is not triggered
+	size_t include_where = 0;		// origin 1; 0 is not triggered
+	size_t restart_full_scan = 0;	// origin 1; 0 is not triggered
+	do	{
+		if (line_is_preprocessing_directive(*inbound_lines[i]))
+			{	// directive
+			{	// scoping brace
+			const size_t token_size = inbound_lines[i]-&gt;size();
+			if (1==token_size)
+				{
+				inbound_lines.DeleteIdx(i);	// Null directive #, delete
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+			const size_t whitespace_size = strspn(inbound_lines[i]-&gt;data()+1,lang.WhiteSpace+1);
+			if (token_size-1 == whitespace_size)
+				{
+				inbound_lines.DeleteIdx(i);	// Null directive #, delete
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+
+			inbound_lines[i]-&gt;flags |= PREPROCESSING_DIRECTIVE_FLAG;
+			if (0&lt;whitespace_size)
+				{	// normalize
+				inbound_lines[i]-&gt;c_array()[whitespace_size] = '#';
+				inbound_lines[i]-&gt;ltrim(whitespace_size);
+				assert(!inbound_lines[i]-&gt;empty());
+				assert('#'==inbound_lines[i]-&gt;front());
+				};
+			}	// end scoping brace
+			const errr directive_type = find_directive(inbound_lines[i]-&gt;data()+1,lang);
+			if (0&gt;directive_type &amp;&amp; 0==if_depth)
+				{	//! \test Warn_unrecognized_directive.hpp : naked unrecognized directive
+				message_header(*inbound_lines[i]);
+				INC_INFORM(&quot;warning: unrecognized preprocessing directive '&quot;);
+				size_t j = 0;
+				while(++j&lt;inbound_lines[i]-&gt;size() &amp;&amp; !lang.IsWS_NotFirst(inbound_lines[i]-&gt;data()[j]))
+					INC_INFORM(inbound_lines[i]-&gt;data()[j]);
+				INFORM(&quot;' (C99 6.10p1/C++98 16.1p1)&quot;);
+				if (bool_options[boolopt::warnings_are_errors]) zcc_errors.inc_error();
+				inbound_lines.DeleteIdx(i);
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+
+			// stripping trailing spaces damages incomplete string and character literals.
+			switch(directive_type)
+			{
+			case PP::IF:		
+			case PP::IFDEF:		
+			case PP::IFNDEF:	
+			case PP::ELIF:		
+			case PP::ELSE:		
+			case PP::ENDIF:		
+			case PP::INCLUDE:	
+			case PP::DEFINE:	
+			case PP::UNDEF:		
+			case PP::LINE:		
+			case PP::ERROR:		
+			case PP::PRAGMA:	{	// normalize the whitespace; allowed to shove directive left to do it
+								size_t critical_offset = valid_directives[directive_type].second+1;
+								if (inbound_lines[i]-&gt;size()&gt;critical_offset)
+									{
+									const size_t intra_WS = strspn(inbound_lines[i]-&gt;data()+critical_offset,lang.WhiteSpace+1);
+									if (0==intra_WS)
+										//! \todo really should be a bit more clever about this
+										inbound_lines[i]-&gt;replace_once(critical_offset,0,' ');
+									else if (inbound_lines[i]-&gt;size()-critical_offset&lt;=intra_WS)
+										{
+										if (PP::PRAGMA==directive_type)
+											{
+											inbound_lines.DeleteIdx(i);	// empty pragma is legal, but Z.C++ says it has no effect
+											if (0==i) goto Restart;
+											--i;
+											continue;
+											};
+										inbound_lines[i]-&gt;rtrim(intra_WS);
+										}
+									else if (1&lt;intra_WS)
+										inbound_lines[i]-&gt;replace_once(std::nothrow,critical_offset,intra_WS,' ');
+									else
+										inbound_lines[i]-&gt;c_array()[critical_offset] = ' ';
+									}
+								PACK_DIRECTIVE(inbound_lines[i]-&gt;flags,directive_type);
+								assert(inbound_lines[i]-&gt;size()&gt;=valid_directives[directive_type].second+1);
+								break;
+								};
+			default:			{	// Unrecognized.  Warn-and-delete when we know it's going to be executed (not within any conditional blocks.
+								PACK_DIRECTIVE(inbound_lines[i]-&gt;flags,PP_INVALID);
+								break;
+								};
+			};
+
+			// #if nesting-depth 0 processing
+			if (0==if_depth)
+				{
+				lex_flags first_token_flags = 0;
+				size_t first_token_len = 0;
+				if (PP::ERROR==directive_type)
+					{	// an error by fiat
+						//! \test cpp/Error_error_directive.hpp
+						//! \test cpp/Error_error_directive2.hpp
+					message_header(*inbound_lines[i]);
+					INC_INFORM(ERR_STR);
+					INFORM(inbound_lines[i]-&gt;data()+(sizeof(&quot;#error &quot;)-1));
+					inbound_lines.DeleteIdx(i);
+					zcc_errors.inc_error();
+					if (0==i) goto Restart;
+					--i;
+					continue;
+					};
+				if (   PP::ELSE ==directive_type
+					|| PP::ELIF ==directive_type
+					|| PP::ENDIF==directive_type)
+					{	// no prior #if/#ifdef/#ifndef is an error
+					//! \test Error_naked_else.hpp : #else without #if/#ifdef/#ifndef
+					//! \test Error_naked_elif.hpp : #elif without #if/#ifdef/#ifndef
+					//! \test Error_naked_endif.hpp : #endif without #if/#ifdef/#ifndef
+					//! \test Error_elif_after_else.hpp : #elif after #else
+					//! \test Error_else_after_else.hpp : #else after #else
+					message_header(*inbound_lines[i]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM(&quot;#&quot;);
+					INC_INFORM(valid_directives[directive_type].first);
+					INFORM(&quot; without paired #if/#ifdef/#ifndef (C99 6.10p1/C++98 16.1p1)&quot;);
+					inbound_lines.DeleteIdx(i);
+					zcc_errors.inc_error();
+					if (0==i) goto Restart;
+					--i;
+					continue;
+					};
+				if (   PP::DEFINE ==directive_type
+					|| PP::UNDEF  ==directive_type
+					|| PP::INCLUDE==directive_type
+					|| PP::LINE   ==directive_type)
+					{	// these must have preprocessing tokens to be meaningful
+					//! \test Error_no_token_define.hpp : #define no tokens
+					//! \test Error_no_token_undef.hpp : #undef no tokens
+					//! \test Error_no_token_include.hpp : #include no tokens
+					//! \test Error_no_token_line.hpp : #line no tokens
+					if (inbound_lines[i]-&gt;size()==valid_directives[directive_type].second+1)
+						{
+						message_header(*inbound_lines[i]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM(&quot;#&quot;);
+						INC_INFORM(valid_directives[directive_type].first);
+						INFORM(&quot; must have preprocessing tokens afterwards (allowing for macro substitution); discarding. (C99 6.10p1/C++98 16.1p1)&quot;);
+						inbound_lines.DeleteIdx(i);
+						zcc_errors.inc_error();
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					}
+				if (   PP::DEFINE ==directive_type
+					|| PP::UNDEF  ==directive_type)
+					{	// do basic legality checks now: C identifier, not locked
+					const size_t critical_offset = valid_directives[directive_type].second+2;
+					if (inbound_lines[i]-&gt;size()&gt;critical_offset) first_token_len = lang.UnfilteredNextToken(inbound_lines[i]-&gt;data()+critical_offset,first_token_flags);
+					if (C_TESTFLAG_IDENTIFIER!=first_token_flags)
+						{	//! \test Error_undef_no_identifier.hpp : #undef without identifier
+						message_header(*inbound_lines[i]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM(&quot;#&quot;);
+						INC_INFORM(valid_directives[directive_type].first);
+						INFORM(&quot; does not have an identifier afterwards; discarding. (C99 6.10p1/C++98 16.1p1)&quot;);
+						inbound_lines.DeleteIdx(i);
+						zcc_errors.inc_error();
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+
+					// want to catch illegal tokens before ditching a #undef of a locked macro
+					//! \test Error_undef_illegal_tokens.hpp : #undef illegal tokens
+					if (PP::UNDEF==directive_type) truncate_illegal_tokens(*inbound_lines[i],directive_type,critical_offset+first_token_len);
+
+					if (hard_locked_macro(inbound_lines[i]-&gt;data()+critical_offset,first_token_len))
+						{	//! \test Error_undef_STDC.hpp : #undef __STDC__
+						discard_locked_macro(inbound_lines,i,directive_type,first_token_len);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					if (	0==include_where &amp;&amp; 0==restart_full_scan
+						&amp;&amp;	pragma_locked_macro(inbound_lines[i]-&gt;data()+critical_offset,first_token_len,locked_macros))
+						{	// here so we don't recalculate the above
+						//! \test cpp/Error_undef_locked_macro.hpp
+						discard_locked_macro(inbound_lines,i,directive_type,first_token_len);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					if (PP::DEFINE==directive_type &amp;&amp; inbound_lines[i]-&gt;size()&gt;critical_offset+first_token_len)
+						{	// standardize silently
+						const size_t intra_WS = strspn(inbound_lines[i]-&gt;data()+critical_offset+first_token_len,lang.WhiteSpace+1);
+						if (inbound_lines[i]-&gt;size()-(critical_offset+first_token_len)&lt;=intra_WS)
+							inbound_lines[i]-&gt;rtrim(intra_WS);	// normalize -- null-def object-like macro
+						else if (1&lt;intra_WS)
+							inbound_lines[i]-&gt;replace_once(std::nothrow,critical_offset+first_token_len,intra_WS,' ');
+						}
+					};
+				if (PP::PRAGMA==directive_type)
+					{
+					const size_t critical_offset = valid_directives[directive_type].second+2;
+					assert(inbound_lines[i]-&gt;size()&gt;critical_offset);
+					if (C99_VA_ARGS_flinch(*inbound_lines[i],sizeof(&quot;pragma &quot;)-1))
+						{	//! \test Error_pragma_VA_ARGS.hpp
+						message_header(*inbound_lines[i]);
+						INFORM(&quot;discarding pragma&quot;);
+						inbound_lines.DeleteIdx(i);	// ignore the pragma
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					first_token_len = lang.UnfilteredNextToken(inbound_lines[i]-&gt;data()+critical_offset,first_token_flags);
+					if (0&gt;linear_find_lencached(inbound_lines[i]-&gt;data()+critical_offset, first_token_len, accept_pragma_leading_tokens, STATIC_SIZE(accept_pragma_leading_tokens)))
+						{
+						inbound_lines.DeleteIdx(i);	// ignore the pragma
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					}
+				if (PP::INCLUDE==directive_type &amp;&amp; 0==include_where)
+					{	// we have an include; postpone inclusion
+						// don't think memory conservation is ISO
+					if (0==restart_full_scan)
+						intradirective_preprocess(*inbound_lines[i], sizeof(&quot;#include &quot;)-1,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval);
+					include_where = i+1;
+					};
+				if (0==include_where &amp;&amp; 0==restart_full_scan)
+					{
+					if (PP::LINE==directive_type)
+						{
+						if (C99_VA_ARGS_flinch(*inbound_lines[i],sizeof(&quot;#line &quot;)-1))
+							{	//! \test cpp/line.C99/Error_VA_ARGS.h, cpp/line.C99/Error_VA_ARGS.hpp
+							message_header(*inbound_lines[i]);
+							INFORM(&quot;discarding #line directive&quot;);
+							inbound_lines.DeleteIdx(i);
+							if (0==i) goto Restart;
+							--i;
+							continue;
+							};
+
+						intradirective_preprocess(*inbound_lines[i], sizeof(&quot;#line &quot;)-1,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval);
+						use_line_directive_and_discard(inbound_lines,i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					if (PP::UNDEF==directive_type)
+						{
+						const size_t critical_offset = valid_directives[directive_type].second+2;
+						assert(0&lt;first_token_len);
+						assert(inbound_lines[i]-&gt;size()&gt;=critical_offset+first_token_len);
+						// apply undef
+						const errr object_macro_index = binary_find(inbound_lines[i]-&gt;data()+critical_offset,first_token_len,macros_object);
+						const errr function_macro_index = binary_find(inbound_lines[i]-&gt;data()+critical_offset,first_token_len,macros_function);
+						assert(0&gt;object_macro_index || 0&gt;function_macro_index);
+						if (0&lt;=object_macro_index)
+							{
+							macros_object.DeleteIdx(object_macro_index);
+							macros_object_expansion.DeleteIdx(object_macro_index);
+							macros_object_expansion_pre_eval.DeleteIdx(object_macro_index);
+							};
+						if (0&lt;=function_macro_index)
+							{
+							macros_function.DeleteIdx(function_macro_index);
+							macros_function_arglist.DeleteIdx(function_macro_index);
+							macros_function_expansion.DeleteIdx(function_macro_index);
+							macros_function_expansion_pre_eval.DeleteIdx(function_macro_index);
+							}
+						inbound_lines.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					if (PP::DEFINE==directive_type)
+						{
+						const size_t critical_offset = valid_directives[directive_type].second+2;
+						assert(0&lt;first_token_len);
+						assert(inbound_lines[i]-&gt;size()&gt;=critical_offset+first_token_len);
+						const errr object_macro_index = binary_find(inbound_lines[i]-&gt;data()+critical_offset,first_token_len,macros_object);
+						const errr function_macro_index = binary_find(inbound_lines[i]-&gt;data()+critical_offset,first_token_len,macros_function);
+						assert(0&gt;object_macro_index || 0&gt;function_macro_index);
+						if (inbound_lines[i]-&gt;size()==critical_offset+first_token_len)
+							{	// object-like, empty string
+ObjectLikeMacroEmptyString:
+							if (	 0&lt;=function_macro_index
+								|| 	(0&lt;=object_macro_index &amp;&amp; NULL!=macros_object_expansion[object_macro_index]))
+								{	//! \test define.C99/Error_dup1.hpp, define.C99/Error_dup1.h
+									//! \test define.C99/Error_dup2.hpp, define.C99/Error_dup2.h
+								discard_duplicate_define(inbound_lines,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (0&lt;=object_macro_index)
+								{	// already present: discard silently
+									//! \test define.C99/Pass_dup1.hpp, define.C99/Pass_dup1.h
+								inbound_lines.DeleteIdx(i);	// discard silently
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							const size_t object_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(object_macro_index);
+							macros_object.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion_pre_eval.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object[object_macro_insertion_index] = _new_buffer_nonNULL_throws&lt;char&gt;(ZAIMONI_LEN_WITH_NULL(first_token_len));
+							strncpy(macros_object[object_macro_insertion_index],inbound_lines[i]-&gt;data()+critical_offset,first_token_len);
+							ZAIMONI_NULL_TERMINATE(macros_object[object_macro_insertion_index][first_token_len]);
+							}
+						else if (lang.IsWS_NotFirst(inbound_lines[i]-&gt;data()[critical_offset+first_token_len]))
+							{	// object-like, not empty string
+							if (	0&lt;=function_macro_index
+								|| 	(0&lt;=object_macro_index &amp;&amp; NULL==macros_object_expansion[object_macro_index]))
+								{	//! \test define.C99/Error_dup3.hpp, define.C99/Error_dup3.h
+									//! \test define.C99/Error_dup4.hpp, define.C99/Error_dup4.h
+									//! \test define.C99/Pass_dup2.hpp, define.C99/Pass_dup2.h
+								discard_duplicate_define(inbound_lines,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+							Token&lt;char&gt; expansion(*inbound_lines[i],critical_offset+first_token_len,inbound_lines[i]-&gt;size()-(critical_offset+first_token_len),0);
+							normalize_macro_expansion(expansion,*inbound_lines[i],critical_offset,first_token_len);
+							//! \test define.C99/Pass_dup2.hpp, define.C99/Pass_dup2.h
+							//! \test define.C99/Error_concatenate1.hpp, define.C99/Error_concatenate1.h
+							//! \test define.C99/Error_concatenate2.hpp, define.C99/Error_concatenate2.h
+							if (discard_leading_trailing_concatenate_op(expansion))
+								goto ObjectLikeMacroEmptyString;
+							if (0&lt;=object_macro_index)
+								{	//! \test define.C99/Error_dup5.hpp, define.C99/Error_dup5.h
+									//! \test define.C99/Pass_dup2.hpp, define.C99/Pass_dup2.h
+								if (strcmp(expansion.data(),macros_object_expansion[object_macro_index]-&gt;data()))
+									discard_duplicate_define(inbound_lines,i,critical_offset,first_token_len);
+								else
+									inbound_lines.DeleteIdx(i);	// discard silently even if it matches
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (C99_VA_ARGS_flinch(expansion,0))
+								{	//! \test define.C99/Error_VA_ARGS.hpp, define.C99/Error_VA_ARGS.h
+								message_header(expansion);
+								INFORM(&quot;discarding macro&quot;);
+								inbound_lines.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+
+							// DO NOT check for context free errors here; could legitimately want to deep-stringize every invocation of the macro
+							const size_t object_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(object_macro_index);
+							macros_object.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion_pre_eval.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object[object_macro_insertion_index] = _new_buffer_nonNULL_throws&lt;char&gt;(ZAIMONI_LEN_WITH_NULL(first_token_len));
+
+							strncpy(macros_object[object_macro_insertion_index],inbound_lines[i]-&gt;data()+critical_offset,first_token_len);
+							ZAIMONI_NULL_TERMINATE(macros_object[object_macro_insertion_index][first_token_len]);
+							macros_object_expansion_pre_eval[object_macro_insertion_index] = new Token&lt;char&gt;(expansion);
+							macros_object_expansion[object_macro_insertion_index] = new Token&lt;char&gt;;
+							expansion.MoveInto(*macros_object_expansion[object_macro_insertion_index]);
+							object_macro_concatenate(*macros_object_expansion_pre_eval[object_macro_insertion_index]);
+							if (C99_VA_ARGS_flinch(*macros_object_expansion_pre_eval[object_macro_insertion_index],0))
+								{	//! \test define.C99/Error_concatenate5.hpp, define.C99/Error_concatenate5.h
+								message_header(*macros_object_expansion_pre_eval[object_macro_insertion_index]);
+								INFORM(&quot;discarding macro&quot;);
+								macros_object.DeleteIdx(object_macro_insertion_index);
+								macros_object_expansion.DeleteIdx(object_macro_insertion_index);
+								macros_object_expansion_pre_eval.DeleteIdx(object_macro_insertion_index);
+								inbound_lines.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							//! \todo should do locked macros [not __FILE__ or __LINE__] that are not first or last identifiers on speculation
+							}
+						else if ('('==inbound_lines[i]-&gt;data()[critical_offset+first_token_len])
+							{	// function-like
+							const size_t argspan = function_macro_argument_span(inbound_lines[i]-&gt;data()+critical_offset+first_token_len);
+							if (0==argspan)
+								{
+								message_header(*inbound_lines[i]);
+								INC_INFORM(ERR_STR);
+								INC_INFORM(inbound_lines[i]-&gt;data()+critical_offset,first_token_len);
+								INFORM(&quot; has an invalid argument list.  Discarding. (C99 6.10.3p/C++0x 16.3p10)&quot;);
+								inbound_lines.DeleteIdx(i);
+								zcc_errors.inc_error();
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (0&lt;=object_macro_index)
+								{	//! \test define.C99/Error_dup6.hpp, define.C99/Error_dup6.h
+								discard_duplicate_define(inbound_lines,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							Token&lt;char&gt; arglist(*inbound_lines[i],critical_offset+first_token_len,argspan,0);
+							normalize_macro_expansion(arglist,*inbound_lines[i],critical_offset,first_token_len);	// should be no string literals here, so should be no errors here
+							if (0&lt;=function_macro_index &amp;&amp; strcmp(arglist.data(),macros_function_arglist[function_macro_index]-&gt;data()))
+								{	//! \test define.C99/Error_dup7.hpp, define.C99/Error_dup7.h
+								discard_duplicate_define(inbound_lines,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (inbound_lines[i]-&gt;size()-(critical_offset+first_token_len)&gt;argspan)
+								{
+								const size_t skip_ws = strspn(inbound_lines[i]-&gt;data()+critical_offset+first_token_len+argspan,lang.WhiteSpace+1);
+								if (inbound_lines[i]-&gt;size()-(critical_offset+first_token_len+argspan)&lt;=skip_ws)
+									inbound_lines[i]-&gt;rtrim(skip_ws);
+								};
+							if (inbound_lines[i]-&gt;size()-(critical_offset+first_token_len)&lt;=argspan)
+								{	// empty expansion
+FunctionLikeMacroEmptyString:	if (0&lt;=function_macro_index)
+									{	//! \test define.C99/Error_dup9.hpp, define.C99/Error_dup9.h
+										//! \test define.C99/Pass_dup4.h, define.C99/Pass_dup4.h
+									if (NULL!=macros_function_expansion[function_macro_index])
+										discard_duplicate_define(inbound_lines,i,critical_offset,first_token_len);
+									else
+										inbound_lines.DeleteIdx(i);	// ignore silently if exactly agreed
+									if (0==i) goto Restart;
+									--i;
+									continue;
+									}
+								const size_t function_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(function_macro_index);
+								macros_function.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_arglist.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_expansion.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_expansion_pre_eval.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function[function_macro_insertion_index] = _new_buffer_nonNULL_throws&lt;char&gt;(ZAIMONI_LEN_WITH_NULL(first_token_len));
+
+								strncpy(macros_function[function_macro_insertion_index],inbound_lines[i]-&gt;data()+critical_offset,first_token_len);
+								ZAIMONI_NULL_TERMINATE(macros_function[function_macro_insertion_index][first_token_len]);
+								macros_function_arglist[function_macro_insertion_index] = new Token&lt;char&gt;;
+								arglist.MoveInto(*macros_function_arglist[function_macro_insertion_index]);
+
+								inbound_lines.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							Token&lt;char&gt; expansion(*inbound_lines[i],critical_offset+first_token_len+argspan,inbound_lines[i]-&gt;size()-(critical_offset+first_token_len+argspan),0);
+							normalize_macro_expansion(expansion,*inbound_lines[i],critical_offset,first_token_len);
+							// white-box test policy: cases above will work
+							if (discard_leading_trailing_concatenate_op(expansion))
+								goto FunctionLikeMacroEmptyString;
+							if (0&lt;=function_macro_index)
+								{	//! \test define.C99/Error_dup8.hpp, define.C99/Error_dup8.h
+									//! \test define.C99/Pass_dup3.h, define.C99/Pass_dup3.h
+								if (strcmp(expansion.data(),macros_function_expansion[function_macro_index]-&gt;data()))
+									discard_duplicate_define(inbound_lines,i,critical_offset,first_token_len);
+								else
+									inbound_lines.DeleteIdx(i);	// discard silently even if it matches
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if ((5&gt;arglist.size() || strcmp(arglist.end()-(sizeof(&quot;...)&quot;)-1),&quot;...)&quot;)) &amp;&amp; C99_VA_ARGS_flinch(expansion,0))
+								{	//! \test define.C99/Error_VA_ARGS2.hpp, define.C99/Error_VA_ARGS2.h
+									//! \test define.C99/Pass_VA_ARGS.hpp, define.C99/Pass_VA_ARGS.h
+								message_header(expansion);
+								INFORM(&quot;discarding macro&quot;);
+								inbound_lines.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+
+							// DO NOT check for context free errors here; could legitimately want to deep-stringize every invocation of the macro
+							const size_t function_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(function_macro_index);
+							macros_function.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_arglist.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_expansion.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_expansion_pre_eval.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function[function_macro_insertion_index] = _new_buffer_nonNULL_throws&lt;char&gt;(ZAIMONI_LEN_WITH_NULL(first_token_len));
+
+							strncpy(macros_function[function_macro_insertion_index],inbound_lines[i]-&gt;data()+critical_offset,first_token_len);
+							ZAIMONI_NULL_TERMINATE(macros_function[function_macro_insertion_index][first_token_len]);
+							macros_function_arglist[function_macro_insertion_index] = new Token&lt;char&gt;;
+							macros_function_expansion[function_macro_insertion_index] = new Token&lt;char&gt;;
+							macros_function_expansion_pre_eval[function_macro_insertion_index] = new Token&lt;char&gt;(expansion);
+							arglist.MoveInto(*macros_function_arglist[function_macro_insertion_index]);
+							expansion.MoveInto(*macros_function_expansion[function_macro_insertion_index]);
+							if (flush_bad_stringize(*macros_function_expansion_pre_eval[function_macro_insertion_index],*macros_function_arglist[function_macro_insertion_index]))
+								{
+								delete macros_function_expansion_pre_eval[function_macro_insertion_index];
+								macros_function_expansion_pre_eval[function_macro_insertion_index] = NULL;
+								};
+							if (NULL!=macros_function_expansion_pre_eval[function_macro_insertion_index])
+								{
+								function_macro_concatenate_novars(*macros_function_expansion_pre_eval[function_macro_insertion_index], *macros_function_arglist[function_macro_insertion_index]);
+								if ((5&gt;macros_function_arglist[function_macro_insertion_index]-&gt;size() || strcmp(macros_function_arglist[function_macro_insertion_index]-&gt;end()-(sizeof(&quot;...)&quot;)-1),&quot;...)&quot;)) &amp;&amp; C99_VA_ARGS_flinch(*macros_function_expansion_pre_eval[function_macro_insertion_index],0))
+									{	//! \test define.C99/Error_concatenate6.hpp, define.C99/Error_concatenate6.h
+										//! \test define.C99/Pass_concatenate3.hpp, define.C99/Pass_concatenate3.h
+									message_header(*macros_function_expansion_pre_eval[function_macro_insertion_index]);
+									INFORM(&quot;discarding macro&quot;);
+									macros_function.DeleteIdx(function_macro_insertion_index);
+									macros_function_arglist.DeleteIdx(function_macro_insertion_index);
+									macros_function_expansion.DeleteIdx(function_macro_insertion_index);
+									macros_function_expansion_pre_eval.DeleteIdx(function_macro_insertion_index);
+									inbound_lines.DeleteIdx(i);
+									if (0==i) goto Restart;
+									--i;
+									continue;
+									}
+								};
+							//! \todo should do locked macros [not __FILE__ or __LINE__] that are not first or last identifiers on speculation
+							};
+						inbound_lines.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					// should use #pragma directives
+					// all three STDC pragmas are scoped: they have to be around until fairly late in the compilation sequence
+					// we are required to ignore unrecognized pragmas -- no warnings
+					// want immediately: #pragma ZCC lock ___
+					// * locks macros
+					if (PP::PRAGMA==directive_type)
+						{
+						const size_t critical_offset = valid_directives[directive_type].second+2;
+//#/*cut-cpp*/
+						const unsigned int pragma_code =
+//#/*cut-cpp*/
+						interpret_pragma(inbound_lines[i]-&gt;data()+critical_offset,inbound_lines[i]-&gt;size()-critical_offset,locked_macros);
+//#/*cut-cpp*/
+						switch(pragma_code)
+						{
+						default:
+//#/*cut-cpp*/
+						inbound_lines.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+//#/*cut-cpp*/
+						case RELAY_ZCC_ENABLE_TYPEID+1:
+							inbound_lines[i]-&gt;replace_once(0,inbound_lines[i]-&gt;size(),pragma_relay_keywords[pragma_code-1].first,pragma_relay_keywords[pragma_code-1].second);
+							continue;
+						}
+//#/*cut-cpp*/
+						}
+					}
+				}
+
+			if (   PP::IF    ==directive_type
+				|| PP::IFDEF ==directive_type
+				|| PP::IFNDEF==directive_type)
+				{
+				if (1 == ++if_depth)
+					{
+					if_where = i;
+					else_where = 0;
+					// front-load syntax checking
+					// only report errors once
+					if (!(inbound_lines[i]-&gt;flags &amp; INVALID_DIRECTIVE_FLAG) &amp;&amp; 0==include_where)
+						{
+						if (PP::IF==directive_type)
+							{
+							if (!if_elif_syntax_ok(*inbound_lines[i],macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,min_types))
+								inbound_lines[i]-&gt;flags |= INVALID_DIRECTIVE_FLAG;
+							}
+						else{
+							if (!ifdef_ifndef_syntax_ok(*inbound_lines[i],macros_object,macros_function))
+								inbound_lines[i]-&gt;flags |= INVALID_DIRECTIVE_FLAG;
+							else
+								assert(PP::IF==UNPACK_DIRECTIVE(inbound_lines[i]-&gt;flags));
+							}
+						}
+					if (0==restart_full_scan)
+						{
+						restart_full_scan = i+1;
+						//! \todo do it all, have complete information
+						};
+					//! \todo front-load syntax checking, etc. when safe [0==include_where &amp;&amp; if_where+1==restart_full_scan]
+					//! can detect gross-invalidity anyway, but anything requiring authoritiatively knowing macro (un)defined-ness won't go through
+					}
+				}
+			else if (   PP::ELSE ==directive_type
+					 || PP::ELIF ==directive_type
+					 || PP::ENDIF==directive_type)
+				{
+				assert(0&lt;if_depth);
+				if (1==if_depth)
+					{
+					if (PP::ELIF!=directive_type)
+						//! test Error_else_with_tokens.hpp : #else with tokens
+						//! test Error_endif_with_tokens.hpp : #endif with tokens
+						truncate_illegal_tokens(*inbound_lines[i],directive_type,valid_directives[directive_type].second+1);
+					else if (	!(inbound_lines[i]-&gt;flags &amp; INVALID_DIRECTIVE_FLAG)
+							 &amp;&amp; !if_elif_syntax_ok(*inbound_lines[i],macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,min_types))
+						inbound_lines[i]-&gt;flags |= INVALID_DIRECTIVE_FLAG;
+					};
+
+				if (PP::ENDIF==directive_type)
+					{
+					if (0 == --if_depth)
+						{	// trigger conditional preprocessing here
+						assert(inbound_lines[if_where]-&gt;flags &amp; PREPROCESSING_DIRECTIVE_FLAG);
+						assert(0==else_where || (inbound_lines[else_where-1]-&gt;flags &amp; PREPROCESSING_DIRECTIVE_FLAG));
+						assert(0==else_where || (if_where&lt;=else_where &amp;&amp; else_where&lt;=i));
+						if (inbound_lines[if_where]-&gt;flags &amp; INVALID_DIRECTIVE_FLAG)
+							{	// already tagged as invalid
+							message_header(*inbound_lines[if_where]);
+							INFORM(&quot;Ignoring entire block controlled by flawed directive&quot;);
+							inbound_lines.DeleteNSlotsAt(i-if_where+1,if_where);
+							i = if_where;
+							if (0==i) goto Restart;
+							if (restart_full_scan&gt;=i+1) restart_full_scan = 0;	// very possible
+							if (include_where&gt;=i+1) include_where = 0;			// failsafing
+							--i;
+							continue;
+							};
+
+						// inject reductions here
+						const unsigned int else_directive = (0==else_where) ? PP_INVALID : UNPACK_DIRECTIVE(inbound_lines[else_where-1]-&gt;flags);
+						assert(0==else_where || PP::ELSE==else_directive || PP::ELIF==else_directive);
+						if (!strcmp(inbound_lines[if_where]-&gt;data(),&quot;#if 0&quot;))
+							{
+							if (0==else_where)
+								{
+								inbound_lines.DeleteNSlotsAt(i-if_where+1,if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan&gt;=i+1) restart_full_scan = 0;	// very possible
+								if (include_where&gt;=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							if (PP::ELSE==else_directive)
+								{
+								inbound_lines.DeleteIdx(i);
+//								inbound_lines.DeleteNSlotsAt((else_where-1)-if_where+1,if_where);
+								inbound_lines.DeleteNSlotsAt(else_where-if_where,if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan&gt;=i+1) restart_full_scan = 0;	// very possible
+								if (include_where&gt;=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							if (inbound_lines[else_where-1]-&gt;flags &amp; INVALID_DIRECTIVE_FLAG)
+								{	//! \test Error8.hpp : #elif no control expression, critical
+								message_header(*inbound_lines[else_where-1]);
+								INFORM(&quot;Ignoring all lines from invalid #elif to matching #endif&quot;);
+								inbound_lines.DeleteNSlotsAt(i-if_where+1,if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan&gt;=i+1) restart_full_scan = 0;	// very possible
+								if (include_where&gt;=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							//! \todo do full reduction here to make errors read #elif rather than #if
+							// recurse it
+							inbound_lines[else_where-1]-&gt;c_array()[2] = '#';
+							inbound_lines[else_where-1]-&gt;ltrim(2);
+							PACK_DIRECTIVE(inbound_lines[else_where-1]-&gt;flags,PP::IF);
+//							inbound_lines.DeleteNSlotsAt((else_where-1)-if_where+1,if_where);
+							inbound_lines.DeleteNSlotsAt(else_where-if_where+2,if_where);
+							i = if_where;
+							if (0==i) goto Restart;
+							if (restart_full_scan&gt;=i+1) restart_full_scan = 0;	// very possible
+							if (include_where&gt;=i+1) include_where = 0;			// failsafing
+							--i;
+							continue;
+							};
+						if (!strcmp(inbound_lines[if_where]-&gt;data(),&quot;#if 1&quot;))
+							{
+							if (0==else_where)
+								{
+								inbound_lines.DeleteIdx(i);
+								inbound_lines.DeleteIdx(if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan&gt;=i+1) restart_full_scan = 0;	// very possible
+								if (include_where&gt;=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							if (PP::ELIF==else_directive &amp;&amp; (inbound_lines[else_where-1]-&gt;flags &amp; INVALID_DIRECTIVE_FLAG))
+								{	//! \test Error9.hpp : #elif no control expression, non-critical
+								message_header(*inbound_lines[else_where-1]);
+								INFORM(&quot;Continuing as expression for invalid #elif not needed.&quot;);
+								};
+//							inbound_lines.DeleteNSlotsAt(i-(else_where-1)+1,else_where-1);
+							inbound_lines.DeleteNSlotsAt(i-else_where+2,else_where-1);
+							inbound_lines.DeleteIdx(if_where);
+							i = if_where;
+							if (0==i) goto Restart;
+							if (restart_full_scan&gt;=i+1) restart_full_scan = 0;	// very possible
+							if (include_where&gt;=i+1) include_where = 0;			// failsafing
+							--i;
+							continue;
+							};
+						}
+					}
+				else if (1==if_depth &amp;&amp; 0==else_where)
+					else_where = i+1;
+				}
+			}
+		// non-directive; lex, and check for macros and _Pragma operators
+		// remember to convert whitespace to single-space tokens, and flush those later
+		else if (0==include_where &amp;&amp; 0==restart_full_scan)
+			{
+			assert(0==i);
+			size_t outbound_origin = outbound_tokens.size();
+			outbound_tokens.resize(outbound_origin+1);
+			outbound_tokens.back() = inbound_lines.front();
+			inbound_lines.front() = NULL;
+			inbound_lines.DeleteIdx(0);
+			if (!tokenize_line(outbound_tokens,outbound_origin))
+				goto Restart;
+			while(outbound_tokens.size()&gt;outbound_origin)
+				{
+				if (C_TESTFLAG_PP_OP_PUNC &amp; outbound_tokens[outbound_origin]-&gt;flags)
+					{	// check for categorically illegal tokens
+					const signed int old_pp_code = C_PP_DECODE(outbound_tokens[outbound_origin]-&gt;flags);
+					const signed int pp_code = (old_pp_code) ? old_pp_code : lang.pp_support-&gt;EncodePPOpPunc(outbound_tokens[outbound_origin]-&gt;data(),outbound_tokens[outbound_origin]-&gt;size());
+					assert(0&lt;pp_code);
+					if (C_DISALLOW_POSTPROCESSED_SOURCE &amp; lang.pp_support-&gt;GetPPOpPuncFlags(pp_code))
+						{	//! \todo need test cases
+							// actually, this might need to be language-sensitive (e.g., Perl)
+						message_header(*outbound_tokens[outbound_origin]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM(&quot;Forbidden token '&quot;);
+						INC_INFORM(outbound_tokens[outbound_origin]-&gt;data(),outbound_tokens[outbound_origin]-&gt;size());
+						INFORM(&quot;' in postprocessed source.  Discarding.&quot;);
+						zcc_errors.inc_error();
+						outbound_tokens.DeleteIdx(outbound_origin);
+						continue;
+						}
+					C_PP_ENCODE(outbound_tokens[outbound_origin]-&gt;flags,pp_code);
+					}
+				else if (C_TESTFLAG_IDENTIFIER==outbound_tokens[outbound_origin]-&gt;flags)
+					{
+					if (!strcmp(outbound_tokens[outbound_origin]-&gt;data(),&quot;_Pragma&quot;))
+						{	// could be pragma operator; syntax _Pragma ( C-string )
+						while(1&gt;=outbound_tokens.size()-outbound_origin &amp;&amp; !line_is_preprocessing_directive(*inbound_lines[0]))
+							{
+							size_t tmp = outbound_tokens.size();
+							outbound_tokens.resize(tmp+1);
+							outbound_tokens.back() = inbound_lines.front();
+							inbound_lines.front() = NULL;
+							inbound_lines.DeleteIdx(0);
+							tokenize_line(outbound_tokens,tmp);
+							};
+						if (     1&gt;=outbound_tokens.size()-outbound_origin
+							||   1!=outbound_tokens[outbound_origin+1]-&gt;size()
+							|| '('!=outbound_tokens[outbound_origin+1]-&gt;front())
+							{	//! \test cpp/Pragma.C99/Error_op1.hpp, cpp/Pragma.C99/Error_op1.h
+								//! \test cpp/Pragma.C99/Error_op2.hpp, cpp/Pragma.C99/Error_op2.h
+							message_header2(*outbound_tokens[outbound_origin],outbound_tokens[outbound_origin]-&gt;logical_line.second);
+							INC_INFORM(ERR_STR);
+							INFORM(&quot;Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)&quot;);
+							zcc_errors.inc_error();
+							outbound_tokens.DeleteIdx(outbound_origin);
+							continue;
+							};
+						while(2&gt;=outbound_tokens.size()-outbound_origin &amp;&amp; !line_is_preprocessing_directive(*inbound_lines[0]))
+							{
+							size_t tmp = outbound_tokens.size();
+							outbound_tokens.resize(tmp+1);
+							outbound_tokens.back() = inbound_lines.front();
+							inbound_lines.front() = NULL;
+							inbound_lines.DeleteIdx(0);
+							tokenize_line(outbound_tokens,tmp);
+							};
+						if (   2&gt;=outbound_tokens.size()-outbound_origin
+							|| C_TESTFLAG_STRING_LITERAL!=outbound_tokens[outbound_origin+2]-&gt;flags)
+							{	//! \test cpp/Pragma.C99/Error_op3.hpp, cpp/Pragma.C99/Error_op3.h
+								//! \test cpp/Pragma.C99/Error_op4.hpp, cpp/Pragma.C99/Error_op4.h
+							message_header2(*outbound_tokens[outbound_origin],outbound_tokens[outbound_origin]-&gt;logical_line.second);
+							INC_INFORM(ERR_STR);
+							INFORM(&quot;Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)&quot;);
+							zcc_errors.inc_error();
+							outbound_tokens.DeleteNSlotsAt(2,outbound_origin);
+							continue;
+							};
+						while(3&gt;=outbound_tokens.size()-outbound_origin &amp;&amp; !line_is_preprocessing_directive(*inbound_lines[0]))
+							{
+							size_t tmp = outbound_tokens.size();
+							outbound_tokens.resize(tmp+1);
+							outbound_tokens.back() = inbound_lines.front();
+							inbound_lines.front() = NULL;
+							inbound_lines.DeleteIdx(0);
+							tokenize_line(outbound_tokens,tmp);
+							};
+						if (     3&gt;=outbound_tokens.size()-outbound_origin
+							||   1!=outbound_tokens[outbound_origin+3]-&gt;size()
+							|| ')'!=outbound_tokens[outbound_origin+3]-&gt;front())
+							{	//! \test cpp/Pragma.C99/Error_op5.hpp, cpp/Pragma.C99/Error_op5.h
+								//! \test cpp/Pragma.C99/Error_op6.hpp, cpp/Pragma.C99/Error_op6.h
+							message_header2(*TokenList[i],TokenList[i]-&gt;logical_line.second);
+							INC_INFORM(ERR_STR);
+							INFORM(&quot;Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)&quot;);
+							zcc_errors.inc_error();
+							outbound_tokens.DeleteNSlotsAt(3,outbound_origin);
+							continue;
+							};
+						if ('L'==outbound_tokens[outbound_origin+2]-&gt;front())
+							outbound_tokens[outbound_origin+2]-&gt;ltrim(1);
+						if (2&lt;outbound_tokens[outbound_origin+2]-&gt;size())
+							{	//! \test Pass_pragma_STDC.hpp
+							autovalarray_ptr_throws&lt;char&gt; pragma_string(lang.UnescapeStringLength(outbound_tokens[outbound_origin+2]-&gt;data()+1,outbound_tokens[outbound_origin+2]-&gt;size()-2));
+							lang.UnescapeString(pragma_string.c_array(),outbound_tokens[outbound_origin+2]-&gt;data()+1,outbound_tokens[outbound_origin+2]-&gt;size()-2);
+//#/*cut-cpp*/
+							const unsigned int pragma_code =
+//#/*cut-cpp*/
+							interpret_pragma(pragma_string.data(),pragma_string.size(),locked_macros);
+//#/*cut-cpp*/
+							switch(pragma_code)
+							{
+							case RELAY_ZCC_ENABLE_TYPEID+1:
+								outbound_tokens[outbound_origin]-&gt;replace_once(0,TokenList[outbound_origin]-&gt;size(),pragma_relay_keywords[pragma_code-1].first,pragma_relay_keywords[pragma_code-1].second);
+								outbound_tokens.DeleteNSlotsAt(3,outbound_origin+1);
+								continue;
+							}
+//#/*cut-cpp*/
+							};
+						outbound_tokens.DeleteNSlotsAt(4,outbound_origin);
+						continue;
+						};
+					const errr object_macro_index = binary_find(outbound_tokens[outbound_origin]-&gt;data(),outbound_tokens[outbound_origin]-&gt;size(),macros_object);
+					const errr function_macro_index = binary_find(outbound_tokens[outbound_origin]-&gt;data(),outbound_tokens[outbound_origin]-&gt;size(),macros_function);
+					assert(0&gt;object_macro_index || 0&gt;function_macro_index);
+					if (0&lt;=object_macro_index)
+						{	// object-like macro
+						if (!macros_object_expansion_pre_eval[object_macro_index])
+							{	// expands to nothing
+								//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
+							outbound_tokens.DeleteIdx(outbound_origin);
+							continue;
+							}
+						assert(!macros_object_expansion_pre_eval[object_macro_index]-&gt;empty());
+						{	//! \test cpp/default/Preprocess_*.h/hpp
+						size_t discard = 0;
+						dynamic_macro_replace_once(*outbound_tokens[outbound_origin],discard,outbound_tokens[outbound_origin]-&gt;size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
+						}
+						size_t actual_tokens = tokenize_line(outbound_tokens,outbound_origin);
+						assert(0&lt;actual_tokens);
+						outbound_origin += actual_tokens;
+						}
+					else if (0&lt;=function_macro_index)
+						{	// could be function-like macro
+						if (   1&lt;outbound_tokens.size()-outbound_origin
+							&amp;&amp; outbound_tokens[outbound_origin]-&gt;logical_line.first==outbound_tokens[outbound_origin+1]-&gt;logical_line.first
+							&amp;&amp; outbound_tokens[outbound_origin]-&gt;logical_line.second+outbound_tokens[outbound_origin]-&gt;size()==outbound_tokens[outbound_origin+1]-&gt;logical_line.second
+							&amp;&amp; '('==outbound_tokens[outbound_origin+1]-&gt;front())
+							{
+							size_t paren_depth = 1;
+							size_t comma_count = 0;
+							size_t j = outbound_origin+1;
+							do	{
+								if (1&gt;=outbound_tokens.size()-j)
+									{	
+									if (inbound_lines.empty())
+										{	//! \test cpp/Error_macro_arglist4.hpp
+											// error out, incomplete function-like macro
+										message_header2(*outbound_tokens[outbound_origin],outbound_tokens[outbound_origin]-&gt;logical_line.second);
+										INC_INFORM(ERR_STR);
+										INC_INFORM(&quot;macro &quot;);
+										INC_INFORM(outbound_tokens[outbound_origin]-&gt;data(),outbound_tokens[outbound_origin]-&gt;size());
+										INFORM(&quot; did not close its argument list in time. (C99 6.10p1/C++98 16.1p1)&quot;);
+										zcc_errors.inc_error();
+										goto Restart;
+										}
+									if (line_is_preprocessing_directive(*inbound_lines[0]))
+										{	//! \test cpp/Error_macro_arglist7.hpp
+											// error out, undefined behavior
+										message_header2(*outbound_tokens[outbound_origin],outbound_tokens[outbound_origin]-&gt;logical_line.second);
+										INC_INFORM(ERR_STR);
+										INFORM(&quot;macro invocation contains preprocessing directive.  Defining undefined behavior as ignoring macro invocation. (C99 6.10.3p11/C++98 16.3p10)&quot;);
+										zcc_errors.inc_error();
+										goto Restart;
+										}
+									size_t tmp = outbound_tokens.size();
+									outbound_tokens.resize(tmp+1);
+									outbound_tokens.back() = inbound_lines.front();
+									inbound_lines.front() = NULL;
+									inbound_lines.DeleteIdx(0);
+									if (!tokenize_line(outbound_tokens,tmp))
+										continue;
+									}
+								if (1==outbound_tokens[++j]-&gt;size())
+									switch(outbound_tokens[j]-&gt;front())
+									{
+									case '(':
+										++paren_depth;
+										break;
+									case ',':
+										++comma_count;
+										break;
+									case ')':
+										--paren_depth;
+										//	break;
+									};
+								}
+							while(0&lt;paren_depth);
+							assert(0==paren_depth);	// remove when above verified to be converted correctly							
+							assert(macros_function_arglist[function_macro_index]);
+							assert('('==macros_function_arglist[function_macro_index]-&gt;front());
+							assert(')'==macros_function_arglist[function_macro_index]-&gt;back());
+							const size_t formal_arg_span = macros_function_arglist[function_macro_index]-&gt;size();
+							const size_t formal_arg_count = (2&lt;formal_arg_span) ? std::count(macros_function_arglist[function_macro_index]-&gt;begin(),macros_function_arglist[function_macro_index]-&gt;end(),',')+1 : 0;
+							const bool formal_varadic = 5&lt;=formal_arg_span &amp;&amp; !strncmp(macros_function_arglist[function_macro_index]-&gt;data()+(formal_arg_span-4),&quot;...&quot;,sizeof(&quot;...&quot;)-1);
+							const size_t arg_count = (i+2==j) ? 0 : comma_count+1;
+							if (arg_count&lt;formal_arg_count || (arg_count&gt;formal_arg_count &amp;&amp; !formal_varadic))
+								{	//! \test cpp/Error_macro_arglist5.hpp
+									//! \test cpp/Error_macro_arglist6.hpp
+								message_header2(*outbound_tokens[outbound_origin],outbound_tokens[outbound_origin]-&gt;logical_line.second);
+								INC_INFORM(ERR_STR);
+								INC_INFORM(&quot;macro &quot;);
+								INC_INFORM(outbound_tokens[outbound_origin]-&gt;data(),outbound_tokens[outbound_origin]-&gt;size());
+								INC_INFORM(&quot; had &quot;);
+								INC_INFORM(arg_count);
+								INC_INFORM(&quot; argument&quot;);
+								INC_INFORM((1==arg_count) ? &quot;&quot; : &quot;s&quot;);
+								INC_INFORM(&quot;, needed &quot;);
+								if (formal_varadic) INC_INFORM(&quot;at least &quot;);
+								INC_INFORM(formal_arg_count);
+								INFORM(&quot;. (C99 6.10p1/C++0x 16.1p1)&quot;);
+								zcc_errors.inc_error();
+								outbound_origin = j;
+								continue;
+								}
+							if (!macros_function_expansion_pre_eval[function_macro_index])
+								{	// expands to nothing
+									//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
+								outbound_tokens.DeleteNSlotsAt(j-outbound_origin+1,outbound_origin);
+								goto Restart;
+								}
+							assert(!macros_function_expansion_pre_eval[function_macro_index]-&gt;empty());
+							{	//! \test default/Preprocess_*.h/hpp 
+							Token&lt;char&gt;* Tmp = new Token&lt;char&gt;(*macros_function_expansion_pre_eval[function_macro_index]);
+							Tmp-&gt;logical_line = outbound_tokens[outbound_origin]-&gt;logical_line;
+							if (!nonrecursive_macro_replacement_list(Tmp-&gt;data()))
+								{	// XXX trashes line information to reuse intrapreprocessing stuff
+								size_t discard = outbound_origin;
+								Token&lt;char&gt;* Tmp2 = new Token&lt;char&gt;(*outbound_tokens[outbound_origin]);
+								while(++discard &lt;= j) Tmp2-&gt;append(outbound_tokens[discard]-&gt;data());
+								discard = 0;
+								dynamic_macro_replace_once(*Tmp2,discard,outbound_tokens[outbound_origin]-&gt;size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
+								delete Tmp;
+								Tmp = Tmp2;
+								}
+							outbound_tokens.DeleteNSlotsAt(j-outbound_origin,outbound_origin+1);
+							delete outbound_tokens[outbound_origin];
+							outbound_tokens[outbound_origin] = Tmp;
+							}
+							size_t actual_tokens = tokenize_line(outbound_tokens,outbound_origin);
+							assert(0&lt;actual_tokens);
+							outbound_origin += actual_tokens;
+							};
+							}
+						}
+					else{	// replace predefined macros, if they are here
+							//! \test cpp/default/Preprocess_STDC_defines.hpp, cpp/default/Preprocess_STDC_defines.h
+						predefined_macro_replacement(*outbound_tokens[outbound_origin],0);
+						}
+					}
+				}
+			--i;
+			}
+	while(++i&lt;inbound_lines.size());
+
+	if (0&lt;if_depth)
+		{	//! \test Error_naked_if.hpp
+		message_header(*inbound_lines[if_where]);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(if_depth);
+		INC_INFORM(&quot; #if/#ifdef/#ifndef&quot;);
+		if (1&lt;if_depth) INC_INFORM(&quot;'s&quot;);
+		INFORM(&quot; without matching #endif directives (first one here).  (C99 6.10p1/C++98 16.1p1)&quot;);
+		zcc_errors.inc_error();
+		}
+	assert(0==include_where || 0==restart_full_scan || include_where&lt;restart_full_scan);
+
+	if (0&lt;include_where)
+		{	// Need to find the file....
+		assert(1==include_where);
+		--include_where;
+		assert(PP::INCLUDE == UNPACK_DIRECTIVE(inbound_lines[0]-&gt;flags));
+		if (inbound_lines[0]-&gt;size()&lt;=(sizeof(&quot;#include &lt;&gt;&quot;)-1))
+			{	//! \test Error_include_tiny1.hpp
+				//! \test Error_include_tiny2.hpp
+			message_header(*inbound_lines[0]);
+			INC_INFORM(ERR_STR);
+			INFORM(&quot;#include is too small to contain a valid filename; discarding and continuing (C99 6.10.2p2,3/C++98 16.2p2,3)&quot;);
+			inbound_lines.DeleteIdx(0);
+			zcc_errors.inc_error();
+			goto Restart;
+			}
+		// already preprocessed, fortunately
+		bool local_include = false;
+		size_t filename_len = inbound_lines[0]-&gt;size()-(sizeof(&quot;#include &lt;&gt;&quot;)-1);
+		switch(inbound_lines[0]-&gt;data()[sizeof(&quot;#include &quot;)-1])
+		{
+		case '&quot;':	{	// local-include
+					if ('&quot;'!=inbound_lines[0]-&gt;back())
+						{	//! \test Error_include_unterminated2.hpp
+						message_header(*inbound_lines[0]);
+						INC_INFORM(ERR_STR);
+						INFORM(&quot;#include \&quot;... does not terminate properly; discarding and continuing (C99 6.10.2p3/C++98 16.2p3)&quot;);
+						inbound_lines.DeleteIdx(include_where);
+						zcc_errors.inc_error();
+						goto Restart;
+						};
+					local_include = true;
+					break;
+					}
+		case '&lt;':	{	// system-include
+					if ('&gt;'!=inbound_lines[0]-&gt;back())
+						{	//! \test Error_include_unterminated1.hpp
+						message_header(*inbound_lines[0]);
+						INC_INFORM(ERR_STR);
+						INFORM(&quot;#include &lt;... does not terminate properly; discarding and continuing (C99 6.10.2p2/C++98 16.2p2)&quot;);
+						inbound_lines.DeleteIdx(0);
+						zcc_errors.inc_error();
+						goto Restart;
+						};
+					break;
+					}
+		default:	{	// neither
+					message_header(*inbound_lines[0]);
+					INC_INFORM(ERR_STR);
+					INFORM(&quot;#include has bad format; discarding and continuing (C99 6.10.2p2,3/C++98 16.2p2,3)&quot;);
+					inbound_lines.DeleteIdx(0);
+					zcc_errors.inc_error();
+					goto Restart;
+					}
+		};
+		// iterate through search path until something found matching
+		// need to map following
+		// * filename given from #include
+		// * full path that actually finds the file, or positive failure to find (AtomicString)
+		// * cached content (probably separate indexing on full-path), if not include-guarded
+		// * whether include-guarded #define; if so, what the include-guard macro is...
+		// * whether the subject of a pragma-once
+		// We need a de-facto stack for the &quot;most recent include dirctory&quot; to deal with local includes
+#define CPP_INCLUDE_NOT_FOUND 1U
+
+		autovalarray_ptr&lt;Token&lt;char&gt;* &gt; IncludeTokenList;
+		const char* const look_for = register_substring(inbound_lines[0]-&gt;data()+sizeof(&quot;#include &lt;&quot;)-1,filename_len);
+		assert(filename_len==strlen(look_for));
+		if (local_include)
+			{	// #include &quot;...&quot; prohibits interior &quot;
+			if (strchr(look_for,'&quot;'))
+				{	//! \test Error_include_multiterminated2.hpp
+				message_header(*inbound_lines[0]);
+				INC_INFORM(ERR_STR);
+				INFORM(&quot;#include \&quot;...\&quot; contains \&quot;; discarding and continuing (C99 6.10.2p3/C++98 16.2p3)&quot;);
+				inbound_lines.DeleteIdx(0);
+				zcc_errors.inc_error();
+				goto Restart;
+				}
+			}
+		else if (strchr(look_for,'&gt;')) // #include &lt;...&gt; prohibits interior &gt;
+			{	//! \test Error_include_multiterminated1.hpp
+			message_header(*inbound_lines[0]);
+			INC_INFORM(ERR_STR);
+			INFORM(&quot;#include &lt;...&gt; contains &gt;; discarding and continuing (C99 6.10.2p2/C++98 16.2p2)&quot;);
+			inbound_lines.DeleteIdx(0);
+			zcc_errors.inc_error();
+			goto Restart;
+			};
+
+		errr have_file_index = binary_find(look_for, filename_len, include_file_index);
+		// system includes use their handle for information.
+		//! \todo rewrite this to support the #include_next extension?
+		if (0&lt;=have_file_index)
+			{	// already have this one....
+			if (CPP_INCLUDE_NOT_FOUND==include_file_index[have_file_index].third)
+				{	// don't error again....
+				inbound_lines.DeleteIdx(0);
+				goto Restart;
+				}
+			assert(NULL!=include_file_index[have_file_index].second);
+			const errr cache_index = binary_find(include_file_index[have_file_index].second, strlen(include_file_index[have_file_index].second),include_file_cache);
+			assert(0&lt;=cache_index);
+			IncludeTokenList = *include_file_cache[cache_index].second;
+		 	}
+		else{
+			char buf[FILENAME_MAX];
+			const char* main_index_name = NULL;
+			// note: local_include needs to know where to start...
+			bool found_file = local_include &amp;&amp; find_local_include(look_for, buf, (inbound_lines[0]-&gt;parent_dir ? inbound_lines[0]-&gt;parent_dir : &quot;.&quot;));
+			bool hardcoded_header = false;
+			if (found_file)
+				{	// filepath known; local includes use the calculated path for information
+				main_index_name = register_string(buf);
+				have_file_index = binary_find(main_index_name, strlen(main_index_name), include_file_index);
+				if (0&lt;=have_file_index)
+					{
+					assert(CPP_INCLUDE_NOT_FOUND!=include_file_index[have_file_index].third);
+					const errr cache_index = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
+					assert(0&lt;=cache_index);
+					IncludeTokenList = *include_file_cache[cache_index].second;
+					}
+				else{	// filepath known; inhale and set up cache
+					if (!load_sourcefile(IncludeTokenList,buf,lang)) throw std::bad_alloc();
+					// backfit SourceFile... to look_for; parent_dir to parent directory of file in buf
+					if (!IncludeTokenList.empty())
+						{
+						char parent_path[FILENAME_MAX];
+						z_dirname(parent_path,buf);
+						const char* const parent_dir = register_string(parent_path);
+						size_t j = IncludeTokenList.size();
+						do	{
+							IncludeTokenList[--j]-&gt;src_filename = look_for;
+							IncludeTokenList[j]-&gt;parent_dir = parent_dir;
+							}
+						while(0&lt;j);
+						};
+					// set up include_file_index, include_file_cache
+					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(have_file_index);
+					const errr cache_index = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
+					const size_t include_file_cache_target = BINARY_SEARCH_DECODE_INSERTION_POINT(cache_index);
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_cache.insertNSlotsAt(1,include_file_cache_target);
+					include_file_cache[include_file_cache_target].second = new autovalarray_ptr&lt;Token&lt;char&gt;* &gt;(IncludeTokenList);
+					include_file_cache[include_file_cache_target].first = main_index_name;
+					include_file_index[include_file_index_target].first = main_index_name;
+					include_file_index[include_file_index_target].second = main_index_name;
+					include_file_index[include_file_index_target].third = 0;
+					}
+				}
+			else{	// we're having to process it as a system include.
+				errr tmp = 0;
+				// C99 7.1.2p4 and C++98 17.3.3.1.1p2 both prohibit having any keywords defined as macros when including a library header.
+				// C++0x 17.4.3.2.2 goes further and simply prohibits defining any keywords as macros.  Oops.
+				// C0x appears to be conserving C99 exactly.
+				// We undefine the offending macros as well as erroring, mainly to prevent duplicate error messages
+				// C99 doesn't care about such defines *after* the header; C++98 does.
+				//! \test cpp/default/keywords/Error_*.h
+				if (Lang::C==lang_code &amp;&amp; 0&lt;lang.pp_support-&gt;LengthOfSystemHeader(look_for))
+					C99_reject_keyword_macros(inbound_lines,0,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+
+				const unsigned int hardcoded_header_idx = detect_hardcoded_system_header(look_for,lang_code);
+				switch(hardcoded_header_idx)
+				{
+#ifndef NDEBUG
+				default: FATAL(&quot;hardcoded_header_idx out of range&quot;);
+#endif
+				case 3:	{	// stdint.h/cstdint
+					hardcoded_header = true;
+					C99_reject_keyword_macros(inbound_lines,0,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+					if (0&gt;binary_find(&quot;__STDINT_H__&quot;,sizeof(&quot;__STDINT_H__&quot;)-1,macros_object))	
+						create_stdint_header(IncludeTokenList,look_for);	// not included yet
+					break;
+					}
+				case 2:	{	// stddef.h/cstddef
+					hardcoded_header = true;
+					C99_reject_keyword_macros(inbound_lines,0,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+					if (0&gt;binary_find(&quot;__STDDEF_H__&quot;,sizeof(&quot;__STDDEF_H__&quot;)-1,macros_object))	
+						create_stddef_header(IncludeTokenList,look_for);	// not included yet
+					break;
+					}
+				case 1:	{	// limits.h/climits
+					hardcoded_header = true;
+					C99_reject_keyword_macros(inbound_lines,0,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+					if (0&gt;binary_find(&quot;__LIMITS_H__&quot;,sizeof(&quot;__LIMITS_H__&quot;)-1,macros_object))	
+						create_limits_header(IncludeTokenList,look_for);	// not included yet
+					break;
+					}
+				case 0:;
+				}
+
+				found_file = !hardcoded_header &amp;&amp; find_system_include(look_for, buf);
+				if (found_file)
+					{	// filepath known; inhale and set up cache
+					if (!load_sourcefile(IncludeTokenList,buf,lang)) throw std::bad_alloc();
+					// backfit SourceFile... to look_for; parent_dir to parent directory of file in buf
+					if (!IncludeTokenList.empty())
+						{
+						char parent_path[FILENAME_MAX];
+						z_dirname(parent_path,buf);
+						const char* const parent_dir = (!strcmp(parent_path,origin_dir)) ? origin_dir : register_string(parent_path);
+						size_t j = IncludeTokenList.size();
+						do	{
+							IncludeTokenList[--j]-&gt;src_filename = look_for;
+							IncludeTokenList[j]-&gt;parent_dir = parent_dir;
+							}
+						while(0&lt;j);
+						};
+					main_index_name = register_string(buf);
+					// set up include_file_index, include_file_cache
+					tmp = binary_find(look_for,filename_len,include_file_index);
+					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
+					tmp = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
+					const size_t include_file_cache_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_cache.insertNSlotsAt(1,include_file_cache_target);
+					include_file_cache[include_file_cache_target].second = new autovalarray_ptr&lt;Token&lt;char&gt;* &gt;(IncludeTokenList);
+					include_file_cache[include_file_cache_target].first = main_index_name;
+					include_file_index[include_file_index_target].first = look_for;
+					include_file_index[include_file_index_target].second = main_index_name;
+					include_file_index[include_file_index_target].third = 0;
+					}
+				else if (!hardcoded_header)
+					{	// not there at all...
+					// set up include_file_index
+					tmp = binary_find(look_for,filename_len,include_file_index);
+					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_index[include_file_index_target].first = look_for;
+					include_file_index[include_file_index_target].second = NULL;
+					include_file_index[include_file_index_target].third = CPP_INCLUDE_NOT_FOUND;
+
+					message_header(*inbound_lines[0]);
+					INC_INFORM(ERR_STR);
+					INFORM(&quot;#include'd file not found; discarding and continuing&quot;);
+					inbound_lines.DeleteIdx(0);
+					zcc_errors.inc_error();
+					goto Restart;
+					}
+				}
+			}
+#undef CPP_INCLUDE_NOT_FOUND
+		//! also tested in a number of data transform tests
+		//! \test Pass_include_local.hpp
+		if (!IncludeTokenList.empty())
+			{	// not sure whether C99 5.1.1.2 4 requires preprocessing the whole header before pasting, but it permits it
+				// this implies:
+				// * conditional-compilation directives must be balanced for each file
+				// * #line directives never escape files anyway
+			{
+			zaimoni::autovalarray_ptr&lt;zaimoni::Token&lt;char&gt;* &gt; inbound_lines_backup;
+			zaimoni::autovalarray_ptr&lt;zaimoni::Token&lt;char&gt;* &gt; outbound_tokens_backup;
+			inbound_lines.MoveInto(inbound_lines_backup);
+			outbound_tokens.MoveInto(outbound_tokens_backup);
+			++include_level;
+			_preprocess_alt(IncludeTokenList, locked_macros, macros_object, macros_object_expansion, macros_object_expansion_pre_eval, macros_function, macros_function_arglist, macros_function_expansion, macros_function_expansion_pre_eval, include_file_index, include_file_cache, min_types);
+			--include_level;
+			inbound_lines_backup.MoveInto(inbound_lines);
+			outbound_tokens_backup.MoveInto(outbound_tokens);
+			}
+			if (!IncludeTokenList.empty())
+				{
+				size_t j = IncludeTokenList.size();
+				inbound_lines.insertNSlotsAt(j,1);
+				memmove(inbound_lines.c_array()+1,IncludeTokenList.data(),j*sizeof(Token&lt;char*&gt;*));
+#ifdef ZAIMONI_NULL_REALLY_IS_ZERO
+				memset(IncludeTokenList.c_array(),0,j*sizeof(Token&lt;char*&gt;*));
+#else
+				std::fill(IncludeTokenList.begin(),IncludeTokenList.end(),NULL)
+#endif
+				}
+			}
+
+		// XXX fallthrough hack XXX
+		inbound_lines.DeleteIdx(0);
+		goto Restart;
+		}
+	outbound_tokens.MoveInto(TokenList);
+}
+#endif
+#/*cut-nocpp*/
+#/*cut-cpp*/
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000284.html">[Zcplusplus-commits] r517 - in trunk: . tools
</A></li>
	<LI>Next message: <A HREF="000286.html">[Zcplusplus-commits] r519 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#285">[ date ]</a>
              <a href="thread.html#285">[ thread ]</a>
              <a href="subject.html#285">[ subject ]</a>
              <a href="author.html#285">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/zcplusplus-commits">More information about the Zcplusplus-commits
mailing list</a><br>
</body></html>
