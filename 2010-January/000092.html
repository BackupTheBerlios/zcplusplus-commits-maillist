<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Zcplusplus-commits] r325 - trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/zcplusplus-commits/2010-January/index.html" >
   <LINK REL="made" HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r325%20-%20trunk&In-Reply-To=%3C201001100937.o0A9bwsZ002591%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000091.html">
   <LINK REL="Next"  HREF="000093.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Zcplusplus-commits] r325 - trunk</H1>
    <B>zaimoni at mail.berlios.de</B> 
    <A HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r325%20-%20trunk&In-Reply-To=%3C201001100937.o0A9bwsZ002591%40sheep.berlios.de%3E"
       TITLE="[Zcplusplus-commits] r325 - trunk">zaimoni at mail.berlios.de
       </A><BR>
    <I>Sun Jan 10 10:37:58 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="000091.html">[Zcplusplus-commits] r324 - trunk
</A></li>
        <LI>Next message: <A HREF="000093.html">[Zcplusplus-commits] r326 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#92">[ date ]</a>
              <a href="thread.html#92">[ thread ]</a>
              <a href="subject.html#92">[ subject ]</a>
              <a href="author.html#92">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zaimoni
Date: 2010-01-10 10:37:43 +0100 (Sun, 10 Jan 2010)
New Revision: 325

Added:
   trunk/unsigned_var_int.cpp
   trunk/unsigned_var_int.hpp
Modified:
   trunk/CPUInfo.cpp
   trunk/CPUInfo.hpp
   trunk/CPreproc_autogen.cpp
   trunk/CSupport.cpp
Log:
internal fork: ZCC_LEGACY_FIXED_INT macro controls fallback to old target unsigned long long implementation.  Also, fix SVN build

Modified: trunk/CPUInfo.cpp
===================================================================
--- trunk/CPUInfo.cpp	2010-01-06 04:15:00 UTC (rev 324)
+++ trunk/CPUInfo.cpp	2010-01-10 09:37:43 UTC (rev 325)
@@ -1,5 +1,5 @@
 // CPUInfo.cpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #include &quot;CPUInfo.hpp&quot;
 #include &lt;algorithm&gt;
@@ -10,29 +10,25 @@
 
 void CPUInfo::_init()
 {
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM+1&gt; tmp;
-	unsigned_var_int tmp2;
 
 #define SET_MAXIMUM(A)	\
 	tmp.clear();	\
 	tmp.set((SUCCEED_OR_DIE(VM_MAX_BIT_PLATFORM&gt;=C_char_bit()*C_sizeof_##A()),C_char_bit()*C_sizeof_##A()));	\
 	tmp -= 1;	\
 	unsigned_maxima[std_int_##A-1] = tmp
+#else
+	unsigned_var_int tmp;
 
-	SET_MAXIMUM(char);
-	SET_MAXIMUM(short);
-	SET_MAXIMUM(int);
-	SET_MAXIMUM(long);
-	SET_MAXIMUM(long_long);
-
-#undef SET_MAXIMUM
 #define SET_MAXIMUM(A)	\
-	tmp2.set_bitcount(VM_MAX_BIT_PLATFORM+1);	\
-	tmp2.clear();	\
-	tmp2.set((SUCCEED_OR_DIE(VM_MAX_BIT_PLATFORM&gt;=C_char_bit()*C_sizeof_##A()),C_char_bit()*C_sizeof_##A()));	\
-	tmp2 -= 1;	\
-	tmp2.set_bitcount(VM_MAX_BIT_PLATFORM);	\
-	tmp2.MoveInto(unsigned_maxima_alt[std_int_##A-1])
+	tmp.set_bitcount(VM_MAX_BIT_PLATFORM+1);	\
+	tmp.clear();	\
+	tmp.set((SUCCEED_OR_DIE(VM_MAX_BIT_PLATFORM&gt;=C_char_bit()*C_sizeof_##A()),C_char_bit()*C_sizeof_##A()));	\
+	tmp -= 1;	\
+	tmp.set_bitcount(VM_MAX_BIT_PLATFORM);	\
+	tmp.MoveInto(unsigned_maxima[std_int_##A-1])
+#endif
 
 	SET_MAXIMUM(char);
 	SET_MAXIMUM(short);
@@ -45,12 +41,9 @@
 	size_t i = 0;
 	do	(signed_maxima[i] = unsigned_maxima[i]) &gt;&gt;= 1;
 	while(std_int_long_long&gt; ++i);
-
-	i = 0;
-	do	(signed_maxima_alt[i] = unsigned_maxima_alt[i]) &gt;&gt;= 1;
-	while(std_int_long_long&gt; ++i);
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 bool CPUInfo::trap_int(const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; src_int,std_int_enum machine_type) const
 {
 	switch(machine_type)
@@ -86,7 +79,45 @@
 	}
 	return false;
 }
+#else
+bool CPUInfo::trap_int(const unsigned_var_int&amp; src_int,std_int_enum machine_type) const
+{
+	switch(machine_type)
+	{
+	default: return false;
+	case std_int_int:
+	case std_int_long:
+	case std_int_long_long:;
+	}
+	const unsigned int bitcount = C_bit(machine_type);
+	const int target_bytecount = bitcount/CHAR_BIT;
+	const unsigned int target_bitcount = bitcount%CHAR_BIT;
+	assert(VM_MAX_BIT_PLATFORM&gt;=bitcount &amp;&amp; 1&lt;=bitcount);
 
+	switch(C_signed_int_representation())
+	{
+	case ones_complement:	{	// bitwise all-ones may be trap (-0)
+							if (0&lt;target_bytecount &amp;&amp; target_bytecount&gt;std::count(src_int.data(),src_int.data()+target_bytecount,UCHAR_MAX)) return false;
+							return 0==target_bitcount || (UCHAR_MAX&gt;&gt;(CHAR_BIT-target_bitcount))==((UCHAR_MAX&gt;&gt;(CHAR_BIT-target_bitcount)) &amp; src_int.data()[target_bytecount]);
+							}
+	case twos_complement:		// sign bit only set may be trap -(2^N)
+	case sign_and_magnitude:{	// sign bit only set may be trap (-0)
+							if (0==target_bitcount)
+								{
+								if (1&lt;target_bytecount &amp;&amp; target_bytecount-1&gt;std::count(src_int.data(),src_int.data()+(target_bytecount-1U),0)) return false;
+								return (1U&lt;&lt;(CHAR_BIT-1))==src_int.data()[target_bytecount-1];
+								}
+							else{
+								if (0&lt;target_bytecount &amp;&amp; target_bytecount&gt;std::count(src_int.data(),src_int.data()+target_bytecount,0)) return false;
+								return (1U&lt;&lt;(CHAR_BIT-1-target_bitcount))==((UCHAR_MAX&gt;&gt;(CHAR_BIT-target_bitcount)) &amp; src_int.data()[target_bytecount]);
+								}
+							}
+	}
+	return false;
+}
+#endif
+
+#ifdef ZCC_LEGACY_FIXED_INT
 void CPUInfo::signed_additive_inverse(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; src_int,std_int_enum machine_type) const
 {
 	assert(machine_type);
@@ -105,7 +136,28 @@
 		}
 	src_int = tmp;
 }
+#else
+void CPUInfo::signed_additive_inverse(unsigned_var_int&amp; src_int,std_int_enum machine_type) const
+{
+	assert(machine_type);
+	const int signed_int_rep = C_signed_int_representation();
+	if (sign_and_magnitude==signed_int_rep)
+		{
+		src_int.toggle(C_bit(machine_type)-1);
+		return;
+		}
+	unsigned_var_int tmp(unsigned_max(machine_type));
+	tmp -= src_int;
+	if (twos_complement==signed_int_rep)
+		{
+		tmp += 1;
+		tmp.mask_to(C_bit(machine_type));
+		}
+	tmp.MoveInto(src_int);
+}
+#endif
 
+#ifdef ZCC_LEGACY_FIXED_INT
 void CPUInfo::unsigned_additive_inverse(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; src_int,std_int_enum machine_type) const
 {
 	assert(machine_type);
@@ -115,7 +167,20 @@
 	tmp.mask_to(C_bit(machine_type));
 	src_int = tmp;
 }
+#else
+void CPUInfo::unsigned_additive_inverse(unsigned_var_int&amp; src_int,std_int_enum machine_type) const
+{
+	assert(machine_type);
+	assert(src_int&lt;=unsigned_max(machine_type));
+	unsigned_var_int tmp(0);
+	tmp.resize(src_int.size());
+	tmp -= src_int;
+	tmp.mask_to(C_bit(machine_type));
+	tmp.MoveInto(src_int);
+}
+#endif
 
+#ifdef ZCC_LEGACY_FIXED_INT
 bool CPUInfo::C_promote_integer(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; x,const promotion_info&amp; src_type, const promotion_info&amp; dest_type) const
 {
 	if (src_type.is_signed &amp;&amp; x.test(src_type.bitcount-1))
@@ -128,6 +193,20 @@
 		};
 	return dest_type.is_signed &amp;&amp; x.test(dest_type.bitcount-1);
 }
+#else
+bool CPUInfo::C_promote_integer(unsigned_var_int&amp; x,const promotion_info&amp; src_type, const promotion_info&amp; dest_type) const
+{
+	if (src_type.is_signed &amp;&amp; x.test(src_type.bitcount-1))
+		{
+		if (!dest_type.is_signed)
+			// unsigned integer result: C99 6.3.1.3p2 dictates modulo conversion to unsigned
+			C_cast_signed_to_unsigned(x,src_type.machine_type);
+		else if (dest_type.bitcount&gt;src_type.bitcount)
+			sign_extend(x,src_type.machine_type,dest_type.machine_type);
+		};
+	return dest_type.is_signed &amp;&amp; x.test(dest_type.bitcount-1);
+}
+#endif
 
 }	// end namespace virtual_machine
 

Modified: trunk/CPUInfo.hpp
===================================================================
--- trunk/CPUInfo.hpp	2010-01-06 04:15:00 UTC (rev 324)
+++ trunk/CPUInfo.hpp	2010-01-10 09:37:43 UTC (rev 325)
@@ -1,11 +1,14 @@
 // CPUInfo.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #ifndef CPUINFO_HPP
 #define CPUINFO_HPP
 
+#ifdef ZCC_LEGACY_FIXED_INT
 #include &quot;unsigned_fixed_int.hpp&quot;
+#else
 #include &quot;unsigned_var_int.hpp&quot;
+#endif
 
 namespace virtual_machine {
 
@@ -66,10 +69,13 @@
 	CPUInfo(const CPUInfo&amp; src);		// disable copy-construction
 	void operator=(const CPUInfo&amp; src);
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; unsigned_maxima[std_int_enum_max];
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; signed_maxima[std_int_enum_max];
-	unsigned_var_int unsigned_maxima_alt[std_int_enum_max];
-	unsigned_var_int signed_maxima_alt[std_int_enum_max];
+#else
+	unsigned_var_int unsigned_maxima[std_int_enum_max];
+	unsigned_var_int signed_maxima[std_int_enum_max];
+#endif
 
 	const unsigned short char_bit;
 	const unsigned short sizeof_short;
@@ -113,15 +119,26 @@
 																	(std_int_long==x) ? C_char_bit()*C_sizeof_long() : C_char_bit()*C_sizeof_long_long() ;}
 
 	signed_int_rep C_signed_int_representation() const {return (signed_int_rep)(signed_int_representation &amp; 3U);};
+#ifdef ZCC_LEGACY_FIXED_INT
 	bool trap_int(const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; src_int,std_int_enum machine_type) const;
 	void signed_additive_inverse(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; src_int,std_int_enum machine_type) const;
 	void unsigned_additive_inverse(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; src_int,std_int_enum machine_type) const;
 	void sign_extend(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; src_int,std_int_enum machine_type_from,std_int_enum machine_type_to) const
+#else
+	bool trap_int(const unsigned_var_int&amp; src_int,std_int_enum machine_type) const;
+	void signed_additive_inverse(unsigned_var_int&amp; src_int,std_int_enum machine_type) const;
+	void unsigned_additive_inverse(unsigned_var_int&amp; src_int,std_int_enum machine_type) const;
+	void sign_extend(unsigned_var_int&amp; src_int,std_int_enum machine_type_from,std_int_enum machine_type_to) const
+#endif
 		{
 		signed_additive_inverse(src_int,machine_type_from);
 		signed_additive_inverse(src_int,machine_type_to);
 		};
+#ifdef ZCC_LEGACY_FIXED_INT
 	void C_cast_signed_to_unsigned(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; src_int,std_int_enum machine_type) const
+#else
+	void C_cast_signed_to_unsigned(unsigned_var_int&amp; src_int,std_int_enum machine_type) const
+#endif
 		{	// C99 6.3.1.3p2 dictates modulo conversion to unsigned
 		if (twos_complement!=C_signed_int_representation() &amp;&amp; src_int.test(C_bit(machine_type)-1))
 			{
@@ -136,13 +153,24 @@
 	// use different functions for ptrdiff_t and size_t to future-proof (e.g., DOS has ptrdiff 2 bytes but can go larger than that in object size in some memory models)
 	std_int_enum ptrdiff_t_type() const {return (std_int_enum)((signed_int_representation&gt;&gt;7) &amp; 7U);};
 	std_int_enum size_t_type() const {return (std_int_enum)((signed_int_representation&gt;&gt;7) &amp; 7U);};
+#ifdef ZCC_LEGACY_FIXED_INT
 	const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; unsigned_max(std_int_enum x) const {return unsigned_maxima[x-1];};
 	template&lt;std_int_enum x&gt; const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; unsigned_max() const {return unsigned_maxima[x-1];}
 	const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; signed_max(std_int_enum x) const {return signed_maxima[x-1];};
 	template&lt;std_int_enum x&gt; const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; signed_max() const {return signed_maxima[x-1];}
+#else
+	const unsigned_var_int&amp; unsigned_max(std_int_enum x) const {return unsigned_maxima[x-1];};
+	template&lt;std_int_enum x&gt; const unsigned_var_int&amp; unsigned_max() const {return unsigned_maxima[x-1];}
+	const unsigned_var_int&amp; signed_max(std_int_enum x) const {return signed_maxima[x-1];};
+	template&lt;std_int_enum x&gt; const unsigned_var_int&amp; signed_max() const {return signed_maxima[x-1];}
+#endif
 
 	// return value is weird...it's true iff the promoted x is a negative numeral
+#ifdef ZCC_LEGACY_FIXED_INT
 	bool C_promote_integer(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; x,const promotion_info&amp; src_type, const promotion_info&amp; dest_type) const;
+#else
+	bool C_promote_integer(unsigned_var_int&amp; x,const promotion_info&amp; src_type, const promotion_info&amp; dest_type) const;
+#endif
 };
 
 #undef SELECT_TARGET_WCHAR_T

Modified: trunk/CPreproc_autogen.cpp
===================================================================
--- trunk/CPreproc_autogen.cpp	2010-01-06 04:15:00 UTC (rev 324)
+++ trunk/CPreproc_autogen.cpp	2010-01-10 09:37:43 UTC (rev 325)
@@ -1,5 +1,5 @@
 // CPreproc_autogen.cpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 // class CPreprocessor support for autogenerating headers for arbitrary machine targets.
 
 #include &quot;CPreproc.hpp&quot;
@@ -441,7 +441,11 @@
 		if (1==target_machine.C_sizeof_int()) tmp[LIMITS_CHAR_MAX_LINE]-&gt;append('U');
 		}
 	// signed character limits
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; s_max(target_machine.signed_max&lt;virtual_machine::std_int_char&gt;());
+#else
+	unsigned_var_int s_max(target_machine.signed_max&lt;virtual_machine::std_int_char&gt;());
+#endif
 	tmp[LIMITS_SCHAR_MAX_LINE]-&gt;append(z_ucharint_toa(s_max,buf+1,10)-1);
 	if (target_machine.char_is_signed_char()) tmp[LIMITS_CHAR_MAX_LINE]-&gt;append(buf);
 	const bool twos_complement_non_trapping = virtual_machine::twos_complement==target_machine.C_signed_int_representation() &amp;&amp; !bool_options[boolopt::int_traps];
@@ -711,7 +715,11 @@
 	const bool target_is_twos_complement = virtual_machine::twos_complement==target_machine.C_signed_int_representation();
 	char signed_min_metabuf[virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+4)] = &quot;&quot;;
 	char* signed_min_buf[virtual_machine::std_int_enum_max] = {signed_min_metabuf, signed_min_metabuf+(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+2*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+3*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+4*(2+(VM_MAX_BIT_PLATFORM/3)+2)};
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; tmp_VM;
+#else
+	unsigned_var_int tmp_VM;
+#endif
 	if (target_is_twos_complement &amp;&amp; !bool_options[boolopt::int_traps])
 		{
 		*signed_min_buf[0] = '-';

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-01-06 04:15:00 UTC (rev 324)
+++ trunk/CSupport.cpp	2010-01-10 09:37:43 UTC (rev 325)
@@ -2450,13 +2450,26 @@
 	return (ub&lt;hex_len) ? ub : hex_len;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; eval_hex_escape(const char* src, size_t src_len)
+#else
+static unsigned_var_int eval_hex_escape(const char* src, size_t src_len)
+#endif
 {
 	assert(NULL!=src);
 	assert(0&lt;src_len);
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; tmp(0);
+#else
+	unsigned_var_int tmp;
+	tmp.set_bitcount(VM_MAX_BIT_PLATFORM);
+#endif
 #ifndef NDEBUG
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; uchar_max(target_machine-&gt;unsigned_max&lt;virtual_machine::std_int_long_long&gt;());
+#else
+	unsigned_var_int uchar_max(target_machine-&gt;unsigned_max&lt;virtual_machine::std_int_long_long&gt;());
+#endif
 	uchar_max &gt;&gt;= 4;
 #endif
 	do	{
@@ -2626,7 +2639,11 @@
 		}
 	if ('&quot;' != *(x++)) return false;
 	if (0 == --x_len) return true;	// empty string is legal
+#ifdef ZCC_LEGACY_FIXED_INT
 	const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; uchar_max = target_machine-&gt;unsigned_max((wide_string) ? target_machine-&gt;UNICODE_wchar_t() : virtual_machine::std_int_char);
+#else
+	const unsigned_var_int&amp; uchar_max = target_machine-&gt;unsigned_max((wide_string) ? target_machine-&gt;UNICODE_wchar_t() : virtual_machine::std_int_char);
+#endif
 
 	size_t i = 0;
 	do	{
@@ -2653,7 +2670,11 @@
 		}
 	if ('\'' != *(x++)) return false;
 	if (0 == --x_len) return false;	// empty character literal is illegal
+#ifdef ZCC_LEGACY_FIXED_INT
 	const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; uchar_max = target_machine-&gt;unsigned_max((wide_string) ? target_machine-&gt;UNICODE_wchar_t() : virtual_machine::std_int_char);
+#else
+	const unsigned_var_int&amp; uchar_max = target_machine-&gt;unsigned_max((wide_string) ? target_machine-&gt;UNICODE_wchar_t() : virtual_machine::std_int_char);
+#endif
 
 	size_t i = 0;
 	do	{
@@ -2967,13 +2988,23 @@
 	{
 	default: return false;
 	case virtual_machine::ones_complement:		{
+#ifdef ZCC_LEGACY_FIXED_INT
 												unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; tmp(0);
+#else
+												unsigned_var_int tmp;
+												tmp.set_bitcount(VM_MAX_BIT_PLATFORM);
+#endif
 												if (VM_MAX_BIT_PLATFORM&gt;target_machine-&gt;C_char_bit()) tmp.set(target_machine-&gt;C_char_bit());
 												tmp -= 1;
 												return tmp==result;
 												}
 	case virtual_machine::sign_and_magnitude:	{
+#ifdef ZCC_LEGACY_FIXED_INT
 												unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; tmp(0);
+#else
+												unsigned_var_int tmp;
+												tmp.set_bitcount(VM_MAX_BIT_PLATFORM);
+#endif
 												tmp.set(target_machine-&gt;C_char_bit()-1);
 												return tmp==result;
 												}
@@ -4095,13 +4126,24 @@
 	if (0&lt;offset) src.DeleteNSlotsAt&lt;0&gt;(offset,src.size&lt;0&gt;()-offset);
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 bool convert_to(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; dest,const C_PPIntCore&amp; src)
+#else
+bool convert_to(unsigned_var_int&amp; dest,const C_PPIntCore&amp; src)
+#endif
 {
 	assert(8==src.radix || 10==src.radix || 16==src.radix);
 	assert(NULL!=src.ptr &amp;&amp; 0&lt;src.digit_span);
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; alt_radix(src.radix);
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; strict_ub;
+#else
+	unsigned_var_int alt_radix(src.radix);
+	unsigned_var_int strict_ub;
+	strict_ub.set_bitcount(VM_MAX_BIT_PLATFORM);
+	alt_radix.set_bitcount(VM_MAX_BIT_PLATFORM);
+#endif
 	const char* target = src.ptr;
 	size_t target_len = src.digit_span;
 
@@ -4119,6 +4161,7 @@
 		}
 
 	const char* const end = target+target_len;
+	dest.set_bitcount(VM_MAX_BIT_PLATFORM);
 	dest.clear();
 	dest += InterpretHexadecimalDigit(*target);
 	while(++target!=end)
@@ -4131,9 +4174,17 @@
 }
 
 // forward-declare to handle recursion
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool C99_intlike_literal_to_VM(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; dest, const parse_tree&amp; src);
+#else
+static bool C99_intlike_literal_to_VM(unsigned_var_int&amp; dest, const parse_tree&amp; src);
+#endif
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool _C99_intlike_literal_to_VM(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; dest, const parse_tree&amp; src)
+#else
+static bool _C99_intlike_literal_to_VM(unsigned_var_int&amp; dest, const parse_tree&amp; src)
+#endif
 {
 	assert(C_TYPE::INTEGERLIKE!=src.type_code.base_type_index);
 
@@ -4148,8 +4199,13 @@
 			assert(old.bitcount&gt;=lhs.bitcount);
 			if (lhs.is_signed)
 				{
+#ifdef ZCC_LEGACY_FIXED_INT
 				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_int;
 				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+#else
+				unsigned_var_int lhs_int;
+				unsigned_var_int rhs_int;
+#endif
 				if (	C99_intlike_literal_to_VM(lhs_int,*src.data&lt;1&gt;())
 					&amp;&amp;	C99_intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;()))
 					{
@@ -4179,6 +4235,7 @@
 	if (C_TESTFLAG_CHAR_LITERAL &amp; src.index_tokens[0].flags)
 		{
 		dest = EvalCharacterLiteral(src.index_tokens[0].token.first,src.index_tokens[0].token.second);
+		dest.set_bitcount(VM_MAX_BIT_PLATFORM);
 		return true;
 		}	
 
@@ -4189,18 +4246,24 @@
 	return true;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool _CPP_intlike_literal_to_VM(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; dest, const parse_tree&amp; src)
+#else
+static bool _CPP_intlike_literal_to_VM(unsigned_var_int&amp; dest, const parse_tree&amp; src)
+#endif
 {
 	//! \todo: similar code for handling LLONG_MIN as above.  Need that only for zcc; can't test in preprocessor as the true reserved word won't make it this far.
 	if (!src.is_atomic()) return false;
 	// intercept true, false
 	if 		(token_is_string&lt;4&gt;(src.index_tokens[0].token,&quot;true&quot;))
 		{
+		dest.set_bitcount(VM_MAX_BIT_PLATFORM);
 		dest = 1;
 		return true;
 		}
 	else if (token_is_string&lt;5&gt;(src.index_tokens[0].token,&quot;false&quot;))
 		{
+		dest.set_bitcount(VM_MAX_BIT_PLATFORM);
 		dest.clear();
 		return true;
 		};
@@ -4232,7 +4295,11 @@
 	return ret;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool C99_intlike_literal_to_VM(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; dest, const parse_tree&amp; src)
+#else
+static bool C99_intlike_literal_to_VM(unsigned_var_int&amp; dest, const parse_tree&amp; src)
+#endif
 {
 	const POD_pair&lt;const parse_tree*,bool&gt; actual = _find_intlike_literal(&amp;src);
 
@@ -4251,7 +4318,11 @@
 	return true;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool CPP_intlike_literal_to_VM(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; dest, const parse_tree&amp; src)
+#else
+static bool CPP_intlike_literal_to_VM(unsigned_var_int&amp; dest, const parse_tree&amp; src)
+#endif
 {
 	const POD_pair&lt;const parse_tree*,bool&gt; actual = _find_intlike_literal(&amp;src);
 
@@ -4279,10 +4350,18 @@
  * \return -1 : can't decide quickly whether this is a null 
  *         pointer constant
  */
+#ifdef ZCC_LEGACY_FIXED_INT
 int is_null_pointer_constant(const parse_tree&amp; src, func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+int is_null_pointer_constant(const parse_tree&amp; src, func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (!converts_to_integerlike(src.type_code)) return 0;
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; tmp;
+#else
+	unsigned_var_int tmp;
+#endif
 	if (intlike_literal_to_VM(tmp,src)) return tmp==0;
 	return -1;
 }
@@ -4311,7 +4390,11 @@
 			src.type_code.set_type(C_TYPE::INTEGERLIKE);
 			C_PPIntCore parse_tmp;
 			ZAIMONI_PASSTHROUGH_ASSERT(C_PPIntCore::is(src.index_tokens[0].token.first,src.index_tokens[0].token.second,parse_tmp));
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; tmp;
+#else
+			unsigned_var_int tmp;
+#endif
 			const unsigned char type_hint = parse_tmp.hinted_type;
 			const bool no_signed = 1==type_hint%2;
 			const bool no_unsigned = !no_signed &amp;&amp; 10==parse_tmp.radix;
@@ -5147,7 +5230,11 @@
 // can't do much syntax-checking or immediate-evaluation here because of binary +/-
 // unary +/- syntax checking out out of place as it's needed by all of the unary operators
 // return code is true for success, false for memory failure
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool VM_to_token(const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; src_int,const size_t base_type_index,POD_pair&lt;char*,lex_flags&gt;&amp; dest)
+#else
+static bool VM_to_token(const unsigned_var_int&amp; src_int,const size_t base_type_index,POD_pair&lt;char*,lex_flags&gt;&amp; dest)
+#endif
 {
 	const char* const suffix = literal_suffix(base_type_index);
 	char buf[(VM_MAX_BIT_PLATFORM/3)+4];	// null-termination: 1 byte; 3 bytes for type hint
@@ -5165,7 +5252,11 @@
 }
 
 // return code is true for success, false for memory failure
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool VM_to_literal(parse_tree&amp; dest, const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; src_int,const parse_tree&amp; src,const type_system&amp; types)
+#else
+static bool VM_to_literal(parse_tree&amp; dest, const unsigned_var_int&amp; src_int,const parse_tree&amp; src,const type_system&amp; types)
+#endif
 {
 	POD_pair&lt;char*,lex_flags&gt; new_token;
 	if (!VM_to_token(src_int,src.type_code.base_type_index,new_token)) return false;
@@ -5224,7 +5315,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_unary_minus(parse_tree&amp; src, const type_system&amp; types,func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_unary_minus(parse_tree&amp; src, const type_system&amp; types,func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(is_C99_unary_operator_expression&lt;'-'&gt;(src));
 	bool is_true = false;
@@ -5240,7 +5335,11 @@
 		{	// unsigned...we're fine
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
 		const type_spec old_type = src.type_code;
+#ifdef ZCC_LEGACY_FIXED_INT
 		unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int;
+#else
+		unsigned_var_int res_int;
+#endif
 		intlike_literal_to_VM(res_int,*src.data&lt;2&gt;());
 		target_machine-&gt;unsigned_additive_inverse(res_int,machine_type);
 
@@ -5543,7 +5642,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool int_has_trapped(parse_tree&amp; src,const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; src_int,bool hard_error)
+#else
+static bool int_has_trapped(parse_tree&amp; src,const unsigned_var_int&amp; src_int,bool hard_error)
+#endif
 {
 	assert(C_TYPE::INT&lt;=src.type_code.base_type_index &amp;&amp; C_TYPE::INTEGERLIKE&gt;src.type_code.base_type_index);
 	// check for trap representation for signed types
@@ -5653,7 +5756,11 @@
 // eventually recover enough memory for this to complete.
 static bool construct_twos_complement_int_min(parse_tree&amp; dest, const type_system&amp; types, const virtual_machine::std_int_enum machine_type, const parse_tree&amp; src_loc)
 {
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; tmp_int(target_machine-&gt;signed_max(machine_type));
+#else
+	unsigned_var_int tmp_int(target_machine-&gt;signed_max(machine_type));	// of course, throwing constructor gets in the way
+#endif
 	parse_tree* const tmp = _new_buffer&lt;parse_tree&gt;(1);	// XXX we recycle this variable later
 	if (NULL==tmp) return false;
 	if (!VM_to_literal(*tmp,tmp_int,src_loc,types)) return false;
@@ -5705,11 +5812,19 @@
 	return true;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_bitwise_compl(parse_tree&amp; src, const type_system&amp; types,bool hard_error,func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_complement_expression,func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_bitwise_compl(parse_tree&amp; src, const type_system&amp; types,bool hard_error,func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_complement_expression,func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(is_bitwise_complement_expression(src));
 	assert(converts_to_integerlike(src.data&lt;2&gt;()-&gt;type_code));
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int;
+#else
+	unsigned_var_int res_int;
+#endif
 	if (intlike_literal_to_VM(res_int,*src.data&lt;2&gt;())) 
 		{
 		const type_spec old_type = src.type_code;
@@ -6134,7 +6249,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_mult_expression(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_mult_expression(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(is_C99_mult_operator_expression&lt;'*'&gt;(src));
 
@@ -6163,8 +6282,13 @@
 		return true;
 		};
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int;
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+#else
+	unsigned_var_int res_int;
+	unsigned_var_int rhs_int;
+#endif
 	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data&lt;1&gt;());
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;());
 	if (lhs_converted &amp;&amp; 1==res_int)
@@ -6192,9 +6316,15 @@
 		const bool rhs_negative = target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
 		if (old.is_signed)
 			{	// signed integer result: overflow is undefined
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_test(res_int);
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_test(rhs_int);
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; ub(target_machine-&gt;signed_max(old.machine_type));
+#else
+			unsigned_var_int lhs_test(res_int);
+			unsigned_var_int rhs_test(rhs_int);
+			unsigned_var_int ub(target_machine-&gt;signed_max(old.machine_type));
+#endif
 			const bool tweak_ub = rhs_negative!=lhs_negative &amp;&amp; virtual_machine::twos_complement==target_machine-&gt;C_signed_int_representation() &amp;&amp; !bool_options[boolopt::int_traps];
 			if (rhs_negative) target_machine-&gt;signed_additive_inverse(rhs_test,old.machine_type);
 			if (lhs_negative) target_machine-&gt;signed_additive_inverse(lhs_test,old.machine_type);
@@ -6247,7 +6377,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_div_expression(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_div_expression(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(is_C99_mult_operator_expression&lt;'/'&gt;(src));
 
@@ -6285,8 +6419,13 @@
 		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
 		};
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int;
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+#else
+	unsigned_var_int res_int;
+	unsigned_var_int rhs_int;
+#endif
 	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data&lt;1&gt;());
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;());
 	if (rhs_converted &amp;&amp; rhs_int==1)
@@ -6311,9 +6450,15 @@
 		const bool rhs_negative = target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
 		if (old.is_signed)
 			{	// signed integer result
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_test(res_int);
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_test(rhs_int);
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; ub(target_machine-&gt;signed_max(old.machine_type));
+#else
+			unsigned_var_int lhs_test(res_int);
+			unsigned_var_int rhs_test(rhs_int);
+			unsigned_var_int ub(target_machine-&gt;signed_max(old.machine_type));
+#endif
 			if (rhs_negative) target_machine-&gt;signed_additive_inverse(rhs_test,old.machine_type);
 			if (lhs_negative) target_machine-&gt;signed_additive_inverse(lhs_test,old.machine_type);
 			if (rhs_negative!=lhs_negative &amp;&amp; virtual_machine::twos_complement==target_machine-&gt;C_signed_int_representation()) ub += 1;
@@ -6341,7 +6486,11 @@
 			bool round_away = false;
 			if (rhs_negative!=lhs_negative &amp;&amp; bool_options[boolopt::int_neg_div_rounds_away_from_zero])
 				{
+#ifdef ZCC_LEGACY_FIXED_INT
 				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_mod_test(lhs_test);
+#else
+				unsigned_var_int lhs_mod_test(lhs_test);
+#endif
 				lhs_mod_test %= rhs_test;
 				round_away = 0!=lhs_mod_test;
 				}
@@ -6384,7 +6533,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_mod_expression(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_mod_expression(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(is_C99_mult_operator_expression&lt;'%'&gt;(src));
 
@@ -6422,8 +6575,13 @@
 		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
 		};
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int;
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+#else
+	unsigned_var_int res_int;
+	unsigned_var_int rhs_int;
+#endif
 	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data&lt;1&gt;());
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;());
 	if (rhs_converted &amp;&amp; rhs_int==1)
@@ -6450,9 +6608,15 @@
 		const bool rhs_negative = target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
 		if (old.is_signed)
 			{	// signed integer result
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_test(res_int);
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_test(rhs_int);
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; ub(target_machine-&gt;signed_max(old.machine_type));
+#else
+			unsigned_var_int lhs_test(res_int);
+			unsigned_var_int rhs_test(rhs_int);
+			unsigned_var_int ub(target_machine-&gt;signed_max(old.machine_type));
+#endif
 			if (rhs_negative) target_machine-&gt;signed_additive_inverse(rhs_test,old.machine_type);
 			if (lhs_negative) target_machine-&gt;signed_additive_inverse(lhs_test,old.machine_type);
 			if (rhs_negative!=lhs_negative &amp;&amp; virtual_machine::twos_complement==target_machine-&gt;C_signed_int_representation()) ub += 1;
@@ -6745,7 +6909,11 @@
 
 // this one hides a slight inefficiency: negative literals take 2 dynamic memory allocations, positive literals take one
 // return code is true for success, false for memory failure
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool VM_to_signed_literal(parse_tree&amp; x,const bool is_negative, const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; src_int,const parse_tree&amp; src,const type_system&amp; types)
+#else
+static bool VM_to_signed_literal(parse_tree&amp; x,const bool is_negative, const unsigned_var_int&amp; src_int,const parse_tree&amp; src,const type_system&amp; types)
+#endif
 {
 	if (is_negative)
 		{
@@ -6759,7 +6927,11 @@
 	return true;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_add_expression(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_add_expression(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(is_C99_add_operator_expression&lt;'+'&gt;(src));
 
@@ -6791,8 +6963,13 @@
 				src.type_code = old_type;
 				return true;
 				};
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int;
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+#else
+			unsigned_var_int res_int;
+			unsigned_var_int rhs_int;
+#endif
 			const promote_aux old(old_type.base_type_index);
 			const promote_aux lhs(src.data&lt;1&gt;()-&gt;type_code.base_type_index);
 			assert(old.bitcount&gt;=lhs.bitcount);
@@ -6806,9 +6983,15 @@
 				{
 				if (old.is_signed)
 					{	// signed integer result
+#ifdef ZCC_LEGACY_FIXED_INT
 					unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_test(res_int);
 					unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_test(rhs_int);
 					unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; ub(target_machine-&gt;signed_max(old.machine_type));
+#else
+					unsigned_var_int lhs_test(res_int);
+					unsigned_var_int rhs_test(rhs_int);
+					unsigned_var_int ub(target_machine-&gt;signed_max(old.machine_type));
+#endif
 					bool result_is_negative = false;
 					if (rhs_negative) target_machine-&gt;signed_additive_inverse(rhs_test,old.machine_type);
 					if (lhs_negative) target_machine-&gt;signed_additive_inverse(lhs_test,old.machine_type);
@@ -6905,7 +7088,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_sub_expression(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_sub_expression(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(is_C99_add_operator_expression&lt;'-'&gt;(src));
 
@@ -6941,8 +7128,13 @@
 				src.type_code = old_type;
 				return true;
 				}
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int;
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+#else
+			unsigned_var_int res_int;
+			unsigned_var_int rhs_int;
+#endif
 			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data&lt;1&gt;());
 			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;());
 			if (lhs_converted &amp;&amp; rhs_converted)
@@ -6958,9 +7150,15 @@
 				const bool rhs_negative = target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
 				if (old.is_signed)
 					{	// signed integer result
+#ifdef ZCC_LEGACY_FIXED_INT
 					unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_test(res_int);
 					unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_test(rhs_int);
 					unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; ub(target_machine-&gt;signed_max(old.machine_type));
+#else
+					unsigned_var_int lhs_test(res_int);
+					unsigned_var_int rhs_test(rhs_int);
+					unsigned_var_int ub(target_machine-&gt;signed_max(old.machine_type));
+#endif
 					bool result_is_negative = false;
 					if (rhs_negative) target_machine-&gt;signed_additive_inverse(rhs_test,old.machine_type);
 					if (lhs_negative) target_machine-&gt;signed_additive_inverse(lhs_test,old.machine_type);
@@ -7059,7 +7257,11 @@
 
 // +: either both are arithmetic, or one is raw pointer and one is integer
 // -: either both are arithmetic, or both are compatible raw pointer, or left is raw pointer and right is integer
+#ifdef ZCC_LEGACY_FIXED_INT
 static void C_CPP_add_expression_easy_syntax_check(parse_tree&amp; src,const type_system&amp; types,func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+static void C_CPP_add_expression_easy_syntax_check(parse_tree&amp; src,const type_system&amp; types,func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert((C99_ADD_SUBTYPE_PLUS==src.subtype &amp;&amp; is_C99_add_operator_expression&lt;'+'&gt;(src)) || (C99_ADD_SUBTYPE_MINUS==src.subtype &amp;&amp; is_C99_add_operator_expression&lt;'-'&gt;(src)));
 	BOOST_STATIC_ASSERT(1==C99_ADD_SUBTYPE_MINUS-C99_ADD_SUBTYPE_PLUS);
@@ -7304,7 +7506,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_shift(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_shift(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(converts_to_integerlike(src.data&lt;1&gt;()-&gt;type_code));
 	assert(converts_to_integerlike(src.data&lt;2&gt;()-&gt;type_code));
@@ -7329,7 +7535,11 @@
 			}
 		};
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+#else
+	unsigned_var_int rhs_int;
+#endif
 	if (intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;()))
 		{
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(old_type.base_type_index);
@@ -7350,7 +7560,11 @@
 			};
 		if (undefined_behavior) return false;
 
+#ifdef ZCC_LEGACY_FIXED_INT
 		unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int;
+#else
+		unsigned_var_int res_int;
+#endif
 		if (intlike_literal_to_VM(res_int,*src.data&lt;1&gt;()))
 			{
 			// note that incoming negative signed integers are not handled by this code path
@@ -7475,14 +7689,23 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_relation_expression(parse_tree&amp; src, const type_system&amp; types,func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_relation_expression(parse_tree&amp; src, const type_system&amp; types,func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_GT-C99_RELATION_SUBTYPE_LT);
 	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_LTE-C99_RELATION_SUBTYPE_GT);
 	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_GTE-C99_RELATION_SUBTYPE_LTE);
 	assert(C99_RELATION_SUBTYPE_LT&lt;=src.subtype &amp;&amp; C99_RELATION_SUBTYPE_GTE&gt;=src.subtype);
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_int;
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+#else
+	unsigned_var_int lhs_int;
+	unsigned_var_int rhs_int;
+#endif
 
 	const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data&lt;1&gt;());
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;());
@@ -7664,12 +7887,21 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_equality_expression(parse_tree&amp; src, const type_system&amp; types, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_equality_expression(parse_tree&amp; src, const type_system&amp; types, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {	
 	BOOST_STATIC_ASSERT(1==C99_EQUALITY_SUBTYPE_NEQ-C99_EQUALITY_SUBTYPE_EQ);
 	assert(C99_EQUALITY_SUBTYPE_EQ&lt;=src.subtype &amp;&amp; C99_EQUALITY_SUBTYPE_NEQ&gt;=src.subtype);
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_int;
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+#else
+	unsigned_var_int lhs_int;
+	unsigned_var_int rhs_int;
+#endif
 	const unsigned int integer_literal_case = 	  converts_to_integer(src.data&lt;1&gt;()-&gt;type_code)
 											+	2*converts_to_integer(src.data&lt;2&gt;()-&gt;type_code);
 	const bool is_equal_op = src.subtype==C99_EQUALITY_SUBTYPE_EQ;
@@ -7892,7 +8124,11 @@
 	return false;
 }
 
+#if ZCC_LEGACY_FIXED_INT
 static bool eval_bitwise_AND(parse_tree&amp; src, const type_system&amp; types,bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_bitwise_AND(parse_tree&amp; src, const type_system&amp; types,bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(converts_to_integerlike(src.data&lt;1&gt;()-&gt;type_code));
 	assert(converts_to_integerlike(src.data&lt;2&gt;()-&gt;type_code));
@@ -7921,12 +8157,21 @@
 		return true;
 		};
 
+#if ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_int;
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+#else
+	unsigned_var_int lhs_int;
+	unsigned_var_int rhs_int;
+#endif
 	if (intlike_literal_to_VM(lhs_int,*src.data&lt;1&gt;()) &amp;&amp; intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;()))
 		{
 		const promote_aux old(old_type.base_type_index);
+#if ZCC_LEGACY_FIXED_INT
 		unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int(lhs_int);
+#else
+		unsigned_var_int res_int(lhs_int);
+#endif
 		res_int &amp;= rhs_int;
 
 		// check for trap representation for signed types
@@ -8067,7 +8312,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_bitwise_XOR(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_bitwise_XOR(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(converts_to_integerlike(src.data&lt;1&gt;()-&gt;type_code));
 	assert(converts_to_integerlike(src.data&lt;2&gt;()-&gt;type_code));
@@ -8096,13 +8345,22 @@
 			}
 		};
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_int;
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+#else
+	unsigned_var_int lhs_int;
+	unsigned_var_int rhs_int;
+#endif
 	if (intlike_literal_to_VM(lhs_int,*src.data&lt;1&gt;()) &amp;&amp; intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;()))
 		{
 		const type_spec old_type = src.type_code;
 		const promote_aux old(old_type.base_type_index);
+#ifdef ZCC_LEGACY_FIXED_INT
 		unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int(lhs_int);
+#else
+		unsigned_var_int res_int(lhs_int);
+#endif
 		res_int ^= rhs_int;
 //		res_int.mask_to(target_machine-&gt;C_bit(machine_type));	// shouldn't need this
 
@@ -8235,7 +8493,11 @@
 	return false;
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static bool eval_bitwise_OR(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+static bool eval_bitwise_OR(parse_tree&amp; src, const type_system&amp; types, bool hard_error, func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	assert(converts_to_integerlike(src.data&lt;1&gt;()-&gt;type_code));
 	assert(converts_to_integerlike(src.data&lt;2&gt;()-&gt;type_code));
@@ -8264,13 +8526,22 @@
 			}
 		};
 
+#ifdef ZCC_LEGACY_FIXED_INT
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_int;
 	unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+#else
+	unsigned_var_int lhs_int;
+	unsigned_var_int rhs_int;
+#endif
 	if (intlike_literal_to_VM(lhs_int,*src.data&lt;1&gt;()) &amp;&amp; intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;()))
 		{
 		const type_spec old_type = src.type_code;
 
+#ifdef ZCC_LEGACY_FIXED_INT
 		unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int(lhs_int);
+#else
+		unsigned_var_int res_int(lhs_int);
+#endif
 		res_int |= rhs_int;
 //		res_int.mask_to(target_machine-&gt;C_bit(machine_type));	// shouldn't need this
 		if 		(res_int==lhs_int)
@@ -9355,7 +9626,11 @@
 #endif
 }
 
+#ifdef ZCC_LEGACY_FIXED_INT
 static void eval_string_literal_deref(parse_tree&amp; src,const type_system&amp; types,const POD_pair&lt;const char*,size_t&gt;&amp; str_lit,const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; tmp,bool is_negative,bool index_src_is_char)
+#else
+static void eval_string_literal_deref(parse_tree&amp; src,const type_system&amp; types,const POD_pair&lt;const char*,size_t&gt;&amp; str_lit,const unsigned_var_int&amp; tmp,bool is_negative,bool index_src_is_char)
+#endif
 {
 	const size_t strict_ub = LengthOfCStringLiteral(str_lit.first,str_lit.second);
 	// C99 6.2.6.2p3 -0 is not actually allowed to generate the bitpattern -0, so no trapping
@@ -9416,7 +9691,11 @@
 eval_array_deref(parse_tree&amp; src,const type_system&amp; types,
 				 func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 				 func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type literal_converts_to_integer,
+#ifdef ZCC_LEGACY_FIXED_INT
 				 func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+				 func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (!is_array_deref(src)) return false;
 	// crunch __[...]
@@ -9429,7 +9708,11 @@
 										(C_TESTFLAG_STRING_LITERAL==src.data&lt;1&gt;()-&gt;index_tokens[0].flags) ? 1 : UINT_MAX;
 		if (UINT_MAX&gt;str_index)
 			{
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; tmp; 
+#else
+			unsigned_var_int tmp; 
+#endif
 			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index))) return false;
 			const size_t promoted_type = default_promote_type(src.type_code.base_type_index);
 			const virtual_machine::std_int_enum machine_type = (virtual_machine::std_int_enum)((promoted_type-C_TYPE::INT)/2+virtual_machine::std_int_int);
@@ -9454,7 +9737,11 @@
 			//! \test default/Pass_if_zero.h
 			//! \test default/Pass_if_nonzero.hpp
 			//! \test default/Pass_if_nonzero.h
+#ifdef ZCC_LEGACY_FIXED_INT
 			eval_string_literal_deref(src,types,src.data&lt;2&gt;()-&gt;index_tokens[0].token,unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;(0),false,false);
+#else
+			eval_string_literal_deref(src,types,src.data&lt;2&gt;()-&gt;index_tokens[0].token,unsigned_var_int(0),false,false);
+#endif
 			return true;
 			}
 		}
@@ -9477,7 +9764,11 @@
 static bool eval_bitwise_compl(	parse_tree&amp; src, const type_system&amp; types,
 								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 								func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_complement_expression,
+#ifdef ZCC_LEGACY_FIXED_INT
 								func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+								func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_bitwise_complement_expression(src))
 		{
@@ -9501,7 +9792,11 @@
 static bool eval_unary_minus(parse_tree&amp; src, const type_system&amp; types,
 							 func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							 func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							 func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+							 func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_unary_operator_expression&lt;'-'&gt;(src))
 		{
@@ -9514,7 +9809,11 @@
 static bool eval_mult_expression(parse_tree&amp; src,const type_system&amp; types,
 								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 								func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 								func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+								func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_mult_operator_expression&lt;'*'&gt;(src))
 		{
@@ -9528,7 +9827,11 @@
 static bool eval_div_expression(parse_tree&amp; src,const type_system&amp; types,
 								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 								func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 								func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+								func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_mult_operator_expression&lt;'/'&gt;(src))
 		{
@@ -9542,7 +9845,11 @@
 static bool eval_mod_expression(parse_tree&amp; src,const type_system&amp; types,
 								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 								func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 								func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+								func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_mult_operator_expression&lt;'%'&gt;(src))
 		{
@@ -9553,10 +9860,15 @@
 	return false;
 }
 
+
 static bool eval_add_expression(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_add_operator_expression&lt;'+'&gt;(src))
 		{
@@ -9570,7 +9882,11 @@
 static bool eval_sub_expression(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_add_operator_expression&lt;'-'&gt;(src))
 		{
@@ -9584,7 +9900,11 @@
 static bool eval_shift(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_shift_expression(src))
 		{
@@ -9597,7 +9917,11 @@
 
 static bool eval_relation_expression(parse_tree&amp; src,const type_system&amp; types,
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_C99_relation_expression(src))
 		{
@@ -9612,7 +9936,11 @@
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_equality_expression,
 							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_equality_expression(src))
 		{
@@ -9627,7 +9955,11 @@
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_AND_expression,
 							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_bitwise_AND_expression(src))
 		{
@@ -9642,7 +9974,11 @@
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_XOR_expression,
 							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_bitwise_XOR_expression(src))
 		{
@@ -9657,7 +9993,11 @@
 							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
 							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_OR_expression,
 							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+#ifdef ZCC_LEGACY_FIXED_INT
 							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#else
+							func_traits&lt;bool (*)(unsigned_var_int&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+#endif
 {
 	if (is_bitwise_OR_expression(src))
 		{
@@ -9817,8 +10157,13 @@
 			};
 		if (non_representable_int_min)
 			{
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int;
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+#else
+			unsigned_var_int res_int;
+			unsigned_var_int rhs_int;
+#endif
 			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data&lt;1&gt;());
 			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;());
 			if (lhs_converted &amp;&amp; rhs_converted)
@@ -9839,9 +10184,15 @@
 				target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
 #endif
 				assert(lhs_negative &amp;&amp; !rhs_negative);
+#ifdef ZCC_LEGACY_FIXED_INT
 				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_test(res_int);
 				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_test(rhs_int);
 				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; ub(target_machine-&gt;signed_max(old.machine_type));
+#else
+				unsigned_var_int lhs_test(res_int);
+				unsigned_var_int rhs_test(rhs_int);
+				unsigned_var_int ub(target_machine-&gt;signed_max(old.machine_type));
+#endif
 				target_machine-&gt;signed_additive_inverse(lhs_test,old.machine_type);
 				ub += 1;
 				assert(ub&gt;=lhs_test &amp;&amp; ub&gt;=rhs_test);
@@ -9885,8 +10236,13 @@
 			};
 		if (non_representable_int_min)
 			{
+#ifdef ZCC_LEGACY_FIXED_INT
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int;
 			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+#else
+			unsigned_var_int res_int;
+			unsigned_var_int rhs_int;
+#endif
 			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data&lt;1&gt;());
 			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;());
 			if (lhs_converted &amp;&amp; rhs_converted)
@@ -9907,9 +10263,15 @@
 				target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
 #endif
 				assert(lhs_negative &amp;&amp; !rhs_negative);
+#ifdef ZCC_LEGACY_FIXED_INT
 				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_test(res_int);
 				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_test(rhs_int);
 				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; ub(target_machine-&gt;signed_max(old.machine_type));
+#else
+				unsigned_var_int lhs_test(res_int);
+				unsigned_var_int rhs_test(rhs_int);
+				unsigned_var_int ub(target_machine-&gt;signed_max(old.machine_type));
+#endif
 				target_machine-&gt;signed_additive_inverse(lhs_test,old.machine_type);
 				ub += 1;
 				assert(ub&gt;=lhs_test &amp;&amp; ub&gt;=rhs_test);

Added: trunk/unsigned_var_int.cpp
===================================================================
--- trunk/unsigned_var_int.cpp	2010-01-06 04:15:00 UTC (rev 324)
+++ trunk/unsigned_var_int.cpp	2010-01-10 09:37:43 UTC (rev 325)
@@ -0,0 +1,211 @@
+// unsigned_var_int.cpp
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#include &quot;unsigned_var_int.hpp&quot;
+
+static size_t bytes_to_represent(uintmax_t src)
+{
+	size_t n = 1;
+	while(UCHAR_MAX&lt;src)
+		{
+		++n;
+		src /= UCHAR_MAX;
+		};
+	return n;
+}
+
+unsigned_var_int::unsigned_var_int(const unsigned_var_int&amp; src)
+{
+	_data.init(src._data.size());
+	memmove(_data.c_array(),src._data.data(),src._data.size());
+}
+
+unsigned_var_int::unsigned_var_int(uintmax_t src)
+{
+	const size_t n = bytes_to_represent(src);
+	_data.init(n);
+	unsigned_copy(_data.c_array(),src,n);
+}
+
+unsigned_var_int&amp; unsigned_var_int::operator=(const unsigned_var_int&amp; src)
+{
+	_data.resize(src._data.size());
+	memmove(_data.c_array(),src._data.data(),src._data.size());
+	return *this;
+}
+
+unsigned_var_int&amp; unsigned_var_int::operator=(uintmax_t src)
+{
+	const size_t n = bytes_to_represent(src);
+	if (n&gt; _data.size()) _data.resize(n);
+	unsigned_copy(_data.c_array(),src,n);
+	if (n&lt;_data.size()) memset(_data.c_array()+n,0,_data.size()-n);
+	return *this;
+}
+
+void unsigned_var_int::MoveInto(unsigned_var_int&amp; dest)
+{
+	dest._data.resize(0);
+	dest._data = _data;
+	_data.init(0);
+}
+
+unsigned_var_int&amp; unsigned_var_int::operator+=(const unsigned_var_int&amp; rhs)
+{
+	if (size()&lt;=rhs.size())
+		{
+		unsigned_sum(c_array(),size(),rhs.data());
+		}
+	else{	// need to zero-extend rhs
+		unsigned_var_int tmp(rhs);
+		tmp._data.resize(size());
+		unsigned_sum(c_array(),size(),tmp.data());
+		}
+	return *this;
+}
+
+unsigned_var_int operator+(const unsigned_var_int&amp; lhs,const unsigned_var_int&amp; rhs)
+{
+	const bool lhs_larger = lhs.size()&gt;=rhs.size();
+	unsigned_var_int tmp(lhs_larger ? lhs : rhs);
+	tmp += (lhs_larger ? rhs : lhs);
+	return tmp;
+}
+
+
+unsigned_var_int&amp; unsigned_var_int::operator-=(const unsigned_var_int&amp; rhs)
+{
+	if (size()&lt;=rhs.size())
+		unsigned_diff(c_array(),size(),rhs.data());
+	else{	// need to zero-extend rhs
+		unsigned_var_int tmp(rhs);
+		tmp.resize(size());
+		unsigned_diff(c_array(),size(),tmp.data());
+		}
+	return *this;
+}
+
+unsigned_var_int operator-(const unsigned_var_int&amp; lhs,const unsigned_var_int&amp; rhs)
+{
+	unsigned_var_int tmp(lhs);
+	if (tmp.size()&lt;rhs.size()) tmp.resize(rhs.size());
+	tmp -= rhs;
+	return tmp;	// uses NRVO
+}
+
+unsigned_var_int&amp; unsigned_var_int::operator*=(const unsigned_var_int&amp; rhs)
+{
+	unsigned_var_int tmp(0);;
+	tmp.resize(size());
+	unsigned_mult(tmp.c_array(),tmp.size(),data(),size(),rhs.data(),rhs.size());
+	return *this = tmp;
+}
+
+unsigned_var_int&amp; unsigned_var_int::operator&amp;=(const unsigned_var_int&amp; rhs)
+{
+	if (size()&lt;=rhs.size())
+		bitwise_and(c_array(),size(),rhs.data());
+	else{
+		unsigned_var_int tmp(rhs);
+		tmp.resize(size());
+		bitwise_and(c_array(),size(),tmp.data());
+		}
+	return *this;
+}
+
+unsigned_var_int&amp; unsigned_var_int::operator^=(const unsigned_var_int&amp; rhs)
+{
+	if (size()&lt;=rhs.size())
+		bitwise_xor(c_array(),size(),rhs.data());
+	else
+		bitwise_xor(c_array(),rhs.size(),rhs.data());
+	return *this;
+}
+
+unsigned_var_int&amp; unsigned_var_int::operator|=(const unsigned_var_int&amp; rhs)
+{
+	if (size()&lt;=rhs.size())
+		bitwise_or(c_array(),size(),rhs.data());
+	else
+		bitwise_or(c_array(),rhs.size(),rhs.data());
+	return *this;
+}
+
+void unsigned_var_int::div_op(const unsigned_var_int&amp; divisor, unsigned_var_int&amp; quotient)
+{
+	if (divisor.size()==quotient.size())
+		{
+		const size_t cur_size = size();
+		if (cur_size==divisor.size())
+			{
+			remainder_quotient(size(),c_array(),divisor.data(),quotient.c_array());
+			return;
+			}
+		resize(divisor.size());
+		remainder_quotient(size(),c_array(),divisor.data(),quotient.c_array());
+		resize(cur_size);
+		return;
+		}
+	FATAL(&quot;unsigned_var_int::div_op not fully implemented yet.&quot;);
+}
+
+unsigned_var_int operator/(unsigned_var_int lhs,const unsigned_var_int&amp; rhs)
+{
+	unsigned_var_int quotient(0);
+	quotient.resize(rhs.size());
+	lhs.div_op(rhs,quotient);
+	return quotient;
+}
+
+unsigned_var_int&amp; unsigned_var_int::operator/=(const unsigned_var_int&amp; rhs)
+{
+	unsigned_var_int quotient(0);
+	quotient.resize(rhs.size());
+	div_op(rhs,quotient);
+	quotient.MoveInto(*this);
+	return *this;
+}
+
+unsigned_var_int&amp; unsigned_var_int::operator%=(const unsigned_var_int&amp; rhs)
+{
+	unsigned_var_int quotient(0);
+	quotient.resize(rhs.size());
+	div_op(rhs,quotient);
+	return *this;
+}
+
+signed int cmp(const unsigned_var_int&amp; lhs, const unsigned_var_int&amp; rhs)
+{
+	size_t lhs_size = lhs.size();
+	size_t rhs_size = rhs.size();
+
+	// normalize representation being checked
+	while(1&lt;lhs_size &amp;&amp; !lhs.data()[lhs_size-1]) --lhs_size;
+	while(1&lt;rhs_size &amp;&amp; !rhs.data()[rhs_size-1]) --rhs_size;
+	
+	if (lhs_size&lt;rhs_size) return -1;
+	if (lhs_size&gt;rhs_size) return 1;
+
+	return unsigned_cmp(lhs.data(),lhs_size,rhs.data());
+}
+
+char* z_ucharint_toa(unsigned_var_int target,char* const buf,unsigned int radix)
+{
+	char* ret = buf;
+	unsigned_var_int radix_copy(radix);
+	radix_copy.resize(target.size());
+	unsigned_var_int power_up(1);
+	power_up.resize(target.size());
+	while(power_up&lt;=target/radix_copy) power_up *= radix_copy;
+	do	{
+		unsigned char tmp = (unsigned char)((target/power_up).to_uint());
+		tmp += (10&gt;tmp) ? (unsigned char)('0') : (unsigned char)('A')-10U;	// ahem...assumes ASCII linear A-Z
+		*ret++ = tmp;
+		target %= power_up;
+		power_up /= radix_copy;
+		}
+	while(0&lt;power_up);
+	*ret = '\0';
+	return buf;
+}
+

Added: trunk/unsigned_var_int.hpp
===================================================================
--- trunk/unsigned_var_int.hpp	2010-01-06 04:15:00 UTC (rev 324)
+++ trunk/unsigned_var_int.hpp	2010-01-10 09:37:43 UTC (rev 325)
@@ -0,0 +1,147 @@
+// unsigned_var_int.hpp
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#ifndef UNSIGNED_VAR_INT_HPP
+#define UNSIGNED_VAR_INT_HPP 1
+
+#include &quot;unsigned_aux.hpp&quot;
+#include &quot;uchar_blob.hpp&quot;
+
+// the main class
+// this does implement C/C++ modulo wraparound; change the size beforehand if this is an issue.
+class unsigned_var_int
+{
+private:
+	uchar_blob _data;
+public:
+	unsigned_var_int() {_data.init(0);};
+	explicit unsigned_var_int(uintmax_t src);
+	unsigned_var_int(const unsigned_var_int&amp; src);
+
+	unsigned_var_int&amp; operator=(const unsigned_var_int&amp; src);
+	unsigned_var_int&amp; operator=(uintmax_t src);
+	unsigned_var_int&amp; operator=(const uchar_blob&amp; src) {value_copy(_data,src); return *this;};
+	void MoveInto(unsigned_var_int&amp; dest);
+
+	unsigned_var_int&amp; operator~() {bitwise_compl(_data.c_array(),_data.size()); return *this;};
+	void auto_bitwise_complement() {bitwise_compl(_data.c_array(),_data.size());};
+	unsigned_var_int&amp; operator+=(const unsigned_var_int&amp; rhs);
+	unsigned_var_int&amp; operator+=(uintmax_t rhs) {unsigned_sum(_data.c_array(),_data.size(),rhs); return *this;};
+	unsigned_var_int&amp; operator-=(const unsigned_var_int&amp; rhs);
+	unsigned_var_int&amp; operator-=(uintmax_t rhs) {unsigned_diff(_data.c_array(),_data.size(),rhs); return *this;};
+	unsigned_var_int&amp; operator*=(const unsigned_var_int&amp; rhs);
+	unsigned_var_int&amp; operator&amp;=(const unsigned_var_int&amp; rhs);
+	unsigned_var_int&amp; operator^=(const unsigned_var_int&amp; rhs);
+	unsigned_var_int&amp; operator|=(const unsigned_var_int&amp; rhs);
+	unsigned_var_int&amp; operator&gt;&gt;=(uintmax_t rhs) {unsigned_right_shift(_data.c_array(),_data.size(),rhs); return *this;};
+	unsigned_var_int&amp; operator&lt;&lt;=(uintmax_t rhs) {unsigned_left_shift(_data.c_array(),_data.size(),rhs); return *this;};
+
+	void div_op(const unsigned_var_int&amp; divisor, unsigned_var_int&amp; quotient);
+
+	unsigned_var_int&amp; operator/=(const unsigned_var_int&amp; rhs);
+	unsigned_var_int&amp; operator%=(const unsigned_var_int&amp; rhs);
+
+	unsigned int int_log2() const {return ::int_log2(_data.data(),_data.size());};
+
+	void set(size_t n)
+		{
+		assert(_data.size()&gt;n/CHAR_BIT);
+		_data.c_array()[n/CHAR_BIT] |= ((unsigned char)(1U))&lt;&lt;(n%CHAR_BIT);
+		};
+	void set(size_t n,bool x)
+		{
+		assert(_data.size()&gt;n/CHAR_BIT);
+		if (x)
+			_data.c_array()[n/CHAR_BIT] |= ((unsigned char)(1U))&lt;&lt;(n%CHAR_BIT);
+		else
+			_data.c_array()[n/CHAR_BIT] &amp;= ~(((unsigned char)(1U))&lt;&lt;(n%CHAR_BIT));
+		};
+	void reset(size_t n)
+		{
+		assert(_data.size()&gt;n/CHAR_BIT);
+		_data.c_array()[n/CHAR_BIT] &amp;= ~(((unsigned char)(1U))&lt;&lt;(n%CHAR_BIT));
+		};
+
+	bool test(size_t n) const
+		{
+		assert(_data.size()&gt;n/CHAR_BIT);
+		return _data.data()[n/CHAR_BIT] &amp; (((unsigned char)(1U))&lt;&lt;(n%CHAR_BIT));
+		}
+
+	void toggle(size_t n)
+		{
+		assert(_data.size()&gt;n/CHAR_BIT);
+		_data.c_array()[n/CHAR_BIT] ^= (((unsigned char)(1U))&lt;&lt;(n%CHAR_BIT));
+		};
+
+	bool representable_as_uint() const
+		{	//! \todo remove assumption host has no padding bits in uintmax_t
+		size_t i = _data.size();
+		if (sizeof(uintmax_t)&gt;=i) return true;
+		do	if ((unsigned char)('\0')!=_data.data()[--i]) return false;
+		while(sizeof(uintmax_t)&lt;i);
+		return true;
+		};
+
+	void resize(size_t n) {_data.resize(n);};
+	void set_bitcount(size_t n) {_data.resize(n/CHAR_BIT+(0&lt;n%CHAR_BIT));};
+	void mask_to(size_t bitcount) {assert(bitcount&lt;=CHAR_BIT*_data.size());return ::mask_to(_data.c_array(),_data.size(),bitcount);};
+	uintmax_t to_uint() const {return ::to_uint(_data.data(),_data.size());};
+	void set_max() {memset(_data.c_array(),UCHAR_MAX,_data.size());};
+
+	// STL glue
+	void clear() {memset(_data.c_array(),0,_data.size());};
+
+	const unsigned char* data() const {return _data.data();};
+	unsigned char* c_array() {return _data.c_array();};
+	size_t size() const {return _data.size();};
+	bool empty() const {return _data.empty();};
+
+	const unsigned char* begin() const {return _data.begin();};
+	unsigned char* begin() {return _data.begin();};
+	const unsigned char* end() const {return _data.end();};
+	unsigned char* end() {return _data.end();};
+
+	unsigned char front() const {return _data.front();};
+	unsigned char&amp; front() {return _data.front();};
+	unsigned char back() const {return _data.back();};
+	unsigned char&amp; back() {return _data.back();};
+};
+
+// render as C string
+char* z_ucharint_toa(unsigned_var_int target,char* const buf,unsigned int radix);
+
+// the larger size of lhs and rhs is used here
+unsigned_var_int operator+(const unsigned_var_int&amp; lhs,const unsigned_var_int&amp; rhs);
+unsigned_var_int operator-(const unsigned_var_int&amp; lhs,const unsigned_var_int&amp; rhs);
+unsigned_var_int operator/(unsigned_var_int lhs,const unsigned_var_int&amp; rhs);
+
+// classic cmp: -1 for less than, 0 for equal, 1 for greater than.
+signed int cmp(const unsigned_var_int&amp; lhs, const unsigned_var_int&amp; rhs);
+
+// comparison operators
+inline bool operator==(const unsigned_var_int&amp; lhs, const unsigned_var_int&amp; rhs) {return 0==cmp(lhs,rhs);}
+inline bool operator==(const unsigned_var_int&amp; lhs, uintmax_t rhs) {return 0==unsigned_cmp(lhs.data(),lhs.size(),rhs);}
+inline bool operator==(uintmax_t lhs, const unsigned_var_int&amp; rhs) {return 0==unsigned_cmp(rhs.data(),rhs.size(),lhs);}
+
+inline bool operator!=(const unsigned_var_int&amp; lhs, const unsigned_var_int&amp; rhs) {return 0!=cmp(lhs,rhs);}
+inline bool operator!=(const unsigned_var_int&amp; lhs, uintmax_t rhs) {return 0==unsigned_cmp(lhs.data(),lhs.size(),rhs);}
+inline bool operator!=(uintmax_t lhs, const unsigned_var_int&amp; rhs) {return 0==unsigned_cmp(rhs.data(),rhs.size(),lhs);}
+
+inline bool operator&lt;(const unsigned_var_int&amp; lhs, const unsigned_var_int&amp; rhs) {return -1==cmp(lhs,rhs);}
+inline bool operator&lt;(const unsigned_var_int&amp; lhs, uintmax_t rhs) {return -1==unsigned_cmp(lhs.data(),lhs.size(),rhs);}
+inline bool operator&lt;(uintmax_t lhs, const unsigned_var_int&amp; rhs) {return 1==unsigned_cmp(rhs.data(),rhs.size(),lhs);}
+
+inline bool operator&gt;(const unsigned_var_int&amp; lhs, const unsigned_var_int&amp; rhs) {return 1==cmp(lhs,rhs);}
+inline bool operator&gt;(const unsigned_var_int&amp; lhs, uintmax_t rhs) {return 1==unsigned_cmp(lhs.data(),lhs.size(),rhs);}
+inline bool operator&gt;(uintmax_t lhs, const unsigned_var_int&amp; rhs) {return -1==unsigned_cmp(rhs.data(),rhs.size(),lhs);}
+
+inline bool operator&lt;=(const unsigned_var_int&amp; lhs, const unsigned_var_int&amp; rhs) {return 1!=cmp(lhs,rhs);}
+inline bool operator&lt;=(const unsigned_var_int&amp; lhs, uintmax_t rhs) {return 0&gt;=unsigned_cmp(lhs.data(),lhs.size(),rhs);}
+inline bool operator&lt;=(uintmax_t lhs, const unsigned_var_int&amp; rhs) {return 0&lt;=unsigned_cmp(rhs.data(),rhs.size(),lhs);}
+
+inline bool operator&gt;=(const unsigned_var_int&amp; lhs, const unsigned_var_int&amp; rhs) {return -1!=cmp(lhs,rhs);}
+inline bool operator&gt;=(const unsigned_var_int&amp; lhs, uintmax_t rhs) {return 0&lt;=unsigned_cmp(lhs.data(),lhs.size(),rhs);}
+inline bool operator&gt;=(uintmax_t lhs, const unsigned_var_int&amp; rhs) {return 0&gt;=unsigned_cmp(rhs.data(),rhs.size(),lhs);}
+
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000091.html">[Zcplusplus-commits] r324 - trunk
</A></li>
	<LI>Next message: <A HREF="000093.html">[Zcplusplus-commits] r326 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#92">[ date ]</a>
              <a href="thread.html#92">[ thread ]</a>
              <a href="subject.html#92">[ subject ]</a>
              <a href="author.html#92">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/zcplusplus-commits">More information about the Zcplusplus-commits
mailing list</a><br>
</body></html>
