From zaimoni at mail.berlios.de  Fri Jan  7 01:17:39 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri,  7 Jan 2011 01:17:39 +0100
Subject: [Zcplusplus-commits] r556 - trunk
Message-ID: <20110107001739.EF1B7480A18@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-07 01:17:39 +0100 (Fri, 07 Jan 2011)
New Revision: 556

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/kleene_star.hpp
Log:
reduce RAM thrashing

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-12-22 21:50:38 UTC (rev 555)
+++ trunk/CSupport.cpp	2011-01-07 00:17:39 UTC (rev 556)
@@ -13059,8 +13059,9 @@
 					tmp2.type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 					tmp2.flags |= (parse_tree::INVALID | PARSE_PRIMARY_TYPE);
 					};
-				goto rescan;
+				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
 				}
+				break;
 				case ENUM_NAMED_DEF:
 				{	// can only define once
 				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
@@ -13078,7 +13079,8 @@
 					zcc_errors.inc_error();
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"enum"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
 					}
 				// C1X 6.7.2.3p2 states that conflicting union or struct must error
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(tmp2.index_tokens[1].token.first))
@@ -13129,6 +13131,7 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
+				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
 				}
 				break;
 				case ENUM_ANON_DEF:
@@ -13143,7 +13146,7 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				goto rescan;
+				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
 				}
 				}
 			while(pre_invariant_decl_scanner.size()> ++k);
@@ -14110,14 +14113,15 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'enum ");
-					INC_INFORM(src.data<0>()[i+k].index_tokens[1].token.first,src.data<0>()[i+k].index_tokens[1].token.second);
+					INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
 					INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
 					zcc_errors.inc_error();
 					tmp2.type_code.set_type(C_TYPE::INT);	// fail over to int, like C
 					tmp2.flags |= (parse_tree::INVALID | PARSE_PRIMARY_TYPE);
-					}
-				goto rescan;
+					};
+				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
 				}
+				break;
 				case ENUM_NAMED_DEF:
 				{	// can only define once
 				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
@@ -14135,7 +14139,8 @@
 					zcc_errors.inc_error();
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"enum"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
@@ -14189,6 +14194,7 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
+				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
 				}
 				break;
 				case ENUM_ANON_DEF:
@@ -14203,7 +14209,7 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				goto rescan;
+				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
 				}
 				}
 			while(pre_invariant_decl_scanner.size()> ++k);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-12-22 21:50:38 UTC (rev 555)
+++ trunk/CSupport.cpp.in	2011-01-07 00:17:39 UTC (rev 556)
@@ -13206,8 +13206,9 @@
 					tmp2.type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 					tmp2.flags |= (parse_tree::INVALID | PARSE_PRIMARY_TYPE);
 					};
-				goto rescan;
+				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
 				}
+				break;
 				case ENUM_NAMED_DEF:
 				{	// can only define once
 				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
@@ -13225,7 +13226,8 @@
 					zcc_errors.inc_error();
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"enum"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
 					}
 				// C1X 6.7.2.3p2 states that conflicting union or struct must error
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(tmp2.index_tokens[1].token.first))
@@ -13276,6 +13278,7 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
+				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
 				}
 				break;
 				case ENUM_ANON_DEF:
@@ -13290,7 +13293,7 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				goto rescan;
+				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
 				}
 				}
 			while(pre_invariant_decl_scanner.size()> ++k);
@@ -14260,14 +14263,15 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'enum ");
-					INC_INFORM(src.data<0>()[i+k].index_tokens[1].token.first,src.data<0>()[i+k].index_tokens[1].token.second);
+					INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
 					INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
 					zcc_errors.inc_error();
 					tmp2.type_code.set_type(C_TYPE::INT);	// fail over to int, like C
 					tmp2.flags |= (parse_tree::INVALID | PARSE_PRIMARY_TYPE);
-					}
-				goto rescan;
+					};
+				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
 				}
+				break;
 				case ENUM_NAMED_DEF:
 				{	// can only define once
 				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
@@ -14285,7 +14289,8 @@
 					zcc_errors.inc_error();
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"enum"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
@@ -14339,6 +14344,7 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
+				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
 				}
 				break;
 				case ENUM_ANON_DEF:
@@ -14353,7 +14359,7 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				goto rescan;
+				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
 				}
 				}
 			while(pre_invariant_decl_scanner.size()> ++k);

Modified: trunk/kleene_star.hpp
===================================================================
--- trunk/kleene_star.hpp	2010-12-22 21:50:38 UTC (rev 555)
+++ trunk/kleene_star.hpp	2011-01-07 00:17:39 UTC (rev 556)
@@ -27,6 +27,14 @@
 	size_t empty() const {return result_scan.empty();};
 	size_t size() const {return result_scan.size();};
 	size_t operator[](size_t i) const {assert(size()>i);return result_scan[i];};
+	void reclassify(const size_t i,const size_t new_value)
+		{
+		assert(size()>i);
+		assert(_strict_ub>new_value);
+		if (new_value==result_scan[i]) return;
+		--_detect_count[result_scan[i]];
+		++_detect_count[result_scan[i] = new_value];
+		};
 	size_t front() const {return result_scan.front();};
 	size_t back() const {return result_scan.back();};
 	void clear()



From zaimoni at mail.berlios.de  Fri Jan  7 02:42:09 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri,  7 Jan 2011 02:42:09 +0100
Subject: [Zcplusplus-commits] r557 - trunk
Message-ID: <20110107014209.4D0C0480A1A@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-07 02:42:08 +0100 (Fri, 07 Jan 2011)
New Revision: 557

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
adjust parsing of anonymous classes towards standard-compliance

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-07 00:17:39 UTC (rev 556)
+++ trunk/CSupport.cpp	2011-01-07 01:42:08 UTC (rev 557)
@@ -10515,6 +10515,97 @@
 		}
 }
 
+static void _condense_const_volatile_onto_type_preparsed(parse_tree& src,size_t& i,size_t& k,kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner,const char* const warn_const,const char* const warn_volatile)
+{
+	size_t offset = 0;
+	bool have_warned_too_many_types = false;
+	bool have_warned_about_const = false;
+	bool have_warned_about_volatile = false;
+
+	assert(src.size<0>()>i);
+	assert(src.size<0>()-i>=invariant_decl_scanner.size());
+	assert(invariant_decl_scanner.size()>k);
+	assert(PARSE_TYPE & src.data<0>()[i+k].flags);
+	while(k>offset)
+		switch(invariant_decl_scanner[offset])
+		{
+		case C99_CPP_CONST_IDX:
+			//! \test decl.C99/Warn_dup_const.h
+			//! \test decl.C99/Warn_dup_const.hpp
+			//! \test decl.C99/Warn_dup_const2.h
+			//! \test decl.C99/Warn_dup_const2.hpp
+			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
+			src.DeleteIdx<0>(i-- +offset);
+			invariant_decl_scanner.DeleteIdx(offset);
+			continue;
+		case C99_CPP_VOLATILE_IDX:
+			//! \test decl.C99/Warn_dup_volatile.h
+			//! \test decl.C99/Warn_dup_volatile.hpp
+			//! \test decl.C99/Warn_dup_volatile2.h
+			//! \test decl.C99/Warn_dup_volatile2.hpp
+			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
+			src.DeleteIdx<0>(i-- +offset);
+			invariant_decl_scanner.DeleteIdx(offset);
+			continue;
+		default:
+			if (invariant_decl_scanner.strict_ub()-1==invariant_decl_scanner[offset-1])
+				{
+				if (!have_warned_too_many_types)
+					{
+					message_header(src.data<0>()[i+offset].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("multiple types in decl-specifier sequence, discarding extra types");
+					zcc_errors.inc_error();
+					have_warned_too_many_types = true;
+					}
+				src.DeleteIdx<0>(i-- +offset);
+				invariant_decl_scanner.DeleteIdx(offset);
+				continue;
+				}
+			++offset;
+		}
+
+	offset = k+1;
+	while(invariant_decl_scanner.size()>offset)
+		switch(invariant_decl_scanner[offset])
+		{
+		case C99_CPP_CONST_IDX:
+			//! \test decl.C99/Warn_dup_const2.h
+			//! \test decl.C99/Warn_dup_const2.hpp
+			//! \test decl.C99/Warn_dup_const3.h
+			//! \test decl.C99/Warn_dup_const3.hpp
+			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
+			src.DeleteIdx<0>(i+offset);
+			invariant_decl_scanner.DeleteIdx(offset);
+			continue;
+		case C99_CPP_VOLATILE_IDX:
+			//! \test decl.C99/Warn_dup_volatile2.h
+			//! \test decl.C99/Warn_dup_volatile2.hpp
+			//! \test decl.C99/Warn_dup_volatile3.h
+			//! \test decl.C99/Warn_dup_volatile3.hpp
+			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
+			src.DeleteIdx<0>(i+offset);
+			invariant_decl_scanner.DeleteIdx(offset);
+			continue;
+		default:
+			if (invariant_decl_scanner.strict_ub()-1==invariant_decl_scanner[offset-1])
+				{
+				if (!have_warned_too_many_types)
+					{
+					message_header(src.data<0>()[i+offset].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("multiple types in decl-specifier sequence, discarding extra types");
+					zcc_errors.inc_error();
+					have_warned_too_many_types = true;
+					}
+				src.DeleteIdx<0>(i-- +offset);
+				invariant_decl_scanner.DeleteIdx(offset);
+				continue;
+				}
+			++offset;
+		}
+}
+
 static void _condense_const_volatile_onto_type(parse_tree& src,size_t& i,kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner,const char* const warn_const,const char* const warn_volatile)
 {
 	size_t offset = 0;
@@ -14084,6 +14175,7 @@
 		}
 		if (!pre_invariant_decl_scanner.empty())
 			{
+			const bool semicolon_terminated_decl = robust_token_is_char<';'>(src.data<0>()[i+pre_invariant_decl_scanner.size()]); 
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
 			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse
@@ -14098,7 +14190,55 @@
 				case STRUCT_ANON_DEF: break;
 				case CLASS_NAME: break;
 				case CLASS_NAMED_DEF: break;
-				case CLASS_ANON_DEF: break;
+				case CLASS_ANON_DEF:
+				{	// anonymous types cannot be matched
+				// tentatively forward-declare immediately
+				const type_system::type_index tmp = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class,src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
+				assert(tmp);
+				assert(parse_tree::types->get_structdecl(tmp));
+				{
+				parse_tree& tmp2 =  src.c_array<0>()[i+k];				
+				tmp2.type_code.set_type(tmp);
+				tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+				}
+				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+				_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+
+				// parse the union and upgrade it to a full definition
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp);
+				assert(tmp3);
+				const parse_tree& tmp2 =  src.data<0>()[i+k];				
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(tmp,tmp4);
+				assert(parse_tree::types->get_C_structdef(tmp));
+
+				if (semicolon_terminated_decl)
+					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \test decl.C99/Error_class_anon_def_const.hpp
+					//! \test decl.C99/Error_class_anon_def_const2.hpp
+					//! \test decl.C99/Error_class_anon_def_volatile.hpp
+					//! \test decl.C99/Error_class_anon_def_volatile2.hpp
+					//! \test decl.C99/Error_class_anon_def_const_volatile.hpp
+					//! \test decl.C99/Error_class_anon_def_const_volatile2.hpp
+					//! \test decl.C99/Error_class_anon_def_const_volatile3.hpp
+					//! \test decl.C99/Error_class_anon_def_const_volatile4.hpp
+					//! \test decl.C99/Error_class_anon_def_const_volatile5.hpp
+					//! \test decl.C99/Error_class_anon_def_const_volatile6.hpp
+					CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i+k]);
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("unreferenceable anonymous class declaration");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// remove from parse
+					src.DeleteNSlotsAt<0>(i+pre_invariant_decl_scanner.size(),i);
+					goto rescan;
+					}
+				}
+				break;
 				//! \bug the enums aren't handling const/volatile qualification
 				case ENUM_NAME:
 				{
@@ -14886,51 +15026,7 @@
 				}
 			}
 			break;
-			case CLASS_ANON_DEF:
-			{	// anonymous types cannot be matched
-			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			assert(tmp2);
-			assert(parse_tree::types->get_structdecl(tmp2));
-			src.c_array<0>()[i].type_code.set_type(tmp2);
-			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-
-			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
-			assert(parse_tree::types->get_C_structdef(tmp2));
-
-			if (	1<src.size<0>()-i
-				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				//! \test decl.C99/Error_class_anon_def_const.hpp
-				//! \test decl.C99/Error_class_anon_def_const2.hpp
-				//! \test decl.C99/Error_class_anon_def_volatile.hpp
-				//! \test decl.C99/Error_class_anon_def_volatile2.hpp
-				//! \test decl.C99/Error_class_anon_def_const_volatile.hpp
-				//! \test decl.C99/Error_class_anon_def_const_volatile2.hpp
-				//! \test decl.C99/Error_class_anon_def_const_volatile3.hpp
-				//! \test decl.C99/Error_class_anon_def_const_volatile4.hpp
-				//! \test decl.C99/Error_class_anon_def_const_volatile5.hpp
-				//! \test decl.C99/Error_class_anon_def_const_volatile6.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-				//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous class declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			}
-			break;
+			case CLASS_ANON_DEF: break;	/* already handled */
 			case ENUM_NAME: break;	/* already handled */
 			case ENUM_NAMED_DEF: break;	/* already handled */
 			case ENUM_ANON_DEF: break;	/* already handled */

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-07 00:17:39 UTC (rev 556)
+++ trunk/CSupport.cpp.in	2011-01-07 01:42:08 UTC (rev 557)
@@ -10651,6 +10651,97 @@
 		}
 }
 
+static void _condense_const_volatile_onto_type_preparsed(parse_tree& src,size_t& i,size_t& k,kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner,const char* const warn_const,const char* const warn_volatile)
+{
+	size_t offset = 0;
+	bool have_warned_too_many_types = false;
+	bool have_warned_about_const = false;
+	bool have_warned_about_volatile = false;
+
+	assert(src.size<0>()>i);
+	assert(src.size<0>()-i>=invariant_decl_scanner.size());
+	assert(invariant_decl_scanner.size()>k);
+	assert(PARSE_TYPE & src.data<0>()[i+k].flags);
+	while(k>offset)
+		switch(invariant_decl_scanner[offset])
+		{
+		case C99_CPP_CONST_IDX:
+			//! \test decl.C99/Warn_dup_const.h
+			//! \test decl.C99/Warn_dup_const.hpp
+			//! \test decl.C99/Warn_dup_const2.h
+			//! \test decl.C99/Warn_dup_const2.hpp
+			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
+			src.DeleteIdx<0>(i-- +offset);
+			invariant_decl_scanner.DeleteIdx(offset);
+			continue;
+		case C99_CPP_VOLATILE_IDX:
+			//! \test decl.C99/Warn_dup_volatile.h
+			//! \test decl.C99/Warn_dup_volatile.hpp
+			//! \test decl.C99/Warn_dup_volatile2.h
+			//! \test decl.C99/Warn_dup_volatile2.hpp
+			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
+			src.DeleteIdx<0>(i-- +offset);
+			invariant_decl_scanner.DeleteIdx(offset);
+			continue;
+		default:
+			if (invariant_decl_scanner.strict_ub()-1==invariant_decl_scanner[offset-1])
+				{
+				if (!have_warned_too_many_types)
+					{
+					message_header(src.data<0>()[i+offset].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("multiple types in decl-specifier sequence, discarding extra types");
+					zcc_errors.inc_error();
+					have_warned_too_many_types = true;
+					}
+				src.DeleteIdx<0>(i-- +offset);
+				invariant_decl_scanner.DeleteIdx(offset);
+				continue;
+				}
+			++offset;
+		}
+
+	offset = k+1;
+	while(invariant_decl_scanner.size()>offset)
+		switch(invariant_decl_scanner[offset])
+		{
+		case C99_CPP_CONST_IDX:
+			//! \test decl.C99/Warn_dup_const2.h
+			//! \test decl.C99/Warn_dup_const2.hpp
+			//! \test decl.C99/Warn_dup_const3.h
+			//! \test decl.C99/Warn_dup_const3.hpp
+			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
+			src.DeleteIdx<0>(i+offset);
+			invariant_decl_scanner.DeleteIdx(offset);
+			continue;
+		case C99_CPP_VOLATILE_IDX:
+			//! \test decl.C99/Warn_dup_volatile2.h
+			//! \test decl.C99/Warn_dup_volatile2.hpp
+			//! \test decl.C99/Warn_dup_volatile3.h
+			//! \test decl.C99/Warn_dup_volatile3.hpp
+			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
+			src.DeleteIdx<0>(i+offset);
+			invariant_decl_scanner.DeleteIdx(offset);
+			continue;
+		default:
+			if (invariant_decl_scanner.strict_ub()-1==invariant_decl_scanner[offset-1])
+				{
+				if (!have_warned_too_many_types)
+					{
+					message_header(src.data<0>()[i+offset].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("multiple types in decl-specifier sequence, discarding extra types");
+					zcc_errors.inc_error();
+					have_warned_too_many_types = true;
+					}
+				src.DeleteIdx<0>(i-- +offset);
+				invariant_decl_scanner.DeleteIdx(offset);
+				continue;
+				}
+			++offset;
+		}
+}
+
 static void _condense_const_volatile_onto_type(parse_tree& src,size_t& i,kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner,const char* const warn_const,const char* const warn_volatile)
 {
 	size_t offset = 0;
@@ -14231,9 +14322,7 @@
 		}
 		if (!pre_invariant_decl_scanner.empty())
 			{
-#/*cut-nocpp*/
 			const bool semicolon_terminated_decl = robust_token_is_char<';'>(src.data<0>()[i+pre_invariant_decl_scanner.size()]); 
-#/*cut-nocpp*/
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
 			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse
@@ -14248,7 +14337,55 @@
 				case STRUCT_ANON_DEF: break;
 				case CLASS_NAME: break;
 				case CLASS_NAMED_DEF: break;
-				case CLASS_ANON_DEF: break;
+				case CLASS_ANON_DEF:
+				{	// anonymous types cannot be matched
+				// tentatively forward-declare immediately
+				const type_system::type_index tmp = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class,src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
+				assert(tmp);
+				assert(parse_tree::types->get_structdecl(tmp));
+				{
+				parse_tree& tmp2 =  src.c_array<0>()[i+k];				
+				tmp2.type_code.set_type(tmp);
+				tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+				}
+				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+				_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+
+				// parse the union and upgrade it to a full definition
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp);
+				assert(tmp3);
+				const parse_tree& tmp2 =  src.data<0>()[i+k];				
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(tmp,tmp4);
+				assert(parse_tree::types->get_C_structdef(tmp));
+
+				if (semicolon_terminated_decl)
+					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \test decl.C99/Error_class_anon_def_const.hpp
+					//! \test decl.C99/Error_class_anon_def_const2.hpp
+					//! \test decl.C99/Error_class_anon_def_volatile.hpp
+					//! \test decl.C99/Error_class_anon_def_volatile2.hpp
+					//! \test decl.C99/Error_class_anon_def_const_volatile.hpp
+					//! \test decl.C99/Error_class_anon_def_const_volatile2.hpp
+					//! \test decl.C99/Error_class_anon_def_const_volatile3.hpp
+					//! \test decl.C99/Error_class_anon_def_const_volatile4.hpp
+					//! \test decl.C99/Error_class_anon_def_const_volatile5.hpp
+					//! \test decl.C99/Error_class_anon_def_const_volatile6.hpp
+					CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i+k]);
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("unreferenceable anonymous class declaration");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// remove from parse
+					src.DeleteNSlotsAt<0>(i+pre_invariant_decl_scanner.size(),i);
+					goto rescan;
+					}
+				}
+				break;
 				//! \bug the enums aren't handling const/volatile qualification
 				case ENUM_NAME:
 				{
@@ -15036,51 +15173,7 @@
 				}
 			}
 			break;
-			case CLASS_ANON_DEF:
-			{	// anonymous types cannot be matched
-			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			assert(tmp2);
-			assert(parse_tree::types->get_structdecl(tmp2));
-			src.c_array<0>()[i].type_code.set_type(tmp2);
-			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-
-			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
-			assert(parse_tree::types->get_C_structdef(tmp2));
-
-			if (	1<src.size<0>()-i
-				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				//! \test decl.C99/Error_class_anon_def_const.hpp
-				//! \test decl.C99/Error_class_anon_def_const2.hpp
-				//! \test decl.C99/Error_class_anon_def_volatile.hpp
-				//! \test decl.C99/Error_class_anon_def_volatile2.hpp
-				//! \test decl.C99/Error_class_anon_def_const_volatile.hpp
-				//! \test decl.C99/Error_class_anon_def_const_volatile2.hpp
-				//! \test decl.C99/Error_class_anon_def_const_volatile3.hpp
-				//! \test decl.C99/Error_class_anon_def_const_volatile4.hpp
-				//! \test decl.C99/Error_class_anon_def_const_volatile5.hpp
-				//! \test decl.C99/Error_class_anon_def_const_volatile6.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-				//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous class declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			}
-			break;
+			case CLASS_ANON_DEF: break;	/* already handled */
 			case ENUM_NAME: break;	/* already handled */
 			case ENUM_NAMED_DEF: break;	/* already handled */
 			case ENUM_ANON_DEF: break;	/* already handled */



From zaimoni at mail.berlios.de  Fri Jan  7 04:10:39 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri,  7 Jan 2011 04:10:39 +0100
Subject: [Zcplusplus-commits] r558 - trunk
Message-ID: <20110107031040.35CA2480A1A@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-07 04:10:39 +0100 (Fri, 07 Jan 2011)
New Revision: 558

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
adjust parsing of named class definitions towards standard-compliance

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-07 01:42:08 UTC (rev 557)
+++ trunk/CSupport.cpp	2011-01-07 03:10:39 UTC (rev 558)
@@ -14089,12 +14089,12 @@
 {
 	parse_tree& tmp = src.c_array<0>()[i];
 #ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
 #else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename);
 	assert(tmp2);
-	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace));
+	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace)==tmp2);
 	assert(parse_tree::types->get_structdecl(tmp2));
 	tmp.type_code.set_type(tmp2);
 #endif
@@ -14102,6 +14102,24 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 }
 
+static void _forward_declare_CPP_class_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	parse_tree& tmp = src.c_array<0>()[i+k];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
+#else
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace));
+	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
+	invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+	_condense_const_volatile_onto_type_preparsed(src,i,k,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+}
+
 // handle namespaces or else
 //! \todo check that the fact all literals are already legal-form is used
 //! \throw std::bad_alloc
@@ -14135,6 +14153,7 @@
 	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier);
 	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1+12,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier_or_tag);
 	size_t i = 0;
+restart_master_loop:
 	while(i<src.size<0>())
 		{
 		conserve_tokens(src.c_array<0>()[i]);
@@ -14189,7 +14208,102 @@
 				case STRUCT_NAMED_DEF: break;
 				case STRUCT_ANON_DEF: break;
 				case CLASS_NAME: break;
-				case CLASS_NAMED_DEF: break;
+				case CLASS_NAMED_DEF:
+				{	// can only define once
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				{
+				parse_tree& tmp2 =  src.c_array<0>()[i+k];				
+				if (tmp)
+					{
+					if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
+						{	//! \test zcc/decl.C99/Error_class_multidef.hpp
+						message_header(src.data<0>()[i+k].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("'class ");
+						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INFORM("' already defined (C++98 3.2p1)");
+						message_header(fatal_def->_decl);
+						INFORM("prior definition here");
+						zcc_errors.inc_error();
+						// reduce to named-specifier
+						tmp2.DeleteIdx<2>(0);
+						assert(is_C99_named_specifier(tmp2,"class"));
+						goto rescan;
+						}					
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+					}
+				// One Definition Rule states that conflicting enum, struct, or class must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_union_as_class2.hpp
+						//! \test zcc/decl.C99/Error_union_as_class4.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("class ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C++98 One Definition Rule)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_enum_as_class2.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("class ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C++98 One Definition Rule)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+				else _forward_declare_CPP_class_preparsed(src,active_namespace,i,k,pre_invariant_decl_scanner);
+				}
+				// parse the union and upgrade it to a full definition
+				parse_tree& tmp2 =  src.c_array<0>()[i+k];				
+				const type_system::type_index vr_tmp = tmp2.type_code.base_type_index;
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
+				assert(tmp3);
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+				assert(parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace)==vr_tmp);
+				assert(parse_tree::types->get_C_structdef(vr_tmp));
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here
+					//! \test decl.C99/Error_class_def_const.hpp
+					//! \test decl.C99/Error_class_def_const2.hpp
+					//! \test decl.C99/Error_class_def_volatile.hpp
+					//! \test decl.C99/Error_class_def_volatile2.hpp
+					//! \test decl.C99/Error_class_def_const_volatile.hpp
+					//! \test decl.C99/Error_class_def_const_volatile2.hpp
+					//! \test decl.C99/Error_class_def_const_volatile3.hpp
+					//! \test decl.C99/Error_class_def_const_volatile4.hpp
+					//! \test decl.C99/Error_class_def_const_volatile5.hpp
+					//! \test decl.C99/Error_class_def_const_volatile6.hpp
+					CPP0X_flush_const_volatile_without_object(tmp2);
+					// accept definition
+					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+					continue;
+					}
+				}
+				break;
 				case CLASS_ANON_DEF:
 				{	// anonymous types cannot be matched
 				// tentatively forward-declare immediately
@@ -14234,8 +14348,8 @@
 					if (bool_options[boolopt::warnings_are_errors])
 						zcc_errors.inc_error();
 					// remove from parse
-					src.DeleteNSlotsAt<0>(i+pre_invariant_decl_scanner.size(),i);
-					goto rescan;
+					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+					goto restart_master_loop;
 					}
 				}
 				break;
@@ -14841,99 +14955,7 @@
 				}
 			}
 			break;
-			case CLASS_NAMED_DEF:
-			{	// can only define once
-			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			if (tmp)
-				{
-				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
-					{	//! \test zcc/decl.C99/Error_class_multidef.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'class ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' already defined (C++98 3.2p1)");
-					message_header(fatal_def->_decl);
-					INFORM("prior definition here");
-					zcc_errors.inc_error();
-					// reduce to named-specifier
-					src.c_array<0>()[i].DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(src.data<0>()[i],"class"));
-					goto reparse;
-					}					
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				}
-			// One Definition Rule states that conflicting enum, struct, or class must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_union_as_class2.hpp
-					//! \test zcc/decl.C99/Error_union_as_class4.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("class ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C++98 One Definition Rule)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_enum_as_class2.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("class ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C++98 One Definition Rule)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
-			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==vr_tmp);
-			assert(parse_tree::types->get_C_structdef(vr_tmp));
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here
-				//! \test decl.C99/Error_class_def_const.hpp
-				//! \test decl.C99/Error_class_def_const2.hpp
-				//! \test decl.C99/Error_class_def_volatile.hpp
-				//! \test decl.C99/Error_class_def_volatile2.hpp
-				//! \test decl.C99/Error_class_def_const_volatile.hpp
-				//! \test decl.C99/Error_class_def_const_volatile2.hpp
-				//! \test decl.C99/Error_class_def_const_volatile3.hpp
-				//! \test decl.C99/Error_class_def_const_volatile4.hpp
-				//! \test decl.C99/Error_class_def_const_volatile5.hpp
-				//! \test decl.C99/Error_class_def_const_volatile6.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				// accept definition
-				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				i += 2;
-				continue;
-				}
-			}
-			break;
+			case CLASS_NAMED_DEF: break;	/* already handled */
 			case UNION_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-07 01:42:08 UTC (rev 557)
+++ trunk/CSupport.cpp.in	2011-01-07 03:10:39 UTC (rev 558)
@@ -14236,12 +14236,12 @@
 {
 	parse_tree& tmp = src.c_array<0>()[i];
 #ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
 #else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename);
 	assert(tmp2);
-	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace));
+	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace)==tmp2);
 	assert(parse_tree::types->get_structdecl(tmp2));
 	tmp.type_code.set_type(tmp2);
 #endif
@@ -14249,6 +14249,24 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 }
 
+static void _forward_declare_CPP_class_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	parse_tree& tmp = src.c_array<0>()[i+k];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
+#else
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace));
+	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
+	invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+	_condense_const_volatile_onto_type_preparsed(src,i,k,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+}
+
 // handle namespaces or else
 //! \todo check that the fact all literals are already legal-form is used
 //! \throw std::bad_alloc
@@ -14282,6 +14300,7 @@
 	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier);
 	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1+12,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier_or_tag);
 	size_t i = 0;
+restart_master_loop:
 	while(i<src.size<0>())
 		{
 		conserve_tokens(src.c_array<0>()[i]);
@@ -14336,7 +14355,102 @@
 				case STRUCT_NAMED_DEF: break;
 				case STRUCT_ANON_DEF: break;
 				case CLASS_NAME: break;
-				case CLASS_NAMED_DEF: break;
+				case CLASS_NAMED_DEF:
+				{	// can only define once
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				{
+				parse_tree& tmp2 =  src.c_array<0>()[i+k];				
+				if (tmp)
+					{
+					if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
+						{	//! \test zcc/decl.C99/Error_class_multidef.hpp
+						message_header(src.data<0>()[i+k].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("'class ");
+						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INFORM("' already defined (C++98 3.2p1)");
+						message_header(fatal_def->_decl);
+						INFORM("prior definition here");
+						zcc_errors.inc_error();
+						// reduce to named-specifier
+						tmp2.DeleteIdx<2>(0);
+						assert(is_C99_named_specifier(tmp2,"class"));
+						goto rescan;
+						}					
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+					}
+				// One Definition Rule states that conflicting enum, struct, or class must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_union_as_class2.hpp
+						//! \test zcc/decl.C99/Error_union_as_class4.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("class ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C++98 One Definition Rule)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_enum_as_class2.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("class ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C++98 One Definition Rule)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+				else _forward_declare_CPP_class_preparsed(src,active_namespace,i,k,pre_invariant_decl_scanner);
+				}
+				// parse the union and upgrade it to a full definition
+				parse_tree& tmp2 =  src.c_array<0>()[i+k];				
+				const type_system::type_index vr_tmp = tmp2.type_code.base_type_index;
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
+				assert(tmp3);
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+				assert(parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace)==vr_tmp);
+				assert(parse_tree::types->get_C_structdef(vr_tmp));
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here
+					//! \test decl.C99/Error_class_def_const.hpp
+					//! \test decl.C99/Error_class_def_const2.hpp
+					//! \test decl.C99/Error_class_def_volatile.hpp
+					//! \test decl.C99/Error_class_def_volatile2.hpp
+					//! \test decl.C99/Error_class_def_const_volatile.hpp
+					//! \test decl.C99/Error_class_def_const_volatile2.hpp
+					//! \test decl.C99/Error_class_def_const_volatile3.hpp
+					//! \test decl.C99/Error_class_def_const_volatile4.hpp
+					//! \test decl.C99/Error_class_def_const_volatile5.hpp
+					//! \test decl.C99/Error_class_def_const_volatile6.hpp
+					CPP0X_flush_const_volatile_without_object(tmp2);
+					// accept definition
+					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+					continue;
+					}
+				}
+				break;
 				case CLASS_ANON_DEF:
 				{	// anonymous types cannot be matched
 				// tentatively forward-declare immediately
@@ -14381,8 +14495,8 @@
 					if (bool_options[boolopt::warnings_are_errors])
 						zcc_errors.inc_error();
 					// remove from parse
-					src.DeleteNSlotsAt<0>(i+pre_invariant_decl_scanner.size(),i);
-					goto rescan;
+					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+					goto restart_master_loop;
 					}
 				}
 				break;
@@ -14988,99 +15102,7 @@
 				}
 			}
 			break;
-			case CLASS_NAMED_DEF:
-			{	// can only define once
-			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			if (tmp)
-				{
-				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
-					{	//! \test zcc/decl.C99/Error_class_multidef.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'class ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' already defined (C++98 3.2p1)");
-					message_header(fatal_def->_decl);
-					INFORM("prior definition here");
-					zcc_errors.inc_error();
-					// reduce to named-specifier
-					src.c_array<0>()[i].DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(src.data<0>()[i],"class"));
-					goto reparse;
-					}					
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				}
-			// One Definition Rule states that conflicting enum, struct, or class must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_union_as_class2.hpp
-					//! \test zcc/decl.C99/Error_union_as_class4.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("class ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C++98 One Definition Rule)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_enum_as_class2.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("class ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C++98 One Definition Rule)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
-			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==vr_tmp);
-			assert(parse_tree::types->get_C_structdef(vr_tmp));
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here
-				//! \test decl.C99/Error_class_def_const.hpp
-				//! \test decl.C99/Error_class_def_const2.hpp
-				//! \test decl.C99/Error_class_def_volatile.hpp
-				//! \test decl.C99/Error_class_def_volatile2.hpp
-				//! \test decl.C99/Error_class_def_const_volatile.hpp
-				//! \test decl.C99/Error_class_def_const_volatile2.hpp
-				//! \test decl.C99/Error_class_def_const_volatile3.hpp
-				//! \test decl.C99/Error_class_def_const_volatile4.hpp
-				//! \test decl.C99/Error_class_def_const_volatile5.hpp
-				//! \test decl.C99/Error_class_def_const_volatile6.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				// accept definition
-				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				i += 2;
-				continue;
-				}
-			}
-			break;
+			case CLASS_NAMED_DEF: break;	/* already handled */
 			case UNION_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately



From zaimoni at mail.berlios.de  Fri Jan  7 05:35:05 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri,  7 Jan 2011 05:35:05 +0100
Subject: [Zcplusplus-commits] r559 - trunk
Message-ID: <20110107043505.E07C5480A1E@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-07 05:35:05 +0100 (Fri, 07 Jan 2011)
New Revision: 559

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
handle too-many-types declarations early

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-07 03:10:39 UTC (rev 558)
+++ trunk/CSupport.cpp	2011-01-07 04:35:05 UTC (rev 559)
@@ -13121,6 +13121,46 @@
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
 			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse
+			{	// check for too many types now
+			size_t typecount = pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list));
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAMED_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_ANON_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAMED_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_ANON_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAMED_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_ANON_DEF);
+			if (1<typecount)
+				{
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("declaration trying to attribute more than one type");
+				zcc_errors.inc_error();
+				// flush the extra types by how annoying they are to the parser
+				// names and already-parsed types go first
+				size_t k = pre_invariant_decl_scanner.size();
+				assert(0<k);
+				do	switch(pre_invariant_decl_scanner[--k])
+					{
+					case STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME:
+					case STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME:
+					case STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME:
+					case STATIC_SIZE(C99_nontype_decl_specifier_list):
+						src.DeleteIdx<0>(i+k);
+						pre_invariant_decl_scanner.DeleteIdx(k);
+						--typecount;
+					}
+				while(0<k && 1<typecount);
+				if (1<typecount)
+					{	// cascading errors: cauterize now
+					INFORM("must discard definition to reduce declaration to one type: stopping to prevent spurious errors");
+					return;
+					}
+				}
+			}
+
 			size_t k = 0;
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(C99_nontype_decl_specifier_list))
 				{
@@ -14198,6 +14238,50 @@
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
 			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse
+			{	// check for too many types now
+			size_t typecount = pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAMED_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_ANON_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAMED_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_ANON_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAMED_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_ANON_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAMED_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_ANON_DEF);
+			if (1<typecount)
+				{
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("declaration trying to attribute more than one type (C++98 7.1.5p2; C++0X 7.1.6p2)");
+				zcc_errors.inc_error();
+				// flush the extra types by how annoying they are to the parser
+				// names and already-parsed types go first
+				size_t k = pre_invariant_decl_scanner.size();
+				assert(0<k);
+				do	switch(pre_invariant_decl_scanner[--k])
+					{
+					case STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME:
+					case STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME:
+					case STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME:
+					case STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME:
+					case STATIC_SIZE(CPP0X_nontype_decl_specifier_list):
+						src.DeleteIdx<0>(i+k);
+						pre_invariant_decl_scanner.DeleteIdx(k);
+						--typecount;
+					}
+				while(0<k && 1<typecount);
+				if (1<typecount)
+					{	// cascading errors: cauterize now
+					INFORM("must discard definition to reduce declaration to one type: stopping to prevent spurious errors");
+					return;
+					}
+				}
+			}
+
 			size_t k = 0;
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(CPP0X_nontype_decl_specifier_list))
 				{

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-07 03:10:39 UTC (rev 558)
+++ trunk/CSupport.cpp.in	2011-01-07 04:35:05 UTC (rev 559)
@@ -13268,6 +13268,46 @@
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
 			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse
+			{	// check for too many types now
+			size_t typecount = pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list));
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAMED_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_ANON_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAMED_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_ANON_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAMED_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_ANON_DEF);
+			if (1<typecount)
+				{
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("declaration trying to attribute more than one type");
+				zcc_errors.inc_error();
+				// flush the extra types by how annoying they are to the parser
+				// names and already-parsed types go first
+				size_t k = pre_invariant_decl_scanner.size();
+				assert(0<k);
+				do	switch(pre_invariant_decl_scanner[--k])
+					{
+					case STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME:
+					case STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME:
+					case STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME:
+					case STATIC_SIZE(C99_nontype_decl_specifier_list):
+						src.DeleteIdx<0>(i+k);
+						pre_invariant_decl_scanner.DeleteIdx(k);
+						--typecount;
+					}
+				while(0<k && 1<typecount);
+				if (1<typecount)
+					{	// cascading errors: cauterize now
+					INFORM("must discard definition to reduce declaration to one type: stopping to prevent spurious errors");
+					return;
+					}
+				}
+			}
+
 			size_t k = 0;
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(C99_nontype_decl_specifier_list))
 				{
@@ -14345,6 +14385,50 @@
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
 			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse
+			{	// check for too many types now
+			size_t typecount = pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAMED_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_ANON_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAMED_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_ANON_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAMED_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_ANON_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAMED_DEF);
+			typecount += pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_ANON_DEF);
+			if (1<typecount)
+				{
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("declaration trying to attribute more than one type (C++98 7.1.5p2; C++0X 7.1.6p2)");
+				zcc_errors.inc_error();
+				// flush the extra types by how annoying they are to the parser
+				// names and already-parsed types go first
+				size_t k = pre_invariant_decl_scanner.size();
+				assert(0<k);
+				do	switch(pre_invariant_decl_scanner[--k])
+					{
+					case STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME:
+					case STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME:
+					case STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME:
+					case STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME:
+					case STATIC_SIZE(CPP0X_nontype_decl_specifier_list):
+						src.DeleteIdx<0>(i+k);
+						pre_invariant_decl_scanner.DeleteIdx(k);
+						--typecount;
+					}
+				while(0<k && 1<typecount);
+				if (1<typecount)
+					{	// cascading errors: cauterize now
+					INFORM("must discard definition to reduce declaration to one type: stopping to prevent spurious errors");
+					return;
+					}
+				}
+			}
+
 			size_t k = 0;
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(CPP0X_nontype_decl_specifier_list))
 				{



From zaimoni at mail.berlios.de  Sun Jan  9 00:13:56 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun,  9 Jan 2011 00:13:56 +0100
Subject: [Zcplusplus-commits] r560 - trunk
Message-ID: <20110108231357.26A41480BEC@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-09 00:13:56 +0100 (Sun, 09 Jan 2011)
New Revision: 560

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
make class name parsing closer to standard-compliant

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-07 04:35:05 UTC (rev 559)
+++ trunk/CSupport.cpp	2011-01-08 23:13:56 UTC (rev 560)
@@ -14125,23 +14125,6 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 }
 
-static void _forward_declare_CPP_class(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
-{
-	parse_tree& tmp = src.c_array<0>()[i];
-#ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
-#else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename);
-	assert(tmp2);
-	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace));
-	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace)==tmp2);
-	assert(parse_tree::types->get_structdecl(tmp2));
-	tmp.type_code.set_type(tmp2);
-#endif
-	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
-	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-}
-
 static void _forward_declare_CPP_class_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i+k];
@@ -14280,6 +14263,12 @@
 					return;
 					}
 				}
+			//! \bug check for pre-existing typedefs if no types
+			if (0>=typecount)
+				{
+				pre_invariant_decl_scanner.clear();	// RAM efficiency
+				goto reparse;
+				}
 			}
 
 			size_t k = 0;
@@ -14291,7 +14280,105 @@
 				case STRUCT_NAME: break;
 				case STRUCT_NAMED_DEF: break;
 				case STRUCT_ANON_DEF: break;
-				case CLASS_NAME: break;
+				case CLASS_NAME:
+				{
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (tmp)
+					{
+					assert(0<parse_tree::types->use_count(tmp));
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+					}
+				// One Definition Rule states that conflicting enum, struct, or class must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_union_as_class.hpp
+						//! \test zcc/decl.C99/Error_union_as_class3.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("class ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C++98 One Definition Rule)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_enum_as_class.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("class ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C++98 One Definition Rule)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+				else _forward_declare_CPP_class_preparsed(src,active_namespace,i,k,pre_invariant_decl_scanner);
+				}
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here
+					//! \test decl.C99/Error_class_forward_def_const.hpp
+					//! \test decl.C99/Error_class_forward_def_const2.hpp
+					//! \test decl.C99/Error_class_forward_def_const3.hpp
+					//! \test decl.C99/Error_class_forward_def_const4.hpp
+					//! \test decl.C99/Error_class_forward_def_volatile.hpp
+					//! \test decl.C99/Error_class_forward_def_volatile2.hpp
+					//! \test decl.C99/Error_class_forward_def_volatile3.hpp
+					//! \test decl.C99/Error_class_forward_def_volatile4.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile2.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile3.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile4.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile5.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile6.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile7.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile8.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile9.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile10.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile11.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile12.hpp
+					CPP0X_flush_const_volatile_without_object(tmp2);
+					if (tmp)
+						{	// but if already (forward-)declared then this is a no-op
+							// think this is common enough to not warrant OAOO/DRY treatment
+						//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+						// remove from parse
+						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						goto restart_master_loop;
+						}
+					// forward-declare
+					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+					i += 1+pre_invariant_decl_scanner.size();
+					goto restart_master_loop;
+					}
+				else if (!tmp)
+					{	// used without at least forward-declaring
+						//! \bug needs test cases
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("used without at least forward-declaring");
+					zcc_errors.inc_error();
+					}
+				i += pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
+				}
+//				break;
 				case CLASS_NAMED_DEF:
 				{	// can only define once
 				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
@@ -14384,10 +14471,11 @@
 					CPP0X_flush_const_volatile_without_object(tmp2);
 					// accept definition
 					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-					continue;
 					}
+				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
 				}
-				break;
+//				break;
 				case CLASS_ANON_DEF:
 				{	// anonymous types cannot be matched
 				// tentatively forward-declare immediately
@@ -14435,9 +14523,12 @@
 					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
 					goto restart_master_loop;
 					}
+				i += pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
 				}
-				break;
+//				break;
 				//! \bug the enums aren't handling const/volatile qualification
+				//! \bug the enums aren't noticing semicolon termination
 				case ENUM_NAME:
 				{
 				parse_tree& tmp2 =  src.c_array<0>()[i+k];
@@ -14457,9 +14548,10 @@
 					tmp2.type_code.set_type(C_TYPE::INT);	// fail over to int, like C
 					tmp2.flags |= (parse_tree::INVALID | PARSE_PRIMARY_TYPE);
 					};
-				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
 				}
-				break;
+//				break;
 				case ENUM_NAMED_DEF:
 				{	// can only define once
 				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
@@ -14511,14 +14603,20 @@
 					INC_INFORM(" declared as ");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
-					INC_INFORM(text_from_keyword(*tmp3));
+					const char* const text = text_from_keyword(*tmp3);
+					INC_INFORM(text);
 					INFORM(" (C++98 One Definition Rule)");
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("struct");
+					tmp2.set_index_token_from_str_literal<0>(text);
 					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"struct"));
+					assert(is_C99_named_specifier(tmp2,text_from_keyword(*tmp3)));
+					if (!strcmp("class",text))
+						{
+						pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
+						continue;
+						}
 					goto rescan;
 					}
 				//! \test zcc/decl.C99/Pass_enum_def.hpp
@@ -14532,9 +14630,10 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
 				}
-				break;
+//				break;
 				case ENUM_ANON_DEF:
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.hpp
@@ -14547,7 +14646,8 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
 				}
 				}
 			while(pre_invariant_decl_scanner.size()> ++k);
@@ -14755,100 +14855,7 @@
 				}
 			}
 			break;
-			case CLASS_NAME:
-			{
-			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			if (tmp)
-				{
-				assert(0<parse_tree::types->use_count(tmp));
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				}
-			// One Definition Rule states that conflicting enum, struct, or class must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_union_as_class.hpp
-					//! \test zcc/decl.C99/Error_union_as_class3.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("class ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C++98 One Definition Rule)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_enum_as_class.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("class ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C++98 One Definition Rule)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here
-				//! \test decl.C99/Error_class_forward_def_const.hpp
-				//! \test decl.C99/Error_class_forward_def_const2.hpp
-				//! \test decl.C99/Error_class_forward_def_const3.hpp
-				//! \test decl.C99/Error_class_forward_def_const4.hpp
-				//! \test decl.C99/Error_class_forward_def_volatile.hpp
-				//! \test decl.C99/Error_class_forward_def_volatile2.hpp
-				//! \test decl.C99/Error_class_forward_def_volatile3.hpp
-				//! \test decl.C99/Error_class_forward_def_volatile4.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile2.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile3.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile4.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile5.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile6.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile7.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile8.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile9.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile10.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile11.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile12.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				if (tmp)
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-					// remove from parse
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;					
-					}
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				i += 2;
-				continue;
-				}
-			else if (!tmp)
-				{	// used without at least forward-declaring
-					//! \bug needs test cases
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("used without at least forward-declaring");
-				zcc_errors.inc_error();
-				}
-			}
-			break;
+			case CLASS_NAME: break;	/* already handled */
 			case UNION_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-07 04:35:05 UTC (rev 559)
+++ trunk/CSupport.cpp.in	2011-01-08 23:13:56 UTC (rev 560)
@@ -14272,23 +14272,6 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 }
 
-static void _forward_declare_CPP_class(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
-{
-	parse_tree& tmp = src.c_array<0>()[i];
-#ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
-#else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename);
-	assert(tmp2);
-	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace));
-	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace)==tmp2);
-	assert(parse_tree::types->get_structdecl(tmp2));
-	tmp.type_code.set_type(tmp2);
-#endif
-	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
-	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-}
-
 static void _forward_declare_CPP_class_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i+k];
@@ -14427,6 +14410,12 @@
 					return;
 					}
 				}
+			//! \bug check for pre-existing typedefs if no types
+			if (0>=typecount)
+				{
+				pre_invariant_decl_scanner.clear();	// RAM efficiency
+				goto reparse;
+				}
 			}
 
 			size_t k = 0;
@@ -14438,7 +14427,105 @@
 				case STRUCT_NAME: break;
 				case STRUCT_NAMED_DEF: break;
 				case STRUCT_ANON_DEF: break;
-				case CLASS_NAME: break;
+				case CLASS_NAME:
+				{
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (tmp)
+					{
+					assert(0<parse_tree::types->use_count(tmp));
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+					}
+				// One Definition Rule states that conflicting enum, struct, or class must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_union_as_class.hpp
+						//! \test zcc/decl.C99/Error_union_as_class3.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("class ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C++98 One Definition Rule)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_enum_as_class.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("class ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C++98 One Definition Rule)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+				else _forward_declare_CPP_class_preparsed(src,active_namespace,i,k,pre_invariant_decl_scanner);
+				}
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here
+					//! \test decl.C99/Error_class_forward_def_const.hpp
+					//! \test decl.C99/Error_class_forward_def_const2.hpp
+					//! \test decl.C99/Error_class_forward_def_const3.hpp
+					//! \test decl.C99/Error_class_forward_def_const4.hpp
+					//! \test decl.C99/Error_class_forward_def_volatile.hpp
+					//! \test decl.C99/Error_class_forward_def_volatile2.hpp
+					//! \test decl.C99/Error_class_forward_def_volatile3.hpp
+					//! \test decl.C99/Error_class_forward_def_volatile4.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile2.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile3.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile4.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile5.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile6.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile7.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile8.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile9.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile10.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile11.hpp
+					//! \test decl.C99/Error_class_forward_def_const_volatile12.hpp
+					CPP0X_flush_const_volatile_without_object(tmp2);
+					if (tmp)
+						{	// but if already (forward-)declared then this is a no-op
+							// think this is common enough to not warrant OAOO/DRY treatment
+						//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+						// remove from parse
+						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						goto restart_master_loop;
+						}
+					// forward-declare
+					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+					i += 1+pre_invariant_decl_scanner.size();
+					goto restart_master_loop;
+					}
+				else if (!tmp)
+					{	// used without at least forward-declaring
+						//! \bug needs test cases
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("used without at least forward-declaring");
+					zcc_errors.inc_error();
+					}
+				i += pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
+				}
+//				break;
 				case CLASS_NAMED_DEF:
 				{	// can only define once
 				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
@@ -14531,10 +14618,11 @@
 					CPP0X_flush_const_volatile_without_object(tmp2);
 					// accept definition
 					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-					continue;
 					}
+				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
 				}
-				break;
+//				break;
 				case CLASS_ANON_DEF:
 				{	// anonymous types cannot be matched
 				// tentatively forward-declare immediately
@@ -14582,9 +14670,12 @@
 					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
 					goto restart_master_loop;
 					}
+				i += pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
 				}
-				break;
+//				break;
 				//! \bug the enums aren't handling const/volatile qualification
+				//! \bug the enums aren't noticing semicolon termination
 				case ENUM_NAME:
 				{
 				parse_tree& tmp2 =  src.c_array<0>()[i+k];
@@ -14604,9 +14695,10 @@
 					tmp2.type_code.set_type(C_TYPE::INT);	// fail over to int, like C
 					tmp2.flags |= (parse_tree::INVALID | PARSE_PRIMARY_TYPE);
 					};
-				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
 				}
-				break;
+//				break;
 				case ENUM_NAMED_DEF:
 				{	// can only define once
 				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
@@ -14658,14 +14750,20 @@
 					INC_INFORM(" declared as ");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
-					INC_INFORM(text_from_keyword(*tmp3));
+					const char* const text = text_from_keyword(*tmp3);
+					INC_INFORM(text);
 					INFORM(" (C++98 One Definition Rule)");
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("struct");
+					tmp2.set_index_token_from_str_literal<0>(text);
 					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"struct"));
+					assert(is_C99_named_specifier(tmp2,text_from_keyword(*tmp3)));
+					if (!strcmp("class",text))
+						{
+						pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
+						continue;
+						}
 					goto rescan;
 					}
 				//! \test zcc/decl.C99/Pass_enum_def.hpp
@@ -14679,9 +14777,10 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
 				}
-				break;
+//				break;
 				case ENUM_ANON_DEF:
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.hpp
@@ -14694,7 +14793,8 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
 				}
 				}
 			while(pre_invariant_decl_scanner.size()> ++k);
@@ -14902,100 +15002,7 @@
 				}
 			}
 			break;
-			case CLASS_NAME:
-			{
-			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			if (tmp)
-				{
-				assert(0<parse_tree::types->use_count(tmp));
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				}
-			// One Definition Rule states that conflicting enum, struct, or class must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_union_as_class.hpp
-					//! \test zcc/decl.C99/Error_union_as_class3.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("class ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C++98 One Definition Rule)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_enum_as_class.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("class ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C++98 One Definition Rule)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here
-				//! \test decl.C99/Error_class_forward_def_const.hpp
-				//! \test decl.C99/Error_class_forward_def_const2.hpp
-				//! \test decl.C99/Error_class_forward_def_const3.hpp
-				//! \test decl.C99/Error_class_forward_def_const4.hpp
-				//! \test decl.C99/Error_class_forward_def_volatile.hpp
-				//! \test decl.C99/Error_class_forward_def_volatile2.hpp
-				//! \test decl.C99/Error_class_forward_def_volatile3.hpp
-				//! \test decl.C99/Error_class_forward_def_volatile4.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile2.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile3.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile4.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile5.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile6.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile7.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile8.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile9.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile10.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile11.hpp
-				//! \test decl.C99/Error_class_forward_def_const_volatile12.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				if (tmp)
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-					// remove from parse
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;					
-					}
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				i += 2;
-				continue;
-				}
-			else if (!tmp)
-				{	// used without at least forward-declaring
-					//! \bug needs test cases
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("used without at least forward-declaring");
-				zcc_errors.inc_error();
-				}
-			}
-			break;
+			case CLASS_NAME: break;	/* already handled */
 			case UNION_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);



From zaimoni at mail.berlios.de  Sun Jan  9 08:55:46 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun,  9 Jan 2011 08:55:46 +0100
Subject: [Zcplusplus-commits] r561 - trunk
Message-ID: <20110109075546.5E9E1480A26@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-09 08:55:45 +0100 (Sun, 09 Jan 2011)
New Revision: 561

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
C++ anomymous structs: converge parsing towards standard

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-08 23:13:56 UTC (rev 560)
+++ trunk/CSupport.cpp	2011-01-09 07:55:45 UTC (rev 561)
@@ -14279,7 +14279,56 @@
 				case UNION_ANON_DEF: break;
 				case STRUCT_NAME: break;
 				case STRUCT_NAMED_DEF: break;
-				case STRUCT_ANON_DEF: break;
+				case STRUCT_ANON_DEF:
+				{	// anonymous types cannot be matched
+				// tentatively forward-declare immediately
+				const type_system::type_index tmp = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct,src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
+				assert(tmp);
+				assert(parse_tree::types->get_structdecl(tmp));
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				tmp2.type_code.set_type(tmp);
+				tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+				}
+				_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+
+				// parse the union and upgrade it to a full definition
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp);
+				assert(tmp3);
+				const parse_tree& tmp2 = src.data<0>()[i+k];
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(tmp,tmp4);
+				assert(parse_tree::types->get_C_structdef(tmp));
+
+				if (semicolon_terminated_decl)
+					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \test decl.C99/Error_struct_anon_def_const.hpp
+					//! \test decl.C99/Error_struct_anon_def_const2.hpp
+					//! \test decl.C99/Error_struct_anon_def_volatile.hpp
+					//! \test decl.C99/Error_struct_anon_def_volatile2.hpp
+					//! \test decl.C99/Error_struct_anon_def_const_volatile.hpp
+					//! \test decl.C99/Error_struct_anon_def_const_volatile2.hpp
+					//! \test decl.C99/Error_struct_anon_def_const_volatile3.hpp
+					//! \test decl.C99/Error_struct_anon_def_const_volatile4.hpp
+					//! \test decl.C99/Error_struct_anon_def_const_volatile5.hpp
+					//! \test decl.C99/Error_struct_anon_def_const_volatile6.hpp
+					CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("unreferenceable anonymous struct declaration");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// remove from parse
+					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+					goto restart_master_loop;
+					}
+				i += pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
+				}
+//				break;
 				case CLASS_NAME:
 				{
 				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
@@ -15094,51 +15143,7 @@
 				}
 			}
 			break;
-			case STRUCT_ANON_DEF:
-			{	// anonymous types cannot be matched
-			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			assert(tmp2);
-			assert(parse_tree::types->get_structdecl(tmp2));
-			src.c_array<0>()[i].type_code.set_type(tmp2);
-			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-
-			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
-			assert(parse_tree::types->get_C_structdef(tmp2));
-
-			if (	1<src.size<0>()-i
-				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				//! \test decl.C99/Error_struct_anon_def_const.hpp
-				//! \test decl.C99/Error_struct_anon_def_const2.hpp
-				//! \test decl.C99/Error_struct_anon_def_volatile.hpp
-				//! \test decl.C99/Error_struct_anon_def_volatile2.hpp
-				//! \test decl.C99/Error_struct_anon_def_const_volatile.hpp
-				//! \test decl.C99/Error_struct_anon_def_const_volatile2.hpp
-				//! \test decl.C99/Error_struct_anon_def_const_volatile3.hpp
-				//! \test decl.C99/Error_struct_anon_def_const_volatile4.hpp
-				//! \test decl.C99/Error_struct_anon_def_const_volatile5.hpp
-				//! \test decl.C99/Error_struct_anon_def_const_volatile6.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-				//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous struct declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			}
-			break;
+			case STRUCT_ANON_DEF: break;	/* already handled */
 			case CLASS_ANON_DEF: break;	/* already handled */
 			case ENUM_NAME: break;	/* already handled */
 			case ENUM_NAMED_DEF: break;	/* already handled */

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-08 23:13:56 UTC (rev 560)
+++ trunk/CSupport.cpp.in	2011-01-09 07:55:45 UTC (rev 561)
@@ -14426,7 +14426,56 @@
 				case UNION_ANON_DEF: break;
 				case STRUCT_NAME: break;
 				case STRUCT_NAMED_DEF: break;
-				case STRUCT_ANON_DEF: break;
+				case STRUCT_ANON_DEF:
+				{	// anonymous types cannot be matched
+				// tentatively forward-declare immediately
+				const type_system::type_index tmp = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct,src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
+				assert(tmp);
+				assert(parse_tree::types->get_structdecl(tmp));
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				tmp2.type_code.set_type(tmp);
+				tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+				}
+				_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+
+				// parse the union and upgrade it to a full definition
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp);
+				assert(tmp3);
+				const parse_tree& tmp2 = src.data<0>()[i+k];
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(tmp,tmp4);
+				assert(parse_tree::types->get_C_structdef(tmp));
+
+				if (semicolon_terminated_decl)
+					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \test decl.C99/Error_struct_anon_def_const.hpp
+					//! \test decl.C99/Error_struct_anon_def_const2.hpp
+					//! \test decl.C99/Error_struct_anon_def_volatile.hpp
+					//! \test decl.C99/Error_struct_anon_def_volatile2.hpp
+					//! \test decl.C99/Error_struct_anon_def_const_volatile.hpp
+					//! \test decl.C99/Error_struct_anon_def_const_volatile2.hpp
+					//! \test decl.C99/Error_struct_anon_def_const_volatile3.hpp
+					//! \test decl.C99/Error_struct_anon_def_const_volatile4.hpp
+					//! \test decl.C99/Error_struct_anon_def_const_volatile5.hpp
+					//! \test decl.C99/Error_struct_anon_def_const_volatile6.hpp
+					CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("unreferenceable anonymous struct declaration");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// remove from parse
+					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+					goto restart_master_loop;
+					}
+				i += pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
+				}
+//				break;
 				case CLASS_NAME:
 				{
 				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
@@ -15241,51 +15290,7 @@
 				}
 			}
 			break;
-			case STRUCT_ANON_DEF:
-			{	// anonymous types cannot be matched
-			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			assert(tmp2);
-			assert(parse_tree::types->get_structdecl(tmp2));
-			src.c_array<0>()[i].type_code.set_type(tmp2);
-			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-
-			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
-			assert(parse_tree::types->get_C_structdef(tmp2));
-
-			if (	1<src.size<0>()-i
-				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				//! \test decl.C99/Error_struct_anon_def_const.hpp
-				//! \test decl.C99/Error_struct_anon_def_const2.hpp
-				//! \test decl.C99/Error_struct_anon_def_volatile.hpp
-				//! \test decl.C99/Error_struct_anon_def_volatile2.hpp
-				//! \test decl.C99/Error_struct_anon_def_const_volatile.hpp
-				//! \test decl.C99/Error_struct_anon_def_const_volatile2.hpp
-				//! \test decl.C99/Error_struct_anon_def_const_volatile3.hpp
-				//! \test decl.C99/Error_struct_anon_def_const_volatile4.hpp
-				//! \test decl.C99/Error_struct_anon_def_const_volatile5.hpp
-				//! \test decl.C99/Error_struct_anon_def_const_volatile6.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-				//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous struct declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			}
-			break;
+			case STRUCT_ANON_DEF: break;	/* already handled */
 			case CLASS_ANON_DEF: break;	/* already handled */
 			case ENUM_NAME: break;	/* already handled */
 			case ENUM_NAMED_DEF: break;	/* already handled */



From zaimoni at mail.berlios.de  Sun Jan  9 19:59:22 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun,  9 Jan 2011 19:59:22 +0100
Subject: [Zcplusplus-commits] r562 - trunk
Message-ID: <20110109185922.F17FD480BE5@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-09 19:59:22 +0100 (Sun, 09 Jan 2011)
New Revision: 562

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
C++ named struct defintions: bring parsing closer to standard

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-09 07:55:45 UTC (rev 561)
+++ trunk/CSupport.cpp	2011-01-09 18:59:22 UTC (rev 562)
@@ -14125,6 +14125,24 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 }
 
+static void _forward_declare_CPP_struct_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	parse_tree& tmp = src.c_array<0>()[i+k];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
+#else
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace));
+	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
+	invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+	_condense_const_volatile_onto_type_preparsed(src,i,k,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+}
+
 static void _forward_declare_CPP_class_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i+k];
@@ -14278,7 +14296,103 @@
 				case UNION_NAMED_DEF: break;
 				case UNION_ANON_DEF: break;
 				case STRUCT_NAME: break;
-				case STRUCT_NAMED_DEF: break;
+				case STRUCT_NAMED_DEF:
+				{	// can only define once
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (tmp)
+					{
+					if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
+						{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
+						message_header(src.data<0>()[i+k].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("'struct ");
+						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INFORM("' already defined (C++98 3.2p1)");
+						message_header(fatal_def->_decl);
+						INFORM("prior definition here");
+						zcc_errors.inc_error();
+						// reduce to named-specifier
+						tmp2.DeleteIdx<2>(0);
+						assert(is_C99_named_specifier(tmp2,"struct"));
+						goto rescan;
+						}					
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+					}
+				// One Definition Rule states that conflicting enum, struct, or class must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_union_as_struct2.hpp
+						//! \test zcc/decl.C99/Error_union_as_struct4.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C++98 One Definition Rule)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_enum_as_struct2.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C++98 One Definition Rule)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(src.data<0>()[i+k],"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+				else _forward_declare_CPP_struct_preparsed(src,active_namespace,i,k,pre_invariant_decl_scanner);
+				}
+				// parse the union and upgrade it to a full definition
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				const type_system::type_index vr_tmp = tmp2.type_code.base_type_index;
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
+				assert(tmp3);
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+				assert(parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace)==vr_tmp);
+				assert(parse_tree::types->get_C_structdef(vr_tmp));
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here
+					//! \test decl.C99/Error_struct_def_const.hpp
+					//! \test decl.C99/Error_struct_def_const2.hpp
+					//! \test decl.C99/Error_struct_def_volatile.hpp
+					//! \test decl.C99/Error_struct_def_volatile2.hpp
+					//! \test decl.C99/Error_struct_def_const_volatile.hpp
+					//! \test decl.C99/Error_struct_def_const_volatile2.hpp
+					//! \test decl.C99/Error_struct_def_const_volatile3.hpp
+					//! \test decl.C99/Error_struct_def_const_volatile4.hpp
+					//! \test decl.C99/Error_struct_def_const_volatile5.hpp
+					//! \test decl.C99/Error_struct_def_const_volatile6.hpp
+					CPP0X_flush_const_volatile_without_object(tmp2);
+					// accept definition
+					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+					}
+				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
+				}
+//				break;
 				case STRUCT_ANON_DEF:
 				{	// anonymous types cannot be matched
 				// tentatively forward-declare immediately
@@ -14295,7 +14409,7 @@
 				// parse the union and upgrade it to a full definition
 				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp);
 				assert(tmp3);
-				const parse_tree& tmp2 = src.data<0>()[i+k];
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
 				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
 				//! \todo record field structure, etc.
 				parse_tree::types->upgrade_decl_to_def(tmp,tmp4);
@@ -14313,7 +14427,7 @@
 					//! \test decl.C99/Error_struct_anon_def_const_volatile4.hpp
 					//! \test decl.C99/Error_struct_anon_def_const_volatile5.hpp
 					//! \test decl.C99/Error_struct_anon_def_const_volatile6.hpp
-					CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
+					CPP0X_flush_const_volatile_without_object(tmp2);
 					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
 					message_header(tmp2.index_tokens[0]);
@@ -15002,99 +15116,7 @@
 				}
 			}
 			break;
-			case STRUCT_NAMED_DEF:
-			{	// can only define once
-			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			if (tmp)
-				{
-				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
-					{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'struct ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' already defined (C++98 3.2p1)");
-					message_header(fatal_def->_decl);
-					INFORM("prior definition here");
-					zcc_errors.inc_error();
-					// reduce to named-specifier
-					src.c_array<0>()[i].DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-					goto reparse;
-					}					
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				}
-			// One Definition Rule states that conflicting enum, struct, or class must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_union_as_struct2.hpp
-					//! \test zcc/decl.C99/Error_union_as_struct4.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C++98 One Definition Rule)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_enum_as_struct2.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C++98 One Definition Rule)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
-			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==vr_tmp);
-			assert(parse_tree::types->get_C_structdef(vr_tmp));
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here
-				//! \test decl.C99/Error_struct_def_const.hpp
-				//! \test decl.C99/Error_struct_def_const2.hpp
-				//! \test decl.C99/Error_struct_def_volatile.hpp
-				//! \test decl.C99/Error_struct_def_volatile2.hpp
-				//! \test decl.C99/Error_struct_def_const_volatile.hpp
-				//! \test decl.C99/Error_struct_def_const_volatile2.hpp
-				//! \test decl.C99/Error_struct_def_const_volatile3.hpp
-				//! \test decl.C99/Error_struct_def_const_volatile4.hpp
-				//! \test decl.C99/Error_struct_def_const_volatile5.hpp
-				//! \test decl.C99/Error_struct_def_const_volatile6.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				// accept definition
-				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				i += 2;
-				continue;
-				}
-			}
-			break;
+			case STRUCT_NAMED_DEF: break;	/* already handled */
 			case CLASS_NAMED_DEF: break;	/* already handled */
 			case UNION_ANON_DEF:
 			{	// anonymous types cannot be matched

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-09 07:55:45 UTC (rev 561)
+++ trunk/CSupport.cpp.in	2011-01-09 18:59:22 UTC (rev 562)
@@ -14272,6 +14272,24 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 }
 
+static void _forward_declare_CPP_struct_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	parse_tree& tmp = src.c_array<0>()[i+k];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
+#else
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace));
+	assert(parse_tree::types->get_id_struct_class_CPP(tmp.index_tokens[1].token.first,active_namespace)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
+	invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+	_condense_const_volatile_onto_type_preparsed(src,i,k,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+}
+
 static void _forward_declare_CPP_class_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i+k];
@@ -14425,7 +14443,103 @@
 				case UNION_NAMED_DEF: break;
 				case UNION_ANON_DEF: break;
 				case STRUCT_NAME: break;
-				case STRUCT_NAMED_DEF: break;
+				case STRUCT_NAMED_DEF:
+				{	// can only define once
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (tmp)
+					{
+					if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
+						{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
+						message_header(src.data<0>()[i+k].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("'struct ");
+						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INFORM("' already defined (C++98 3.2p1)");
+						message_header(fatal_def->_decl);
+						INFORM("prior definition here");
+						zcc_errors.inc_error();
+						// reduce to named-specifier
+						tmp2.DeleteIdx<2>(0);
+						assert(is_C99_named_specifier(tmp2,"struct"));
+						goto rescan;
+						}					
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+					}
+				// One Definition Rule states that conflicting enum, struct, or class must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_union_as_struct2.hpp
+						//! \test zcc/decl.C99/Error_union_as_struct4.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C++98 One Definition Rule)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_enum_as_struct2.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C++98 One Definition Rule)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(src.data<0>()[i+k],"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+				else _forward_declare_CPP_struct_preparsed(src,active_namespace,i,k,pre_invariant_decl_scanner);
+				}
+				// parse the union and upgrade it to a full definition
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				const type_system::type_index vr_tmp = tmp2.type_code.base_type_index;
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
+				assert(tmp3);
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+				assert(parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace)==vr_tmp);
+				assert(parse_tree::types->get_C_structdef(vr_tmp));
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here
+					//! \test decl.C99/Error_struct_def_const.hpp
+					//! \test decl.C99/Error_struct_def_const2.hpp
+					//! \test decl.C99/Error_struct_def_volatile.hpp
+					//! \test decl.C99/Error_struct_def_volatile2.hpp
+					//! \test decl.C99/Error_struct_def_const_volatile.hpp
+					//! \test decl.C99/Error_struct_def_const_volatile2.hpp
+					//! \test decl.C99/Error_struct_def_const_volatile3.hpp
+					//! \test decl.C99/Error_struct_def_const_volatile4.hpp
+					//! \test decl.C99/Error_struct_def_const_volatile5.hpp
+					//! \test decl.C99/Error_struct_def_const_volatile6.hpp
+					CPP0X_flush_const_volatile_without_object(tmp2);
+					// accept definition
+					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+					}
+				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
+				}
+//				break;
 				case STRUCT_ANON_DEF:
 				{	// anonymous types cannot be matched
 				// tentatively forward-declare immediately
@@ -14442,7 +14556,7 @@
 				// parse the union and upgrade it to a full definition
 				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp);
 				assert(tmp3);
-				const parse_tree& tmp2 = src.data<0>()[i+k];
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
 				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
 				//! \todo record field structure, etc.
 				parse_tree::types->upgrade_decl_to_def(tmp,tmp4);
@@ -14460,7 +14574,7 @@
 					//! \test decl.C99/Error_struct_anon_def_const_volatile4.hpp
 					//! \test decl.C99/Error_struct_anon_def_const_volatile5.hpp
 					//! \test decl.C99/Error_struct_anon_def_const_volatile6.hpp
-					CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
+					CPP0X_flush_const_volatile_without_object(tmp2);
 					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
 					message_header(tmp2.index_tokens[0]);
@@ -15149,99 +15263,7 @@
 				}
 			}
 			break;
-			case STRUCT_NAMED_DEF:
-			{	// can only define once
-			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			if (tmp)
-				{
-				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
-					{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'struct ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' already defined (C++98 3.2p1)");
-					message_header(fatal_def->_decl);
-					INFORM("prior definition here");
-					zcc_errors.inc_error();
-					// reduce to named-specifier
-					src.c_array<0>()[i].DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-					goto reparse;
-					}					
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				}
-			// One Definition Rule states that conflicting enum, struct, or class must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_union_as_struct2.hpp
-					//! \test zcc/decl.C99/Error_union_as_struct4.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C++98 One Definition Rule)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_enum_as_struct2.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C++98 One Definition Rule)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
-			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==vr_tmp);
-			assert(parse_tree::types->get_C_structdef(vr_tmp));
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here
-				//! \test decl.C99/Error_struct_def_const.hpp
-				//! \test decl.C99/Error_struct_def_const2.hpp
-				//! \test decl.C99/Error_struct_def_volatile.hpp
-				//! \test decl.C99/Error_struct_def_volatile2.hpp
-				//! \test decl.C99/Error_struct_def_const_volatile.hpp
-				//! \test decl.C99/Error_struct_def_const_volatile2.hpp
-				//! \test decl.C99/Error_struct_def_const_volatile3.hpp
-				//! \test decl.C99/Error_struct_def_const_volatile4.hpp
-				//! \test decl.C99/Error_struct_def_const_volatile5.hpp
-				//! \test decl.C99/Error_struct_def_const_volatile6.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				// accept definition
-				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				i += 2;
-				continue;
-				}
-			}
-			break;
+			case STRUCT_NAMED_DEF: break;	/* already handled */
 			case CLASS_NAMED_DEF: break;	/* already handled */
 			case UNION_ANON_DEF:
 			{	// anonymous types cannot be matched



From zaimoni at mail.berlios.de  Sun Jan  9 22:49:15 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun,  9 Jan 2011 22:49:15 +0100
Subject: [Zcplusplus-commits] r563 - trunk
Message-ID: <20110109214916.5CC80480BEC@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-09 22:49:15 +0100 (Sun, 09 Jan 2011)
New Revision: 563

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
C++ struct name declarations: converge parsing towards standard

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-09 18:59:22 UTC (rev 562)
+++ trunk/CSupport.cpp	2011-01-09 21:49:15 UTC (rev 563)
@@ -14108,23 +14108,6 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 }
 
-static void _forward_declare_CPP_struct(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
-{
-	parse_tree& tmp = src.c_array<0>()[i];
-#ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
-#else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-	assert(tmp2);
-	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-	assert(parse_tree::types->get_structdecl(tmp2));
-	tmp.type_code.set_type(tmp2);
-#endif
-	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
-	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-}
-
 static void _forward_declare_CPP_struct_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i+k];
@@ -14295,7 +14278,104 @@
 				case UNION_NAME: break;
 				case UNION_NAMED_DEF: break;
 				case UNION_ANON_DEF: break;
-				case STRUCT_NAME: break;
+				case STRUCT_NAME:
+				{
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (tmp)
+					{
+					assert(0<parse_tree::types->use_count(tmp));
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+					}
+				// One Definition Rule states that conflicting enum, struct, or class must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_union_as_struct.hpp
+						//! \test zcc/decl.C99/Error_union_as_struct3.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C++98 One Definition Rule)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_enum_as_struct.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C++98 One Definition Rule)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+				else _forward_declare_CPP_struct_preparsed(src,active_namespace,i,k,pre_invariant_decl_scanner);
+				}
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here
+					//! \test decl.C99/Error_struct_forward_def_const.hpp
+					//! \test decl.C99/Error_struct_forward_def_const2.hpp
+					//! \test decl.C99/Error_struct_forward_def_const3.hpp
+					//! \test decl.C99/Error_struct_forward_def_const4.hpp
+					//! \test decl.C99/Error_struct_forward_def_volatile.hpp
+					//! \test decl.C99/Error_struct_forward_def_volatile2.hpp
+					//! \test decl.C99/Error_struct_forward_def_volatile3.hpp
+					//! \test decl.C99/Error_struct_forward_def_volatile4.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile2.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile3.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile4.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile5.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile6.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile7.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile8.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile9.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile10.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile11.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile12.hpp
+					CPP0X_flush_const_volatile_without_object(tmp2);
+					if (tmp)
+						{	// but if already (forward-)declared then this is a no-op
+							// think this is common enough to not warrant OAOO/DRY treatment
+						//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+						// remove from parse
+						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						goto restart_master_loop;
+						}
+					// forward-declare
+					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+					}
+				else if (!tmp)
+					{	// used without at least forward-declaring
+						//! \bug needs test cases
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("used without at least forward-declaring");
+					zcc_errors.inc_error();
+					}
+				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
+				}
+//				break;
 				case STRUCT_NAMED_DEF:
 				{	// can only define once
 				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
@@ -14311,12 +14391,15 @@
 						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
 						INFORM("' already defined (C++98 3.2p1)");
 						message_header(fatal_def->_decl);
-						INFORM("prior definition here");
+						const char* const text = text_from_keyword(fatal_def->_decl);
+						INFORM(strcmp("class",text) ? "prior definition here" : "prior definition as class here");
 						zcc_errors.inc_error();
 						// reduce to named-specifier
+						tmp2.set_index_token_from_str_literal<0>(text);
 						tmp2.DeleteIdx<2>(0);
-						assert(is_C99_named_specifier(tmp2,"struct"));
-						goto rescan;
+						assert(is_C99_named_specifier(tmp2,text));
+						pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
+						continue;
 						}					
 					tmp2.type_code.set_type(tmp);
 					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
@@ -14557,12 +14640,15 @@
 						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
 						INFORM("' already defined (C++98 3.2p1)");
 						message_header(fatal_def->_decl);
-						INFORM("prior definition here");
+						const char* const text = text_from_keyword(fatal_def->_decl);
+						INFORM(strcmp("class",text) ? "prior definition as struct here" : "prior definition here");
 						zcc_errors.inc_error();
 						// reduce to named-specifier
+						tmp2.set_index_token_from_str_literal<0>(text);
 						tmp2.DeleteIdx<2>(0);
-						assert(is_C99_named_specifier(tmp2,"class"));
-						goto rescan;
+						assert(is_C99_named_specifier(tmp2,text));
+						pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
+						continue;
 						}					
 					tmp2.type_code.set_type(tmp);
 					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
@@ -14774,13 +14860,9 @@
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>(text);
 					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,text_from_keyword(*tmp3)));
-					if (!strcmp("class",text))
-						{
-						pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
-						continue;
-						}
-					goto rescan;
+					assert(is_C99_named_specifier(tmp2,text));
+					pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
+					continue;
 					}
 				//! \test zcc/decl.C99/Pass_enum_def.hpp
 				// enum-specifier doesn't have a specific declaration mode
@@ -14924,100 +15006,7 @@
 				}
 			}
 			break;
-			case STRUCT_NAME:
-			{
-			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			if (tmp)
-				{
-				assert(0<parse_tree::types->use_count(tmp));
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				}
-			// One Definition Rule states that conflicting enum, struct, or class must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_union_as_struct.hpp
-					//! \test zcc/decl.C99/Error_union_as_struct3.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C++98 One Definition Rule)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_enum_as_struct.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C++98 One Definition Rule)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here
-				//! \test decl.C99/Error_struct_forward_def_const.hpp
-				//! \test decl.C99/Error_struct_forward_def_const2.hpp
-				//! \test decl.C99/Error_struct_forward_def_const3.hpp
-				//! \test decl.C99/Error_struct_forward_def_const4.hpp
-				//! \test decl.C99/Error_struct_forward_def_volatile.hpp
-				//! \test decl.C99/Error_struct_forward_def_volatile2.hpp
-				//! \test decl.C99/Error_struct_forward_def_volatile3.hpp
-				//! \test decl.C99/Error_struct_forward_def_volatile4.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile2.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile3.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile4.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile5.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile6.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile7.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile8.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile9.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile10.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile11.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile12.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				if (tmp)
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-					// remove from parse
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;					
-					}
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				i += 2;
-				continue;
-				}
-			else if (!tmp)
-				{	// used without at least forward-declaring
-					//! \bug needs test cases
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("used without at least forward-declaring");
-				zcc_errors.inc_error();
-				}
-			}
-			break;
+			case STRUCT_NAME: break;	/* already handled */
 			case CLASS_NAME: break;	/* already handled */
 			case UNION_NAMED_DEF:
 			{	// can only define once

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-09 18:59:22 UTC (rev 562)
+++ trunk/CSupport.cpp.in	2011-01-09 21:49:15 UTC (rev 563)
@@ -14255,23 +14255,6 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 }
 
-static void _forward_declare_CPP_struct(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
-{
-	parse_tree& tmp = src.c_array<0>()[i];
-#ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
-#else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-	assert(tmp2);
-	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-	assert(parse_tree::types->get_structdecl(tmp2));
-	tmp.type_code.set_type(tmp2);
-#endif
-	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
-	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-}
-
 static void _forward_declare_CPP_struct_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i+k];
@@ -14442,7 +14425,104 @@
 				case UNION_NAME: break;
 				case UNION_NAMED_DEF: break;
 				case UNION_ANON_DEF: break;
-				case STRUCT_NAME: break;
+				case STRUCT_NAME:
+				{
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (tmp)
+					{
+					assert(0<parse_tree::types->use_count(tmp));
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+					}
+				// One Definition Rule states that conflicting enum, struct, or class must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_union_as_struct.hpp
+						//! \test zcc/decl.C99/Error_union_as_struct3.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C++98 One Definition Rule)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_enum_as_struct.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C++98 One Definition Rule)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+				else _forward_declare_CPP_struct_preparsed(src,active_namespace,i,k,pre_invariant_decl_scanner);
+				}
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here
+					//! \test decl.C99/Error_struct_forward_def_const.hpp
+					//! \test decl.C99/Error_struct_forward_def_const2.hpp
+					//! \test decl.C99/Error_struct_forward_def_const3.hpp
+					//! \test decl.C99/Error_struct_forward_def_const4.hpp
+					//! \test decl.C99/Error_struct_forward_def_volatile.hpp
+					//! \test decl.C99/Error_struct_forward_def_volatile2.hpp
+					//! \test decl.C99/Error_struct_forward_def_volatile3.hpp
+					//! \test decl.C99/Error_struct_forward_def_volatile4.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile2.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile3.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile4.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile5.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile6.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile7.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile8.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile9.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile10.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile11.hpp
+					//! \test decl.C99/Error_struct_forward_def_const_volatile12.hpp
+					CPP0X_flush_const_volatile_without_object(tmp2);
+					if (tmp)
+						{	// but if already (forward-)declared then this is a no-op
+							// think this is common enough to not warrant OAOO/DRY treatment
+						//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+						// remove from parse
+						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						goto restart_master_loop;
+						}
+					// forward-declare
+					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+					}
+				else if (!tmp)
+					{	// used without at least forward-declaring
+						//! \bug needs test cases
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("used without at least forward-declaring");
+					zcc_errors.inc_error();
+					}
+				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
+				}
+//				break;
 				case STRUCT_NAMED_DEF:
 				{	// can only define once
 				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
@@ -14458,12 +14538,15 @@
 						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
 						INFORM("' already defined (C++98 3.2p1)");
 						message_header(fatal_def->_decl);
-						INFORM("prior definition here");
+						const char* const text = text_from_keyword(fatal_def->_decl);
+						INFORM(strcmp("class",text) ? "prior definition here" : "prior definition as class here");
 						zcc_errors.inc_error();
 						// reduce to named-specifier
+						tmp2.set_index_token_from_str_literal<0>(text);
 						tmp2.DeleteIdx<2>(0);
-						assert(is_C99_named_specifier(tmp2,"struct"));
-						goto rescan;
+						assert(is_C99_named_specifier(tmp2,text));
+						pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
+						continue;
 						}					
 					tmp2.type_code.set_type(tmp);
 					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
@@ -14704,12 +14787,15 @@
 						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
 						INFORM("' already defined (C++98 3.2p1)");
 						message_header(fatal_def->_decl);
-						INFORM("prior definition here");
+						const char* const text = text_from_keyword(fatal_def->_decl);
+						INFORM(strcmp("class",text) ? "prior definition as struct here" : "prior definition here");
 						zcc_errors.inc_error();
 						// reduce to named-specifier
+						tmp2.set_index_token_from_str_literal<0>(text);
 						tmp2.DeleteIdx<2>(0);
-						assert(is_C99_named_specifier(tmp2,"class"));
-						goto rescan;
+						assert(is_C99_named_specifier(tmp2,text));
+						pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
+						continue;
 						}					
 					tmp2.type_code.set_type(tmp);
 					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
@@ -14921,13 +15007,9 @@
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>(text);
 					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,text_from_keyword(*tmp3)));
-					if (!strcmp("class",text))
-						{
-						pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
-						continue;
-						}
-					goto rescan;
+					assert(is_C99_named_specifier(tmp2,text));
+					pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
+					continue;
 					}
 				//! \test zcc/decl.C99/Pass_enum_def.hpp
 				// enum-specifier doesn't have a specific declaration mode
@@ -15071,100 +15153,7 @@
 				}
 			}
 			break;
-			case STRUCT_NAME:
-			{
-			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			if (tmp)
-				{
-				assert(0<parse_tree::types->use_count(tmp));
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				}
-			// One Definition Rule states that conflicting enum, struct, or class must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_union_as_struct.hpp
-					//! \test zcc/decl.C99/Error_union_as_struct3.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C++98 One Definition Rule)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_enum_as_struct.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C++98 One Definition Rule)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here
-				//! \test decl.C99/Error_struct_forward_def_const.hpp
-				//! \test decl.C99/Error_struct_forward_def_const2.hpp
-				//! \test decl.C99/Error_struct_forward_def_const3.hpp
-				//! \test decl.C99/Error_struct_forward_def_const4.hpp
-				//! \test decl.C99/Error_struct_forward_def_volatile.hpp
-				//! \test decl.C99/Error_struct_forward_def_volatile2.hpp
-				//! \test decl.C99/Error_struct_forward_def_volatile3.hpp
-				//! \test decl.C99/Error_struct_forward_def_volatile4.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile2.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile3.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile4.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile5.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile6.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile7.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile8.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile9.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile10.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile11.hpp
-				//! \test decl.C99/Error_struct_forward_def_const_volatile12.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				if (tmp)
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-					// remove from parse
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;					
-					}
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				i += 2;
-				continue;
-				}
-			else if (!tmp)
-				{	// used without at least forward-declaring
-					//! \bug needs test cases
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("used without at least forward-declaring");
-				zcc_errors.inc_error();
-				}
-			}
-			break;
+			case STRUCT_NAME: break;	/* already handled */
 			case CLASS_NAME: break;	/* already handled */
 			case UNION_NAMED_DEF:
 			{	// can only define once



From zaimoni at mail.berlios.de  Sun Jan  9 23:04:59 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun,  9 Jan 2011 23:04:59 +0100
Subject: [Zcplusplus-commits] r564 - trunk
Message-ID: <20110109220500.02BEC480BEC@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-09 23:04:59 +0100 (Sun, 09 Jan 2011)
New Revision: 564

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
be more consistent about using those tmp variables

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-09 21:49:15 UTC (rev 563)
+++ trunk/CSupport.cpp	2011-01-09 22:04:59 UTC (rev 564)
@@ -14385,7 +14385,7 @@
 					{
 					if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
 						{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
-						message_header(src.data<0>()[i+k].index_tokens[0]);
+						message_header(tmp2.index_tokens[0]);
 						INC_INFORM(ERR_STR);
 						INC_INFORM("'struct ");
 						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
@@ -14438,7 +14438,7 @@
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(src.data<0>()[i+k],"enum"));
+					assert(is_C99_named_specifier(tmp2,"enum"));
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
 					continue;
 					}
@@ -14634,7 +14634,7 @@
 					{
 					if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
 						{	//! \test zcc/decl.C99/Error_class_multidef.hpp
-						message_header(src.data<0>()[i+k].index_tokens[0]);
+						message_header(tmp2.index_tokens[0]);
 						INC_INFORM(ERR_STR);
 						INC_INFORM("'class ");
 						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
@@ -14742,7 +14742,7 @@
 				// parse the union and upgrade it to a full definition
 				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp);
 				assert(tmp3);
-				const parse_tree& tmp2 =  src.data<0>()[i+k];				
+				parse_tree& tmp2 =  src.c_array<0>()[i+k];				
 				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
 				//! \todo record field structure, etc.
 				parse_tree::types->upgrade_decl_to_def(tmp,tmp4);
@@ -14760,7 +14760,7 @@
 					//! \test decl.C99/Error_class_anon_def_const_volatile4.hpp
 					//! \test decl.C99/Error_class_anon_def_const_volatile5.hpp
 					//! \test decl.C99/Error_class_anon_def_const_volatile6.hpp
-					CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i+k]);
+					CPP0X_flush_const_volatile_without_object(tmp2);
 					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
 					message_header(tmp2.index_tokens[0]);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-09 21:49:15 UTC (rev 563)
+++ trunk/CSupport.cpp.in	2011-01-09 22:04:59 UTC (rev 564)
@@ -14532,7 +14532,7 @@
 					{
 					if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
 						{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
-						message_header(src.data<0>()[i+k].index_tokens[0]);
+						message_header(tmp2.index_tokens[0]);
 						INC_INFORM(ERR_STR);
 						INC_INFORM("'struct ");
 						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
@@ -14585,7 +14585,7 @@
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(src.data<0>()[i+k],"enum"));
+					assert(is_C99_named_specifier(tmp2,"enum"));
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
 					continue;
 					}
@@ -14781,7 +14781,7 @@
 					{
 					if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
 						{	//! \test zcc/decl.C99/Error_class_multidef.hpp
-						message_header(src.data<0>()[i+k].index_tokens[0]);
+						message_header(tmp2.index_tokens[0]);
 						INC_INFORM(ERR_STR);
 						INC_INFORM("'class ");
 						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
@@ -14889,7 +14889,7 @@
 				// parse the union and upgrade it to a full definition
 				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp);
 				assert(tmp3);
-				const parse_tree& tmp2 =  src.data<0>()[i+k];				
+				parse_tree& tmp2 =  src.c_array<0>()[i+k];				
 				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
 				//! \todo record field structure, etc.
 				parse_tree::types->upgrade_decl_to_def(tmp,tmp4);
@@ -14907,7 +14907,7 @@
 					//! \test decl.C99/Error_class_anon_def_const_volatile4.hpp
 					//! \test decl.C99/Error_class_anon_def_const_volatile5.hpp
 					//! \test decl.C99/Error_class_anon_def_const_volatile6.hpp
-					CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i+k]);
+					CPP0X_flush_const_volatile_without_object(tmp2);
 					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
 					message_header(tmp2.index_tokens[0]);



From zaimoni at mail.berlios.de  Mon Jan 10 01:53:03 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 10 Jan 2011 01:53:03 +0100
Subject: [Zcplusplus-commits] r565 - trunk
Message-ID: <20110110005303.930BD480DB9@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-10 01:53:03 +0100 (Mon, 10 Jan 2011)
New Revision: 565

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
C++ anonymous union definitions: converge parsing towards standard

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-09 22:04:59 UTC (rev 564)
+++ trunk/CSupport.cpp	2011-01-10 00:53:03 UTC (rev 565)
@@ -14277,7 +14277,58 @@
 				{
 				case UNION_NAME: break;
 				case UNION_NAMED_DEF: break;
-				case UNION_ANON_DEF: break;
+				case UNION_ANON_DEF:
+				{	// anonymous types cannot be matched
+				// tentatively forward-declare immediately
+				const type_system::type_index tmp = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union,src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
+				assert(tmp);
+
+				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+				assert(parse_tree::types->get_structdecl(tmp));
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				tmp2.type_code.set_type(tmp);
+				tmp2.flags |= PARSE_UNION_TYPE;
+				}
+				_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+
+				// parse the union and upgrade it to a full definition
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp);
+				assert(tmp3);
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(tmp,tmp4);
+				assert(parse_tree::types->get_C_structdef(tmp));
+
+				if (semicolon_terminated_decl)
+					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \test decl.C99/Error_union_anon_def_const.hpp
+					//! \test decl.C99/Error_union_anon_def_const2.hpp
+					//! \test decl.C99/Error_union_anon_def_volatile.hpp
+					//! \test decl.C99/Error_union_anon_def_volatile2.hpp
+					//! \test decl.C99/Error_union_anon_def_const_volatile.hpp
+					//! \test decl.C99/Error_union_anon_def_const_volatile2.hpp
+					//! \test decl.C99/Error_union_anon_def_const_volatile3.hpp
+					//! \test decl.C99/Error_union_anon_def_const_volatile4.hpp
+					//! \test decl.C99/Error_union_anon_def_const_volatile5.hpp
+					//! \test decl.C99/Error_union_anon_def_const_volatile6.hpp
+					CPP0X_flush_const_volatile_without_object(tmp2);
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("unreferenceable anonymous union declaration");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// remove from parse
+					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+					goto restart_master_loop;
+					}
+				i += pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
+				}
+//				break;
 				case STRUCT_NAME:
 				{
 				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
@@ -15107,53 +15158,7 @@
 			break;
 			case STRUCT_NAMED_DEF: break;	/* already handled */
 			case CLASS_NAMED_DEF: break;	/* already handled */
-			case UNION_ANON_DEF:
-			{	// anonymous types cannot be matched
-			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			assert(tmp2);
-
-			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-			assert(parse_tree::types->get_structdecl(tmp2));
-			src.c_array<0>()[i].type_code.set_type(tmp2);
-			src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-
-			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
-			assert(parse_tree::types->get_C_structdef(tmp2));
-
-			if (	1<src.size<0>()-i
-				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				//! \test decl.C99/Error_union_anon_def_const.hpp
-				//! \test decl.C99/Error_union_anon_def_const2.hpp
-				//! \test decl.C99/Error_union_anon_def_volatile.hpp
-				//! \test decl.C99/Error_union_anon_def_volatile2.hpp
-				//! \test decl.C99/Error_union_anon_def_const_volatile.hpp
-				//! \test decl.C99/Error_union_anon_def_const_volatile2.hpp
-				//! \test decl.C99/Error_union_anon_def_const_volatile3.hpp
-				//! \test decl.C99/Error_union_anon_def_const_volatile4.hpp
-				//! \test decl.C99/Error_union_anon_def_const_volatile5.hpp
-				//! \test decl.C99/Error_union_anon_def_const_volatile6.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-				//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous union declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			}
-			break;
+			case UNION_ANON_DEF: break;	/* already handled */
 			case STRUCT_ANON_DEF: break;	/* already handled */
 			case CLASS_ANON_DEF: break;	/* already handled */
 			case ENUM_NAME: break;	/* already handled */

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-09 22:04:59 UTC (rev 564)
+++ trunk/CSupport.cpp.in	2011-01-10 00:53:03 UTC (rev 565)
@@ -14424,7 +14424,58 @@
 				{
 				case UNION_NAME: break;
 				case UNION_NAMED_DEF: break;
-				case UNION_ANON_DEF: break;
+				case UNION_ANON_DEF:
+				{	// anonymous types cannot be matched
+				// tentatively forward-declare immediately
+				const type_system::type_index tmp = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union,src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
+				assert(tmp);
+
+				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+				assert(parse_tree::types->get_structdecl(tmp));
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				tmp2.type_code.set_type(tmp);
+				tmp2.flags |= PARSE_UNION_TYPE;
+				}
+				_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+
+				// parse the union and upgrade it to a full definition
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp);
+				assert(tmp3);
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(tmp,tmp4);
+				assert(parse_tree::types->get_C_structdef(tmp));
+
+				if (semicolon_terminated_decl)
+					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \test decl.C99/Error_union_anon_def_const.hpp
+					//! \test decl.C99/Error_union_anon_def_const2.hpp
+					//! \test decl.C99/Error_union_anon_def_volatile.hpp
+					//! \test decl.C99/Error_union_anon_def_volatile2.hpp
+					//! \test decl.C99/Error_union_anon_def_const_volatile.hpp
+					//! \test decl.C99/Error_union_anon_def_const_volatile2.hpp
+					//! \test decl.C99/Error_union_anon_def_const_volatile3.hpp
+					//! \test decl.C99/Error_union_anon_def_const_volatile4.hpp
+					//! \test decl.C99/Error_union_anon_def_const_volatile5.hpp
+					//! \test decl.C99/Error_union_anon_def_const_volatile6.hpp
+					CPP0X_flush_const_volatile_without_object(tmp2);
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("unreferenceable anonymous union declaration");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// remove from parse
+					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+					goto restart_master_loop;
+					}
+				i += pre_invariant_decl_scanner.size();
+				goto restart_master_loop;
+				}
+//				break;
 				case STRUCT_NAME:
 				{
 				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
@@ -15254,53 +15305,7 @@
 			break;
 			case STRUCT_NAMED_DEF: break;	/* already handled */
 			case CLASS_NAMED_DEF: break;	/* already handled */
-			case UNION_ANON_DEF:
-			{	// anonymous types cannot be matched
-			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			assert(tmp2);
-
-			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-			assert(parse_tree::types->get_structdecl(tmp2));
-			src.c_array<0>()[i].type_code.set_type(tmp2);
-			src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-
-			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
-			assert(parse_tree::types->get_C_structdef(tmp2));
-
-			if (	1<src.size<0>()-i
-				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				//! \test decl.C99/Error_union_anon_def_const.hpp
-				//! \test decl.C99/Error_union_anon_def_const2.hpp
-				//! \test decl.C99/Error_union_anon_def_volatile.hpp
-				//! \test decl.C99/Error_union_anon_def_volatile2.hpp
-				//! \test decl.C99/Error_union_anon_def_const_volatile.hpp
-				//! \test decl.C99/Error_union_anon_def_const_volatile2.hpp
-				//! \test decl.C99/Error_union_anon_def_const_volatile3.hpp
-				//! \test decl.C99/Error_union_anon_def_const_volatile4.hpp
-				//! \test decl.C99/Error_union_anon_def_const_volatile5.hpp
-				//! \test decl.C99/Error_union_anon_def_const_volatile6.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-				//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous union declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			}
-			break;
+			case UNION_ANON_DEF: break;	/* already handled */
 			case STRUCT_ANON_DEF: break;	/* already handled */
 			case CLASS_ANON_DEF: break;	/* already handled */
 			case ENUM_NAME: break;	/* already handled */



From zaimoni at mail.berlios.de  Mon Jan 10 02:02:15 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 10 Jan 2011 02:02:15 +0100
Subject: [Zcplusplus-commits] r566 - trunk
Message-ID: <20110110010215.9C395480DB9@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-10 02:02:15 +0100 (Mon, 10 Jan 2011)
New Revision: 566

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
efficiency tuning; use correct metaphor for successful conversion

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-10 00:53:03 UTC (rev 565)
+++ trunk/CSupport.cpp	2011-01-10 01:02:15 UTC (rev 566)
@@ -14265,11 +14265,8 @@
 					}
 				}
 			//! \bug check for pre-existing typedefs if no types
-			if (0>=typecount)
-				{
-				pre_invariant_decl_scanner.clear();	// RAM efficiency
+			if (0>=typecount || 0<pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)))
 				goto reparse;
-				}
 			}
 
 			size_t k = 0;
@@ -14325,8 +14322,7 @@
 					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
 					goto restart_master_loop;
 					}
-				i += pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case STRUCT_NAME:
@@ -14423,8 +14419,7 @@
 					INFORM("used without at least forward-declaring");
 					zcc_errors.inc_error();
 					}
-				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case STRUCT_NAMED_DEF:
@@ -14523,8 +14518,7 @@
 					// accept definition
 					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 					}
-				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case STRUCT_ANON_DEF:
@@ -14573,8 +14567,7 @@
 					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
 					goto restart_master_loop;
 					}
-				i += pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case CLASS_NAME:
@@ -14672,8 +14665,7 @@
 					INFORM("used without at least forward-declaring");
 					zcc_errors.inc_error();
 					}
-				i += pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case CLASS_NAMED_DEF:
@@ -14772,8 +14764,7 @@
 					// accept definition
 					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
 					}
-				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case CLASS_ANON_DEF:
@@ -14848,8 +14839,7 @@
 					tmp2.type_code.set_type(C_TYPE::INT);	// fail over to int, like C
 					tmp2.flags |= (parse_tree::INVALID | PARSE_PRIMARY_TYPE);
 					};
-				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case ENUM_NAMED_DEF:
@@ -14926,8 +14916,7 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case ENUM_ANON_DEF:
@@ -14942,12 +14931,10 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 				}
 			while(pre_invariant_decl_scanner.size()> ++k);
-			pre_invariant_decl_scanner.clear();	// RAM efficiency
 			};
 		}
 		// check naked declarations first; handle namespaces later

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-10 00:53:03 UTC (rev 565)
+++ trunk/CSupport.cpp.in	2011-01-10 01:02:15 UTC (rev 566)
@@ -14412,11 +14412,8 @@
 					}
 				}
 			//! \bug check for pre-existing typedefs if no types
-			if (0>=typecount)
-				{
-				pre_invariant_decl_scanner.clear();	// RAM efficiency
+			if (0>=typecount || 0<pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)))
 				goto reparse;
-				}
 			}
 
 			size_t k = 0;
@@ -14472,8 +14469,7 @@
 					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
 					goto restart_master_loop;
 					}
-				i += pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case STRUCT_NAME:
@@ -14570,8 +14566,7 @@
 					INFORM("used without at least forward-declaring");
 					zcc_errors.inc_error();
 					}
-				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case STRUCT_NAMED_DEF:
@@ -14670,8 +14665,7 @@
 					// accept definition
 					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 					}
-				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case STRUCT_ANON_DEF:
@@ -14720,8 +14714,7 @@
 					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
 					goto restart_master_loop;
 					}
-				i += pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case CLASS_NAME:
@@ -14819,8 +14812,7 @@
 					INFORM("used without at least forward-declaring");
 					zcc_errors.inc_error();
 					}
-				i += pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case CLASS_NAMED_DEF:
@@ -14919,8 +14911,7 @@
 					// accept definition
 					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
 					}
-				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case CLASS_ANON_DEF:
@@ -14995,8 +14986,7 @@
 					tmp2.type_code.set_type(C_TYPE::INT);	// fail over to int, like C
 					tmp2.flags |= (parse_tree::INVALID | PARSE_PRIMARY_TYPE);
 					};
-				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case ENUM_NAMED_DEF:
@@ -15073,8 +15063,7 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 //				break;
 				case ENUM_ANON_DEF:
@@ -15089,12 +15078,10 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				i += semicolon_terminated_decl+pre_invariant_decl_scanner.size();
-				goto restart_master_loop;
+				goto reparse;
 				}
 				}
 			while(pre_invariant_decl_scanner.size()> ++k);
-			pre_invariant_decl_scanner.clear();	// RAM efficiency
 			};
 		}
 		// check naked declarations first; handle namespaces later



From zaimoni at mail.berlios.de  Mon Jan 10 04:00:02 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 10 Jan 2011 04:00:02 +0100
Subject: [Zcplusplus-commits] r567 - trunk
Message-ID: <20110110030003.0C1A5480DF3@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-10 04:00:02 +0100 (Mon, 10 Jan 2011)
New Revision: 567

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
C++ named structure definitions: converge towards standard parsing

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-10 01:02:15 UTC (rev 566)
+++ trunk/CSupport.cpp	2011-01-10 03:00:02 UTC (rev 567)
@@ -14108,6 +14108,24 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 }
 
+static void _forward_declare_CPP_union_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	parse_tree& tmp = src.c_array<0>()[i+k];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
+#else
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_union_CPP(tmp.index_tokens[1].token.first,active_namespace));
+	assert(parse_tree::types->get_id_union_CPP(tmp.index_tokens[1].token.first,active_namespace)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_UNION_TYPE;
+	invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+	_condense_const_volatile_onto_type_preparsed(src,i,k,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+}
+
 static void _forward_declare_CPP_struct_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i+k];
@@ -14273,7 +14291,108 @@
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(CPP0X_nontype_decl_specifier_list))
 				{
 				case UNION_NAME: break;
-				case UNION_NAMED_DEF: break;
+				case UNION_NAMED_DEF:
+				{	// can only define once
+				const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];					
+				if (tmp)
+					{
+					if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
+						{	//! \test zcc/decl.C99/Error_union_multidef.hpp
+						message_header(tmp2.index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("'union ");
+						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INFORM("' already defined (C++98 3.2p1)");
+						message_header(fatal_def->_decl);
+						INFORM("prior definition here");
+						zcc_errors.inc_error();
+						// reduce to named-specifier
+						tmp2.DeleteIdx<2>(0);
+						assert(is_C99_named_specifier(tmp2,"union"));
+						goto rescan;
+						}					
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_UNION_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+					}
+				// One Definition Rule states that conflicting enum, struct, or class must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_struct_as_union2.hpp
+						//! \test zcc/decl.C99/Error_struct_as_union4.hpp
+						//! \test zcc/decl.C99/Error_class_as_union2.hpp
+						//! \test zcc/decl.C99/Error_class_as_union4.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(" declared as ");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					const char* const text = text_from_keyword(*tmp3);
+					INC_INFORM(text);
+					INFORM(" (C++98 One Definition Rule)");
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>(text);
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,text));
+					pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
+					continue;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C++98 One Definition Rule)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+				else _forward_declare_CPP_union_preparsed(src,active_namespace,i,k,pre_invariant_decl_scanner);
+				}
+				// parse the union and upgrade it to a full definition
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				const type_system::type_index vr_tmp = tmp2.type_code.base_type_index;
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
+				assert(tmp3);
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+				assert(parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace)==vr_tmp);
+				assert(parse_tree::types->get_C_structdef(vr_tmp));
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here
+					//! \test decl.C99/Error_union_def_const.hpp
+					//! \test decl.C99/Error_union_def_const2.hpp
+					//! \test decl.C99/Error_union_def_volatile.hpp
+					//! \test decl.C99/Error_union_def_volatile2.hpp
+					//! \test decl.C99/Error_union_def_const_volatile.hpp
+					//! \test decl.C99/Error_union_def_const_volatile2.hpp
+					//! \test decl.C99/Error_union_def_const_volatile3.hpp
+					//! \test decl.C99/Error_union_def_const_volatile4.hpp
+					//! \test decl.C99/Error_union_def_const_volatile5.hpp
+					//! \test decl.C99/Error_union_def_const_volatile6.hpp
+					CPP0X_flush_const_volatile_without_object(tmp2);
+					// accept definition
+					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+					}
+				goto reparse;
+				}
+//				break;
 				case UNION_ANON_DEF:
 				{	// anonymous types cannot be matched
 				// tentatively forward-declare immediately
@@ -15046,103 +15165,7 @@
 			break;
 			case STRUCT_NAME: break;	/* already handled */
 			case CLASS_NAME: break;	/* already handled */
-			case UNION_NAMED_DEF:
-			{	// can only define once
-			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			if (tmp)
-				{
-				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
-					{	//! \test zcc/decl.C99/Error_union_multidef.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'union ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' already defined (C++98 3.2p1)");
-					message_header(fatal_def->_decl);
-					INFORM("prior definition here");
-					zcc_errors.inc_error();
-					// reduce to named-specifier
-					src.c_array<0>()[i].DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-					goto reparse;
-					}					
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				}
-			// One Definition Rule states that conflicting enum, struct, or class must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_struct_as_union2.hpp
-					//! \test zcc/decl.C99/Error_struct_as_union4.hpp
-					//! \test zcc/decl.C99/Error_class_as_union2.hpp
-					//! \test zcc/decl.C99/Error_class_as_union4.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INC_INFORM(" declared as ");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				INC_INFORM(text_from_keyword(*tmp2));
-				INFORM(" (C++98 One Definition Rule)");
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C++98 One Definition Rule)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-			else _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
-			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==vr_tmp);
-			assert(parse_tree::types->get_C_structdef(vr_tmp));
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here
-				//! \test decl.C99/Error_union_def_const.hpp
-				//! \test decl.C99/Error_union_def_const2.hpp
-				//! \test decl.C99/Error_union_def_volatile.hpp
-				//! \test decl.C99/Error_union_def_volatile2.hpp
-				//! \test decl.C99/Error_union_def_const_volatile.hpp
-				//! \test decl.C99/Error_union_def_const_volatile2.hpp
-				//! \test decl.C99/Error_union_def_const_volatile3.hpp
-				//! \test decl.C99/Error_union_def_const_volatile4.hpp
-				//! \test decl.C99/Error_union_def_const_volatile5.hpp
-				//! \test decl.C99/Error_union_def_const_volatile6.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				// accept definition
-				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				i += 2;
-				continue;
-				}
-			}
-			break;
+			case UNION_NAMED_DEF: break;	/* already handled */
 			case STRUCT_NAMED_DEF: break;	/* already handled */
 			case CLASS_NAMED_DEF: break;	/* already handled */
 			case UNION_ANON_DEF: break;	/* already handled */

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-10 01:02:15 UTC (rev 566)
+++ trunk/CSupport.cpp.in	2011-01-10 03:00:02 UTC (rev 567)
@@ -14255,6 +14255,24 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 }
 
+static void _forward_declare_CPP_union_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	parse_tree& tmp = src.c_array<0>()[i+k];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
+#else
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(tmp.index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_union_CPP(tmp.index_tokens[1].token.first,active_namespace));
+	assert(parse_tree::types->get_id_union_CPP(tmp.index_tokens[1].token.first,active_namespace)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_UNION_TYPE;
+	invariant_decl_scanner.reclassify(k,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+	_condense_const_volatile_onto_type_preparsed(src,i,k,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+}
+
 static void _forward_declare_CPP_struct_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i+k];
@@ -14420,7 +14438,108 @@
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(CPP0X_nontype_decl_specifier_list))
 				{
 				case UNION_NAME: break;
-				case UNION_NAMED_DEF: break;
+				case UNION_NAMED_DEF:
+				{	// can only define once
+				const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];					
+				if (tmp)
+					{
+					if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
+						{	//! \test zcc/decl.C99/Error_union_multidef.hpp
+						message_header(tmp2.index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("'union ");
+						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INFORM("' already defined (C++98 3.2p1)");
+						message_header(fatal_def->_decl);
+						INFORM("prior definition here");
+						zcc_errors.inc_error();
+						// reduce to named-specifier
+						tmp2.DeleteIdx<2>(0);
+						assert(is_C99_named_specifier(tmp2,"union"));
+						goto rescan;
+						}					
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_UNION_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+					}
+				// One Definition Rule states that conflicting enum, struct, or class must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_struct_as_union2.hpp
+						//! \test zcc/decl.C99/Error_struct_as_union4.hpp
+						//! \test zcc/decl.C99/Error_class_as_union2.hpp
+						//! \test zcc/decl.C99/Error_class_as_union4.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(" declared as ");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					const char* const text = text_from_keyword(*tmp3);
+					INC_INFORM(text);
+					INFORM(" (C++98 One Definition Rule)");
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>(text);
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,text));
+					pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
+					continue;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C++98 One Definition Rule)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+				else _forward_declare_CPP_union_preparsed(src,active_namespace,i,k,pre_invariant_decl_scanner);
+				}
+				// parse the union and upgrade it to a full definition
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				const type_system::type_index vr_tmp = tmp2.type_code.base_type_index;
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
+				assert(tmp3);
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+				assert(parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace)==vr_tmp);
+				assert(parse_tree::types->get_C_structdef(vr_tmp));
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here
+					//! \test decl.C99/Error_union_def_const.hpp
+					//! \test decl.C99/Error_union_def_const2.hpp
+					//! \test decl.C99/Error_union_def_volatile.hpp
+					//! \test decl.C99/Error_union_def_volatile2.hpp
+					//! \test decl.C99/Error_union_def_const_volatile.hpp
+					//! \test decl.C99/Error_union_def_const_volatile2.hpp
+					//! \test decl.C99/Error_union_def_const_volatile3.hpp
+					//! \test decl.C99/Error_union_def_const_volatile4.hpp
+					//! \test decl.C99/Error_union_def_const_volatile5.hpp
+					//! \test decl.C99/Error_union_def_const_volatile6.hpp
+					CPP0X_flush_const_volatile_without_object(tmp2);
+					// accept definition
+					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+					}
+				goto reparse;
+				}
+//				break;
 				case UNION_ANON_DEF:
 				{	// anonymous types cannot be matched
 				// tentatively forward-declare immediately
@@ -15193,103 +15312,7 @@
 			break;
 			case STRUCT_NAME: break;	/* already handled */
 			case CLASS_NAME: break;	/* already handled */
-			case UNION_NAMED_DEF:
-			{	// can only define once
-			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			if (tmp)
-				{
-				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
-					{	//! \test zcc/decl.C99/Error_union_multidef.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'union ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' already defined (C++98 3.2p1)");
-					message_header(fatal_def->_decl);
-					INFORM("prior definition here");
-					zcc_errors.inc_error();
-					// reduce to named-specifier
-					src.c_array<0>()[i].DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-					goto reparse;
-					}					
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				}
-			// One Definition Rule states that conflicting enum, struct, or class must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_struct_as_union2.hpp
-					//! \test zcc/decl.C99/Error_struct_as_union4.hpp
-					//! \test zcc/decl.C99/Error_class_as_union2.hpp
-					//! \test zcc/decl.C99/Error_class_as_union4.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INC_INFORM(" declared as ");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				INC_INFORM(text_from_keyword(*tmp2));
-				INFORM(" (C++98 One Definition Rule)");
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C++98 One Definition Rule)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-			else _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
-			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==vr_tmp);
-			assert(parse_tree::types->get_C_structdef(vr_tmp));
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here
-				//! \test decl.C99/Error_union_def_const.hpp
-				//! \test decl.C99/Error_union_def_const2.hpp
-				//! \test decl.C99/Error_union_def_volatile.hpp
-				//! \test decl.C99/Error_union_def_volatile2.hpp
-				//! \test decl.C99/Error_union_def_const_volatile.hpp
-				//! \test decl.C99/Error_union_def_const_volatile2.hpp
-				//! \test decl.C99/Error_union_def_const_volatile3.hpp
-				//! \test decl.C99/Error_union_def_const_volatile4.hpp
-				//! \test decl.C99/Error_union_def_const_volatile5.hpp
-				//! \test decl.C99/Error_union_def_const_volatile6.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				// accept definition
-				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				i += 2;
-				continue;
-				}
-			}
-			break;
+			case UNION_NAMED_DEF: break;	/* already handled */
 			case STRUCT_NAMED_DEF: break;	/* already handled */
 			case CLASS_NAMED_DEF: break;	/* already handled */
 			case UNION_ANON_DEF: break;	/* already handled */



From zaimoni at mail.berlios.de  Mon Jan 10 04:48:06 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 10 Jan 2011 04:48:06 +0100
Subject: [Zcplusplus-commits] r568 - trunk
Message-ID: <20110110034806.EBE51480DF3@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-10 04:48:06 +0100 (Mon, 10 Jan 2011)
New Revision: 568

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
C++ named union declarators: converge parsing towards standard

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-10 03:00:02 UTC (rev 567)
+++ trunk/CSupport.cpp	2011-01-10 03:48:06 UTC (rev 568)
@@ -14091,23 +14091,6 @@
 		}
 }
 
-static void _forward_declare_CPP_union(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
-{
-	parse_tree& tmp = src.c_array<0>()[i];
-#ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
-#else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-	assert(tmp2);
-	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-	assert(parse_tree::types->get_structdecl(tmp2));
-	tmp.type_code.set_type(tmp2);
-#endif
-	tmp.flags |= PARSE_UNION_TYPE;
-	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-}
-
 static void _forward_declare_CPP_union_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i+k];
@@ -14208,11 +14191,10 @@
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// pre-scan for declaration-like items
 		{
-rescan:
-		pre_invariant_decl_scanner.clear(); // there's a lot of rescanning paths, so conserve lines of code
 		{	// wouldn't work for unnamed function parameters
 		const size_t strict_ub = src.size<0>()-i;
 		const parse_tree* const origin = src.data<0>()+i;
+		pre_invariant_decl_scanner.clear();	// fail-safe
 		while(pre_invariant_decl_scanner(origin[pre_invariant_decl_scanner.size()]))
 			// if we ran out of tokens, bad
 			if (strict_ub <= pre_invariant_decl_scanner.size())
@@ -14290,7 +14272,108 @@
 			size_t k = 0;
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(CPP0X_nontype_decl_specifier_list))
 				{
-				case UNION_NAME: break;
+				case UNION_NAME:
+				{
+				const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];					
+				if (tmp)
+					{
+					assert(0<parse_tree::types->use_count(tmp));
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_UNION_TYPE;
+					_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+					}
+				// One Definition Rule states that conflicting enum, struct, or class must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_struct_as_union.hpp
+						//! \test zcc/decl.C99/Error_struct_as_union3.hpp
+						//! \test zcc/decl.C99/Error_class_as_union.hpp
+						//! \test zcc/decl.C99/Error_class_as_union3.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(" declared as ");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					const char* const text = text_from_keyword(*tmp3);
+					INC_INFORM(text);
+					INFORM(" (C++98 One Definition Rule)");
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>(text);
+					assert(is_C99_named_specifier(tmp2,text));
+					pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
+					continue;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C++98 One Definition Rule)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+				else _forward_declare_CPP_union_preparsed(src,active_namespace,i,k,pre_invariant_decl_scanner);
+				}
+				parse_tree& tmp2 = src.c_array<0>()[i+k];					
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here
+					//! \test decl.C99/Error_union_forward_def_const.hpp
+					//! \test decl.C99/Error_union_forward_def_const2.hpp
+					//! \test decl.C99/Error_union_forward_def_const3.hpp
+					//! \test decl.C99/Error_union_forward_def_const4.hpp
+					//! \test decl.C99/Error_union_forward_def_volatile.hpp
+					//! \test decl.C99/Error_union_forward_def_volatile2.hpp
+					//! \test decl.C99/Error_union_forward_def_volatile3.hpp
+					//! \test decl.C99/Error_union_forward_def_volatile4.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile2.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile3.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile4.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile5.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile6.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile7.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile8.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile9.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile10.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile11.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile12.hpp
+					CPP0X_flush_const_volatile_without_object(tmp2);
+					if (tmp)
+						{	// but if already (forward-)declared then this is a no-op
+							// think this is common enough to not warrant OAOO/DRY treatment
+						//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+						// remove from parse
+						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						goto restart_master_loop;
+						};
+					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+					}
+				else if (!tmp)
+					{	// used without at least forward-declaring
+						//! \bug needs test cases
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("used without at least forward-declaring");
+					zcc_errors.inc_error();
+					}
+				goto reparse;
+				}
+//				break;
 				case UNION_NAMED_DEF:
 				{	// can only define once
 				const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
@@ -14311,7 +14394,8 @@
 						// reduce to named-specifier
 						tmp2.DeleteIdx<2>(0);
 						assert(is_C99_named_specifier(tmp2,"union"));
-						goto rescan;
+						pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
+						continue;
 						}					
 					tmp2.type_code.set_type(tmp);
 					tmp2.flags |= PARSE_UNION_TYPE;
@@ -14472,7 +14556,8 @@
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("union");
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_struct.hpp
@@ -14587,7 +14672,8 @@
 					tmp2.set_index_token_from_str_literal<0>("union");
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_struct2.hpp
@@ -14717,7 +14803,8 @@
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("union");
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_class.hpp
@@ -14773,8 +14860,6 @@
 						}
 					// forward-declare
 					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-					i += 1+pre_invariant_decl_scanner.size();
-					goto restart_master_loop;
 					}
 				else if (!tmp)
 					{	// used without at least forward-declaring
@@ -14833,7 +14918,8 @@
 					tmp2.set_index_token_from_str_literal<0>("union");
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_class2.hpp
@@ -14998,7 +15084,8 @@
 					tmp2.set_index_token_from_str_literal<0>("union");
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_struct_as_enum.hpp
@@ -15058,6 +15145,7 @@
 		}
 		// check naked declarations first; handle namespaces later
 reparse:
+		pre_invariant_decl_scanner.clear();	// just in case; RAM conservation
 		const int tag_type = notice_CPP_tag(src.data<0>()[i]);
 		if (tag_type)
 			{
@@ -15066,103 +15154,7 @@
 #ifndef NDEBUG
 			default: _fatal_code("return value of notice_C99_tag out of range",3);
 #endif
-			case UNION_NAME:
-			{
-			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			if (tmp)
-				{
-				assert(0<parse_tree::types->use_count(tmp));
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				}
-			// One Definition Rule states that conflicting enum, struct, or class must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_struct_as_union.hpp
-					//! \test zcc/decl.C99/Error_struct_as_union3.hpp
-					//! \test zcc/decl.C99/Error_class_as_union.hpp
-					//! \test zcc/decl.C99/Error_class_as_union3.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INC_INFORM(" declared as ");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				INC_INFORM(text_from_keyword(*tmp2));
-				INFORM(" (C++98 One Definition Rule)");
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
-				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C++98 One Definition Rule)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-			else _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here
-				//! \test decl.C99/Error_union_forward_def_const.hpp
-				//! \test decl.C99/Error_union_forward_def_const2.hpp
-				//! \test decl.C99/Error_union_forward_def_const3.hpp
-				//! \test decl.C99/Error_union_forward_def_const4.hpp
-				//! \test decl.C99/Error_union_forward_def_volatile.hpp
-				//! \test decl.C99/Error_union_forward_def_volatile2.hpp
-				//! \test decl.C99/Error_union_forward_def_volatile3.hpp
-				//! \test decl.C99/Error_union_forward_def_volatile4.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile2.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile3.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile4.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile5.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile6.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile7.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile8.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile9.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile10.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile11.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile12.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				if (tmp)
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-					// remove from parse
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;					
-					};
-				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				i += 2;
-				continue;
-				}
-			else if (!tmp)
-				{	// used without at least forward-declaring
-					//! \bug needs test cases
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("used without at least forward-declaring");
-				zcc_errors.inc_error();
-				}
-			}
-			break;
+			case UNION_NAME: break;	/* already handled */
 			case STRUCT_NAME: break;	/* already handled */
 			case CLASS_NAME: break;	/* already handled */
 			case UNION_NAMED_DEF: break;	/* already handled */

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-10 03:00:02 UTC (rev 567)
+++ trunk/CSupport.cpp.in	2011-01-10 03:48:06 UTC (rev 568)
@@ -14238,23 +14238,6 @@
 		}
 }
 
-static void _forward_declare_CPP_union(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
-{
-	parse_tree& tmp = src.c_array<0>()[i];
-#ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
-#else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-	assert(tmp2);
-	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-	assert(parse_tree::types->get_structdecl(tmp2));
-	tmp.type_code.set_type(tmp2);
-#endif
-	tmp.flags |= PARSE_UNION_TYPE;
-	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-}
-
 static void _forward_declare_CPP_union_preparsed(parse_tree& src, const char* const active_namespace, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i+k];
@@ -14355,11 +14338,10 @@
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// pre-scan for declaration-like items
 		{
-rescan:
-		pre_invariant_decl_scanner.clear(); // there's a lot of rescanning paths, so conserve lines of code
 		{	// wouldn't work for unnamed function parameters
 		const size_t strict_ub = src.size<0>()-i;
 		const parse_tree* const origin = src.data<0>()+i;
+		pre_invariant_decl_scanner.clear();	// fail-safe
 		while(pre_invariant_decl_scanner(origin[pre_invariant_decl_scanner.size()]))
 			// if we ran out of tokens, bad
 			if (strict_ub <= pre_invariant_decl_scanner.size())
@@ -14437,7 +14419,108 @@
 			size_t k = 0;
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(CPP0X_nontype_decl_specifier_list))
 				{
-				case UNION_NAME: break;
+				case UNION_NAME:
+				{
+				const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];					
+				if (tmp)
+					{
+					assert(0<parse_tree::types->use_count(tmp));
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_UNION_TYPE;
+					_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+					}
+				// One Definition Rule states that conflicting enum, struct, or class must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_struct_as_union.hpp
+						//! \test zcc/decl.C99/Error_struct_as_union3.hpp
+						//! \test zcc/decl.C99/Error_class_as_union.hpp
+						//! \test zcc/decl.C99/Error_class_as_union3.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(" declared as ");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					const char* const text = text_from_keyword(*tmp3);
+					INC_INFORM(text);
+					INFORM(" (C++98 One Definition Rule)");
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>(text);
+					assert(is_C99_named_specifier(tmp2,text));
+					pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
+					continue;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+					{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C++98 One Definition Rule)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+				else _forward_declare_CPP_union_preparsed(src,active_namespace,i,k,pre_invariant_decl_scanner);
+				}
+				parse_tree& tmp2 = src.c_array<0>()[i+k];					
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here
+					//! \test decl.C99/Error_union_forward_def_const.hpp
+					//! \test decl.C99/Error_union_forward_def_const2.hpp
+					//! \test decl.C99/Error_union_forward_def_const3.hpp
+					//! \test decl.C99/Error_union_forward_def_const4.hpp
+					//! \test decl.C99/Error_union_forward_def_volatile.hpp
+					//! \test decl.C99/Error_union_forward_def_volatile2.hpp
+					//! \test decl.C99/Error_union_forward_def_volatile3.hpp
+					//! \test decl.C99/Error_union_forward_def_volatile4.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile2.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile3.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile4.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile5.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile6.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile7.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile8.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile9.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile10.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile11.hpp
+					//! \test decl.C99/Error_union_forward_def_const_volatile12.hpp
+					CPP0X_flush_const_volatile_without_object(tmp2);
+					if (tmp)
+						{	// but if already (forward-)declared then this is a no-op
+							// think this is common enough to not warrant OAOO/DRY treatment
+						//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+						// remove from parse
+						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						goto restart_master_loop;
+						};
+					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+					}
+				else if (!tmp)
+					{	// used without at least forward-declaring
+						//! \bug needs test cases
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("used without at least forward-declaring");
+					zcc_errors.inc_error();
+					}
+				goto reparse;
+				}
+//				break;
 				case UNION_NAMED_DEF:
 				{	// can only define once
 				const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
@@ -14458,7 +14541,8 @@
 						// reduce to named-specifier
 						tmp2.DeleteIdx<2>(0);
 						assert(is_C99_named_specifier(tmp2,"union"));
-						goto rescan;
+						pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
+						continue;
 						}					
 					tmp2.type_code.set_type(tmp);
 					tmp2.flags |= PARSE_UNION_TYPE;
@@ -14619,7 +14703,8 @@
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("union");
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_struct.hpp
@@ -14734,7 +14819,8 @@
 					tmp2.set_index_token_from_str_literal<0>("union");
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_struct2.hpp
@@ -14864,7 +14950,8 @@
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("union");
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_class.hpp
@@ -14920,8 +15007,6 @@
 						}
 					// forward-declare
 					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-					i += 1+pre_invariant_decl_scanner.size();
-					goto restart_master_loop;
 					}
 				else if (!tmp)
 					{	// used without at least forward-declaring
@@ -14980,7 +15065,8 @@
 					tmp2.set_index_token_from_str_literal<0>("union");
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_class2.hpp
@@ -15145,7 +15231,8 @@
 					tmp2.set_index_token_from_str_literal<0>("union");
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_struct_as_enum.hpp
@@ -15205,6 +15292,7 @@
 		}
 		// check naked declarations first; handle namespaces later
 reparse:
+		pre_invariant_decl_scanner.clear();	// just in case; RAM conservation
 		const int tag_type = notice_CPP_tag(src.data<0>()[i]);
 		if (tag_type)
 			{
@@ -15213,103 +15301,7 @@
 #ifndef NDEBUG
 			default: _fatal_code("return value of notice_C99_tag out of range",3);
 #endif
-			case UNION_NAME:
-			{
-			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			if (tmp)
-				{
-				assert(0<parse_tree::types->use_count(tmp));
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				}
-			// One Definition Rule states that conflicting enum, struct, or class must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_struct_as_union.hpp
-					//! \test zcc/decl.C99/Error_struct_as_union3.hpp
-					//! \test zcc/decl.C99/Error_class_as_union.hpp
-					//! \test zcc/decl.C99/Error_class_as_union3.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INC_INFORM(" declared as ");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				INC_INFORM(text_from_keyword(*tmp2));
-				INFORM(" (C++98 One Definition Rule)");
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
-				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C++98 One Definition Rule)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-			else _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here
-				//! \test decl.C99/Error_union_forward_def_const.hpp
-				//! \test decl.C99/Error_union_forward_def_const2.hpp
-				//! \test decl.C99/Error_union_forward_def_const3.hpp
-				//! \test decl.C99/Error_union_forward_def_const4.hpp
-				//! \test decl.C99/Error_union_forward_def_volatile.hpp
-				//! \test decl.C99/Error_union_forward_def_volatile2.hpp
-				//! \test decl.C99/Error_union_forward_def_volatile3.hpp
-				//! \test decl.C99/Error_union_forward_def_volatile4.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile2.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile3.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile4.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile5.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile6.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile7.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile8.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile9.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile10.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile11.hpp
-				//! \test decl.C99/Error_union_forward_def_const_volatile12.hpp
-				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				if (tmp)
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-					// remove from parse
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;					
-					};
-				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				i += 2;
-				continue;
-				}
-			else if (!tmp)
-				{	// used without at least forward-declaring
-					//! \bug needs test cases
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("used without at least forward-declaring");
-				zcc_errors.inc_error();
-				}
-			}
-			break;
+			case UNION_NAME: break;	/* already handled */
 			case STRUCT_NAME: break;	/* already handled */
 			case CLASS_NAME: break;	/* already handled */
 			case UNION_NAMED_DEF: break;	/* already handled */



From zaimoni at mail.berlios.de  Mon Jan 10 04:56:50 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 10 Jan 2011 04:56:50 +0100
Subject: [Zcplusplus-commits] r569 - trunk
Message-ID: <20110110035651.4820B480DF3@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-10 04:56:50 +0100 (Mon, 10 Jan 2011)
New Revision: 569

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
morally dead switch cleanup

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-10 03:48:06 UTC (rev 568)
+++ trunk/CSupport.cpp	2011-01-10 03:56:50 UTC (rev 569)
@@ -14176,7 +14176,6 @@
 		}
 
 	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier);
-	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1+12,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier_or_tag);
 	size_t i = 0;
 restart_master_loop:
 	while(i<src.size<0>())
@@ -14189,12 +14188,12 @@
 			continue;
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
-		// pre-scan for declaration-like items
+		// check naked declarations first; handle namespaces later
 		{
+		kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1+12,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier_or_tag);
 		{	// wouldn't work for unnamed function parameters
 		const size_t strict_ub = src.size<0>()-i;
 		const parse_tree* const origin = src.data<0>()+i;
-		pre_invariant_decl_scanner.clear();	// fail-safe
 		while(pre_invariant_decl_scanner(origin[pre_invariant_decl_scanner.size()]))
 			// if we ran out of tokens, bad
 			if (strict_ub <= pre_invariant_decl_scanner.size())
@@ -15143,32 +15142,7 @@
 			while(pre_invariant_decl_scanner.size()> ++k);
 			};
 		}
-		// check naked declarations first; handle namespaces later
 reparse:
-		pre_invariant_decl_scanner.clear();	// just in case; RAM conservation
-		const int tag_type = notice_CPP_tag(src.data<0>()[i]);
-		if (tag_type)
-			{
-			switch(tag_type)
-			{	//! \todo deal with indentation violations later
-#ifndef NDEBUG
-			default: _fatal_code("return value of notice_C99_tag out of range",3);
-#endif
-			case UNION_NAME: break;	/* already handled */
-			case STRUCT_NAME: break;	/* already handled */
-			case CLASS_NAME: break;	/* already handled */
-			case UNION_NAMED_DEF: break;	/* already handled */
-			case STRUCT_NAMED_DEF: break;	/* already handled */
-			case CLASS_NAMED_DEF: break;	/* already handled */
-			case UNION_ANON_DEF: break;	/* already handled */
-			case STRUCT_ANON_DEF: break;	/* already handled */
-			case CLASS_ANON_DEF: break;	/* already handled */
-			case ENUM_NAME: break;	/* already handled */
-			case ENUM_NAMED_DEF: break;	/* already handled */
-			case ENUM_ANON_DEF: break;	/* already handled */
-			}
-			};
-
 		// namespace scanner
 		// need some scheme to handle unnamed namespaces (probably alphabetical counter after something illegal so unmatchable)
 		// C++0X has inline namespaces; ignore these for now (well, maybe not: consuming the inline will prevent problems)

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-10 03:48:06 UTC (rev 568)
+++ trunk/CSupport.cpp.in	2011-01-10 03:56:50 UTC (rev 569)
@@ -14323,7 +14323,6 @@
 		}
 
 	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier);
-	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1+12,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier_or_tag);
 	size_t i = 0;
 restart_master_loop:
 	while(i<src.size<0>())
@@ -14336,12 +14335,12 @@
 			continue;
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
-		// pre-scan for declaration-like items
+		// check naked declarations first; handle namespaces later
 		{
+		kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1+12,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier_or_tag);
 		{	// wouldn't work for unnamed function parameters
 		const size_t strict_ub = src.size<0>()-i;
 		const parse_tree* const origin = src.data<0>()+i;
-		pre_invariant_decl_scanner.clear();	// fail-safe
 		while(pre_invariant_decl_scanner(origin[pre_invariant_decl_scanner.size()]))
 			// if we ran out of tokens, bad
 			if (strict_ub <= pre_invariant_decl_scanner.size())
@@ -15290,32 +15289,7 @@
 			while(pre_invariant_decl_scanner.size()> ++k);
 			};
 		}
-		// check naked declarations first; handle namespaces later
 reparse:
-		pre_invariant_decl_scanner.clear();	// just in case; RAM conservation
-		const int tag_type = notice_CPP_tag(src.data<0>()[i]);
-		if (tag_type)
-			{
-			switch(tag_type)
-			{	//! \todo deal with indentation violations later
-#ifndef NDEBUG
-			default: _fatal_code("return value of notice_C99_tag out of range",3);
-#endif
-			case UNION_NAME: break;	/* already handled */
-			case STRUCT_NAME: break;	/* already handled */
-			case CLASS_NAME: break;	/* already handled */
-			case UNION_NAMED_DEF: break;	/* already handled */
-			case STRUCT_NAMED_DEF: break;	/* already handled */
-			case CLASS_NAMED_DEF: break;	/* already handled */
-			case UNION_ANON_DEF: break;	/* already handled */
-			case STRUCT_ANON_DEF: break;	/* already handled */
-			case CLASS_ANON_DEF: break;	/* already handled */
-			case ENUM_NAME: break;	/* already handled */
-			case ENUM_NAMED_DEF: break;	/* already handled */
-			case ENUM_ANON_DEF: break;	/* already handled */
-			}
-			};
-
 		// namespace scanner
 		// need some scheme to handle unnamed namespaces (probably alphabetical counter after something illegal so unmatchable)
 		// C++0X has inline namespaces; ignore these for now (well, maybe not: consuming the inline will prevent problems)



From zaimoni at mail.berlios.de  Mon Jan 10 05:07:53 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 10 Jan 2011 05:07:53 +0100
Subject: [Zcplusplus-commits] r570 - trunk
Message-ID: <20110110040754.1EEA6480DFA@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-10 05:07:53 +0100 (Mon, 10 Jan 2011)
New Revision: 570

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
adjusting scope of a kleene_star variable, other conceptual cleanup

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-10 03:56:50 UTC (rev 569)
+++ trunk/CSupport.cpp	2011-01-10 04:07:53 UTC (rev 570)
@@ -13079,7 +13079,6 @@
 	// ask GCC: struct/class/union/enum collides with each other (both C and C++), does not collide with namespace
 	// think we can handle this as "disallow conflicting definitions"
 	kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(C99_type_or_invariant_decl_specifier);
-	kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1+9,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(C99_type_or_invariant_decl_specifier_or_tag);
 	size_t i = 0;
 	while(i<src.size<0>())
 		{
@@ -13094,7 +13093,7 @@
 		// pre-scan for declaration-like items
 		{
 rescan:
-		pre_invariant_decl_scanner.clear(); // there's a lot of rescanning paths, so conserve lines of code
+		kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1+9,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(C99_type_or_invariant_decl_specifier_or_tag);
 		{	// wouldn't work for unnamed function parameters
 		const size_t strict_ub = src.size<0>()-i;
 		const parse_tree* const origin = src.data<0>()+i;
@@ -13190,7 +13189,7 @@
 					tmp2.type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 					tmp2.flags |= (parse_tree::INVALID | PARSE_PRIMARY_TYPE);
 					};
-				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
+				goto reparse;
 				}
 				break;
 				case ENUM_NAMED_DEF:
@@ -13262,9 +13261,9 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
+				goto reparse;
 				}
-				break;
+//				break;
 				case ENUM_ANON_DEF:
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
@@ -13277,11 +13276,10 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
+				goto reparse;
 				}
 				}
 			while(pre_invariant_decl_scanner.size()> ++k);
-			pre_invariant_decl_scanner.clear();	// RAM efficiency
 			};
 		}
 		// check naked declarations first

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-10 03:56:50 UTC (rev 569)
+++ trunk/CSupport.cpp.in	2011-01-10 04:07:53 UTC (rev 570)
@@ -13223,7 +13223,6 @@
 	// ask GCC: struct/class/union/enum collides with each other (both C and C++), does not collide with namespace
 	// think we can handle this as "disallow conflicting definitions"
 	kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(C99_type_or_invariant_decl_specifier);
-	kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1+9,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(C99_type_or_invariant_decl_specifier_or_tag);
 	size_t i = 0;
 	while(i<src.size<0>())
 		{
@@ -13238,7 +13237,7 @@
 		// pre-scan for declaration-like items
 		{
 rescan:
-		pre_invariant_decl_scanner.clear(); // there's a lot of rescanning paths, so conserve lines of code
+		kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1+9,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(C99_type_or_invariant_decl_specifier_or_tag);
 		{	// wouldn't work for unnamed function parameters
 		const size_t strict_ub = src.size<0>()-i;
 		const parse_tree* const origin = src.data<0>()+i;
@@ -13337,7 +13336,7 @@
 					tmp2.type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 					tmp2.flags |= (parse_tree::INVALID | PARSE_PRIMARY_TYPE);
 					};
-				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
+				goto reparse;
 				}
 				break;
 				case ENUM_NAMED_DEF:
@@ -13409,9 +13408,9 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
+				goto reparse;
 				}
-				break;
+//				break;
 				case ENUM_ANON_DEF:
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
@@ -13424,11 +13423,10 @@
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 					return;
 					}
-				pre_invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
+				goto reparse;
 				}
 				}
 			while(pre_invariant_decl_scanner.size()> ++k);
-			pre_invariant_decl_scanner.clear();	// RAM efficiency
 			};
 		}
 		// check naked declarations first



From zaimoni at mail.berlios.de  Mon Jan 10 06:51:15 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 10 Jan 2011 06:51:15 +0100
Subject: [Zcplusplus-commits] r571 - trunk
Message-ID: <20110110055116.9073B480A3A@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-10 06:51:15 +0100 (Mon, 10 Jan 2011)
New Revision: 571

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
C anonymous struct definitions: converge parsing towards standard

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-10 04:07:53 UTC (rev 570)
+++ trunk/CSupport.cpp	2011-01-10 05:51:15 UTC (rev 571)
@@ -13080,6 +13080,7 @@
 	// think we can handle this as "disallow conflicting definitions"
 	kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(C99_type_or_invariant_decl_specifier);
 	size_t i = 0;
+restart_master_loop:
 	while(i<src.size<0>())
 		{
 		conserve_tokens(src.c_array<0>()[i]);
@@ -13117,6 +13118,7 @@
 		}
 		if (!pre_invariant_decl_scanner.empty())
 			{
+			const bool semicolon_terminated_decl = robust_token_is_char<';'>(src.data<0>()[i+pre_invariant_decl_scanner.size()]); 
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
 			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse
@@ -13158,6 +13160,9 @@
 					return;
 					}
 				}
+			//! \bug check for pre-existing typedefs if no types
+			if (0>=typecount || 0<pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)))
+				goto reparse;
 			}
 
 			size_t k = 0;
@@ -13168,7 +13173,56 @@
 				case UNION_ANON_DEF: break;
 				case STRUCT_NAME: break;
 				case STRUCT_NAMED_DEF: break;
-				case STRUCT_ANON_DEF: break;
+				case STRUCT_ANON_DEF:
+				{	// anonymous types cannot be matched
+				// tentatively forward-declare immediately
+				const type_system::type_index tmp = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_struct,src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
+				assert(tmp);
+				assert(parse_tree::types->get_structdecl(tmp));
+
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				tmp2.type_code.set_type(tmp);
+				tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+				}
+				_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+
+				// parse the union and upgrade it to a full definition
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp);
+				assert(tmp3);
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(tmp,tmp4);
+				assert(parse_tree::types->get_C_structdef(tmp));
+
+				if (semicolon_terminated_decl)
+					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \test decl.C99/Warn_struct_anon_def_const.h
+					//! \test decl.C99/Warn_struct_anon_def_const2.h
+					//! \test decl.C99/Warn_struct_anon_def_volatile.h
+					//! \test decl.C99/Warn_struct_anon_def_volatile2.h
+					//! \test decl.C99/Warn_struct_anon_def_const_volatile.h
+					//! \test decl.C99/Warn_struct_anon_def_const_volatile2.h
+					//! \test decl.C99/Warn_struct_anon_def_const_volatile3.h
+					//! \test decl.C99/Warn_struct_anon_def_const_volatile4.h
+					//! \test decl.C99/Warn_struct_anon_def_const_volatile5.h
+					//! \test decl.C99/Warn_struct_anon_def_const_volatile6.h
+					C99_flush_const_volatile_without_object(tmp2);
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_struct.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("unreferenceable anonymous struct declaration");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// remove from parse
+					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+					goto restart_master_loop;
+					}
+				goto reparse;
+				}
+//				break;
 				//! \bug the enums aren't handling const/volatile qualification
 				case ENUM_NAME:
 				{	// C99 6.7.2.3: allowed only after name is defined
@@ -13191,7 +13245,7 @@
 					};
 				goto reparse;
 				}
-				break;
+//				break;
 				case ENUM_NAMED_DEF:
 				{	// can only define once
 				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
@@ -13715,52 +13769,7 @@
 				}
 			}
 			break;
-			case STRUCT_ANON_DEF:
-			{	// anonymous types cannot be matched
-			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			assert(tmp2);
-			assert(parse_tree::types->get_structdecl(tmp2));
-
-			src.c_array<0>()[i].type_code.set_type(tmp2);
-			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-
-			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
-			assert(parse_tree::types->get_C_structdef(tmp2));
-
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				//! \test decl.C99/Warn_struct_anon_def_const.h
-				//! \test decl.C99/Warn_struct_anon_def_const2.h
-				//! \test decl.C99/Warn_struct_anon_def_volatile.h
-				//! \test decl.C99/Warn_struct_anon_def_volatile2.h
-				//! \test decl.C99/Warn_struct_anon_def_const_volatile.h
-				//! \test decl.C99/Warn_struct_anon_def_const_volatile2.h
-				//! \test decl.C99/Warn_struct_anon_def_const_volatile3.h
-				//! \test decl.C99/Warn_struct_anon_def_const_volatile4.h
-				//! \test decl.C99/Warn_struct_anon_def_const_volatile5.h
-				//! \test decl.C99/Warn_struct_anon_def_const_volatile6.h
-				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-				//! \test zcc/decl.C99/Warn_inaccessible_struct.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous struct declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			}
-			break;
+			case STRUCT_ANON_DEF: break;	/* already handled */
 			case ENUM_NAME: break;	/* already handled */
 			case ENUM_NAMED_DEF: break;	/* already handled */
 			case ENUM_ANON_DEF: break;	/* already handled */

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-10 04:07:53 UTC (rev 570)
+++ trunk/CSupport.cpp.in	2011-01-10 05:51:15 UTC (rev 571)
@@ -13224,6 +13224,7 @@
 	// think we can handle this as "disallow conflicting definitions"
 	kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(C99_type_or_invariant_decl_specifier);
 	size_t i = 0;
+restart_master_loop:
 	while(i<src.size<0>())
 		{
 		conserve_tokens(src.c_array<0>()[i]);
@@ -13261,9 +13262,7 @@
 		}
 		if (!pre_invariant_decl_scanner.empty())
 			{
-#/*cut-nocpp*/
-			const bool semicolon_terminated_decl = robust_token_is_char<';'>(src.data<0>()[i+pre_invariant_decl_scanner.empty()]); 
-#/*cut-nocpp*/
+			const bool semicolon_terminated_decl = robust_token_is_char<';'>(src.data<0>()[i+pre_invariant_decl_scanner.size()]); 
 			//! \todo naked identifier beyond could be an already-existing typedef which would trigger a rescan
 			//! \todo ; means decl terminates w/o identifier 
 			//! \todo if there are unparsed tags, scan for them and parse
@@ -13305,6 +13304,9 @@
 					return;
 					}
 				}
+			//! \bug check for pre-existing typedefs if no types
+			if (0>=typecount || 0<pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)))
+				goto reparse;
 			}
 
 			size_t k = 0;
@@ -13315,7 +13317,56 @@
 				case UNION_ANON_DEF: break;
 				case STRUCT_NAME: break;
 				case STRUCT_NAMED_DEF: break;
-				case STRUCT_ANON_DEF: break;
+				case STRUCT_ANON_DEF:
+				{	// anonymous types cannot be matched
+				// tentatively forward-declare immediately
+				const type_system::type_index tmp = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_struct,src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
+				assert(tmp);
+				assert(parse_tree::types->get_structdecl(tmp));
+
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				tmp2.type_code.set_type(tmp);
+				tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+				}
+				_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+
+				// parse the union and upgrade it to a full definition
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp);
+				assert(tmp3);
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(tmp,tmp4);
+				assert(parse_tree::types->get_C_structdef(tmp));
+
+				if (semicolon_terminated_decl)
+					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \test decl.C99/Warn_struct_anon_def_const.h
+					//! \test decl.C99/Warn_struct_anon_def_const2.h
+					//! \test decl.C99/Warn_struct_anon_def_volatile.h
+					//! \test decl.C99/Warn_struct_anon_def_volatile2.h
+					//! \test decl.C99/Warn_struct_anon_def_const_volatile.h
+					//! \test decl.C99/Warn_struct_anon_def_const_volatile2.h
+					//! \test decl.C99/Warn_struct_anon_def_const_volatile3.h
+					//! \test decl.C99/Warn_struct_anon_def_const_volatile4.h
+					//! \test decl.C99/Warn_struct_anon_def_const_volatile5.h
+					//! \test decl.C99/Warn_struct_anon_def_const_volatile6.h
+					C99_flush_const_volatile_without_object(tmp2);
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_struct.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("unreferenceable anonymous struct declaration");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// remove from parse
+					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+					goto restart_master_loop;
+					}
+				goto reparse;
+				}
+//				break;
 				//! \bug the enums aren't handling const/volatile qualification
 				case ENUM_NAME:
 				{	// C99 6.7.2.3: allowed only after name is defined
@@ -13338,7 +13389,7 @@
 					};
 				goto reparse;
 				}
-				break;
+//				break;
 				case ENUM_NAMED_DEF:
 				{	// can only define once
 				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
@@ -13862,52 +13913,7 @@
 				}
 			}
 			break;
-			case STRUCT_ANON_DEF:
-			{	// anonymous types cannot be matched
-			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			assert(tmp2);
-			assert(parse_tree::types->get_structdecl(tmp2));
-
-			src.c_array<0>()[i].type_code.set_type(tmp2);
-			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-
-			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
-			assert(parse_tree::types->get_C_structdef(tmp2));
-
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				//! \test decl.C99/Warn_struct_anon_def_const.h
-				//! \test decl.C99/Warn_struct_anon_def_const2.h
-				//! \test decl.C99/Warn_struct_anon_def_volatile.h
-				//! \test decl.C99/Warn_struct_anon_def_volatile2.h
-				//! \test decl.C99/Warn_struct_anon_def_const_volatile.h
-				//! \test decl.C99/Warn_struct_anon_def_const_volatile2.h
-				//! \test decl.C99/Warn_struct_anon_def_const_volatile3.h
-				//! \test decl.C99/Warn_struct_anon_def_const_volatile4.h
-				//! \test decl.C99/Warn_struct_anon_def_const_volatile5.h
-				//! \test decl.C99/Warn_struct_anon_def_const_volatile6.h
-				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-				//! \test zcc/decl.C99/Warn_inaccessible_struct.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous struct declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			}
-			break;
+			case STRUCT_ANON_DEF: break;	/* already handled */
 			case ENUM_NAME: break;	/* already handled */
 			case ENUM_NAMED_DEF: break;	/* already handled */
 			case ENUM_ANON_DEF: break;	/* already handled */



From zaimoni at mail.berlios.de  Mon Jan 10 08:04:11 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 10 Jan 2011 08:04:11 +0100
Subject: [Zcplusplus-commits] r572 - trunk
Message-ID: <20110110070411.75E91480A3A@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-10 08:04:10 +0100 (Mon, 10 Jan 2011)
New Revision: 572

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
C named struct definitions: converge parsing towards standard

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-10 05:51:15 UTC (rev 571)
+++ trunk/CSupport.cpp	2011-01-10 07:04:10 UTC (rev 572)
@@ -13055,6 +13055,24 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 }
 
+static void _forward_declare_C_struct_preparsed(parse_tree& src, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	parse_tree& tmp = src.c_array<0>()[i];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl(tmp.index_tokens[1].token.first,union_struct_decl::decl_struct,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
+#else
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(tmp.index_tokens[1].token.first,union_struct_decl::decl_struct,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_struct_class(tmp.index_tokens[1].token.first));
+	assert(parse_tree::types->get_id_struct_class(tmp.index_tokens[1].token.first)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
+	invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
+	_condense_const_volatile_onto_type_preparsed(src,i,k,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+}
+
 // will need: "function-type vector"
 // return: 1 typespec record (for now, other languages may have more demanding requirements)
 // incoming: n typespec records, flag for trailing ...
@@ -13172,7 +13190,103 @@
 				case UNION_NAMED_DEF: break;
 				case UNION_ANON_DEF: break;
 				case STRUCT_NAME: break;
-				case STRUCT_NAMED_DEF: break;
+				case STRUCT_NAMED_DEF:
+				{	// can only define once
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i+k].index_tokens[1].token.first);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];					
+				if (tmp)
+					{
+					assert(0<parse_tree::types->use_count(tmp));
+					if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
+						{	//! \test zcc/decl.C99/Error_struct_multidef.h
+						message_header(tmp2.index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("'struct ");
+						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INFORM("' already defined (C99 6.7.2.3p1)");
+						message_header(fatal_def->_decl);
+						INFORM("prior definition here");
+						zcc_errors.inc_error();
+						// reduce to named-specifier
+						tmp2.DeleteIdx<2>(0);
+						assert(is_C99_named_specifier(tmp2,"struct"));
+						goto rescan;
+						}
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+					}
+				// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_union_as_struct2.h
+						//! \test zcc/decl.C99/Error_union_as_struct4.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C99 6.7.2.3p2)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_enum_as_struct2.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_struct_forward_def.h
+				else _forward_declare_C_struct_preparsed(src,i,k,pre_invariant_decl_scanner);
+				}
+				// parse the union and upgrade it to a full definition
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				const type_system::type_index vr_tmp = tmp2.type_code.base_type_index;
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
+				assert(tmp3);
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+				assert(parse_tree::types->get_id_struct_class(tmp2.index_tokens[1].token.first)==vr_tmp);
+				assert(parse_tree::types->get_C_structdef(vr_tmp));
+				if (semicolon_terminated_decl)
+					{	// no objects declared, trigger the const/volatile warnings
+					//! \test decl.C99/Warn_struct_def_const.h
+					//! \test decl.C99/Warn_struct_def_const2.h
+					//! \test decl.C99/Warn_struct_def_volatile.h
+					//! \test decl.C99/Warn_struct_def_volatile2.h
+					//! \test decl.C99/Warn_struct_def_const_volatile.h
+					//! \test decl.C99/Warn_struct_def_const_volatile2.h
+					//! \test decl.C99/Warn_struct_def_const_volatile3.h
+					//! \test decl.C99/Warn_struct_def_const_volatile4.h
+					//! \test decl.C99/Warn_struct_def_const_volatile5.h
+					//! \test decl.C99/Warn_struct_def_const_volatile6.h
+					C99_flush_const_volatile_without_object(tmp2);
+					// accept definition
+					//! \test zcc/decl.C99/Pass_union_forward_def.h
+					};
+				goto reparse;
+				}
+//				break;
 				case STRUCT_ANON_DEF:
 				{	// anonymous types cannot be matched
 				// tentatively forward-declare immediately
@@ -13629,100 +13743,7 @@
 				};
 			}
 			break;
-			case STRUCT_NAMED_DEF:
-			{	// can only define once
-			const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
-			if (tmp)
-				{
-				assert(0<parse_tree::types->use_count(tmp));
-				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
-					{	//! \test zcc/decl.C99/Error_struct_multidef.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'struct ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' already defined (C99 6.7.2.3p1)");
-					message_header(fatal_def->_decl);
-					INFORM("prior definition here");
-					zcc_errors.inc_error();
-					// reduce to named-specifier
-					src.c_array<0>()[i].DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-					goto reparse;
-					}
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				}
-			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_union_as_struct2.h
-					//! \test zcc/decl.C99/Error_union_as_struct4.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C99 6.7.2.3p2)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_enum_as_struct2.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_struct_forward_def.h
-			else _forward_declare_C_struct(src,i,invariant_decl_scanner);
-			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(parse_tree::types->get_C_structdef(vr_tmp));
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// no objects declared, trigger the const/volatile warnings
-				//! \test decl.C99/Warn_struct_def_const.h
-				//! \test decl.C99/Warn_struct_def_const2.h
-				//! \test decl.C99/Warn_struct_def_volatile.h
-				//! \test decl.C99/Warn_struct_def_volatile2.h
-				//! \test decl.C99/Warn_struct_def_const_volatile.h
-				//! \test decl.C99/Warn_struct_def_const_volatile2.h
-				//! \test decl.C99/Warn_struct_def_const_volatile3.h
-				//! \test decl.C99/Warn_struct_def_const_volatile4.h
-				//! \test decl.C99/Warn_struct_def_const_volatile5.h
-				//! \test decl.C99/Warn_struct_def_const_volatile6.h
-				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				// accept definition
-				//! \test zcc/decl.C99/Pass_union_forward_def.h
-				i += 2;
-				continue;
-				};
-			}
-			break;
+			case STRUCT_NAMED_DEF: break;	/* already handled */
 			case UNION_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-10 05:51:15 UTC (rev 571)
+++ trunk/CSupport.cpp.in	2011-01-10 07:04:10 UTC (rev 572)
@@ -13199,6 +13199,24 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 }
 
+static void _forward_declare_C_struct_preparsed(parse_tree& src, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	parse_tree& tmp = src.c_array<0>()[i];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl(tmp.index_tokens[1].token.first,union_struct_decl::decl_struct,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
+#else
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(tmp.index_tokens[1].token.first,union_struct_decl::decl_struct,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_struct_class(tmp.index_tokens[1].token.first));
+	assert(parse_tree::types->get_id_struct_class(tmp.index_tokens[1].token.first)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
+	invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
+	_condense_const_volatile_onto_type_preparsed(src,i,k,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+}
+
 // will need: "function-type vector"
 // return: 1 typespec record (for now, other languages may have more demanding requirements)
 // incoming: n typespec records, flag for trailing ...
@@ -13316,7 +13334,103 @@
 				case UNION_NAMED_DEF: break;
 				case UNION_ANON_DEF: break;
 				case STRUCT_NAME: break;
-				case STRUCT_NAMED_DEF: break;
+				case STRUCT_NAMED_DEF:
+				{	// can only define once
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i+k].index_tokens[1].token.first);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];					
+				if (tmp)
+					{
+					assert(0<parse_tree::types->use_count(tmp));
+					if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
+						{	//! \test zcc/decl.C99/Error_struct_multidef.h
+						message_header(tmp2.index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("'struct ");
+						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INFORM("' already defined (C99 6.7.2.3p1)");
+						message_header(fatal_def->_decl);
+						INFORM("prior definition here");
+						zcc_errors.inc_error();
+						// reduce to named-specifier
+						tmp2.DeleteIdx<2>(0);
+						assert(is_C99_named_specifier(tmp2,"struct"));
+						goto rescan;
+						}
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+					}
+				// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_union_as_struct2.h
+						//! \test zcc/decl.C99/Error_union_as_struct4.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C99 6.7.2.3p2)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_enum_as_struct2.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_struct_forward_def.h
+				else _forward_declare_C_struct_preparsed(src,i,k,pre_invariant_decl_scanner);
+				}
+				// parse the union and upgrade it to a full definition
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				const type_system::type_index vr_tmp = tmp2.type_code.base_type_index;
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
+				assert(tmp3);
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+				assert(parse_tree::types->get_id_struct_class(tmp2.index_tokens[1].token.first)==vr_tmp);
+				assert(parse_tree::types->get_C_structdef(vr_tmp));
+				if (semicolon_terminated_decl)
+					{	// no objects declared, trigger the const/volatile warnings
+					//! \test decl.C99/Warn_struct_def_const.h
+					//! \test decl.C99/Warn_struct_def_const2.h
+					//! \test decl.C99/Warn_struct_def_volatile.h
+					//! \test decl.C99/Warn_struct_def_volatile2.h
+					//! \test decl.C99/Warn_struct_def_const_volatile.h
+					//! \test decl.C99/Warn_struct_def_const_volatile2.h
+					//! \test decl.C99/Warn_struct_def_const_volatile3.h
+					//! \test decl.C99/Warn_struct_def_const_volatile4.h
+					//! \test decl.C99/Warn_struct_def_const_volatile5.h
+					//! \test decl.C99/Warn_struct_def_const_volatile6.h
+					C99_flush_const_volatile_without_object(tmp2);
+					// accept definition
+					//! \test zcc/decl.C99/Pass_union_forward_def.h
+					};
+				goto reparse;
+				}
+//				break;
 				case STRUCT_ANON_DEF:
 				{	// anonymous types cannot be matched
 				// tentatively forward-declare immediately
@@ -13773,100 +13887,7 @@
 				};
 			}
 			break;
-			case STRUCT_NAMED_DEF:
-			{	// can only define once
-			const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
-			if (tmp)
-				{
-				assert(0<parse_tree::types->use_count(tmp));
-				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
-					{	//! \test zcc/decl.C99/Error_struct_multidef.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'struct ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' already defined (C99 6.7.2.3p1)");
-					message_header(fatal_def->_decl);
-					INFORM("prior definition here");
-					zcc_errors.inc_error();
-					// reduce to named-specifier
-					src.c_array<0>()[i].DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-					goto reparse;
-					}
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				}
-			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_union_as_struct2.h
-					//! \test zcc/decl.C99/Error_union_as_struct4.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C99 6.7.2.3p2)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_enum_as_struct2.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_struct_forward_def.h
-			else _forward_declare_C_struct(src,i,invariant_decl_scanner);
-			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(parse_tree::types->get_C_structdef(vr_tmp));
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// no objects declared, trigger the const/volatile warnings
-				//! \test decl.C99/Warn_struct_def_const.h
-				//! \test decl.C99/Warn_struct_def_const2.h
-				//! \test decl.C99/Warn_struct_def_volatile.h
-				//! \test decl.C99/Warn_struct_def_volatile2.h
-				//! \test decl.C99/Warn_struct_def_const_volatile.h
-				//! \test decl.C99/Warn_struct_def_const_volatile2.h
-				//! \test decl.C99/Warn_struct_def_const_volatile3.h
-				//! \test decl.C99/Warn_struct_def_const_volatile4.h
-				//! \test decl.C99/Warn_struct_def_const_volatile5.h
-				//! \test decl.C99/Warn_struct_def_const_volatile6.h
-				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				// accept definition
-				//! \test zcc/decl.C99/Pass_union_forward_def.h
-				i += 2;
-				continue;
-				};
-			}
-			break;
+			case STRUCT_NAMED_DEF: break;	/* already handled */
 			case UNION_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately



From zaimoni at mail.berlios.de  Mon Jan 10 19:47:18 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 10 Jan 2011 19:47:18 +0100
Subject: [Zcplusplus-commits] r573 - trunk
Message-ID: <20110110184718.B6354480510@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-10 19:47:18 +0100 (Mon, 10 Jan 2011)
New Revision: 573

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
C named struct declarators: converge parsing towards standard

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-10 07:04:10 UTC (rev 572)
+++ trunk/CSupport.cpp	2011-01-10 18:47:18 UTC (rev 573)
@@ -13038,23 +13038,6 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 }
 
-static void _forward_declare_C_struct(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
-{
-	parse_tree& tmp = src.c_array<0>()[i];
-#ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
-#else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-	assert(tmp2);
-	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-	assert(parse_tree::types->get_structdecl(tmp2));
-	tmp.type_code.set_type(tmp2);
-#endif
-	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
-	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-}
-
 static void _forward_declare_C_struct_preparsed(parse_tree& src, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i];
@@ -13189,7 +13172,103 @@
 				case UNION_NAME: break;
 				case UNION_NAMED_DEF: break;
 				case UNION_ANON_DEF: break;
-				case STRUCT_NAME: break;
+				case STRUCT_NAME:
+				{
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i+k].index_tokens[1].token.first);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (tmp)
+					{
+					assert(0<parse_tree::types->use_count(tmp));
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+					}
+				// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_union_as_struct.h
+						//! \test zcc/decl.C99/Error_union_as_struct3.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C99 6.7.2.3p2)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_enum_as_struct.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_struct_forward_def.h
+				else _forward_declare_C_struct_preparsed(src,i,k,pre_invariant_decl_scanner);
+				}
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here (C99 6.7.2.3)
+					//! \test decl.C99/Warn_struct_forward_def_const.h
+					//! \test decl.C99/Warn_struct_forward_def_const2.h
+					//! \test decl.C99/Warn_struct_forward_def_const3.h
+					//! \test decl.C99/Warn_struct_forward_def_const4.h
+					//! \test decl.C99/Warn_struct_forward_def_volatile.h
+					//! \test decl.C99/Warn_struct_forward_def_volatile2.h
+					//! \test decl.C99/Warn_struct_forward_def_volatile3.h
+					//! \test decl.C99/Warn_struct_forward_def_volatile4.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile2.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile3.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile4.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile5.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile6.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile7.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile8.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile9.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile10.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile11.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile12.h
+					C99_flush_const_volatile_without_object(tmp2);
+					if (tmp)
+						{	// but if already (forward-)declared then this is a no-op
+							// think this is common enough to not warrant OAOO/DRY treatment
+						//! \test zcc/decl.C99/Pass_struct_forward_def.h
+						// remove from parse
+						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						goto restart_master_loop;
+						}
+					// forward-declare
+					//! \test zcc/decl.C99/Pass_struct_forward_def.h
+					}
+				else if (!tmp)
+					{	// used without at least forward-declaring
+						//! \bug needs test cases
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("used without at least forward-declaring");
+					zcc_errors.inc_error();
+					}
+				goto reparse;
+				}
+//				break;
 				case STRUCT_NAMED_DEF:
 				{	// can only define once
 				const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i+k].index_tokens[1].token.first);
@@ -13211,7 +13290,8 @@
 						// reduce to named-specifier
 						tmp2.DeleteIdx<2>(0);
 						assert(is_C99_named_specifier(tmp2,"struct"));
-						goto rescan;
+						pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
+						continue;
 						}
 					tmp2.type_code.set_type(tmp);
 					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
@@ -13415,7 +13495,8 @@
 					tmp2.set_index_token_from_str_literal<0>("struct");
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"struct"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
+					continue;
 					}
 				
 				// enum-specifier doesn't have a specific declaration mode
@@ -13555,100 +13636,7 @@
 				}
 			}
 			break;
-			case STRUCT_NAME:
-			{
-			const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
-			if (tmp)
-				{
-				assert(0<parse_tree::types->use_count(tmp));
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				}
-			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_union_as_struct.h
-					//! \test zcc/decl.C99/Error_union_as_struct3.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C99 6.7.2.3p2)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_enum_as_struct.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_struct_forward_def.h
-			else _forward_declare_C_struct(src,i,invariant_decl_scanner);
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here (C99 6.7.2.3)
-				//! \test decl.C99/Warn_struct_forward_def_const.h
-				//! \test decl.C99/Warn_struct_forward_def_const2.h
-				//! \test decl.C99/Warn_struct_forward_def_const3.h
-				//! \test decl.C99/Warn_struct_forward_def_const4.h
-				//! \test decl.C99/Warn_struct_forward_def_volatile.h
-				//! \test decl.C99/Warn_struct_forward_def_volatile2.h
-				//! \test decl.C99/Warn_struct_forward_def_volatile3.h
-				//! \test decl.C99/Warn_struct_forward_def_volatile4.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile2.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile3.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile4.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile5.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile6.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile7.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile8.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile9.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile10.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile11.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile12.h
-				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				if (tmp)
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_struct_forward_def.h
-					// remove from parse
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;					
-					}
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				i += 2;
-				continue;
-				}
-			else if (!tmp)
-				{	// used without at least forward-declaring
-					//! \bug needs test cases
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("used without at least forward-declaring");
-				zcc_errors.inc_error();
-				}
-			}
-			break;
+			case STRUCT_NAME: break;	/* already handled */
 			case UNION_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-10 07:04:10 UTC (rev 572)
+++ trunk/CSupport.cpp.in	2011-01-10 18:47:18 UTC (rev 573)
@@ -13182,23 +13182,6 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 }
 
-static void _forward_declare_C_struct(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
-{
-	parse_tree& tmp = src.c_array<0>()[i];
-#ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
-#else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-	assert(tmp2);
-	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-	assert(parse_tree::types->get_structdecl(tmp2));
-	tmp.type_code.set_type(tmp2);
-#endif
-	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
-	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-}
-
 static void _forward_declare_C_struct_preparsed(parse_tree& src, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i];
@@ -13333,7 +13316,103 @@
 				case UNION_NAME: break;
 				case UNION_NAMED_DEF: break;
 				case UNION_ANON_DEF: break;
-				case STRUCT_NAME: break;
+				case STRUCT_NAME:
+				{
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i+k].index_tokens[1].token.first);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (tmp)
+					{
+					assert(0<parse_tree::types->use_count(tmp));
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+					}
+				// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_union_as_struct.h
+						//! \test zcc/decl.C99/Error_union_as_struct3.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as union (C99 6.7.2.3p2)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("union");
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_enum_as_struct.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("struct ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_struct_forward_def.h
+				else _forward_declare_C_struct_preparsed(src,i,k,pre_invariant_decl_scanner);
+				}
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here (C99 6.7.2.3)
+					//! \test decl.C99/Warn_struct_forward_def_const.h
+					//! \test decl.C99/Warn_struct_forward_def_const2.h
+					//! \test decl.C99/Warn_struct_forward_def_const3.h
+					//! \test decl.C99/Warn_struct_forward_def_const4.h
+					//! \test decl.C99/Warn_struct_forward_def_volatile.h
+					//! \test decl.C99/Warn_struct_forward_def_volatile2.h
+					//! \test decl.C99/Warn_struct_forward_def_volatile3.h
+					//! \test decl.C99/Warn_struct_forward_def_volatile4.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile2.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile3.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile4.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile5.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile6.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile7.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile8.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile9.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile10.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile11.h
+					//! \test decl.C99/Warn_struct_forward_def_const_volatile12.h
+					C99_flush_const_volatile_without_object(tmp2);
+					if (tmp)
+						{	// but if already (forward-)declared then this is a no-op
+							// think this is common enough to not warrant OAOO/DRY treatment
+						//! \test zcc/decl.C99/Pass_struct_forward_def.h
+						// remove from parse
+						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						goto restart_master_loop;
+						}
+					// forward-declare
+					//! \test zcc/decl.C99/Pass_struct_forward_def.h
+					}
+				else if (!tmp)
+					{	// used without at least forward-declaring
+						//! \bug needs test cases
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("used without at least forward-declaring");
+					zcc_errors.inc_error();
+					}
+				goto reparse;
+				}
+//				break;
 				case STRUCT_NAMED_DEF:
 				{	// can only define once
 				const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i+k].index_tokens[1].token.first);
@@ -13355,7 +13434,8 @@
 						// reduce to named-specifier
 						tmp2.DeleteIdx<2>(0);
 						assert(is_C99_named_specifier(tmp2,"struct"));
-						goto rescan;
+						pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
+						continue;
 						}
 					tmp2.type_code.set_type(tmp);
 					tmp2.flags |= PARSE_CLASS_STRUCT_TYPE;
@@ -13559,7 +13639,8 @@
 					tmp2.set_index_token_from_str_literal<0>("struct");
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"struct"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
+					continue;
 					}
 				
 				// enum-specifier doesn't have a specific declaration mode
@@ -13699,100 +13780,7 @@
 				}
 			}
 			break;
-			case STRUCT_NAME:
-			{
-			const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
-			if (tmp)
-				{
-				assert(0<parse_tree::types->use_count(tmp));
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				}
-			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_union_as_struct.h
-					//! \test zcc/decl.C99/Error_union_as_struct3.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as union (C99 6.7.2.3p2)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
-				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_enum_as_struct.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_struct_forward_def.h
-			else _forward_declare_C_struct(src,i,invariant_decl_scanner);
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here (C99 6.7.2.3)
-				//! \test decl.C99/Warn_struct_forward_def_const.h
-				//! \test decl.C99/Warn_struct_forward_def_const2.h
-				//! \test decl.C99/Warn_struct_forward_def_const3.h
-				//! \test decl.C99/Warn_struct_forward_def_const4.h
-				//! \test decl.C99/Warn_struct_forward_def_volatile.h
-				//! \test decl.C99/Warn_struct_forward_def_volatile2.h
-				//! \test decl.C99/Warn_struct_forward_def_volatile3.h
-				//! \test decl.C99/Warn_struct_forward_def_volatile4.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile2.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile3.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile4.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile5.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile6.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile7.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile8.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile9.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile10.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile11.h
-				//! \test decl.C99/Warn_struct_forward_def_const_volatile12.h
-				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				if (tmp)
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_struct_forward_def.h
-					// remove from parse
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;					
-					}
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				i += 2;
-				continue;
-				}
-			else if (!tmp)
-				{	// used without at least forward-declaring
-					//! \bug needs test cases
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("used without at least forward-declaring");
-				zcc_errors.inc_error();
-				}
-			}
-			break;
+			case STRUCT_NAME: break;	/* already handled */
 			case UNION_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);



From zaimoni at mail.berlios.de  Mon Jan 10 20:46:57 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 10 Jan 2011 20:46:57 +0100
Subject: [Zcplusplus-commits] r574 - trunk
Message-ID: <20110110194658.67387480510@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-10 20:46:57 +0100 (Mon, 10 Jan 2011)
New Revision: 574

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
C anonymous union definitions: converge parsing towards standard

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-10 18:47:18 UTC (rev 573)
+++ trunk/CSupport.cpp	2011-01-10 19:46:57 UTC (rev 574)
@@ -13162,7 +13162,7 @@
 					}
 				}
 			//! \bug check for pre-existing typedefs if no types
-			if (0>=typecount || 0<pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)))
+			if (0>=typecount || 0<pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)))
 				goto reparse;
 			}
 
@@ -13171,7 +13171,56 @@
 				{
 				case UNION_NAME: break;
 				case UNION_NAMED_DEF: break;
-				case UNION_ANON_DEF: break;
+				case UNION_ANON_DEF:
+				{	// anonymous types cannot be matched
+				// tentatively forward-declare immediately
+				const type_system::type_index tmp = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_union,src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
+				assert(tmp);
+				assert(parse_tree::types->get_structdecl(tmp));
+				
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				tmp2.type_code.set_type(tmp);
+				tmp2.flags |= PARSE_UNION_TYPE;
+				}
+				_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+
+				// parse the union and upgrade it to a full definition
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp);
+				assert(tmp3);
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(tmp,tmp4);
+				assert(parse_tree::types->get_C_structdef(tmp));
+
+				if (semicolon_terminated_decl)
+					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \test decl.C99/Warn_union_anon_def_const.h
+					//! \test decl.C99/Warn_union_anon_def_const2.h
+					//! \test decl.C99/Warn_union_anon_def_volatile.h
+					//! \test decl.C99/Warn_union_anon_def_volatile2.h
+					//! \test decl.C99/Warn_union_anon_def_const_volatile.h
+					//! \test decl.C99/Warn_union_anon_def_const_volatile2.h
+					//! \test decl.C99/Warn_union_anon_def_const_volatile3.h
+					//! \test decl.C99/Warn_union_anon_def_const_volatile4.h
+					//! \test decl.C99/Warn_union_anon_def_const_volatile5.h
+					//! \test decl.C99/Warn_union_anon_def_const_volatile6.h
+					C99_flush_const_volatile_without_object(tmp2);
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_union.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("unreferenceable anonymous union declaration");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// remove from parse
+					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+					goto restart_master_loop;
+					}
+				goto reparse;
+				}
+//				break;
 				case STRUCT_NAME:
 				{
 				const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i+k].index_tokens[1].token.first);
@@ -13732,52 +13781,7 @@
 			}
 			break;
 			case STRUCT_NAMED_DEF: break;	/* already handled */
-			case UNION_ANON_DEF:
-			{	// anonymous types cannot be matched
-			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_union,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			assert(tmp2);
-			assert(parse_tree::types->get_structdecl(tmp2));
-
-			src.c_array<0>()[i].type_code.set_type(tmp2);
-			src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-
-			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
-			assert(parse_tree::types->get_C_structdef(tmp2));
-
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				//! \test decl.C99/Warn_union_anon_def_const.h
-				//! \test decl.C99/Warn_union_anon_def_const2.h
-				//! \test decl.C99/Warn_union_anon_def_volatile.h
-				//! \test decl.C99/Warn_union_anon_def_volatile2.h
-				//! \test decl.C99/Warn_union_anon_def_const_volatile.h
-				//! \test decl.C99/Warn_union_anon_def_const_volatile2.h
-				//! \test decl.C99/Warn_union_anon_def_const_volatile3.h
-				//! \test decl.C99/Warn_union_anon_def_const_volatile4.h
-				//! \test decl.C99/Warn_union_anon_def_const_volatile5.h
-				//! \test decl.C99/Warn_union_anon_def_const_volatile6.h
-				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-				//! \test zcc/decl.C99/Warn_inaccessible_union.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous union declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			}
-			break;
+			case UNION_ANON_DEF: break;	/* already handled */
 			case STRUCT_ANON_DEF: break;	/* already handled */
 			case ENUM_NAME: break;	/* already handled */
 			case ENUM_NAMED_DEF: break;	/* already handled */

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-10 18:47:18 UTC (rev 573)
+++ trunk/CSupport.cpp.in	2011-01-10 19:46:57 UTC (rev 574)
@@ -13306,7 +13306,7 @@
 					}
 				}
 			//! \bug check for pre-existing typedefs if no types
-			if (0>=typecount || 0<pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)))
+			if (0>=typecount || 0<pre_invariant_decl_scanner.count(STATIC_SIZE(C99_nontype_decl_specifier_list)))
 				goto reparse;
 			}
 
@@ -13315,7 +13315,56 @@
 				{
 				case UNION_NAME: break;
 				case UNION_NAMED_DEF: break;
-				case UNION_ANON_DEF: break;
+				case UNION_ANON_DEF:
+				{	// anonymous types cannot be matched
+				// tentatively forward-declare immediately
+				const type_system::type_index tmp = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_union,src.data<0>()[i+k].index_tokens[0].logical_line,src.data<0>()[i+k].index_tokens[0].src_filename);
+				assert(tmp);
+				assert(parse_tree::types->get_structdecl(tmp));
+				
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				tmp2.type_code.set_type(tmp);
+				tmp2.flags |= PARSE_UNION_TYPE;
+				}
+				_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+
+				// parse the union and upgrade it to a full definition
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp);
+				assert(tmp3);
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[0].logical_line,tmp2.index_tokens[0].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(tmp,tmp4);
+				assert(parse_tree::types->get_C_structdef(tmp));
+
+				if (semicolon_terminated_decl)
+					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \test decl.C99/Warn_union_anon_def_const.h
+					//! \test decl.C99/Warn_union_anon_def_const2.h
+					//! \test decl.C99/Warn_union_anon_def_volatile.h
+					//! \test decl.C99/Warn_union_anon_def_volatile2.h
+					//! \test decl.C99/Warn_union_anon_def_const_volatile.h
+					//! \test decl.C99/Warn_union_anon_def_const_volatile2.h
+					//! \test decl.C99/Warn_union_anon_def_const_volatile3.h
+					//! \test decl.C99/Warn_union_anon_def_const_volatile4.h
+					//! \test decl.C99/Warn_union_anon_def_const_volatile5.h
+					//! \test decl.C99/Warn_union_anon_def_const_volatile6.h
+					C99_flush_const_volatile_without_object(tmp2);
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_union.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("unreferenceable anonymous union declaration");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// remove from parse
+					src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+					goto restart_master_loop;
+					}
+				goto reparse;
+				}
+//				break;
 				case STRUCT_NAME:
 				{
 				const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i+k].index_tokens[1].token.first);
@@ -13876,52 +13925,7 @@
 			}
 			break;
 			case STRUCT_NAMED_DEF: break;	/* already handled */
-			case UNION_ANON_DEF:
-			{	// anonymous types cannot be matched
-			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_union,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			assert(tmp2);
-			assert(parse_tree::types->get_structdecl(tmp2));
-
-			src.c_array<0>()[i].type_code.set_type(tmp2);
-			src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-
-			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
-			assert(parse_tree::types->get_C_structdef(tmp2));
-
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				//! \test decl.C99/Warn_union_anon_def_const.h
-				//! \test decl.C99/Warn_union_anon_def_const2.h
-				//! \test decl.C99/Warn_union_anon_def_volatile.h
-				//! \test decl.C99/Warn_union_anon_def_volatile2.h
-				//! \test decl.C99/Warn_union_anon_def_const_volatile.h
-				//! \test decl.C99/Warn_union_anon_def_const_volatile2.h
-				//! \test decl.C99/Warn_union_anon_def_const_volatile3.h
-				//! \test decl.C99/Warn_union_anon_def_const_volatile4.h
-				//! \test decl.C99/Warn_union_anon_def_const_volatile5.h
-				//! \test decl.C99/Warn_union_anon_def_const_volatile6.h
-				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-				//! \test zcc/decl.C99/Warn_inaccessible_union.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous union declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			}
-			break;
+			case UNION_ANON_DEF: break;	/* already handled */
 			case STRUCT_ANON_DEF: break;	/* already handled */
 			case ENUM_NAME: break;	/* already handled */
 			case ENUM_NAMED_DEF: break;	/* already handled */



From zaimoni at mail.berlios.de  Tue Jan 11 01:34:22 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 11 Jan 2011 01:34:22 +0100
Subject: [Zcplusplus-commits] r575 - trunk
Message-ID: <20110111003422.C4FEC480514@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-11 01:34:22 +0100 (Tue, 11 Jan 2011)
New Revision: 575

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
C named union definitions: converge parsing towards standard

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-10 19:46:57 UTC (rev 574)
+++ trunk/CSupport.cpp	2011-01-11 00:34:22 UTC (rev 575)
@@ -13038,6 +13038,24 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 }
 
+static void _forward_declare_C_union_preparsed(parse_tree& src, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	parse_tree& tmp = src.c_array<0>()[i];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl(tmp.index_tokens[1].token.first,union_struct_decl::decl_union,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
+#else
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(tmp.index_tokens[1].token.first,union_struct_decl::decl_union,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_union(tmp.index_tokens[1].token.first));
+	assert(parse_tree::types->get_id_union(tmp.index_tokens[1].token.first)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_UNION_TYPE;
+	invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
+	_condense_const_volatile_onto_type_preparsed(src,i,k,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+}
+
 static void _forward_declare_C_struct_preparsed(parse_tree& src, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i];
@@ -13170,7 +13188,104 @@
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(C99_nontype_decl_specifier_list))
 				{
 				case UNION_NAME: break;
-				case UNION_NAMED_DEF: break;
+				case UNION_NAMED_DEF:
+				{	// can only define once
+				const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i+k].index_tokens[1].token.first);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (tmp)
+					{
+					assert(0<parse_tree::types->use_count(tmp));
+					if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
+						{	//! \test zcc/decl.C99/Error_union_multidef.h
+						message_header(tmp2.index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("'union ");
+						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INFORM("' already defined (C99 6.7.2.3p1)");
+						message_header(fatal_def->_decl);
+						INFORM("prior definition here");
+						zcc_errors.inc_error();
+						// reduce to named-specifier
+						tmp2.DeleteIdx<2>(0);
+						assert(is_C99_named_specifier(tmp2,"union"));
+						goto rescan;
+						}
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_UNION_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+					}
+				// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_struct_as_union2.h
+						//! \test zcc/decl.C99/Error_struct_as_union4.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as struct (C99 6.7.2.3p2)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("struct");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"struct"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
+					continue;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_enum_as_union.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_union_forward_def.h
+				else _forward_declare_C_union_preparsed(src,i,k,pre_invariant_decl_scanner);
+				}
+				// parse the union and upgrade it to a full definition
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				const type_system::type_index vr_tmp = tmp2.type_code.base_type_index;
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
+				assert(tmp3);
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+				assert(parse_tree::types->get_id_union(tmp2.index_tokens[1].token.first)==vr_tmp);
+				assert(parse_tree::types->get_C_structdef(vr_tmp));
+				if (semicolon_terminated_decl)
+					{	// no objects declared, trigger the const/volatile warnings
+					//! \test decl.C99/Warn_union_def_const.h
+					//! \test decl.C99/Warn_union_def_const2.h
+					//! \test decl.C99/Warn_union_def_volatile.h
+					//! \test decl.C99/Warn_union_def_volatile2.h
+					//! \test decl.C99/Warn_union_def_const_volatile.h
+					//! \test decl.C99/Warn_union_def_const_volatile2.h
+					//! \test decl.C99/Warn_union_def_const_volatile3.h
+					//! \test decl.C99/Warn_union_def_const_volatile4.h
+					//! \test decl.C99/Warn_union_def_const_volatile5.h
+					//! \test decl.C99/Warn_union_def_const_volatile6.h
+					C99_flush_const_volatile_without_object(tmp2);
+					// accept definition
+					//! \test zcc/decl.C99/Pass_union_forward_def.h
+					};
+				goto reparse;
+				}
+//				break;
 				case UNION_ANON_DEF:
 				{	// anonymous types cannot be matched
 				// tentatively forward-declare immediately
@@ -13686,100 +13801,7 @@
 			}
 			break;
 			case STRUCT_NAME: break;	/* already handled */
-			case UNION_NAMED_DEF:
-			{	// can only define once
-			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);
-			if (tmp)
-				{
-				assert(0<parse_tree::types->use_count(tmp));
-				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
-					{	//! \test zcc/decl.C99/Error_union_multidef.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'union ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' already defined (C99 6.7.2.3p1)");
-					message_header(fatal_def->_decl);
-					INFORM("prior definition here");
-					zcc_errors.inc_error();
-					// reduce to named-specifier
-					src.c_array<0>()[i].DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-					goto reparse;
-					}
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				}
-			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_struct_as_union2.h
-					//! \test zcc/decl.C99/Error_struct_as_union4.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as struct (C99 6.7.2.3p2)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_enum_as_union.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_union_forward_def.h
-			else _forward_declare_C_union(src,i,invariant_decl_scanner);
-			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(parse_tree::types->get_C_structdef(vr_tmp));
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// no objects declared, trigger the const/volatile warnings
-				//! \test decl.C99/Warn_union_def_const.h
-				//! \test decl.C99/Warn_union_def_const2.h
-				//! \test decl.C99/Warn_union_def_volatile.h
-				//! \test decl.C99/Warn_union_def_volatile2.h
-				//! \test decl.C99/Warn_union_def_const_volatile.h
-				//! \test decl.C99/Warn_union_def_const_volatile2.h
-				//! \test decl.C99/Warn_union_def_const_volatile3.h
-				//! \test decl.C99/Warn_union_def_const_volatile4.h
-				//! \test decl.C99/Warn_union_def_const_volatile5.h
-				//! \test decl.C99/Warn_union_def_const_volatile6.h
-				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				// accept definition
-				//! \test zcc/decl.C99/Pass_union_forward_def.h
-				i += 2;
-				continue;
-				};
-			}
-			break;
+			case UNION_NAMED_DEF: break;	/* already handled */
 			case STRUCT_NAMED_DEF: break;	/* already handled */
 			case UNION_ANON_DEF: break;	/* already handled */
 			case STRUCT_ANON_DEF: break;	/* already handled */

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-10 19:46:57 UTC (rev 574)
+++ trunk/CSupport.cpp.in	2011-01-11 00:34:22 UTC (rev 575)
@@ -13182,6 +13182,24 @@
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 }
 
+static void _forward_declare_C_union_preparsed(parse_tree& src, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	parse_tree& tmp = src.c_array<0>()[i];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl(tmp.index_tokens[1].token.first,union_struct_decl::decl_union,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
+#else
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(tmp.index_tokens[1].token.first,union_struct_decl::decl_union,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_union(tmp.index_tokens[1].token.first));
+	assert(parse_tree::types->get_id_union(tmp.index_tokens[1].token.first)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_UNION_TYPE;
+	invariant_decl_scanner.reclassify(k,STATIC_SIZE(C99_nontype_decl_specifier_list));
+	_condense_const_volatile_onto_type_preparsed(src,i,k,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+}
+
 static void _forward_declare_C_struct_preparsed(parse_tree& src, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i];
@@ -13314,7 +13332,104 @@
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(C99_nontype_decl_specifier_list))
 				{
 				case UNION_NAME: break;
-				case UNION_NAMED_DEF: break;
+				case UNION_NAMED_DEF:
+				{	// can only define once
+				const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i+k].index_tokens[1].token.first);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				if (tmp)
+					{
+					assert(0<parse_tree::types->use_count(tmp));
+					if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
+						{	//! \test zcc/decl.C99/Error_union_multidef.h
+						message_header(tmp2.index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("'union ");
+						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INFORM("' already defined (C99 6.7.2.3p1)");
+						message_header(fatal_def->_decl);
+						INFORM("prior definition here");
+						zcc_errors.inc_error();
+						// reduce to named-specifier
+						tmp2.DeleteIdx<2>(0);
+						assert(is_C99_named_specifier(tmp2,"union"));
+						goto rescan;
+						}
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_UNION_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+					}
+				// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_struct_as_union2.h
+						//! \test zcc/decl.C99/Error_struct_as_union4.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as struct (C99 6.7.2.3p2)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("struct");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"struct"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
+					continue;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_enum_as_union.h
+					message_header(tmp2.index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					tmp2.DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_union_forward_def.h
+				else _forward_declare_C_union_preparsed(src,i,k,pre_invariant_decl_scanner);
+				}
+				// parse the union and upgrade it to a full definition
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
+				const type_system::type_index vr_tmp = tmp2.type_code.base_type_index;
+				const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
+				assert(tmp3);
+				C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
+				//! \todo record field structure, etc.
+				parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+				assert(parse_tree::types->get_id_union(tmp2.index_tokens[1].token.first)==vr_tmp);
+				assert(parse_tree::types->get_C_structdef(vr_tmp));
+				if (semicolon_terminated_decl)
+					{	// no objects declared, trigger the const/volatile warnings
+					//! \test decl.C99/Warn_union_def_const.h
+					//! \test decl.C99/Warn_union_def_const2.h
+					//! \test decl.C99/Warn_union_def_volatile.h
+					//! \test decl.C99/Warn_union_def_volatile2.h
+					//! \test decl.C99/Warn_union_def_const_volatile.h
+					//! \test decl.C99/Warn_union_def_const_volatile2.h
+					//! \test decl.C99/Warn_union_def_const_volatile3.h
+					//! \test decl.C99/Warn_union_def_const_volatile4.h
+					//! \test decl.C99/Warn_union_def_const_volatile5.h
+					//! \test decl.C99/Warn_union_def_const_volatile6.h
+					C99_flush_const_volatile_without_object(tmp2);
+					// accept definition
+					//! \test zcc/decl.C99/Pass_union_forward_def.h
+					};
+				goto reparse;
+				}
+//				break;
 				case UNION_ANON_DEF:
 				{	// anonymous types cannot be matched
 				// tentatively forward-declare immediately
@@ -13830,100 +13945,7 @@
 			}
 			break;
 			case STRUCT_NAME: break;	/* already handled */
-			case UNION_NAMED_DEF:
-			{	// can only define once
-			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);
-			if (tmp)
-				{
-				assert(0<parse_tree::types->use_count(tmp));
-				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
-					{	//! \test zcc/decl.C99/Error_union_multidef.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'union ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' already defined (C99 6.7.2.3p1)");
-					message_header(fatal_def->_decl);
-					INFORM("prior definition here");
-					zcc_errors.inc_error();
-					// reduce to named-specifier
-					src.c_array<0>()[i].DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-					goto reparse;
-					}
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				}
-			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_struct_as_union2.h
-					//! \test zcc/decl.C99/Error_struct_as_union4.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as struct (C99 6.7.2.3p2)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_enum_as_union.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				src.c_array<0>()[i].DeleteIdx<2>(0);
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_union_forward_def.h
-			else _forward_declare_C_union(src,i,invariant_decl_scanner);
-			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
-			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
-			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			//! \todo record field structure, etc.
-			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(parse_tree::types->get_C_structdef(vr_tmp));
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// no objects declared, trigger the const/volatile warnings
-				//! \test decl.C99/Warn_union_def_const.h
-				//! \test decl.C99/Warn_union_def_const2.h
-				//! \test decl.C99/Warn_union_def_volatile.h
-				//! \test decl.C99/Warn_union_def_volatile2.h
-				//! \test decl.C99/Warn_union_def_const_volatile.h
-				//! \test decl.C99/Warn_union_def_const_volatile2.h
-				//! \test decl.C99/Warn_union_def_const_volatile3.h
-				//! \test decl.C99/Warn_union_def_const_volatile4.h
-				//! \test decl.C99/Warn_union_def_const_volatile5.h
-				//! \test decl.C99/Warn_union_def_const_volatile6.h
-				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				// accept definition
-				//! \test zcc/decl.C99/Pass_union_forward_def.h
-				i += 2;
-				continue;
-				};
-			}
-			break;
+			case UNION_NAMED_DEF: break;	/* already handled */
 			case STRUCT_NAMED_DEF: break;	/* already handled */
 			case UNION_ANON_DEF: break;	/* already handled */
 			case STRUCT_ANON_DEF: break;	/* already handled */



From zaimoni at mail.berlios.de  Tue Jan 11 03:53:16 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 11 Jan 2011 03:53:16 +0100
Subject: [Zcplusplus-commits] r576 - trunk
Message-ID: <20110111025317.559DA480514@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-11 03:53:16 +0100 (Tue, 11 Jan 2011)
New Revision: 576

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
C named union specifies: converge parsing towards standard

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-11 00:34:22 UTC (rev 575)
+++ trunk/CSupport.cpp	2011-01-11 02:53:16 UTC (rev 576)
@@ -13021,23 +13021,6 @@
 	return SIZE_MAX;
 }	
 
-static void _forward_declare_C_union(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
-{
-	parse_tree& tmp = src.c_array<0>()[i];
-#ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
-#else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-	assert(tmp2);
-	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-	assert(parse_tree::types->get_structdecl(tmp2));
-	tmp.type_code.set_type(tmp2);
-#endif
-	tmp.flags |= PARSE_UNION_TYPE;
-	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-}
-
 static void _forward_declare_C_union_preparsed(parse_tree& src, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i];
@@ -13112,7 +13095,6 @@
 		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// pre-scan for declaration-like items
 		{
-rescan:
 		kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1+9,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(C99_type_or_invariant_decl_specifier_or_tag);
 		{	// wouldn't work for unnamed function parameters
 		const size_t strict_ub = src.size<0>()-i;
@@ -13187,7 +13169,101 @@
 			size_t k = 0;
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(C99_nontype_decl_specifier_list))
 				{
-				case UNION_NAME: break;
+				case UNION_NAME:
+				{
+				const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i+k].index_tokens[1].token.first);
+				if (tmp)
+					{
+					assert(0<parse_tree::types->use_count(tmp));
+					src.c_array<0>()[i+k].type_code.set_type(tmp);
+					src.c_array<0>()[i+k].flags |= PARSE_UNION_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+					}
+				// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i+k].index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_struct_as_union.h
+						//! \test zcc/decl.C99/Error_struct_as_union3.h
+					message_header(src.data<0>()[i+k].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(src.data<0>()[i+k].index_tokens[1].token.first);
+					INFORM(" declared as struct (C99 6.7.2.3p2)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					src.c_array<0>()[i+k].set_index_token_from_str_literal<0>("struct");
+					assert(is_C99_named_specifier(src.data<0>()[i+k],"struct"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
+					continue;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i+k].index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_enum_as_union.h
+					message_header(src.data<0>()[i+k].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(src.data<0>()[i+k].index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					src.c_array<0>()[i+k].set_index_token_from_str_literal<0>("enum");
+					assert(is_C99_named_specifier(src.data<0>()[i+k],"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_union_forward_def.h
+				else _forward_declare_C_union_preparsed(src,i,k,pre_invariant_decl_scanner);
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here (C99 6.7.2.3)
+					//! \test decl.C99/Warn_union_forward_def_const.h
+					//! \test decl.C99/Warn_union_forward_def_const2.h
+					//! \test decl.C99/Warn_union_forward_def_const3.h
+					//! \test decl.C99/Warn_union_forward_def_const4.h
+					//! \test decl.C99/Warn_union_forward_def_volatile.h
+					//! \test decl.C99/Warn_union_forward_def_volatile2.h
+					//! \test decl.C99/Warn_union_forward_def_volatile3.h
+					//! \test decl.C99/Warn_union_forward_def_volatile4.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile2.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile3.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile4.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile5.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile6.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile7.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile8.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile9.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile10.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile11.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile12.h
+					C99_flush_const_volatile_without_object(src.c_array<0>()[i+k]);
+					if (tmp)
+						{	// but if already (forward-)declared then this is a no-op
+							// think this is common enough to not warrant OAOO/DRY treatment
+						//! \test zcc/decl.C99/Pass_union_forward_def.h
+						// remove from parse
+						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						assert(0<parse_tree::types->use_count(tmp));
+						goto restart_master_loop;
+						}
+					// forward-declare
+					//! \test zcc/decl.C99/Pass_union_forward_def.h
+					}
+				else if (!tmp)
+					{	// used without at least forward-declaring
+						//! \bug needs test cases
+					message_header(src.data<0>()[i+k].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("used without at least forward-declaring");
+					zcc_errors.inc_error();
+					}
+				goto reparse;
+				}
+//				break;
 				case UNION_NAMED_DEF:
 				{	// can only define once
 				const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i+k].index_tokens[1].token.first);
@@ -13209,7 +13285,8 @@
 						// reduce to named-specifier
 						tmp2.DeleteIdx<2>(0);
 						assert(is_C99_named_specifier(tmp2,"union"));
-						goto rescan;
+						pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME);
+						continue;
 						}
 					tmp2.type_code.set_type(tmp);
 					tmp2.flags |= PARSE_UNION_TYPE;
@@ -13364,7 +13441,8 @@
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("union");
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
 					{	//! \test zcc/decl.C99/Error_enum_as_struct.h
@@ -13417,6 +13495,7 @@
 						//! \test zcc/decl.C99/Pass_struct_forward_def.h
 						// remove from parse
 						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						assert(0<parse_tree::types->use_count(tmp));
 						goto restart_master_loop;
 						}
 					// forward-declare
@@ -13478,7 +13557,8 @@
 					tmp2.set_index_token_from_str_literal<0>("union");
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
 					{	//! \test zcc/decl.C99/Error_enum_as_struct2.h
@@ -13641,7 +13721,8 @@
 					tmp2.set_index_token_from_str_literal<0>("union");
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(tmp2.index_tokens[1].token.first))
 					{	//! \test zcc/decl.C99/Error_struct_as_enum.h
@@ -13705,101 +13786,7 @@
 #ifndef NDEBUG
 			default: _fatal_code("return value of notice_C99_tag out of range",3);
 #endif
-			case UNION_NAME:
-			{
-			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);
-			if (tmp)
-				{
-				assert(0<parse_tree::types->use_count(tmp));
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				}
-			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_struct_as_union.h
-					//! \test zcc/decl.C99/Error_struct_as_union3.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as struct (C99 6.7.2.3p2)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
-				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_enum_as_union.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_union_forward_def.h
-			else _forward_declare_C_union(src,i,invariant_decl_scanner);
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here (C99 6.7.2.3)
-				//! \test decl.C99/Warn_union_forward_def_const.h
-				//! \test decl.C99/Warn_union_forward_def_const2.h
-				//! \test decl.C99/Warn_union_forward_def_const3.h
-				//! \test decl.C99/Warn_union_forward_def_const4.h
-				//! \test decl.C99/Warn_union_forward_def_volatile.h
-				//! \test decl.C99/Warn_union_forward_def_volatile2.h
-				//! \test decl.C99/Warn_union_forward_def_volatile3.h
-				//! \test decl.C99/Warn_union_forward_def_volatile4.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile2.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile3.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile4.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile5.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile6.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile7.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile8.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile9.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile10.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile11.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile12.h
-				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				if (tmp)
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_union_forward_def.h
-					// remove from parse
-					src.DeleteNSlotsAt<0>(2,i);
-					assert(0<parse_tree::types->use_count(tmp));
-					continue;					
-					}
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_union_forward_def.h
-				i += 2;
-				continue;
-				}
-			else if (!tmp)
-				{	// used without at least forward-declaring
-					//! \bug needs test cases
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("used without at least forward-declaring");
-				zcc_errors.inc_error();
-				}
-			}
-			break;
+			case UNION_NAME: break;	/* already handled */
 			case STRUCT_NAME: break;	/* already handled */
 			case UNION_NAMED_DEF: break;	/* already handled */
 			case STRUCT_NAMED_DEF: break;	/* already handled */
@@ -14400,6 +14387,7 @@
 						//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 						// remove from parse
 						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						assert(0<parse_tree::types->use_count(tmp));
 						goto restart_master_loop;
 						};
 					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
@@ -14651,6 +14639,7 @@
 						//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 						// remove from parse
 						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						assert(0<parse_tree::types->use_count(tmp));
 						goto restart_master_loop;
 						}
 					// forward-declare
@@ -14897,6 +14886,7 @@
 						//! \test zcc/decl.C99/Pass_class_forward_def.hpp
 						// remove from parse
 						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						assert(0<parse_tree::types->use_count(tmp));
 						goto restart_master_loop;
 						}
 					// forward-declare

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-11 00:34:22 UTC (rev 575)
+++ trunk/CSupport.cpp.in	2011-01-11 02:53:16 UTC (rev 576)
@@ -13165,23 +13165,6 @@
 	return SIZE_MAX;
 }	
 
-static void _forward_declare_C_union(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
-{
-	parse_tree& tmp = src.c_array<0>()[i];
-#ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
-#else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-	assert(tmp2);
-	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-	assert(parse_tree::types->get_structdecl(tmp2));
-	tmp.type_code.set_type(tmp2);
-#endif
-	tmp.flags |= PARSE_UNION_TYPE;
-	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-}
-
 static void _forward_declare_C_union_preparsed(parse_tree& src, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
 	parse_tree& tmp = src.c_array<0>()[i];
@@ -13256,7 +13239,6 @@
 		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// pre-scan for declaration-like items
 		{
-rescan:
 		kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1+9,size_t (*)(const parse_tree&)> pre_invariant_decl_scanner(C99_type_or_invariant_decl_specifier_or_tag);
 		{	// wouldn't work for unnamed function parameters
 		const size_t strict_ub = src.size<0>()-i;
@@ -13331,7 +13313,101 @@
 			size_t k = 0;
 			do	switch(pre_invariant_decl_scanner[k]-STATIC_SIZE(C99_nontype_decl_specifier_list))
 				{
-				case UNION_NAME: break;
+				case UNION_NAME:
+				{
+				const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i+k].index_tokens[1].token.first);
+				if (tmp)
+					{
+					assert(0<parse_tree::types->use_count(tmp));
+					src.c_array<0>()[i+k].type_code.set_type(tmp);
+					src.c_array<0>()[i+k].flags |= PARSE_UNION_TYPE;
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+					}
+				// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i+k].index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_struct_as_union.h
+						//! \test zcc/decl.C99/Error_struct_as_union3.h
+					message_header(src.data<0>()[i+k].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(src.data<0>()[i+k].index_tokens[1].token.first);
+					INFORM(" declared as struct (C99 6.7.2.3p2)");
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					src.c_array<0>()[i+k].set_index_token_from_str_literal<0>("struct");
+					assert(is_C99_named_specifier(src.data<0>()[i+k],"struct"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
+					continue;
+					}
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i+k].index_tokens[1].token.first))
+					{	//! \test zcc/decl.C99/Error_enum_as_union.h
+					message_header(src.data<0>()[i+k].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("union ");
+					INC_INFORM(src.data<0>()[i+k].index_tokens[1].token.first);
+					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
+					assert(tmp3);
+					message_header(*tmp3);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					src.c_array<0>()[i+k].set_index_token_from_str_literal<0>("enum");
+					assert(is_C99_named_specifier(src.data<0>()[i+k],"enum"));
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
+					continue;
+					}
+				// tentatively forward-declare immediately
+				//! \test zcc/decl.C99/Pass_union_forward_def.h
+				else _forward_declare_C_union_preparsed(src,i,k,pre_invariant_decl_scanner);
+				if (semicolon_terminated_decl)
+					{	// check for forward-declaration here (C99 6.7.2.3)
+					//! \test decl.C99/Warn_union_forward_def_const.h
+					//! \test decl.C99/Warn_union_forward_def_const2.h
+					//! \test decl.C99/Warn_union_forward_def_const3.h
+					//! \test decl.C99/Warn_union_forward_def_const4.h
+					//! \test decl.C99/Warn_union_forward_def_volatile.h
+					//! \test decl.C99/Warn_union_forward_def_volatile2.h
+					//! \test decl.C99/Warn_union_forward_def_volatile3.h
+					//! \test decl.C99/Warn_union_forward_def_volatile4.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile2.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile3.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile4.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile5.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile6.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile7.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile8.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile9.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile10.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile11.h
+					//! \test decl.C99/Warn_union_forward_def_const_volatile12.h
+					C99_flush_const_volatile_without_object(src.c_array<0>()[i+k]);
+					if (tmp)
+						{	// but if already (forward-)declared then this is a no-op
+							// think this is common enough to not warrant OAOO/DRY treatment
+						//! \test zcc/decl.C99/Pass_union_forward_def.h
+						// remove from parse
+						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						assert(0<parse_tree::types->use_count(tmp));
+						goto restart_master_loop;
+						}
+					// forward-declare
+					//! \test zcc/decl.C99/Pass_union_forward_def.h
+					}
+				else if (!tmp)
+					{	// used without at least forward-declaring
+						//! \bug needs test cases
+					message_header(src.data<0>()[i+k].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("used without at least forward-declaring");
+					zcc_errors.inc_error();
+					}
+				goto reparse;
+				}
+//				break;
 				case UNION_NAMED_DEF:
 				{	// can only define once
 				const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i+k].index_tokens[1].token.first);
@@ -13353,7 +13429,8 @@
 						// reduce to named-specifier
 						tmp2.DeleteIdx<2>(0);
 						assert(is_C99_named_specifier(tmp2,"union"));
-						goto rescan;
+						pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME);
+						continue;
 						}
 					tmp2.type_code.set_type(tmp);
 					tmp2.flags |= PARSE_UNION_TYPE;
@@ -13508,7 +13585,8 @@
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("union");
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
 					{	//! \test zcc/decl.C99/Error_enum_as_struct.h
@@ -13561,6 +13639,7 @@
 						//! \test zcc/decl.C99/Pass_struct_forward_def.h
 						// remove from parse
 						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						assert(0<parse_tree::types->use_count(tmp));
 						goto restart_master_loop;
 						}
 					// forward-declare
@@ -13622,7 +13701,8 @@
 					tmp2.set_index_token_from_str_literal<0>("union");
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
 					{	//! \test zcc/decl.C99/Error_enum_as_struct2.h
@@ -13785,7 +13865,8 @@
 					tmp2.set_index_token_from_str_literal<0>("union");
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"union"));
-					goto rescan;
+					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME);
+					continue;
 					}
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(tmp2.index_tokens[1].token.first))
 					{	//! \test zcc/decl.C99/Error_struct_as_enum.h
@@ -13849,101 +13930,7 @@
 #ifndef NDEBUG
 			default: _fatal_code("return value of notice_C99_tag out of range",3);
 #endif
-			case UNION_NAME:
-			{
-			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);
-			if (tmp)
-				{
-				assert(0<parse_tree::types->use_count(tmp));
-				src.c_array<0>()[i].type_code.set_type(tmp);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				}
-			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_struct_as_union.h
-					//! \test zcc/decl.C99/Error_struct_as_union3.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as struct (C99 6.7.2.3p2)");
-				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
-				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-				goto reparse;
-				}
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_enum_as_union.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
-				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
-				goto reparse;
-				}
-			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_union_forward_def.h
-			else _forward_declare_C_union(src,i,invariant_decl_scanner);
-			if (   1<src.size<0>()-i
-				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// check for forward-declaration here (C99 6.7.2.3)
-				//! \test decl.C99/Warn_union_forward_def_const.h
-				//! \test decl.C99/Warn_union_forward_def_const2.h
-				//! \test decl.C99/Warn_union_forward_def_const3.h
-				//! \test decl.C99/Warn_union_forward_def_const4.h
-				//! \test decl.C99/Warn_union_forward_def_volatile.h
-				//! \test decl.C99/Warn_union_forward_def_volatile2.h
-				//! \test decl.C99/Warn_union_forward_def_volatile3.h
-				//! \test decl.C99/Warn_union_forward_def_volatile4.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile2.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile3.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile4.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile5.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile6.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile7.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile8.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile9.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile10.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile11.h
-				//! \test decl.C99/Warn_union_forward_def_const_volatile12.h
-				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
-				if (tmp)
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_union_forward_def.h
-					// remove from parse
-					src.DeleteNSlotsAt<0>(2,i);
-					assert(0<parse_tree::types->use_count(tmp));
-					continue;					
-					}
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_union_forward_def.h
-				i += 2;
-				continue;
-				}
-			else if (!tmp)
-				{	// used without at least forward-declaring
-					//! \bug needs test cases
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("used without at least forward-declaring");
-				zcc_errors.inc_error();
-				}
-			}
-			break;
+			case UNION_NAME: break;	/* already handled */
 			case STRUCT_NAME: break;	/* already handled */
 			case UNION_NAMED_DEF: break;	/* already handled */
 			case STRUCT_NAMED_DEF: break;	/* already handled */
@@ -14544,6 +14531,7 @@
 						//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 						// remove from parse
 						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						assert(0<parse_tree::types->use_count(tmp));
 						goto restart_master_loop;
 						};
 					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
@@ -14795,6 +14783,7 @@
 						//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 						// remove from parse
 						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						assert(0<parse_tree::types->use_count(tmp));
 						goto restart_master_loop;
 						}
 					// forward-declare
@@ -15041,6 +15030,7 @@
 						//! \test zcc/decl.C99/Pass_class_forward_def.hpp
 						// remove from parse
 						src.DeleteNSlotsAt<0>(1+pre_invariant_decl_scanner.size(),i);
+						assert(0<parse_tree::types->use_count(tmp));
 						goto restart_master_loop;
 						}
 					// forward-declare



From zaimoni at mail.berlios.de  Tue Jan 11 04:04:29 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 11 Jan 2011 04:04:29 +0100
Subject: [Zcplusplus-commits] r577 - trunk
Message-ID: <20110111030430.4EC5D480514@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-11 04:04:29 +0100 (Tue, 11 Jan 2011)
New Revision: 577

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
remove morally dead switch; proper use of tmp2 variable

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-11 02:53:16 UTC (rev 576)
+++ trunk/CSupport.cpp	2011-01-11 03:04:29 UTC (rev 577)
@@ -13172,52 +13172,56 @@
 				case UNION_NAME:
 				{
 				const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i+k].index_tokens[1].token.first);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
 				if (tmp)
 					{
 					assert(0<parse_tree::types->use_count(tmp));
-					src.c_array<0>()[i+k].type_code.set_type(tmp);
-					src.c_array<0>()[i+k].flags |= PARSE_UNION_TYPE;
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_UNION_TYPE;
 					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 					}
 				// C1X 6.7.2.3p2 states that conflicting enum or struct must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i+k].index_tokens[1].token.first))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(tmp2.index_tokens[1].token.first))
 					{	//! \test zcc/decl.C99/Error_struct_as_union.h
 						//! \test zcc/decl.C99/Error_struct_as_union3.h
-					message_header(src.data<0>()[i+k].index_tokens[0]);
+					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(src.data<0>()[i+k].index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1].token.first);
 					INFORM(" declared as struct (C99 6.7.2.3p2)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					src.c_array<0>()[i+k].set_index_token_from_str_literal<0>("struct");
-					assert(is_C99_named_specifier(src.data<0>()[i+k],"struct"));
+					tmp2.set_index_token_from_str_literal<0>("struct");
+					assert(is_C99_named_specifier(tmp2,"struct"));
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i+k].index_tokens[1].token.first))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
 					{	//! \test zcc/decl.C99/Error_enum_as_union.h
-					message_header(src.data<0>()[i+k].index_tokens[0]);
+					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(src.data<0>()[i+k].index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1].token.first);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					src.c_array<0>()[i+k].set_index_token_from_str_literal<0>("enum");
-					assert(is_C99_named_specifier(src.data<0>()[i+k],"enum"));
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					assert(is_C99_named_specifier(tmp2,"enum"));
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
 					continue;
 					}
 				// tentatively forward-declare immediately
 				//! \test zcc/decl.C99/Pass_union_forward_def.h
 				else _forward_declare_C_union_preparsed(src,i,k,pre_invariant_decl_scanner);
+				}
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
 				if (semicolon_terminated_decl)
 					{	// check for forward-declaration here (C99 6.7.2.3)
 					//! \test decl.C99/Warn_union_forward_def_const.h
@@ -13240,7 +13244,7 @@
 					//! \test decl.C99/Warn_union_forward_def_const_volatile10.h
 					//! \test decl.C99/Warn_union_forward_def_const_volatile11.h
 					//! \test decl.C99/Warn_union_forward_def_const_volatile12.h
-					C99_flush_const_volatile_without_object(src.c_array<0>()[i+k]);
+					C99_flush_const_volatile_without_object(tmp2);
 					if (tmp)
 						{	// but if already (forward-)declared then this is a no-op
 							// think this is common enough to not warrant OAOO/DRY treatment
@@ -13256,7 +13260,7 @@
 				else if (!tmp)
 					{	// used without at least forward-declaring
 						//! \bug needs test cases
-					message_header(src.data<0>()[i+k].index_tokens[0]);
+					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INFORM("used without at least forward-declaring");
 					zcc_errors.inc_error();
@@ -13777,27 +13781,7 @@
 			};
 		}
 		// check naked declarations first
-reparse:
-		const int tag_type = notice_C99_tag(src.data<0>()[i]);
-		if (tag_type)
-			{
-			switch(tag_type)
-			{	//! \todo deal with indentation violations later
-#ifndef NDEBUG
-			default: _fatal_code("return value of notice_C99_tag out of range",3);
-#endif
-			case UNION_NAME: break;	/* already handled */
-			case STRUCT_NAME: break;	/* already handled */
-			case UNION_NAMED_DEF: break;	/* already handled */
-			case STRUCT_NAMED_DEF: break;	/* already handled */
-			case UNION_ANON_DEF: break;	/* already handled */
-			case STRUCT_ANON_DEF: break;	/* already handled */
-			case ENUM_NAME: break;	/* already handled */
-			case ENUM_NAMED_DEF: break;	/* already handled */
-			case ENUM_ANON_DEF: break;	/* already handled */
-			}
-			}
-			
+reparse:			
 		// general declaration scanner 
 		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
 		// intercept declarations as follows

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-11 02:53:16 UTC (rev 576)
+++ trunk/CSupport.cpp.in	2011-01-11 03:04:29 UTC (rev 577)
@@ -13316,52 +13316,56 @@
 				case UNION_NAME:
 				{
 				const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i+k].index_tokens[1].token.first);
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
 				if (tmp)
 					{
 					assert(0<parse_tree::types->use_count(tmp));
-					src.c_array<0>()[i+k].type_code.set_type(tmp);
-					src.c_array<0>()[i+k].flags |= PARSE_UNION_TYPE;
+					tmp2.type_code.set_type(tmp);
+					tmp2.flags |= PARSE_UNION_TYPE;
 					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 					}
 				// C1X 6.7.2.3p2 states that conflicting enum or struct must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i+k].index_tokens[1].token.first))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(tmp2.index_tokens[1].token.first))
 					{	//! \test zcc/decl.C99/Error_struct_as_union.h
 						//! \test zcc/decl.C99/Error_struct_as_union3.h
-					message_header(src.data<0>()[i+k].index_tokens[0]);
+					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(src.data<0>()[i+k].index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1].token.first);
 					INFORM(" declared as struct (C99 6.7.2.3p2)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					src.c_array<0>()[i+k].set_index_token_from_str_literal<0>("struct");
-					assert(is_C99_named_specifier(src.data<0>()[i+k],"struct"));
+					tmp2.set_index_token_from_str_literal<0>("struct");
+					assert(is_C99_named_specifier(tmp2,"struct"));
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i+k].index_tokens[1].token.first))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(tmp2.index_tokens[1].token.first))
 					{	//! \test zcc/decl.C99/Error_enum_as_union.h
-					message_header(src.data<0>()[i+k].index_tokens[0]);
+					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(src.data<0>()[i+k].index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1].token.first);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					src.c_array<0>()[i+k].set_index_token_from_str_literal<0>("enum");
-					assert(is_C99_named_specifier(src.data<0>()[i+k],"enum"));
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					assert(is_C99_named_specifier(tmp2,"enum"));
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
 					continue;
 					}
 				// tentatively forward-declare immediately
 				//! \test zcc/decl.C99/Pass_union_forward_def.h
 				else _forward_declare_C_union_preparsed(src,i,k,pre_invariant_decl_scanner);
+				}
+				parse_tree& tmp2 = src.c_array<0>()[i+k];
 				if (semicolon_terminated_decl)
 					{	// check for forward-declaration here (C99 6.7.2.3)
 					//! \test decl.C99/Warn_union_forward_def_const.h
@@ -13384,7 +13388,7 @@
 					//! \test decl.C99/Warn_union_forward_def_const_volatile10.h
 					//! \test decl.C99/Warn_union_forward_def_const_volatile11.h
 					//! \test decl.C99/Warn_union_forward_def_const_volatile12.h
-					C99_flush_const_volatile_without_object(src.c_array<0>()[i+k]);
+					C99_flush_const_volatile_without_object(tmp2);
 					if (tmp)
 						{	// but if already (forward-)declared then this is a no-op
 							// think this is common enough to not warrant OAOO/DRY treatment
@@ -13400,7 +13404,7 @@
 				else if (!tmp)
 					{	// used without at least forward-declaring
 						//! \bug needs test cases
-					message_header(src.data<0>()[i+k].index_tokens[0]);
+					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INFORM("used without at least forward-declaring");
 					zcc_errors.inc_error();
@@ -13921,27 +13925,7 @@
 			};
 		}
 		// check naked declarations first
-reparse:
-		const int tag_type = notice_C99_tag(src.data<0>()[i]);
-		if (tag_type)
-			{
-			switch(tag_type)
-			{	//! \todo deal with indentation violations later
-#ifndef NDEBUG
-			default: _fatal_code("return value of notice_C99_tag out of range",3);
-#endif
-			case UNION_NAME: break;	/* already handled */
-			case STRUCT_NAME: break;	/* already handled */
-			case UNION_NAMED_DEF: break;	/* already handled */
-			case STRUCT_NAMED_DEF: break;	/* already handled */
-			case UNION_ANON_DEF: break;	/* already handled */
-			case STRUCT_ANON_DEF: break;	/* already handled */
-			case ENUM_NAME: break;	/* already handled */
-			case ENUM_NAMED_DEF: break;	/* already handled */
-			case ENUM_ANON_DEF: break;	/* already handled */
-			}
-			}
-			
+reparse:			
 		// general declaration scanner 
 		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
 		// intercept declarations as follows



From zaimoni at mail.berlios.de  Tue Jan 11 04:34:08 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 11 Jan 2011 04:34:08 +0100
Subject: [Zcplusplus-commits] r578 - trunk
Message-ID: <20110111033408.E1747480514@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-11 04:34:08 +0100 (Tue, 11 Jan 2011)
New Revision: 578

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
formal bugfix

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-11 03:04:29 UTC (rev 577)
+++ trunk/CSupport.cpp	2011-01-11 03:34:08 UTC (rev 578)
@@ -14294,7 +14294,7 @@
 					assert(0<parse_tree::types->use_count(tmp));
 					tmp2.type_code.set_type(tmp);
 					tmp2.flags |= PARSE_UNION_TYPE;
-					_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-11 03:04:29 UTC (rev 577)
+++ trunk/CSupport.cpp.in	2011-01-11 03:34:08 UTC (rev 578)
@@ -14438,7 +14438,7 @@
 					assert(0<parse_tree::types->use_count(tmp));
 					tmp2.type_code.set_type(tmp);
 					tmp2.flags |= PARSE_UNION_TYPE;
-					_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
 				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))



From zaimoni at mail.berlios.de  Sat Jan 22 05:42:17 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 22 Jan 2011 05:42:17 +0100
Subject: [Zcplusplus-commits] r579 - trunk
Message-ID: <20110122044218.03ABB480817@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-22 05:42:17 +0100 (Sat, 22 Jan 2011)
New Revision: 579

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
remove unused variable

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-11 03:34:08 UTC (rev 578)
+++ trunk/CSupport.cpp	2011-01-22 04:42:17 UTC (rev 579)
@@ -13080,7 +13080,6 @@
 	// note that typedefs and struct/union declarations/definitions create new types; if this happens we are no longer context-free (so second pass with context-based parsing)
 	// ask GCC: struct/class/union/enum collides with each other (both C and C++), does not collide with namespace
 	// think we can handle this as "disallow conflicting definitions"
-	kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(C99_type_or_invariant_decl_specifier);
 	size_t i = 0;
 restart_master_loop:
 	while(i<src.size<0>())
@@ -14188,7 +14187,6 @@
 		return;
 		}
 
-	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier);
 	size_t i = 0;
 restart_master_loop:
 	while(i<src.size<0>())

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-11 03:34:08 UTC (rev 578)
+++ trunk/CSupport.cpp.in	2011-01-22 04:42:17 UTC (rev 579)
@@ -13224,7 +13224,6 @@
 	// note that typedefs and struct/union declarations/definitions create new types; if this happens we are no longer context-free (so second pass with context-based parsing)
 	// ask GCC: struct/class/union/enum collides with each other (both C and C++), does not collide with namespace
 	// think we can handle this as "disallow conflicting definitions"
-	kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(C99_type_or_invariant_decl_specifier);
 	size_t i = 0;
 restart_master_loop:
 	while(i<src.size<0>())
@@ -14332,7 +14331,6 @@
 		return;
 		}
 
-	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier);
 	size_t i = 0;
 restart_master_loop:
 	while(i<src.size<0>())



From zaimoni at mail.berlios.de  Sat Jan 22 07:40:34 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 22 Jan 2011 07:40:34 +0100
Subject: [Zcplusplus-commits] r580 - in trunk: . tests/zcc/decl.C99
	tests/zcc.in/decl.C99
Message-ID: <20110122064035.27563480757@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-22 07:40:34 +0100 (Sat, 22 Jan 2011)
New Revision: 580

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/tests/zcc.in/decl.C99/Pass_enum_def.in
   trunk/tests/zcc/decl.C99/Pass_enum_def.h
   trunk/tests/zcc/decl.C99/Pass_enum_def.hpp
Log:
augment enumeration declaration tests

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-22 04:42:17 UTC (rev 579)
+++ trunk/CSupport.cpp	2011-01-22 06:40:34 UTC (rev 580)
@@ -11623,6 +11623,11 @@
 	bool operator()(const parse_tree& x)
 		{
 		BOOST_STATIC_ASSERT(CHAR_BIT*sizeof(uintmax_t)>=STATIC_SIZE(C99_decl_specifiers));
+		if (!base_type.base_type_index && (PARSE_TYPE & x.flags))
+			{
+			value_copy(base_type,x.type_code);
+			return true;
+			}
 		if (!x.is_atomic()) return false;
 		const errr Idx = linear_find(x.index_tokens[0].token.first,x.index_tokens[0].token.second,C99_decl_specifiers,STATIC_SIZE(C99_decl_specifiers));
 		if (0<=Idx)
@@ -11633,13 +11638,10 @@
 			};
 		// not a decl-specifier; bail out if we already have a type
 		if (base_type.base_type_index) return false;
-		if (PARSE_TYPE & x.flags)
-			{
-			value_copy(base_type,x.type_code);
-			return true;
-			}
 		// handle typedefs
-		if (check_for_typedef(base_type,x.index_tokens[0].token.first,types)) return true;
+		if (   !C99_echo_reserved_keyword(x.index_tokens[0].token.first,x.index_tokens[0].token.second)
+			&& (C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags))
+			return check_for_typedef(base_type,x.index_tokens[0].token.first,types);
 		return false;
 		};
 	bool analyze_flags_global(parse_tree& x, size_t i, size_t& decl_count)
@@ -11704,6 +11706,8 @@
 	uintmax_t get_flags() const {return flags;};
 	//! \throw std::bad_alloc
 	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
+	const enum_def* is_enumeration() const {assert(0==base_type.pointer_power); return types.get_enum_def(base_type.base_type_index);};
+	bool is_type() const {return base_type.base_type_index;};
 };
 
 class CPP0X_decl_specifier_scanner
@@ -11727,6 +11731,11 @@
 		{
 		BOOST_STATIC_ASSERT(CHAR_BIT*sizeof(uintmax_t)>=STATIC_SIZE(CPP0X_decl_specifiers));
 		assert(x.size<0>()>i);
+		if (!base_type.base_type_index && (PARSE_TYPE & x.data<0>()[i].flags))
+			{
+			value_copy(base_type,x.data<0>()[i].type_code);
+			return true;
+			}
 		if (!x.data<0>()[i].is_atomic()) return false;
 		const errr Idx = linear_find(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second,CPP0X_decl_specifiers,STATIC_SIZE(CPP0X_decl_specifiers));
 		if (0<=Idx)
@@ -11737,20 +11746,12 @@
 			};
 		// not a decl-specifier; bail out if we already have a type
 		if (base_type.base_type_index) return false;
-		if (PARSE_TYPE & x.data<0>()[i].flags)
-			{
-			value_copy(base_type,x.data<0>()[i].type_code);
-			return true;
-			}
-		{	// handle typedefs
+		// handle typedefs
 		// determine what fully-qualified name would be
-		if (   x.data<0>()[i].is_atomic()
-			&& !(PARSE_TYPE & x.data<0>()[i].flags)
-			&& !CPP_echo_reserved_keyword(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second)
+		if (   !CPP_echo_reserved_keyword(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second)
 			&& (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags))
 			// shove Koenig lookup into type_system
 			return check_for_typedef(base_type,x.data<0>()[i].index_tokens[0].token.first,active_namespace,types);
-		}
 		return false;
 		};
 	bool analyze_flags_global(parse_tree& x, size_t i, size_t& decl_count)
@@ -11849,6 +11850,8 @@
 	uintmax_t get_flags() const {return flags;};
 	//! \throw std::bad_alloc
 	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
+	const enum_def* is_enumeration() const {assert(0==base_type.pointer_power); return types.get_enum_def(base_type.base_type_index);};
+	bool is_type() const {return base_type.base_type_index;};
 };
 
 static size_t C99_cv_qualifier_span(parse_tree& x, size_t i,type_spec& target_type)
@@ -13802,11 +13805,17 @@
 			assert(src.size<0>()-i>decl_count);	// unterminated declaration handled above
 			if (robust_token_is_char<';'>(src.data<0>()[i+decl_count]))
 				{	// C99 7p2 error: must declare something
-					//! \test zcc/decl.C99/Error_extern_semicolon.h
-					//! \test zcc/decl.C99/Error_static_semicolon.h
-					//! \test zcc/decl.C99/Error_typedef_semicolon.h
-					//! \test zcc/decl.C99/Error_register_semicolon.h
-					//! \test zcc/decl.C99/Error_auto_semicolon.h
+				if (   declFind.is_enumeration()	// but a raw enumeration is fine
+					|| (1==decl_count && declFind.is_type()))	// as is a forward-declare
+					{
+					i += decl_count+1;
+					continue;
+					}
+				//! \test zcc/decl.C99/Error_extern_semicolon.h
+				//! \test zcc/decl.C99/Error_static_semicolon.h
+				//! \test zcc/decl.C99/Error_typedef_semicolon.h
+				//! \test zcc/decl.C99/Error_register_semicolon.h
+				//! \test zcc/decl.C99/Error_auto_semicolon.h
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("declaration must declare something (C99 6.7p2)");
@@ -15294,14 +15303,20 @@
 			assert(src.size<0>()-i>decl_count);	/* unterminated declarations already handled */
 			if (robust_token_is_char<';'>(src.data<0>()[i+decl_count]))
 				{	// must declare something
-					//! \test zcc/decl.C99/Error_extern_semicolon.hpp
-					//! \test zcc/decl.C99/Error_static_semicolon.hpp
-					//! \test zcc/decl.C99/Error_typedef_semicolon.hpp
-					//! \test zcc/decl.C99/Error_register_semicolon.hpp
-					//! \test zcc/decl.C99/Error_mutable_semicolon.hpp
-					//! \test zcc/decl.C99/Error_virtual_semicolon.hpp
-					//! \test zcc/decl.C99/Error_friend_semicolon.hpp
-					//! \test zcc/decl.C99/Error_explicit_semicolon.hpp
+				if (   declFind.is_enumeration()	// but a raw enumeration is fine
+					|| (1==decl_count && declFind.is_type()))	// as is a forward-declare
+					{
+					i += decl_count+1;
+					continue;
+					}
+				//! \test zcc/decl.C99/Error_extern_semicolon.hpp
+				//! \test zcc/decl.C99/Error_static_semicolon.hpp
+				//! \test zcc/decl.C99/Error_typedef_semicolon.hpp
+				//! \test zcc/decl.C99/Error_register_semicolon.hpp
+				//! \test zcc/decl.C99/Error_mutable_semicolon.hpp
+				//! \test zcc/decl.C99/Error_virtual_semicolon.hpp
+				//! \test zcc/decl.C99/Error_friend_semicolon.hpp
+				//! \test zcc/decl.C99/Error_explicit_semicolon.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("declaration must declare something (C++98 7p4)");

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-22 04:42:17 UTC (rev 579)
+++ trunk/CSupport.cpp.in	2011-01-22 06:40:34 UTC (rev 580)
@@ -11767,6 +11767,11 @@
 	bool operator()(const parse_tree& x)
 		{
 		BOOST_STATIC_ASSERT(CHAR_BIT*sizeof(uintmax_t)>=STATIC_SIZE(C99_decl_specifiers));
+		if (!base_type.base_type_index && (PARSE_TYPE & x.flags))
+			{
+			value_copy(base_type,x.type_code);
+			return true;
+			}
 		if (!x.is_atomic()) return false;
 		const errr Idx = linear_find(x.index_tokens[0].token.first,x.index_tokens[0].token.second,C99_decl_specifiers,STATIC_SIZE(C99_decl_specifiers));
 		if (0<=Idx)
@@ -11777,13 +11782,10 @@
 			};
 		// not a decl-specifier; bail out if we already have a type
 		if (base_type.base_type_index) return false;
-		if (PARSE_TYPE & x.flags)
-			{
-			value_copy(base_type,x.type_code);
-			return true;
-			}
 		// handle typedefs
-		if (check_for_typedef(base_type,x.index_tokens[0].token.first,types)) return true;
+		if (   !C99_echo_reserved_keyword(x.index_tokens[0].token.first,x.index_tokens[0].token.second)
+			&& (C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags))
+			return check_for_typedef(base_type,x.index_tokens[0].token.first,types);
 		return false;
 		};
 	bool analyze_flags_global(parse_tree& x, size_t i, size_t& decl_count)
@@ -11848,6 +11850,8 @@
 	uintmax_t get_flags() const {return flags;};
 	//! \throw std::bad_alloc
 	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
+	const enum_def* is_enumeration() const {assert(0==base_type.pointer_power); return types.get_enum_def(base_type.base_type_index);};
+	bool is_type() const {return base_type.base_type_index;};
 };
 
 class CPP0X_decl_specifier_scanner
@@ -11871,6 +11875,11 @@
 		{
 		BOOST_STATIC_ASSERT(CHAR_BIT*sizeof(uintmax_t)>=STATIC_SIZE(CPP0X_decl_specifiers));
 		assert(x.size<0>()>i);
+		if (!base_type.base_type_index && (PARSE_TYPE & x.data<0>()[i].flags))
+			{
+			value_copy(base_type,x.data<0>()[i].type_code);
+			return true;
+			}
 		if (!x.data<0>()[i].is_atomic()) return false;
 		const errr Idx = linear_find(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second,CPP0X_decl_specifiers,STATIC_SIZE(CPP0X_decl_specifiers));
 		if (0<=Idx)
@@ -11881,20 +11890,12 @@
 			};
 		// not a decl-specifier; bail out if we already have a type
 		if (base_type.base_type_index) return false;
-		if (PARSE_TYPE & x.data<0>()[i].flags)
-			{
-			value_copy(base_type,x.data<0>()[i].type_code);
-			return true;
-			}
-		{	// handle typedefs
+		// handle typedefs
 		// determine what fully-qualified name would be
-		if (   x.data<0>()[i].is_atomic()
-			&& !(PARSE_TYPE & x.data<0>()[i].flags)
-			&& !CPP_echo_reserved_keyword(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second)
+		if (   !CPP_echo_reserved_keyword(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second)
 			&& (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags))
 			// shove Koenig lookup into type_system
 			return check_for_typedef(base_type,x.data<0>()[i].index_tokens[0].token.first,active_namespace,types);
-		}
 		return false;
 		};
 	bool analyze_flags_global(parse_tree& x, size_t i, size_t& decl_count)
@@ -11993,6 +11994,8 @@
 	uintmax_t get_flags() const {return flags;};
 	//! \throw std::bad_alloc
 	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
+	const enum_def* is_enumeration() const {assert(0==base_type.pointer_power); return types.get_enum_def(base_type.base_type_index);};
+	bool is_type() const {return base_type.base_type_index;};
 };
 
 static size_t C99_cv_qualifier_span(parse_tree& x, size_t i,type_spec& target_type)
@@ -13946,11 +13949,17 @@
 			assert(src.size<0>()-i>decl_count);	// unterminated declaration handled above
 			if (robust_token_is_char<';'>(src.data<0>()[i+decl_count]))
 				{	// C99 7p2 error: must declare something
-					//! \test zcc/decl.C99/Error_extern_semicolon.h
-					//! \test zcc/decl.C99/Error_static_semicolon.h
-					//! \test zcc/decl.C99/Error_typedef_semicolon.h
-					//! \test zcc/decl.C99/Error_register_semicolon.h
-					//! \test zcc/decl.C99/Error_auto_semicolon.h
+				if (   declFind.is_enumeration()	// but a raw enumeration is fine
+					|| (1==decl_count && declFind.is_type()))	// as is a forward-declare
+					{
+					i += decl_count+1;
+					continue;
+					}
+				//! \test zcc/decl.C99/Error_extern_semicolon.h
+				//! \test zcc/decl.C99/Error_static_semicolon.h
+				//! \test zcc/decl.C99/Error_typedef_semicolon.h
+				//! \test zcc/decl.C99/Error_register_semicolon.h
+				//! \test zcc/decl.C99/Error_auto_semicolon.h
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("declaration must declare something (C99 6.7p2)");
@@ -14369,6 +14378,52 @@
 				src.DeleteNSlotsAt<0>(strict_ub,i);
 				return;
 				};
+#/*cut-nocpp*/
+		// more generally, we should recover any type-id; haven't checked how much we can do here
+		// this doesn't generalize fully to C
+		// do not have namespace available in CPP0X_type_or_invariant_decl_specifier_or_tag so can't punt there (unsure if this is worth a global)
+		// identifier might be type name: recover
+		if (0==pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)))
+			{
+			if (origin[pre_invariant_decl_scanner.size()].index_tokens[0].flags & C_TESTFLAG_IDENTIFIER)
+				{
+				parse_tree& tmp2 = src.c_array<0>()[i+k];					
+				{
+				type_system::type_index tmp = parse_tree::types->get_id_union_CPP(pre_invariant_decl_scanner.size()].index_tokens[0],active_namespace);
+				if (tmp)
+					{	// is a union
+					tmp2.grab_index_token_from<1,0>(tmp2);
+					tmp2.set_index_token_from_str_literal<0>("union");
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (tmp = parse_tree::types->get_id_struct_class_CPP(pre_invariant_decl_scanner.size()].index_tokens[0],active_namespace))
+					{	// is a struct/class
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(tmp);
+					assert(tmp3);
+					const char* const text = text_from_keyword(*tmp3);
+					tmp2.grab_index_token_from<1,0>(tmp2);
+					tmp2.set_index_token_from_str_literal<0>(text);
+					assert(is_C99_named_specifier(tmp2,text));
+					goto rescan;
+					}
+				else if (tmp = parse_tree::types->get_id_enum_CPP(pre_invariant_decl_scanner.size()].index_tokens[0],active_namespace))
+					{	// is an enum
+					tmp2.grab_index_token_from<1,0>(tmp2);
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					goto rescan;
+					};
+				}
+				{
+				const zaimoni::POD_triple<type_spec,const char*,size_t>* const tmp = parse_tree::types->get_typedef_CPP(pre_invariant_decl_scanner.size()].index_tokens[0],active_namespace);
+				if (tmp)
+					{
+					}
+				}
+				}
+			}
+#/*cut-nocpp*/
 		}
 		if (!pre_invariant_decl_scanner.empty())
 			{
@@ -15438,14 +15493,20 @@
 			assert(src.size<0>()-i>decl_count);	/* unterminated declarations already handled */
 			if (robust_token_is_char<';'>(src.data<0>()[i+decl_count]))
 				{	// must declare something
-					//! \test zcc/decl.C99/Error_extern_semicolon.hpp
-					//! \test zcc/decl.C99/Error_static_semicolon.hpp
-					//! \test zcc/decl.C99/Error_typedef_semicolon.hpp
-					//! \test zcc/decl.C99/Error_register_semicolon.hpp
-					//! \test zcc/decl.C99/Error_mutable_semicolon.hpp
-					//! \test zcc/decl.C99/Error_virtual_semicolon.hpp
-					//! \test zcc/decl.C99/Error_friend_semicolon.hpp
-					//! \test zcc/decl.C99/Error_explicit_semicolon.hpp
+				if (   declFind.is_enumeration()	// but a raw enumeration is fine
+					|| (1==decl_count && declFind.is_type()))	// as is a forward-declare
+					{
+					i += decl_count+1;
+					continue;
+					}
+				//! \test zcc/decl.C99/Error_extern_semicolon.hpp
+				//! \test zcc/decl.C99/Error_static_semicolon.hpp
+				//! \test zcc/decl.C99/Error_typedef_semicolon.hpp
+				//! \test zcc/decl.C99/Error_register_semicolon.hpp
+				//! \test zcc/decl.C99/Error_mutable_semicolon.hpp
+				//! \test zcc/decl.C99/Error_virtual_semicolon.hpp
+				//! \test zcc/decl.C99/Error_friend_semicolon.hpp
+				//! \test zcc/decl.C99/Error_explicit_semicolon.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("declaration must declare something (C++98 7p4)");

Modified: trunk/tests/zcc/decl.C99/Pass_enum_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_def.h	2011-01-22 04:42:17 UTC (rev 579)
+++ trunk/tests/zcc/decl.C99/Pass_enum_def.h	2011-01-22 06:40:34 UTC (rev 580)
@@ -6,3 +6,60 @@
 	x_factor = 1
 };
 
+// ringing the changes on extern
+extern enum good_test x1;
+extern const enum good_test x2;
+extern volatile enum good_test x3;
+extern const volatile enum good_test x4;
+extern volatile const enum good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static enum good_test x6;
+static volatile enum good_test x7;
+static const volatile enum good_test x8;
+static volatile const enum good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern enum good_test x10;
+volatile extern enum good_test x11;
+const extern volatile enum good_test x12;
+const volatile extern enum good_test x13;
+volatile extern const enum good_test x14;
+volatile const extern enum good_test x15;
+
+volatile static enum good_test x16;
+const static volatile enum good_test x17;
+const volatile static enum good_test x18;
+volatile static const enum good_test x19;
+volatile const static enum good_test x20;
+
+// define-declares
+// ringing the changes on extern
+extern enum good_test2 { x_factor2 = 1 } x21;
+extern const enum good_test3 { x_factor3 = 1 } x22;
+extern volatile enum good_test4 { x_factor4 = 1 } x23;
+extern const volatile enum good_test5 { x_factor5 = 1 } x24;
+extern volatile const enum good_test6 { x_factor6 = 1 } x25;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static enum good_test7 { x_factor7 = 1 } x26;
+static volatile enum good_test8 { x_factor8 = 1 } x27;
+static const volatile enum good_test9 { x_factor9 = 1 } x28;
+static volatile const enum good_test10 { x_factor10 = 1 } x29;
+
+// extern/static not in first postion is deprecated, but legal
+const extern enum good_test11 { x_factor11 = 1 } x30;
+volatile extern enum good_test12 { x_factor12 = 1 } x31;
+const extern volatile enum good_test13 { x_factor13 = 1 } x32;
+const volatile extern enum good_test14 { x_factor14 = 1 } x33;
+volatile extern const enum good_test15 { x_factor15 = 1 } x34;
+volatile const extern enum good_test16 { x_factor16 = 1 } x35;
+
+volatile static enum good_test17 { x_factor17 = 1 } x16;
+const static volatile enum good_test18 { x_factor18 = 1 } x37;
+const volatile static enum good_test19 { x_factor19 = 1 } x38;
+volatile static const enum good_test20 { x_factor20 = 1 } x39;
+volatile const static enum good_test21 { x_factor21 = 1 } x40;
+

Modified: trunk/tests/zcc/decl.C99/Pass_enum_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_def.hpp	2011-01-22 04:42:17 UTC (rev 579)
+++ trunk/tests/zcc/decl.C99/Pass_enum_def.hpp	2011-01-22 06:40:34 UTC (rev 580)
@@ -6,3 +6,60 @@
 	x_factor = 1
 };
 
+// ringing the changes on extern
+extern enum good_test x1;
+extern const enum good_test x2;
+extern volatile enum good_test x3;
+extern const volatile enum good_test x4;
+extern volatile const enum good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static enum good_test x6;
+static volatile enum good_test x7;
+static const volatile enum good_test x8;
+static volatile const enum good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern enum good_test x10;
+volatile extern enum good_test x11;
+const extern volatile enum good_test x12;
+const volatile extern enum good_test x13;
+volatile extern const enum good_test x14;
+volatile const extern enum good_test x15;
+
+volatile static enum good_test x16;
+const static volatile enum good_test x17;
+const volatile static enum good_test x18;
+volatile static const enum good_test x19;
+volatile const static enum good_test x20;
+
+// define-declares
+// ringing the changes on extern
+extern enum good_test2 { x_factor2 = 1 } x21;
+extern const enum good_test3 { x_factor3 = 1 } x22;
+extern volatile enum good_test4 { x_factor4 = 1 } x23;
+extern const volatile enum good_test5 { x_factor5 = 1 } x24;
+extern volatile const enum good_test6 { x_factor6 = 1 } x25;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static enum good_test7 { x_factor7 = 1 } x26;
+static volatile enum good_test8 { x_factor8 = 1 } x27;
+static const volatile enum good_test9 { x_factor9 = 1 } x28;
+static volatile const enum good_test10 { x_factor10 = 1 } x29;
+
+// extern/static not in first postion is deprecated, but legal
+const extern enum good_test11 { x_factor11 = 1 } x30;
+volatile extern enum good_test12 { x_factor12 = 1 } x31;
+const extern volatile enum good_test13 { x_factor13 = 1 } x32;
+const volatile extern enum good_test14 { x_factor14 = 1 } x33;
+volatile extern const enum good_test15 { x_factor15 = 1 } x34;
+volatile const extern enum good_test16 { x_factor16 = 1 } x35;
+
+volatile static enum good_test17 { x_factor17 = 1 } x16;
+const static volatile enum good_test18 { x_factor18 = 1 } x37;
+const volatile static enum good_test19 { x_factor19 = 1 } x38;
+volatile static const enum good_test20 { x_factor20 = 1 } x39;
+volatile const static enum good_test21 { x_factor21 = 1 } x40;
+

Modified: trunk/tests/zcc.in/decl.C99/Pass_enum_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_enum_def.in	2011-01-22 04:42:17 UTC (rev 579)
+++ trunk/tests/zcc.in/decl.C99/Pass_enum_def.in	2011-01-22 06:40:34 UTC (rev 580)
@@ -6,3 +6,60 @@
 	x_factor = 1
 };
 
+// ringing the changes on extern
+extern enum good_test x1;
+extern const enum good_test x2;
+extern volatile enum good_test x3;
+extern const volatile enum good_test x4;
+extern volatile const enum good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static enum good_test x6;
+static volatile enum good_test x7;
+static const volatile enum good_test x8;
+static volatile const enum good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern enum good_test x10;
+volatile extern enum good_test x11;
+const extern volatile enum good_test x12;
+const volatile extern enum good_test x13;
+volatile extern const enum good_test x14;
+volatile const extern enum good_test x15;
+
+volatile static enum good_test x16;
+const static volatile enum good_test x17;
+const volatile static enum good_test x18;
+volatile static const enum good_test x19;
+volatile const static enum good_test x20;
+
+// define-declares
+// ringing the changes on extern
+extern enum good_test2 { x_factor2 = 1 } x21;
+extern const enum good_test3 { x_factor3 = 1 } x22;
+extern volatile enum good_test4 { x_factor4 = 1 } x23;
+extern const volatile enum good_test5 { x_factor5 = 1 } x24;
+extern volatile const enum good_test6 { x_factor6 = 1 } x25;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static enum good_test7 { x_factor7 = 1 } x26;
+static volatile enum good_test8 { x_factor8 = 1 } x27;
+static const volatile enum good_test9 { x_factor9 = 1 } x28;
+static volatile const enum good_test10 { x_factor10 = 1 } x29;
+
+// extern/static not in first postion is deprecated, but legal
+const extern enum good_test11 { x_factor11 = 1 } x30;
+volatile extern enum good_test12 { x_factor12 = 1 } x31;
+const extern volatile enum good_test13 { x_factor13 = 1 } x32;
+const volatile extern enum good_test14 { x_factor14 = 1 } x33;
+volatile extern const enum good_test15 { x_factor15 = 1 } x34;
+volatile const extern enum good_test16 { x_factor16 = 1 } x35;
+
+volatile static enum good_test17 { x_factor17 = 1 } x16;
+const static volatile enum good_test18 { x_factor18 = 1 } x37;
+const volatile static enum good_test19 { x_factor19 = 1 } x38;
+volatile static const enum good_test20 { x_factor20 = 1 } x39;
+volatile const static enum good_test21 { x_factor21 = 1 } x40;
+



From zaimoni at mail.berlios.de  Sat Jan 22 07:41:43 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 22 Jan 2011 07:41:43 +0100
Subject: [Zcplusplus-commits] r581 - trunk/tests/zcc.in/decl.C99
Message-ID: <20110122064143.D6E4D480757@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-22 07:41:43 +0100 (Sat, 22 Jan 2011)
New Revision: 581

Added:
   trunk/tests/zcc.in/decl.C99/Error_struct_as_enum.in
   trunk/tests/zcc.in/decl.C99/Error_struct_as_enum2.in
   trunk/tests/zcc.in/decl.C99/Error_union_as_enum.in
   trunk/tests/zcc.in/decl.C99/Error_union_as_enum2.in
Log:
add some omitted *.in files for generating test cases

Added: trunk/tests/zcc.in/decl.C99/Error_struct_as_enum.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_struct_as_enum.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_struct_as_enum.in	2011-01-22 06:41:43 UTC (rev 581)
@@ -0,0 +1,9 @@
+SUFFIXES h hpp
+// using struct as enum
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct bad_test;
+
+enum bad_test {
+	x_factor = 1
+};

Added: trunk/tests/zcc.in/decl.C99/Error_struct_as_enum2.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_struct_as_enum2.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_struct_as_enum2.in	2011-01-22 06:41:43 UTC (rev 581)
@@ -0,0 +1,11 @@
+SUFFIXES h hpp
+// using struct as enum
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct bad_test {
+	int x_factor;
+};
+
+enum bad_test {
+	x_factor = 1
+};

Added: trunk/tests/zcc.in/decl.C99/Error_union_as_enum.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_union_as_enum.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_union_as_enum.in	2011-01-22 06:41:43 UTC (rev 581)
@@ -0,0 +1,9 @@
+SUFFIXES h hpp
+// using union as enum
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test;
+
+enum bad_test {
+	x_factor = 1
+};

Added: trunk/tests/zcc.in/decl.C99/Error_union_as_enum2.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_union_as_enum2.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_union_as_enum2.in	2011-01-22 06:41:43 UTC (rev 581)
@@ -0,0 +1,12 @@
+SUFFIXES h hpp
+// using union as enum
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test {
+	int x_factor;
+};
+
+enum bad_test {
+	x_factor = 1
+};
+



From zaimoni at mail.berlios.de  Sat Jan 22 08:49:46 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 22 Jan 2011 08:49:46 +0100
Subject: [Zcplusplus-commits] r582 - in trunk: . tests/zcc/decl.C99
	tests/zcc.in/decl.C99
Message-ID: <20110122074947.4772D480772@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-22 08:49:46 +0100 (Sat, 22 Jan 2011)
New Revision: 582

Added:
   trunk/tests/zcc.in/decl.C99/Error_enum_runon_def.in
   trunk/tests/zcc/decl.C99/Error_enum_runon_def.h
   trunk/tests/zcc/decl.C99/Error_enum_runon_def.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
test missing , in declarations

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-22 06:41:43 UTC (rev 581)
+++ trunk/CSupport.cpp	2011-01-22 07:49:46 UTC (rev 582)
@@ -13954,16 +13954,17 @@
 					};
 				// ,: iterate
 				// anything else: error
-				if (!robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset]))
-					{
+				if (!robust_token_is_char<','>(src.data<0>()[i+decl_count+decl_offset]))
+					{	//! \test decl.C99/Error_enum_runon_def.h
 					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INFORM("declaration disoriented by missing , (C99 6.7p1)");
-					// find the next semicolon
-					size_t j = i+decl_count+decl_offset;
-					while(!robust_token_is_char<';'>(src.data<0>()[j]) && src.size<0>()> ++j);
-					src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
-					continue;
+					zcc_errors.inc_error();
+					// remove everything starting here through next semicolon
+					src.DeleteNSlotsAt<0>(span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>()),i+decl_count+decl_offset);
+					src.c_array<0>()[i+decl_count+decl_offset].flags |= parse_tree::GOOD_LINE_BREAK;
+					++decl_offset;
+					break;
 					}
 				++decl_offset;
 				}
@@ -15464,15 +15465,17 @@
 					};
 				// ,: iterate
 				// anything else: error
-				if (!robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset]))
-					{
+				if (!robust_token_is_char<','>(src.data<0>()[i+decl_count+decl_offset]))
+					{	//! \test decl.C99/Error_enum_runon_def.hpp
 					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INFORM("declaration disoriented by missing , (C++98 7p1)");
-					// find the next semicolon
-					const size_t span = span_to_semicolon(src.begin<0>()+(i+decl_count+decl_offset),src.end<0>());
-					src.DeleteNSlotsAt<0>(span,i+decl_count+decl_offset);
-					continue;
+					zcc_errors.inc_error();
+					// remove everything starting here through next semicolon
+					src.DeleteNSlotsAt<0>(span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>()),i+decl_count+decl_offset);
+					src.c_array<0>()[i+decl_count+decl_offset].flags |= parse_tree::GOOD_LINE_BREAK;
+					++decl_offset;
+					break;
 					}
 				++decl_offset;
 				}

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-22 06:41:43 UTC (rev 581)
+++ trunk/CSupport.cpp.in	2011-01-22 07:49:46 UTC (rev 582)
@@ -14098,16 +14098,17 @@
 					};
 				// ,: iterate
 				// anything else: error
-				if (!robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset]))
-					{
+				if (!robust_token_is_char<','>(src.data<0>()[i+decl_count+decl_offset]))
+					{	//! \test decl.C99/Error_enum_runon_def.h
 					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INFORM("declaration disoriented by missing , (C99 6.7p1)");
-					// find the next semicolon
-					size_t j = i+decl_count+decl_offset;
-					while(!robust_token_is_char<';'>(src.data<0>()[j]) && src.size<0>()> ++j);
-					src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
-					continue;
+					zcc_errors.inc_error();
+					// remove everything starting here through next semicolon
+					src.DeleteNSlotsAt<0>(span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>()),i+decl_count+decl_offset);
+					src.c_array<0>()[i+decl_count+decl_offset].flags |= parse_tree::GOOD_LINE_BREAK;
+					++decl_offset;
+					break;
 					}
 				++decl_offset;
 				}
@@ -15654,15 +15655,17 @@
 					};
 				// ,: iterate
 				// anything else: error
-				if (!robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset]))
-					{
+				if (!robust_token_is_char<','>(src.data<0>()[i+decl_count+decl_offset]))
+					{	//! \test decl.C99/Error_enum_runon_def.hpp
 					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INFORM("declaration disoriented by missing , (C++98 7p1)");
-					// find the next semicolon
-					const size_t span = span_to_semicolon(src.begin<0>()+(i+decl_count+decl_offset),src.end<0>());
-					src.DeleteNSlotsAt<0>(span,i+decl_count+decl_offset);
-					continue;
+					zcc_errors.inc_error();
+					// remove everything starting here through next semicolon
+					src.DeleteNSlotsAt<0>(span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>()),i+decl_count+decl_offset);
+					src.c_array<0>()[i+decl_count+decl_offset].flags |= parse_tree::GOOD_LINE_BREAK;
+					++decl_offset;
+					break;
 					}
 				++decl_offset;
 				}

Added: trunk/tests/zcc/decl.C99/Error_enum_runon_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_runon_def.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_enum_runon_def.h	2011-01-22 07:49:46 UTC (rev 582)
@@ -0,0 +1,11 @@
+// decl.C99\Error_enum_runon_def.h
+// using singly defined enum
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+// ringing the changes on extern
+extern enum bad_test x1
+extern const enum bad_test x2;

Added: trunk/tests/zcc/decl.C99/Error_enum_runon_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_runon_def.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_enum_runon_def.hpp	2011-01-22 07:49:46 UTC (rev 582)
@@ -0,0 +1,11 @@
+// decl.C99\Error_enum_runon_def.hpp
+// using singly defined enum
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+// ringing the changes on extern
+extern enum bad_test x1
+extern const enum bad_test x2;

Added: trunk/tests/zcc.in/decl.C99/Error_enum_runon_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_runon_def.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_runon_def.in	2011-01-22 07:49:46 UTC (rev 582)
@@ -0,0 +1,11 @@
+SUFFIXES h hpp
+// using singly defined enum
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+// ringing the changes on extern
+extern enum bad_test x1
+extern const enum bad_test x2;



From zaimoni at mail.berlios.de  Sat Jan 22 21:16:18 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 22 Jan 2011 21:16:18 +0100
Subject: [Zcplusplus-commits] r583 - in trunk/tests: zcc/decl.C99
	zcc.in/decl.C99
Message-ID: <20110122201618.70838481232@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-22 21:16:18 +0100 (Sat, 22 Jan 2011)
New Revision: 583

Modified:
   trunk/tests/zcc.in/decl.C99/Pass_enum_def.in
   trunk/tests/zcc/decl.C99/Pass_enum_def.h
   trunk/tests/zcc/decl.C99/Pass_enum_def.hpp
Log:
copyright date fixup

Modified: trunk/tests/zcc/decl.C99/Pass_enum_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_def.h	2011-01-22 07:49:46 UTC (rev 582)
+++ trunk/tests/zcc/decl.C99/Pass_enum_def.h	2011-01-22 20:16:18 UTC (rev 583)
@@ -1,6 +1,6 @@
 // decl.C99\Pass_enum_def.h
 // using singly defined enum
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 enum good_test {
 	x_factor = 1

Modified: trunk/tests/zcc/decl.C99/Pass_enum_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_def.hpp	2011-01-22 07:49:46 UTC (rev 582)
+++ trunk/tests/zcc/decl.C99/Pass_enum_def.hpp	2011-01-22 20:16:18 UTC (rev 583)
@@ -1,6 +1,6 @@
 // decl.C99\Pass_enum_def.hpp
 // using singly defined enum
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 enum good_test {
 	x_factor = 1

Modified: trunk/tests/zcc.in/decl.C99/Pass_enum_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_enum_def.in	2011-01-22 07:49:46 UTC (rev 582)
+++ trunk/tests/zcc.in/decl.C99/Pass_enum_def.in	2011-01-22 20:16:18 UTC (rev 583)
@@ -1,6 +1,6 @@
 SUFFIXES h hpp
 // using singly defined enum
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 enum good_test {
 	x_factor = 1



From zaimoni at mail.berlios.de  Sat Jan 22 22:07:14 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 22 Jan 2011 22:07:14 +0100
Subject: [Zcplusplus-commits] r584 - trunk
Message-ID: <20110122210715.5381A481232@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-22 22:07:14 +0100 (Sat, 22 Jan 2011)
New Revision: 584

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
formal fix to unexercised source code

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-22 20:16:18 UTC (rev 583)
+++ trunk/CSupport.cpp	2011-01-22 21:07:14 UTC (rev 584)
@@ -13837,16 +13837,17 @@
 				assert(0<initdecl_span || !initdecl_identifier);
 				if (0==initdecl_span)
 					{	// no declarator where expected
+					//! \todo test suite/Jan. 22 2011 does not exercise.  Is this dead code?
 					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INFORM("declarator missing (C99 6.7p1)");
 					zcc_errors.inc_error();
 					// find the next semicolon
-					const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
+					const size_t remove_these = span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
 					if (have_we_parsed_yet)
-						src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
+						src.DeleteNSlotsAt<0>(remove_these,i+decl_count+decl_offset);
 					else
-						src.DeleteNSlotsAt<0>((j-i)+(src.size<0>()>j),i);
+						src.DeleteNSlotsAt<0>(remove_these+decl_count+decl_offset+(src.size<0>()>i+remove_these+decl_count+decl_offset),i);
 					break;
 					};
 				if (!initdecl_identifier)
@@ -13862,12 +13863,12 @@
 						assert(!have_we_parsed_yet);
 						src.DeleteNSlotsAt<0>(decl_count+decl_offset+initdecl_span,i);
 						}
-					else{
-						const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
+					else{	//! \todo test suite/Jan. 22 2011 does not exercise.  Is this dead code?
+						const size_t remove_these = span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
 						if (have_we_parsed_yet)
-							src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
+							src.DeleteNSlotsAt<0>(remove_these,i+decl_count+decl_offset);
 						else
-							src.DeleteNSlotsAt<0>((j-i)+1,i);
+							src.DeleteNSlotsAt<0>(remove_these+decl_count+decl_offset+(src.size<0>()>i+remove_these+decl_count+decl_offset),i);
 						}
 					break;
 					};
@@ -15339,16 +15340,17 @@
 				assert(0<initdecl_span || !initdecl_identifier);
 				if (0==initdecl_span)
 					{	// no declarator where expected
+					//! \todo test suite/Jan. 22 2011 does not exercise.  Is this dead code?
 					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INFORM("declarator missing (C++98 7p1)");
 					zcc_errors.inc_error();
 					// find the next semicolon
-					const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
+					const size_t remove_these = span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
 					if (have_we_parsed_yet)
-						src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
+						src.DeleteNSlotsAt<0>(remove_these,i+decl_count+decl_offset);
 					else
-						src.DeleteNSlotsAt<0>((j-i)+(src.size<0>()>j),i);
+						src.DeleteNSlotsAt<0>(remove_these+decl_count+decl_offset+(src.size<0>()>i+remove_these+decl_count+decl_offset),i);
 					break;
 					};
 				if (!initdecl_identifier)
@@ -15364,12 +15366,12 @@
 						assert(!have_we_parsed_yet);
 						src.DeleteNSlotsAt<0>(decl_count+decl_offset+initdecl_span,i);
 						}
-					else{
-						const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
+					else{	//! \todo test suite/Jan. 22 2011 does not exercise.  Is this dead code?
+						const size_t remove_these = span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
 						if (have_we_parsed_yet)
-							src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
+							src.DeleteNSlotsAt<0>(remove_these,i+decl_count+decl_offset);
 						else
-							src.DeleteNSlotsAt<0>((j-i)+1,i);
+							src.DeleteNSlotsAt<0>(remove_these+decl_count+decl_offset+(src.size<0>()>i+remove_these+decl_count+decl_offset),i);
 						}
 					break;
 					};

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-22 20:16:18 UTC (rev 583)
+++ trunk/CSupport.cpp.in	2011-01-22 21:07:14 UTC (rev 584)
@@ -13981,16 +13981,17 @@
 				assert(0<initdecl_span || !initdecl_identifier);
 				if (0==initdecl_span)
 					{	// no declarator where expected
+					//! \todo test suite/Jan. 22 2011 does not exercise.  Is this dead code?
 					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INFORM("declarator missing (C99 6.7p1)");
 					zcc_errors.inc_error();
 					// find the next semicolon
-					const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
+					const size_t remove_these = span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
 					if (have_we_parsed_yet)
-						src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
+						src.DeleteNSlotsAt<0>(remove_these,i+decl_count+decl_offset);
 					else
-						src.DeleteNSlotsAt<0>((j-i)+(src.size<0>()>j),i);
+						src.DeleteNSlotsAt<0>(remove_these+decl_count+decl_offset+(src.size<0>()>i+remove_these+decl_count+decl_offset),i);
 					break;
 					};
 				if (!initdecl_identifier)
@@ -14006,12 +14007,12 @@
 						assert(!have_we_parsed_yet);
 						src.DeleteNSlotsAt<0>(decl_count+decl_offset+initdecl_span,i);
 						}
-					else{
-						const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
+					else{	//! \todo test suite/Jan. 22 2011 does not exercise.  Is this dead code?
+						const size_t remove_these = span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
 						if (have_we_parsed_yet)
-							src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
+							src.DeleteNSlotsAt<0>(remove_these,i+decl_count+decl_offset);
 						else
-							src.DeleteNSlotsAt<0>((j-i)+1,i);
+							src.DeleteNSlotsAt<0>(remove_these+decl_count+decl_offset+(src.size<0>()>i+remove_these+decl_count+decl_offset),i);
 						}
 					break;
 					};
@@ -15529,16 +15530,17 @@
 				assert(0<initdecl_span || !initdecl_identifier);
 				if (0==initdecl_span)
 					{	// no declarator where expected
+					//! \todo test suite/Jan. 22 2011 does not exercise.  Is this dead code?
 					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INFORM("declarator missing (C++98 7p1)");
 					zcc_errors.inc_error();
 					// find the next semicolon
-					const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
+					const size_t remove_these = span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
 					if (have_we_parsed_yet)
-						src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
+						src.DeleteNSlotsAt<0>(remove_these,i+decl_count+decl_offset);
 					else
-						src.DeleteNSlotsAt<0>((j-i)+(src.size<0>()>j),i);
+						src.DeleteNSlotsAt<0>(remove_these+decl_count+decl_offset+(src.size<0>()>i+remove_these+decl_count+decl_offset),i);
 					break;
 					};
 				if (!initdecl_identifier)
@@ -15554,12 +15556,12 @@
 						assert(!have_we_parsed_yet);
 						src.DeleteNSlotsAt<0>(decl_count+decl_offset+initdecl_span,i);
 						}
-					else{
-						const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
+					else{	//! \todo test suite/Jan. 22 2011 does not exercise.  Is this dead code?
+						const size_t remove_these = span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
 						if (have_we_parsed_yet)
-							src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
+							src.DeleteNSlotsAt<0>(remove_these,i+decl_count+decl_offset);
 						else
-							src.DeleteNSlotsAt<0>((j-i)+1,i);
+							src.DeleteNSlotsAt<0>(remove_these+decl_count+decl_offset+(src.size<0>()>i+remove_these+decl_count+decl_offset),i);
 						}
 					break;
 					};



From zaimoni at mail.berlios.de  Sun Jan 23 02:59:53 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 23 Jan 2011 02:59:53 +0100
Subject: [Zcplusplus-commits] r585 - in trunk: . tests/zcc/decl.C99
Message-ID: <20110123015954.038B748126F@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-23 02:59:53 +0100 (Sun, 23 Jan 2011)
New Revision: 585

Added:
   trunk/tests/zcc/decl.C99/Pass_enum_def2.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/type_system.cpp
   trunk/type_system.cpp.in
   trunk/type_system.hpp
   trunk/type_system.hpp.in
Log:
C++ enumeration variable declaration test

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-22 21:07:14 UTC (rev 584)
+++ trunk/CSupport.cpp	2011-01-23 01:59:53 UTC (rev 585)
@@ -14216,6 +14216,7 @@
 		{	// wouldn't work for unnamed function parameters
 		const size_t strict_ub = src.size<0>()-i;
 		const parse_tree* const origin = src.data<0>()+i;
+rescan:
 		while(pre_invariant_decl_scanner(origin[pre_invariant_decl_scanner.size()]))
 			// if we ran out of tokens, bad
 			if (strict_ub <= pre_invariant_decl_scanner.size())
@@ -14236,6 +14237,54 @@
 				src.DeleteNSlotsAt<0>(strict_ub,i);
 				return;
 				};
+		// more generally, we should recover any type-id; haven't checked how much we can do here
+		// this doesn't generalize fully to C
+		// do not have namespace available in CPP0X_type_or_invariant_decl_specifier_or_tag so can't punt there (unsure if this is worth a global)
+		// identifier might be type name: recover
+		if (0==pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)))
+			{
+			parse_tree& tmp2 = src.c_array<0>()[i+pre_invariant_decl_scanner.size()];					
+			if (tmp2.is_atomic() && (tmp2.index_tokens[0].flags & C_TESTFLAG_IDENTIFIER))
+				{
+				{
+				type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[0].token.first,active_namespace);
+				if (tmp)
+					{	// is an enum
+					tmp2.grab_index_token_from<1,0>(tmp2);
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					goto rescan;
+#if 0
+					}
+				else if (tmp = parse_tree::types->get_id_union_CPP(pre_invariant_decl_scanner.size()].index_tokens[0],active_namespace))
+					{	// is a union
+					tmp2.grab_index_token_from<1,0>(tmp2);
+					tmp2.set_index_token_from_str_literal<0>("union");
+					assert(is_C99_named_specifier(tmp2,"union"));
+					goto rescan;
+					}
+				else if (tmp = parse_tree::types->get_id_struct_class_CPP(pre_invariant_decl_scanner.size()].index_tokens[0],active_namespace))
+					{	// is a struct/class
+					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(tmp);
+					assert(tmp3);
+					const char* const text = text_from_keyword(*tmp3);
+					tmp2.grab_index_token_from<1,0>(tmp2);
+					tmp2.set_index_token_from_str_literal<0>(text);
+					assert(is_C99_named_specifier(tmp2,text));
+					goto rescan;
+#endif
+					};
+				}
+#if 0
+				{
+				const zaimoni::POD_triple<type_spec,const char*,size_t>* const tmp = parse_tree::types->get_typedef_CPP(pre_invariant_decl_scanner.size()].index_tokens[0],active_namespace);
+				if (tmp)
+					{
+					}
+				}
+#endif
+				}
+			}
 		}
 		if (!pre_invariant_decl_scanner.empty())
 			{
@@ -14329,7 +14378,7 @@
 					pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -14448,7 +14497,7 @@
 					pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -14581,7 +14630,7 @@
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_struct.hpp
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -14698,7 +14747,7 @@
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_struct2.hpp
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -14829,7 +14878,7 @@
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_class.hpp
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -14945,7 +14994,7 @@
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_class2.hpp
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -15074,7 +15123,7 @@
 				case ENUM_NAMED_DEF:
 				{	// can only define once
 				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
-				if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_multidef.hpp
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -15138,7 +15187,7 @@
 				//! \test zcc/decl.C99/Pass_enum_def.hpp
 				// enum-specifier doesn't have a specific declaration mode
 				const type_system::type_index tmp3 = parse_tree::types->register_enum_def_CPP(tmp2.index_tokens[1].token.first,active_namespace,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
-				assert(parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace)==tmp3);
+				assert(parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace)==tmp3);
 				tmp2.type_code.set_type(tmp3);	// C++: enums are own type
 				tmp2.flags |= PARSE_ENUM_TYPE;
 				if (!record_enum_values(*tmp2.c_array<2>(),tmp3,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-22 21:07:14 UTC (rev 584)
+++ trunk/CSupport.cpp.in	2011-01-23 01:59:53 UTC (rev 585)
@@ -14360,6 +14360,7 @@
 		{	// wouldn't work for unnamed function parameters
 		const size_t strict_ub = src.size<0>()-i;
 		const parse_tree* const origin = src.data<0>()+i;
+rescan:
 		while(pre_invariant_decl_scanner(origin[pre_invariant_decl_scanner.size()]))
 			// if we ran out of tokens, bad
 			if (strict_ub <= pre_invariant_decl_scanner.size())
@@ -14380,19 +14381,26 @@
 				src.DeleteNSlotsAt<0>(strict_ub,i);
 				return;
 				};
-#/*cut-nocpp*/
 		// more generally, we should recover any type-id; haven't checked how much we can do here
 		// this doesn't generalize fully to C
 		// do not have namespace available in CPP0X_type_or_invariant_decl_specifier_or_tag so can't punt there (unsure if this is worth a global)
 		// identifier might be type name: recover
 		if (0==pre_invariant_decl_scanner.count(STATIC_SIZE(CPP0X_nontype_decl_specifier_list)))
 			{
-			if (origin[pre_invariant_decl_scanner.size()].index_tokens[0].flags & C_TESTFLAG_IDENTIFIER)
+			parse_tree& tmp2 = src.c_array<0>()[i+pre_invariant_decl_scanner.size()];					
+			if (tmp2.is_atomic() && (tmp2.index_tokens[0].flags & C_TESTFLAG_IDENTIFIER))
 				{
-				parse_tree& tmp2 = src.c_array<0>()[i+k];					
 				{
-				type_system::type_index tmp = parse_tree::types->get_id_union_CPP(pre_invariant_decl_scanner.size()].index_tokens[0],active_namespace);
+				type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[0].token.first,active_namespace);
 				if (tmp)
+					{	// is an enum
+					tmp2.grab_index_token_from<1,0>(tmp2);
+					tmp2.set_index_token_from_str_literal<0>("enum");
+					assert(is_C99_named_specifier(tmp2,"enum"));
+					goto rescan;
+#if 0
+					}
+				else if (tmp = parse_tree::types->get_id_union_CPP(pre_invariant_decl_scanner.size()].index_tokens[0],active_namespace))
 					{	// is a union
 					tmp2.grab_index_token_from<1,0>(tmp2);
 					tmp2.set_index_token_from_str_literal<0>("union");
@@ -14408,24 +14416,19 @@
 					tmp2.set_index_token_from_str_literal<0>(text);
 					assert(is_C99_named_specifier(tmp2,text));
 					goto rescan;
-					}
-				else if (tmp = parse_tree::types->get_id_enum_CPP(pre_invariant_decl_scanner.size()].index_tokens[0],active_namespace))
-					{	// is an enum
-					tmp2.grab_index_token_from<1,0>(tmp2);
-					tmp2.set_index_token_from_str_literal<0>("enum");
-					assert(is_C99_named_specifier(tmp2,"enum"));
-					goto rescan;
+#endif
 					};
 				}
+#if 0
 				{
 				const zaimoni::POD_triple<type_spec,const char*,size_t>* const tmp = parse_tree::types->get_typedef_CPP(pre_invariant_decl_scanner.size()].index_tokens[0],active_namespace);
 				if (tmp)
 					{
 					}
 				}
+#endif
 				}
 			}
-#/*cut-nocpp*/
 		}
 		if (!pre_invariant_decl_scanner.empty())
 			{
@@ -14519,7 +14522,7 @@
 					pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -14638,7 +14641,7 @@
 					pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -14771,7 +14774,7 @@
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_struct.hpp
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -14888,7 +14891,7 @@
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_struct2.hpp
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -15019,7 +15022,7 @@
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_class.hpp
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -15135,7 +15138,7 @@
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_as_class2.hpp
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -15264,7 +15267,7 @@
 				case ENUM_NAMED_DEF:
 				{	// can only define once
 				parse_tree& tmp2 = src.c_array<0>()[i+k]; 
-				if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_enum_multidef.hpp
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -15328,7 +15331,7 @@
 				//! \test zcc/decl.C99/Pass_enum_def.hpp
 				// enum-specifier doesn't have a specific declaration mode
 				const type_system::type_index tmp3 = parse_tree::types->register_enum_def_CPP(tmp2.index_tokens[1].token.first,active_namespace,tmp2.index_tokens[1].logical_line,tmp2.index_tokens[1].src_filename);
-				assert(parse_tree::types->get_id_enum_CPP(tmp2.index_tokens[1].token.first,active_namespace)==tmp3);
+				assert(parse_tree::types->get_id_enum_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace)==tmp3);
 				tmp2.type_code.set_type(tmp3);	// C++: enums are own type
 				tmp2.flags |= PARSE_ENUM_TYPE;
 				if (!record_enum_values(*tmp2.c_array<2>(),tmp3,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))

Added: trunk/tests/zcc/decl.C99/Pass_enum_def2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_def2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Pass_enum_def2.hpp	2011-01-23 01:59:53 UTC (rev 585)
@@ -0,0 +1,136 @@
+// decl.C99\Pass_enum_def2.hpp
+// using singly defined enum
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+
+enum good_test {
+	x_factor = 1
+};
+
+// this section checks that suppressing enum keyword works
+// ringing the changes on extern
+extern good_test x1;
+extern const good_test x2;
+extern volatile good_test x3;
+extern const volatile good_test x4;
+extern volatile const good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static good_test x6;
+static volatile good_test x7;
+static const volatile good_test x8;
+static volatile const good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern good_test x10;
+volatile extern good_test x11;
+const extern volatile good_test x12;
+const volatile extern good_test x13;
+volatile extern const good_test x14;
+volatile const extern good_test x15;
+
+volatile static good_test x16;
+const static volatile good_test x17;
+const volatile static good_test x18;
+volatile static const good_test x19;
+volatile const static good_test x20;
+
+// check that things work properly in namespaces
+namespace test {
+enum good_test {
+	x_factor = 1
+};
+
+// ringing the changes on extern
+extern enum good_test x1;
+extern const enum good_test x2;
+extern volatile enum good_test x3;
+extern const volatile enum good_test x4;
+extern volatile const enum good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static enum good_test x6;
+static volatile enum good_test x7;
+static const volatile enum good_test x8;
+static volatile const enum good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern enum good_test x10;
+volatile extern enum good_test x11;
+const extern volatile enum good_test x12;
+const volatile extern enum good_test x13;
+volatile extern const enum good_test x14;
+volatile const extern enum good_test x15;
+
+volatile static enum good_test x16;
+const static volatile enum good_test x17;
+const volatile static enum good_test x18;
+volatile static const enum good_test x19;
+volatile const static enum good_test x20;
+
+// define-declares
+// ringing the changes on extern
+extern enum good_test2 { x_factor2 = 1 } x21;
+extern const enum good_test3 { x_factor3 = 1 } x22;
+extern volatile enum good_test4 { x_factor4 = 1 } x23;
+extern const volatile enum good_test5 { x_factor5 = 1 } x24;
+extern volatile const enum good_test6 { x_factor6 = 1 } x25;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static enum good_test7 { x_factor7 = 1 } x26;
+static volatile enum good_test8 { x_factor8 = 1 } x27;
+static const volatile enum good_test9 { x_factor9 = 1 } x28;
+static volatile const enum good_test10 { x_factor10 = 1 } x29;
+
+// extern/static not in first postion is deprecated, but legal
+const extern enum good_test11 { x_factor11 = 1 } x30;
+volatile extern enum good_test12 { x_factor12 = 1 } x31;
+const extern volatile enum good_test13 { x_factor13 = 1 } x32;
+const volatile extern enum good_test14 { x_factor14 = 1 } x33;
+volatile extern const enum good_test15 { x_factor15 = 1 } x34;
+volatile const extern enum good_test16 { x_factor16 = 1 } x35;
+
+volatile static enum good_test17 { x_factor17 = 1 } x16;
+const static volatile enum good_test18 { x_factor18 = 1 } x37;
+const volatile static enum good_test19 { x_factor19 = 1 } x38;
+volatile static const enum good_test20 { x_factor20 = 1 } x39;
+volatile const static enum good_test21 { x_factor21 = 1 } x40;
+}	// end namespace test
+
+// check that enum suppression works in namespaces
+namespace test2 {
+enum good_test {
+	x_factor = 1
+};
+
+// ringing the changes on extern
+extern good_test x1;
+extern const good_test x2;
+extern volatile good_test x3;
+extern const volatile good_test x4;
+extern volatile const good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static good_test x6;
+static volatile good_test x7;
+static const volatile good_test x8;
+static volatile const good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern good_test x10;
+volatile extern good_test x11;
+const extern volatile good_test x12;
+const volatile extern good_test x13;
+volatile extern const good_test x14;
+volatile const extern good_test x15;
+
+volatile static good_test x16;
+const static volatile good_test x17;
+const volatile static good_test x18;
+volatile static const good_test x19;
+volatile const static good_test x20;
+
+}	// end namespace test2

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2011-01-22 21:07:14 UTC (rev 584)
+++ trunk/type_system.cpp	2011-01-23 01:59:53 UTC (rev 585)
@@ -259,6 +259,22 @@
 	return _get_id_enum_CPP(alias);
 }
 
+// for checking for pre-existing type system definitions
+type_system::type_index
+type_system::get_id_enum_CPP_exact(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+	assert(!strstr(alias,"::"));
+	
+	if (active_namespace && *active_namespace)
+		{	// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		const type_index tmp2 = is_string_registered(tmp_alias) ? _get_id_enum(tmp_alias) : 0;
+		return (free(tmp_alias),tmp2);
+		}
+	return _get_id_enum(alias);
+}
+
 void type_system::use_type(type_index id)
 {
 	assert(core_types_size+dynamic_types.size()>=id);

Modified: trunk/type_system.cpp.in
===================================================================
--- trunk/type_system.cpp.in	2011-01-22 21:07:14 UTC (rev 584)
+++ trunk/type_system.cpp.in	2011-01-23 01:59:53 UTC (rev 585)
@@ -270,6 +270,22 @@
 	return _get_id_enum_CPP(alias);
 }
 
+// for checking for pre-existing type system definitions
+type_system::type_index
+type_system::get_id_enum_CPP_exact(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+	assert(!strstr(alias,"::"));
+	
+	if (active_namespace && *active_namespace)
+		{	// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		const type_index tmp2 = is_string_registered(tmp_alias) ? _get_id_enum(tmp_alias) : 0;
+		return (free(tmp_alias),tmp2);
+		}
+	return _get_id_enum(alias);
+}
+
 void type_system::use_type(type_index id)
 {
 	assert(core_types_size+dynamic_types.size()>=id);

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2011-01-22 21:07:14 UTC (rev 584)
+++ trunk/type_system.hpp	2011-01-23 01:59:53 UTC (rev 585)
@@ -60,6 +60,7 @@
 		return _get_id_enum(x);
 		}
 	type_index get_id_enum_CPP(const char* alias,const char* active_namespace) const;
+	type_index get_id_enum_CPP_exact(const char* alias,const char* active_namespace) const;
 	void use_type(type_index id);
 	void unuse_type(type_index id);
 	size_t use_count(type_index id) const

Modified: trunk/type_system.hpp.in
===================================================================
--- trunk/type_system.hpp.in	2011-01-22 21:07:14 UTC (rev 584)
+++ trunk/type_system.hpp.in	2011-01-23 01:59:53 UTC (rev 585)
@@ -75,6 +75,7 @@
 		return _get_id_enum(x);
 		}
 	type_index get_id_enum_CPP(const char* alias,const char* active_namespace) const;
+	type_index get_id_enum_CPP_exact(const char* alias,const char* active_namespace) const;
 	void use_type(type_index id);
 	void unuse_type(type_index id);
 	size_t use_count(type_index id) const



From zaimoni at mail.berlios.de  Sun Jan 23 21:16:05 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 23 Jan 2011 21:16:05 +0100
Subject: [Zcplusplus-commits] r586 - in trunk/tests: zcc/decl.C99
	zcc.in/decl.C99
Message-ID: <20110123201605.AB0E4481275@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-23 21:16:05 +0100 (Sun, 23 Jan 2011)
New Revision: 586

Modified:
   trunk/tests/zcc.in/decl.C99/Error_enum_runon_def.in
   trunk/tests/zcc/decl.C99/Error_enum_runon_def.h
   trunk/tests/zcc/decl.C99/Error_enum_runon_def.hpp
Log:
copyright date fixup

Modified: trunk/tests/zcc/decl.C99/Error_enum_runon_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_runon_def.h	2011-01-23 01:59:53 UTC (rev 585)
+++ trunk/tests/zcc/decl.C99/Error_enum_runon_def.h	2011-01-23 20:16:05 UTC (rev 586)
@@ -1,6 +1,6 @@
 // decl.C99\Error_enum_runon_def.h
 // using singly defined enum
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2010 Kenneth Boyd, license: MIT.txt
 
 enum bad_test {
 	x_factor = 1

Modified: trunk/tests/zcc/decl.C99/Error_enum_runon_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_runon_def.hpp	2011-01-23 01:59:53 UTC (rev 585)
+++ trunk/tests/zcc/decl.C99/Error_enum_runon_def.hpp	2011-01-23 20:16:05 UTC (rev 586)
@@ -1,6 +1,6 @@
 // decl.C99\Error_enum_runon_def.hpp
 // using singly defined enum
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2010 Kenneth Boyd, license: MIT.txt
 
 enum bad_test {
 	x_factor = 1

Modified: trunk/tests/zcc.in/decl.C99/Error_enum_runon_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_runon_def.in	2011-01-23 01:59:53 UTC (rev 585)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_runon_def.in	2011-01-23 20:16:05 UTC (rev 586)
@@ -1,6 +1,6 @@
 SUFFIXES h hpp
 // using singly defined enum
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2010 Kenneth Boyd, license: MIT.txt
 
 enum bad_test {
 	x_factor = 1



From zaimoni at mail.berlios.de  Sun Jan 23 21:34:09 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 23 Jan 2011 21:34:09 +0100
Subject: [Zcplusplus-commits] r587 - in trunk/tests: zcc/decl.C99
	zcc.in/decl.C99
Message-ID: <20110123203409.452EC4812D7@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-23 21:34:08 +0100 (Sun, 23 Jan 2011)
New Revision: 587

Modified:
   trunk/tests/zcc.in/decl.C99/Error_enum_runon_def.in
   trunk/tests/zcc.in/decl.C99/Pass_enum_def.in
   trunk/tests/zcc/decl.C99/Error_enum_runon_def.h
   trunk/tests/zcc/decl.C99/Error_enum_runon_def.hpp
   trunk/tests/zcc/decl.C99/Pass_enum_def.h
   trunk/tests/zcc/decl.C99/Pass_enum_def.hpp
Log:
copyright date fixup

Modified: trunk/tests/zcc/decl.C99/Error_enum_runon_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_runon_def.h	2011-01-23 20:16:05 UTC (rev 586)
+++ trunk/tests/zcc/decl.C99/Error_enum_runon_def.h	2011-01-23 20:34:08 UTC (rev 587)
@@ -1,6 +1,6 @@
 // decl.C99\Error_enum_runon_def.h
 // using singly defined enum
-// (C)2010 Kenneth Boyd, license: MIT.txt
+// (C)2011 Kenneth Boyd, license: MIT.txt
 
 enum bad_test {
 	x_factor = 1

Modified: trunk/tests/zcc/decl.C99/Error_enum_runon_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_runon_def.hpp	2011-01-23 20:16:05 UTC (rev 586)
+++ trunk/tests/zcc/decl.C99/Error_enum_runon_def.hpp	2011-01-23 20:34:08 UTC (rev 587)
@@ -1,6 +1,6 @@
 // decl.C99\Error_enum_runon_def.hpp
 // using singly defined enum
-// (C)2010 Kenneth Boyd, license: MIT.txt
+// (C)2011 Kenneth Boyd, license: MIT.txt
 
 enum bad_test {
 	x_factor = 1

Modified: trunk/tests/zcc/decl.C99/Pass_enum_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_def.h	2011-01-23 20:16:05 UTC (rev 586)
+++ trunk/tests/zcc/decl.C99/Pass_enum_def.h	2011-01-23 20:34:08 UTC (rev 587)
@@ -1,6 +1,6 @@
 // decl.C99\Pass_enum_def.h
 // using singly defined enum
-// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 enum good_test {
 	x_factor = 1

Modified: trunk/tests/zcc/decl.C99/Pass_enum_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_def.hpp	2011-01-23 20:16:05 UTC (rev 586)
+++ trunk/tests/zcc/decl.C99/Pass_enum_def.hpp	2011-01-23 20:34:08 UTC (rev 587)
@@ -1,6 +1,6 @@
 // decl.C99\Pass_enum_def.hpp
 // using singly defined enum
-// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 enum good_test {
 	x_factor = 1

Modified: trunk/tests/zcc.in/decl.C99/Error_enum_runon_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_runon_def.in	2011-01-23 20:16:05 UTC (rev 586)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_runon_def.in	2011-01-23 20:34:08 UTC (rev 587)
@@ -1,6 +1,6 @@
 SUFFIXES h hpp
 // using singly defined enum
-// (C)2010 Kenneth Boyd, license: MIT.txt
+// (C)2011 Kenneth Boyd, license: MIT.txt
 
 enum bad_test {
 	x_factor = 1

Modified: trunk/tests/zcc.in/decl.C99/Pass_enum_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_enum_def.in	2011-01-23 20:16:05 UTC (rev 586)
+++ trunk/tests/zcc.in/decl.C99/Pass_enum_def.in	2011-01-23 20:34:08 UTC (rev 587)
@@ -1,6 +1,6 @@
 SUFFIXES h hpp
 // using singly defined enum
-// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 enum good_test {
 	x_factor = 1



From zaimoni at mail.berlios.de  Mon Jan 24 00:40:47 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 24 Jan 2011 00:40:47 +0100
Subject: [Zcplusplus-commits] r588 - in trunk: . tests/zcc/decl.C99
	tests/zcc.in/decl.C99
Message-ID: <20110123234047.E72374812E1@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-24 00:40:47 +0100 (Mon, 24 Jan 2011)
New Revision: 588

Added:
   trunk/tests/zcc.in/decl.C99/Error_struct_runon_def.in
   trunk/tests/zcc.in/decl.C99/Error_union_runon_def.in
   trunk/tests/zcc/decl.C99/Error_class_runon_def.hpp
   trunk/tests/zcc/decl.C99/Error_struct_runon_def.h
   trunk/tests/zcc/decl.C99/Error_struct_runon_def.hpp
   trunk/tests/zcc/decl.C99/Error_union_runon_def.h
   trunk/tests/zcc/decl.C99/Error_union_runon_def.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
verify error for run-on definitions of struct, class, union

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-23 20:34:08 UTC (rev 587)
+++ trunk/CSupport.cpp	2011-01-23 23:40:47 UTC (rev 588)
@@ -10536,6 +10536,7 @@
 			//! \test decl.C99/Warn_dup_const2.hpp
 			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
 			src.DeleteIdx<0>(i-- +offset);
+			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
 			continue;
 		case C99_CPP_VOLATILE_IDX:
@@ -10545,10 +10546,11 @@
 			//! \test decl.C99/Warn_dup_volatile2.hpp
 			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
 			src.DeleteIdx<0>(i-- +offset);
+			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
 			continue;
 		default:
-			if (invariant_decl_scanner.strict_ub()-1==invariant_decl_scanner[offset-1])
+			if (0<offset && invariant_decl_scanner.strict_ub()-1==invariant_decl_scanner[offset-1])
 				{
 				if (!have_warned_too_many_types)
 					{
@@ -10559,6 +10561,7 @@
 					have_warned_too_many_types = true;
 					}
 				src.DeleteIdx<0>(i-- +offset);
+				assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 				invariant_decl_scanner.DeleteIdx(offset);
 				continue;
 				}
@@ -10576,6 +10579,7 @@
 			//! \test decl.C99/Warn_dup_const3.hpp
 			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
 			src.DeleteIdx<0>(i+offset);
+			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
 			continue;
 		case C99_CPP_VOLATILE_IDX:
@@ -10585,6 +10589,7 @@
 			//! \test decl.C99/Warn_dup_volatile3.hpp
 			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
 			src.DeleteIdx<0>(i+offset);
+			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
 			continue;
 		default:
@@ -10599,6 +10604,7 @@
 					have_warned_too_many_types = true;
 					}
 				src.DeleteIdx<0>(i-- +offset);
+				assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 				invariant_decl_scanner.DeleteIdx(offset);
 				continue;
 				}

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-23 20:34:08 UTC (rev 587)
+++ trunk/CSupport.cpp.in	2011-01-23 23:40:47 UTC (rev 588)
@@ -10672,6 +10672,7 @@
 			//! \test decl.C99/Warn_dup_const2.hpp
 			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
 			src.DeleteIdx<0>(i-- +offset);
+			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
 			continue;
 		case C99_CPP_VOLATILE_IDX:
@@ -10681,10 +10682,11 @@
 			//! \test decl.C99/Warn_dup_volatile2.hpp
 			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
 			src.DeleteIdx<0>(i-- +offset);
+			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
 			continue;
 		default:
-			if (invariant_decl_scanner.strict_ub()-1==invariant_decl_scanner[offset-1])
+			if (0<offset && invariant_decl_scanner.strict_ub()-1==invariant_decl_scanner[offset-1])
 				{
 				if (!have_warned_too_many_types)
 					{
@@ -10695,6 +10697,7 @@
 					have_warned_too_many_types = true;
 					}
 				src.DeleteIdx<0>(i-- +offset);
+				assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 				invariant_decl_scanner.DeleteIdx(offset);
 				continue;
 				}
@@ -10712,6 +10715,7 @@
 			//! \test decl.C99/Warn_dup_const3.hpp
 			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
 			src.DeleteIdx<0>(i+offset);
+			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
 			continue;
 		case C99_CPP_VOLATILE_IDX:
@@ -10721,6 +10725,7 @@
 			//! \test decl.C99/Warn_dup_volatile3.hpp
 			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
 			src.DeleteIdx<0>(i+offset);
+			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
 			continue;
 		default:
@@ -10735,6 +10740,7 @@
 					have_warned_too_many_types = true;
 					}
 				src.DeleteIdx<0>(i-- +offset);
+				assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 				invariant_decl_scanner.DeleteIdx(offset);
 				continue;
 				}

Added: trunk/tests/zcc/decl.C99/Error_class_runon_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_runon_def.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_runon_def.hpp	2011-01-23 23:40:47 UTC (rev 588)
@@ -0,0 +1,11 @@
+// decl.C99\Error_class_runon_def.hpp
+// using singly defined class
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+class bad_test {
+	int x_factor;
+};
+
+// ringing the changes on extern
+extern class bad_test x1
+extern const class bad_test x2;

Added: trunk/tests/zcc/decl.C99/Error_struct_runon_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_runon_def.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_runon_def.h	2011-01-23 23:40:47 UTC (rev 588)
@@ -0,0 +1,11 @@
+// decl.C99\Error_struct_runon_def.h
+// using singly defined struct
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+struct bad_test {
+	int x_factor;
+};
+
+// ringing the changes on extern
+extern struct bad_test x1
+extern const struct bad_test x2;

Added: trunk/tests/zcc/decl.C99/Error_struct_runon_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_runon_def.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_runon_def.hpp	2011-01-23 23:40:47 UTC (rev 588)
@@ -0,0 +1,11 @@
+// decl.C99\Error_struct_runon_def.hpp
+// using singly defined struct
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+struct bad_test {
+	int x_factor;
+};
+
+// ringing the changes on extern
+extern struct bad_test x1
+extern const struct bad_test x2;

Added: trunk/tests/zcc/decl.C99/Error_union_runon_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_runon_def.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_runon_def.h	2011-01-23 23:40:47 UTC (rev 588)
@@ -0,0 +1,11 @@
+// decl.C99\Error_union_runon_def.h
+// using singly defined union
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+union bad_test {
+	int x_factor;
+};
+
+// ringing the changes on extern
+extern union bad_test x1
+extern const union bad_test x2;

Added: trunk/tests/zcc/decl.C99/Error_union_runon_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_runon_def.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_runon_def.hpp	2011-01-23 23:40:47 UTC (rev 588)
@@ -0,0 +1,11 @@
+// decl.C99\Error_union_runon_def.hpp
+// using singly defined union
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+union bad_test {
+	int x_factor;
+};
+
+// ringing the changes on extern
+extern union bad_test x1
+extern const union bad_test x2;

Added: trunk/tests/zcc.in/decl.C99/Error_struct_runon_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_struct_runon_def.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_struct_runon_def.in	2011-01-23 23:40:47 UTC (rev 588)
@@ -0,0 +1,11 @@
+SUFFIXES h hpp
+// using singly defined struct
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+struct bad_test {
+	int x_factor;
+};
+
+// ringing the changes on extern
+extern struct bad_test x1
+extern const struct bad_test x2;

Added: trunk/tests/zcc.in/decl.C99/Error_union_runon_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_union_runon_def.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_union_runon_def.in	2011-01-23 23:40:47 UTC (rev 588)
@@ -0,0 +1,11 @@
+SUFFIXES h hpp
+// using singly defined union
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+union bad_test {
+	int x_factor;
+};
+
+// ringing the changes on extern
+extern union bad_test x1
+extern const union bad_test x2;



From zaimoni at mail.berlios.de  Mon Jan 24 18:39:07 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 24 Jan 2011 18:39:07 +0100
Subject: [Zcplusplus-commits] r589 - trunk
Message-ID: <20110124173907.BCBF2481290@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-24 18:39:07 +0100 (Mon, 24 Jan 2011)
New Revision: 589

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
stop an assert blocking a test case from triggering

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-23 23:40:47 UTC (rev 588)
+++ trunk/CSupport.cpp	2011-01-24 17:39:07 UTC (rev 589)
@@ -10522,10 +10522,13 @@
 	bool have_warned_about_const = false;
 	bool have_warned_about_volatile = false;
 
-	assert(src.size<0>()>i);
-	assert(src.size<0>()-i>=invariant_decl_scanner.size());
-	assert(invariant_decl_scanner.size()>k);
-	assert(PARSE_TYPE & src.data<0>()[i+k].flags);
+#define INVARIANT()	\
+	assert(src.size<0>()>i);	\
+	assert(src.size<0>()-i>=invariant_decl_scanner.size());	\
+	assert(invariant_decl_scanner.size()>k);	\
+	assert(PARSE_TYPE & src.data<0>()[i+k].flags)
+	
+	INVARIANT();
 	while(k>offset)
 		switch(invariant_decl_scanner[offset])
 		{
@@ -10536,8 +10539,9 @@
 			//! \test decl.C99/Warn_dup_const2.hpp
 			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
 			src.DeleteIdx<0>(i-- +offset);
-			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
+			if (invariant_decl_scanner.size()<=k) return;
+			INVARIANT();
 			continue;
 		case C99_CPP_VOLATILE_IDX:
 			//! \test decl.C99/Warn_dup_volatile.h
@@ -10546,8 +10550,9 @@
 			//! \test decl.C99/Warn_dup_volatile2.hpp
 			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
 			src.DeleteIdx<0>(i-- +offset);
-			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
+			if (invariant_decl_scanner.size()<=k) return;
+			INVARIANT();
 			continue;
 		default:
 			if (0<offset && invariant_decl_scanner.strict_ub()-1==invariant_decl_scanner[offset-1])
@@ -10561,8 +10566,9 @@
 					have_warned_too_many_types = true;
 					}
 				src.DeleteIdx<0>(i-- +offset);
-				assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 				invariant_decl_scanner.DeleteIdx(offset);
+				if (invariant_decl_scanner.size()<=k) return;
+				INVARIANT();
 				continue;
 				}
 			++offset;
@@ -10579,8 +10585,8 @@
 			//! \test decl.C99/Warn_dup_const3.hpp
 			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
 			src.DeleteIdx<0>(i+offset);
-			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
+			INVARIANT();
 			continue;
 		case C99_CPP_VOLATILE_IDX:
 			//! \test decl.C99/Warn_dup_volatile2.h
@@ -10589,8 +10595,8 @@
 			//! \test decl.C99/Warn_dup_volatile3.hpp
 			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
 			src.DeleteIdx<0>(i+offset);
-			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
+			INVARIANT();
 			continue;
 		default:
 			if (invariant_decl_scanner.strict_ub()-1==invariant_decl_scanner[offset-1])
@@ -10604,8 +10610,8 @@
 					have_warned_too_many_types = true;
 					}
 				src.DeleteIdx<0>(i-- +offset);
-				assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 				invariant_decl_scanner.DeleteIdx(offset);
+				INVARIANT();
 				continue;
 				}
 			++offset;

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-23 23:40:47 UTC (rev 588)
+++ trunk/CSupport.cpp.in	2011-01-24 17:39:07 UTC (rev 589)
@@ -10658,10 +10658,13 @@
 	bool have_warned_about_const = false;
 	bool have_warned_about_volatile = false;
 
-	assert(src.size<0>()>i);
-	assert(src.size<0>()-i>=invariant_decl_scanner.size());
-	assert(invariant_decl_scanner.size()>k);
-	assert(PARSE_TYPE & src.data<0>()[i+k].flags);
+#define INVARIANT()	\
+	assert(src.size<0>()>i);	\
+	assert(src.size<0>()-i>=invariant_decl_scanner.size());	\
+	assert(invariant_decl_scanner.size()>k);	\
+	assert(PARSE_TYPE & src.data<0>()[i+k].flags)
+	
+	INVARIANT();
 	while(k>offset)
 		switch(invariant_decl_scanner[offset])
 		{
@@ -10672,8 +10675,9 @@
 			//! \test decl.C99/Warn_dup_const2.hpp
 			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
 			src.DeleteIdx<0>(i-- +offset);
-			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
+			if (invariant_decl_scanner.size()<=k) return;
+			INVARIANT();
 			continue;
 		case C99_CPP_VOLATILE_IDX:
 			//! \test decl.C99/Warn_dup_volatile.h
@@ -10682,8 +10686,9 @@
 			//! \test decl.C99/Warn_dup_volatile2.hpp
 			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
 			src.DeleteIdx<0>(i-- +offset);
-			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
+			if (invariant_decl_scanner.size()<=k) return;
+			INVARIANT();
 			continue;
 		default:
 			if (0<offset && invariant_decl_scanner.strict_ub()-1==invariant_decl_scanner[offset-1])
@@ -10697,8 +10702,9 @@
 					have_warned_too_many_types = true;
 					}
 				src.DeleteIdx<0>(i-- +offset);
-				assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 				invariant_decl_scanner.DeleteIdx(offset);
+				if (invariant_decl_scanner.size()<=k) return;
+				INVARIANT();
 				continue;
 				}
 			++offset;
@@ -10715,8 +10721,8 @@
 			//! \test decl.C99/Warn_dup_const3.hpp
 			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
 			src.DeleteIdx<0>(i+offset);
-			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
+			INVARIANT();
 			continue;
 		case C99_CPP_VOLATILE_IDX:
 			//! \test decl.C99/Warn_dup_volatile2.h
@@ -10725,8 +10731,8 @@
 			//! \test decl.C99/Warn_dup_volatile3.hpp
 			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
 			src.DeleteIdx<0>(i+offset);
-			assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 			invariant_decl_scanner.DeleteIdx(offset);
+			INVARIANT();
 			continue;
 		default:
 			if (invariant_decl_scanner.strict_ub()-1==invariant_decl_scanner[offset-1])
@@ -10740,8 +10746,8 @@
 					have_warned_too_many_types = true;
 					}
 				src.DeleteIdx<0>(i-- +offset);
-				assert(PARSE_TYPE & src.data<0>()[i+k].flags);
 				invariant_decl_scanner.DeleteIdx(offset);
+				INVARIANT();
 				continue;
 				}
 			++offset;



From zaimoni at mail.berlios.de  Mon Jan 24 19:00:08 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 24 Jan 2011 19:00:08 +0100
Subject: [Zcplusplus-commits] r590 - in trunk: . tests/zcc/decl.C99
	tests/zcc.in/decl.C99
Message-ID: <20110124180008.85BB248129B@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-24 19:00:07 +0100 (Mon, 24 Jan 2011)
New Revision: 590

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/tests/zcc.in/decl.C99/Pass_struct_def.in
   trunk/tests/zcc.in/decl.C99/Pass_union_def.in
   trunk/tests/zcc/decl.C99/Pass_class_def.hpp
   trunk/tests/zcc/decl.C99/Pass_struct_def.h
   trunk/tests/zcc/decl.C99/Pass_struct_def.hpp
   trunk/tests/zcc/decl.C99/Pass_union_def.h
   trunk/tests/zcc/decl.C99/Pass_union_def.hpp
Log:
test case augmentation

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-24 17:39:07 UTC (rev 589)
+++ trunk/CSupport.cpp	2011-01-24 18:00:07 UTC (rev 590)
@@ -13038,7 +13038,7 @@
 
 static void _forward_declare_C_union_preparsed(parse_tree& src, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
-	parse_tree& tmp = src.c_array<0>()[i];
+	parse_tree& tmp = src.c_array<0>()[i+k];
 #ifdef NDEBUG
 	tmp.type_code.set_type(parse_tree::types->register_structdecl(tmp.index_tokens[1].token.first,union_struct_decl::decl_union,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
 #else
@@ -13056,7 +13056,7 @@
 
 static void _forward_declare_C_struct_preparsed(parse_tree& src, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
-	parse_tree& tmp = src.c_array<0>()[i];
+	parse_tree& tmp = src.c_array<0>()[i+k];
 #ifdef NDEBUG
 	tmp.type_code.set_type(parse_tree::types->register_structdecl(tmp.index_tokens[1].token.first,union_struct_decl::decl_struct,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
 #else

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-24 17:39:07 UTC (rev 589)
+++ trunk/CSupport.cpp.in	2011-01-24 18:00:07 UTC (rev 590)
@@ -13182,7 +13182,7 @@
 
 static void _forward_declare_C_union_preparsed(parse_tree& src, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
-	parse_tree& tmp = src.c_array<0>()[i];
+	parse_tree& tmp = src.c_array<0>()[i+k];
 #ifdef NDEBUG
 	tmp.type_code.set_type(parse_tree::types->register_structdecl(tmp.index_tokens[1].token.first,union_struct_decl::decl_union,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
 #else
@@ -13200,7 +13200,7 @@
 
 static void _forward_declare_C_struct_preparsed(parse_tree& src, size_t& i, size_t& k, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
-	parse_tree& tmp = src.c_array<0>()[i];
+	parse_tree& tmp = src.c_array<0>()[i+k];
 #ifdef NDEBUG
 	tmp.type_code.set_type(parse_tree::types->register_structdecl(tmp.index_tokens[1].token.first,union_struct_decl::decl_struct,tmp.index_tokens[1].logical_line,tmp.index_tokens[1].src_filename));
 #else

Modified: trunk/tests/zcc/decl.C99/Pass_class_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_class_def.hpp	2011-01-24 17:39:07 UTC (rev 589)
+++ trunk/tests/zcc/decl.C99/Pass_class_def.hpp	2011-01-24 18:00:07 UTC (rev 590)
@@ -1,20 +1,65 @@
 // decl.C99\Pass_class_def.hpp
 // using singly defined struct
-// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010,2011 Kenneth Boyd, license: MIT.txt
 
 class good_test {
 	int x_factor;
 };
 
-// exercise some declarations
-class good_test x1;
-const class good_test c1;
-class good_test const c2;
-volatile class good_test v1;
-class good_test volatile v2;
-const volatile class good_test cv1;
-volatile const class good_test cv2;
-const class good_test volatile cv3;
-volatile class good_test const cv4;
-class good_test const volatile cv5;
-class good_test volatile const cv6;
+// ringing the changes on extern
+extern struct good_test x1;
+extern const struct good_test x2;
+extern volatile struct good_test x3;
+extern const volatile struct good_test x4;
+extern volatile const struct good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static struct good_test x6;
+static volatile struct good_test x7;
+static const volatile struct good_test x8;
+static volatile const struct good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern struct good_test x10;
+volatile extern struct good_test x11;
+const extern volatile struct good_test x12;
+const volatile extern struct good_test x13;
+volatile extern const struct good_test x14;
+volatile const extern struct good_test x15;
+
+volatile static struct good_test x16;
+const static volatile struct good_test x17;
+const volatile static struct good_test x18;
+volatile static const struct good_test x19;
+volatile const static struct good_test x20;
+
+// define-declares
+// ringing the changes on extern
+extern struct good_test2 { int x_factor2; } x21;
+extern const struct good_test3 { int x_factor3; } x22;
+extern volatile struct good_test4 { int x_factor4; } x23;
+extern const volatile struct good_test5 { int x_factor5; } x24;
+extern volatile const struct good_test6 { int x_factor6; } x25;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static struct good_test7 { int x_factor7; } x26;
+static volatile struct good_test8 { int x_factor8; } x27;
+static const volatile struct good_test9 { int x_factor9; } x28;
+static volatile const struct good_test10 { int x_factor10; } x29;
+
+// extern/static not in first postion is deprecated, but legal
+const extern struct good_test11 { int x_factor11; } x30;
+volatile extern struct good_test12 { int x_factor12; } x31;
+const extern volatile struct good_test13 { int x_factor13; } x32;
+const volatile extern struct good_test14 { int x_factor14; } x33;
+volatile extern const struct good_test15 { int x_factor15; } x34;
+volatile const extern struct good_test16 { int x_factor16; } x35;
+
+volatile static struct good_test17 { int x_factor17; } x16;
+const static volatile struct good_test18 { int x_factor18; } x37;
+const volatile static struct good_test19 { int x_factor19; } x38;
+volatile static const struct good_test20 { int x_factor20; } x39;
+volatile const static struct good_test21 { int x_factor21; } x40;
+

Modified: trunk/tests/zcc/decl.C99/Pass_struct_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_struct_def.h	2011-01-24 17:39:07 UTC (rev 589)
+++ trunk/tests/zcc/decl.C99/Pass_struct_def.h	2011-01-24 18:00:07 UTC (rev 590)
@@ -1,20 +1,65 @@
 // decl.C99\Pass_struct_def.h
 // using singly defined struct
-// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 struct good_test {
 	int x_factor;
 };
 
-// exercise some declarations
-struct good_test x1;
-const struct good_test c1;
-struct good_test const c2;
-volatile struct good_test v1;
-struct good_test volatile v2;
-const volatile struct good_test cv1;
-volatile const struct good_test cv2;
-const struct good_test volatile cv3;
-volatile struct good_test const cv4;
-struct good_test const volatile cv5;
-struct good_test volatile const cv6;
+// ringing the changes on extern
+extern struct good_test x1;
+extern const struct good_test x2;
+extern volatile struct good_test x3;
+extern const volatile struct good_test x4;
+extern volatile const struct good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static struct good_test x6;
+static volatile struct good_test x7;
+static const volatile struct good_test x8;
+static volatile const struct good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern struct good_test x10;
+volatile extern struct good_test x11;
+const extern volatile struct good_test x12;
+const volatile extern struct good_test x13;
+volatile extern const struct good_test x14;
+volatile const extern struct good_test x15;
+
+volatile static struct good_test x16;
+const static volatile struct good_test x17;
+const volatile static struct good_test x18;
+volatile static const struct good_test x19;
+volatile const static struct good_test x20;
+
+// define-declares
+// ringing the changes on extern
+extern struct good_test2 { int x_factor2; } x21;
+extern const struct good_test3 { int x_factor3; } x22;
+extern volatile struct good_test4 { int x_factor4; } x23;
+extern const volatile struct good_test5 { int x_factor5; } x24;
+extern volatile const struct good_test6 { int x_factor6; } x25;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static struct good_test7 { int x_factor7; } x26;
+static volatile struct good_test8 { int x_factor8; } x27;
+static const volatile struct good_test9 { int x_factor9; } x28;
+static volatile const struct good_test10 { int x_factor10; } x29;
+
+// extern/static not in first postion is deprecated, but legal
+const extern struct good_test11 { int x_factor11; } x30;
+volatile extern struct good_test12 { int x_factor12; } x31;
+const extern volatile struct good_test13 { int x_factor13; } x32;
+const volatile extern struct good_test14 { int x_factor14; } x33;
+volatile extern const struct good_test15 { int x_factor15; } x34;
+volatile const extern struct good_test16 { int x_factor16; } x35;
+
+volatile static struct good_test17 { int x_factor17; } x16;
+const static volatile struct good_test18 { int x_factor18; } x37;
+const volatile static struct good_test19 { int x_factor19; } x38;
+volatile static const struct good_test20 { int x_factor20; } x39;
+volatile const static struct good_test21 { int x_factor21; } x40;
+

Modified: trunk/tests/zcc/decl.C99/Pass_struct_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_struct_def.hpp	2011-01-24 17:39:07 UTC (rev 589)
+++ trunk/tests/zcc/decl.C99/Pass_struct_def.hpp	2011-01-24 18:00:07 UTC (rev 590)
@@ -1,20 +1,65 @@
 // decl.C99\Pass_struct_def.hpp
 // using singly defined struct
-// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 struct good_test {
 	int x_factor;
 };
 
-// exercise some declarations
-struct good_test x1;
-const struct good_test c1;
-struct good_test const c2;
-volatile struct good_test v1;
-struct good_test volatile v2;
-const volatile struct good_test cv1;
-volatile const struct good_test cv2;
-const struct good_test volatile cv3;
-volatile struct good_test const cv4;
-struct good_test const volatile cv5;
-struct good_test volatile const cv6;
+// ringing the changes on extern
+extern struct good_test x1;
+extern const struct good_test x2;
+extern volatile struct good_test x3;
+extern const volatile struct good_test x4;
+extern volatile const struct good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static struct good_test x6;
+static volatile struct good_test x7;
+static const volatile struct good_test x8;
+static volatile const struct good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern struct good_test x10;
+volatile extern struct good_test x11;
+const extern volatile struct good_test x12;
+const volatile extern struct good_test x13;
+volatile extern const struct good_test x14;
+volatile const extern struct good_test x15;
+
+volatile static struct good_test x16;
+const static volatile struct good_test x17;
+const volatile static struct good_test x18;
+volatile static const struct good_test x19;
+volatile const static struct good_test x20;
+
+// define-declares
+// ringing the changes on extern
+extern struct good_test2 { int x_factor2; } x21;
+extern const struct good_test3 { int x_factor3; } x22;
+extern volatile struct good_test4 { int x_factor4; } x23;
+extern const volatile struct good_test5 { int x_factor5; } x24;
+extern volatile const struct good_test6 { int x_factor6; } x25;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static struct good_test7 { int x_factor7; } x26;
+static volatile struct good_test8 { int x_factor8; } x27;
+static const volatile struct good_test9 { int x_factor9; } x28;
+static volatile const struct good_test10 { int x_factor10; } x29;
+
+// extern/static not in first postion is deprecated, but legal
+const extern struct good_test11 { int x_factor11; } x30;
+volatile extern struct good_test12 { int x_factor12; } x31;
+const extern volatile struct good_test13 { int x_factor13; } x32;
+const volatile extern struct good_test14 { int x_factor14; } x33;
+volatile extern const struct good_test15 { int x_factor15; } x34;
+volatile const extern struct good_test16 { int x_factor16; } x35;
+
+volatile static struct good_test17 { int x_factor17; } x16;
+const static volatile struct good_test18 { int x_factor18; } x37;
+const volatile static struct good_test19 { int x_factor19; } x38;
+volatile static const struct good_test20 { int x_factor20; } x39;
+volatile const static struct good_test21 { int x_factor21; } x40;
+

Modified: trunk/tests/zcc/decl.C99/Pass_union_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_union_def.h	2011-01-24 17:39:07 UTC (rev 589)
+++ trunk/tests/zcc/decl.C99/Pass_union_def.h	2011-01-24 18:00:07 UTC (rev 590)
@@ -1,20 +1,65 @@
 // decl.C99\Pass_union_def.h
 // using singly defined union
-// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 union good_test {
 	int x_factor;
 };
 
-// exercise some declarations
-union good_test x1;
-const union good_test c1;
-union good_test const c2;
-volatile union good_test v1;
-union good_test volatile v2;
-const volatile union good_test cv1;
-volatile const union good_test cv2;
-const union good_test volatile cv3;
-volatile union good_test const cv4;
-union good_test const volatile cv5;
-union good_test volatile const cv6;
+// ringing the changes on extern
+extern union good_test x1;
+extern const union good_test x2;
+extern volatile union good_test x3;
+extern const volatile union good_test x4;
+extern volatile const union good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static union good_test x6;
+static volatile union good_test x7;
+static const volatile union good_test x8;
+static volatile const union good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern union good_test x10;
+volatile extern union good_test x11;
+const extern volatile union good_test x12;
+const volatile extern union good_test x13;
+volatile extern const union good_test x14;
+volatile const extern union good_test x15;
+
+volatile static union good_test x16;
+const static volatile union good_test x17;
+const volatile static union good_test x18;
+volatile static const union good_test x19;
+volatile const static union good_test x20;
+
+// define-declares
+// ringing the changes on extern
+extern union good_test2 { int x_factor2; } x21;
+extern const union good_test3 { int x_factor3; } x22;
+extern volatile union good_test4 { int x_factor4; } x23;
+extern const volatile union good_test5 { int x_factor5; } x24;
+extern volatile const union good_test6 { int x_factor6; } x25;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static union good_test7 { int x_factor7; } x26;
+static volatile union good_test8 { int x_factor8; } x27;
+static const volatile union good_test9 { int x_factor9; } x28;
+static volatile const union good_test10 { int x_factor10; } x29;
+
+// extern/static not in first postion is deprecated, but legal
+const extern union good_test11 { int x_factor11; } x30;
+volatile extern union good_test12 { int x_factor12; } x31;
+const extern volatile union good_test13 { int x_factor13; } x32;
+const volatile extern union good_test14 { int x_factor14; } x33;
+volatile extern const union good_test15 { int x_factor15; } x34;
+volatile const extern union good_test16 { int x_factor16; } x35;
+
+volatile static union good_test17 { int x_factor17; } x16;
+const static volatile union good_test18 { int x_factor18; } x37;
+const volatile static union good_test19 { int x_factor19; } x38;
+volatile static const union good_test20 { int x_factor20; } x39;
+volatile const static union good_test21 { int x_factor21; } x40;
+

Modified: trunk/tests/zcc/decl.C99/Pass_union_def.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_union_def.hpp	2011-01-24 17:39:07 UTC (rev 589)
+++ trunk/tests/zcc/decl.C99/Pass_union_def.hpp	2011-01-24 18:00:07 UTC (rev 590)
@@ -1,21 +1,65 @@
 // decl.C99\Pass_union_def.hpp
 // using singly defined union
-// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 union good_test {
 	int x_factor;
 };
 
-// exercise some declarations
-union good_test x1;
-const union good_test c1;
-union good_test const c2;
-volatile union good_test v1;
-union good_test volatile v2;
-const volatile union good_test cv1;
-volatile const union good_test cv2;
-const union good_test volatile cv3;
-volatile union good_test const cv4;
-union good_test const volatile cv5;
-union good_test volatile const cv6;
+// ringing the changes on extern
+extern union good_test x1;
+extern const union good_test x2;
+extern volatile union good_test x3;
+extern const volatile union good_test x4;
+extern volatile const union good_test x5;
 
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static union good_test x6;
+static volatile union good_test x7;
+static const volatile union good_test x8;
+static volatile const union good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern union good_test x10;
+volatile extern union good_test x11;
+const extern volatile union good_test x12;
+const volatile extern union good_test x13;
+volatile extern const union good_test x14;
+volatile const extern union good_test x15;
+
+volatile static union good_test x16;
+const static volatile union good_test x17;
+const volatile static union good_test x18;
+volatile static const union good_test x19;
+volatile const static union good_test x20;
+
+// define-declares
+// ringing the changes on extern
+extern union good_test2 { int x_factor2; } x21;
+extern const union good_test3 { int x_factor3; } x22;
+extern volatile union good_test4 { int x_factor4; } x23;
+extern const volatile union good_test5 { int x_factor5; } x24;
+extern volatile const union good_test6 { int x_factor6; } x25;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static union good_test7 { int x_factor7; } x26;
+static volatile union good_test8 { int x_factor8; } x27;
+static const volatile union good_test9 { int x_factor9; } x28;
+static volatile const union good_test10 { int x_factor10; } x29;
+
+// extern/static not in first postion is deprecated, but legal
+const extern union good_test11 { int x_factor11; } x30;
+volatile extern union good_test12 { int x_factor12; } x31;
+const extern volatile union good_test13 { int x_factor13; } x32;
+const volatile extern union good_test14 { int x_factor14; } x33;
+volatile extern const union good_test15 { int x_factor15; } x34;
+volatile const extern union good_test16 { int x_factor16; } x35;
+
+volatile static union good_test17 { int x_factor17; } x16;
+const static volatile union good_test18 { int x_factor18; } x37;
+const volatile static union good_test19 { int x_factor19; } x38;
+volatile static const union good_test20 { int x_factor20; } x39;
+volatile const static union good_test21 { int x_factor21; } x40;
+

Modified: trunk/tests/zcc.in/decl.C99/Pass_struct_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_struct_def.in	2011-01-24 17:39:07 UTC (rev 589)
+++ trunk/tests/zcc.in/decl.C99/Pass_struct_def.in	2011-01-24 18:00:07 UTC (rev 590)
@@ -1,8 +1,65 @@
 SUFFIXES h hpp
 // using singly defined struct
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 struct good_test {
 	int x_factor;
 };
 
+// ringing the changes on extern
+extern struct good_test x1;
+extern const struct good_test x2;
+extern volatile struct good_test x3;
+extern const volatile struct good_test x4;
+extern volatile const struct good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static struct good_test x6;
+static volatile struct good_test x7;
+static const volatile struct good_test x8;
+static volatile const struct good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern struct good_test x10;
+volatile extern struct good_test x11;
+const extern volatile struct good_test x12;
+const volatile extern struct good_test x13;
+volatile extern const struct good_test x14;
+volatile const extern struct good_test x15;
+
+volatile static struct good_test x16;
+const static volatile struct good_test x17;
+const volatile static struct good_test x18;
+volatile static const struct good_test x19;
+volatile const static struct good_test x20;
+
+// define-declares
+// ringing the changes on extern
+extern struct good_test2 { int x_factor2; } x21;
+extern const struct good_test3 { int x_factor3; } x22;
+extern volatile struct good_test4 { int x_factor4; } x23;
+extern const volatile struct good_test5 { int x_factor5; } x24;
+extern volatile const struct good_test6 { int x_factor6; } x25;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static struct good_test7 { int x_factor7; } x26;
+static volatile struct good_test8 { int x_factor8; } x27;
+static const volatile struct good_test9 { int x_factor9; } x28;
+static volatile const struct good_test10 { int x_factor10; } x29;
+
+// extern/static not in first postion is deprecated, but legal
+const extern struct good_test11 { int x_factor11; } x30;
+volatile extern struct good_test12 { int x_factor12; } x31;
+const extern volatile struct good_test13 { int x_factor13; } x32;
+const volatile extern struct good_test14 { int x_factor14; } x33;
+volatile extern const struct good_test15 { int x_factor15; } x34;
+volatile const extern struct good_test16 { int x_factor16; } x35;
+
+volatile static struct good_test17 { int x_factor17; } x16;
+const static volatile struct good_test18 { int x_factor18; } x37;
+const volatile static struct good_test19 { int x_factor19; } x38;
+volatile static const struct good_test20 { int x_factor20; } x39;
+volatile const static struct good_test21 { int x_factor21; } x40;
+

Modified: trunk/tests/zcc.in/decl.C99/Pass_union_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_union_def.in	2011-01-24 17:39:07 UTC (rev 589)
+++ trunk/tests/zcc.in/decl.C99/Pass_union_def.in	2011-01-24 18:00:07 UTC (rev 590)
@@ -1,8 +1,65 @@
 SUFFIXES h hpp
 // using singly defined union
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 union good_test {
 	int x_factor;
 };
 
+// ringing the changes on extern
+extern union good_test x1;
+extern const union good_test x2;
+extern volatile union good_test x3;
+extern const volatile union good_test x4;
+extern volatile const union good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static union good_test x6;
+static volatile union good_test x7;
+static const volatile union good_test x8;
+static volatile const union good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern union good_test x10;
+volatile extern union good_test x11;
+const extern volatile union good_test x12;
+const volatile extern union good_test x13;
+volatile extern const union good_test x14;
+volatile const extern union good_test x15;
+
+volatile static union good_test x16;
+const static volatile union good_test x17;
+const volatile static union good_test x18;
+volatile static const union good_test x19;
+volatile const static union good_test x20;
+
+// define-declares
+// ringing the changes on extern
+extern union good_test2 { int x_factor2; } x21;
+extern const union good_test3 { int x_factor3; } x22;
+extern volatile union good_test4 { int x_factor4; } x23;
+extern const volatile union good_test5 { int x_factor5; } x24;
+extern volatile const union good_test6 { int x_factor6; } x25;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static union good_test7 { int x_factor7; } x26;
+static volatile union good_test8 { int x_factor8; } x27;
+static const volatile union good_test9 { int x_factor9; } x28;
+static volatile const union good_test10 { int x_factor10; } x29;
+
+// extern/static not in first postion is deprecated, but legal
+const extern union good_test11 { int x_factor11; } x30;
+volatile extern union good_test12 { int x_factor12; } x31;
+const extern volatile union good_test13 { int x_factor13; } x32;
+const volatile extern union good_test14 { int x_factor14; } x33;
+volatile extern const union good_test15 { int x_factor15; } x34;
+volatile const extern union good_test16 { int x_factor16; } x35;
+
+volatile static union good_test17 { int x_factor17; } x16;
+const static volatile union good_test18 { int x_factor18; } x37;
+const volatile static union good_test19 { int x_factor19; } x38;
+volatile static const union good_test20 { int x_factor20; } x39;
+volatile const static union good_test21 { int x_factor21; } x40;
+



From zaimoni at mail.berlios.de  Mon Jan 24 19:20:40 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 24 Jan 2011 19:20:40 +0100
Subject: [Zcplusplus-commits] r591 - trunk/tests/zcc/decl.C99
Message-ID: <20110124182040.8A4EB481290@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-24 19:20:40 +0100 (Mon, 24 Jan 2011)
New Revision: 591

Modified:
   trunk/tests/zcc/decl.C99/Pass_enum_def2.hpp
Log:
copyright date fixup

Modified: trunk/tests/zcc/decl.C99/Pass_enum_def2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_def2.hpp	2011-01-24 18:00:07 UTC (rev 590)
+++ trunk/tests/zcc/decl.C99/Pass_enum_def2.hpp	2011-01-24 18:20:40 UTC (rev 591)
@@ -1,6 +1,6 @@
 // decl.C99\Pass_enum_def2.hpp
 // using singly defined enum
-// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 enum good_test {
 	x_factor = 1



From zaimoni at mail.berlios.de  Mon Jan 24 19:55:07 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 24 Jan 2011 19:55:07 +0100
Subject: [Zcplusplus-commits] r592 - in trunk: . tests/zcc/decl.C99
Message-ID: <20110124185508.390AD481290@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-24 19:55:07 +0100 (Mon, 24 Jan 2011)
New Revision: 592

Added:
   trunk/tests/zcc/decl.C99/Pass_union_def2.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/type_system.cpp
   trunk/type_system.cpp.in
   trunk/type_system.hpp
   trunk/type_system.hpp.in
Log:
exercise C++ unions in namespaces

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-24 18:20:40 UTC (rev 591)
+++ trunk/CSupport.cpp	2011-01-24 18:55:07 UTC (rev 592)
@@ -14266,16 +14266,16 @@
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					assert(is_C99_named_specifier(tmp2,"enum"));
 					goto rescan;
-#if 0
 					}
-				else if (tmp = parse_tree::types->get_id_union_CPP(pre_invariant_decl_scanner.size()].index_tokens[0],active_namespace))
+				else if (tmp = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[0].token.first,active_namespace))
 					{	// is a union
 					tmp2.grab_index_token_from<1,0>(tmp2);
 					tmp2.set_index_token_from_str_literal<0>("union");
 					assert(is_C99_named_specifier(tmp2,"union"));
 					goto rescan;
+#if 0
 					}
-				else if (tmp = parse_tree::types->get_id_struct_class_CPP(pre_invariant_decl_scanner.size()].index_tokens[0],active_namespace))
+				else if (tmp = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[0].token.first,active_namespace))
 					{	// is a struct/class
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(tmp);
 					assert(tmp3);
@@ -14459,7 +14459,7 @@
 //				break;
 				case UNION_NAMED_DEF:
 				{	// can only define once
-				const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				const type_system::type_index tmp = parse_tree::types->get_id_union_CPP_exact(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
 				{
 				parse_tree& tmp2 = src.c_array<0>()[i+k];					
 				if (tmp)
@@ -14624,7 +14624,7 @@
 					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_union_as_struct.hpp
 						//! \test zcc/decl.C99/Error_union_as_struct3.hpp
 					message_header(tmp2.index_tokens[0]);
@@ -14740,7 +14740,7 @@
 					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_union_as_struct2.hpp
 						//! \test zcc/decl.C99/Error_union_as_struct4.hpp
 					message_header(tmp2.index_tokens[0]);
@@ -14872,7 +14872,7 @@
 					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_union_as_class.hpp
 						//! \test zcc/decl.C99/Error_union_as_class3.hpp
 					message_header(tmp2.index_tokens[0]);
@@ -14987,7 +14987,7 @@
 					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_union_as_class2.hpp
 						//! \test zcc/decl.C99/Error_union_as_class4.hpp
 					message_header(tmp2.index_tokens[0]);
@@ -15153,7 +15153,7 @@
 					continue;
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_union_as_enum.hpp
 						//! \test zcc/decl.C99/Error_union_as_enum2.hpp
 					message_header(tmp2.index_tokens[0]);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-24 18:20:40 UTC (rev 591)
+++ trunk/CSupport.cpp.in	2011-01-24 18:55:07 UTC (rev 592)
@@ -14410,16 +14410,16 @@
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					assert(is_C99_named_specifier(tmp2,"enum"));
 					goto rescan;
-#if 0
 					}
-				else if (tmp = parse_tree::types->get_id_union_CPP(pre_invariant_decl_scanner.size()].index_tokens[0],active_namespace))
+				else if (tmp = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[0].token.first,active_namespace))
 					{	// is a union
 					tmp2.grab_index_token_from<1,0>(tmp2);
 					tmp2.set_index_token_from_str_literal<0>("union");
 					assert(is_C99_named_specifier(tmp2,"union"));
 					goto rescan;
+#if 0
 					}
-				else if (tmp = parse_tree::types->get_id_struct_class_CPP(pre_invariant_decl_scanner.size()].index_tokens[0],active_namespace))
+				else if (tmp = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[0].token.first,active_namespace))
 					{	// is a struct/class
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(tmp);
 					assert(tmp3);
@@ -14603,7 +14603,7 @@
 //				break;
 				case UNION_NAMED_DEF:
 				{	// can only define once
-				const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				const type_system::type_index tmp = parse_tree::types->get_id_union_CPP_exact(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
 				{
 				parse_tree& tmp2 = src.c_array<0>()[i+k];					
 				if (tmp)
@@ -14768,7 +14768,7 @@
 					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_union_as_struct.hpp
 						//! \test zcc/decl.C99/Error_union_as_struct3.hpp
 					message_header(tmp2.index_tokens[0]);
@@ -14884,7 +14884,7 @@
 					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_union_as_struct2.hpp
 						//! \test zcc/decl.C99/Error_union_as_struct4.hpp
 					message_header(tmp2.index_tokens[0]);
@@ -15016,7 +15016,7 @@
 					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_union_as_class.hpp
 						//! \test zcc/decl.C99/Error_union_as_class3.hpp
 					message_header(tmp2.index_tokens[0]);
@@ -15131,7 +15131,7 @@
 					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_union_as_class2.hpp
 						//! \test zcc/decl.C99/Error_union_as_class4.hpp
 					message_header(tmp2.index_tokens[0]);
@@ -15297,7 +15297,7 @@
 					continue;
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_union_as_enum.hpp
 						//! \test zcc/decl.C99/Error_union_as_enum2.hpp
 					message_header(tmp2.index_tokens[0]);

Added: trunk/tests/zcc/decl.C99/Pass_union_def2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_union_def2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Pass_union_def2.hpp	2011-01-24 18:55:07 UTC (rev 592)
@@ -0,0 +1,136 @@
+// decl.C99\Pass_union_def2.hpp
+// using singly defined union
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
+
+union good_test {
+	int x_factor;
+};
+
+// this section checks that suppressing union keyword works
+// ringing the changes on extern
+extern good_test x1;
+extern const good_test x2;
+extern volatile good_test x3;
+extern const volatile good_test x4;
+extern volatile const good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static good_test x6;
+static volatile good_test x7;
+static const volatile good_test x8;
+static volatile const good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern good_test x10;
+volatile extern good_test x11;
+const extern volatile good_test x12;
+const volatile extern good_test x13;
+volatile extern const good_test x14;
+volatile const extern good_test x15;
+
+volatile static good_test x16;
+const static volatile good_test x17;
+const volatile static good_test x18;
+volatile static const good_test x19;
+volatile const static good_test x20;
+
+// check that things work properly in namespaces
+namespace test {
+union good_test {
+	int x_factor;
+};
+
+// ringing the changes on extern
+extern union good_test x1;
+extern const union good_test x2;
+extern volatile union good_test x3;
+extern const volatile union good_test x4;
+extern volatile const union good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static union good_test x6;
+static volatile union good_test x7;
+static const volatile union good_test x8;
+static volatile const union good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern union good_test x10;
+volatile extern union good_test x11;
+const extern volatile union good_test x12;
+const volatile extern union good_test x13;
+volatile extern const union good_test x14;
+volatile const extern union good_test x15;
+
+volatile static union good_test x16;
+const static volatile union good_test x17;
+const volatile static union good_test x18;
+volatile static const union good_test x19;
+volatile const static union good_test x20;
+
+// define-declares
+// ringing the changes on extern
+extern union good_test2 { int x_factor2; } x21;
+extern const union good_test3 { int x_factor3; } x22;
+extern volatile union good_test4 { int x_factor4; } x23;
+extern const volatile union good_test5 { int x_factor5; } x24;
+extern volatile const union good_test6 { int x_factor6; } x25;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static union good_test7 { int x_factor7; } x26;
+static volatile union good_test8 { int x_factor8; } x27;
+static const volatile union good_test9 { int x_factor9; } x28;
+static volatile const union good_test10 { int x_factor10; } x29;
+
+// extern/static not in first postion is deprecated, but legal
+const extern union good_test11 { int x_factor11; } x30;
+volatile extern union good_test12 { int x_factor12; } x31;
+const extern volatile union good_test13 { int x_factor13; } x32;
+const volatile extern union good_test14 { int x_factor14; } x33;
+volatile extern const union good_test15 { int x_factor15; } x34;
+volatile const extern union good_test16 { int x_factor16; } x35;
+
+volatile static union good_test17 { int x_factor17; } x16;
+const static volatile union good_test18 { int x_factor18; } x37;
+const volatile static union good_test19 { int x_factor19; } x38;
+volatile static const union good_test20 { int x_factor20; } x39;
+volatile const static union good_test21 { int x_factor21; } x40;
+}	// end namespace test
+
+// check that union suppression works in namespaces
+namespace test2 {
+union good_test {
+	int x_factor;
+};
+
+// ringing the changes on extern
+extern good_test x1;
+extern const good_test x2;
+extern volatile good_test x3;
+extern const volatile good_test x4;
+extern volatile const good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static good_test x6;
+static volatile good_test x7;
+static const volatile good_test x8;
+static volatile const good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern good_test x10;
+volatile extern good_test x11;
+const extern volatile good_test x12;
+const volatile extern good_test x13;
+volatile extern const good_test x14;
+volatile const extern good_test x15;
+
+volatile static good_test x16;
+const static volatile good_test x17;
+const volatile static good_test x18;
+volatile static const good_test x19;
+volatile const static good_test x20;
+
+}	// end namespace test2

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2011-01-24 18:20:40 UTC (rev 591)
+++ trunk/type_system.cpp	2011-01-24 18:55:07 UTC (rev 592)
@@ -99,7 +99,23 @@
 	return _get_id_union_CPP(alias);
 }
 
+// for checking for pre-existing type system definitions
 type_system::type_index
+type_system::get_id_union_CPP_exact(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+	assert(!strstr(alias,"::"));
+	
+	if (active_namespace && *active_namespace)
+		{	// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		const type_index tmp2 = is_string_registered(tmp_alias) ? _get_id_union(tmp_alias) : 0;
+		return (free(tmp_alias),tmp2);
+		}
+	return _get_id_union(alias);
+}
+
+type_system::type_index
 type_system::_get_id_struct_class(const char* const x) const
 {
 	const size_t x_len = strlen(x);

Modified: trunk/type_system.cpp.in
===================================================================
--- trunk/type_system.cpp.in	2011-01-24 18:20:40 UTC (rev 591)
+++ trunk/type_system.cpp.in	2011-01-24 18:55:07 UTC (rev 592)
@@ -110,7 +110,23 @@
 	return _get_id_union_CPP(alias);
 }
 
+// for checking for pre-existing type system definitions
 type_system::type_index
+type_system::get_id_union_CPP_exact(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+	assert(!strstr(alias,"::"));
+	
+	if (active_namespace && *active_namespace)
+		{	// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		const type_index tmp2 = is_string_registered(tmp_alias) ? _get_id_union(tmp_alias) : 0;
+		return (free(tmp_alias),tmp2);
+		}
+	return _get_id_union(alias);
+}
+
+type_system::type_index
 type_system::_get_id_struct_class(const char* const x) const
 {
 	const size_t x_len = strlen(x);

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2011-01-24 18:20:40 UTC (rev 591)
+++ trunk/type_system.hpp	2011-01-24 18:55:07 UTC (rev 592)
@@ -48,6 +48,7 @@
 		return _get_id_union(x);
 		}
 	type_index get_id_union_CPP(const char* alias,const char* active_namespace) const;
+	type_index get_id_union_CPP_exact(const char* alias,const char* active_namespace) const;
 	type_index get_id_struct_class(const char* x) const
 		{
 		assert(x && *x);

Modified: trunk/type_system.hpp.in
===================================================================
--- trunk/type_system.hpp.in	2011-01-24 18:20:40 UTC (rev 591)
+++ trunk/type_system.hpp.in	2011-01-24 18:55:07 UTC (rev 592)
@@ -63,6 +63,7 @@
 		return _get_id_union(x);
 		}
 	type_index get_id_union_CPP(const char* alias,const char* active_namespace) const;
+	type_index get_id_union_CPP_exact(const char* alias,const char* active_namespace) const;
 	type_index get_id_struct_class(const char* x) const
 		{
 		assert(x && *x);



From zaimoni at mail.berlios.de  Tue Jan 25 03:33:16 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 25 Jan 2011 03:33:16 +0100
Subject: [Zcplusplus-commits] r593 - in trunk: . tests/zcc/decl.C99
Message-ID: <20110125023316.79D964812F2@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-25 03:33:15 +0100 (Tue, 25 Jan 2011)
New Revision: 593

Added:
   trunk/tests/zcc/decl.C99/Pass_class_def2.hpp
   trunk/tests/zcc/decl.C99/Pass_struct_def2.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/type_system.cpp
   trunk/type_system.cpp.in
   trunk/type_system.hpp
   trunk/type_system.hpp.in
Log:
exercise C++ structs, classes in namespaces

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-24 18:55:07 UTC (rev 592)
+++ trunk/CSupport.cpp	2011-01-25 02:33:15 UTC (rev 593)
@@ -13996,9 +13996,9 @@
 	switch(x.keyword())
 	{
 	default: _fatal_code("invalid state",3); 
-	case union_struct_decl::decl_union: return "union ";
-	case union_struct_decl::decl_struct: return "struct ";
-	case union_struct_decl::decl_class: return "class ";
+	case union_struct_decl::decl_union: return "union";
+	case union_struct_decl::decl_struct: return "struct";
+	case union_struct_decl::decl_class: return "class";
 	}				
 }
 
@@ -14273,7 +14273,6 @@
 					tmp2.set_index_token_from_str_literal<0>("union");
 					assert(is_C99_named_specifier(tmp2,"union"));
 					goto rescan;
-#if 0
 					}
 				else if (tmp = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[0].token.first,active_namespace))
 					{	// is a struct/class
@@ -14284,7 +14283,6 @@
 					tmp2.set_index_token_from_str_literal<0>(text);
 					assert(is_C99_named_specifier(tmp2,text));
 					goto rescan;
-#endif
 					};
 				}
 #if 0
@@ -14367,7 +14365,7 @@
 					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_struct_as_union.hpp
 						//! \test zcc/decl.C99/Error_struct_as_union3.hpp
 						//! \test zcc/decl.C99/Error_class_as_union.hpp
@@ -14485,7 +14483,7 @@
 					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_struct_as_union2.hpp
 						//! \test zcc/decl.C99/Error_struct_as_union4.hpp
 						//! \test zcc/decl.C99/Error_class_as_union2.hpp
@@ -14712,7 +14710,7 @@
 //				break;
 				case STRUCT_NAMED_DEF:
 				{	// can only define once
-				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP_exact(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
 				{
 				parse_tree& tmp2 = src.c_array<0>()[i+k];
 				if (tmp)
@@ -14959,7 +14957,7 @@
 //				break;
 				case CLASS_NAMED_DEF:
 				{	// can only define once
-				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP_exact(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
 				{
 				parse_tree& tmp2 =  src.c_array<0>()[i+k];				
 				if (tmp)
@@ -15172,7 +15170,7 @@
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_struct_as_enum.hpp
 						//! \test zcc/decl.C99/Error_struct_as_enum2.hpp
 						//! \test zcc/decl.C99/Error_class_as_enum.hpp

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-24 18:55:07 UTC (rev 592)
+++ trunk/CSupport.cpp.in	2011-01-25 02:33:15 UTC (rev 593)
@@ -14140,9 +14140,9 @@
 	switch(x.keyword())
 	{
 	default: _fatal_code("invalid state",3); 
-	case union_struct_decl::decl_union: return "union ";
-	case union_struct_decl::decl_struct: return "struct ";
-	case union_struct_decl::decl_class: return "class ";
+	case union_struct_decl::decl_union: return "union";
+	case union_struct_decl::decl_struct: return "struct";
+	case union_struct_decl::decl_class: return "class";
 	}				
 }
 
@@ -14417,7 +14417,6 @@
 					tmp2.set_index_token_from_str_literal<0>("union");
 					assert(is_C99_named_specifier(tmp2,"union"));
 					goto rescan;
-#if 0
 					}
 				else if (tmp = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[0].token.first,active_namespace))
 					{	// is a struct/class
@@ -14428,7 +14427,6 @@
 					tmp2.set_index_token_from_str_literal<0>(text);
 					assert(is_C99_named_specifier(tmp2,text));
 					goto rescan;
-#endif
 					};
 				}
 #if 0
@@ -14511,7 +14509,7 @@
 					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_struct_as_union.hpp
 						//! \test zcc/decl.C99/Error_struct_as_union3.hpp
 						//! \test zcc/decl.C99/Error_class_as_union.hpp
@@ -14629,7 +14627,7 @@
 					_condense_const_volatile_onto_type_preparsed(src,i,k,pre_invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 					}
 				// One Definition Rule states that conflicting enum, struct, or class must error
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_struct_as_union2.hpp
 						//! \test zcc/decl.C99/Error_struct_as_union4.hpp
 						//! \test zcc/decl.C99/Error_class_as_union2.hpp
@@ -14856,7 +14854,7 @@
 //				break;
 				case STRUCT_NAMED_DEF:
 				{	// can only define once
-				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP_exact(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
 				{
 				parse_tree& tmp2 = src.c_array<0>()[i+k];
 				if (tmp)
@@ -15103,7 +15101,7 @@
 //				break;
 				case CLASS_NAMED_DEF:
 				{	// can only define once
-				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
+				const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP_exact(src.data<0>()[i+k].index_tokens[1].token.first,active_namespace);
 				{
 				parse_tree& tmp2 =  src.c_array<0>()[i+k];				
 				if (tmp)
@@ -15316,7 +15314,7 @@
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
-				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[1].token.first,active_namespace))
+				else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP_exact(tmp2.index_tokens[1].token.first,active_namespace))
 					{	//! \test zcc/decl.C99/Error_struct_as_enum.hpp
 						//! \test zcc/decl.C99/Error_struct_as_enum2.hpp
 						//! \test zcc/decl.C99/Error_class_as_enum.hpp

Added: trunk/tests/zcc/decl.C99/Pass_class_def2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_class_def2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Pass_class_def2.hpp	2011-01-25 02:33:15 UTC (rev 593)
@@ -0,0 +1,136 @@
+// decl.C99\Pass_class_def2.hpp
+// using singly defined class
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+class good_test {
+	int x_factor;
+};
+
+// this section checks that suppressing class keyword works
+// ringing the changes on extern
+extern good_test x1;
+extern const good_test x2;
+extern volatile good_test x3;
+extern const volatile good_test x4;
+extern volatile const good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static good_test x6;
+static volatile good_test x7;
+static const volatile good_test x8;
+static volatile const good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern good_test x10;
+volatile extern good_test x11;
+const extern volatile good_test x12;
+const volatile extern good_test x13;
+volatile extern const good_test x14;
+volatile const extern good_test x15;
+
+volatile static good_test x16;
+const static volatile good_test x17;
+const volatile static good_test x18;
+volatile static const good_test x19;
+volatile const static good_test x20;
+
+// check that things work properly in namespaces
+namespace test {
+class good_test {
+	int x_factor;
+};
+
+// ringing the changes on extern
+extern class good_test x1;
+extern const class good_test x2;
+extern volatile class good_test x3;
+extern const volatile class good_test x4;
+extern volatile const class good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static class good_test x6;
+static volatile class good_test x7;
+static const volatile class good_test x8;
+static volatile const class good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern class good_test x10;
+volatile extern class good_test x11;
+const extern volatile class good_test x12;
+const volatile extern class good_test x13;
+volatile extern const class good_test x14;
+volatile const extern class good_test x15;
+
+volatile static class good_test x16;
+const static volatile class good_test x17;
+const volatile static class good_test x18;
+volatile static const class good_test x19;
+volatile const static class good_test x20;
+
+// define-declares
+// ringing the changes on extern
+extern class good_test2 { int x_factor2; } x21;
+extern const class good_test3 { int x_factor3; } x22;
+extern volatile class good_test4 { int x_factor4; } x23;
+extern const volatile class good_test5 { int x_factor5; } x24;
+extern volatile const class good_test6 { int x_factor6; } x25;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static class good_test7 { int x_factor7; } x26;
+static volatile class good_test8 { int x_factor8; } x27;
+static const volatile class good_test9 { int x_factor9; } x28;
+static volatile const class good_test10 { int x_factor10; } x29;
+
+// extern/static not in first postion is deprecated, but legal
+const extern class good_test11 { int x_factor11; } x30;
+volatile extern class good_test12 { int x_factor12; } x31;
+const extern volatile class good_test13 { int x_factor13; } x32;
+const volatile extern class good_test14 { int x_factor14; } x33;
+volatile extern const class good_test15 { int x_factor15; } x34;
+volatile const extern class good_test16 { int x_factor16; } x35;
+
+volatile static class good_test17 { int x_factor17; } x16;
+const static volatile class good_test18 { int x_factor18; } x37;
+const volatile static class good_test19 { int x_factor19; } x38;
+volatile static const class good_test20 { int x_factor20; } x39;
+volatile const static class good_test21 { int x_factor21; } x40;
+}	// end namespace test
+
+// check that class suppression works in namespaces
+namespace test2 {
+class good_test {
+	int x_factor;
+};
+
+// ringing the changes on extern
+extern good_test x1;
+extern const good_test x2;
+extern volatile good_test x3;
+extern const volatile good_test x4;
+extern volatile const good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static good_test x6;
+static volatile good_test x7;
+static const volatile good_test x8;
+static volatile const good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern good_test x10;
+volatile extern good_test x11;
+const extern volatile good_test x12;
+const volatile extern good_test x13;
+volatile extern const good_test x14;
+volatile const extern good_test x15;
+
+volatile static good_test x16;
+const static volatile good_test x17;
+const volatile static good_test x18;
+volatile static const good_test x19;
+volatile const static good_test x20;
+
+}	// end namespace test2

Added: trunk/tests/zcc/decl.C99/Pass_struct_def2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_struct_def2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Pass_struct_def2.hpp	2011-01-25 02:33:15 UTC (rev 593)
@@ -0,0 +1,136 @@
+// decl.C99\Pass_struct_def2.hpp
+// using singly defined struct
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+struct good_test {
+	int x_factor;
+};
+
+// this section checks that suppressing struct keyword works
+// ringing the changes on extern
+extern good_test x1;
+extern const good_test x2;
+extern volatile good_test x3;
+extern const volatile good_test x4;
+extern volatile const good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static good_test x6;
+static volatile good_test x7;
+static const volatile good_test x8;
+static volatile const good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern good_test x10;
+volatile extern good_test x11;
+const extern volatile good_test x12;
+const volatile extern good_test x13;
+volatile extern const good_test x14;
+volatile const extern good_test x15;
+
+volatile static good_test x16;
+const static volatile good_test x17;
+const volatile static good_test x18;
+volatile static const good_test x19;
+volatile const static good_test x20;
+
+// check that things work properly in namespaces
+namespace test {
+struct good_test {
+	int x_factor;
+};
+
+// ringing the changes on extern
+extern struct good_test x1;
+extern const struct good_test x2;
+extern volatile struct good_test x3;
+extern const volatile struct good_test x4;
+extern volatile const struct good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static struct good_test x6;
+static volatile struct good_test x7;
+static const volatile struct good_test x8;
+static volatile const struct good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern struct good_test x10;
+volatile extern struct good_test x11;
+const extern volatile struct good_test x12;
+const volatile extern struct good_test x13;
+volatile extern const struct good_test x14;
+volatile const extern struct good_test x15;
+
+volatile static struct good_test x16;
+const static volatile struct good_test x17;
+const volatile static struct good_test x18;
+volatile static const struct good_test x19;
+volatile const static struct good_test x20;
+
+// define-declares
+// ringing the changes on extern
+extern struct good_test2 { int x_factor2; } x21;
+extern const struct good_test3 { int x_factor3; } x22;
+extern volatile struct good_test4 { int x_factor4; } x23;
+extern const volatile struct good_test5 { int x_factor5; } x24;
+extern volatile const struct good_test6 { int x_factor6; } x25;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static struct good_test7 { int x_factor7; } x26;
+static volatile struct good_test8 { int x_factor8; } x27;
+static const volatile struct good_test9 { int x_factor9; } x28;
+static volatile const struct good_test10 { int x_factor10; } x29;
+
+// extern/static not in first postion is deprecated, but legal
+const extern struct good_test11 { int x_factor11; } x30;
+volatile extern struct good_test12 { int x_factor12; } x31;
+const extern volatile struct good_test13 { int x_factor13; } x32;
+const volatile extern struct good_test14 { int x_factor14; } x33;
+volatile extern const struct good_test15 { int x_factor15; } x34;
+volatile const extern struct good_test16 { int x_factor16; } x35;
+
+volatile static struct good_test17 { int x_factor17; } x16;
+const static volatile struct good_test18 { int x_factor18; } x37;
+const volatile static struct good_test19 { int x_factor19; } x38;
+volatile static const struct good_test20 { int x_factor20; } x39;
+volatile const static struct good_test21 { int x_factor21; } x40;
+}	// end namespace test
+
+// check that struct suppression works in namespaces
+namespace test2 {
+struct good_test {
+	int x_factor;
+};
+
+// ringing the changes on extern
+extern good_test x1;
+extern const good_test x2;
+extern volatile good_test x3;
+extern const volatile good_test x4;
+extern volatile const good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static good_test x6;
+static volatile good_test x7;
+static const volatile good_test x8;
+static volatile const good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern good_test x10;
+volatile extern good_test x11;
+const extern volatile good_test x12;
+const volatile extern good_test x13;
+volatile extern const good_test x14;
+volatile const extern good_test x15;
+
+volatile static good_test x16;
+const static volatile good_test x17;
+const volatile static good_test x18;
+volatile static const good_test x19;
+volatile const static good_test x20;
+
+}	// end namespace test2

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2011-01-24 18:55:07 UTC (rev 592)
+++ trunk/type_system.cpp	2011-01-25 02:33:15 UTC (rev 593)
@@ -200,6 +200,22 @@
 	return _get_id_struct_class_CPP(alias);
 }
 
+// for checking for pre-existing type system definitions
+type_system::type_index
+type_system::get_id_struct_class_CPP_exact(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+	assert(!strstr(alias,"::"));
+	
+	if (active_namespace && *active_namespace)
+		{	// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		const type_index tmp2 = is_string_registered(tmp_alias) ? _get_id_struct_class(tmp_alias) : 0;
+		return (free(tmp_alias),tmp2);
+		}
+	return _get_id_struct_class(alias);
+}
+
 type_system::type_index type_system::_get_id_enum(const char* const x) const
 {
 	const size_t x_len = strlen(x);

Modified: trunk/type_system.cpp.in
===================================================================
--- trunk/type_system.cpp.in	2011-01-24 18:55:07 UTC (rev 592)
+++ trunk/type_system.cpp.in	2011-01-25 02:33:15 UTC (rev 593)
@@ -211,6 +211,22 @@
 	return _get_id_struct_class_CPP(alias);
 }
 
+// for checking for pre-existing type system definitions
+type_system::type_index
+type_system::get_id_struct_class_CPP_exact(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+	assert(!strstr(alias,"::"));
+	
+	if (active_namespace && *active_namespace)
+		{	// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		const type_index tmp2 = is_string_registered(tmp_alias) ? _get_id_struct_class(tmp_alias) : 0;
+		return (free(tmp_alias),tmp2);
+		}
+	return _get_id_struct_class(alias);
+}
+
 type_system::type_index type_system::_get_id_enum(const char* const x) const
 {
 	const size_t x_len = strlen(x);

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2011-01-24 18:55:07 UTC (rev 592)
+++ trunk/type_system.hpp	2011-01-25 02:33:15 UTC (rev 593)
@@ -55,6 +55,7 @@
 		return _get_id_struct_class(x);
 		}
 	type_index get_id_struct_class_CPP(const char* alias,const char* active_namespace) const;
+	type_index get_id_struct_class_CPP_exact(const char* alias,const char* active_namespace) const;
 	type_index get_id_enum(const char* x) const
 		{
 		assert(x && *x);

Modified: trunk/type_system.hpp.in
===================================================================
--- trunk/type_system.hpp.in	2011-01-24 18:55:07 UTC (rev 592)
+++ trunk/type_system.hpp.in	2011-01-25 02:33:15 UTC (rev 593)
@@ -70,6 +70,7 @@
 		return _get_id_struct_class(x);
 		}
 	type_index get_id_struct_class_CPP(const char* alias,const char* active_namespace) const;
+	type_index get_id_struct_class_CPP_exact(const char* alias,const char* active_namespace) const;
 	type_index get_id_enum(const char* x) const
 		{
 		assert(x && *x);



From zaimoni at mail.berlios.de  Tue Jan 25 05:41:24 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 25 Jan 2011 05:41:24 +0100
Subject: [Zcplusplus-commits] r594 - trunk
Message-ID: <20110125044125.73DD84812F6@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-25 05:41:24 +0100 (Tue, 25 Jan 2011)
New Revision: 594

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/CSupport_pp.cpp
   trunk/ParseTree.cpp
   trunk/ParseTree.hpp
   trunk/weak_token.hpp
Log:
weak_token gets an INC_INFORM specialization

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-25 02:33:15 UTC (rev 593)
+++ trunk/CSupport.cpp	2011-01-25 04:41:24 UTC (rev 594)
@@ -1795,7 +1795,7 @@
 		{
 		message_header(rhs);
 		INC_INFORM(ERR_STR);
-		INC_INFORM(lhs.token.first,lhs.token.second);
+		INC_INFORM(lhs);
 		INFORM(" denies [ ] its left argument (C99 6.5.2p1/C++98 5.2p1)");
 		zcc_errors.inc_error();
 		};
@@ -1805,9 +1805,9 @@
 			{
 			message_header(rhs);
 			INC_INFORM(ERR_STR);
-			INC_INFORM(rhs.token.first,rhs.token.second);
+			INC_INFORM(rhs);
 			INC_INFORM(" denies ");
-			INC_INFORM(lhs.token.first,lhs.token.second);
+			INC_INFORM(lhs);
 			INFORM(" its right argument (C99 6.5.3p1/C++98 5.3p1)");
 			zcc_errors.inc_error();
 			}
@@ -1818,9 +1818,9 @@
 			{
 			message_header(lhs);
 			INC_INFORM(ERR_STR);
-			INC_INFORM(lhs.token.first,lhs.token.second);
+			INC_INFORM(lhs);
 			INC_INFORM(" denies ");
-			INC_INFORM(rhs.token.first,rhs.token.second);
+			INC_INFORM(rhs);
 			INFORM(" its left argument");
 			zcc_errors.inc_error();
 			}
@@ -1857,7 +1857,7 @@
 			//! \test if.C99/Error_control21.h, if.C99/Error_control21.hpp
 		message_header(tokenlist[0]);
 		INC_INFORM(ERR_STR);
-		INC_INFORM(tokenlist[0].token.first,tokenlist[0].token.second);
+		INC_INFORM(tokenlist[0]);
 		INFORM((1==tokenlist_len && hard_end && right_paren_asphyxiates(tokenlist[0])) ? " as only token doesn't have either of its arguments (C99 6.5.3p1/C++98 5.3p1)"
 				: " as first token doesn't have its left argument (C99 6.5.3p1/C++98 5.3p1)");
 		zcc_errors.inc_error();
@@ -1873,7 +1873,7 @@
 			//! \test if.C99/Error_control10.h, if.C99/Error_control10.hpp
 		message_header(tokenlist[tokenlist_len-1]);
 		INC_INFORM(ERR_STR);
-		INC_INFORM(tokenlist[tokenlist_len-1].token.first,tokenlist[tokenlist_len-1].token.second);
+		INC_INFORM(tokenlist[tokenlist_len-1]);
 		INFORM(" as last token doesn't have its right argument (C99 6.5.3p1/C++98 5.3p1)");
 		zcc_errors.inc_error();
 		}
@@ -13202,7 +13202,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as struct (C99 6.7.2.3p2)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -13219,7 +13219,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -13295,7 +13295,7 @@
 						message_header(tmp2.index_tokens[0]);
 						INC_INFORM(ERR_STR);
 						INC_INFORM("'union ");
-						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INC_INFORM(tmp2.index_tokens[1]);
 						INFORM("' already defined (C99 6.7.2.3p1)");
 						message_header(fatal_def->_decl);
 						INFORM("prior definition here");
@@ -13317,7 +13317,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as struct (C99 6.7.2.3p2)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -13335,7 +13335,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -13450,7 +13450,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C99 6.7.2.3p2)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -13467,7 +13467,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -13543,7 +13543,7 @@
 						message_header(tmp2.index_tokens[0]);
 						INC_INFORM(ERR_STR);
 						INC_INFORM("'struct ");
-						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INC_INFORM(tmp2.index_tokens[1]);
 						INFORM("' already defined (C99 6.7.2.3p1)");
 						message_header(fatal_def->_decl);
 						INFORM("prior definition here");
@@ -13565,7 +13565,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C99 6.7.2.3p2)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -13583,7 +13583,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -13693,7 +13693,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'enum ");
-					INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
 					zcc_errors.inc_error();
 					tmp2.type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
@@ -13710,7 +13710,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'enum ");
-					INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM("' already defined (C99 6.7.2.3p1)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -13729,7 +13729,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C99 6.7.2.3p2)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -13748,7 +13748,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as struct (C99 6.7.2.3p2)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -14103,7 +14103,7 @@
 	if (is_CPP_namespace(src) && robust_token_is_string<9>(src.index_tokens[1].token,"<unknown>"))
 		{	// make anonymous namespaces look like authentic source code
 		// first index token
-		INC_INFORM(src.index_tokens[0].token.first,src.index_tokens[0].token.second);
+		INC_INFORM(src.index_tokens[0]);
 		INC_INFORM(' ');
 		// postfix data
 		INC_INFORM(*src.data<2>());
@@ -14267,14 +14267,14 @@
 					assert(is_C99_named_specifier(tmp2,"enum"));
 					goto rescan;
 					}
-				else if (tmp = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[0].token.first,active_namespace))
+				else if ((tmp = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[0].token.first,active_namespace)))
 					{	// is a union
 					tmp2.grab_index_token_from<1,0>(tmp2);
 					tmp2.set_index_token_from_str_literal<0>("union");
 					assert(is_C99_named_specifier(tmp2,"union"));
 					goto rescan;
 					}
-				else if (tmp = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[0].token.first,active_namespace))
+				else if ((tmp = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[0].token.first,active_namespace)))
 					{	// is a struct/class
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(tmp);
 					assert(tmp3);
@@ -14373,7 +14373,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INC_INFORM(" declared as ");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -14393,7 +14393,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -14467,7 +14467,7 @@
 						message_header(tmp2.index_tokens[0]);
 						INC_INFORM(ERR_STR);
 						INC_INFORM("'union ");
-						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INC_INFORM(tmp2.index_tokens[1]);
 						INFORM("' already defined (C++98 3.2p1)");
 						message_header(fatal_def->_decl);
 						INFORM("prior definition here");
@@ -14491,7 +14491,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INC_INFORM(" declared as ");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -14512,7 +14512,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -14628,7 +14628,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C++98 One Definition Rule)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -14645,7 +14645,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -14720,7 +14720,7 @@
 						message_header(tmp2.index_tokens[0]);
 						INC_INFORM(ERR_STR);
 						INC_INFORM("'struct ");
-						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INC_INFORM(tmp2.index_tokens[1]);
 						INFORM("' already defined (C++98 3.2p1)");
 						message_header(fatal_def->_decl);
 						const char* const text = text_from_keyword(fatal_def->_decl);
@@ -14744,7 +14744,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C++98 One Definition Rule)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -14762,7 +14762,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -14876,7 +14876,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("class ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C++98 One Definition Rule)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -14893,7 +14893,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("class ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -14967,7 +14967,7 @@
 						message_header(tmp2.index_tokens[0]);
 						INC_INFORM(ERR_STR);
 						INC_INFORM("'class ");
-						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INC_INFORM(tmp2.index_tokens[1]);
 						INFORM("' already defined (C++98 3.2p1)");
 						message_header(fatal_def->_decl);
 						const char* const text = text_from_keyword(fatal_def->_decl);
@@ -14991,7 +14991,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("class ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C++98 One Definition Rule)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -15009,7 +15009,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("class ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -15121,7 +15121,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'enum ");
-					INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
 					zcc_errors.inc_error();
 					tmp2.type_code.set_type(C_TYPE::INT);	// fail over to int, like C
@@ -15138,7 +15138,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'enum ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM("' already defined (C++98 3.2p1)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -15157,7 +15157,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C++98 One Definition Rule)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -15178,7 +15178,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INC_INFORM(" declared as ");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-25 02:33:15 UTC (rev 593)
+++ trunk/CSupport.cpp.in	2011-01-25 04:41:24 UTC (rev 594)
@@ -1850,7 +1850,7 @@
 		{
 		message_header(rhs);
 		INC_INFORM(ERR_STR);
-		INC_INFORM(lhs.token.first,lhs.token.second);
+		INC_INFORM(lhs);
 		INFORM(" denies [ ] its left argument (C99 6.5.2p1/C++98 5.2p1)");
 		zcc_errors.inc_error();
 		};
@@ -1860,9 +1860,9 @@
 			{
 			message_header(rhs);
 			INC_INFORM(ERR_STR);
-			INC_INFORM(rhs.token.first,rhs.token.second);
+			INC_INFORM(rhs);
 			INC_INFORM(" denies ");
-			INC_INFORM(lhs.token.first,lhs.token.second);
+			INC_INFORM(lhs);
 			INFORM(" its right argument (C99 6.5.3p1/C++98 5.3p1)");
 			zcc_errors.inc_error();
 			}
@@ -1873,9 +1873,9 @@
 			{
 			message_header(lhs);
 			INC_INFORM(ERR_STR);
-			INC_INFORM(lhs.token.first,lhs.token.second);
+			INC_INFORM(lhs);
 			INC_INFORM(" denies ");
-			INC_INFORM(rhs.token.first,rhs.token.second);
+			INC_INFORM(rhs);
 			INFORM(" its left argument");
 			zcc_errors.inc_error();
 			}
@@ -1912,7 +1912,7 @@
 			//! \test if.C99/Error_control21.h, if.C99/Error_control21.hpp
 		message_header(tokenlist[0]);
 		INC_INFORM(ERR_STR);
-		INC_INFORM(tokenlist[0].token.first,tokenlist[0].token.second);
+		INC_INFORM(tokenlist[0]);
 		INFORM((1==tokenlist_len && hard_end && right_paren_asphyxiates(tokenlist[0])) ? " as only token doesn't have either of its arguments (C99 6.5.3p1/C++98 5.3p1)"
 				: " as first token doesn't have its left argument (C99 6.5.3p1/C++98 5.3p1)");
 		zcc_errors.inc_error();
@@ -1928,7 +1928,7 @@
 			//! \test if.C99/Error_control10.h, if.C99/Error_control10.hpp
 		message_header(tokenlist[tokenlist_len-1]);
 		INC_INFORM(ERR_STR);
-		INC_INFORM(tokenlist[tokenlist_len-1].token.first,tokenlist[tokenlist_len-1].token.second);
+		INC_INFORM(tokenlist[tokenlist_len-1]);
 		INFORM(" as last token doesn't have its right argument (C99 6.5.3p1/C++98 5.3p1)");
 		zcc_errors.inc_error();
 		}
@@ -13346,7 +13346,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as struct (C99 6.7.2.3p2)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -13363,7 +13363,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -13439,7 +13439,7 @@
 						message_header(tmp2.index_tokens[0]);
 						INC_INFORM(ERR_STR);
 						INC_INFORM("'union ");
-						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INC_INFORM(tmp2.index_tokens[1]);
 						INFORM("' already defined (C99 6.7.2.3p1)");
 						message_header(fatal_def->_decl);
 						INFORM("prior definition here");
@@ -13461,7 +13461,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as struct (C99 6.7.2.3p2)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -13479,7 +13479,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -13594,7 +13594,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C99 6.7.2.3p2)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -13611,7 +13611,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -13687,7 +13687,7 @@
 						message_header(tmp2.index_tokens[0]);
 						INC_INFORM(ERR_STR);
 						INC_INFORM("'struct ");
-						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INC_INFORM(tmp2.index_tokens[1]);
 						INFORM("' already defined (C99 6.7.2.3p1)");
 						message_header(fatal_def->_decl);
 						INFORM("prior definition here");
@@ -13709,7 +13709,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C99 6.7.2.3p2)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -13727,7 +13727,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -13837,7 +13837,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'enum ");
-					INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
 					zcc_errors.inc_error();
 					tmp2.type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
@@ -13854,7 +13854,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'enum ");
-					INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM("' already defined (C99 6.7.2.3p1)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -13873,7 +13873,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C99 6.7.2.3p2)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -13892,7 +13892,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as struct (C99 6.7.2.3p2)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -14247,7 +14247,7 @@
 	if (is_CPP_namespace(src) && robust_token_is_string<9>(src.index_tokens[1].token,"<unknown>"))
 		{	// make anonymous namespaces look like authentic source code
 		// first index token
-		INC_INFORM(src.index_tokens[0].token.first,src.index_tokens[0].token.second);
+		INC_INFORM(src.index_tokens[0]);
 		INC_INFORM(' ');
 		// postfix data
 		INC_INFORM(*src.data<2>());
@@ -14411,14 +14411,14 @@
 					assert(is_C99_named_specifier(tmp2,"enum"));
 					goto rescan;
 					}
-				else if (tmp = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[0].token.first,active_namespace))
+				else if ((tmp = parse_tree::types->get_id_union_CPP(tmp2.index_tokens[0].token.first,active_namespace)))
 					{	// is a union
 					tmp2.grab_index_token_from<1,0>(tmp2);
 					tmp2.set_index_token_from_str_literal<0>("union");
 					assert(is_C99_named_specifier(tmp2,"union"));
 					goto rescan;
 					}
-				else if (tmp = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[0].token.first,active_namespace))
+				else if ((tmp = parse_tree::types->get_id_struct_class_CPP(tmp2.index_tokens[0].token.first,active_namespace)))
 					{	// is a struct/class
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(tmp);
 					assert(tmp3);
@@ -14517,7 +14517,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INC_INFORM(" declared as ");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -14537,7 +14537,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -14611,7 +14611,7 @@
 						message_header(tmp2.index_tokens[0]);
 						INC_INFORM(ERR_STR);
 						INC_INFORM("'union ");
-						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INC_INFORM(tmp2.index_tokens[1]);
 						INFORM("' already defined (C++98 3.2p1)");
 						message_header(fatal_def->_decl);
 						INFORM("prior definition here");
@@ -14635,7 +14635,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INC_INFORM(" declared as ");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -14656,7 +14656,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -14772,7 +14772,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C++98 One Definition Rule)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -14789,7 +14789,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -14864,7 +14864,7 @@
 						message_header(tmp2.index_tokens[0]);
 						INC_INFORM(ERR_STR);
 						INC_INFORM("'struct ");
-						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INC_INFORM(tmp2.index_tokens[1]);
 						INFORM("' already defined (C++98 3.2p1)");
 						message_header(fatal_def->_decl);
 						const char* const text = text_from_keyword(fatal_def->_decl);
@@ -14888,7 +14888,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C++98 One Definition Rule)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -14906,7 +14906,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -15020,7 +15020,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("class ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C++98 One Definition Rule)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -15037,7 +15037,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("class ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -15111,7 +15111,7 @@
 						message_header(tmp2.index_tokens[0]);
 						INC_INFORM(ERR_STR);
 						INC_INFORM("'class ");
-						INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+						INC_INFORM(tmp2.index_tokens[1]);
 						INFORM("' already defined (C++98 3.2p1)");
 						message_header(fatal_def->_decl);
 						const char* const text = text_from_keyword(fatal_def->_decl);
@@ -15135,7 +15135,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("class ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C++98 One Definition Rule)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -15153,7 +15153,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("class ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -15265,7 +15265,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'enum ");
-					INC_INFORM(tmp2.index_tokens[1].token.first,tmp2.index_tokens[1].token.second);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
 					zcc_errors.inc_error();
 					tmp2.type_code.set_type(C_TYPE::INT);	// fail over to int, like C
@@ -15282,7 +15282,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'enum ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM("' already defined (C++98 3.2p1)");
 					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
 					assert(tmp3);
@@ -15301,7 +15301,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("struct ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as union (C++98 One Definition Rule)");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);
@@ -15322,7 +15322,7 @@
 					message_header(tmp2.index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("union ");
-					INC_INFORM(tmp2.index_tokens[1].token.first);
+					INC_INFORM(tmp2.index_tokens[1]);
 					INC_INFORM(" declared as ");
 					const union_struct_decl* const tmp3 = parse_tree::types->get_structdecl(fatal_def);
 					assert(tmp3);

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2011-01-25 02:33:15 UTC (rev 593)
+++ trunk/CSupport_pp.cpp	2011-01-25 04:41:24 UTC (rev 594)
@@ -1568,7 +1568,7 @@
 		{
 		message_header(rhs);
 		INC_INFORM(ERR_STR);
-		INC_INFORM(lhs.token.first,lhs.token.second);
+		INC_INFORM(lhs);
 		INFORM(" denies [ ] its left argument (C99 6.5.2p1/C++98 5.2p1)");
 		zcc_errors.inc_error();
 		};
@@ -1578,9 +1578,9 @@
 			{
 			message_header(rhs);
 			INC_INFORM(ERR_STR);
-			INC_INFORM(rhs.token.first,rhs.token.second);
+			INC_INFORM(rhs);
 			INC_INFORM(" denies ");
-			INC_INFORM(lhs.token.first,lhs.token.second);
+			INC_INFORM(lhs);
 			INFORM(" its right argument (C99 6.5.3p1/C++98 5.3p1)");
 			zcc_errors.inc_error();
 			}
@@ -1591,9 +1591,9 @@
 			{
 			message_header(lhs);
 			INC_INFORM(ERR_STR);
-			INC_INFORM(lhs.token.first,lhs.token.second);
+			INC_INFORM(lhs);
 			INC_INFORM(" denies ");
-			INC_INFORM(rhs.token.first,rhs.token.second);
+			INC_INFORM(rhs);
 			INFORM(" its left argument");
 			zcc_errors.inc_error();
 			}
@@ -1630,7 +1630,7 @@
 			//! \test if.C99/Error_control21.h, if.C99/Error_control21.hpp
 		message_header(tokenlist[0]);
 		INC_INFORM(ERR_STR);
-		INC_INFORM(tokenlist[0].token.first,tokenlist[0].token.second);
+		INC_INFORM(tokenlist[0]);
 		INFORM((1==tokenlist_len && hard_end && right_paren_asphyxiates(tokenlist[0])) ? " as only token doesn't have either of its arguments (C99 6.5.3p1/C++98 5.3p1)"
 				: " as first token doesn't have its left argument (C99 6.5.3p1/C++98 5.3p1)");
 		zcc_errors.inc_error();
@@ -1646,7 +1646,7 @@
 			//! \test if.C99/Error_control10.h, if.C99/Error_control10.hpp
 		message_header(tokenlist[tokenlist_len-1]);
 		INC_INFORM(ERR_STR);
-		INC_INFORM(tokenlist[tokenlist_len-1].token.first,tokenlist[tokenlist_len-1].token.second);
+		INC_INFORM(tokenlist[tokenlist_len-1]);
 		INFORM(" as last token doesn't have its right argument (C99 6.5.3p1/C++98 5.3p1)");
 		zcc_errors.inc_error();
 		}
@@ -2853,9 +2853,10 @@
 #define PARSE_PRIMARY_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-19))
 #define PARSE_UNION_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-20))
 #define PARSE_CLASS_STRUCT_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-21))
+#define PARSE_ENUM_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-22))
 
 // check for collision with lowest three bits
-BOOST_STATIC_ASSERT(sizeof(lex_flags)*CHAR_BIT-parse_tree::PREDEFINED_STRICT_UB>=20);
+BOOST_STATIC_ASSERT(sizeof(lex_flags)*CHAR_BIT-parse_tree::PREDEFINED_STRICT_UB>=22);
 
 /* nonstrict expression types */
 #define PARSE_POSTFIX_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION)
@@ -2877,7 +2878,7 @@
 #define PARSE_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION | PARSE_STRICT_SHIFT_EXPRESSION | PARSE_STRICT_RELATIONAL_EXPRESSION | PARSE_STRICT_EQUALITY_EXPRESSION | PARSE_STRICT_BITAND_EXPRESSION | PARSE_STRICT_BITXOR_EXPRESSION | PARSE_STRICT_BITOR_EXPRESSION | PARSE_STRICT_LOGICAND_EXPRESSION | PARSE_STRICT_LOGICOR_EXPRESSION | PARSE_STRICT_CONDITIONAL_EXPRESSION | PARSE_STRICT_ASSIGNMENT_EXPRESSION | PARSE_STRICT_COMMA_EXPRESSION)
 
 /* nonstrict type categories */
-#define PARSE_TYPE (PARSE_PRIMARY_TYPE | PARSE_UNION_TYPE | PARSE_CLASS_STRUCT_TYPE)
+#define PARSE_TYPE (PARSE_PRIMARY_TYPE | PARSE_UNION_TYPE | PARSE_CLASS_STRUCT_TYPE | PARSE_ENUM_TYPE)
 
 /* already-parsed */
 #define PARSE_OBVIOUS (PARSE_EXPRESSION | PARSE_TYPE | parse_tree::INVALID)

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2011-01-25 02:33:15 UTC (rev 593)
+++ trunk/ParseTree.cpp	2011-01-25 04:41:24 UTC (rev 594)
@@ -1,5 +1,5 @@
 // ParseTree.cpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 #include "ParseTree.hpp"
 
@@ -475,10 +475,10 @@
 		sp = false;
 		};
 	// first index token
-	if (NULL!=src.index_tokens[0].token.first)
+	if (src.index_tokens[0].token.first)
 		{
 		if (sp) INC_INFORM(' ');
-		INC_INFORM(src.index_tokens[0].token.first,src.index_tokens[0].token.second);
+		INC_INFORM(src.index_tokens[0]);
 		sp = true;
 		}
 	// infix data
@@ -501,10 +501,10 @@
 		sp = false;
 		};
 	// second index token
-	if (NULL!=src.index_tokens[1].token.first)
+	if (src.index_tokens[1].token.first)
 		{
 		if (sp) INC_INFORM(' ');
-		INC_INFORM(src.index_tokens[1].token.first,src.index_tokens[1].token.second);
+		INC_INFORM(src.index_tokens[1]);
 		sp = true;
 		}
 	// postfix data

Modified: trunk/ParseTree.hpp
===================================================================
--- trunk/ParseTree.hpp	2011-01-25 02:33:15 UTC (rev 593)
+++ trunk/ParseTree.hpp	2011-01-25 04:41:24 UTC (rev 594)
@@ -1,13 +1,13 @@
 // ParseTree.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 #ifndef PARSETREE_HPP
 #define PARSETREE_HPP 1
 
 #include "type_spec.hpp"
 
+#include "Zaimoni.STL/MetaRAM2.hpp"
 #include "weak_token.hpp"
-#include "Zaimoni.STL/MetaRAM2.hpp"
 
 // KBB: this really should be a class rather than a struct; it would benefit from having a proper destructor.
 // Unfortunately, new/delete and realloc don't mix -- and this type can have multiple lists of tokens underneath it....

Modified: trunk/weak_token.hpp
===================================================================
--- trunk/weak_token.hpp	2011-01-25 02:33:15 UTC (rev 593)
+++ trunk/weak_token.hpp	2011-01-25 04:41:24 UTC (rev 594)
@@ -1,5 +1,5 @@
 // weak_token.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 #ifndef WEAK_TOKEN_HPP
 #define WEAK_TOKEN_HPP
@@ -26,6 +26,11 @@
 		}
 };
 
+// if we're already getting INC_INFORM from Zaimoni.STL/Logging.h then provide our own
+#ifdef ZAIMONI_LOGGING_H
+inline void INC_INFORM(const weak_token& src) {_inc_inform(src.token.first,src.token.second);}
+#endif
+
 namespace boost {
 
 #define ZAIMONI_TEMPLATE_SPEC template<>



From zaimoni at mail.berlios.de  Wed Jan 26 10:58:05 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 26 Jan 2011 10:58:05 +0100
Subject: [Zcplusplus-commits] r595 - trunk
Message-ID: <20110126095805.C6EA6480C22@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-26 10:58:05 +0100 (Wed, 26 Jan 2011)
New Revision: 595

Modified:
   trunk/ParseTree.cpp
Log:
reduce lines of code, indentation

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2011-01-25 04:41:24 UTC (rev 594)
+++ trunk/ParseTree.cpp	2011-01-26 09:58:05 UTC (rev 595)
@@ -533,18 +533,11 @@
 	assert(begin<src.size(dest_idx));
 	assert(end<=src.size(dest_idx));
 	this->clear();
-	if (begin<end)
-		{
-		if (begin+1==end)
-			value_copy(*this,src.data(dest_idx)[begin]);
-		else{
-			size_t i = end-begin;
-			if (!resize(dest_idx,end-begin)) throw std::bad_alloc();
-			do	{
-				--i;
-				value_copy(c_array(dest_idx)[i],src.data(dest_idx)[i+begin]);
-				}
-			while(0<i);
-			}
-		}
+	if (begin>=end) return;
+	const size_t i = end-begin;
+	if (1==i) value_copy(*this,src.data(dest_idx)[begin]);
+	else{
+		if (!resize(dest_idx,i)) throw std::bad_alloc();
+		zaimoni::autotransform_n<void (*)(parse_tree&,const parse_tree&)>(c_array(dest_idx),src.data(dest_idx)+begin,i,value_copy);
+		}	
 }



From zaimoni at mail.berlios.de  Wed Jan 26 11:35:53 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 26 Jan 2011 11:35:53 +0100
Subject: [Zcplusplus-commits] r596 - trunk
Message-ID: <20110126103554.0B270480C1C@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-26 11:35:53 +0100 (Wed, 26 Jan 2011)
New Revision: 596

Modified:
   trunk/ParseTree.cpp
Log:
reduce lines of code

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2011-01-26 09:58:05 UTC (rev 595)
+++ trunk/ParseTree.cpp	2011-01-26 10:35:53 UTC (rev 596)
@@ -71,27 +71,19 @@
 	return true;
 }
 
+template<class iter,class src>
+bool entangled_with(src& x,iter begin,iter end)
+{
+	while(begin!=end) if ((begin++)->entangled_with(x)) return true;
+	return false;
+}
+
 bool parse_tree::entangled_with(const type_spec& x) const
 {
 	if (x.entangled_with(type_code)) return true;
-	size_t i = 0;
-	while(size<0>()>i)
-		{
-		if (data<0>()[i].entangled_with(x)) return true;
-		++i;
-		}
-	i = 0;
-	while(size<1>()>i)
-		{
-		if (data<1>()[i].entangled_with(x)) return true;
-		++i;
-		}
-	i = 0;
-	while(size<2>()>i)
-		{
-		if (data<2>()[i].entangled_with(x)) return true;
-		++i;
-		}
+	if (::entangled_with(x,begin<0>(),end<0>())) return true;
+	if (::entangled_with(x,begin<1>(),end<1>())) return true;
+	if (::entangled_with(x,begin<2>(),end<2>())) return true;
 	return false;
 }
 
@@ -109,73 +101,27 @@
 	if (args[2] && x.args[2] && args[2]==x.args[2]) return true;
 
 	size_t i = 0;
-	size_t j = 0;
 	while(size<0>()>i)
 		{
-		while(x.size<0>()>j)
-			{
-			if (data<0>()[i].entangled_with(x.data<0>()[j])) return true;
-			++j;
-			}
-		j = 0;
-		while(x.size<1>()>j)
-			{
-			if (data<0>()[i].entangled_with(x.data<1>()[j])) return true;
-			++j;
-			}
-		j = 0;
-		while(x.size<2>()>j)
-			{
-			if (data<0>()[i].entangled_with(x.data<2>()[j])) return true;
-			++j;
-			}
-		j = 0;
+		if (::entangled_with(data<0>()[i],x.begin<0>(),x.end<0>())) return true;
+		if (::entangled_with(data<0>()[i],x.begin<1>(),x.end<1>())) return true;
+		if (::entangled_with(data<0>()[i],x.begin<2>(),x.end<2>())) return true;
 		++i;
 		}
 	i = 0;
 	while(size<1>()>i)
 		{
-		while(x.size<0>()>j)
-			{
-			if (data<1>()[i].entangled_with(x.data<0>()[j])) return true;
-			++j;
-			}
-		j = 0;
-		while(x.size<1>()>j)
-			{
-			if (data<1>()[i].entangled_with(x.data<1>()[j])) return true;
-			++j;
-			}
-		j = 0;
-		while(x.size<2>()>j)
-			{
-			if (data<1>()[i].entangled_with(x.data<2>()[j])) return true;
-			++j;
-			}
-		j = 0;
+		if (::entangled_with(data<1>()[i],x.begin<0>(),x.end<0>())) return true;
+		if (::entangled_with(data<1>()[i],x.begin<1>(),x.end<1>())) return true;
+		if (::entangled_with(data<1>()[i],x.begin<2>(),x.end<2>())) return true;
 		++i;
 		}
 	i = 0;
 	while(size<2>()>i)
 		{
-		while(x.size<0>()>j)
-			{
-			if (data<2>()[i].entangled_with(x.data<0>()[j])) return true;
-			++j;
-			}
-		j = 0;
-		while(x.size<1>()>j)
-			{
-			if (data<2>()[i].entangled_with(x.data<1>()[j])) return true;
-			++j;
-			}
-		j = 0;
-		while(x.size<2>()>j)
-			{
-			if (data<2>()[i].entangled_with(x.data<2>()[j])) return true;
-			++j;
-			}
-		j = 0;
+		if (::entangled_with(data<2>()[i],x.begin<0>(),x.end<0>())) return true;
+		if (::entangled_with(data<2>()[i],x.begin<1>(),x.end<1>())) return true;
+		if (::entangled_with(data<2>()[i],x.begin<2>(),x.end<2>())) return true;
 		++i;
 		}
 	return false;
@@ -188,17 +134,11 @@
 	if (args[1] && args[2] && args[1]==args[2]) return true;
 
 	size_t i = 0;
-	size_t j = 0;
 	while(size<0>()>i)
 		{
 		if (data<0>()[i].self_entangled()) return true;
 		if (data<0>()[i].entangled_with(type_code)) return true;
-		while(i>j)
-			{
-			if (data<0>()[i].entangled_with(data<0>()[j])) return true;
-			++j;
-			}
-		j = 0;
+		if (0<i && ::entangled_with(data<0>()[i],begin<0>(),begin<0>()+i)) return true;
 		++i;
 		}
 	i = 0;
@@ -206,12 +146,7 @@
 		{
 		if (data<1>()[i].self_entangled()) return true;
 		if (data<1>()[i].entangled_with(type_code)) return true;
-		while(i>j)
-			{
-			if (data<1>()[i].entangled_with(data<1>()[j])) return true;
-			++j;
-			}
-		j = 0;
+		if (0<i && ::entangled_with(data<1>()[i],begin<1>(),begin<1>()+i)) return true;
 		++i;
 		}
 	i = 0;
@@ -219,12 +154,7 @@
 		{
 		if (data<2>()[i].self_entangled()) return true;
 		if (data<2>()[i].entangled_with(type_code)) return true;
-		while(i>j)
-			{
-			if (data<2>()[i].entangled_with(data<2>()[j])) return true;
-			++j;
-			}
-		j = 0;
+		if (0<i && ::entangled_with(data<2>()[i],begin<2>(),begin<2>()+i)) return true;
 		++i;
 		}
 	return false;



From zaimoni at mail.berlios.de  Wed Jan 26 12:06:19 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 26 Jan 2011 12:06:19 +0100
Subject: [Zcplusplus-commits] r597 - trunk
Message-ID: <20110126110620.07086480C1C@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-26 12:06:19 +0100 (Wed, 26 Jan 2011)
New Revision: 597

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
fix automatic formatting of union/struct/class/enum named specifiers

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-26 10:35:53 UTC (rev 596)
+++ trunk/CSupport.cpp	2011-01-26 11:06:19 UTC (rev 597)
@@ -14037,7 +14037,10 @@
 	if (types.get_enum_def(src.base_type_index))
 		INC_INFORM("enum ");
 	else if (const union_struct_decl* tmp = types.get_structdecl(src.base_type_index))
+		{
 		INC_INFORM(text_from_keyword(*tmp));
+		INC_INFORM(' ');
+		}
 	INC_INFORM(type_name ? type_name : "<unresolved type>");
 
 	while(0<start_ptr_scan--)

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-26 10:35:53 UTC (rev 596)
+++ trunk/CSupport.cpp.in	2011-01-26 11:06:19 UTC (rev 597)
@@ -14181,7 +14181,10 @@
 	if (types.get_enum_def(src.base_type_index))
 		INC_INFORM("enum ");
 	else if (const union_struct_decl* tmp = types.get_structdecl(src.base_type_index))
+		{
 		INC_INFORM(text_from_keyword(*tmp));
+		INC_INFORM(' ');
+		}
 	INC_INFORM(type_name ? type_name : "<unresolved type>");
 
 	while(0<start_ptr_scan--)



From zaimoni at mail.berlios.de  Wed Jan 26 20:27:24 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 26 Jan 2011 20:27:24 +0100
Subject: [Zcplusplus-commits] r598 - trunk
Message-ID: <20110126192725.61C0748065D@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-26 20:27:24 +0100 (Wed, 26 Jan 2011)
New Revision: 598

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
object size reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-26 11:06:19 UTC (rev 597)
+++ trunk/CSupport.cpp	2011-01-26 19:27:24 UTC (rev 598)
@@ -15268,33 +15268,30 @@
 				assert(is_CPP_namespace(src.data<0>()[i]));
 
 				if (active_namespace)
-					{
-					char* new_active_namespace = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(strlen(active_namespace)+11 /*sizeof("::<unknown>")-1*/));
-					strcpy(new_active_namespace,active_namespace);
-					strcat(new_active_namespace,"::<unknown>");
-					strcat(new_active_namespace,"");
+					{	//! \todo exception-unsafe; fix
+					char* const new_active_namespace = type_system::namespace_concatenate("<unknown>",active_namespace,"::");
 					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],new_active_namespace);
 					free(new_active_namespace);
 					}
-				else{
-					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],"<unknown>");
-					}
+				else CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],"<unknown>");
 				++i;
 				continue;
 				}
+			{
+			parse_tree* const origin = src.c_array<0>()+i;
 			const bool namespace_has_body = (	3<=src.size<0>()-i
-											&&	robust_token_is_char<'{'>(src.data<0>()[i+2].index_tokens[0].token)
-											&&	robust_token_is_char<'}'>(src.data<0>()[i+2].index_tokens[1].token));
+											&&	robust_token_is_char<'{'>(origin[2].index_tokens[0].token)
+											&&	robust_token_is_char<'}'>(origin[2].index_tokens[1].token));
 			// next token must be an atomic identifier
 			// already-parsed primary types are no good, neither are reserved keywords
-			if (	!src.data<0>()[i+1].is_atomic()
-				|| 	!(C_TESTFLAG_IDENTIFIER & src.data<0>()[i+1].index_tokens[0].flags)
-				||	(PARSE_TYPE & src.data<0>()[i+1].flags)
-				||	CPP_echo_reserved_keyword(src.data<0>()[i+1].index_tokens[0].token.first,src.data<0>()[i+1].index_tokens[0].token.second))
+			if (	!origin[1].is_atomic()
+				|| 	!(C_TESTFLAG_IDENTIFIER & origin[1].index_tokens[0].flags)
+				||	(PARSE_TYPE & origin[1].flags)
+				||	CPP_echo_reserved_keyword(origin[1].index_tokens[0].token.first,origin[1].index_tokens[0].token.second))
 				{	//! \test zcc/namespace.CPP/Error_badname1.hpp
 					//! \test zcc/namespace.CPP/Error_badname2.hpp
 					//! \test zcc/namespace.CPP/Error_badname3.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
+				message_header(origin->index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("named namespace declaration must use non-reserved identifier (C++98 7.3.1p1, 7.3.2p1)");
 				zcc_errors.inc_error();
@@ -15303,10 +15300,10 @@
 				};
 			if (!namespace_has_body)
 				{	//! \test zcc/namespace.CPP/Error_premature2.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
+				message_header(origin->index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("'namespace ");
-				INC_INFORM(src.data<0>()[i+1]);
+				INC_INFORM(origin[1]);
 				INFORM("' definition needs a body (C++98 7.3.1p1)");
 				zcc_errors.inc_error();
 				src.DeleteNSlotsAt<0>(2,i);
@@ -15317,11 +15314,12 @@
 			// namespace name: postfix arg 1
 			// namespace definition body: postfix arg 2
 			// the namespace name is likely to be reused: atomic string target
-			register_token<0>(src.c_array<0>()[i+1]);
-			src.c_array<0>()[i].resize<2>(1);
-			src.c_array<0>()[i].grab_index_token_from<1,0>(src.c_array<0>()[i+1]);
-			src.c_array<0>()[i].grab_index_token_location_from<1,0>(src.data<0>()[i+1]);	// inject it at where the namespace body starts
-			src.c_array<0>()[i+2].OverwriteInto(src.c_array<0>()[i].c_array<2>()[0]);
+			register_token<0>(origin[1]);
+			origin->resize<2>(1);
+			origin->grab_index_token_from<1,0>(origin[1]);
+			origin->grab_index_token_location_from<1,0>(origin[1]);	// inject it at where the namespace body starts
+			origin[2].OverwriteInto(origin->c_array<2>()[0]);
+			}
 			src.DeleteNSlotsAt<0>(2,i+1);
 			src.c_array<0>()[i].flags |= parse_tree::GOOD_LINE_BREAK;
 			assert(is_CPP_namespace(src.data<0>()[i]));

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-26 11:06:19 UTC (rev 597)
+++ trunk/CSupport.cpp.in	2011-01-26 19:27:24 UTC (rev 598)
@@ -15412,33 +15412,30 @@
 				assert(is_CPP_namespace(src.data<0>()[i]));
 
 				if (active_namespace)
-					{
-					char* new_active_namespace = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(strlen(active_namespace)+11 /*sizeof("::<unknown>")-1*/));
-					strcpy(new_active_namespace,active_namespace);
-					strcat(new_active_namespace,"::<unknown>");
-					strcat(new_active_namespace,"");
+					{	//! \todo exception-unsafe; fix
+					char* const new_active_namespace = type_system::namespace_concatenate("<unknown>",active_namespace,"::");
 					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],new_active_namespace);
 					free(new_active_namespace);
 					}
-				else{
-					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],"<unknown>");
-					}
+				else CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],"<unknown>");
 				++i;
 				continue;
 				}
+			{
+			parse_tree* const origin = src.c_array<0>()+i;
 			const bool namespace_has_body = (	3<=src.size<0>()-i
-											&&	robust_token_is_char<'{'>(src.data<0>()[i+2].index_tokens[0].token)
-											&&	robust_token_is_char<'}'>(src.data<0>()[i+2].index_tokens[1].token));
+											&&	robust_token_is_char<'{'>(origin[2].index_tokens[0].token)
+											&&	robust_token_is_char<'}'>(origin[2].index_tokens[1].token));
 			// next token must be an atomic identifier
 			// already-parsed primary types are no good, neither are reserved keywords
-			if (	!src.data<0>()[i+1].is_atomic()
-				|| 	!(C_TESTFLAG_IDENTIFIER & src.data<0>()[i+1].index_tokens[0].flags)
-				||	(PARSE_TYPE & src.data<0>()[i+1].flags)
-				||	CPP_echo_reserved_keyword(src.data<0>()[i+1].index_tokens[0].token.first,src.data<0>()[i+1].index_tokens[0].token.second))
+			if (	!origin[1].is_atomic()
+				|| 	!(C_TESTFLAG_IDENTIFIER & origin[1].index_tokens[0].flags)
+				||	(PARSE_TYPE & origin[1].flags)
+				||	CPP_echo_reserved_keyword(origin[1].index_tokens[0].token.first,origin[1].index_tokens[0].token.second))
 				{	//! \test zcc/namespace.CPP/Error_badname1.hpp
 					//! \test zcc/namespace.CPP/Error_badname2.hpp
 					//! \test zcc/namespace.CPP/Error_badname3.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
+				message_header(origin->index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("named namespace declaration must use non-reserved identifier (C++98 7.3.1p1, 7.3.2p1)");
 				zcc_errors.inc_error();
@@ -15447,10 +15444,10 @@
 				};
 			if (!namespace_has_body)
 				{	//! \test zcc/namespace.CPP/Error_premature2.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
+				message_header(origin->index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("'namespace ");
-				INC_INFORM(src.data<0>()[i+1]);
+				INC_INFORM(origin[1]);
 				INFORM("' definition needs a body (C++98 7.3.1p1)");
 				zcc_errors.inc_error();
 				src.DeleteNSlotsAt<0>(2,i);
@@ -15461,11 +15458,12 @@
 			// namespace name: postfix arg 1
 			// namespace definition body: postfix arg 2
 			// the namespace name is likely to be reused: atomic string target
-			register_token<0>(src.c_array<0>()[i+1]);
-			src.c_array<0>()[i].resize<2>(1);
-			src.c_array<0>()[i].grab_index_token_from<1,0>(src.c_array<0>()[i+1]);
-			src.c_array<0>()[i].grab_index_token_location_from<1,0>(src.data<0>()[i+1]);	// inject it at where the namespace body starts
-			src.c_array<0>()[i+2].OverwriteInto(src.c_array<0>()[i].c_array<2>()[0]);
+			register_token<0>(origin[1]);
+			origin->resize<2>(1);
+			origin->grab_index_token_from<1,0>(origin[1]);
+			origin->grab_index_token_location_from<1,0>(origin[1]);	// inject it at where the namespace body starts
+			origin[2].OverwriteInto(origin->c_array<2>()[0]);
+			}
 			src.DeleteNSlotsAt<0>(2,i+1);
 			src.c_array<0>()[i].flags |= parse_tree::GOOD_LINE_BREAK;
 			assert(is_CPP_namespace(src.data<0>()[i]));



From zaimoni at mail.berlios.de  Wed Jan 26 20:45:02 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 26 Jan 2011 20:45:02 +0100
Subject: [Zcplusplus-commits] r599 - trunk
Message-ID: <20110126194503.118CE48065D@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-26 20:45:02 +0100 (Wed, 26 Jan 2011)
New Revision: 599

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
lines of code reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-26 19:27:24 UTC (rev 598)
+++ trunk/CSupport.cpp	2011-01-26 19:45:02 UTC (rev 599)
@@ -13072,6 +13072,14 @@
 	_condense_const_volatile_onto_type_preparsed(src,i,k,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 }
 
+static void enumeration_already_defined(const type_system::type_index x)
+{
+	const enum_def* const tmp = parse_tree::types->get_enum_def(x);
+	assert(tmp);
+	message_header(*tmp);
+	INFORM("prior definition here");
+}
+
 // will need: "function-type vector"
 // return: 1 typespec record (for now, other languages may have more demanding requirements)
 // incoming: n typespec records, flag for trailing ...
@@ -13221,10 +13229,7 @@
 					INC_INFORM("union ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					assert(is_C99_named_specifier(tmp2,"enum"));
@@ -13337,10 +13342,7 @@
 					INC_INFORM("union ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					tmp2.DeleteIdx<2>(0);
@@ -13469,10 +13471,7 @@
 					INC_INFORM("struct ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					assert(is_C99_named_specifier(tmp2,"enum"));
@@ -13585,10 +13584,7 @@
 					INC_INFORM("struct ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					tmp2.DeleteIdx<2>(0);
@@ -13712,10 +13708,7 @@
 					INC_INFORM("'enum ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM("' already defined (C99 6.7.2.3p1)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"enum"));
@@ -14398,10 +14391,7 @@
 					INC_INFORM("union ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					assert(is_C99_named_specifier(tmp2,"enum"));
@@ -14517,10 +14507,7 @@
 					INC_INFORM("union ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					tmp2.DeleteIdx<2>(0);
@@ -14650,10 +14637,7 @@
 					INC_INFORM("struct ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					assert(is_C99_named_specifier(tmp2,"enum"));
@@ -14767,10 +14751,7 @@
 					INC_INFORM("struct ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					tmp2.DeleteIdx<2>(0);
@@ -14898,10 +14879,7 @@
 					INC_INFORM("class ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
@@ -15014,10 +14992,7 @@
 					INC_INFORM("class ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					tmp2.DeleteIdx<2>(0);
@@ -15143,10 +15118,7 @@
 					INC_INFORM("'enum ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM("' already defined (C++98 3.2p1)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"enum"));

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-26 19:27:24 UTC (rev 598)
+++ trunk/CSupport.cpp.in	2011-01-26 19:45:02 UTC (rev 599)
@@ -13216,6 +13216,14 @@
 	_condense_const_volatile_onto_type_preparsed(src,i,k,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 }
 
+static void enumeration_already_defined(const type_system::type_index x)
+{
+	const enum_def* const tmp = parse_tree::types->get_enum_def(x);
+	assert(tmp);
+	message_header(*tmp);
+	INFORM("prior definition here");
+}
+
 // will need: "function-type vector"
 // return: 1 typespec record (for now, other languages may have more demanding requirements)
 // incoming: n typespec records, flag for trailing ...
@@ -13365,10 +13373,7 @@
 					INC_INFORM("union ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					assert(is_C99_named_specifier(tmp2,"enum"));
@@ -13481,10 +13486,7 @@
 					INC_INFORM("union ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					tmp2.DeleteIdx<2>(0);
@@ -13613,10 +13615,7 @@
 					INC_INFORM("struct ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					assert(is_C99_named_specifier(tmp2,"enum"));
@@ -13729,10 +13728,7 @@
 					INC_INFORM("struct ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					tmp2.DeleteIdx<2>(0);
@@ -13856,10 +13852,7 @@
 					INC_INFORM("'enum ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM("' already defined (C99 6.7.2.3p1)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"enum"));
@@ -14542,10 +14535,7 @@
 					INC_INFORM("union ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					assert(is_C99_named_specifier(tmp2,"enum"));
@@ -14661,10 +14651,7 @@
 					INC_INFORM("union ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					tmp2.DeleteIdx<2>(0);
@@ -14794,10 +14781,7 @@
 					INC_INFORM("struct ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					assert(is_C99_named_specifier(tmp2,"enum"));
@@ -14911,10 +14895,7 @@
 					INC_INFORM("struct ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					tmp2.DeleteIdx<2>(0);
@@ -15042,10 +15023,7 @@
 					INC_INFORM("class ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
@@ -15158,10 +15136,7 @@
 					INC_INFORM("class ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.set_index_token_from_str_literal<0>("enum");
 					tmp2.DeleteIdx<2>(0);
@@ -15287,10 +15262,7 @@
 					INC_INFORM("'enum ");
 					INC_INFORM(tmp2.index_tokens[1]);
 					INFORM("' already defined (C++98 3.2p1)");
-					const enum_def* const tmp3 = parse_tree::types->get_enum_def(fatal_def);
-					assert(tmp3);
-					message_header(*tmp3);
-					INFORM("prior definition here");
+					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
 					tmp2.DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(tmp2,"enum"));



From zaimoni at mail.berlios.de  Thu Jan 27 00:38:29 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 27 Jan 2011 00:38:29 +0100
Subject: [Zcplusplus-commits] r600 - trunk
Message-ID: <20110126233830.3C7CC48119B@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-27 00:38:29 +0100 (Thu, 27 Jan 2011)
New Revision: 600

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
lines of code reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-26 19:45:02 UTC (rev 599)
+++ trunk/CSupport.cpp	2011-01-26 23:38:29 UTC (rev 600)
@@ -13080,6 +13080,14 @@
 	INFORM("prior definition here");
 }
 
+static void change_definition_to_different_specifier(parse_tree& x, const char* const text)
+{
+	assert(text && *text);
+	x.set_index_token_from_str_literal<0>(text);
+	x.DeleteIdx<2>(0);
+	assert(is_C99_named_specifier(x,text));
+}
+
 // will need: "function-type vector"
 // return: 1 typespec record (for now, other languages may have more demanding requirements)
 // incoming: n typespec records, flag for trailing ...
@@ -13329,9 +13337,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("struct");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"struct"));
+					change_definition_to_different_specifier(tmp2,"struct");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
 					continue;
 					}
@@ -13344,9 +13350,7 @@
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
 					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("enum");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"enum"));
+					change_definition_to_different_specifier(tmp2,"enum");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
 					continue;
 					}
@@ -13571,9 +13575,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("union");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"union"));
+					change_definition_to_different_specifier(tmp2,"union");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
@@ -13586,9 +13588,7 @@
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
 					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("enum");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"enum"));
+					change_definition_to_different_specifier(tmp2,"enum");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
 					continue;
 					}
@@ -13729,9 +13729,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("union");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"union"));
+					change_definition_to_different_specifier(tmp2,"union");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
@@ -13748,9 +13746,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("struct");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"struct"));
+					change_definition_to_different_specifier(tmp2,"struct");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
 					continue;
 					}
@@ -14494,9 +14490,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>(text);
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,text));
+					change_definition_to_different_specifier(tmp2,text);
 					pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
 					continue;
 					}
@@ -14509,9 +14503,7 @@
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("enum");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"enum"));
+					change_definition_to_different_specifier(tmp2,"enum");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
 					continue;
 					}
@@ -14714,9 +14706,7 @@
 						INFORM(strcmp("class",text) ? "prior definition here" : "prior definition as class here");
 						zcc_errors.inc_error();
 						// reduce to named-specifier
-						tmp2.set_index_token_from_str_literal<0>(text);
-						tmp2.DeleteIdx<2>(0);
-						assert(is_C99_named_specifier(tmp2,text));
+						change_definition_to_different_specifier(tmp2,text);
 						pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
 						continue;
 						}					
@@ -14738,9 +14728,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("union");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"union"));
+					change_definition_to_different_specifier(tmp2,"union");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
@@ -14753,9 +14741,7 @@
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("enum");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"enum"));
+					change_definition_to_different_specifier(tmp2,"enum");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
 					continue;
 					}
@@ -14955,9 +14941,7 @@
 						INFORM(strcmp("class",text) ? "prior definition as struct here" : "prior definition here");
 						zcc_errors.inc_error();
 						// reduce to named-specifier
-						tmp2.set_index_token_from_str_literal<0>(text);
-						tmp2.DeleteIdx<2>(0);
-						assert(is_C99_named_specifier(tmp2,text));
+						change_definition_to_different_specifier(tmp2,text);
 						pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
 						continue;
 						}					
@@ -14979,9 +14963,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("union");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"union"));
+					change_definition_to_different_specifier(tmp2,"union");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
@@ -14994,9 +14976,7 @@
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("enum");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"enum"));
+					change_definition_to_different_specifier(tmp2,"enum");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
 					continue;
 					}
@@ -15139,9 +15119,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("union");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"union"));
+					change_definition_to_different_specifier(tmp2,"union");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
@@ -15163,9 +15141,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>(text);
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,text));
+					change_definition_to_different_specifier(tmp2,text);
 					pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
 					continue;
 					}

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-26 19:45:02 UTC (rev 599)
+++ trunk/CSupport.cpp.in	2011-01-26 23:38:29 UTC (rev 600)
@@ -13224,6 +13224,14 @@
 	INFORM("prior definition here");
 }
 
+static void change_definition_to_different_specifier(parse_tree& x, const char* const text)
+{
+	assert(text && *text);
+	x.set_index_token_from_str_literal<0>(text);
+	x.DeleteIdx<2>(0);
+	assert(is_C99_named_specifier(x,text));
+}
+
 // will need: "function-type vector"
 // return: 1 typespec record (for now, other languages may have more demanding requirements)
 // incoming: n typespec records, flag for trailing ...
@@ -13473,9 +13481,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("struct");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"struct"));
+					change_definition_to_different_specifier(tmp2,"struct");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
 					continue;
 					}
@@ -13488,9 +13494,7 @@
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
 					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("enum");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"enum"));
+					change_definition_to_different_specifier(tmp2,"enum");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
 					continue;
 					}
@@ -13715,9 +13719,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("union");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"union"));
+					change_definition_to_different_specifier(tmp2,"union");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
@@ -13730,9 +13732,7 @@
 					INFORM(" declared as enumeration (C99 6.7.2.3p2)");
 					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("enum");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"enum"));
+					change_definition_to_different_specifier(tmp2,"enum");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+ENUM_NAME);
 					continue;
 					}
@@ -13873,9 +13873,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("union");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"union"));
+					change_definition_to_different_specifier(tmp2,"union");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
@@ -13892,9 +13890,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("struct");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"struct"));
+					change_definition_to_different_specifier(tmp2,"struct");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(C99_nontype_decl_specifier_list)+STRUCT_NAME);
 					continue;
 					}
@@ -14638,9 +14634,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>(text);
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,text));
+					change_definition_to_different_specifier(tmp2,text);
 					pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
 					continue;
 					}
@@ -14653,9 +14647,7 @@
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("enum");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"enum"));
+					change_definition_to_different_specifier(tmp2,"enum");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
 					continue;
 					}
@@ -14858,9 +14850,7 @@
 						INFORM(strcmp("class",text) ? "prior definition here" : "prior definition as class here");
 						zcc_errors.inc_error();
 						// reduce to named-specifier
-						tmp2.set_index_token_from_str_literal<0>(text);
-						tmp2.DeleteIdx<2>(0);
-						assert(is_C99_named_specifier(tmp2,text));
+						change_definition_to_different_specifier(tmp2,text);
 						pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
 						continue;
 						}					
@@ -14882,9 +14872,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("union");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"union"));
+					change_definition_to_different_specifier(tmp2,"union");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
@@ -14897,9 +14885,7 @@
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("enum");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"enum"));
+					change_definition_to_different_specifier(tmp2,"enum");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
 					continue;
 					}
@@ -15099,9 +15085,7 @@
 						INFORM(strcmp("class",text) ? "prior definition as struct here" : "prior definition here");
 						zcc_errors.inc_error();
 						// reduce to named-specifier
-						tmp2.set_index_token_from_str_literal<0>(text);
-						tmp2.DeleteIdx<2>(0);
-						assert(is_C99_named_specifier(tmp2,text));
+						change_definition_to_different_specifier(tmp2,text);
 						pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
 						continue;
 						}					
@@ -15123,9 +15107,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("union");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"union"));
+					change_definition_to_different_specifier(tmp2,"union");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
@@ -15138,9 +15120,7 @@
 					INFORM(" declared as enumeration (C++98 One Definition Rule)");
 					enumeration_already_defined(fatal_def);
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("enum");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"enum"));
+					change_definition_to_different_specifier(tmp2,"enum");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+ENUM_NAME);
 					continue;
 					}
@@ -15283,9 +15263,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>("union");
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,"union"));
+					change_definition_to_different_specifier(tmp2,"union");
 					pre_invariant_decl_scanner.reclassify(k--,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+UNION_NAME);
 					continue;
 					}
@@ -15307,9 +15285,7 @@
 					message_header(*tmp3);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
-					tmp2.set_index_token_from_str_literal<0>(text);
-					tmp2.DeleteIdx<2>(0);
-					assert(is_C99_named_specifier(tmp2,text));
+					change_definition_to_different_specifier(tmp2,text);
 					pre_invariant_decl_scanner.reclassify(k--,strcmp("class",text) ? STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+STRUCT_NAME : STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+CLASS_NAME);
 					continue;
 					}



From zaimoni at mail.berlios.de  Thu Jan 27 01:29:43 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 27 Jan 2011 01:29:43 +0100
Subject: [Zcplusplus-commits] r601 - trunk
Message-ID: <20110127002943.6252248113B@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-27 01:29:43 +0100 (Thu, 27 Jan 2011)
New Revision: 601

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
reduce object file size

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-26 23:38:29 UTC (rev 600)
+++ trunk/CSupport.cpp	2011-01-27 00:29:43 UTC (rev 601)
@@ -12571,9 +12571,11 @@
 		assert(!(PARSE_TYPE & src.data<0>()[i].flags));
 		assert(!echo_reserved_keyword(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].token.second));
 		{
-		char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[0].token.first,active_namespace,"::") : NULL;
-		const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[0].token.first;
-		if (const type_system::enumerator_info* fatal_def = parse_tree::types->get_enumerator(fullname))
+		char* const namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[0].token.first,active_namespace,"::") : NULL;
+		const char* const fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[0].token.first;
+		const type_system::enumerator_info* const fatal_def = parse_tree::types->get_enumerator(fullname);
+		free(namespace_name);
+		if (fatal_def)
 			{	// --do-what-i-mean could recover if the prior definition were identical
 				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined (but scope matters)
 				// C++: One Definition Rule wipes out
@@ -12584,10 +12586,8 @@
 			message_header(fatal_def->second.second);
 			INFORM("prior definition here");
 			zcc_errors.inc_error();
-			free(namespace_name);
 			return false;
 			};
-		free(namespace_name);
 		}
 #if 0
 		// next proposed function call is a bit handwavish right now...

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-26 23:38:29 UTC (rev 600)
+++ trunk/CSupport.cpp.in	2011-01-27 00:29:43 UTC (rev 601)
@@ -12715,9 +12715,11 @@
 		assert(!(PARSE_TYPE & src.data<0>()[i].flags));
 		assert(!echo_reserved_keyword(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].token.second));
 		{
-		char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[0].token.first,active_namespace,"::") : NULL;
-		const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[0].token.first;
-		if (const type_system::enumerator_info* fatal_def = parse_tree::types->get_enumerator(fullname))
+		char* const namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[0].token.first,active_namespace,"::") : NULL;
+		const char* const fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[0].token.first;
+		const type_system::enumerator_info* const fatal_def = parse_tree::types->get_enumerator(fullname);
+		free(namespace_name);
+		if (fatal_def)
 			{	// --do-what-i-mean could recover if the prior definition were identical
 				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined (but scope matters)
 				// C++: One Definition Rule wipes out
@@ -12728,10 +12730,8 @@
 			message_header(fatal_def->second.second);
 			INFORM("prior definition here");
 			zcc_errors.inc_error();
-			free(namespace_name);
 			return false;
 			};
-		free(namespace_name);
 		}
 #if 0
 		// next proposed function call is a bit handwavish right now...



From zaimoni at mail.berlios.de  Thu Jan 27 01:55:13 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 27 Jan 2011 01:55:13 +0100
Subject: [Zcplusplus-commits] r602 - trunk
Message-ID: <20110127005513.EECC148113B@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-27 01:55:13 +0100 (Thu, 27 Jan 2011)
New Revision: 602

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
object size reduction; reduce indentation

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-27 00:29:43 UTC (rev 601)
+++ trunk/CSupport.cpp	2011-01-27 00:55:13 UTC (rev 602)
@@ -12251,30 +12251,32 @@
 static void C99_CPP_handle_static_assertion(parse_tree& src,PP_auxfunc& langinfo,const size_t i,const char* const err,const char* const active_namespace)
 {
 	assert(err && *err);
+	assert(src.size<0>()>i);
 	// find the next ';'
-	const size_t j = i+span_to_semicolon(src.data<0>()+i,src.end<0>());
+	const parse_tree* const origin = src.data<0>()+i;
+	const size_t j = i+span_to_semicolon(origin,src.end<0>());
 	if (src.size<0>()<=j)
 		{	//! \test zcc/staticassert.C99/Error_scope1.h, zcc/staticassert.C99/Error_scope1.hpp
 			//! \test zcc/staticassert.C99/Error_scope2.h, zcc/staticassert.C99/Error_scope2.hpp
-		message_header(src.data<0>()[i].index_tokens[0]);
+		message_header(origin->index_tokens[0]);
 		INC_INFORM(ERR_STR);
 		INFORM("static assertion cut off by end of scope");
 		zcc_errors.inc_error();
 		src.DeleteNSlotsAt<0>(j-i,i);
 		return;
 		};
-	if (   !is_naked_parentheses_pair(src.data<0>()[i+1])
-		|| 3>src.data<0>()[i+1].size<0>()
-		|| !robust_token_is_char<','>(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-2])
-		|| !src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].is_atomic()
-		|| C_TESTFLAG_STRING_LITERAL!=src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].flags)
+	if (   !is_naked_parentheses_pair(origin[1])
+		|| 3>origin[1].size<0>()
+		|| !robust_token_is_char<','>(origin[1].data<0>()[origin[1].size<0>()-2])
+		|| !origin[1].data<0>()[origin[1].size<0>()-1].is_atomic()
+		|| C_TESTFLAG_STRING_LITERAL!=origin[1].data<0>()[origin[1].size<0>()-1].index_tokens[0].flags)
 		{	//! \test zcc/staticassert.C99/Error_badarg1.h, zcc/staticassert.C99/Error_badarg1.hpp
 			//! \test zcc/staticassert.C99/Error_badarg2.h, zcc/staticassert.C99/Error_badarg2.hpp
 			//! \test zcc/staticassert.C99/Error_badarg3.h, zcc/staticassert.C99/Error_badarg3.hpp
 			//! \test zcc/staticassert.C99/Error_badarg5.h, zcc/staticassert.C99/Error_badarg5.hpp
 			//! \test zcc/staticassert.C99/Error_badarg6.h, zcc/staticassert.C99/Error_badarg6.hpp
 			//! \test zcc/staticassert.C99/Error_badarg7.h, zcc/staticassert.C99/Error_badarg7.hpp
-		message_header(src.data<0>()[i].index_tokens[0]);
+		message_header(origin->index_tokens[0]);
 		INC_INFORM(ERR_STR);
 		INFORM("malformed static assertion");
 		zcc_errors.inc_error();
@@ -12283,7 +12285,7 @@
 		};
 	if (2!=j-i)
 		{	//! \test zcc/staticassert.C99/Error_badarg4.h, zcc/staticassert.C99/Error_badarg4.hpp
-		message_header(src.data<0>()[i].index_tokens[0]);
+		message_header(origin->index_tokens[0]);
 		INC_INFORM(ERR_STR);
 		INFORM("garbage between static assertion arguments and terminating ;");
 		zcc_errors.inc_error();
@@ -12293,14 +12295,14 @@
 	// actually use the static assertion correctly.
 	parse_tree_class parsetree;
 	{
-	const size_t k = src.data<0>()[i+1].size<0>()-2;
+	const size_t k = origin[1].size<0>()-2;
 	if (!parsetree.resize<0>(k))
 		{
-		message_header(src.data<0>()[i].index_tokens[0]);
+		message_header(origin->index_tokens[0]);
 		INC_INFORM(ERR_STR);
 		_fatal("insufficient RAM to parse static assertion");
 		};
-	zaimoni::autotransform_n<void (*)(parse_tree&,const parse_tree&)>(parsetree.c_array<0>(),src.data<0>()[i+1].data<0>(),k,value_copy);
+	zaimoni::autotransform_n<void (*)(parse_tree&,const parse_tree&)>(parsetree.c_array<0>(),origin[1].data<0>(),k,value_copy);
 	// type all enumerators now to make life reasonable later on for the expression-parser
 	size_t enum_scan = k;
 	do	notice_enumerator_CPP(parsetree.c_array<0>()[--enum_scan],*parse_tree::types,active_namespace);
@@ -12319,7 +12321,7 @@
 		if (!parsetree.is_atomic() && !(langinfo.EvalParseTree)(parsetree,*parse_tree::types))
 			{
 			parsetree.destroy();	// efficiency
-			message_header(src.data<0>()[i].index_tokens[0]);
+			message_header(origin->index_tokens[0]);
 			INC_INFORM(ERR_STR);
 			INFORM(err);
 			zcc_errors.inc_error();
@@ -12331,7 +12333,7 @@
 		if (!parsetree.is_atomic())
 			{	//! \bug need test cases
 			parsetree.destroy();	// efficiency
-			message_header(src.data<0>()[i].index_tokens[0]);
+			message_header(origin->index_tokens[0]);
 			INC_INFORM(ERR_STR);
 			INFORM(err);
 			zcc_errors.inc_error();
@@ -12348,7 +12350,7 @@
 		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true,*parse_tree::types))
 			{	//! \bug need test cases
 			parsetree.destroy();	// efficiency
-			message_header(src.data<0>()[i].index_tokens[0]);
+			message_header(origin->index_tokens[0]);
 			INC_INFORM(ERR_STR);
 			INFORM(err);
 			zcc_errors.inc_error();
@@ -12359,11 +12361,11 @@
 		//! \test zcc/staticassert.C1X/Pass_autosucceed.h, zcc/staticassert.C1X/Pass_autosucceed.hpp
 		if (!is_true)
 			{	//! \test zcc/staticassert.C1X/Error_autofail.h, zcc/staticassert.C1X/Error_autofail.hpp
-			message_header(src.data<0>()[i].index_tokens[0]);
+			message_header(origin->index_tokens[0]);
 			INC_INFORM(ERR_STR);
 			// hmm...really should unescape string before emitting
-			const size_t tmp_size = LengthOfCStringLiteral(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.second);
-			if (1U>=tmp_size || 'L'== *src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first)
+			const size_t tmp_size = LengthOfCStringLiteral(origin[1].data<0>()[origin[1].size<0>()-1].index_tokens[0].token.first,origin[1].data<0>()[origin[1].size<0>()-1].index_tokens[0].token.second);
+			if (1U>=tmp_size || 'L'== *origin[1].data<0>()[origin[1].size<0>()-1].index_tokens[0].token.first)
 				{	//! \todo handle wide-strings later
 				INFORM("(static assertion failure)");
 				zcc_errors.inc_error();
@@ -12379,7 +12381,7 @@
 				src.DeleteNSlotsAt<0>(j-i+1,i);
 				return;
 				}
-			UnescapeCString(tmp,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first+1,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.second-2);
+			UnescapeCString(tmp,origin[1].data<0>()[origin[1].size<0>()-1].index_tokens[0].token.first+1,origin[1].data<0>()[origin[1].size<0>()-1].index_tokens[0].token.second-2);
 			INFORM(tmp);
 			free(tmp);
 			zcc_errors.inc_error();
@@ -12413,32 +12415,29 @@
 				goto cpp_enum_was_retyped;
 				}
 			}
-		else{
-			if (prior_value==target_machine->unsigned_max(test.machine_type))
-				{
-				if (C_TYPE::INTEGERLIKE == ++current_enumerator_type)	// smallest type that can handle this
-					{	// unsigned long long overflow, fact it's defined doesn't save us
-					//! \test decl.C99/Error_enum_overflow.hpp
-					message_header(src);
-					INC_INFORM(ERR_STR);
-					INFORM("default-initialization of enumerator requires uintmax_t overflow (C++0X 7.2p5)");
-					zcc_errors.inc_error();
-					return false;
-					}
-				goto cpp_enum_was_retyped;
+		else if (prior_value==target_machine->unsigned_max(test.machine_type))
+			{
+			if (C_TYPE::INTEGERLIKE == ++current_enumerator_type)	// smallest type that can handle this
+				{	// unsigned long long overflow, fact it's defined doesn't save us
+				//! \test decl.C99/Error_enum_overflow.hpp
+				message_header(src);
+				INC_INFORM(ERR_STR);
+				INFORM("default-initialization of enumerator requires uintmax_t overflow (C++0X 7.2p5)");
+				zcc_errors.inc_error();
+				return false;
 				}
+			goto cpp_enum_was_retyped;
 			}
 		}
-	else{	// C
-		if (prior_value==target_machine->signed_max<virtual_machine::std_int_int>())
-			{	// signed integer overflow
-				//! \test decl.C99/Error_enum_overflow.h
-			message_header(src);
-			INC_INFORM(ERR_STR);
-			INFORM("default-initialization of enumerator requires signed int overflow (C99 6.7.2.2p3)");
-			zcc_errors.inc_error();
-			return false;
-			}
+	// C
+	else if (prior_value==target_machine->signed_max<virtual_machine::std_int_int>())
+		{	// signed integer overflow
+			//! \test decl.C99/Error_enum_overflow.h
+		message_header(src);
+		INC_INFORM(ERR_STR);
+		INFORM("default-initialization of enumerator requires signed int overflow (C99 6.7.2.2p3)");
+		zcc_errors.inc_error();
+		return false;
 		}
 	return true;
 }

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-27 00:29:43 UTC (rev 601)
+++ trunk/CSupport.cpp.in	2011-01-27 00:55:13 UTC (rev 602)
@@ -12395,30 +12395,32 @@
 static void C99_CPP_handle_static_assertion(parse_tree& src,PP_auxfunc& langinfo,const size_t i,const char* const err,const char* const active_namespace)
 {
 	assert(err && *err);
+	assert(src.size<0>()>i);
 	// find the next ';'
-	const size_t j = i+span_to_semicolon(src.data<0>()+i,src.end<0>());
+	const parse_tree* const origin = src.data<0>()+i;
+	const size_t j = i+span_to_semicolon(origin,src.end<0>());
 	if (src.size<0>()<=j)
 		{	//! \test zcc/staticassert.C99/Error_scope1.h, zcc/staticassert.C99/Error_scope1.hpp
 			//! \test zcc/staticassert.C99/Error_scope2.h, zcc/staticassert.C99/Error_scope2.hpp
-		message_header(src.data<0>()[i].index_tokens[0]);
+		message_header(origin->index_tokens[0]);
 		INC_INFORM(ERR_STR);
 		INFORM("static assertion cut off by end of scope");
 		zcc_errors.inc_error();
 		src.DeleteNSlotsAt<0>(j-i,i);
 		return;
 		};
-	if (   !is_naked_parentheses_pair(src.data<0>()[i+1])
-		|| 3>src.data<0>()[i+1].size<0>()
-		|| !robust_token_is_char<','>(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-2])
-		|| !src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].is_atomic()
-		|| C_TESTFLAG_STRING_LITERAL!=src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].flags)
+	if (   !is_naked_parentheses_pair(origin[1])
+		|| 3>origin[1].size<0>()
+		|| !robust_token_is_char<','>(origin[1].data<0>()[origin[1].size<0>()-2])
+		|| !origin[1].data<0>()[origin[1].size<0>()-1].is_atomic()
+		|| C_TESTFLAG_STRING_LITERAL!=origin[1].data<0>()[origin[1].size<0>()-1].index_tokens[0].flags)
 		{	//! \test zcc/staticassert.C99/Error_badarg1.h, zcc/staticassert.C99/Error_badarg1.hpp
 			//! \test zcc/staticassert.C99/Error_badarg2.h, zcc/staticassert.C99/Error_badarg2.hpp
 			//! \test zcc/staticassert.C99/Error_badarg3.h, zcc/staticassert.C99/Error_badarg3.hpp
 			//! \test zcc/staticassert.C99/Error_badarg5.h, zcc/staticassert.C99/Error_badarg5.hpp
 			//! \test zcc/staticassert.C99/Error_badarg6.h, zcc/staticassert.C99/Error_badarg6.hpp
 			//! \test zcc/staticassert.C99/Error_badarg7.h, zcc/staticassert.C99/Error_badarg7.hpp
-		message_header(src.data<0>()[i].index_tokens[0]);
+		message_header(origin->index_tokens[0]);
 		INC_INFORM(ERR_STR);
 		INFORM("malformed static assertion");
 		zcc_errors.inc_error();
@@ -12427,7 +12429,7 @@
 		};
 	if (2!=j-i)
 		{	//! \test zcc/staticassert.C99/Error_badarg4.h, zcc/staticassert.C99/Error_badarg4.hpp
-		message_header(src.data<0>()[i].index_tokens[0]);
+		message_header(origin->index_tokens[0]);
 		INC_INFORM(ERR_STR);
 		INFORM("garbage between static assertion arguments and terminating ;");
 		zcc_errors.inc_error();
@@ -12437,14 +12439,14 @@
 	// actually use the static assertion correctly.
 	parse_tree_class parsetree;
 	{
-	const size_t k = src.data<0>()[i+1].size<0>()-2;
+	const size_t k = origin[1].size<0>()-2;
 	if (!parsetree.resize<0>(k))
 		{
-		message_header(src.data<0>()[i].index_tokens[0]);
+		message_header(origin->index_tokens[0]);
 		INC_INFORM(ERR_STR);
 		_fatal("insufficient RAM to parse static assertion");
 		};
-	zaimoni::autotransform_n<void (*)(parse_tree&,const parse_tree&)>(parsetree.c_array<0>(),src.data<0>()[i+1].data<0>(),k,value_copy);
+	zaimoni::autotransform_n<void (*)(parse_tree&,const parse_tree&)>(parsetree.c_array<0>(),origin[1].data<0>(),k,value_copy);
 	// type all enumerators now to make life reasonable later on for the expression-parser
 	size_t enum_scan = k;
 	do	notice_enumerator_CPP(parsetree.c_array<0>()[--enum_scan],*parse_tree::types,active_namespace);
@@ -12463,7 +12465,7 @@
 		if (!parsetree.is_atomic() && !(langinfo.EvalParseTree)(parsetree,*parse_tree::types))
 			{
 			parsetree.destroy();	// efficiency
-			message_header(src.data<0>()[i].index_tokens[0]);
+			message_header(origin->index_tokens[0]);
 			INC_INFORM(ERR_STR);
 			INFORM(err);
 			zcc_errors.inc_error();
@@ -12475,7 +12477,7 @@
 		if (!parsetree.is_atomic())
 			{	//! \bug need test cases
 			parsetree.destroy();	// efficiency
-			message_header(src.data<0>()[i].index_tokens[0]);
+			message_header(origin->index_tokens[0]);
 			INC_INFORM(ERR_STR);
 			INFORM(err);
 			zcc_errors.inc_error();
@@ -12492,7 +12494,7 @@
 		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true,*parse_tree::types))
 			{	//! \bug need test cases
 			parsetree.destroy();	// efficiency
-			message_header(src.data<0>()[i].index_tokens[0]);
+			message_header(origin->index_tokens[0]);
 			INC_INFORM(ERR_STR);
 			INFORM(err);
 			zcc_errors.inc_error();
@@ -12503,11 +12505,11 @@
 		//! \test zcc/staticassert.C1X/Pass_autosucceed.h, zcc/staticassert.C1X/Pass_autosucceed.hpp
 		if (!is_true)
 			{	//! \test zcc/staticassert.C1X/Error_autofail.h, zcc/staticassert.C1X/Error_autofail.hpp
-			message_header(src.data<0>()[i].index_tokens[0]);
+			message_header(origin->index_tokens[0]);
 			INC_INFORM(ERR_STR);
 			// hmm...really should unescape string before emitting
-			const size_t tmp_size = LengthOfCStringLiteral(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.second);
-			if (1U>=tmp_size || 'L'== *src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first)
+			const size_t tmp_size = LengthOfCStringLiteral(origin[1].data<0>()[origin[1].size<0>()-1].index_tokens[0].token.first,origin[1].data<0>()[origin[1].size<0>()-1].index_tokens[0].token.second);
+			if (1U>=tmp_size || 'L'== *origin[1].data<0>()[origin[1].size<0>()-1].index_tokens[0].token.first)
 				{	//! \todo handle wide-strings later
 				INFORM("(static assertion failure)");
 				zcc_errors.inc_error();
@@ -12523,7 +12525,7 @@
 				src.DeleteNSlotsAt<0>(j-i+1,i);
 				return;
 				}
-			UnescapeCString(tmp,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first+1,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.second-2);
+			UnescapeCString(tmp,origin[1].data<0>()[origin[1].size<0>()-1].index_tokens[0].token.first+1,origin[1].data<0>()[origin[1].size<0>()-1].index_tokens[0].token.second-2);
 			INFORM(tmp);
 			free(tmp);
 			zcc_errors.inc_error();
@@ -12557,32 +12559,29 @@
 				goto cpp_enum_was_retyped;
 				}
 			}
-		else{
-			if (prior_value==target_machine->unsigned_max(test.machine_type))
-				{
-				if (C_TYPE::INTEGERLIKE == ++current_enumerator_type)	// smallest type that can handle this
-					{	// unsigned long long overflow, fact it's defined doesn't save us
-					//! \test decl.C99/Error_enum_overflow.hpp
-					message_header(src);
-					INC_INFORM(ERR_STR);
-					INFORM("default-initialization of enumerator requires uintmax_t overflow (C++0X 7.2p5)");
-					zcc_errors.inc_error();
-					return false;
-					}
-				goto cpp_enum_was_retyped;
+		else if (prior_value==target_machine->unsigned_max(test.machine_type))
+			{
+			if (C_TYPE::INTEGERLIKE == ++current_enumerator_type)	// smallest type that can handle this
+				{	// unsigned long long overflow, fact it's defined doesn't save us
+				//! \test decl.C99/Error_enum_overflow.hpp
+				message_header(src);
+				INC_INFORM(ERR_STR);
+				INFORM("default-initialization of enumerator requires uintmax_t overflow (C++0X 7.2p5)");
+				zcc_errors.inc_error();
+				return false;
 				}
+			goto cpp_enum_was_retyped;
 			}
 		}
-	else{	// C
-		if (prior_value==target_machine->signed_max<virtual_machine::std_int_int>())
-			{	// signed integer overflow
-				//! \test decl.C99/Error_enum_overflow.h
-			message_header(src);
-			INC_INFORM(ERR_STR);
-			INFORM("default-initialization of enumerator requires signed int overflow (C99 6.7.2.2p3)");
-			zcc_errors.inc_error();
-			return false;
-			}
+	// C
+	else if (prior_value==target_machine->signed_max<virtual_machine::std_int_int>())
+		{	// signed integer overflow
+			//! \test decl.C99/Error_enum_overflow.h
+		message_header(src);
+		INC_INFORM(ERR_STR);
+		INFORM("default-initialization of enumerator requires signed int overflow (C99 6.7.2.2p3)");
+		zcc_errors.inc_error();
+		return false;
 		}
 	return true;
 }



From zaimoni at mail.berlios.de  Thu Jan 27 02:09:07 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 27 Jan 2011 02:09:07 +0100
Subject: [Zcplusplus-commits] r603 - trunk
Message-ID: <20110127010908.5C9E948119B@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-27 02:09:07 +0100 (Thu, 27 Jan 2011)
New Revision: 603

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
reduce indentation

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-27 00:55:13 UTC (rev 602)
+++ trunk/CSupport.cpp	2011-01-27 01:09:07 UTC (rev 603)
@@ -11576,12 +11576,10 @@
 static bool check_for_typedef(type_spec& dest,const char* const src,const type_system& types)
 {
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(src);
-	if (tmp)
-		{	//! \todo C++: check for access control if source ends up being a class or struct
-		value_copy(dest,tmp->first);
-		return true;
-		}
-	return false;
+	if (!tmp) return false;
+	//! \todo C++: check for access control if source ends up being a class or struct
+	value_copy(dest,tmp->first);
+	return true;
 }
 
 //! \todo should this be a type_system member?

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-27 00:55:13 UTC (rev 602)
+++ trunk/CSupport.cpp.in	2011-01-27 01:09:07 UTC (rev 603)
@@ -11720,12 +11720,10 @@
 static bool check_for_typedef(type_spec& dest,const char* const src,const type_system& types)
 {
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(src);
-	if (tmp)
-		{	//! \todo C++: check for access control if source ends up being a class or struct
-		value_copy(dest,tmp->first);
-		return true;
-		}
-	return false;
+	if (!tmp) return false;
+	//! \todo C++: check for access control if source ends up being a class or struct
+	value_copy(dest,tmp->first);
+	return true;
 }
 
 //! \todo should this be a type_system member?



From zaimoni at mail.berlios.de  Thu Jan 27 02:29:32 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 27 Jan 2011 02:29:32 +0100
Subject: [Zcplusplus-commits] r604 - trunk
Message-ID: <20110127012932.852E948119B@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-27 02:29:31 +0100 (Thu, 27 Jan 2011)
New Revision: 604

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
object file size reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-27 01:09:07 UTC (rev 603)
+++ trunk/CSupport.cpp	2011-01-27 01:29:31 UTC (rev 604)
@@ -10853,17 +10853,18 @@
 	bool typeid_is_ok = false;	// has to be enabled in #include <typeinfo>
 	size_t i = 0;
 	do	{
-		if (src.data<0>()[i].is_atomic())
+		parse_tree& tmp = src.c_array<0>()[i];
+		if (tmp.is_atomic())
 			{
-			const errr Idx = linear_find(src.data<0>()[i].index_tokens[0].token.first, src.data<0>()[i].index_tokens[0].token.second,pragma_relay_keywords,PRAGMA_RELAY_KEYWORDS_STRICT_UB);
+			const errr Idx = linear_find(tmp.index_tokens[0].token.first, tmp.index_tokens[0].token.second,pragma_relay_keywords,PRAGMA_RELAY_KEYWORDS_STRICT_UB);
 			if (0<=Idx)
 				{	// react to any relay keywords that actually mean anything here
 				if (RELAY_ZCC_ENABLE_TYPEID==Idx) typeid_is_ok = true;
 				src.DeleteIdx<0>(i);
 				}
-			else if (!typeid_is_ok && token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"typeid"))
+			else if (!typeid_is_ok && token_is_string<6>(tmp.index_tokens[0].token,"typeid"))
 				//! \test staticassert.C1X/Error_typeid_no_typeinfo.hpp
-				simple_error(src.c_array<0>()[i]," requires #include <typeinfo> first (C++0X 5.2.8p6)");
+				simple_error(tmp," requires #include <typeinfo> first (C++0X 5.2.8p6)");
 			}
 		}
 	while(src.size<0>()> ++i);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-27 01:09:07 UTC (rev 603)
+++ trunk/CSupport.cpp.in	2011-01-27 01:29:31 UTC (rev 604)
@@ -10989,17 +10989,18 @@
 	bool typeid_is_ok = false;	// has to be enabled in #include <typeinfo>
 	size_t i = 0;
 	do	{
-		if (src.data<0>()[i].is_atomic())
+		parse_tree& tmp = src.c_array<0>()[i];
+		if (tmp.is_atomic())
 			{
-			const errr Idx = linear_find(src.data<0>()[i].index_tokens[0].token.first, src.data<0>()[i].index_tokens[0].token.second,pragma_relay_keywords,PRAGMA_RELAY_KEYWORDS_STRICT_UB);
+			const errr Idx = linear_find(tmp.index_tokens[0].token.first, tmp.index_tokens[0].token.second,pragma_relay_keywords,PRAGMA_RELAY_KEYWORDS_STRICT_UB);
 			if (0<=Idx)
 				{	// react to any relay keywords that actually mean anything here
 				if (RELAY_ZCC_ENABLE_TYPEID==Idx) typeid_is_ok = true;
 				src.DeleteIdx<0>(i);
 				}
-			else if (!typeid_is_ok && token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"typeid"))
+			else if (!typeid_is_ok && token_is_string<6>(tmp.index_tokens[0].token,"typeid"))
 				//! \test staticassert.C1X/Error_typeid_no_typeinfo.hpp
-				simple_error(src.c_array<0>()[i]," requires #include <typeinfo> first (C++0X 5.2.8p6)");
+				simple_error(tmp," requires #include <typeinfo> first (C++0X 5.2.8p6)");
 			}
 		}
 	while(src.size<0>()> ++i);



From zaimoni at mail.berlios.de  Thu Jan 27 02:34:19 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 27 Jan 2011 02:34:19 +0100
Subject: [Zcplusplus-commits] r605 - trunk
Message-ID: <20110127013419.B9FCF48119B@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-27 02:34:19 +0100 (Thu, 27 Jan 2011)
New Revision: 605

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
restrict scope of macro to where it's needed

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-01-27 01:29:31 UTC (rev 604)
+++ trunk/CSupport.cpp	2011-01-27 01:34:19 UTC (rev 605)
@@ -10616,6 +10616,7 @@
 				}
 			++offset;
 		}
+#undef INVARIANT
 }
 
 static void _condense_const_volatile_onto_type(parse_tree& src,size_t& i,kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner,const char* const warn_const,const char* const warn_volatile)

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-01-27 01:29:31 UTC (rev 604)
+++ trunk/CSupport.cpp.in	2011-01-27 01:34:19 UTC (rev 605)
@@ -10752,6 +10752,7 @@
 				}
 			++offset;
 		}
+#undef INVARIANT
 }
 
 static void _condense_const_volatile_onto_type(parse_tree& src,size_t& i,kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner,const char* const warn_const,const char* const warn_volatile)



From zaimoni at mail.berlios.de  Thu Jan 27 03:47:10 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 27 Jan 2011 03:47:10 +0100
Subject: [Zcplusplus-commits] r606 - in trunk: . lib
Message-ID: <20110127024710.7A89B4811A8@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-27 03:47:09 +0100 (Thu, 27 Jan 2011)
New Revision: 606

Added:
   trunk/lib/zc++-0.0.7/
Removed:
   trunk/lib/zc++-0.0.6/
Modified:
   trunk/_version.h
Log:
version tweak

Modified: trunk/_version.h
===================================================================
--- trunk/_version.h	2011-01-27 01:34:19 UTC (rev 605)
+++ trunk/_version.h	2011-01-27 02:47:09 UTC (rev 606)
@@ -1,11 +1,11 @@
 /* _version.h */
 /* central version information for ZCC */
-/* (C)2010 Kenneth Boyd, license: MIT.txt */
+/* (C)2010,2011 Kenneth Boyd, license: MIT.txt */
 
 #ifndef ZCC_VERSION
-#define ZCC_VERSION "0.0.6"
+#define ZCC_VERSION "0.0.7"
 #define ZCC_VERSION_MAJOR 0
 #define ZCC_VERSION_MINOR 0
-#define ZCC_VERSION_PATCH 6
+#define ZCC_VERSION_PATCH 7
 #endif
 



From zaimoni at mail.berlios.de  Sat Jan 29 06:04:26 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 29 Jan 2011 06:04:26 +0100
Subject: [Zcplusplus-commits] r607 - trunk/doc
Message-ID: <20110129050426.2D629480BF8@sheep.berlios.de>

Author: zaimoni
Date: 2011-01-29 06:04:25 +0100 (Sat, 29 Jan 2011)
New Revision: 607

Modified:
   trunk/doc/OPTIONS.txt
Log:
update options listing

Modified: trunk/doc/OPTIONS.txt
===================================================================
--- trunk/doc/OPTIONS.txt	2011-01-27 02:47:09 UTC (rev 606)
+++ trunk/doc/OPTIONS.txt	2011-01-29 05:04:25 UTC (rev 607)
@@ -1,4 +1,4 @@
-Z.C++ 0.0.3 zcc
+Z.C++ 0.0.7 zcc
 usage: zcc [options] infile
 boolean options
  --test: final internal state to stderr
@@ -13,12 +13,19 @@
  --int-neg-div-rounds-away-from-zero: make -3/-2==-2 contrary to C99 recommendation
  -Wc-c++-compat: Warn when something legal in C/C++ would be an error in C++/C for C/C++
  -Wbackport: Warn when something legal would be an error under an older standard
+
 override-default options
  -x: language override
  --system-include: unpreprocessed #include<...> to stdout
  -fmax-errors: how many errors are too many (default 100)
+ -ferror-limit: how many errors are too many (default 100)
+ --target-char-bit: target CHAR_BIT
+ --target-sizeof-short: target sizeof(short), sizeof(unsigned short)
+ --target-sizeof-int: target sizeof(int), sizeof(unsigned int)
+ --target-sizeof-long: target sizeof(long), sizeof(unsigned long)
+ --target-sizeof-long-long: target sizeof(long long), sizeof(unsigned long long)
 
-Z.C++ 0.0.3 z_cpp
+Z.C++ 0.0.7 z_cpp
 usage: z_cpp [options] infile
 boolean options
  --test: final internal state to stderr
@@ -31,10 +38,17 @@
  -fsigned-char: char acts like signed char
  -funsigned-char: char acts like unsigned char (default)
  --int-neg-div-rounds-away-from-zero: make -3/-2==-2 contrary to C99 recommendation
+
 override-default options
  -x: language override
  --system-include: unpreprocessed #include<...> to stdout
  -fmax-errors: how many errors are too many (default 100)
+ -ferror-limit: how many errors are too many (default 100)
+ --target-char-bit: target CHAR_BIT
+ --target-sizeof-short: target sizeof(short), sizeof(unsigned short)
+ --target-sizeof-int: target sizeof(int), sizeof(unsigned int)
+ --target-sizeof-long: target sizeof(long), sizeof(unsigned long)
+ --target-sizeof-long-long: target sizeof(long long), sizeof(unsigned long long)
 
 Z.C++ cmp 0.1
 usage: cmp [options] file1 file2



