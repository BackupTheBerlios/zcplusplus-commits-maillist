From zaimoni at mail.berlios.de  Tue Jun  7 19:02:34 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue,  7 Jun 2011 19:02:34 +0200
Subject: [Zcplusplus-commits] r650 - in trunk: . lib
Message-ID: <20110607170234.A1586480EB1@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-07 19:02:34 +0200 (Tue, 07 Jun 2011)
New Revision: 650

Added:
   trunk/lib/zc++-0.0.9/
Removed:
   trunk/lib/zc++-0.0.8/
Modified:
   trunk/_version.h
Log:
adjust version to 0.0.9 now as planning to use ZCC version as a preprocessor guard clause in tests

Modified: trunk/_version.h
===================================================================
--- trunk/_version.h	2011-05-27 05:57:18 UTC (rev 649)
+++ trunk/_version.h	2011-06-07 17:02:34 UTC (rev 650)
@@ -3,9 +3,9 @@
 /* (C)2010,2011 Kenneth Boyd, license: MIT.txt */
 
 #ifndef ZCC_VERSION
-#define ZCC_VERSION "0.0.8"
+#define ZCC_VERSION "0.0.9"
 #define ZCC_VERSION_MAJOR 0
 #define ZCC_VERSION_MINOR 0
-#define ZCC_VERSION_PATCH 8
+#define ZCC_VERSION_PATCH 9
 #endif
 



From zaimoni at mail.berlios.de  Tue Jun  7 19:42:41 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue,  7 Jun 2011 19:42:41 +0200
Subject: [Zcplusplus-commits] r651 - trunk
Message-ID: <20110607174242.8073B480EB1@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-07 19:42:41 +0200 (Tue, 07 Jun 2011)
New Revision: 651

Modified:
   trunk/CSupport.cpp.in
Log:
repair preprocessing to handle 10000*__ZCC__+100*__ZCC_MINOR__+__ZCC_PATCHLEVEL__

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-06-07 17:02:34 UTC (rev 650)
+++ trunk/CSupport.cpp.in	2011-06-07 17:42:41 UTC (rev 651)
@@ -4112,8 +4112,8 @@
 			&&	src.index_tokens[0].src_filename
 #endif
 			&&	!src.index_tokens[1].token.first
-			&&	src.empty<0>() && src.empty<1>()
-			&&	1==src.size<2>() && ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
+			&&	src.empty<0>() && src.empty<1>();
+//			&&	1==src.size<2>() && ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
 //			&&	1==src.size<2>() && ((PARSE_UNARY_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
 }
 #endif
@@ -5784,7 +5784,7 @@
 }
 
 //! \throw std::bad_alloc
-static void assemble_unary_postfix_arguments(parse_tree& src, size_t& i, const size_t _subtype)
+static void assemble_unary_postfix_arguments(parse_tree& src, const size_t i, const size_t _subtype)
 {
 	assert(1<src.size<0>()-i);
 	parse_tree* const tmp = repurpose_inner_parentheses(src.c_array<0>()[i+1]);	// RAM conservation
@@ -6204,9 +6204,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -6230,9 +6228,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -6256,9 +6252,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -6282,9 +6276,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -6426,9 +6418,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -6452,9 +6442,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -6642,16 +6630,51 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,unary_subtype);
 			src.c_array<0>()[i].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
-			if (0==i)	// unless no predecessor possible
-				C_unary_plusminus_easy_syntax_check(src.c_array<0>()[0],types);
+			if (   0==i	// unless no predecessor possible
+				// operators also work
+			    || robust_token_is_char<'~'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'!'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"++") 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"--") 
+			    || robust_token_is_char<'*'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'/'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'%'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'+'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'-'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"<<") 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,">>")
+			    || robust_token_is_char<'<'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'>'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"<=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,">=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"==")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"!=")
+			    || robust_token_is_char<'&'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<'^'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<'|'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"&&")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"||")
+			    || robust_token_is_char<'?'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<':'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<'='>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"*=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"/=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"%=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"+=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"-=")
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,"<<=")
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,">>=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"&=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"^=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"|=")
+			    || robust_token_is_char<','>(src.data<0>()[i-1].index_tokens[0].token)) 
+				C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i],types);
 			assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i]));
 			return true;
 			};
@@ -6673,16 +6696,62 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,unary_subtype);
 			src.c_array<0>()[i].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
-			if (0==i)	// unless no predecessor possible
-				CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[0],types);
+			if (   0==i	// unless no predecessor possible
+				// operators also work
+			    || robust_token_is_char<'~'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_string<5>(src.data<0>()[i-1].index_tokens[0].token,"compl") 
+			    || robust_token_is_char<'!'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,"not") 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"++") 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"--") 
+			    || robust_token_is_char<'*'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'/'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'%'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'+'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'-'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"<<") 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,">>")
+			    || robust_token_is_char<'<'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'>'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"<=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,">=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"==")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"!=")
+			    || robust_token_is_string<6>(src.data<0>()[i-1].index_tokens[0].token,"not_eq")
+			    || robust_token_is_char<'&'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<6>(src.data<0>()[i-1].index_tokens[0].token,"bitand")
+			    || robust_token_is_char<'^'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,"xor")
+			    || robust_token_is_char<'|'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<5>(src.data<0>()[i-1].index_tokens[0].token,"bitor")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"&&")
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,"and")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"||")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"or")
+			    || robust_token_is_char<'?'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<':'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<'='>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"*=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"/=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"%=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"+=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"-=")
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,"<<=")
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,">>=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"&=")
+			    || robust_token_is_string<6>(src.data<0>()[i-1].index_tokens[0].token,"and_eq")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"^=")
+			    || robust_token_is_string<6>(src.data<0>()[i-1].index_tokens[0].token,"xor_eq")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"|=")
+			    || robust_token_is_string<5>(src.data<0>()[i-1].index_tokens[0].token,"or_eq")
+			    || robust_token_is_char<','>(src.data<0>()[i-1].index_tokens[0].token)) 
+				CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i],types);
 			assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i]));
 			return true;
 			};
@@ -6728,9 +6797,7 @@
 		{
 		assert(1<src.size<0>()-i);
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (   (PARSE_UNARY_EXPRESSION & src.data<0>()[i+1].flags)
 			|| (is_naked_parentheses_pair(src.data<0>()[i+1]) && (PARSE_TYPE & src.data<0>()[i+1].flags)))
@@ -6991,9 +7058,7 @@
 		{
 		assert(1<src.size<0>()-i);
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (is_naked_parentheses_pair(src.data<0>()[i+1]))
 			{
@@ -7014,7 +7079,8 @@
 		&& 	src.data<2>()->is_atomic()
 		&& 	C_TESTFLAG_IDENTIFIER==src.data<2>()->index_tokens[0].flags)
 		{
-		const int tmp = types.C_linkage_code(src.data<2>()->index_tokens[0].token.first);
+		const int tmp = C99_echo_reserved_keyword(src.data<2>()->index_tokens[0].token.first,src.data<2>()->index_tokens[0].token.second) ? -1
+			: types.C_linkage_code(src.data<2>()->index_tokens[0].token.first);
 		const bool is_negative = 0>tmp;
 		const umaxint tmp2(is_negative ? -tmp : tmp);
 		parse_tree tmp3;
@@ -7036,7 +7102,8 @@
 		&& 	src.data<2>()->is_atomic()
 		&& 	C_TESTFLAG_IDENTIFIER==src.data<2>()->index_tokens[0].flags)
 		{
-		const int tmp = types.CPP_linkage_code(src.data<2>()->index_tokens[0].token.first,parse_tree::active_namespace);
+		const int tmp = CPP_echo_reserved_keyword(src.data<2>()->index_tokens[0].token.first,src.data<2>()->index_tokens[0].token.second) ? -1
+			: types.CPP_linkage_code(src.data<2>()->index_tokens[0].token.first,parse_tree::active_namespace);
 		const bool is_negative = 0>tmp;
 		const umaxint tmp2(is_negative ? -tmp : tmp);
 		parse_tree tmp3;
@@ -7280,7 +7347,28 @@
 	if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i]))
 		{
 		if (1<=i && (PARSE_MULT_EXPRESSION & src.data<0>()[i-1].flags))
-			{
+			{	// check for unary +/- with type NOT_VOID
+				// if found, split out the +/- into slot i and adjust i up before proceeding
+			if (   is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1])
+				|| is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]))
+				{
+				if (   C_TYPE::NOT_VOID==src.data<0>()[i-1].type_code.base_type_index
+					&& 0==src.data<0>()[i-1].type_code.pointer_power)
+					{	// ,src.data<0>()[i-1].front<2>()
+#ifndef ZAIMONI_FORCE_ISO
+					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
+#else
+					if (!_insert_n_slots_at(src.args[0].first,src.args[0].second,1,i)) throw std::bad_alloc();
+#endif
+					src.c_array<0>()[i].clear();
+					src.c_array<0>()[i-1].front<2>().MoveInto(src.c_array<0>()[i]);
+					src.c_array<0>()[i-1].DeleteIdx<2>(0);
+					src.c_array<0>()[i-1].type_code.base_type_index = 0;
+					++i;
+					assert(PARSE_MULT_EXPRESSION & src.data<0>()[i-1].flags);
+					assert(is_C99_unary_operator_expression<'*'>(src.data<0>()[i]));
+					}
+				}
 			merge_binary_infix_argument(src,i,PARSE_STRICT_MULT_EXPRESSION);
 			assert(is_C99_mult_operator_expression(src.data<0>()[i]));
 			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
@@ -7301,7 +7389,28 @@
 	if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i]))
 		{
 		if (1<=i && (inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]),(PARSE_MULT_EXPRESSION & src.data<0>()[i-1].flags)))
-			{
+			{	// check for unary +/- with type NOT_VOID
+				// if found, split out the +/- into slot i and adjust i up before proceeding
+			if (   is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1])
+				|| is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]))
+				{
+				if (   C_TYPE::NOT_VOID==src.data<0>()[i-1].type_code.base_type_index
+					&& 0==src.data<0>()[i-1].type_code.pointer_power)
+					{	// ,src.data<0>()[i-1].front<2>()
+#ifndef ZAIMONI_FORCE_ISO
+					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
+#else
+					if (!_insert_n_slots_at(src.args[0].first,src.args[0].second,1,i)) throw std::bad_alloc();
+#endif
+					src.c_array<0>()[i].clear();
+					src.c_array<0>()[i-1].front<2>().MoveInto(src.c_array<0>()[i]);
+					src.c_array<0>()[i-1].DeleteIdx<2>(0);
+					src.c_array<0>()[i-1].type_code.base_type_index = 0;
+					++i;
+					assert(PARSE_MULT_EXPRESSION & src.data<0>()[i-1].flags);
+					assert(is_C99_unary_operator_expression<'*'>(src.data<0>()[i]));
+					}
+				}
 			merge_binary_infix_argument(src,i,PARSE_STRICT_MULT_EXPRESSION);
 			assert(is_C99_mult_operator_expression(src.data<0>()[i]));
 			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
@@ -7832,6 +7941,17 @@
 	if (terse_C99_augment_mult_expression(src,i,types))
 		{
 		C_mult_expression_easy_syntax_check(src.c_array<0>()[i],types);
+		// reconstitute raw +- from terse_C99_augment_mult_expression into unary +-
+		if (0<i)
+			{	// synchronize with locate_C99_unary_plusminus
+			if (const size_t unary_subtype 	= token_is_char<'-'>(src.data<0>()[i-1].index_tokens[0].token) ? C99_UNARY_SUBTYPE_NEG
+									: token_is_char<'+'>(src.data<0>()[i-1].index_tokens[0].token) ? C99_UNARY_SUBTYPE_PLUS : 0)
+				{
+				assemble_unary_postfix_arguments(src,i-1,unary_subtype);	// doesn't work: reference to temporary
+				src.c_array<0>()[i-1].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
+				assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]));
+				};
+			}
 		return;
 		}
 
@@ -7858,6 +7978,17 @@
 	if (terse_CPP_augment_mult_expression(src,i,types))
 		{	//! \todo handle operator overloading
 		CPP_mult_expression_easy_syntax_check(src.c_array<0>()[i],types);
+		// reconstitute raw +- from terse_CPP_augment_mult_expression into unary +-
+		if (0<i)
+			{	// synchronize with locate_CPP_unary_plusminus
+			if (const size_t unary_subtype 	= token_is_char<'-'>(src.data<0>()[i-1].index_tokens[0].token) ? C99_UNARY_SUBTYPE_NEG
+									: token_is_char<'+'>(src.data<0>()[i-1].index_tokens[0].token) ? C99_UNARY_SUBTYPE_PLUS : 0)
+				{
+				assemble_unary_postfix_arguments(src,i-1,unary_subtype);
+				src.c_array<0>()[i-1].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
+				assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]));
+				};
+			}
 		return;
 		}
 



From zaimoni at mail.berlios.de  Tue Jun  7 19:43:29 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue,  7 Jun 2011 19:43:29 +0200
Subject: [Zcplusplus-commits] r652 - trunk
Message-ID: <20110607174330.095DD480EB1@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-07 19:43:29 +0200 (Tue, 07 Jun 2011)
New Revision: 652

Modified:
   trunk/CSupport.cpp
Log:
repair preprocessing to handle 10000*__ZCC__+100*__ZCC_MINOR__+__ZCC_PATCHLEVEL__

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-06-07 17:42:41 UTC (rev 651)
+++ trunk/CSupport.cpp	2011-06-07 17:43:29 UTC (rev 652)
@@ -4048,8 +4048,8 @@
 			&&	src.index_tokens[0].src_filename
 #endif
 			&&	!src.index_tokens[1].token.first
-			&&	src.empty<0>() && src.empty<1>()
-			&&	1==src.size<2>() && ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
+			&&	src.empty<0>() && src.empty<1>();
+//			&&	1==src.size<2>() && ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
 //			&&	1==src.size<2>() && ((PARSE_UNARY_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
 }
 #endif
@@ -5703,7 +5703,7 @@
 }
 
 //! \throw std::bad_alloc
-static void assemble_unary_postfix_arguments(parse_tree& src, size_t& i, const size_t _subtype)
+static void assemble_unary_postfix_arguments(parse_tree& src, const size_t i, const size_t _subtype)
 {
 	assert(1<src.size<0>()-i);
 	parse_tree* const tmp = repurpose_inner_parentheses(src.c_array<0>()[i+1]);	// RAM conservation
@@ -6109,9 +6109,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -6135,9 +6133,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -6161,9 +6157,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -6187,9 +6181,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -6331,9 +6323,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -6357,9 +6347,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -6545,16 +6533,51 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,unary_subtype);
 			src.c_array<0>()[i].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
-			if (0==i)	// unless no predecessor possible
-				C_unary_plusminus_easy_syntax_check(src.c_array<0>()[0],types);
+			if (   0==i	// unless no predecessor possible
+				// operators also work
+			    || robust_token_is_char<'~'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'!'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"++") 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"--") 
+			    || robust_token_is_char<'*'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'/'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'%'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'+'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'-'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"<<") 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,">>")
+			    || robust_token_is_char<'<'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'>'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"<=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,">=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"==")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"!=")
+			    || robust_token_is_char<'&'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<'^'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<'|'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"&&")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"||")
+			    || robust_token_is_char<'?'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<':'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<'='>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"*=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"/=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"%=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"+=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"-=")
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,"<<=")
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,">>=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"&=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"^=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"|=")
+			    || robust_token_is_char<','>(src.data<0>()[i-1].index_tokens[0].token)) 
+				C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i],types);
 			assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i]));
 			return true;
 			};
@@ -6576,16 +6599,62 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,unary_subtype);
 			src.c_array<0>()[i].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
-			if (0==i)	// unless no predecessor possible
-				CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[0],types);
+			if (   0==i	// unless no predecessor possible
+				// operators also work
+			    || robust_token_is_char<'~'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_string<5>(src.data<0>()[i-1].index_tokens[0].token,"compl") 
+			    || robust_token_is_char<'!'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,"not") 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"++") 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"--") 
+			    || robust_token_is_char<'*'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'/'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'%'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'+'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'-'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"<<") 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,">>")
+			    || robust_token_is_char<'<'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'>'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"<=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,">=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"==")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"!=")
+			    || robust_token_is_string<6>(src.data<0>()[i-1].index_tokens[0].token,"not_eq")
+			    || robust_token_is_char<'&'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<6>(src.data<0>()[i-1].index_tokens[0].token,"bitand")
+			    || robust_token_is_char<'^'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,"xor")
+			    || robust_token_is_char<'|'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<5>(src.data<0>()[i-1].index_tokens[0].token,"bitor")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"&&")
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,"and")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"||")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"or")
+			    || robust_token_is_char<'?'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<':'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<'='>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"*=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"/=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"%=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"+=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"-=")
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,"<<=")
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,">>=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"&=")
+			    || robust_token_is_string<6>(src.data<0>()[i-1].index_tokens[0].token,"and_eq")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"^=")
+			    || robust_token_is_string<6>(src.data<0>()[i-1].index_tokens[0].token,"xor_eq")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"|=")
+			    || robust_token_is_string<5>(src.data<0>()[i-1].index_tokens[0].token,"or_eq")
+			    || robust_token_is_char<','>(src.data<0>()[i-1].index_tokens[0].token)) 
+				CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i],types);
 			assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i]));
 			return true;
 			};
@@ -6630,9 +6699,7 @@
 		{
 		assert(1<src.size<0>()-i);
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (   (PARSE_UNARY_EXPRESSION & src.data<0>()[i+1].flags)
 			|| (is_naked_parentheses_pair(src.data<0>()[i+1]) && (PARSE_TYPE & src.data<0>()[i+1].flags)))
@@ -6893,9 +6960,7 @@
 		{
 		assert(1<src.size<0>()-i);
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (is_naked_parentheses_pair(src.data<0>()[i+1]))
 			{
@@ -6916,7 +6981,8 @@
 		&& 	src.data<2>()->is_atomic()
 		&& 	C_TESTFLAG_IDENTIFIER==src.data<2>()->index_tokens[0].flags)
 		{
-		const int tmp = types.C_linkage_code(src.data<2>()->index_tokens[0].token.first);
+		const int tmp = C99_echo_reserved_keyword(src.data<2>()->index_tokens[0].token.first,src.data<2>()->index_tokens[0].token.second) ? -1
+			: types.C_linkage_code(src.data<2>()->index_tokens[0].token.first);
 		const bool is_negative = 0>tmp;
 		const umaxint tmp2(is_negative ? -tmp : tmp);
 		parse_tree tmp3;
@@ -6938,7 +7004,8 @@
 		&& 	src.data<2>()->is_atomic()
 		&& 	C_TESTFLAG_IDENTIFIER==src.data<2>()->index_tokens[0].flags)
 		{
-		const int tmp = types.CPP_linkage_code(src.data<2>()->index_tokens[0].token.first,parse_tree::active_namespace);
+		const int tmp = CPP_echo_reserved_keyword(src.data<2>()->index_tokens[0].token.first,src.data<2>()->index_tokens[0].token.second) ? -1
+			: types.CPP_linkage_code(src.data<2>()->index_tokens[0].token.first,parse_tree::active_namespace);
 		const bool is_negative = 0>tmp;
 		const umaxint tmp2(is_negative ? -tmp : tmp);
 		parse_tree tmp3;
@@ -7177,7 +7244,28 @@
 	if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i]))
 		{
 		if (1<=i && (PARSE_MULT_EXPRESSION & src.data<0>()[i-1].flags))
-			{
+			{	// check for unary +/- with type NOT_VOID
+				// if found, split out the +/- into slot i and adjust i up before proceeding
+			if (   is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1])
+				|| is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]))
+				{
+				if (   C_TYPE::NOT_VOID==src.data<0>()[i-1].type_code.base_type_index
+					&& 0==src.data<0>()[i-1].type_code.pointer_power)
+					{	// ,src.data<0>()[i-1].front<2>()
+#ifndef ZAIMONI_FORCE_ISO
+					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
+#else
+					if (!_insert_n_slots_at(src.args[0].first,src.args[0].second,1,i)) throw std::bad_alloc();
+#endif
+					src.c_array<0>()[i].clear();
+					src.c_array<0>()[i-1].front<2>().MoveInto(src.c_array<0>()[i]);
+					src.c_array<0>()[i-1].DeleteIdx<2>(0);
+					src.c_array<0>()[i-1].type_code.base_type_index = 0;
+					++i;
+					assert(PARSE_MULT_EXPRESSION & src.data<0>()[i-1].flags);
+					assert(is_C99_unary_operator_expression<'*'>(src.data<0>()[i]));
+					}
+				}
 			merge_binary_infix_argument(src,i,PARSE_STRICT_MULT_EXPRESSION);
 			assert(is_C99_mult_operator_expression(src.data<0>()[i]));
 			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
@@ -7198,7 +7286,28 @@
 	if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i]))
 		{
 		if (1<=i && (inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]),(PARSE_MULT_EXPRESSION & src.data<0>()[i-1].flags)))
-			{
+			{	// check for unary +/- with type NOT_VOID
+				// if found, split out the +/- into slot i and adjust i up before proceeding
+			if (   is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1])
+				|| is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]))
+				{
+				if (   C_TYPE::NOT_VOID==src.data<0>()[i-1].type_code.base_type_index
+					&& 0==src.data<0>()[i-1].type_code.pointer_power)
+					{	// ,src.data<0>()[i-1].front<2>()
+#ifndef ZAIMONI_FORCE_ISO
+					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
+#else
+					if (!_insert_n_slots_at(src.args[0].first,src.args[0].second,1,i)) throw std::bad_alloc();
+#endif
+					src.c_array<0>()[i].clear();
+					src.c_array<0>()[i-1].front<2>().MoveInto(src.c_array<0>()[i]);
+					src.c_array<0>()[i-1].DeleteIdx<2>(0);
+					src.c_array<0>()[i-1].type_code.base_type_index = 0;
+					++i;
+					assert(PARSE_MULT_EXPRESSION & src.data<0>()[i-1].flags);
+					assert(is_C99_unary_operator_expression<'*'>(src.data<0>()[i]));
+					}
+				}
 			merge_binary_infix_argument(src,i,PARSE_STRICT_MULT_EXPRESSION);
 			assert(is_C99_mult_operator_expression(src.data<0>()[i]));
 			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
@@ -7721,6 +7830,17 @@
 	if (terse_C99_augment_mult_expression(src,i,types))
 		{
 		C_mult_expression_easy_syntax_check(src.c_array<0>()[i],types);
+		// reconstitute raw +- from terse_C99_augment_mult_expression into unary +-
+		if (0<i)
+			{	// synchronize with locate_C99_unary_plusminus
+			if (const size_t unary_subtype 	= token_is_char<'-'>(src.data<0>()[i-1].index_tokens[0].token) ? C99_UNARY_SUBTYPE_NEG
+									: token_is_char<'+'>(src.data<0>()[i-1].index_tokens[0].token) ? C99_UNARY_SUBTYPE_PLUS : 0)
+				{
+				assemble_unary_postfix_arguments(src,i-1,unary_subtype);	// doesn't work: reference to temporary
+				src.c_array<0>()[i-1].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
+				assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]));
+				};
+			}
 		return;
 		}
 
@@ -7747,6 +7867,17 @@
 	if (terse_CPP_augment_mult_expression(src,i,types))
 		{	//! \todo handle operator overloading
 		CPP_mult_expression_easy_syntax_check(src.c_array<0>()[i],types);
+		// reconstitute raw +- from terse_CPP_augment_mult_expression into unary +-
+		if (0<i)
+			{	// synchronize with locate_CPP_unary_plusminus
+			if (const size_t unary_subtype 	= token_is_char<'-'>(src.data<0>()[i-1].index_tokens[0].token) ? C99_UNARY_SUBTYPE_NEG
+									: token_is_char<'+'>(src.data<0>()[i-1].index_tokens[0].token) ? C99_UNARY_SUBTYPE_PLUS : 0)
+				{
+				assemble_unary_postfix_arguments(src,i-1,unary_subtype);
+				src.c_array<0>()[i-1].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
+				assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]));
+				};
+			}
 		return;
 		}
 



From zaimoni at mail.berlios.de  Tue Jun  7 19:43:38 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue,  7 Jun 2011 19:43:38 +0200
Subject: [Zcplusplus-commits] r653 - trunk
Message-ID: <20110607174338.A8A9D480EB1@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-07 19:43:38 +0200 (Tue, 07 Jun 2011)
New Revision: 653

Modified:
   trunk/CSupport_pp.cpp
Log:
repair preprocessing to handle 10000*__ZCC__+100*__ZCC_MINOR__+__ZCC_PATCHLEVEL__

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2011-06-07 17:43:29 UTC (rev 652)
+++ trunk/CSupport_pp.cpp	2011-06-07 17:43:38 UTC (rev 653)
@@ -4292,7 +4292,7 @@
 }
 
 //! \throw std::bad_alloc
-static void assemble_unary_postfix_arguments(parse_tree& src, size_t& i, const size_t _subtype)
+static void assemble_unary_postfix_arguments(parse_tree& src, const size_t i, const size_t _subtype)
 {
 	assert(1<src.size<0>()-i);
 	parse_tree* const tmp = repurpose_inner_parentheses(src.c_array<0>()[i+1]);	// RAM conservation
@@ -4603,9 +4603,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -4629,9 +4627,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -4655,9 +4651,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -4681,9 +4675,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -4825,9 +4817,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -4851,9 +4841,7 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
@@ -5034,16 +5022,51 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,unary_subtype);
 			src.c_array<0>()[i].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
-			if (0==i)	// unless no predecessor possible
-				C_unary_plusminus_easy_syntax_check(src.c_array<0>()[0],types);
+			if (   0==i	// unless no predecessor possible
+				// operators also work
+			    || robust_token_is_char<'~'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'!'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"++") 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"--") 
+			    || robust_token_is_char<'*'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'/'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'%'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'+'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'-'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"<<") 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,">>")
+			    || robust_token_is_char<'<'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'>'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"<=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,">=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"==")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"!=")
+			    || robust_token_is_char<'&'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<'^'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<'|'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"&&")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"||")
+			    || robust_token_is_char<'?'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<':'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<'='>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"*=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"/=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"%=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"+=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"-=")
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,"<<=")
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,">>=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"&=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"^=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"|=")
+			    || robust_token_is_char<','>(src.data<0>()[i-1].index_tokens[0].token)) 
+				C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i],types);
 			assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i]));
 			return true;
 			};
@@ -5065,16 +5088,62 @@
 		{
 		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
-			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
-		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+		if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
 			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,unary_subtype);
 			src.c_array<0>()[i].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
-			if (0==i)	// unless no predecessor possible
-				CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[0],types);
+			if (   0==i	// unless no predecessor possible
+				// operators also work
+			    || robust_token_is_char<'~'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_string<5>(src.data<0>()[i-1].index_tokens[0].token,"compl") 
+			    || robust_token_is_char<'!'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,"not") 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"++") 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"--") 
+			    || robust_token_is_char<'*'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'/'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'%'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'+'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'-'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"<<") 
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,">>")
+			    || robust_token_is_char<'<'>(src.data<0>()[i-1].index_tokens[0].token) 
+			    || robust_token_is_char<'>'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"<=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,">=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"==")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"!=")
+			    || robust_token_is_string<6>(src.data<0>()[i-1].index_tokens[0].token,"not_eq")
+			    || robust_token_is_char<'&'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<6>(src.data<0>()[i-1].index_tokens[0].token,"bitand")
+			    || robust_token_is_char<'^'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,"xor")
+			    || robust_token_is_char<'|'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<5>(src.data<0>()[i-1].index_tokens[0].token,"bitor")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"&&")
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,"and")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"||")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"or")
+			    || robust_token_is_char<'?'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<':'>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_char<'='>(src.data<0>()[i-1].index_tokens[0].token)
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"*=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"/=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"%=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"+=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"-=")
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,"<<=")
+			    || robust_token_is_string<3>(src.data<0>()[i-1].index_tokens[0].token,">>=")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"&=")
+			    || robust_token_is_string<6>(src.data<0>()[i-1].index_tokens[0].token,"and_eq")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"^=")
+			    || robust_token_is_string<6>(src.data<0>()[i-1].index_tokens[0].token,"xor_eq")
+			    || robust_token_is_string<2>(src.data<0>()[i-1].index_tokens[0].token,"|=")
+			    || robust_token_is_string<5>(src.data<0>()[i-1].index_tokens[0].token,"or_eq")
+			    || robust_token_is_char<','>(src.data<0>()[i-1].index_tokens[0].token)) 
+				CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i],types);
 			assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i]));
 			return true;
 			};
@@ -5283,7 +5352,28 @@
 	if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i]))
 		{
 		if (1<=i && (PARSE_MULT_EXPRESSION & src.data<0>()[i-1].flags))
-			{
+			{	// check for unary +/- with type NOT_VOID
+				// if found, split out the +/- into slot i and adjust i up before proceeding
+			if (   is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1])
+				|| is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]))
+				{
+				if (   C_TYPE::NOT_VOID==src.data<0>()[i-1].type_code.base_type_index
+					&& 0==src.data<0>()[i-1].type_code.pointer_power)
+					{	// ,src.data<0>()[i-1].front<2>()
+#ifndef ZAIMONI_FORCE_ISO
+					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
+#else
+					if (!_insert_n_slots_at(src.args[0].first,src.args[0].second,1,i)) throw std::bad_alloc();
+#endif
+					src.c_array<0>()[i].clear();
+					src.c_array<0>()[i-1].front<2>().MoveInto(src.c_array<0>()[i]);
+					src.c_array<0>()[i-1].DeleteIdx<2>(0);
+					src.c_array<0>()[i-1].type_code.base_type_index = 0;
+					++i;
+					assert(PARSE_MULT_EXPRESSION & src.data<0>()[i-1].flags);
+					assert(is_C99_unary_operator_expression<'*'>(src.data<0>()[i]));
+					}
+				}
 			merge_binary_infix_argument(src,i,PARSE_STRICT_MULT_EXPRESSION);
 			assert(is_C99_mult_operator_expression(src.data<0>()[i]));
 			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
@@ -5304,7 +5394,28 @@
 	if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i]))
 		{
 		if (1<=i && (inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]),(PARSE_MULT_EXPRESSION & src.data<0>()[i-1].flags)))
-			{
+			{	// check for unary +/- with type NOT_VOID
+				// if found, split out the +/- into slot i and adjust i up before proceeding
+			if (   is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1])
+				|| is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]))
+				{
+				if (   C_TYPE::NOT_VOID==src.data<0>()[i-1].type_code.base_type_index
+					&& 0==src.data<0>()[i-1].type_code.pointer_power)
+					{	// ,src.data<0>()[i-1].front<2>()
+#ifndef ZAIMONI_FORCE_ISO
+					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
+#else
+					if (!_insert_n_slots_at(src.args[0].first,src.args[0].second,1,i)) throw std::bad_alloc();
+#endif
+					src.c_array<0>()[i].clear();
+					src.c_array<0>()[i-1].front<2>().MoveInto(src.c_array<0>()[i]);
+					src.c_array<0>()[i-1].DeleteIdx<2>(0);
+					src.c_array<0>()[i-1].type_code.base_type_index = 0;
+					++i;
+					assert(PARSE_MULT_EXPRESSION & src.data<0>()[i-1].flags);
+					assert(is_C99_unary_operator_expression<'*'>(src.data<0>()[i]));
+					}
+				}
 			merge_binary_infix_argument(src,i,PARSE_STRICT_MULT_EXPRESSION);
 			assert(is_C99_mult_operator_expression(src.data<0>()[i]));
 			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
@@ -5800,6 +5911,17 @@
 	if (terse_C99_augment_mult_expression(src,i,types))
 		{
 		C_mult_expression_easy_syntax_check(src.c_array<0>()[i],types);
+		// reconstitute raw +- from terse_C99_augment_mult_expression into unary +-
+		if (0<i)
+			{	// synchronize with locate_C99_unary_plusminus
+			if (const size_t unary_subtype 	= token_is_char<'-'>(src.data<0>()[i-1].index_tokens[0].token) ? C99_UNARY_SUBTYPE_NEG
+									: token_is_char<'+'>(src.data<0>()[i-1].index_tokens[0].token) ? C99_UNARY_SUBTYPE_PLUS : 0)
+				{
+				assemble_unary_postfix_arguments(src,i-1,unary_subtype);	// doesn't work: reference to temporary
+				src.c_array<0>()[i-1].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
+				assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]));
+				};
+			}
 		return;
 		}
 
@@ -5826,6 +5948,17 @@
 	if (terse_CPP_augment_mult_expression(src,i,types))
 		{	//! \todo handle operator overloading
 		CPP_mult_expression_easy_syntax_check(src.c_array<0>()[i],types);
+		// reconstitute raw +- from terse_CPP_augment_mult_expression into unary +-
+		if (0<i)
+			{	// synchronize with locate_CPP_unary_plusminus
+			if (const size_t unary_subtype 	= token_is_char<'-'>(src.data<0>()[i-1].index_tokens[0].token) ? C99_UNARY_SUBTYPE_NEG
+									: token_is_char<'+'>(src.data<0>()[i-1].index_tokens[0].token) ? C99_UNARY_SUBTYPE_PLUS : 0)
+				{
+				assemble_unary_postfix_arguments(src,i-1,unary_subtype);
+				src.c_array<0>()[i-1].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
+				assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]));
+				};
+			}
 		return;
 		}
 



From zaimoni at mail.berlios.de  Tue Jun  7 19:44:32 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue,  7 Jun 2011 19:44:32 +0200
Subject: [Zcplusplus-commits] r654 - trunk/tests/zcc
Message-ID: <20110607174432.40FFC480EB1@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-07 19:44:32 +0200 (Tue, 07 Jun 2011)
New Revision: 654

Modified:
   trunk/tests/zcc/Pass_cstddef.hpp
   trunk/tests/zcc/Pass_stddef_h.h
   trunk/tests/zcc/Pass_stddef_h.hpp
Log:
test linkage for typedefs in stddef.h/cstddef

Modified: trunk/tests/zcc/Pass_cstddef.hpp
===================================================================
--- trunk/tests/zcc/Pass_cstddef.hpp	2011-06-07 17:43:38 UTC (rev 653)
+++ trunk/tests/zcc/Pass_cstddef.hpp	2011-06-07 17:44:32 UTC (rev 654)
@@ -1,5 +1,5 @@
 // zcc/Pass_cstddef.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 #include <cstddef>
 
@@ -95,3 +95,10 @@
 extern const volatile std::ptrdiff_t j13;
 extern const volatile std::size_t k13;
 
+// following is guarded to be run only by ZCC and impersonators
+#if 9<=10000*__ZCC__+100*__ZCC_MINOR__+__ZCC_PATCHLEVEL__
+// ZC++ 0.0.9 supports __zcc_linkage
+// typedefs have no linkage in C
+static_assert(0==__zcc_linkage(std::ptrdiff_t),"std::ptrdiff_t should be defined with no linkage");
+static_assert(0==__zcc_linkage(std::size_t),"std::size_t should be defined with no linkage");
+#endif

Modified: trunk/tests/zcc/Pass_stddef_h.h
===================================================================
--- trunk/tests/zcc/Pass_stddef_h.h	2011-06-07 17:43:38 UTC (rev 653)
+++ trunk/tests/zcc/Pass_stddef_h.h	2011-06-07 17:44:32 UTC (rev 654)
@@ -1,5 +1,5 @@
 // zcc/Pass_stddef_h.h
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 #include <stddef.h>
 
@@ -114,3 +114,11 @@
 extern const volatile size_t k13;
 extern const volatile wchar_t m13;
 
+// following is guarded to be run only by ZCC and impersonators
+#if 9<=10000*__ZCC__+100*__ZCC_MINOR__+__ZCC_PATCHLEVEL__
+// ZC++ 0.0.9 supports __zcc_linkage
+// typedefs have no linkage in C
+_Static_Assert(0==__zcc_linkage(ptrdiff_t),"ptrdiff_t should be defined with no linkage");
+_Static_Assert(0==__zcc_linkage(size_t),"ptrdiff_t should be defined with no linkage");
+_Static_Assert(0==__zcc_linkage(wchar_t),"wchar_t should be defined with no linkage");
+#endif

Modified: trunk/tests/zcc/Pass_stddef_h.hpp
===================================================================
--- trunk/tests/zcc/Pass_stddef_h.hpp	2011-06-07 17:43:38 UTC (rev 653)
+++ trunk/tests/zcc/Pass_stddef_h.hpp	2011-06-07 17:44:32 UTC (rev 654)
@@ -1,5 +1,5 @@
 // zcc/Pass_stddef_h.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 #include <stddef.h>
 
@@ -169,3 +169,11 @@
 extern const volatile ptrdiff_t m13;
 extern const volatile size_t n13;
 
+// following is guarded to be run only by ZCC and impersonators
+#if 9<=10000*__ZCC__+100*__ZCC_MINOR__+__ZCC_PATCHLEVEL__
+// ZC++ 0.0.9 supports __zcc_linkage
+// typedefs have no linkage in C
+static_assert(0==__zcc_linkage(ptrdiff_t),"ptrdiff_t should be defined with no linkage");
+static_assert(0==__zcc_linkage(size_t),"size_t should be defined with no linkage");
+static_assert(-1==__zcc_linkage(wchar_t),"wchar_t is a keyword, should not be defined at all");
+#endif



From zaimoni at mail.berlios.de  Wed Jun  8 03:09:01 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed,  8 Jun 2011 03:09:01 +0200
Subject: [Zcplusplus-commits] r655 - trunk
Message-ID: <20110608010901.B66AD481127@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-08 03:09:00 +0200 (Wed, 08 Jun 2011)
New Revision: 655

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/CSupport_pp.cpp
   trunk/type_spec.hpp
   trunk/type_system.cpp
   trunk/type_system.cpp.in
   trunk/type_system_pp.cpp
Log:
introduce type_spec::is_type for source code reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-06-07 17:44:32 UTC (rev 654)
+++ trunk/CSupport.cpp	2011-06-08 01:09:00 UTC (rev 655)
@@ -1,6 +1,6 @@
 // CSupport.cpp
 // support for C/C++ parsing
-// (C)2009, 2010 Kenneth Boyd, license: MIT.txt
+// (C)2009-2011 Kenneth Boyd, license: MIT.txt
 
 #include "CSupport.hpp"
 #include "_CSupport3.hpp"
@@ -4023,8 +4023,7 @@
 			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags)
-			&&	C_TYPE::TYPEINFO==src.type_code.base_type_index
-			&&	0==src.type_code.pointer_power
+			&&	src.type_code.is_type(C_TYPE::TYPEINFO)
 			&&	(src.type_code.qualifier<0>() & (type_spec::lvalue | type_spec::_const))==(type_spec::lvalue | type_spec::_const);
 }
 
@@ -6212,7 +6211,7 @@
 	if (is_logical_NOT(*src.data<2>()))
 		{
 		if (	is_logical_NOT(*src.data<2>()->data<2>())
-			||	(C_TYPE::BOOL==src.data<2>()->type_code.base_type_index && 0==src.data<2>()->type_code.pointer_power))
+			||	src.data<2>()->type_code.is_type(C_TYPE::BOOL))
 			{
 			parse_tree tmp;
 			src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
@@ -7249,9 +7248,8 @@
 			if (   is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1])
 				|| is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]))
 				{
-				if (   C_TYPE::NOT_VOID==src.data<0>()[i-1].type_code.base_type_index
-					&& 0==src.data<0>()[i-1].type_code.pointer_power)
-					{	// ,src.data<0>()[i-1].front<2>()
+				if (src.data<0>()[i-1].type_code.is_type<C_TYPE::NOT_VOID>())
+					{
 #ifndef ZAIMONI_FORCE_ISO
 					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
 #else
@@ -7291,9 +7289,8 @@
 			if (   is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1])
 				|| is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]))
 				{
-				if (   C_TYPE::NOT_VOID==src.data<0>()[i-1].type_code.base_type_index
-					&& 0==src.data<0>()[i-1].type_code.pointer_power)
-					{	// ,src.data<0>()[i-1].front<2>()
+				if (src.data<0>()[i-1].type_code.is_type<C_TYPE::NOT_VOID>())
+					{
 #ifndef ZAIMONI_FORCE_ISO
 					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
 #else

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-06-07 17:44:32 UTC (rev 654)
+++ trunk/CSupport.cpp.in	2011-06-08 01:09:00 UTC (rev 655)
@@ -5,7 +5,7 @@
 // CSupport_pp.cpp
 #/*cut-nocpp*/
 // support for C/C++ parsing
-// (C)2009, 2010 Kenneth Boyd, license: MIT.txt
+// (C)2009-2011 Kenneth Boyd, license: MIT.txt
 
 #/*cut-cpp*/
 #include "CSupport.hpp"
@@ -4087,8 +4087,7 @@
 			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags)
-			&&	C_TYPE::TYPEINFO==src.type_code.base_type_index
-			&&	0==src.type_code.pointer_power
+			&&	src.type_code.is_type<C_TYPE::TYPEINFO>()
 			&&	(src.type_code.qualifier<0>() & (type_spec::lvalue | type_spec::_const))==(type_spec::lvalue | type_spec::_const);
 }
 
@@ -6307,7 +6306,7 @@
 	if (is_logical_NOT(*src.data<2>()))
 		{
 		if (	is_logical_NOT(*src.data<2>()->data<2>())
-			||	(C_TYPE::BOOL==src.data<2>()->type_code.base_type_index && 0==src.data<2>()->type_code.pointer_power))
+			||	src.data<2>()->type_code.is_type<C_TYPE::BOOL>())
 			{
 			parse_tree tmp;
 			src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
@@ -7352,9 +7351,8 @@
 			if (   is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1])
 				|| is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]))
 				{
-				if (   C_TYPE::NOT_VOID==src.data<0>()[i-1].type_code.base_type_index
-					&& 0==src.data<0>()[i-1].type_code.pointer_power)
-					{	// ,src.data<0>()[i-1].front<2>()
+				if (src.data<0>()[i-1].type_code.is_type<C_TYPE::NOT_VOID>())
+					{
 #ifndef ZAIMONI_FORCE_ISO
 					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
 #else
@@ -7394,9 +7392,8 @@
 			if (   is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1])
 				|| is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]))
 				{
-				if (   C_TYPE::NOT_VOID==src.data<0>()[i-1].type_code.base_type_index
-					&& 0==src.data<0>()[i-1].type_code.pointer_power)
-					{	// ,src.data<0>()[i-1].front<2>()
+				if (src.data<0>()[i-1].type_code.is_type<C_TYPE::NOT_VOID>())
+					{
 #ifndef ZAIMONI_FORCE_ISO
 					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
 #else

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2011-06-07 17:44:32 UTC (rev 654)
+++ trunk/CSupport_pp.cpp	2011-06-08 01:09:00 UTC (rev 655)
@@ -1,6 +1,6 @@
 // CSupport_pp.cpp
 // support for C/C++ parsing
-// (C)2009, 2010 Kenneth Boyd, license: MIT.txt
+// (C)2009-2011 Kenneth Boyd, license: MIT.txt
 
 #include "CSupport_pp.hpp"
 #include "_CSupport1.hpp"
@@ -4706,7 +4706,7 @@
 	if (is_logical_NOT(*src.data<2>()))
 		{
 		if (	is_logical_NOT(*src.data<2>()->data<2>())
-			||	(C_TYPE::BOOL==src.data<2>()->type_code.base_type_index && 0==src.data<2>()->type_code.pointer_power))
+			||	src.data<2>()->type_code.is_type(C_TYPE::BOOL))
 			{
 			parse_tree tmp;
 			src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
@@ -5357,9 +5357,8 @@
 			if (   is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1])
 				|| is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]))
 				{
-				if (   C_TYPE::NOT_VOID==src.data<0>()[i-1].type_code.base_type_index
-					&& 0==src.data<0>()[i-1].type_code.pointer_power)
-					{	// ,src.data<0>()[i-1].front<2>()
+				if (src.data<0>()[i-1].type_code.is_type<C_TYPE::NOT_VOID>())
+					{
 #ifndef ZAIMONI_FORCE_ISO
 					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
 #else
@@ -5399,9 +5398,8 @@
 			if (   is_C99_unary_operator_expression<'+'>(src.data<0>()[i-1])
 				|| is_C99_unary_operator_expression<'-'>(src.data<0>()[i-1]))
 				{
-				if (   C_TYPE::NOT_VOID==src.data<0>()[i-1].type_code.base_type_index
-					&& 0==src.data<0>()[i-1].type_code.pointer_power)
-					{	// ,src.data<0>()[i-1].front<2>()
+				if (src.data<0>()[i-1].type_code.is_type<C_TYPE::NOT_VOID>())
+					{
 #ifndef ZAIMONI_FORCE_ISO
 					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
 #else

Modified: trunk/type_spec.hpp
===================================================================
--- trunk/type_spec.hpp	2011-06-07 17:44:32 UTC (rev 654)
+++ trunk/type_spec.hpp	2011-06-08 01:09:00 UTC (rev 655)
@@ -59,6 +59,8 @@
 	void clear();	// XXX should be constructor; good way to leak memory in other contexts
 	void destroy();	// XXX should be destructor
 	void set_type(size_t _base_type_index);
+	template<size_t _base_type_index >bool is_type() const {return _base_type_index==base_type_index && 0==pointer_power;}
+	bool is_type(const size_t _base_type_index) const {return _base_type_index==base_type_index && 0==pointer_power;};
 	bool operator==(const type_spec& rhs) const;
 	bool operator!=(const type_spec& rhs) const {return !(*this==rhs);};
 

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2011-06-07 17:44:32 UTC (rev 654)
+++ trunk/type_system.cpp	2011-06-08 01:09:00 UTC (rev 655)
@@ -1,5 +1,5 @@
 // type_system.cpp
-// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+// (C)2009-2011 Kenneth Boyd, license: MIT.txt
 
 #include "type_system.hpp"
 #include "enum_type.hpp"
@@ -391,7 +391,8 @@
 	const zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> >* const iter_end = typedef_registry.end();
 	while(iter!=iter_end)
 		{
-		if (base_type_index==iter->second.first.base_type_index && 0==iter->second.first.pointer_power) return iter->first;
+		if (iter->second.first.is_type(base_type_index))
+			return iter->first;
 		++iter;
 		};
 	return NULL;

Modified: trunk/type_system.cpp.in
===================================================================
--- trunk/type_system.cpp.in	2011-06-07 17:44:32 UTC (rev 654)
+++ trunk/type_system.cpp.in	2011-06-08 01:09:00 UTC (rev 655)
@@ -4,7 +4,7 @@
 #/*cut-nocpp*/
 // type_system_pp.cpp
 #/*cut-nocpp*/
-// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+// (C)2009-2011 Kenneth Boyd, license: MIT.txt
 
 #/*cut-cpp*/
 #include "type_system.hpp"
@@ -406,7 +406,8 @@
 	const zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> >* const iter_end = typedef_registry.end();
 	while(iter!=iter_end)
 		{
-		if (base_type_index==iter->second.first.base_type_index && 0==iter->second.first.pointer_power) return iter->first;
+		if (iter->second.first.is_type(base_type_index))
+			return iter->first;
 		++iter;
 		};
 	return NULL;

Modified: trunk/type_system_pp.cpp
===================================================================
--- trunk/type_system_pp.cpp	2011-06-07 17:44:32 UTC (rev 654)
+++ trunk/type_system_pp.cpp	2011-06-08 01:09:00 UTC (rev 655)
@@ -1,5 +1,5 @@
 // type_system_pp.cpp
-// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+// (C)2009-2011 Kenneth Boyd, license: MIT.txt
 
 #include "type_system_pp.hpp"
 



From zaimoni at mail.berlios.de  Wed Jun  8 08:19:42 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed,  8 Jun 2011 08:19:42 +0200
Subject: [Zcplusplus-commits] r656 - trunk/Zaimoni.STL
Message-ID: <20110608061943.1DC22481247@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-08 08:19:42 +0200 (Wed, 08 Jun 2011)
New Revision: 656

Modified:
   trunk/Zaimoni.STL/AutoPtr.hpp
Log:
start construction of POD version of the autoarray classes

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-08 01:09:00 UTC (rev 655)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-08 06:19:42 UTC (rev 656)
@@ -1,6 +1,6 @@
 // AutoPtr.hpp
 // a family of pointers that automatically delete themselves when going out of scope
-// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+// (C)2009-2011 Kenneth Boyd, license: MIT.txt
 
 // autodel_ptr: single pointer
 // weakautoarray_ptr: array of weak pointers
@@ -38,7 +38,7 @@
 	void reset(T*& src);
 	void MoveInto(_meta_auto_ptr<T>& dest) {dest.reset(_ptr);};
 
-	template<typename U> void TransferOutAndNULL(U*& Target) {_single_flush(Target); Target = _ptr; _ptr = NULL;}
+	template<typename U> void TransferOutAndNULL(U*& dest) {_single_flush(dest); dest = _ptr; _ptr = NULL;}
 	T* release() {T* tmp = _ptr; _ptr = NULL; return tmp;};
 	bool empty() const {return NULL==_ptr;};
 	void NULLPtr() {_ptr = NULL;};
@@ -153,62 +153,87 @@
 	void resize(size_t n) {if (!static_cast<Derived*>(this)->Resize(n)) throw std::bad_alloc();};	
 };
 
+// POD backing class for the autoarray and weak autoarray family
 template<typename T>
-class _meta_weakautoarray_ptr : public c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>
+class POD_autoarray_ptr
 {
-private:
-	friend class c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>;
-	friend bool operator==<>(const c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>& lhs, const c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>& rhs);
+protected:
 	T* _ptr;
 #ifdef ZAIMONI_FORCE_ISO
 	size_t _size;
 #endif
+};
+
+} // namespace zaimoni
+
+namespace boost {
+
+#define ZAIMONI_TEMPLATE_SPEC template<typename T>
+#define ZAIMONI_CLASS_SPEC zaimoni::POD_autoarray_ptr<T>
+ZAIMONI_POD_STRUCT(ZAIMONI_TEMPLATE_SPEC,ZAIMONI_CLASS_SPEC,char)
+#undef ZAIMONI_CLASS_SPEC
+#undef ZAIMONI_TEMPLATE_SPEC
+
+} // namespace boost
+
+namespace zaimoni {
+
+template<typename T>
+#if 2
+class _meta_weakautoarray_ptr : public c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>,public POD_autoarray_ptr<T>
+#else
+class _meta_weakautoarray_ptr : public c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>,protected POD_autoarray_ptr<T>
+#endif
+{
+private:
+	friend class c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>;
+	friend bool operator==<>(const c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>& lhs, const c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>& rhs);
 public:
 #ifndef ZAIMONI_FORCE_ISO
-	explicit _meta_weakautoarray_ptr() : _ptr(NULL) {};
-	explicit _meta_weakautoarray_ptr(T*& src) : _ptr(src) {src = NULL;};
-	explicit _meta_weakautoarray_ptr(size_t n) : _ptr(n ? _new_buffer_nonNULL_throws<T>(n) : NULL) {};
-	explicit _meta_weakautoarray_ptr(const std::nothrow_t& tracer, size_t n) : _ptr(_new_buffer<T>(n)) {};
-	explicit _meta_weakautoarray_ptr(const _meta_weakautoarray_ptr& src) : _ptr(NULL) {*this=src;};
+	explicit _meta_weakautoarray_ptr() {this->_ptr = NULL;};
+	explicit _meta_weakautoarray_ptr(T*& src) {this->_ptr = src; src = NULL;};
+	explicit _meta_weakautoarray_ptr(size_t n) {this->_ptr = n ? _new_buffer_nonNULL_throws<T>(n) : NULL;};
+	explicit _meta_weakautoarray_ptr(const std::nothrow_t& tracer, size_t n) {this->_ptr = _new_buffer<T>(n);};
+	explicit _meta_weakautoarray_ptr(const _meta_weakautoarray_ptr& src) {this->_ptr = NULL; *this=src;};
 #else
-	explicit _meta_weakautoarray_ptr() : _ptr(NULL),_size(0) {};
-	explicit _meta_weakautoarray_ptr(T*& src,size_t src_size) : _ptr(src),_size(src_size) {src = NULL;};
-	explicit _meta_weakautoarray_ptr(size_t n) : _ptr(n ? _new_buffer_nonNULL_throws<T>(n) : NULL),_size(n) {};
-	explicit _meta_weakautoarray_ptr(const std::nothrow_t& tracer, size_t n) : _ptr(_new_buffer<T>(n)),_size(n) {};
-	explicit _meta_weakautoarray_ptr(const _meta_weakautoarray_ptr& src) : _ptr(NULL),_size(0) {*this=src;};
+	explicit _meta_weakautoarray_ptr() {this->_ptr = NULL; this->_size = 0;};
+	explicit _meta_weakautoarray_ptr(T*& src,size_t src_size) {this->_ptr = src; this->_size = src_size; src = NULL;};
+	explicit _meta_weakautoarray_ptr(size_t n) {this->_ptr = n ? _new_buffer_nonNULL_throws<T>(n) : NULL; this->_size = n;};
+	explicit _meta_weakautoarray_ptr(const std::nothrow_t& tracer, size_t n) {this->_ptr = _new_buffer<T>(n); this->_size = n;};
+	explicit _meta_weakautoarray_ptr(const _meta_weakautoarray_ptr& src) {this->_ptr = NULL; this->_size = 0; *this=src;};
 #endif
-	~_meta_weakautoarray_ptr() {_weak_flush(_ptr);};
+	~_meta_weakautoarray_ptr() {_weak_flush(this->_ptr);};
 
 #ifndef ZAIMONI_FORCE_ISO
 	void operator=(T* src);
 #endif
 	void operator=(const _meta_weakautoarray_ptr& src);
 	template<typename U> bool value_copy_of(const U& src);	// STL interfaces required of U: size(),data()
-	void reset() {_weak_flush(_ptr); this->NULLPtr();};
+	void reset() {_weak_flush(this->_ptr); this->NULLPtr();};
 	void reset(T*& src);
-	void MoveInto(_meta_weakautoarray_ptr<T>& dest) {dest.reset(_ptr);};
+	void MoveInto(_meta_weakautoarray_ptr<T>& dest) {dest.reset(this->_ptr);};
 
-	void TransferOutAndNULL(T*& Target) {_weak_flush(Target); Target = _ptr; this->NULLPtr();}
+	void TransferOutAndNULL(T*& dest) {_weak_flush(dest); dest = this->_ptr; this->NULLPtr();}
 #ifndef ZAIMONI_FORCE_ISO
-	bool Resize(size_t n) {return _weak_resize(_ptr,n);};
+	bool Resize(size_t n) {return _weak_resize(this->_ptr,n);};
 #else
-	bool Resize(size_t n) {return _weak_resize(_ptr,_size,n);};
+	bool Resize(size_t n) {return _weak_resize(this->_ptr,this->_size,n);};
 #endif
-	void FastDeleteIdx(size_t n) {_weak_delete_idx(_ptr,n);};
+	void FastDeleteIdx(size_t n) {_weak_delete_idx(this->_ptr,n);};
 #ifndef ZAIMONI_FORCE_ISO
-	void DeleteIdx(size_t n) {_safe_weak_delete_idx(_ptr,n);};
+	void DeleteIdx(size_t n) {_safe_weak_delete_idx(this->_ptr,n);};
 #else
-	void DeleteIdx(size_t n) {_safe_weak_delete_idx(_ptr,_size,n);};
+	void DeleteIdx(size_t n) {_safe_weak_delete_idx(this->_ptr,this->_size,n);};
 #endif
-	void DeleteNSlotsAt(size_t n, size_t Idx) {_weak_delete_n_slots_at(_ptr,n,Idx);};
-
+	void DeleteNSlotsAt(size_t n, size_t Idx) {_weak_delete_n_slots_at(this->_ptr,n,Idx);};
+	
 	// Perl grep
 	// next two require of U: STL size(),data()
 	template<typename U,typename op> bool grep(const U& src,op Predicate);
 	template<typename U,typename op> bool invgrep(const U& src,op Predicate);
 
 	// erase all elements
-	void clear() {_weak_flush(_ptr); this->NULLPtr();};
+	void clear() {_weak_flush(this->_ptr); this->NULLPtr();};
 };
 
 template<typename T>
@@ -293,30 +318,30 @@
 };
 
 template<typename T>
-class _meta_autoarray_ptr : public c_var_array_CRTP<_meta_autoarray_ptr<T>, T>
+#if 2
+class _meta_autoarray_ptr : public c_var_array_CRTP<_meta_autoarray_ptr<T>, T>,public POD_autoarray_ptr<T>
+#else
+class _meta_autoarray_ptr : public c_var_array_CRTP<_meta_autoarray_ptr<T>, T>,protected POD_autoarray_ptr<T>
+#endif
 {
 protected:
 	friend class c_var_array_CRTP<_meta_autoarray_ptr<T>, T>;
 	friend bool operator==<>(const c_var_array_CRTP<_meta_autoarray_ptr<T>, T>& lhs, const c_var_array_CRTP<_meta_autoarray_ptr<T>, T>& rhs);
-	T* _ptr;
-#ifdef ZAIMONI_FORCE_ISO
-	size_t _size;
-#endif
 
 #ifndef ZAIMONI_FORCE_ISO
-	explicit _meta_autoarray_ptr() : _ptr(NULL) {};
-	explicit _meta_autoarray_ptr(T*& src) : _ptr(src) {src = NULL;};
-	explicit _meta_autoarray_ptr(size_t n) : _ptr(n ? _new_buffer_nonNULL_throws<T>(n) : NULL) {};
-	explicit _meta_autoarray_ptr(const std::nothrow_t& tracer, size_t n) : _ptr(_new_buffer<T>(n)) {};
-	explicit _meta_autoarray_ptr(const _meta_autoarray_ptr& src) : _ptr(NULL) {*this=src;};
+	explicit _meta_autoarray_ptr() {this->_ptr = NULL;};
+	explicit _meta_autoarray_ptr(T*& src) {this->_ptr = src; src = NULL;};
+	explicit _meta_autoarray_ptr(size_t n) {this->_ptr = n ? _new_buffer_nonNULL_throws<T>(n) : NULL;};
+	explicit _meta_autoarray_ptr(const std::nothrow_t& tracer, size_t n) {this->_ptr = _new_buffer<T>(n);};
+	explicit _meta_autoarray_ptr(const _meta_autoarray_ptr& src) {this->_ptr = NULL; *this=src;};
 #else
-	explicit _meta_autoarray_ptr() : _ptr(NULL),_size(0) {};
-	explicit _meta_autoarray_ptr(T*& src,size_t src_size) : _ptr(src),_size(src_size) {src = NULL;};
-	explicit _meta_autoarray_ptr(size_t n) : _ptr(n ? _new_buffer_nonNULL_throws<T>(n) : NULL),_size(n) {};
-	explicit _meta_autoarray_ptr(const std::nothrow_t& tracer, size_t n) : _ptr(_new_buffer<T>(n)),_size(n) {};
-	explicit _meta_autoarray_ptr(const _meta_autoarray_ptr& src) : _ptr(NULL),_size(0) {*this=src;};
+	explicit _meta_autoarray_ptr() {this->_ptr = NULL; this->_size = 0;};
+	explicit _meta_autoarray_ptr(T*& src,size_t src_size) {this->_ptr = src; this->_size = src_size; src = NULL;};
+	explicit _meta_autoarray_ptr(size_t n) {this->_ptr = n ? _new_buffer_nonNULL_throws<T>(n) : NULL; this->_size = n;};
+	explicit _meta_autoarray_ptr(const std::nothrow_t& tracer, size_t n) {this->_ptr = _new_buffer<T>(n); this->_size = n;};
+	explicit _meta_autoarray_ptr(const _meta_autoarray_ptr& src) {this->_ptr = NULL; this->_size = 0; *this=src;};
 #endif
-	~_meta_autoarray_ptr() {_flush(_ptr);};
+	~_meta_autoarray_ptr() {_flush(this->_ptr);};
 
 #ifndef ZAIMONI_FORCE_ISO
 	void operator=(T* src);
@@ -328,38 +353,38 @@
 	ZAIMONI_STL_TYPE_GLUE_ARRAY(T);
 
 	template<typename U> bool value_copy_of(const U& src);	// STL interfaces required of U: size(),data()
-	void reset() {_flush(_ptr); this->NULLPtr();};
+	void reset() {_flush(this->_ptr); this->NULLPtr();};
 	void reset(T*& src);
-	void MoveInto(_meta_autoarray_ptr<T>& dest) {dest.reset(_ptr);};
+	void MoveInto(_meta_autoarray_ptr<T>& dest) {dest.reset(this->_ptr);};
 
-	void TransferOutAndNULL(T*& Target) {_flush(Target); Target = _ptr; this->NULLPtr();};
+	void TransferOutAndNULL(T*& dest) {_flush(dest); dest = this->_ptr; this->NULLPtr();};
 #ifndef ZAIMONI_FORCE_ISO
-	bool Resize(size_t n) {return _resize(_ptr,n);};
-	void Shrink(size_t n) {_shrink(_ptr,n);};
+	bool Resize(size_t n) {return _resize(this->_ptr,n);};
+	void Shrink(size_t n) {_shrink(this->_ptr,n);};
 #else
-	bool Resize(size_t n) {return _resize(_ptr,_size,n);};
-	void Shrink(size_t n) {_shrink(_ptr,_size,n);};
+	bool Resize(size_t n) {return _resize(this->_ptr,this->_size,n);};
+	void Shrink(size_t n) {_shrink(this->_ptr,this->_size,n);};
 #endif
-	void FastDeleteIdx(size_t n) {_delete_idx(_ptr,n);};
+	void FastDeleteIdx(size_t n) {_delete_idx(this->_ptr,n);};
 #ifndef ZAIMONI_FORCE_ISO
-	void DeleteIdx(size_t n) {_safe_delete_idx(_ptr,n);};
-	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(_ptr,n,Idx);};
-	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(_ptr,indexes,n);};
-	template<typename U> bool InsertSlotAt(size_t Idx, U __default) {return _insert_slot_at(_ptr,Idx,__default);}
+	void DeleteIdx(size_t n) {_safe_delete_idx(this->_ptr,n);};
+	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(this->_ptr,n,Idx);};
+	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,indexes,n);};
+	template<typename U> bool InsertSlotAt(size_t Idx, U __default) {return _insert_slot_at(this->_ptr,Idx,__default);}
 #else
-	void DeleteIdx(size_t n) {_safe_delete_idx(_ptr,_size,n);};
-	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(_ptr,_size,n,Idx);};
-	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(_ptr,_size,indexes,n);};
-	template<typename U> bool InsertSlotAt(size_t Idx, U __default) {return _insert_slot_at(_ptr,_size,Idx,__default);}
+	void DeleteIdx(size_t n) {_safe_delete_idx(this->_ptr,this->_size,n);};
+	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(this->_ptr,this->_size,n,Idx);};
+	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,this->_size,indexes,n);};
+	template<typename U> bool InsertSlotAt(size_t Idx, U __default) {return _insert_slot_at(this->_ptr,this->_size,Idx,__default);}
 #endif
 
 	// Perl grep
 	// these two assume T has valid * operator
-	template<typename U> bool grep(UnaryPredicate* Predicate,_meta_autoarray_ptr<U*>& Target) const;
-	template<typename U> bool invgrep(UnaryPredicate* Predicate,_meta_autoarray_ptr<U*>& Target) const;
+	template<typename U> bool grep(UnaryPredicate* Predicate,_meta_autoarray_ptr<U*>& dest) const;
+	template<typename U> bool invgrep(UnaryPredicate* Predicate,_meta_autoarray_ptr<U*>& dest) const;
 
 	// erase all elements
-	void clear() {_flush(_ptr); this->NULLPtr();};
+	void clear() {_flush(this->_ptr); this->NULLPtr();};
 };
 
 template<typename T>
@@ -485,10 +510,10 @@
 void
 _meta_weakautoarray_ptr<T>::operator=(T* src)
 {
-	if (_ptr!=src)
+	if (this->_ptr!=src)
 		{
-		_weak_flush(_ptr);
-		_ptr = src;
+		_weak_flush(this->_ptr);
+		this->_ptr = src;
 		}
 }
 #endif
@@ -524,19 +549,19 @@
 _meta_weakautoarray_ptr<T>::grep(const U& src,op Predicate)
 {
 	if (src.empty()) return reset(),true;
-	size_t NonStrictLB = 0;
-	size_t StrictUB = src.size();
-	while(!Predicate(src.data()[NonStrictLB]) && StrictUB>++NonStrictLB);
-	if (StrictUB==NonStrictLB) return reset(),true;
-	while(!Predicate(src[--StrictUB]));
-	++StrictUB;
-	if (!Resize(StrictUB-NonStrictLB)) return false;
+	size_t lb = 0;
+	size_t strict_ub = src.size();
+	while(!Predicate(src.data()[lb]) && strict_ub> ++lb);
+	if (strict_ub==lb) return reset(),true;
+	while(!Predicate(src[--strict_ub]));
+	++strict_ub;
+	if (!Resize(strict_ub-lb)) return false;
 	size_t Offset = 0;
-	_ptr[Offset++] = src.data()[NonStrictLB++];
-	while(NonStrictLB<StrictUB-1)
-		if (Predicate(src.data()[NonStrictLB++]))
-			_ptr[Offset++] = src[NonStrictLB-1];
-	_ptr[Offset++] = src.data()[NonStrictLB++];
+	this->_ptr[Offset++] = src.data()[lb++];
+	while(lb<strict_ub-1)
+		if (Predicate(src.data()[lb++]))
+			this->_ptr[Offset++] = src[lb-1];
+	this->_ptr[Offset++] = src.data()[lb++];
 	return Resize(Offset),true;
 }
 
@@ -546,19 +571,19 @@
 _meta_weakautoarray_ptr<T>::invgrep(const U& src,op Predicate)
 {
 	if (src.empty()) return reset(),true;
-	size_t NonStrictLB = 0;
-	size_t StrictUB = src.size();
-	while(Predicate(src.data()[NonStrictLB]) && StrictUB>++NonStrictLB);
-	if (StrictUB==NonStrictLB) return reset(),true;
-	while(Predicate(src[--StrictUB]));
-	++StrictUB;
-	if (!Resize(StrictUB-NonStrictLB)) return false;
+	size_t lb = 0;
+	size_t strict_ub = src.size();
+	while(Predicate(src.data()[lb]) && strict_ub> ++lb);
+	if (strict_ub==lb) return reset(),true;
+	while(Predicate(src[--strict_ub]));
+	++strict_ub;
+	if (!Resize(strict_ub-lb)) return false;
 	size_t Offset = 0;
-	_ptr[Offset++] = src.data()[NonStrictLB++];
-	while(NonStrictLB<StrictUB-1)
-		if (!Predicate(src.data()[NonStrictLB++]))
-			_ptr[Offset++] = src[NonStrictLB-1];
-	_ptr[Offset++] = src.data()[NonStrictLB++];
+	this->_ptr[Offset++] = src.data()[lb++];
+	while(lb<strict_ub-1)
+		if (!Predicate(src.data()[lb++]))
+			this->_ptr[Offset++] = src[lb-1];
+	this->_ptr[Offset++] = src.data()[lb++];
 	return Resize(Offset),true;
 }
 
@@ -582,10 +607,10 @@
 void
 _meta_autoarray_ptr<T>::operator=(T* src)
 {
-	if (_ptr!=src)
+	if (this->_ptr!=src)
 		{
-		_flush(_ptr);
-		_ptr = src;
+		_flush(this->_ptr);
+		this->_ptr = src;
 		}
 }
 #endif
@@ -625,12 +650,12 @@
 void
 _meta_autoarray_ptr<T>::reset(T*& src)
 {	// this convolution handles a recursion issue
-	T* TmpPtr = src;
+	T* tmp = src;
 	src = NULL;
-	if (TmpPtr!=_ptr)
+	if (tmp!=this->_ptr)
 		{
-		if (NULL!=_ptr) _flush(_ptr);
-		_ptr = TmpPtr;
+		if (this->_ptr) _flush(this->_ptr);
+		this->_ptr = tmp;
 		};
 }
 
@@ -640,10 +665,10 @@
 {	// this convolution handles a recursion issue
 	T* tmp = src;
 	src = NULL;
-	if (tmp!=_ptr)
+	if (tmp!=this->_ptr)
 		{
-		if (NULL!=_ptr) _weak_flush(_ptr);
-		_ptr = tmp;
+		if (this->_ptr) _weak_flush(this->_ptr);
+		this->_ptr = tmp;
 		};
 }
 
@@ -655,22 +680,22 @@
 	dest.reset();
 	if (this->empty()) return true;
 
-	size_t NonStrictLB = 0;
-	size_t StrictUB = this->ArraySize();
-	while(!Predicate(*_ptr[NonStrictLB]) && StrictUB>++NonStrictLB);
-	if (StrictUB==NonStrictLB) return true;
+	size_t lb = 0;
+	size_t strict_ub = this->ArraySize();
+	while(!Predicate(*(this->_ptr)[lb]) && strict_ub> ++lb);
+	if (strict_ub==lb) return true;
 
-	while(!Predicate(*_ptr[--StrictUB]));
-	++StrictUB;
-	if (!dest.Resize(StrictUB-NonStrictLB)) return false;
+	while(!Predicate(*(this->_ptr)[--strict_ub]));
+	++strict_ub;
+	if (!dest.Resize(strict_ub-lb)) return false;
 
 	size_t Offset = 0;
 	try	{
-		dest[Offset++] = new U(*_ptr[NonStrictLB++]);
-		while(NonStrictLB<StrictUB-1)
-			if (Predicate(*_ptr[NonStrictLB++]))
-				dest[Offset++] = new U(*_ptr[NonStrictLB-1]);
-		dest[Offset++] = new U(*_ptr[NonStrictLB++]);
+		dest[Offset++] = new U(*(this->_ptr)[lb++]);
+		while(lb<strict_ub-1)
+			if (Predicate(*(this->_ptr)[lb++]))
+				dest[Offset++] = new U(*(this->_ptr)[lb-1]);
+		dest[Offset++] = new U(*(this->_ptr)[lb++]);
 		}
 	catch(const std::bad_alloc&)
 		{
@@ -687,22 +712,22 @@
 	dest.reset();
 	if (this->empty()) return true;
 
-	size_t NonStrictLB = 0;
-	size_t StrictUB = this->ArraySize();
-	while(Predicate(*_ptr[NonStrictLB]) && StrictUB>++NonStrictLB);
-	if (StrictUB==NonStrictLB) return true;
+	size_t lb = 0;
+	size_t strict_ub = this->ArraySize();
+	while(Predicate(*(this->_ptr)[lb]) && strict_ub> ++lb);
+	if (strict_ub==lb) return true;
 
-	while(Predicate(*_ptr[--StrictUB]));
-	++StrictUB;
-	if (!dest.Resize(StrictUB-NonStrictLB)) return false;
+	while(Predicate(*(this->_ptr)[--strict_ub]));
+	++strict_ub;
+	if (!dest.Resize(strict_ub-lb)) return false;
 
 	size_t Offset = 0;
 	try	{
-		dest[Offset++] = new U(*_ptr[NonStrictLB++]);
-		while(NonStrictLB<StrictUB-1)
-			if (!Predicate(*_ptr[NonStrictLB++]))
-				dest[Offset++] = new U(*_ptr[NonStrictLB-1]);
-		dest[Offset++] = new U(*_ptr[NonStrictLB++]);
+		dest[Offset++] = new U(*(this->_ptr)[lb++]);
+		while(lb<strict_ub-1)
+			if (!Predicate(*(this->_ptr)[lb++]))
+				dest[Offset++] = new U(*(this->_ptr)[lb-1]);
+		dest[Offset++] = new U(*(this->_ptr)[lb++]);
 		}
 	catch(const std::bad_alloc&)
 		{



From zaimoni at mail.berlios.de  Wed Jun  8 22:06:03 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed,  8 Jun 2011 22:06:03 +0200
Subject: [Zcplusplus-commits] r657 - trunk/Zaimoni.STL
Message-ID: <20110608200603.CDAB848130A@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-08 22:06:03 +0200 (Wed, 08 Jun 2011)
New Revision: 657

Modified:
   trunk/Zaimoni.STL/AutoPtr.hpp
Log:
source code reduction

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-08 06:19:42 UTC (rev 656)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-08 20:06:03 UTC (rev 657)
@@ -101,25 +101,6 @@
 template<class Derived,class T>
 struct c_var_array_CRTP : public c_array_CRTP<c_var_array_CRTP<Derived,T>, T>
 {
-	// other support
-#ifndef ZAIMONI_FORCE_ISO
-	void NULLPtr() {static_cast<Derived*>(this)->_ptr = NULL;};
-	size_t ArraySize() const {return zaimoni::ArraySize(static_cast<const Derived*>(this)->_ptr);};
-	template<typename U> bool InsertSlotAt(size_t Idx, U _default) {return _insert_slot_at(static_cast<Derived*>(this)->_ptr,Idx,_default);}
-	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(static_cast<Derived*>(this)->_ptr,n,i);};
-	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(static_cast<Derived*>(this)->_ptr,n,i)) throw std::bad_alloc();};
-#else
-	void NULLPtr() {static_cast<Derived*>(this)->_ptr = NULL; static_cast<Derived*>(this)->_size = 0;};
-	size_t ArraySize() const {return static_cast<const Derived*>(this)->_size;};
-	template<typename U> bool InsertSlotAt(size_t Idx, U _default) {return _insert_slot_at(static_cast<Derived*>(this)->_ptr,static_cast<Derived*>(this)->_size,Idx,_default);}
-	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(static_cast<Derived*>(this)->_ptr,static_cast<Derived*>(this)->_size,n,i);};
-	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(static_cast<Derived*>(this)->_ptr,static_cast<Derived*>(this)->_size,n,i)) throw std::bad_alloc();};
-#endif
-
-	// typecasts
-	operator T*&() {return static_cast<Derived*>(this)->_ptr;};
-	operator T* const&() const {return static_cast<const Derived*>(this)->_ptr;};
-
 	// STL support
 	T* c_array() {return static_cast<Derived*>(this)->_ptr;};
 	const T* data() const {return static_cast<const Derived*>(this)->_ptr;};
@@ -139,11 +120,6 @@
 	void rangecheck(size_t i) const { if (i>=size()) FATAL("out-of-bounds array access"); };
 
 	void swap(c_var_array_CRTP& RHS) {std::swap(static_cast<Derived*>(this)->_ptr,static_cast<Derived&>(RHS)._ptr);};
-#ifndef ZAIMONI_FORCE_ISO
-	T* release() {T* tmp = static_cast<Derived*>(this)->_ptr; static_cast<Derived*>(this)->_ptr = NULL; return tmp;};
-#else
-	T* release() {T* tmp = static_cast<Derived*>(this)->_ptr; static_cast<Derived*>(this)->_ptr = NULL; static_cast<Derived*>(this)->_size = 0; return tmp;};
-#endif
 
 	// Perl grep
 	template<typename U> void destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
@@ -162,6 +138,36 @@
 #ifdef ZAIMONI_FORCE_ISO
 	size_t _size;
 #endif
+public:
+#ifndef ZAIMONI_FORCE_ISO
+	void NULLPtr() {_ptr = NULL;};
+	void de_novo(size_t n) {_ptr = n ? _new_buffer_nonNULL_throws<T>(n) : NULL;};
+	void de_novo_nothrow(size_t n) {_ptr = _new_buffer<T>(n);};
+	
+	size_t ArraySize() const {return zaimoni::ArraySize(_ptr);};
+	template<typename U> bool InsertSlotAt(size_t Idx, U _default) {return _insert_slot_at(_ptr,Idx,_default);}
+	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(_ptr,n,i);};
+	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(_ptr,n,i)) throw std::bad_alloc();};
+
+	// STL support	
+	T* release() {T* tmp = _ptr; _ptr = NULL; return tmp;};
+#else
+	void NULLPtr() {_ptr = NULL; _size = 0;};
+	void de_novo(size_t n) {_ptr = n ? _new_buffer_nonNULL_throws<T>(n) : NULL; _size = n;};
+	void de_novo_nothrow(size_t n) {_ptr = _new_buffer<T>(n); _size = n;};
+
+	size_t ArraySize() const {return _size;};
+	template<typename U> bool InsertSlotAt(size_t Idx, U _default) {return _insert_slot_at(_ptr,_size,Idx,_default);}
+	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(_ptr,_size,n,i);};
+	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(_ptr,_size,n,i)) throw std::bad_alloc();};
+
+	// STL support	
+	T* release() {T* tmp = _ptr; _ptr = NULL; _size = 0; return tmp;};
+#endif	
+
+	// typecasts
+	operator T*&() {return _ptr;};
+	operator T* const&() const {return _ptr;};
 };
 
 } // namespace zaimoni
@@ -179,29 +185,21 @@
 namespace zaimoni {
 
 template<typename T>
-#if 2
 class _meta_weakautoarray_ptr : public c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>,public POD_autoarray_ptr<T>
-#else
-class _meta_weakautoarray_ptr : public c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>,protected POD_autoarray_ptr<T>
-#endif
 {
 private:
 	friend class c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>;
 	friend bool operator==<>(const c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>& lhs, const c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>& rhs);
 public:
+	explicit _meta_weakautoarray_ptr() {this->NULLPtr();};
 #ifndef ZAIMONI_FORCE_ISO
-	explicit _meta_weakautoarray_ptr() {this->_ptr = NULL;};
 	explicit _meta_weakautoarray_ptr(T*& src) {this->_ptr = src; src = NULL;};
-	explicit _meta_weakautoarray_ptr(size_t n) {this->_ptr = n ? _new_buffer_nonNULL_throws<T>(n) : NULL;};
-	explicit _meta_weakautoarray_ptr(const std::nothrow_t& tracer, size_t n) {this->_ptr = _new_buffer<T>(n);};
-	explicit _meta_weakautoarray_ptr(const _meta_weakautoarray_ptr& src) {this->_ptr = NULL; *this=src;};
 #else
-	explicit _meta_weakautoarray_ptr() {this->_ptr = NULL; this->_size = 0;};
 	explicit _meta_weakautoarray_ptr(T*& src,size_t src_size) {this->_ptr = src; this->_size = src_size; src = NULL;};
-	explicit _meta_weakautoarray_ptr(size_t n) {this->_ptr = n ? _new_buffer_nonNULL_throws<T>(n) : NULL; this->_size = n;};
-	explicit _meta_weakautoarray_ptr(const std::nothrow_t& tracer, size_t n) {this->_ptr = _new_buffer<T>(n); this->_size = n;};
-	explicit _meta_weakautoarray_ptr(const _meta_weakautoarray_ptr& src) {this->_ptr = NULL; this->_size = 0; *this=src;};
 #endif
+	explicit _meta_weakautoarray_ptr(size_t n) {this->de_novo(n);};
+	explicit _meta_weakautoarray_ptr(const std::nothrow_t& tracer, size_t n) {this->de_novo_nothrow(n);};
+	explicit _meta_weakautoarray_ptr(const _meta_weakautoarray_ptr& src) {this->NULLPtr(); *this=src;};
 	~_meta_weakautoarray_ptr() {_weak_flush(this->_ptr);};
 
 #ifndef ZAIMONI_FORCE_ISO
@@ -216,15 +214,14 @@
 	void TransferOutAndNULL(T*& dest) {_weak_flush(dest); dest = this->_ptr; this->NULLPtr();}
 #ifndef ZAIMONI_FORCE_ISO
 	bool Resize(size_t n) {return _weak_resize(this->_ptr,n);};
-#else
-	bool Resize(size_t n) {return _weak_resize(this->_ptr,this->_size,n);};
-#endif
 	void FastDeleteIdx(size_t n) {_weak_delete_idx(this->_ptr,n);};
-#ifndef ZAIMONI_FORCE_ISO
 	void DeleteIdx(size_t n) {_safe_weak_delete_idx(this->_ptr,n);};
 #else
+	bool Resize(size_t n) {return _weak_resize(this->_ptr,this->_size,n);};
+	void FastDeleteIdx(size_t n) {_weak_delete_idx(this->_ptr,this->_size,n);};
 	void DeleteIdx(size_t n) {_safe_weak_delete_idx(this->_ptr,this->_size,n);};
 #endif
+	//! \todo need an ISO version of _weak_delete_n_slots_at
 	void DeleteNSlotsAt(size_t n, size_t Idx) {_weak_delete_n_slots_at(this->_ptr,n,Idx);};
 	
 	// Perl grep
@@ -318,29 +315,21 @@
 };
 
 template<typename T>
-#if 2
 class _meta_autoarray_ptr : public c_var_array_CRTP<_meta_autoarray_ptr<T>, T>,public POD_autoarray_ptr<T>
-#else
-class _meta_autoarray_ptr : public c_var_array_CRTP<_meta_autoarray_ptr<T>, T>,protected POD_autoarray_ptr<T>
-#endif
 {
 protected:
 	friend class c_var_array_CRTP<_meta_autoarray_ptr<T>, T>;
 	friend bool operator==<>(const c_var_array_CRTP<_meta_autoarray_ptr<T>, T>& lhs, const c_var_array_CRTP<_meta_autoarray_ptr<T>, T>& rhs);
 
+	explicit _meta_autoarray_ptr() {this->NULLPtr();};	
 #ifndef ZAIMONI_FORCE_ISO
-	explicit _meta_autoarray_ptr() {this->_ptr = NULL;};
 	explicit _meta_autoarray_ptr(T*& src) {this->_ptr = src; src = NULL;};
-	explicit _meta_autoarray_ptr(size_t n) {this->_ptr = n ? _new_buffer_nonNULL_throws<T>(n) : NULL;};
-	explicit _meta_autoarray_ptr(const std::nothrow_t& tracer, size_t n) {this->_ptr = _new_buffer<T>(n);};
-	explicit _meta_autoarray_ptr(const _meta_autoarray_ptr& src) {this->_ptr = NULL; *this=src;};
 #else
-	explicit _meta_autoarray_ptr() {this->_ptr = NULL; this->_size = 0;};
 	explicit _meta_autoarray_ptr(T*& src,size_t src_size) {this->_ptr = src; this->_size = src_size; src = NULL;};
-	explicit _meta_autoarray_ptr(size_t n) {this->_ptr = n ? _new_buffer_nonNULL_throws<T>(n) : NULL; this->_size = n;};
-	explicit _meta_autoarray_ptr(const std::nothrow_t& tracer, size_t n) {this->_ptr = _new_buffer<T>(n); this->_size = n;};
-	explicit _meta_autoarray_ptr(const _meta_autoarray_ptr& src) {this->_ptr = NULL; this->_size = 0; *this=src;};
 #endif
+	explicit _meta_autoarray_ptr(size_t n) {this->de_novo(n);};
+	explicit _meta_autoarray_ptr(const std::nothrow_t& tracer, size_t n) {this->de_novo_nothrow(n);};
+	explicit _meta_autoarray_ptr(const _meta_autoarray_ptr& src) {this->NULLPtr(); *this=src;};
 	~_meta_autoarray_ptr() {_flush(this->_ptr);};
 
 #ifndef ZAIMONI_FORCE_ISO
@@ -361,17 +350,15 @@
 #ifndef ZAIMONI_FORCE_ISO
 	bool Resize(size_t n) {return _resize(this->_ptr,n);};
 	void Shrink(size_t n) {_shrink(this->_ptr,n);};
-#else
-	bool Resize(size_t n) {return _resize(this->_ptr,this->_size,n);};
-	void Shrink(size_t n) {_shrink(this->_ptr,this->_size,n);};
-#endif
 	void FastDeleteIdx(size_t n) {_delete_idx(this->_ptr,n);};
-#ifndef ZAIMONI_FORCE_ISO
 	void DeleteIdx(size_t n) {_safe_delete_idx(this->_ptr,n);};
 	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(this->_ptr,n,Idx);};
 	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,indexes,n);};
 	template<typename U> bool InsertSlotAt(size_t Idx, U __default) {return _insert_slot_at(this->_ptr,Idx,__default);}
 #else
+	bool Resize(size_t n) {return _resize(this->_ptr,this->_size,n);};
+	void Shrink(size_t n) {_shrink(this->_ptr,this->_size,n);};
+	void FastDeleteIdx(size_t n) {_delete_idx(this->_ptr,this->_size,n);};
 	void DeleteIdx(size_t n) {_safe_delete_idx(this->_ptr,this->_size,n);};
 	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(this->_ptr,this->_size,n,Idx);};
 	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,this->_size,indexes,n);};



From zaimoni at mail.berlios.de  Wed Jun  8 23:17:15 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed,  8 Jun 2011 23:17:15 +0200
Subject: [Zcplusplus-commits] r658 - trunk/Zaimoni.STL
Message-ID: <20110608211715.D213048130A@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-08 23:17:15 +0200 (Wed, 08 Jun 2011)
New Revision: 658

Modified:
   trunk/Zaimoni.STL/AutoPtr.hpp
Log:
ISO mode fixes

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-08 20:06:03 UTC (rev 657)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-08 21:17:15 UTC (rev 658)
@@ -208,15 +208,17 @@
 	void operator=(const _meta_weakautoarray_ptr& src);
 	template<typename U> bool value_copy_of(const U& src);	// STL interfaces required of U: size(),data()
 	void reset() {_weak_flush(this->_ptr); this->NULLPtr();};
+	void TransferOutAndNULL(T*& dest) {_weak_flush(dest); dest = this->_ptr; this->NULLPtr();}
+
+#ifndef ZAIMONI_FORCE_ISO
 	void reset(T*& src);
 	void MoveInto(_meta_weakautoarray_ptr<T>& dest) {dest.reset(this->_ptr);};
-
-	void TransferOutAndNULL(T*& dest) {_weak_flush(dest); dest = this->_ptr; this->NULLPtr();}
-#ifndef ZAIMONI_FORCE_ISO
 	bool Resize(size_t n) {return _weak_resize(this->_ptr,n);};
 	void FastDeleteIdx(size_t n) {_weak_delete_idx(this->_ptr,n);};
 	void DeleteIdx(size_t n) {_safe_weak_delete_idx(this->_ptr,n);};
 #else
+	void reset(T*& src,size_t n);
+	void MoveInto(_meta_weakautoarray_ptr<T>& dest) {dest.reset(this->_ptr,this->_size);};
 	bool Resize(size_t n) {return _weak_resize(this->_ptr,this->_size,n);};
 	void FastDeleteIdx(size_t n) {_weak_delete_idx(this->_ptr,this->_size,n);};
 	void DeleteIdx(size_t n) {_safe_weak_delete_idx(this->_ptr,this->_size,n);};
@@ -343,11 +345,11 @@
 
 	template<typename U> bool value_copy_of(const U& src);	// STL interfaces required of U: size(),data()
 	void reset() {_flush(this->_ptr); this->NULLPtr();};
+	void TransferOutAndNULL(T*& dest) {_flush(dest); dest = this->_ptr; this->NULLPtr();};
+
+#ifndef ZAIMONI_FORCE_ISO
 	void reset(T*& src);
 	void MoveInto(_meta_autoarray_ptr<T>& dest) {dest.reset(this->_ptr);};
-
-	void TransferOutAndNULL(T*& dest) {_flush(dest); dest = this->_ptr; this->NULLPtr();};
-#ifndef ZAIMONI_FORCE_ISO
 	bool Resize(size_t n) {return _resize(this->_ptr,n);};
 	void Shrink(size_t n) {_shrink(this->_ptr,n);};
 	void FastDeleteIdx(size_t n) {_delete_idx(this->_ptr,n);};
@@ -356,6 +358,8 @@
 	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,indexes,n);};
 	template<typename U> bool InsertSlotAt(size_t Idx, U __default) {return _insert_slot_at(this->_ptr,Idx,__default);}
 #else
+	void reset(T*& src,size_t n);
+	void MoveInto(_meta_autoarray_ptr<T>& dest) {dest.reset(this->_ptr,this->_size);};
 	bool Resize(size_t n) {return _resize(this->_ptr,this->_size,n);};
 	void Shrink(size_t n) {_shrink(this->_ptr,this->_size,n);};
 	void FastDeleteIdx(size_t n) {_delete_idx(this->_ptr,this->_size,n);};
@@ -634,8 +638,11 @@
 }
 
 template<typename T>
-void
-_meta_autoarray_ptr<T>::reset(T*& src)
+#ifndef ZAIMONI_FORCE_ISO
+void _meta_autoarray_ptr<T>::reset(T*& src)
+#else
+void _meta_autoarray_ptr<T>::reset(T*& src, size_t n)
+#endif
 {	// this convolution handles a recursion issue
 	T* tmp = src;
 	src = NULL;
@@ -643,12 +650,18 @@
 		{
 		if (this->_ptr) _flush(this->_ptr);
 		this->_ptr = tmp;
+#ifdef ZAIMONI_FORCE_ISO
+		this->_size = n;
+#endif		
 		};
 }
 
 template<typename T>
-void
-_meta_weakautoarray_ptr<T>::reset(T*& src)
+#ifndef ZAIMONI_FORCE_ISO
+void _meta_weakautoarray_ptr<T>::reset(T*& src)
+#else
+void _meta_weakautoarray_ptr<T>::reset(T*& src,size_t n)
+#endif
 {	// this convolution handles a recursion issue
 	T* tmp = src;
 	src = NULL;
@@ -656,6 +669,9 @@
 		{
 		if (this->_ptr) _weak_flush(this->_ptr);
 		this->_ptr = tmp;
+#ifdef ZAIMONI_FORCE_ISO
+		this->_size = n;
+#endif		
 		};
 }
 



From zaimoni at mail.berlios.de  Wed Jun  8 23:18:10 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed,  8 Jun 2011 23:18:10 +0200
Subject: [Zcplusplus-commits] r659 - trunk/Zaimoni.STL
Message-ID: <20110608211810.B2A0448130A@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-08 23:18:10 +0200 (Wed, 08 Jun 2011)
New Revision: 659

Modified:
   trunk/Zaimoni.STL/AutoPtr.hpp
   trunk/Zaimoni.STL/MetaRAM2.hpp
Log:
ISO mode fixes

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-08 21:17:15 UTC (rev 658)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-08 21:18:10 UTC (rev 659)
@@ -216,15 +216,15 @@
 	bool Resize(size_t n) {return _weak_resize(this->_ptr,n);};
 	void FastDeleteIdx(size_t n) {_weak_delete_idx(this->_ptr,n);};
 	void DeleteIdx(size_t n) {_safe_weak_delete_idx(this->_ptr,n);};
+	void DeleteNSlotsAt(size_t n, size_t Idx) {_weak_delete_n_slots_at(this->_ptr,n,Idx);};
 #else
 	void reset(T*& src,size_t n);
 	void MoveInto(_meta_weakautoarray_ptr<T>& dest) {dest.reset(this->_ptr,this->_size);};
 	bool Resize(size_t n) {return _weak_resize(this->_ptr,this->_size,n);};
 	void FastDeleteIdx(size_t n) {_weak_delete_idx(this->_ptr,this->_size,n);};
 	void DeleteIdx(size_t n) {_safe_weak_delete_idx(this->_ptr,this->_size,n);};
+	void DeleteNSlotsAt(size_t n, size_t Idx) {_weak_delete_n_slots_at(this->_ptr,this->_size,n,Idx);};
 #endif
-	//! \todo need an ISO version of _weak_delete_n_slots_at
-	void DeleteNSlotsAt(size_t n, size_t Idx) {_weak_delete_n_slots_at(this->_ptr,n,Idx);};
 	
 	// Perl grep
 	// next two require of U: STL size(),data()

Modified: trunk/Zaimoni.STL/MetaRAM2.hpp
===================================================================
--- trunk/Zaimoni.STL/MetaRAM2.hpp	2011-06-08 21:17:15 UTC (rev 658)
+++ trunk/Zaimoni.STL/MetaRAM2.hpp	2011-06-08 21:18:10 UTC (rev 659)
@@ -879,14 +879,24 @@
 }
 
 template<typename T>
+#ifndef ZAIMONI_FORCE_ISO
 void _weak_delete_n_slots_at(T**& _ptr, size_t n, size_t i)
 {
 	assert(_ptr);
 	const size_t _ptr_size = ArraySize(_ptr);
+#else
+void _weak_delete_n_slots_at(T**& _ptr, size_t& _ptr_size, size_t n, size_t i)
+{
+	assert(_ptr);
+	assert(0<_ptr_size);
+#endif
 	if (0==i && _ptr_size<=n)
 		{
 		_weak_flush(_ptr);
 		_ptr = NULL;
+#ifdef ZAIMONI_FORCE_ISO
+		_ptr_size = 0;
+#endif
 		return;
 		}
 	T** const _offset_ptr = _ptr+i;
@@ -895,10 +905,16 @@
 		if (i+n<_ptr_size)
 			memmove(_offset_ptr,_offset_ptr+n,sizeof(T*)*(_ptr_size-i-n));
 		_ptr = REALLOC(_ptr,sizeof(T*)*(_ptr_size-n));
+#ifdef ZAIMONI_FORCE_ISO
+		_ptr_size -= n;
+#endif
 		}
 	else{
 		free(_ptr);
 		_ptr = NULL;
+#ifdef ZAIMONI_FORCE_ISO
+		_ptr_size = 0;
+#endif
 		}
 }
 



From zaimoni at mail.berlios.de  Thu Jun  9 03:40:59 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu,  9 Jun 2011 03:40:59 +0200
Subject: [Zcplusplus-commits] r660 - trunk/Zaimoni.STL
Message-ID: <20110609014100.0A96248130A@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-09 03:40:59 +0200 (Thu, 09 Jun 2011)
New Revision: 660

Modified:
   trunk/Zaimoni.STL/AutoPtr.hpp
Log:
let POD_autoarray_ptr take over as CRTP base class

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-08 21:18:10 UTC (rev 659)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-09 01:40:59 UTC (rev 660)
@@ -91,47 +91,9 @@
 {
 };
 
-template<class Derived,class T> struct c_var_array_CRTP;
-
-template<class Derived,class T>
-bool
-operator==(const c_var_array_CRTP<Derived,T>& lhs, const c_var_array_CRTP<Derived,T>& rhs);
-
-// requires: _ptr
-template<class Derived,class T>
-struct c_var_array_CRTP : public c_array_CRTP<c_var_array_CRTP<Derived,T>, T>
-{
-	// STL support
-	T* c_array() {return static_cast<Derived*>(this)->_ptr;};
-	const T* data() const {return static_cast<const Derived*>(this)->_ptr;};
-
-	// at() with range check
-	T& at(size_t i) { rangecheck(i); return static_cast<Derived*>(this)->_ptr[i];}
-	const T& at(size_t i) const { rangecheck(i); return static_cast<const Derived*>(this)->_ptr[i]; };
-
-#ifndef ZAIMONI_FORCE_ISO
-	size_t size() const { return zaimoni::SafeArraySize(static_cast<const Derived*>(this)->_ptr); };
-#else
-	size_t size() const { return static_cast<const Derived*>(this)->_size; };
-#endif
-	bool empty() const { return NULL==static_cast<const Derived*>(this)->_ptr; };
-	static size_t max_size() { return size_t(-1)/sizeof(T); };	// XXX casting -1 to an unsigned type gets the maximum of that type
-
-	void rangecheck(size_t i) const { if (i>=size()) FATAL("out-of-bounds array access"); };
-
-	void swap(c_var_array_CRTP& RHS) {std::swap(static_cast<Derived*>(this)->_ptr,static_cast<Derived&>(RHS)._ptr);};
-
-	// Perl grep
-	template<typename U> void destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
-	template<typename U> void destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
-
-	// throwing resize
-	void resize(size_t n) {if (!static_cast<Derived*>(this)->Resize(n)) throw std::bad_alloc();};	
-};
-
 // POD backing class for the autoarray and weak autoarray family
 template<typename T>
-class POD_autoarray_ptr
+class POD_autoarray_ptr : public c_array_CRTP<POD_autoarray_ptr<T>, T>
 {
 protected:
 	T* _ptr;
@@ -149,7 +111,10 @@
 	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(_ptr,n,i);};
 	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(_ptr,n,i)) throw std::bad_alloc();};
 
+	void swap(POD_autoarray_ptr<T>& rhs) {std::swap(_ptr,rhs._ptr);};
+	
 	// STL support	
+	size_t size() const { return zaimoni::SafeArraySize(_ptr); };
 	T* release() {T* tmp = _ptr; _ptr = NULL; return tmp;};
 #else
 	void NULLPtr() {_ptr = NULL; _size = 0;};
@@ -161,10 +126,23 @@
 	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(_ptr,_size,n,i);};
 	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(_ptr,_size,n,i)) throw std::bad_alloc();};
 
+	void swap(POD_autoarray_ptr<T>& rhs) {std::swap(_ptr,rhs._ptr); std::swap(_size,rhs._size);};
+	
 	// STL support	
 	T* release() {T* tmp = _ptr; _ptr = NULL; _size = 0; return tmp;};
+	size_t size() const { return _size; };
 #endif	
+	T* c_array() {return _ptr;};
+	const T* data() const {return _ptr;};
+	bool empty() const { return NULL==_ptr; };
+	static size_t max_size() { return size_t(-1)/sizeof(T); };	// XXX casting -1 to an unsigned type gets the maximum of that type
 
+	void rangecheck(size_t i) const { if (i>=size()) FATAL("out-of-bounds array access"); };
+
+	// Perl grep
+	template<typename U> void destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
+	template<typename U> void destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
+
 	// typecasts
 	operator T*&() {return _ptr;};
 	operator T* const&() const {return _ptr;};
@@ -185,11 +163,8 @@
 namespace zaimoni {
 
 template<typename T>
-class _meta_weakautoarray_ptr : public c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>,public POD_autoarray_ptr<T>
+class _meta_weakautoarray_ptr : public POD_autoarray_ptr<T>
 {
-private:
-	friend class c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>;
-	friend bool operator==<>(const c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>& lhs, const c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>& rhs);
 public:
 	explicit _meta_weakautoarray_ptr() {this->NULLPtr();};
 #ifndef ZAIMONI_FORCE_ISO
@@ -225,6 +200,7 @@
 	void DeleteIdx(size_t n) {_safe_weak_delete_idx(this->_ptr,this->_size,n);};
 	void DeleteNSlotsAt(size_t n, size_t Idx) {_weak_delete_n_slots_at(this->_ptr,this->_size,n,Idx);};
 #endif
+	void resize(size_t n) {if (!Resize(n)) throw std::bad_alloc();};	
 	
 	// Perl grep
 	// next two require of U: STL size(),data()
@@ -317,12 +293,9 @@
 };
 
 template<typename T>
-class _meta_autoarray_ptr : public c_var_array_CRTP<_meta_autoarray_ptr<T>, T>,public POD_autoarray_ptr<T>
+class _meta_autoarray_ptr : public POD_autoarray_ptr<T>
 {
 protected:
-	friend class c_var_array_CRTP<_meta_autoarray_ptr<T>, T>;
-	friend bool operator==<>(const c_var_array_CRTP<_meta_autoarray_ptr<T>, T>& lhs, const c_var_array_CRTP<_meta_autoarray_ptr<T>, T>& rhs);
-
 	explicit _meta_autoarray_ptr() {this->NULLPtr();};	
 #ifndef ZAIMONI_FORCE_ISO
 	explicit _meta_autoarray_ptr(T*& src) {this->_ptr = src; src = NULL;};
@@ -368,6 +341,7 @@
 	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,this->_size,indexes,n);};
 	template<typename U> bool InsertSlotAt(size_t Idx, U __default) {return _insert_slot_at(this->_ptr,this->_size,Idx,__default);}
 #endif
+	void resize(size_t n) {if (!Resize(n)) throw std::bad_alloc();};	
 
 	// Perl grep
 	// these two assume T has valid * operator
@@ -578,21 +552,16 @@
 	return Resize(Offset),true;
 }
 
-template<class Derived,class T>
+template<class T>
 bool
-operator==(const c_var_array_CRTP<Derived,T>& lhs, const c_var_array_CRTP<Derived,T>& rhs)
+operator==(const POD_autoarray_ptr<T>& lhs, const POD_autoarray_ptr<T>& rhs)
 {
 	const size_t ub = rhs.size();
 	if (ub!=lhs.size()) return false;
 	if (0==ub) return true;
-	return _value_vector_equal(static_cast<const Derived&>(lhs)._ptr,static_cast<const Derived&>(rhs)._ptr,ub);
+	return _value_vector_equal(lhs.data(),rhs.data(),ub);
 }
 
-template<class Derived,class T>
-inline bool
-operator!=(const c_var_array_CRTP<Derived,T>& lhs, const c_var_array_CRTP<Derived,T>& rhs)
-{	return !(lhs==rhs); }
-
 #ifndef ZAIMONI_FORCE_ISO
 template<typename T>
 void
@@ -739,44 +708,44 @@
 	return dest.Resize(Offset),true;
 }
 
-template<class Derived,class T>
+template<class T>
 template<typename U>
 void
-c_var_array_CRTP<Derived,T>::destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type))
+POD_autoarray_ptr<T>::destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type))
 {
 	size_t i = this->size();
-	do	if (!equivalence(x,static_cast<Derived*>(this)->_ptr[--i]))
+	do	if (!equivalence(x,_ptr[--i]))
 			{
 			size_t j = i;
-			while(0<j && !equivalence(x,static_cast<Derived*>(this)->_ptr[j-1])) --j;
+			while(0<j && !equivalence(x,_ptr[j-1])) --j;
 			if (j<i)
 				{
-				static_cast<Derived*>(this)->DeleteNSlotsAt(j,(i-j)+1);
+				this->DeleteNSlotsAt(j,(i-j)+1);
 				i = j;
 				}
 			else
-				static_cast<Derived*>(this)->DeleteIdx(i);
+				this->DeleteIdx(i);
 			}
 	while(0<i);
 }
 
-template<class Derived,class T>
+template<class T>
 template<typename U>
 void
-c_var_array_CRTP<Derived,T>::destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type))
+POD_autoarray_ptr<T>::destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type))
 {
 	size_t i = this->size();
-	do	if (equivalence(x,static_cast<Derived*>(this)->_ptr[--i]))
+	do	if (equivalence(x,_ptr[--i]))
 			{
 			size_t j = i;
-			while(0<j && equivalence(x,static_cast<Derived*>(this)->_ptr[j-1])) --j;
+			while(0<j && equivalence(x,_ptr[j-1])) --j;
 			if (j<i)
 				{
-				static_cast<Derived*>(this)->DeleteNSlotsAt(j,(i-j)+1);
+				this->DeleteNSlotsAt(j,(i-j)+1);
 				i = j;
 				}
 			else
-				static_cast<Derived*>(this)->DeleteIdx(i);
+				this->DeleteIdx(i);
 			}
 	while(0<i);
 }



From zaimoni at mail.berlios.de  Thu Jun  9 04:05:32 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu,  9 Jun 2011 04:05:32 +0200
Subject: [Zcplusplus-commits] r661 - trunk/Zaimoni.STL
Message-ID: <20110609020532.E2F0148130A@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-09 04:05:32 +0200 (Thu, 09 Jun 2011)
New Revision: 661

Modified:
   trunk/Zaimoni.STL/AutoPtr.hpp
Log:
minor adjust to where InsertSlotAt is

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-09 01:40:59 UTC (rev 660)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-09 02:05:32 UTC (rev 661)
@@ -107,7 +107,7 @@
 	void de_novo_nothrow(size_t n) {_ptr = _new_buffer<T>(n);};
 	
 	size_t ArraySize() const {return zaimoni::ArraySize(_ptr);};
-	template<typename U> bool InsertSlotAt(size_t Idx, U _default) {return _insert_slot_at(_ptr,Idx,_default);}
+	template<typename U> bool InsertSlotAt(size_t i, U _default) {return _insert_slot_at(_ptr,i,_default);}
 	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(_ptr,n,i);};
 	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(_ptr,n,i)) throw std::bad_alloc();};
 
@@ -122,7 +122,7 @@
 	void de_novo_nothrow(size_t n) {_ptr = _new_buffer<T>(n); _size = n;};
 
 	size_t ArraySize() const {return _size;};
-	template<typename U> bool InsertSlotAt(size_t Idx, U _default) {return _insert_slot_at(_ptr,_size,Idx,_default);}
+	template<typename U> bool InsertSlotAt(size_t i, U _default) {return _insert_slot_at(_ptr,_size,i,_default);}
 	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(_ptr,_size,n,i);};
 	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(_ptr,_size,n,i)) throw std::bad_alloc();};
 
@@ -329,7 +329,6 @@
 	void DeleteIdx(size_t n) {_safe_delete_idx(this->_ptr,n);};
 	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(this->_ptr,n,Idx);};
 	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,indexes,n);};
-	template<typename U> bool InsertSlotAt(size_t Idx, U __default) {return _insert_slot_at(this->_ptr,Idx,__default);}
 #else
 	void reset(T*& src,size_t n);
 	void MoveInto(_meta_autoarray_ptr<T>& dest) {dest.reset(this->_ptr,this->_size);};
@@ -339,7 +338,6 @@
 	void DeleteIdx(size_t n) {_safe_delete_idx(this->_ptr,this->_size,n);};
 	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(this->_ptr,this->_size,n,Idx);};
 	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,this->_size,indexes,n);};
-	template<typename U> bool InsertSlotAt(size_t Idx, U __default) {return _insert_slot_at(this->_ptr,this->_size,Idx,__default);}
 #endif
 	void resize(size_t n) {if (!Resize(n)) throw std::bad_alloc();};	
 



From zaimoni at mail.berlios.de  Thu Jun  9 05:19:54 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu,  9 Jun 2011 05:19:54 +0200
Subject: [Zcplusplus-commits] r662 - trunk/Zaimoni.STL
Message-ID: <20110609031954.69F3D48132C@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-09 05:19:53 +0200 (Thu, 09 Jun 2011)
New Revision: 662

Modified:
   trunk/Zaimoni.STL/AutoPtr.hpp
Log:
rearrange where member functions are for non-weak case

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-09 02:05:32 UTC (rev 661)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-09 03:19:53 UTC (rev 662)
@@ -101,7 +101,9 @@
 	size_t _size;
 #endif
 public:
+	ZAIMONI_STL_TYPE_GLUE_ARRAY(T);
 #ifndef ZAIMONI_FORCE_ISO
+	// core infrastructure
 	void NULLPtr() {_ptr = NULL;};
 	void de_novo(size_t n) {_ptr = n ? _new_buffer_nonNULL_throws<T>(n) : NULL;};
 	void de_novo_nothrow(size_t n) {_ptr = _new_buffer<T>(n);};
@@ -146,6 +148,24 @@
 	// typecasts
 	operator T*&() {return _ptr;};
 	operator T* const&() const {return _ptr;};
+
+	// generic case is owned-values, so put autovalarray_ptr family implementations here
+#ifndef ZAIMONI_FORCE_ISO
+	bool Resize(size_t n) {return _resize(this->_ptr,n);};
+	void Shrink(size_t n) {_shrink(this->_ptr,n);};
+	void FastDeleteIdx(size_t n) {_delete_idx(this->_ptr,n);};
+	void DeleteIdx(size_t n) {_safe_delete_idx(this->_ptr,n);};
+	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(this->_ptr,n,Idx);};
+	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,indexes,n);};
+#else
+	bool Resize(size_t n) {return _resize(this->_ptr,this->_size,n);};
+	void Shrink(size_t n) {_shrink(this->_ptr,this->_size,n);};
+	void FastDeleteIdx(size_t n) {_delete_idx(this->_ptr,this->_size,n);};
+	void DeleteIdx(size_t n) {_safe_delete_idx(this->_ptr,this->_size,n);};
+	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(this->_ptr,this->_size,n,Idx);};
+	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,this->_size,indexes,n);};
+#endif
+	void resize(size_t n) {if (!this->Resize(n)) throw std::bad_alloc();};	
 };
 
 } // namespace zaimoni
@@ -323,23 +343,10 @@
 #ifndef ZAIMONI_FORCE_ISO
 	void reset(T*& src);
 	void MoveInto(_meta_autoarray_ptr<T>& dest) {dest.reset(this->_ptr);};
-	bool Resize(size_t n) {return _resize(this->_ptr,n);};
-	void Shrink(size_t n) {_shrink(this->_ptr,n);};
-	void FastDeleteIdx(size_t n) {_delete_idx(this->_ptr,n);};
-	void DeleteIdx(size_t n) {_safe_delete_idx(this->_ptr,n);};
-	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(this->_ptr,n,Idx);};
-	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,indexes,n);};
 #else
 	void reset(T*& src,size_t n);
 	void MoveInto(_meta_autoarray_ptr<T>& dest) {dest.reset(this->_ptr,this->_size);};
-	bool Resize(size_t n) {return _resize(this->_ptr,this->_size,n);};
-	void Shrink(size_t n) {_shrink(this->_ptr,this->_size,n);};
-	void FastDeleteIdx(size_t n) {_delete_idx(this->_ptr,this->_size,n);};
-	void DeleteIdx(size_t n) {_safe_delete_idx(this->_ptr,this->_size,n);};
-	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(this->_ptr,this->_size,n,Idx);};
-	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,this->_size,indexes,n);};
 #endif
-	void resize(size_t n) {if (!Resize(n)) throw std::bad_alloc();};	
 
 	// Perl grep
 	// these two assume T has valid * operator
@@ -592,7 +599,7 @@
 _meta_autoarray_ptr<T>::value_copy_of(const U& src)
 {
 	const size_t ub = src.size();
-	if (!Resize(ub)) return false;
+	if (!this->Resize(ub)) return false;
 	if (0<ub)
 		try	{
 			_value_copy_buffer(this->c_array(),src.data(),ub);



From zaimoni at mail.berlios.de  Thu Jun  9 20:31:36 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu,  9 Jun 2011 20:31:36 +0200
Subject: [Zcplusplus-commits] r663 - trunk/Zaimoni.STL
Message-ID: <20110609183136.95F6F48137E@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-09 20:31:36 +0200 (Thu, 09 Jun 2011)
New Revision: 663

Added:
   trunk/Zaimoni.STL/POD_autoarray.hpp
Modified:
   trunk/Zaimoni.STL/AutoPtr.hpp
   trunk/Zaimoni.STL/POSIX.dep
Log:
refactor POD_autoarray into its own file

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-09 03:19:53 UTC (rev 662)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2011-06-09 18:31:36 UTC (rev 663)
@@ -14,8 +14,7 @@
 #ifndef ZAIMONI_AUTOPTR_HPP
 #define ZAIMONI_AUTOPTR_HPP 1
 
-#include "MetaRAM2.hpp"
-#include "metatype/c_array.hpp"
+#include "POD_autoarray.hpp"
 
 namespace zaimoni	{
 
@@ -91,98 +90,7 @@
 {
 };
 
-// POD backing class for the autoarray and weak autoarray family
 template<typename T>
-class POD_autoarray_ptr : public c_array_CRTP<POD_autoarray_ptr<T>, T>
-{
-protected:
-	T* _ptr;
-#ifdef ZAIMONI_FORCE_ISO
-	size_t _size;
-#endif
-public:
-	ZAIMONI_STL_TYPE_GLUE_ARRAY(T);
-#ifndef ZAIMONI_FORCE_ISO
-	// core infrastructure
-	void NULLPtr() {_ptr = NULL;};
-	void de_novo(size_t n) {_ptr = n ? _new_buffer_nonNULL_throws<T>(n) : NULL;};
-	void de_novo_nothrow(size_t n) {_ptr = _new_buffer<T>(n);};
-	
-	size_t ArraySize() const {return zaimoni::ArraySize(_ptr);};
-	template<typename U> bool InsertSlotAt(size_t i, U _default) {return _insert_slot_at(_ptr,i,_default);}
-	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(_ptr,n,i);};
-	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(_ptr,n,i)) throw std::bad_alloc();};
-
-	void swap(POD_autoarray_ptr<T>& rhs) {std::swap(_ptr,rhs._ptr);};
-	
-	// STL support	
-	size_t size() const { return zaimoni::SafeArraySize(_ptr); };
-	T* release() {T* tmp = _ptr; _ptr = NULL; return tmp;};
-#else
-	void NULLPtr() {_ptr = NULL; _size = 0;};
-	void de_novo(size_t n) {_ptr = n ? _new_buffer_nonNULL_throws<T>(n) : NULL; _size = n;};
-	void de_novo_nothrow(size_t n) {_ptr = _new_buffer<T>(n); _size = n;};
-
-	size_t ArraySize() const {return _size;};
-	template<typename U> bool InsertSlotAt(size_t i, U _default) {return _insert_slot_at(_ptr,_size,i,_default);}
-	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(_ptr,_size,n,i);};
-	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(_ptr,_size,n,i)) throw std::bad_alloc();};
-
-	void swap(POD_autoarray_ptr<T>& rhs) {std::swap(_ptr,rhs._ptr); std::swap(_size,rhs._size);};
-	
-	// STL support	
-	T* release() {T* tmp = _ptr; _ptr = NULL; _size = 0; return tmp;};
-	size_t size() const { return _size; };
-#endif	
-	T* c_array() {return _ptr;};
-	const T* data() const {return _ptr;};
-	bool empty() const { return NULL==_ptr; };
-	static size_t max_size() { return size_t(-1)/sizeof(T); };	// XXX casting -1 to an unsigned type gets the maximum of that type
-
-	void rangecheck(size_t i) const { if (i>=size()) FATAL("out-of-bounds array access"); };
-
-	// Perl grep
-	template<typename U> void destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
-	template<typename U> void destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
-
-	// typecasts
-	operator T*&() {return _ptr;};
-	operator T* const&() const {return _ptr;};
-
-	// generic case is owned-values, so put autovalarray_ptr family implementations here
-#ifndef ZAIMONI_FORCE_ISO
-	bool Resize(size_t n) {return _resize(this->_ptr,n);};
-	void Shrink(size_t n) {_shrink(this->_ptr,n);};
-	void FastDeleteIdx(size_t n) {_delete_idx(this->_ptr,n);};
-	void DeleteIdx(size_t n) {_safe_delete_idx(this->_ptr,n);};
-	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(this->_ptr,n,Idx);};
-	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,indexes,n);};
-#else
-	bool Resize(size_t n) {return _resize(this->_ptr,this->_size,n);};
-	void Shrink(size_t n) {_shrink(this->_ptr,this->_size,n);};
-	void FastDeleteIdx(size_t n) {_delete_idx(this->_ptr,this->_size,n);};
-	void DeleteIdx(size_t n) {_safe_delete_idx(this->_ptr,this->_size,n);};
-	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(this->_ptr,this->_size,n,Idx);};
-	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,this->_size,indexes,n);};
-#endif
-	void resize(size_t n) {if (!this->Resize(n)) throw std::bad_alloc();};	
-};
-
-} // namespace zaimoni
-
-namespace boost {
-
-#define ZAIMONI_TEMPLATE_SPEC template<typename T>
-#define ZAIMONI_CLASS_SPEC zaimoni::POD_autoarray_ptr<T>
-ZAIMONI_POD_STRUCT(ZAIMONI_TEMPLATE_SPEC,ZAIMONI_CLASS_SPEC,char)
-#undef ZAIMONI_CLASS_SPEC
-#undef ZAIMONI_TEMPLATE_SPEC
-
-} // namespace boost
-
-namespace zaimoni {
-
-template<typename T>
 class _meta_weakautoarray_ptr : public POD_autoarray_ptr<T>
 {
 public:
@@ -557,16 +465,6 @@
 	return Resize(Offset),true;
 }
 
-template<class T>
-bool
-operator==(const POD_autoarray_ptr<T>& lhs, const POD_autoarray_ptr<T>& rhs)
-{
-	const size_t ub = rhs.size();
-	if (ub!=lhs.size()) return false;
-	if (0==ub) return true;
-	return _value_vector_equal(lhs.data(),rhs.data(),ub);
-}
-
 #ifndef ZAIMONI_FORCE_ISO
 template<typename T>
 void
@@ -713,48 +611,6 @@
 	return dest.Resize(Offset),true;
 }
 
-template<class T>
-template<typename U>
-void
-POD_autoarray_ptr<T>::destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type))
-{
-	size_t i = this->size();
-	do	if (!equivalence(x,_ptr[--i]))
-			{
-			size_t j = i;
-			while(0<j && !equivalence(x,_ptr[j-1])) --j;
-			if (j<i)
-				{
-				this->DeleteNSlotsAt(j,(i-j)+1);
-				i = j;
-				}
-			else
-				this->DeleteIdx(i);
-			}
-	while(0<i);
-}
-
-template<class T>
-template<typename U>
-void
-POD_autoarray_ptr<T>::destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type))
-{
-	size_t i = this->size();
-	do	if (equivalence(x,_ptr[--i]))
-			{
-			size_t j = i;
-			while(0<j && equivalence(x,_ptr[j-1])) --j;
-			if (j<i)
-				{
-				this->DeleteNSlotsAt(j,(i-j)+1);
-				i = j;
-				}
-			else
-				this->DeleteIdx(i);
-			}
-	while(0<i);
-}
-
 // Resize won't compile without this [CSVTable.cxx]
 template<typename T>
 inline void

Added: trunk/Zaimoni.STL/POD_autoarray.hpp
===================================================================
--- trunk/Zaimoni.STL/POD_autoarray.hpp	                        (rev 0)
+++ trunk/Zaimoni.STL/POD_autoarray.hpp	2011-06-09 18:31:36 UTC (rev 663)
@@ -0,0 +1,162 @@
+// POD_autoarray.hpp
+// standard-format core for the autoarray family (AutoPtr.hpp) suitable for use
+// in standard-layout structs that have to be C-compatible
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+// this file is radically different than <memory>, don't pretend to be interoperable
+// NOTE: explicit-grabbing semantics for operator= breaks assigning function results (e.g., operator new)
+
+#ifndef ZAIMONI_POD_AUTOARRAY_HPP
+#define ZAIMONI_POD_AUTOARRAY_HPP 1
+
+#include "MetaRAM2.hpp"
+#include "metatype/c_array.hpp"
+
+namespace zaimoni	{
+
+// POD backing class for the autoarray and weak autoarray family
+template<typename T>
+class POD_autoarray_ptr : public c_array_CRTP<POD_autoarray_ptr<T>, T>
+{
+protected:
+	T* _ptr;
+#ifdef ZAIMONI_FORCE_ISO
+	size_t _size;
+#endif
+public:
+	ZAIMONI_STL_TYPE_GLUE_ARRAY(T);
+#ifndef ZAIMONI_FORCE_ISO
+	// core infrastructure
+	void NULLPtr() {_ptr = NULL;};
+	void de_novo(size_t n) {_ptr = n ? _new_buffer_nonNULL_throws<T>(n) : NULL;};
+	void de_novo_nothrow(size_t n) {_ptr = _new_buffer<T>(n);};
+	
+	size_t ArraySize() const {return zaimoni::ArraySize(_ptr);};
+	template<typename U> bool InsertSlotAt(size_t i, U _default) {return _insert_slot_at(_ptr,i,_default);}
+	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(_ptr,n,i);};
+	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(_ptr,n,i)) throw std::bad_alloc();};
+
+	void swap(POD_autoarray_ptr<T>& rhs) {std::swap(_ptr,rhs._ptr);};
+	
+	// STL support	
+	size_t size() const { return zaimoni::SafeArraySize(_ptr); };
+	T* release() {T* tmp = _ptr; _ptr = NULL; return tmp;};
+#else
+	void NULLPtr() {_ptr = NULL; _size = 0;};
+	void de_novo(size_t n) {_ptr = n ? _new_buffer_nonNULL_throws<T>(n) : NULL; _size = n;};
+	void de_novo_nothrow(size_t n) {_ptr = _new_buffer<T>(n); _size = n;};
+
+	size_t ArraySize() const {return _size;};
+	template<typename U> bool InsertSlotAt(size_t i, U _default) {return _insert_slot_at(_ptr,_size,i,_default);}
+	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(_ptr,_size,n,i);};
+	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(_ptr,_size,n,i)) throw std::bad_alloc();};
+
+	void swap(POD_autoarray_ptr<T>& rhs) {std::swap(_ptr,rhs._ptr); std::swap(_size,rhs._size);};
+	
+	// STL support	
+	T* release() {T* tmp = _ptr; _ptr = NULL; _size = 0; return tmp;};
+	size_t size() const { return _size; };
+#endif	
+	T* c_array() {return _ptr;};
+	const T* data() const {return _ptr;};
+	bool empty() const { return NULL==_ptr; };
+	static size_t max_size() { return size_t(-1)/sizeof(T); };	// XXX casting -1 to an unsigned type gets the maximum of that type
+
+	void rangecheck(size_t i) const { if (i>=size()) FATAL("out-of-bounds array access"); };
+
+	// Perl grep
+	template<typename U> void destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
+	template<typename U> void destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
+
+	// typecasts
+	operator T*&() {return _ptr;};
+	operator T* const&() const {return _ptr;};
+
+	// generic case is owned-values, so put autovalarray_ptr family implementations here
+#ifndef ZAIMONI_FORCE_ISO
+	bool Resize(size_t n) {return _resize(this->_ptr,n);};
+	void Shrink(size_t n) {_shrink(this->_ptr,n);};
+	void FastDeleteIdx(size_t n) {_delete_idx(this->_ptr,n);};
+	void DeleteIdx(size_t n) {_safe_delete_idx(this->_ptr,n);};
+	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(this->_ptr,n,Idx);};
+	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,indexes,n);};
+#else
+	bool Resize(size_t n) {return _resize(this->_ptr,this->_size,n);};
+	void Shrink(size_t n) {_shrink(this->_ptr,this->_size,n);};
+	void FastDeleteIdx(size_t n) {_delete_idx(this->_ptr,this->_size,n);};
+	void DeleteIdx(size_t n) {_safe_delete_idx(this->_ptr,this->_size,n);};
+	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(this->_ptr,this->_size,n,Idx);};
+	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(this->_ptr,this->_size,indexes,n);};
+#endif
+	void resize(size_t n) {if (!this->Resize(n)) throw std::bad_alloc();};	
+};
+
+} // namespace zaimoni
+
+namespace boost {
+
+#define ZAIMONI_TEMPLATE_SPEC template<typename T>
+#define ZAIMONI_CLASS_SPEC zaimoni::POD_autoarray_ptr<T>
+ZAIMONI_POD_STRUCT(ZAIMONI_TEMPLATE_SPEC,ZAIMONI_CLASS_SPEC,char)
+#undef ZAIMONI_CLASS_SPEC
+#undef ZAIMONI_TEMPLATE_SPEC
+
+} // namespace boost
+
+namespace zaimoni {
+
+template<class T>
+bool
+operator==(const POD_autoarray_ptr<T>& lhs, const POD_autoarray_ptr<T>& rhs)
+{
+	const size_t ub = rhs.size();
+	if (ub!=lhs.size()) return false;
+	if (0==ub) return true;
+	return _value_vector_equal(lhs.data(),rhs.data(),ub);
+}
+
+template<class T>
+template<typename U>
+void
+POD_autoarray_ptr<T>::destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type))
+{
+	size_t i = this->size();
+	do	if (!equivalence(x,_ptr[--i]))
+			{
+			size_t j = i;
+			while(0<j && !equivalence(x,_ptr[j-1])) --j;
+			if (j<i)
+				{
+				this->DeleteNSlotsAt(j,(i-j)+1);
+				i = j;
+				}
+			else
+				this->DeleteIdx(i);
+			}
+	while(0<i);
+}
+
+template<class T>
+template<typename U>
+void
+POD_autoarray_ptr<T>::destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type))
+{
+	size_t i = this->size();
+	do	if (equivalence(x,_ptr[--i]))
+			{
+			size_t j = i;
+			while(0<j && equivalence(x,_ptr[j-1])) --j;
+			if (j<i)
+				{
+				this->DeleteNSlotsAt(j,(i-j)+1);
+				i = j;
+				}
+			else
+				this->DeleteIdx(i);
+			}
+	while(0<i);
+}
+
+}		// end namespace zaimoni
+
+#endif

Modified: trunk/Zaimoni.STL/POSIX.dep
===================================================================
--- trunk/Zaimoni.STL/POSIX.dep	2011-06-09 03:19:53 UTC (rev 662)
+++ trunk/Zaimoni.STL/POSIX.dep	2011-06-09 18:31:36 UTC (rev 663)
@@ -27,8 +27,11 @@
 c_array_hpp = c_array.hpp $(addprefix ../, $(Logging_h)) ../boost_core.hpp $(addprefix ../, $(MetaRAM_hpp)) ../algorithm ../logic_lt.hpp operator.hpp
 
 # expand this
+# POD_autoarray.hpp
+POD_autoarray_hpp = $(MetaRAM2_hpp) $(addprefix metatype/, $(c_array_hpp))
+
 # AutoPtr.hpp
-AutoPtr_hpp = AutoPtr.hpp $(MetaRAM2_hpp) $(addprefix metatype/, $(c_array_hpp))
+AutoPtr_hpp = AutoPtr.hpp $(POD_autoarray_hpp)
 
 # LangConf.cpp
 LangConf_hpp = LangConf.hpp std.h $(addprefix ../, $(AutoPtr_hpp)) $(addprefix ../, $(POD_hpp))



From zaimoni at mail.berlios.de  Fri Jun 10 03:30:43 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 10 Jun 2011 03:30:43 +0200
Subject: [Zcplusplus-commits] r664 - trunk/Zaimoni.STL
Message-ID: <20110610013044.362784813CC@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-10 03:30:43 +0200 (Fri, 10 Jun 2011)
New Revision: 664

Modified:
   trunk/Zaimoni.STL/POD_autoarray.hpp
Log:
need this additional member function for the conversion

Modified: trunk/Zaimoni.STL/POD_autoarray.hpp
===================================================================
--- trunk/Zaimoni.STL/POD_autoarray.hpp	2011-06-09 18:31:36 UTC (rev 663)
+++ trunk/Zaimoni.STL/POD_autoarray.hpp	2011-06-10 01:30:43 UTC (rev 664)
@@ -35,6 +35,7 @@
 	template<typename U> bool InsertSlotAt(size_t i, U _default) {return _insert_slot_at(_ptr,i,_default);}
 	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(_ptr,n,i);};
 	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(_ptr,n,i)) throw std::bad_alloc();};
+	void Overwrite(T*& src) {_ptr = src; src = NULL;};
 
 	void swap(POD_autoarray_ptr<T>& rhs) {std::swap(_ptr,rhs._ptr);};
 	
@@ -50,6 +51,7 @@
 	template<typename U> bool InsertSlotAt(size_t i, U _default) {return _insert_slot_at(_ptr,_size,i,_default);}
 	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(_ptr,_size,n,i);};
 	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(_ptr,_size,n,i)) throw std::bad_alloc();};
+	void Overwrite(T*& src,size_t n) {_ptr = src; src = NULL; _size = n;};
 
 	void swap(POD_autoarray_ptr<T>& rhs) {std::swap(_ptr,rhs._ptr); std::swap(_size,rhs._size);};
 	



From zaimoni at mail.berlios.de  Fri Jun 10 03:50:46 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 10 Jun 2011 03:50:46 +0200
Subject: [Zcplusplus-commits] r665 - trunk
Message-ID: <20110610015046.C4FF44813CC@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-10 03:50:46 +0200 (Fri, 10 Jun 2011)
New Revision: 665

Modified:
   trunk/ParseTree.cpp
Log:
reduce code churn from planned big-bang patch

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2011-06-10 01:30:43 UTC (rev 664)
+++ trunk/ParseTree.cpp	2011-06-10 01:50:46 UTC (rev 665)
@@ -47,9 +47,9 @@
 #ifndef ZAIMONI_FORCE_ISO
 bool parse_tree::syntax_ok() const
 {
-	if (args[0] && !_memory_block_start_valid(args[0])) return false;
-	if (args[1] && !_memory_block_start_valid(args[1])) return false;
-	if (args[2] && !_memory_block_start_valid(args[2])) return false;
+	if (data<0>() && !_memory_block_start_valid(data<0>())) return false;
+	if (data<1>() && !_memory_block_start_valid(data<1>())) return false;
+	if (data<2>() && !_memory_block_start_valid(data<2>())) return false;
 
 	if (own_index_token<0>())
 		{
@@ -93,15 +93,15 @@
 bool parse_tree::entangled_with(const parse_tree& x) const
 {
 	if (x.type_code.entangled_with(type_code)) return true;
-	if (args[0] && x.args[0] && args[0]==x.args[0]) return true;
-	if (args[0] && x.args[1] && args[0]==x.args[1]) return true;
-	if (args[0] && x.args[2] && args[0]==x.args[2]) return true;
-	if (args[1] && x.args[0] && args[1]==x.args[0]) return true;
-	if (args[1] && x.args[1] && args[1]==x.args[1]) return true;
-	if (args[1] && x.args[2] && args[1]==x.args[2]) return true;
-	if (args[2] && x.args[0] && args[2]==x.args[0]) return true;
-	if (args[2] && x.args[1] && args[2]==x.args[1]) return true;
-	if (args[2] && x.args[2] && args[2]==x.args[2]) return true;
+	if (begin<0>() && x.begin<0>() && begin<0>()==x.begin<0>()) return true;
+	if (begin<0>() && x.begin<1>() && begin<0>()==x.begin<1>()) return true;
+	if (begin<0>() && x.begin<2>() && begin<0>()==x.begin<2>()) return true;
+	if (begin<1>() && x.begin<0>() && begin<1>()==x.begin<0>()) return true;
+	if (begin<1>() && x.begin<1>() && begin<1>()==x.begin<1>()) return true;
+	if (begin<1>() && x.begin<2>() && begin<1>()==x.begin<2>()) return true;
+	if (begin<2>() && x.begin<0>() && begin<2>()==x.begin<0>()) return true;
+	if (begin<2>() && x.begin<1>() && begin<2>()==x.begin<1>()) return true;
+	if (begin<2>() && x.begin<2>() && begin<2>()==x.begin<2>()) return true;
 
 	size_t i = 0;
 	while(size<0>()>i)
@@ -132,9 +132,9 @@
 
 bool parse_tree::self_entangled() const
 {
-	if (args[0] && args[1] && args[0]==args[1]) return true;
-	if (args[0] && args[2] && args[0]==args[2]) return true;
-	if (args[1] && args[2] && args[1]==args[2]) return true;
+	if (data<0>() && data<1>() && data<0>()==data<1>()) return true;
+	if (data<0>() && data<2>() && data<0>()==data<2>()) return true;
+	if (data<1>() && data<2>() && data<1>()==data<2>()) return true;
 
 	size_t i = 0;
 	while(size<0>()>i)



From zaimoni at mail.berlios.de  Fri Jun 10 05:13:09 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 10 Jun 2011 05:13:09 +0200
Subject: [Zcplusplus-commits] r666 - trunk
Message-ID: <20110610031309.5332C48121D@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-10 05:13:08 +0200 (Fri, 10 Jun 2011)
New Revision: 666

Modified:
   trunk/ParseTree.hpp
Log:
reduce code churn from planned big-bang patch

Modified: trunk/ParseTree.hpp
===================================================================
--- trunk/ParseTree.hpp	2011-06-10 01:50:46 UTC (rev 665)
+++ trunk/ParseTree.hpp	2011-06-10 03:13:08 UTC (rev 666)
@@ -239,7 +239,7 @@
 		assert(size<arg_idx>()-i>=n);
 		assert(0<n);
 		size_t idx = n;
-		do	ZCC_PARSETREE_CARRAY(arg_idx)[i+ --idx].destroy();
+		do	c_array<arg_idx>()[i+ --idx].destroy();
 		while(0<idx);
 #ifdef ZAIMONI_FORCE_ISO
 		zaimoni::_delete_n_slots_at(args[arg_idx].first,args[arg_idx].second,n,i);
@@ -251,7 +251,7 @@
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
 		assert(size<arg_idx>()>i);
-		ZCC_PARSETREE_CARRAY(arg_idx)[i].destroy();
+		c_array<arg_idx>()[i].destroy();
 #ifdef ZAIMONI_FORCE_ISO
 		zaimoni::_delete_idx(args[arg_idx].first,args[arg_idx].second,i);
 #else
@@ -291,7 +291,7 @@
 	template<size_t dest_idx> void fast_set_arg(parse_tree* src)
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>dest_idx);
-		assert(NULL!=src);
+		assert(src);
 		assert(NULL==ZCC_PARSETREE_CARRAY(dest_idx));
 		ZCC_PARSETREE_CARRAY(dest_idx) = src;
 #ifdef ZAIMONI_FORCE_ISO
@@ -325,7 +325,7 @@
 	template<size_t dest_idx> void grab_index_token_from(char*& src,zaimoni::lex_flags src_flags)
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(index_tokens)>dest_idx);
-		assert(NULL!=src);
+		assert(src);
 		if (own_index_token<dest_idx>()) free(const_cast<char*>(index_tokens[dest_idx].token.first));
 		index_tokens[dest_idx].token.first = src;
 		index_tokens[dest_idx].token.second = strlen(src);
@@ -336,7 +336,7 @@
 	template<size_t dest_idx> void grab_index_token_from(const char*& src,zaimoni::lex_flags src_flags)
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(index_tokens)>dest_idx);
-		assert(NULL!=src);
+		assert(src);
 		if (own_index_token<dest_idx>()) free(const_cast<char*>(index_tokens[dest_idx].token.first));
 		index_tokens[dest_idx].token.first = src;
 		index_tokens[dest_idx].token.second = strlen(src);
@@ -347,7 +347,7 @@
 	template<size_t dest_idx> void grab_index_token_from_str_literal(const char* const src,zaimoni::lex_flags src_flags)
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(index_tokens)>dest_idx);
-		assert(NULL!=src);
+		assert(src);
 		if (own_index_token<dest_idx>()) { free(const_cast<char*>(index_tokens[dest_idx].token.first)); };
 		index_tokens[dest_idx].token.first = src;
 		index_tokens[dest_idx].token.second = strlen(src);
@@ -357,7 +357,7 @@
 	template<size_t dest_idx> void set_index_token_from_str_literal(const char* const src)
 		{
 		BOOST_STATIC_ASSERT(STATIC_SIZE(index_tokens)>dest_idx);
-		assert(NULL!=src);
+		assert(src);
 		if (own_index_token<dest_idx>()) { free(const_cast<char*>(index_tokens[dest_idx].token.first)); };
 		index_tokens[dest_idx].token.first = src;
 		index_tokens[dest_idx].token.second = strlen(src);



From zaimoni at mail.berlios.de  Fri Jun 10 06:48:17 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 10 Jun 2011 06:48:17 +0200
Subject: [Zcplusplus-commits] r667 - trunk
Message-ID: <20110610044818.01DEC48135E@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-10 06:48:17 +0200 (Fri, 10 Jun 2011)
New Revision: 667

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/CSupport_pp.cpp
   trunk/ParseTree.cpp
   trunk/ParseTree.hpp
Log:
use POD_autoarray_ptr in parse_tree

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-06-10 03:13:08 UTC (rev 666)
+++ trunk/CSupport.cpp	2011-06-10 04:48:17 UTC (rev 667)
@@ -4023,7 +4023,7 @@
 			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags)
-			&&	src.type_code.is_type(C_TYPE::TYPEINFO)
+			&&	src.type_code.is_type<C_TYPE::TYPEINFO>()
 			&&	(src.type_code.qualifier<0>() & (type_spec::lvalue | type_spec::_const))==(type_spec::lvalue | type_spec::_const);
 }
 
@@ -5009,7 +5009,7 @@
 		zcc_errors.inc_error();
 		};
 
-	size_t j = STATIC_SIZE(src.args);
+	size_t j = STATIC_SIZE(src._args);
 	do	{
 		if (0== --j && src.index_tokens[0].token.first && src.index_tokens[1].token.first)
 			{
@@ -5163,15 +5163,11 @@
 {
 	if (1==src.size<0>() && is_naked_parentheses_pair(*src.data<0>()))
 		{
-		parse_tree::arglist_array tmp = src.c_array<0>()->args[0];
-#ifdef ZAIMONI_FORCE_ISO
-		src.c_array<0>()->args[0].first = NULL;				 
-#else
-		src.c_array<0>()->args[0] = NULL;
-#endif
+		zaimoni::POD_autoarray_ptr<parse_tree> tmp = src.c_array<0>()->_args[0];
+		src.c_array<0>()->_args[0].NULLPtr();
 		src.c_array<0>()->destroy();
 		parse_tree* const tmp2 = src.c_array<0>();
-		src.args[0] = tmp;
+		src._args[0] = tmp;
 		return tmp2;
 		};
 	return _new_buffer_nonNULL_throws<parse_tree>(1);
@@ -5181,15 +5177,11 @@
 {
 	while(1==src.size<0>() && is_naked_parentheses_pair(*src.data<0>()))
 		{
-		parse_tree::arglist_array tmp = src.c_array<0>()->args[0];
-#ifdef ZAIMONI_FORCE_ISO
-		src.c_array<0>()->args[0].first = NULL;				 
-#else
-		src.c_array<0>()->args[0] = NULL;
-#endif
+		zaimoni::POD_autoarray_ptr<parse_tree> tmp = src.c_array<0>()->_args[0];
+		src.c_array<0>()->_args[0].NULLPtr();
 		src.c_array<0>()->destroy();
 		free(src.c_array<0>());
-		src.args[0] = tmp;
+		src._args[0] = tmp;
 		}
 }
 
@@ -6211,7 +6203,7 @@
 	if (is_logical_NOT(*src.data<2>()))
 		{
 		if (	is_logical_NOT(*src.data<2>()->data<2>())
-			||	src.data<2>()->type_code.is_type(C_TYPE::BOOL))
+			||	src.data<2>()->type_code.is_type<C_TYPE::BOOL>())
 			{
 			parse_tree tmp;
 			src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
@@ -7250,11 +7242,7 @@
 				{
 				if (src.data<0>()[i-1].type_code.is_type<C_TYPE::NOT_VOID>())
 					{
-#ifndef ZAIMONI_FORCE_ISO
-					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
-#else
-					if (!_insert_n_slots_at(src.args[0].first,src.args[0].second,1,i)) throw std::bad_alloc();
-#endif
+					src._args[0].insertNSlotsAt(1,i);
 					src.c_array<0>()[i].clear();
 					src.c_array<0>()[i-1].front<2>().MoveInto(src.c_array<0>()[i]);
 					src.c_array<0>()[i-1].DeleteIdx<2>(0);
@@ -7291,11 +7279,7 @@
 				{
 				if (src.data<0>()[i-1].type_code.is_type<C_TYPE::NOT_VOID>())
 					{
-#ifndef ZAIMONI_FORCE_ISO
-					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
-#else
-					if (!_insert_n_slots_at(src.args[0].first,src.args[0].second,1,i)) throw std::bad_alloc();
-#endif
+					src._args[0].insertNSlotsAt(1,i);
 					src.c_array<0>()[i].clear();
 					src.c_array<0>()[i-1].front<2>().MoveInto(src.c_array<0>()[i]);
 					src.c_array<0>()[i-1].DeleteIdx<2>(0);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-06-10 03:13:08 UTC (rev 666)
+++ trunk/CSupport.cpp.in	2011-06-10 04:48:17 UTC (rev 667)
@@ -5081,7 +5081,7 @@
 		zcc_errors.inc_error();
 		};
 
-	size_t j = STATIC_SIZE(src.args);
+	size_t j = STATIC_SIZE(src._args);
 	do	{
 		if (0== --j && src.index_tokens[0].token.first && src.index_tokens[1].token.first)
 			{
@@ -5236,15 +5236,11 @@
 {
 	if (1==src.size<0>() && is_naked_parentheses_pair(*src.data<0>()))
 		{
-		parse_tree::arglist_array tmp = src.c_array<0>()->args[0];
-#ifdef ZAIMONI_FORCE_ISO
-		src.c_array<0>()->args[0].first = NULL;				 
-#else
-		src.c_array<0>()->args[0] = NULL;
-#endif
+		zaimoni::POD_autoarray_ptr<parse_tree> tmp = src.c_array<0>()->_args[0];
+		src.c_array<0>()->_args[0].NULLPtr();
 		src.c_array<0>()->destroy();
 		parse_tree* const tmp2 = src.c_array<0>();
-		src.args[0] = tmp;
+		src._args[0] = tmp;
 		return tmp2;
 		};
 	return _new_buffer_nonNULL_throws<parse_tree>(1);
@@ -5254,15 +5250,11 @@
 {
 	while(1==src.size<0>() && is_naked_parentheses_pair(*src.data<0>()))
 		{
-		parse_tree::arglist_array tmp = src.c_array<0>()->args[0];
-#ifdef ZAIMONI_FORCE_ISO
-		src.c_array<0>()->args[0].first = NULL;				 
-#else
-		src.c_array<0>()->args[0] = NULL;
-#endif
+		zaimoni::POD_autoarray_ptr<parse_tree> tmp = src.c_array<0>()->_args[0];
+		src.c_array<0>()->_args[0].NULLPtr();
 		src.c_array<0>()->destroy();
 		free(src.c_array<0>());
-		src.args[0] = tmp;
+		src._args[0] = tmp;
 		}
 }
 
@@ -7353,11 +7345,7 @@
 				{
 				if (src.data<0>()[i-1].type_code.is_type<C_TYPE::NOT_VOID>())
 					{
-#ifndef ZAIMONI_FORCE_ISO
-					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
-#else
-					if (!_insert_n_slots_at(src.args[0].first,src.args[0].second,1,i)) throw std::bad_alloc();
-#endif
+					src._args[0].insertNSlotsAt(1,i);
 					src.c_array<0>()[i].clear();
 					src.c_array<0>()[i-1].front<2>().MoveInto(src.c_array<0>()[i]);
 					src.c_array<0>()[i-1].DeleteIdx<2>(0);
@@ -7394,11 +7382,7 @@
 				{
 				if (src.data<0>()[i-1].type_code.is_type<C_TYPE::NOT_VOID>())
 					{
-#ifndef ZAIMONI_FORCE_ISO
-					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
-#else
-					if (!_insert_n_slots_at(src.args[0].first,src.args[0].second,1,i)) throw std::bad_alloc();
-#endif
+					src._args[0].insertNSlotsAt(1,i);
 					src.c_array<0>()[i].clear();
 					src.c_array<0>()[i-1].front<2>().MoveInto(src.c_array<0>()[i]);
 					src.c_array<0>()[i-1].DeleteIdx<2>(0);

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2011-06-10 03:13:08 UTC (rev 666)
+++ trunk/CSupport_pp.cpp	2011-06-10 04:48:17 UTC (rev 667)
@@ -3823,15 +3823,11 @@
 {
 	if (1==src.size<0>() && is_naked_parentheses_pair(*src.data<0>()))
 		{
-		parse_tree::arglist_array tmp = src.c_array<0>()->args[0];
-#ifdef ZAIMONI_FORCE_ISO
-		src.c_array<0>()->args[0].first = NULL;				 
-#else
-		src.c_array<0>()->args[0] = NULL;
-#endif
+		zaimoni::POD_autoarray_ptr<parse_tree> tmp = src.c_array<0>()->_args[0];
+		src.c_array<0>()->_args[0].NULLPtr();
 		src.c_array<0>()->destroy();
 		parse_tree* const tmp2 = src.c_array<0>();
-		src.args[0] = tmp;
+		src._args[0] = tmp;
 		return tmp2;
 		};
 	return _new_buffer_nonNULL_throws<parse_tree>(1);
@@ -3841,15 +3837,11 @@
 {
 	while(1==src.size<0>() && is_naked_parentheses_pair(*src.data<0>()))
 		{
-		parse_tree::arglist_array tmp = src.c_array<0>()->args[0];
-#ifdef ZAIMONI_FORCE_ISO
-		src.c_array<0>()->args[0].first = NULL;				 
-#else
-		src.c_array<0>()->args[0] = NULL;
-#endif
+		zaimoni::POD_autoarray_ptr<parse_tree> tmp = src.c_array<0>()->_args[0];
+		src.c_array<0>()->_args[0].NULLPtr();
 		src.c_array<0>()->destroy();
 		free(src.c_array<0>());
-		src.args[0] = tmp;
+		src._args[0] = tmp;
 		}
 }
 
@@ -4706,7 +4698,7 @@
 	if (is_logical_NOT(*src.data<2>()))
 		{
 		if (	is_logical_NOT(*src.data<2>()->data<2>())
-			||	src.data<2>()->type_code.is_type(C_TYPE::BOOL))
+			||	src.data<2>()->type_code.is_type<C_TYPE::BOOL>())
 			{
 			parse_tree tmp;
 			src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
@@ -5359,11 +5351,7 @@
 				{
 				if (src.data<0>()[i-1].type_code.is_type<C_TYPE::NOT_VOID>())
 					{
-#ifndef ZAIMONI_FORCE_ISO
-					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
-#else
-					if (!_insert_n_slots_at(src.args[0].first,src.args[0].second,1,i)) throw std::bad_alloc();
-#endif
+					src._args[0].insertNSlotsAt(1,i);
 					src.c_array<0>()[i].clear();
 					src.c_array<0>()[i-1].front<2>().MoveInto(src.c_array<0>()[i]);
 					src.c_array<0>()[i-1].DeleteIdx<2>(0);
@@ -5400,11 +5388,7 @@
 				{
 				if (src.data<0>()[i-1].type_code.is_type<C_TYPE::NOT_VOID>())
 					{
-#ifndef ZAIMONI_FORCE_ISO
-					if (!_insert_n_slots_at(src.args[0],1,i)) throw std::bad_alloc();
-#else
-					if (!_insert_n_slots_at(src.args[0].first,src.args[0].second,1,i)) throw std::bad_alloc();
-#endif
+					src._args[0].insertNSlotsAt(1,i);
 					src.c_array<0>()[i].clear();
 					src.c_array<0>()[i-1].front<2>().MoveInto(src.c_array<0>()[i]);
 					src.c_array<0>()[i-1].DeleteIdx<2>(0);

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2011-06-10 03:13:08 UTC (rev 666)
+++ trunk/ParseTree.cpp	2011-06-10 04:48:17 UTC (rev 667)
@@ -16,32 +16,14 @@
 
 bool parse_tree::is_atomic() const
 {
-	return (	NULL!=index_tokens[0].token.first
-			&&	NULL==index_tokens[1].token.first
-#ifdef ZAIMONI_FORCE_ISO
-			&&	NULL==args[0].first
-			&&	NULL==args[1].first
-			&&	NULL==args[2].first);
-#else
-			&&	NULL==args[0]
-			&&	NULL==args[1]
-			&&	NULL==args[2]);
-#endif
+	return index_tokens[0].token.first && !index_tokens[1].token.first
+		&& _args[0].empty() && _args[1].empty() && _args[2].empty();
 }
 
 bool parse_tree::is_raw_list() const
 {
-	return (	NULL==index_tokens[0].token.first
-			&&	NULL==index_tokens[1].token.first
-#ifdef ZAIMONI_FORCE_ISO
-			&&	NULL!=args[0].first
-			&&	NULL==args[1].first
-			&&	NULL==args[2].first);
-#else
-			&&	NULL!=args[0]
-			&&	NULL==args[1]
-			&&	NULL==args[2]);
-#endif
+	return !index_tokens[0].token.first &&	!index_tokens[1].token.first
+		&& !_args[0].empty() && _args[1].empty() && _args[2].empty();
 }
 
 #ifndef ZAIMONI_FORCE_ISO
@@ -168,52 +150,30 @@
 {
 	index_tokens[0].clear();
 	index_tokens[1].clear();
-#ifdef ZAIMONI_FORCE_ISO
-	args[0].first = NULL;
-	args[0].second = 0;
-	args[1].first = NULL;
-	args[1].second = 0;
-	args[2].first = NULL;
-	args[2].second = 0;
-#else
-	args[0] = NULL;
-	args[1] = NULL;
-	args[2] = NULL;
-#endif
+	_args[0].NULLPtr();
+	_args[1].NULLPtr();
+	_args[2].NULLPtr();
 	flags = 0;
 	subtype = 0;
 	type_code.clear();
 }
 
-#ifdef ZAIMONI_FORCE_ISO
-static void _destroy(zaimoni::POD_pair<parse_tree*,size_t>& target)
+static void _destroy(zaimoni::POD_autoarray_ptr<parse_tree>& target)
 {
-	if (NULL!=target.first)
+	if (!target.empty())
 		{
-		size_t i = target.second;
-		do	target.first[--i].destroy();
+		size_t i = target.size();
+		do	target.c_array()[--i].destroy();
 		while(0<i);
-		FREE_AND_NULL(target.first);
+		free(target.release());
 		}
 }
-#else
-static void _destroy(parse_tree*& target)
-{
-	if (NULL!=target)
-		{
-		size_t i = ArraySize(target);
-		do	target[--i].destroy();
-		while(0<i);
-		FREE_AND_NULL(target);
-		}
-}
-#endif
 
 void parse_tree::destroy()
 {
-	_destroy(args[2]);
-	_destroy(args[1]);
-	_destroy(args[0]);
+	_destroy(_args[2]);
+	_destroy(_args[1]);
+	_destroy(_args[0]);
 	if (own_index_token<1>()) free(const_cast<char*>(index_tokens[1].token.first));
 	if (own_index_token<0>()) free(const_cast<char*>(index_tokens[0].token.first));
 	index_tokens[1].token.first = NULL;
@@ -369,16 +329,10 @@
 //! the new slots have no content, OverwriteInto won't leak memory
 bool parse_tree::_resize(const size_t arg_idx,size_t n)
 {
-	assert(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-	const size_t old_size = args[arg_idx].second;
-	if (!zaimoni::_resize(args[arg_idx].first,args[arg_idx].second,n)) return false;
-	while(old_size<n) args[arg_idx].first[--n].clear();
-#else
-	const size_t old_size = SafeArraySize(args[arg_idx]);
-	if (!zaimoni::_resize(args[arg_idx],n)) return false;
-	while(old_size<n) args[arg_idx][--n].clear();
-#endif
+	assert(STATIC_SIZE(_args)>arg_idx);
+	const size_t old_size = size(arg_idx);
+	if (!_args[arg_idx].Resize(n)) return false;
+	while(old_size<n) c_array(arg_idx)[--n].clear();
 	return true;
 }
 
@@ -458,7 +412,7 @@
 // slicing copy constructor
 parse_tree_class::parse_tree_class(const parse_tree& src,size_t begin,size_t end,size_t dest_idx)
 {
-	assert(STATIC_SIZE(args)>dest_idx);
+	assert(STATIC_SIZE(_args)>dest_idx);
 	assert(begin<src.size(dest_idx));
 	assert(end<=src.size(dest_idx));
 	this->clear();

Modified: trunk/ParseTree.hpp
===================================================================
--- trunk/ParseTree.hpp	2011-06-10 03:13:08 UTC (rev 666)
+++ trunk/ParseTree.hpp	2011-06-10 04:48:17 UTC (rev 667)
@@ -6,7 +6,7 @@
 
 #include "type_spec.hpp"
 
-#include "Zaimoni.STL/MetaRAM2.hpp"
+#include "Zaimoni.STL/POD_autoarray.hpp"
 #include "weak_token.hpp"
 
 // KBB: this really should be a class rather than a struct; it would benefit from having a proper destructor.
@@ -28,12 +28,6 @@
 //! required to be POD to allow C memory management
 struct parse_tree
 {
-#ifdef ZAIMONI_FORCE_ISO
-	typedef zaimoni::POD_pair<parse_tree*,size_t> arglist_array;
-#else
-	typedef parse_tree* arglist_array;
-#endif
-
 	enum core_flags {	// standardize bitflag use
 		INVALID = (1<<2),	// invalid node
 		CONSTANT_EXPRESSION = (1<<3),	// compile-time constant expression
@@ -43,7 +37,7 @@
 	};
 
 	weak_token index_tokens[2];	//!< 0: left, 1: right
-	arglist_array args[3];		//!< 0: infix, 1: prefix, 2: postfix
+	zaimoni::POD_autoarray_ptr<parse_tree> _args[3];		//!< 0: infix, 1: prefix, 2: postfix
 	zaimoni::lex_flags flags;	// mostly opaque flag suite (parse_tree reserves the lowest 3 bits)
 	size_t subtype;				// opaque assistant to parser
 
@@ -60,151 +54,133 @@
 	void MoveInto(parse_tree& dest);
 	void OverwriteInto(parse_tree& dest);
 
-#ifdef ZAIMONI_FORCE_ISO
-#define	ZCC_PARSETREE_CARRAY(I) args[I].first
-#define	ZCC_PARSETREE_END(I) (args[I].first ? args[I].first+args[I].second : NULL)
-#define ZCC_PARSETREE_BACK(I) (*(args[I].first+args[I].second-1))
-#else
-#define	ZCC_PARSETREE_CARRAY(I) args[I]
-#define	ZCC_PARSETREE_END(I) (args[I] ? args[I]+zaimoni::ArraySize(args[I]) : NULL)
-#define ZCC_PARSETREE_BACK(I) (*(args[I]+zaimoni::ArraySize(args[I])-1))
-#endif
-
 	parse_tree* c_array(size_t arg_idx)
 		{
-		assert(STATIC_SIZE(args)>arg_idx);
-		return ZCC_PARSETREE_CARRAY(arg_idx);
+		assert(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].c_array();
 		};
 	template<size_t arg_idx> parse_tree* c_array()
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-		return ZCC_PARSETREE_CARRAY(arg_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].c_array();
 		}
 	const parse_tree* data(size_t arg_idx) const
 		{
-		assert(STATIC_SIZE(args)>arg_idx);
-		return ZCC_PARSETREE_CARRAY(arg_idx);
+		assert(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].data();
 		}
 	template<size_t arg_idx> const parse_tree* data() const
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-		return ZCC_PARSETREE_CARRAY(arg_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].data();
 		}
 	size_t size(size_t arg_idx) const
 		{
-		assert(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return (NULL==args[arg_idx].first) ? 0 : args[arg_idx].second;
-#else
-		return zaimoni::SafeArraySize(args[arg_idx]);
-#endif
+		assert(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].size();
 		}
 	template<size_t arg_idx> size_t size() const
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-#ifdef ZAIMONI_FORCE_ISO
-		return (NULL==args[arg_idx].first) ? 0 : args[arg_idx].second;
-#else
-		return zaimoni::SafeArraySize(args[arg_idx]);
-#endif
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].size();
 		}
 	parse_tree* begin(size_t arg_idx)
 		{
-		assert(STATIC_SIZE(args)>arg_idx);
-		return ZCC_PARSETREE_CARRAY(arg_idx);
+		assert(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].begin();
 		};
 	template<size_t arg_idx> parse_tree* begin()
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-		return ZCC_PARSETREE_CARRAY(arg_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].begin();
 		}
 	const parse_tree* begin(size_t arg_idx) const
 		{
-		assert(STATIC_SIZE(args)>arg_idx);
-		return ZCC_PARSETREE_CARRAY(arg_idx);
+		assert(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].begin();
 		}
 	template<size_t arg_idx> const parse_tree* begin() const
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-		return ZCC_PARSETREE_CARRAY(arg_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].begin();
 		}
 	parse_tree* end(size_t arg_idx)
 		{
-		assert(STATIC_SIZE(args)>arg_idx);
-		return ZCC_PARSETREE_END(arg_idx);
+		assert(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].end();
 		};
 	template<size_t arg_idx> parse_tree* end()
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-		return ZCC_PARSETREE_END(arg_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].end();
 		}
 	const parse_tree* end(size_t arg_idx) const
 		{
-		assert(STATIC_SIZE(args)>arg_idx);
-		return ZCC_PARSETREE_END(arg_idx);
+		assert(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].end();
 		}
 	template<size_t arg_idx> const parse_tree* end() const
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-		return ZCC_PARSETREE_END(arg_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].end();
 		}
 	parse_tree& front(size_t arg_idx)
 		{
-		assert(STATIC_SIZE(args)>arg_idx);
-		assert(ZCC_PARSETREE_CARRAY(arg_idx));
-		return *ZCC_PARSETREE_CARRAY(arg_idx);
+		assert(STATIC_SIZE(_args)>arg_idx);
+		assert(!empty(arg_idx));
+		return _args[arg_idx].front();
 		};
 	template<size_t arg_idx> parse_tree& front()
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-		assert(ZCC_PARSETREE_CARRAY(arg_idx));
-		return *ZCC_PARSETREE_CARRAY(arg_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
+		assert(!empty<arg_idx>());
+		return _args[arg_idx].front();
 		}
 	const parse_tree& front(size_t arg_idx) const
 		{
-		assert(STATIC_SIZE(args)>arg_idx);
-		assert(ZCC_PARSETREE_CARRAY(arg_idx));
-		return *ZCC_PARSETREE_CARRAY(arg_idx);
+		assert(STATIC_SIZE(_args)>arg_idx);
+		assert(!empty(arg_idx));
+		return _args[arg_idx].front();
 		}
 	template<size_t arg_idx> const parse_tree& front() const
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-		assert(ZCC_PARSETREE_CARRAY(arg_idx));
-		return *ZCC_PARSETREE_CARRAY(arg_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
+		assert(!empty<arg_idx>());
+		return _args[arg_idx].front();
 		}
 	parse_tree& back(size_t arg_idx)
 		{
-		assert(STATIC_SIZE(args)>arg_idx);
-		assert(ZCC_PARSETREE_CARRAY(arg_idx));
-		return ZCC_PARSETREE_BACK(arg_idx);
+		assert(STATIC_SIZE(_args)>arg_idx);
+		assert(!empty(arg_idx));
+		return _args[arg_idx].back();
 		};
 	template<size_t arg_idx> parse_tree& back()
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-		assert(ZCC_PARSETREE_CARRAY(arg_idx));
-		return ZCC_PARSETREE_BACK(arg_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
+		assert(!empty<arg_idx>());
+		return _args[arg_idx].back();
 		}
 	const parse_tree& back(size_t arg_idx) const
 		{
-		assert(STATIC_SIZE(args)>arg_idx);
-		assert(ZCC_PARSETREE_CARRAY(arg_idx));
-		return ZCC_PARSETREE_BACK(arg_idx);
+		assert(STATIC_SIZE(_args)>arg_idx);
+		assert(!empty(arg_idx));
+		return _args[arg_idx].back();
 		}
 	template<size_t arg_idx> const parse_tree& back() const
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-		assert(ZCC_PARSETREE_CARRAY(arg_idx));
-		return ZCC_PARSETREE_BACK(arg_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
+		assert(!empty<arg_idx>());
+		return _args[arg_idx].back();
 		}
 	bool empty(size_t arg_idx) const
 		{
-		assert(STATIC_SIZE(args)>arg_idx);
-		return !ZCC_PARSETREE_CARRAY(arg_idx);
+		assert(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].empty();
 		}
 	template<size_t arg_idx> bool empty() const
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
-		return !ZCC_PARSETREE_CARRAY(arg_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
+		return _args[arg_idx].empty();
 		}
 	template<size_t i> bool own_index_token() const
 		{
@@ -218,49 +194,41 @@
 		}
 	bool resize(size_t arg_idx,size_t n)
 		{
-		assert(STATIC_SIZE(args)>arg_idx);
+		assert(STATIC_SIZE(_args)>arg_idx);
 		return _resize(arg_idx,n);
 		}
 	template<size_t arg_idx> bool resize(size_t n)
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
 		return _resize(arg_idx,n);
 		}
 	template<size_t arg_idx> void eval_to_arg(size_t i)
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
 		assert(size<arg_idx>()>i);
 		_eval_to_arg(arg_idx,i);
 		}
 	template<size_t arg_idx> void DeleteNSlotsAt(size_t n,size_t i)
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
 		assert(size<arg_idx>()>i);
 		assert(size<arg_idx>()-i>=n);
 		assert(0<n);
 		size_t idx = n;
 		do	c_array<arg_idx>()[i+ --idx].destroy();
 		while(0<idx);
-#ifdef ZAIMONI_FORCE_ISO
-		zaimoni::_delete_n_slots_at(args[arg_idx].first,args[arg_idx].second,n,i);
-#else
-		zaimoni::_delete_n_slots_at(args[arg_idx],n,i);
-#endif
+		_args[arg_idx].DeleteNSlotsAt(n,i);
 		}
 	template<size_t arg_idx> void DeleteIdx(size_t i)
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>arg_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>arg_idx);
 		assert(size<arg_idx>()>i);
 		c_array<arg_idx>()[i].destroy();
-#ifdef ZAIMONI_FORCE_ISO
-		zaimoni::_delete_idx(args[arg_idx].first,args[arg_idx].second,i);
-#else
-		zaimoni::_delete_idx(args[arg_idx],i);
-#endif
+		_args[arg_idx].DeleteIdx(i);
 		}
 	template<size_t dest_idx> void DestroyNAtAndRotateTo(size_t n,size_t i,const size_t actual_size)
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>dest_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>dest_idx);
 		assert(size<dest_idx>()>=actual_size);
 		assert(actual_size>i);
 		assert(actual_size-i>=n);
@@ -290,12 +258,13 @@
 
 	template<size_t dest_idx> void fast_set_arg(parse_tree* src)
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>dest_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>dest_idx);
 		assert(src);
-		assert(NULL==ZCC_PARSETREE_CARRAY(dest_idx));
-		ZCC_PARSETREE_CARRAY(dest_idx) = src;
-#ifdef ZAIMONI_FORCE_ISO
-		args[dest_idx].second = 1;
+		assert(empty<dest_idx>());
+#ifndef ZAIMONI_FORCE_ISO
+		_args[dest_idx].Overwrite(src);
+#else
+		_args[dest_idx].Overwrite(src,1);
 #endif
 		}
 
@@ -366,7 +335,7 @@
 
 	template<size_t src_idx,class scanner> size_t get_span(size_t i,scanner& x) const
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>src_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>src_idx);
 		assert(size<src_idx>()>i);
 		size_t found = 0;
 		while(x(data<src_idx>()[i]) && (++found,size<src_idx>()> ++i));
@@ -374,7 +343,7 @@
 		}
 	template<size_t src_idx,class scanner> size_t destructive_get_span(size_t i,scanner& x)
 		{
-		BOOST_STATIC_ASSERT(STATIC_SIZE(args)>src_idx);
+		BOOST_STATIC_ASSERT(STATIC_SIZE(_args)>src_idx);
 		assert(size<src_idx>()>i);
 		size_t found = 0;
 		while(x(*this,i) && (++found,size<src_idx>()> ++i));



From zaimoni at mail.berlios.de  Fri Jun 10 19:45:21 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 10 Jun 2011 19:45:21 +0200
Subject: [Zcplusplus-commits] r668 - trunk/tools
Message-ID: <20110610174521.8D0634801AA@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-10 19:45:20 +0200 (Fri, 10 Jun 2011)
New Revision: 668

Modified:
   trunk/tools/decl_infile.py
Log:
C keyword is _Thread_local, not _Thread_Local #1

Modified: trunk/tools/decl_infile.py
===================================================================
--- trunk/tools/decl_infile.py	2011-06-10 04:48:17 UTC (rev 667)
+++ trunk/tools/decl_infile.py	2011-06-10 17:45:20 UTC (rev 668)
@@ -11,7 +11,7 @@
 
 invariant_header_lines = [
 'SUFFIXES h hpp\n'
-'OBJECTLIKE_MACRO THREAD_LOCAL _Thread_Local thread_local\n'
+'OBJECTLIKE_MACRO THREAD_LOCAL _Thread_local thread_local\n'
 '// (C)2009,2011 Kenneth Boyd, license: MIT.txt\n'
 ]
 



From zaimoni at mail.berlios.de  Fri Jun 10 19:46:01 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 10 Jun 2011 19:46:01 +0200
Subject: [Zcplusplus-commits] r669 - trunk/tests/zcc.in/decl.C99
Message-ID: <20110610174601.CE06E4801AA@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-10 19:46:01 +0200 (Fri, 10 Jun 2011)
New Revision: 669

Modified:
   trunk/tests/zcc.in/decl.C99/Error_extern_static_thread_local_typedef.in
   trunk/tests/zcc.in/decl.C99/Error_extern_thread_local_typedef.in
   trunk/tests/zcc.in/decl.C99/Error_static_thread_local_typedef.in
   trunk/tests/zcc.in/decl.C99/Error_thread_local_typedef.in
   trunk/tests/zcc.in/decl.C99/Pass_enum_def.in
   trunk/tests/zcc.in/decl.C99/Pass_enum_def_decl.in
   trunk/tests/zcc.in/decl.C99/Pass_struct_def.in
   trunk/tests/zcc.in/decl.C99/Pass_struct_def_decl.in
   trunk/tests/zcc.in/decl.C99/Pass_union_def.in
   trunk/tests/zcc.in/decl.C99/Pass_union_def_decl.in
Log:
C keyword is _Thread_local, not _Thread_Local #2

Modified: trunk/tests/zcc.in/decl.C99/Error_extern_static_thread_local_typedef.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_extern_static_thread_local_typedef.in	2011-06-10 17:45:20 UTC (rev 668)
+++ trunk/tests/zcc.in/decl.C99/Error_extern_static_thread_local_typedef.in	2011-06-10 17:46:01 UTC (rev 669)
@@ -1,5 +1,5 @@
 SUFFIXES h hpp
-OBJECTLIKE_MACRO THREAD_LOCAL _Thread_Local thread_local
+OBJECTLIKE_MACRO THREAD_LOCAL _Thread_local thread_local
 // declaration with too many storage qualifiers
 // (C)2011 Kenneth Boyd, license: MIT.txt
 

Modified: trunk/tests/zcc.in/decl.C99/Error_extern_thread_local_typedef.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_extern_thread_local_typedef.in	2011-06-10 17:45:20 UTC (rev 668)
+++ trunk/tests/zcc.in/decl.C99/Error_extern_thread_local_typedef.in	2011-06-10 17:46:01 UTC (rev 669)
@@ -1,5 +1,5 @@
 SUFFIXES h hpp
-OBJECTLIKE_MACRO THREAD_LOCAL _Thread_Local thread_local
+OBJECTLIKE_MACRO THREAD_LOCAL _Thread_local thread_local
 // declaration with too many storage qualifiers
 // (C)2011 Kenneth Boyd, license: MIT.txt
 

Modified: trunk/tests/zcc.in/decl.C99/Error_static_thread_local_typedef.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_static_thread_local_typedef.in	2011-06-10 17:45:20 UTC (rev 668)
+++ trunk/tests/zcc.in/decl.C99/Error_static_thread_local_typedef.in	2011-06-10 17:46:01 UTC (rev 669)
@@ -1,5 +1,5 @@
 SUFFIXES h hpp
-OBJECTLIKE_MACRO THREAD_LOCAL _Thread_Local thread_local
+OBJECTLIKE_MACRO THREAD_LOCAL _Thread_local thread_local
 // declaration with too many storage qualifiers
 // (C)2011 Kenneth Boyd, license: MIT.txt
 

Modified: trunk/tests/zcc.in/decl.C99/Error_thread_local_typedef.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_thread_local_typedef.in	2011-06-10 17:45:20 UTC (rev 668)
+++ trunk/tests/zcc.in/decl.C99/Error_thread_local_typedef.in	2011-06-10 17:46:01 UTC (rev 669)
@@ -1,5 +1,5 @@
 SUFFIXES h hpp
-OBJECTLIKE_MACRO THREAD_LOCAL _Thread_Local thread_local
+OBJECTLIKE_MACRO THREAD_LOCAL _Thread_local thread_local
 // declaration with too many storage qualifiers
 // (C)2011 Kenneth Boyd, license: MIT.txt
 

Modified: trunk/tests/zcc.in/decl.C99/Pass_enum_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_enum_def.in	2011-06-10 17:45:20 UTC (rev 668)
+++ trunk/tests/zcc.in/decl.C99/Pass_enum_def.in	2011-06-10 17:46:01 UTC (rev 669)
@@ -1,5 +1,5 @@
 SUFFIXES h hpp
-OBJECTLIKE_MACRO THREAD_LOCAL _Thread_Local thread_local
+OBJECTLIKE_MACRO THREAD_LOCAL _Thread_local thread_local
 // (C)2009,2011 Kenneth Boyd, license: MIT.txt
 // using singly defined enum
 

Modified: trunk/tests/zcc.in/decl.C99/Pass_enum_def_decl.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_enum_def_decl.in	2011-06-10 17:45:20 UTC (rev 668)
+++ trunk/tests/zcc.in/decl.C99/Pass_enum_def_decl.in	2011-06-10 17:46:01 UTC (rev 669)
@@ -1,5 +1,5 @@
 SUFFIXES h hpp
-OBJECTLIKE_MACRO THREAD_LOCAL _Thread_Local thread_local
+OBJECTLIKE_MACRO THREAD_LOCAL _Thread_local thread_local
 // (C)2009,2011 Kenneth Boyd, license: MIT.txt
 // using singly defined enum
 

Modified: trunk/tests/zcc.in/decl.C99/Pass_struct_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_struct_def.in	2011-06-10 17:45:20 UTC (rev 668)
+++ trunk/tests/zcc.in/decl.C99/Pass_struct_def.in	2011-06-10 17:46:01 UTC (rev 669)
@@ -1,5 +1,5 @@
 SUFFIXES h hpp
-OBJECTLIKE_MACRO THREAD_LOCAL _Thread_Local thread_local
+OBJECTLIKE_MACRO THREAD_LOCAL _Thread_local thread_local
 // (C)2009,2011 Kenneth Boyd, license: MIT.txt
 // using singly defined struct
 

Modified: trunk/tests/zcc.in/decl.C99/Pass_struct_def_decl.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_struct_def_decl.in	2011-06-10 17:45:20 UTC (rev 668)
+++ trunk/tests/zcc.in/decl.C99/Pass_struct_def_decl.in	2011-06-10 17:46:01 UTC (rev 669)
@@ -1,5 +1,5 @@
 SUFFIXES h hpp
-OBJECTLIKE_MACRO THREAD_LOCAL _Thread_Local thread_local
+OBJECTLIKE_MACRO THREAD_LOCAL _Thread_local thread_local
 // (C)2009,2011 Kenneth Boyd, license: MIT.txt
 // using singly defined struct
 

Modified: trunk/tests/zcc.in/decl.C99/Pass_union_def.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_union_def.in	2011-06-10 17:45:20 UTC (rev 668)
+++ trunk/tests/zcc.in/decl.C99/Pass_union_def.in	2011-06-10 17:46:01 UTC (rev 669)
@@ -1,5 +1,5 @@
 SUFFIXES h hpp
-OBJECTLIKE_MACRO THREAD_LOCAL _Thread_Local thread_local
+OBJECTLIKE_MACRO THREAD_LOCAL _Thread_local thread_local
 // (C)2009,2011 Kenneth Boyd, license: MIT.txt
 // using singly defined union
 

Modified: trunk/tests/zcc.in/decl.C99/Pass_union_def_decl.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Pass_union_def_decl.in	2011-06-10 17:45:20 UTC (rev 668)
+++ trunk/tests/zcc.in/decl.C99/Pass_union_def_decl.in	2011-06-10 17:46:01 UTC (rev 669)
@@ -1,5 +1,5 @@
 SUFFIXES h hpp
-OBJECTLIKE_MACRO THREAD_LOCAL _Thread_Local thread_local
+OBJECTLIKE_MACRO THREAD_LOCAL _Thread_local thread_local
 // (C)2009,2011 Kenneth Boyd, license: MIT.txt
 // using singly defined union
 



From zaimoni at mail.berlios.de  Fri Jun 10 19:47:21 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 10 Jun 2011 19:47:21 +0200
Subject: [Zcplusplus-commits] r670 - trunk/tests/zcc/decl.C99
Message-ID: <20110610174721.C69764801AA@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-10 19:47:21 +0200 (Fri, 10 Jun 2011)
New Revision: 670

Modified:
   trunk/tests/zcc/decl.C99/Error_extern_static_thread_local_typedef.h
   trunk/tests/zcc/decl.C99/Error_extern_thread_local_typedef.h
   trunk/tests/zcc/decl.C99/Error_static_thread_local_typedef.h
   trunk/tests/zcc/decl.C99/Error_thread_local_typedef.h
   trunk/tests/zcc/decl.C99/Pass_enum_def.h
   trunk/tests/zcc/decl.C99/Pass_enum_def_decl.h
   trunk/tests/zcc/decl.C99/Pass_struct_def.h
   trunk/tests/zcc/decl.C99/Pass_struct_def_decl.h
   trunk/tests/zcc/decl.C99/Pass_union_def.h
   trunk/tests/zcc/decl.C99/Pass_union_def_decl.h
Log:
C keyword is _Thread_local, not _Thread_Local #3

Modified: trunk/tests/zcc/decl.C99/Error_extern_static_thread_local_typedef.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_extern_static_thread_local_typedef.h	2011-06-10 17:46:01 UTC (rev 669)
+++ trunk/tests/zcc/decl.C99/Error_extern_static_thread_local_typedef.h	2011-06-10 17:47:21 UTC (rev 670)
@@ -2,4 +2,4 @@
 // declaration with too many storage qualifiers
 // (C)2011 Kenneth Boyd, license: MIT.txt
 
-extern static _Thread_Local typedef int i;
+extern static _Thread_local typedef int i;

Modified: trunk/tests/zcc/decl.C99/Error_extern_thread_local_typedef.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_extern_thread_local_typedef.h	2011-06-10 17:46:01 UTC (rev 669)
+++ trunk/tests/zcc/decl.C99/Error_extern_thread_local_typedef.h	2011-06-10 17:47:21 UTC (rev 670)
@@ -2,4 +2,4 @@
 // declaration with too many storage qualifiers
 // (C)2011 Kenneth Boyd, license: MIT.txt
 
-extern _Thread_Local typedef int i;
+extern _Thread_local typedef int i;

Modified: trunk/tests/zcc/decl.C99/Error_static_thread_local_typedef.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_static_thread_local_typedef.h	2011-06-10 17:46:01 UTC (rev 669)
+++ trunk/tests/zcc/decl.C99/Error_static_thread_local_typedef.h	2011-06-10 17:47:21 UTC (rev 670)
@@ -2,4 +2,4 @@
 // declaration with too many storage qualifiers
 // (C)2011 Kenneth Boyd, license: MIT.txt
 
-static _Thread_Local typedef int i;
+static _Thread_local typedef int i;

Modified: trunk/tests/zcc/decl.C99/Error_thread_local_typedef.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_thread_local_typedef.h	2011-06-10 17:46:01 UTC (rev 669)
+++ trunk/tests/zcc/decl.C99/Error_thread_local_typedef.h	2011-06-10 17:47:21 UTC (rev 670)
@@ -2,4 +2,4 @@
 // declaration with too many storage qualifiers
 // (C)2011 Kenneth Boyd, license: MIT.txt
 
-_Thread_Local typedef int i;
+_Thread_local typedef int i;

Modified: trunk/tests/zcc/decl.C99/Pass_enum_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_def.h	2011-06-10 17:46:01 UTC (rev 669)
+++ trunk/tests/zcc/decl.C99/Pass_enum_def.h	2011-06-10 17:47:21 UTC (rev 670)
@@ -33,89 +33,89 @@
 volatile static const enum good_test x19;
 volatile const static enum good_test x20;
 
-// ringing the changes on _Thread_Local extern
-extern _Thread_Local enum good_test x21;
-extern _Thread_Local const enum good_test x22;
-extern _Thread_Local volatile enum good_test x23;
-extern _Thread_Local const volatile enum good_test x24;
-extern _Thread_Local volatile const enum good_test x25;
-_Thread_Local extern enum good_test x26;
-_Thread_Local extern const enum good_test x27;
-_Thread_Local extern volatile enum good_test x28;
-_Thread_Local extern const volatile enum good_test x29;
-_Thread_Local extern volatile const enum good_test x30;
+// ringing the changes on _Thread_local extern
+extern _Thread_local enum good_test x21;
+extern _Thread_local const enum good_test x22;
+extern _Thread_local volatile enum good_test x23;
+extern _Thread_local const volatile enum good_test x24;
+extern _Thread_local volatile const enum good_test x25;
+_Thread_local extern enum good_test x26;
+_Thread_local extern const enum good_test x27;
+_Thread_local extern volatile enum good_test x28;
+_Thread_local extern const volatile enum good_test x29;
+_Thread_local extern volatile const enum good_test x30;
 
-// ringing the changes on _Thread_Local static
-static _Thread_Local enum good_test x31;
-static _Thread_Local const enum good_test x32;
-static _Thread_Local volatile enum good_test x33;
-static _Thread_Local const volatile enum good_test x34;
-static _Thread_Local volatile const enum good_test x35;
-_Thread_Local static enum good_test x36;
-_Thread_Local static const enum good_test x37;
-_Thread_Local static volatile enum good_test x38;
-_Thread_Local static const volatile enum good_test x39;
-_Thread_Local static volatile const enum good_test x40;
+// ringing the changes on _Thread_local static
+static _Thread_local enum good_test x31;
+static _Thread_local const enum good_test x32;
+static _Thread_local volatile enum good_test x33;
+static _Thread_local const volatile enum good_test x34;
+static _Thread_local volatile const enum good_test x35;
+_Thread_local static enum good_test x36;
+_Thread_local static const enum good_test x37;
+_Thread_local static volatile enum good_test x38;
+_Thread_local static const volatile enum good_test x39;
+_Thread_local static volatile const enum good_test x40;
 
-// _Thread_Local extern not in first two postions is deprecated, but legal
-extern const _Thread_Local enum good_test x41;
-const extern _Thread_Local enum good_test x42;
-extern volatile _Thread_Local enum good_test x43;
-volatile extern _Thread_Local enum good_test x44;
-extern const _Thread_Local volatile enum good_test x45;
-extern const volatile _Thread_Local enum good_test x46;
-const extern _Thread_Local volatile enum good_test x47;
-const extern volatile _Thread_Local enum good_test x48;
-const volatile extern _Thread_Local enum good_test x49;
-extern volatile _Thread_Local const enum good_test x50;
-extern volatile const _Thread_Local enum good_test x51;
-volatile extern _Thread_Local const enum good_test x52;
-volatile extern const _Thread_Local enum good_test x53;
-volatile const extern _Thread_Local enum good_test x54;
-_Thread_Local const extern enum good_test x55;
-const _Thread_Local extern enum good_test x56;
-_Thread_Local volatile extern enum good_test x57;
-volatile _Thread_Local extern enum good_test x58;
-_Thread_Local const extern volatile enum good_test x59;
-_Thread_Local const volatile extern enum good_test x60;
-const _Thread_Local extern volatile enum good_test x61;
-const _Thread_Local volatile extern enum good_test x62;
-const volatile _Thread_Local extern enum good_test x63;
-_Thread_Local volatile extern const enum good_test x64;
-_Thread_Local volatile const extern enum good_test x65;
-volatile _Thread_Local extern const enum good_test x66;
-volatile _Thread_Local const extern enum good_test x67;
-volatile const _Thread_Local extern enum good_test x68;
+// _Thread_local extern not in first two postions is deprecated, but legal
+extern const _Thread_local enum good_test x41;
+const extern _Thread_local enum good_test x42;
+extern volatile _Thread_local enum good_test x43;
+volatile extern _Thread_local enum good_test x44;
+extern const _Thread_local volatile enum good_test x45;
+extern const volatile _Thread_local enum good_test x46;
+const extern _Thread_local volatile enum good_test x47;
+const extern volatile _Thread_local enum good_test x48;
+const volatile extern _Thread_local enum good_test x49;
+extern volatile _Thread_local const enum good_test x50;
+extern volatile const _Thread_local enum good_test x51;
+volatile extern _Thread_local const enum good_test x52;
+volatile extern const _Thread_local enum good_test x53;
+volatile const extern _Thread_local enum good_test x54;
+_Thread_local const extern enum good_test x55;
+const _Thread_local extern enum good_test x56;
+_Thread_local volatile extern enum good_test x57;
+volatile _Thread_local extern enum good_test x58;
+_Thread_local const extern volatile enum good_test x59;
+_Thread_local const volatile extern enum good_test x60;
+const _Thread_local extern volatile enum good_test x61;
+const _Thread_local volatile extern enum good_test x62;
+const volatile _Thread_local extern enum good_test x63;
+_Thread_local volatile extern const enum good_test x64;
+_Thread_local volatile const extern enum good_test x65;
+volatile _Thread_local extern const enum good_test x66;
+volatile _Thread_local const extern enum good_test x67;
+volatile const _Thread_local extern enum good_test x68;
 
-// _Thread_Local static not in first two postions is deprecated, but legal
-static const _Thread_Local enum good_test x69;
-const static _Thread_Local enum good_test x70;
-static volatile _Thread_Local enum good_test x71;
-volatile static _Thread_Local enum good_test x72;
-static const _Thread_Local volatile enum good_test x73;
-static const volatile _Thread_Local enum good_test x74;
-const static _Thread_Local volatile enum good_test x75;
-const static volatile _Thread_Local enum good_test x76;
-const volatile static _Thread_Local enum good_test x77;
-static volatile _Thread_Local const enum good_test x78;
-static volatile const _Thread_Local enum good_test x79;
-volatile static _Thread_Local const enum good_test x80;
-volatile static const _Thread_Local enum good_test x81;
-volatile const static _Thread_Local enum good_test x82;
-_Thread_Local const static enum good_test x83;
-const _Thread_Local static enum good_test x84;
-_Thread_Local volatile static enum good_test x85;
-volatile _Thread_Local static enum good_test x86;
-_Thread_Local const static volatile enum good_test x87;
-_Thread_Local const volatile static enum good_test x88;
-const _Thread_Local static volatile enum good_test x89;
-const _Thread_Local volatile static enum good_test x90;
-const volatile _Thread_Local static enum good_test x91;
-_Thread_Local volatile static const enum good_test x92;
-_Thread_Local volatile const static enum good_test x93;
-volatile _Thread_Local static const enum good_test x94;
-volatile _Thread_Local const static enum good_test x95;
-volatile const _Thread_Local static enum good_test x96;
+// _Thread_local static not in first two postions is deprecated, but legal
+static const _Thread_local enum good_test x69;
+const static _Thread_local enum good_test x70;
+static volatile _Thread_local enum good_test x71;
+volatile static _Thread_local enum good_test x72;
+static const _Thread_local volatile enum good_test x73;
+static const volatile _Thread_local enum good_test x74;
+const static _Thread_local volatile enum good_test x75;
+const static volatile _Thread_local enum good_test x76;
+const volatile static _Thread_local enum good_test x77;
+static volatile _Thread_local const enum good_test x78;
+static volatile const _Thread_local enum good_test x79;
+volatile static _Thread_local const enum good_test x80;
+volatile static const _Thread_local enum good_test x81;
+volatile const static _Thread_local enum good_test x82;
+_Thread_local const static enum good_test x83;
+const _Thread_local static enum good_test x84;
+_Thread_local volatile static enum good_test x85;
+volatile _Thread_local static enum good_test x86;
+_Thread_local const static volatile enum good_test x87;
+_Thread_local const volatile static enum good_test x88;
+const _Thread_local static volatile enum good_test x89;
+const _Thread_local volatile static enum good_test x90;
+const volatile _Thread_local static enum good_test x91;
+_Thread_local volatile static const enum good_test x92;
+_Thread_local volatile const static enum good_test x93;
+volatile _Thread_local static const enum good_test x94;
+volatile _Thread_local const static enum good_test x95;
+volatile const _Thread_local static enum good_test x96;
 
 // define-declares
 // ringing the changes on extern
@@ -145,87 +145,87 @@
 volatile static const enum good_test19 { x_factor19 = 1 } x_19;
 volatile const static enum good_test20 { x_factor20 = 1 } x_20;
 
-// ringing the changes on _Thread_Local extern
-extern _Thread_Local enum good_test21 { x_factor21 = 1 } x_21;
-extern _Thread_Local const enum good_test22 { x_factor22 = 1 } x_22;
-extern _Thread_Local volatile enum good_test23 { x_factor23 = 1 } x_23;
-extern _Thread_Local const volatile enum good_test24 { x_factor24 = 1 } x_24;
-extern _Thread_Local volatile const enum good_test25 { x_factor25 = 1 } x_25;
-_Thread_Local extern enum good_test26 { x_factor26 = 1 } x_26;
-_Thread_Local extern const enum good_test27 { x_factor27 = 1 } x_27;
-_Thread_Local extern volatile enum good_test28 { x_factor28 = 1 } x_28;
-_Thread_Local extern const volatile enum good_test29 { x_factor29 = 1 } x_29;
-_Thread_Local extern volatile const enum good_test30 { x_factor30 = 1 } x_30;
+// ringing the changes on _Thread_local extern
+extern _Thread_local enum good_test21 { x_factor21 = 1 } x_21;
+extern _Thread_local const enum good_test22 { x_factor22 = 1 } x_22;
+extern _Thread_local volatile enum good_test23 { x_factor23 = 1 } x_23;
+extern _Thread_local const volatile enum good_test24 { x_factor24 = 1 } x_24;
+extern _Thread_local volatile const enum good_test25 { x_factor25 = 1 } x_25;
+_Thread_local extern enum good_test26 { x_factor26 = 1 } x_26;
+_Thread_local extern const enum good_test27 { x_factor27 = 1 } x_27;
+_Thread_local extern volatile enum good_test28 { x_factor28 = 1 } x_28;
+_Thread_local extern const volatile enum good_test29 { x_factor29 = 1 } x_29;
+_Thread_local extern volatile const enum good_test30 { x_factor30 = 1 } x_30;
 
-// ringing the changes on _Thread_Local static
-static _Thread_Local enum good_test31 { x_factor31 = 1 } x_31;
-static _Thread_Local const enum good_test32 { x_factor32 = 1 } x_32;
-static _Thread_Local volatile enum good_test33 { x_factor33 = 1 } x_33;
-static _Thread_Local const volatile enum good_test34 { x_factor34 = 1 } x_34;
-static _Thread_Local volatile const enum good_test35 { x_factor35 = 1 } x_35;
-_Thread_Local static enum good_test36 { x_factor36 = 1 } x_36;
-_Thread_Local static const enum good_test37 { x_factor37 = 1 } x_37;
-_Thread_Local static volatile enum good_test38 { x_factor38 = 1 } x_38;
-_Thread_Local static const volatile enum good_test39 { x_factor39 = 1 } x_39;
-_Thread_Local static volatile const enum good_test40 { x_factor40 = 1 } x_40;
+// ringing the changes on _Thread_local static
+static _Thread_local enum good_test31 { x_factor31 = 1 } x_31;
+static _Thread_local const enum good_test32 { x_factor32 = 1 } x_32;
+static _Thread_local volatile enum good_test33 { x_factor33 = 1 } x_33;
+static _Thread_local const volatile enum good_test34 { x_factor34 = 1 } x_34;
+static _Thread_local volatile const enum good_test35 { x_factor35 = 1 } x_35;
+_Thread_local static enum good_test36 { x_factor36 = 1 } x_36;
+_Thread_local static const enum good_test37 { x_factor37 = 1 } x_37;
+_Thread_local static volatile enum good_test38 { x_factor38 = 1 } x_38;
+_Thread_local static const volatile enum good_test39 { x_factor39 = 1 } x_39;
+_Thread_local static volatile const enum good_test40 { x_factor40 = 1 } x_40;
 
-// _Thread_Local extern not in first two postions is deprecated, but legal
-extern const _Thread_Local enum good_test41 { x_factor41 = 1 } x_41;
-const extern _Thread_Local enum good_test42 { x_factor42 = 1 } x_42;
-extern volatile _Thread_Local enum good_test43 { x_factor43 = 1 } x_43;
-volatile extern _Thread_Local enum good_test44 { x_factor44 = 1 } x_44;
-extern const _Thread_Local volatile enum good_test45 { x_factor45 = 1 } x_45;
-extern const volatile _Thread_Local enum good_test46 { x_factor46 = 1 } x_46;
-const extern _Thread_Local volatile enum good_test47 { x_factor47 = 1 } x_47;
-const extern volatile _Thread_Local enum good_test48 { x_factor48 = 1 } x_48;
-const volatile extern _Thread_Local enum good_test49 { x_factor49 = 1 } x_49;
-extern volatile _Thread_Local const enum good_test50 { x_factor50 = 1 } x_50;
-extern volatile const _Thread_Local enum good_test51 { x_factor51 = 1 } x_51;
-volatile extern _Thread_Local const enum good_test52 { x_factor52 = 1 } x_52;
-volatile extern const _Thread_Local enum good_test53 { x_factor53 = 1 } x_53;
-volatile const extern _Thread_Local enum good_test54 { x_factor54 = 1 } x_54;
-_Thread_Local const extern enum good_test55 { x_factor55 = 1 } x_55;
-const _Thread_Local extern enum good_test56 { x_factor56 = 1 } x_56;
-_Thread_Local volatile extern enum good_test57 { x_factor57 = 1 } x_57;
-volatile _Thread_Local extern enum good_test58 { x_factor58 = 1 } x_58;
-_Thread_Local const extern volatile enum good_test59 { x_factor59 = 1 } x_59;
-_Thread_Local const volatile extern enum good_test60 { x_factor60 = 1 } x_60;
-const _Thread_Local extern volatile enum good_test61 { x_factor61 = 1 } x_61;
-const _Thread_Local volatile extern enum good_test62 { x_factor62 = 1 } x_62;
-const volatile _Thread_Local extern enum good_test63 { x_factor63 = 1 } x_63;
-_Thread_Local volatile extern const enum good_test64 { x_factor64 = 1 } x_64;
-_Thread_Local volatile const extern enum good_test65 { x_factor65 = 1 } x_65;
-volatile _Thread_Local extern const enum good_test66 { x_factor66 = 1 } x_66;
-volatile _Thread_Local const extern enum good_test67 { x_factor67 = 1 } x_67;
-volatile const _Thread_Local extern enum good_test68 { x_factor68 = 1 } x_68;
+// _Thread_local extern not in first two postions is deprecated, but legal
+extern const _Thread_local enum good_test41 { x_factor41 = 1 } x_41;
+const extern _Thread_local enum good_test42 { x_factor42 = 1 } x_42;
+extern volatile _Thread_local enum good_test43 { x_factor43 = 1 } x_43;
+volatile extern _Thread_local enum good_test44 { x_factor44 = 1 } x_44;
+extern const _Thread_local volatile enum good_test45 { x_factor45 = 1 } x_45;
+extern const volatile _Thread_local enum good_test46 { x_factor46 = 1 } x_46;
+const extern _Thread_local volatile enum good_test47 { x_factor47 = 1 } x_47;
+const extern volatile _Thread_local enum good_test48 { x_factor48 = 1 } x_48;
+const volatile extern _Thread_local enum good_test49 { x_factor49 = 1 } x_49;
+extern volatile _Thread_local const enum good_test50 { x_factor50 = 1 } x_50;
+extern volatile const _Thread_local enum good_test51 { x_factor51 = 1 } x_51;
+volatile extern _Thread_local const enum good_test52 { x_factor52 = 1 } x_52;
+volatile extern const _Thread_local enum good_test53 { x_factor53 = 1 } x_53;
+volatile const extern _Thread_local enum good_test54 { x_factor54 = 1 } x_54;
+_Thread_local const extern enum good_test55 { x_factor55 = 1 } x_55;
+const _Thread_local extern enum good_test56 { x_factor56 = 1 } x_56;
+_Thread_local volatile extern enum good_test57 { x_factor57 = 1 } x_57;
+volatile _Thread_local extern enum good_test58 { x_factor58 = 1 } x_58;
+_Thread_local const extern volatile enum good_test59 { x_factor59 = 1 } x_59;
+_Thread_local const volatile extern enum good_test60 { x_factor60 = 1 } x_60;
+const _Thread_local extern volatile enum good_test61 { x_factor61 = 1 } x_61;
+const _Thread_local volatile extern enum good_test62 { x_factor62 = 1 } x_62;
+const volatile _Thread_local extern enum good_test63 { x_factor63 = 1 } x_63;
+_Thread_local volatile extern const enum good_test64 { x_factor64 = 1 } x_64;
+_Thread_local volatile const extern enum good_test65 { x_factor65 = 1 } x_65;
+volatile _Thread_local extern const enum good_test66 { x_factor66 = 1 } x_66;
+volatile _Thread_local const extern enum good_test67 { x_factor67 = 1 } x_67;
+volatile const _Thread_local extern enum good_test68 { x_factor68 = 1 } x_68;
 
-// _Thread_Local static not in first two postions is deprecated, but legal
-static const _Thread_Local enum good_test69 { x_factor69 = 1 } x_69;
-const static _Thread_Local enum good_test70 { x_factor70 = 1 } x_70;
-static volatile _Thread_Local enum good_test71 { x_factor71 = 1 } x_71;
-volatile static _Thread_Local enum good_test72 { x_factor72 = 1 } x_72;
-static const _Thread_Local volatile enum good_test73 { x_factor73 = 1 } x_73;
-static const volatile _Thread_Local enum good_test74 { x_factor74 = 1 } x_74;
-const static _Thread_Local volatile enum good_test75 { x_factor75 = 1 } x_75;
-const static volatile _Thread_Local enum good_test76 { x_factor76 = 1 } x_76;
-const volatile static _Thread_Local enum good_test77 { x_factor77 = 1 } x_77;
-static volatile _Thread_Local const enum good_test78 { x_factor78 = 1 } x_78;
-static volatile const _Thread_Local enum good_test79 { x_factor79 = 1 } x_79;
-volatile static _Thread_Local const enum good_test80 { x_factor80 = 1 } x_80;
-volatile static const _Thread_Local enum good_test81 { x_factor81 = 1 } x_81;
-volatile const static _Thread_Local enum good_test82 { x_factor82 = 1 } x_82;
-_Thread_Local const static enum good_test83 { x_factor83 = 1 } x_83;
-const _Thread_Local static enum good_test84 { x_factor84 = 1 } x_84;
-_Thread_Local volatile static enum good_test85 { x_factor85 = 1 } x_85;
-volatile _Thread_Local static enum good_test86 { x_factor86 = 1 } x_86;
-_Thread_Local const static volatile enum good_test87 { x_factor87 = 1 } x_87;
-_Thread_Local const volatile static enum good_test88 { x_factor88 = 1 } x_88;
-const _Thread_Local static volatile enum good_test89 { x_factor89 = 1 } x_89;
-const _Thread_Local volatile static enum good_test90 { x_factor90 = 1 } x_90;
-const volatile _Thread_Local static enum good_test91 { x_factor91 = 1 } x_91;
-_Thread_Local volatile static const enum good_test92 { x_factor92 = 1 } x_92;
-_Thread_Local volatile const static enum good_test93 { x_factor93 = 1 } x_93;
-volatile _Thread_Local static const enum good_test94 { x_factor94 = 1 } x_94;
-volatile _Thread_Local const static enum good_test95 { x_factor95 = 1 } x_95;
-volatile const _Thread_Local static enum good_test96 { x_factor96 = 1 } x_96;
+// _Thread_local static not in first two postions is deprecated, but legal
+static const _Thread_local enum good_test69 { x_factor69 = 1 } x_69;
+const static _Thread_local enum good_test70 { x_factor70 = 1 } x_70;
+static volatile _Thread_local enum good_test71 { x_factor71 = 1 } x_71;
+volatile static _Thread_local enum good_test72 { x_factor72 = 1 } x_72;
+static const _Thread_local volatile enum good_test73 { x_factor73 = 1 } x_73;
+static const volatile _Thread_local enum good_test74 { x_factor74 = 1 } x_74;
+const static _Thread_local volatile enum good_test75 { x_factor75 = 1 } x_75;
+const static volatile _Thread_local enum good_test76 { x_factor76 = 1 } x_76;
+const volatile static _Thread_local enum good_test77 { x_factor77 = 1 } x_77;
+static volatile _Thread_local const enum good_test78 { x_factor78 = 1 } x_78;
+static volatile const _Thread_local enum good_test79 { x_factor79 = 1 } x_79;
+volatile static _Thread_local const enum good_test80 { x_factor80 = 1 } x_80;
+volatile static const _Thread_local enum good_test81 { x_factor81 = 1 } x_81;
+volatile const static _Thread_local enum good_test82 { x_factor82 = 1 } x_82;
+_Thread_local const static enum good_test83 { x_factor83 = 1 } x_83;
+const _Thread_local static enum good_test84 { x_factor84 = 1 } x_84;
+_Thread_local volatile static enum good_test85 { x_factor85 = 1 } x_85;
+volatile _Thread_local static enum good_test86 { x_factor86 = 1 } x_86;
+_Thread_local const static volatile enum good_test87 { x_factor87 = 1 } x_87;
+_Thread_local const volatile static enum good_test88 { x_factor88 = 1 } x_88;
+const _Thread_local static volatile enum good_test89 { x_factor89 = 1 } x_89;
+const _Thread_local volatile static enum good_test90 { x_factor90 = 1 } x_90;
+const volatile _Thread_local static enum good_test91 { x_factor91 = 1 } x_91;
+_Thread_local volatile static const enum good_test92 { x_factor92 = 1 } x_92;
+_Thread_local volatile const static enum good_test93 { x_factor93 = 1 } x_93;
+volatile _Thread_local static const enum good_test94 { x_factor94 = 1 } x_94;
+volatile _Thread_local const static enum good_test95 { x_factor95 = 1 } x_95;
+volatile const _Thread_local static enum good_test96 { x_factor96 = 1 } x_96;
 

Modified: trunk/tests/zcc/decl.C99/Pass_enum_def_decl.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_def_decl.h	2011-06-10 17:46:01 UTC (rev 669)
+++ trunk/tests/zcc/decl.C99/Pass_enum_def_decl.h	2011-06-10 17:47:21 UTC (rev 670)
@@ -33,87 +33,87 @@
 volatile static const enum good_test x19;
 volatile const static enum good_test x20;
 
-// ringing the changes on _Thread_Local extern
-extern _Thread_Local enum good_test x21;
-extern _Thread_Local const enum good_test x22;
-extern _Thread_Local volatile enum good_test x23;
-extern _Thread_Local const volatile enum good_test x24;
-extern _Thread_Local volatile const enum good_test x25;
-_Thread_Local extern enum good_test x26;
-_Thread_Local extern const enum good_test x27;
-_Thread_Local extern volatile enum good_test x28;
-_Thread_Local extern const volatile enum good_test x29;
-_Thread_Local extern volatile const enum good_test x30;
+// ringing the changes on _Thread_local extern
+extern _Thread_local enum good_test x21;
+extern _Thread_local const enum good_test x22;
+extern _Thread_local volatile enum good_test x23;
+extern _Thread_local const volatile enum good_test x24;
+extern _Thread_local volatile const enum good_test x25;
+_Thread_local extern enum good_test x26;
+_Thread_local extern const enum good_test x27;
+_Thread_local extern volatile enum good_test x28;
+_Thread_local extern const volatile enum good_test x29;
+_Thread_local extern volatile const enum good_test x30;
 
-// ringing the changes on _Thread_Local static
-static _Thread_Local enum good_test x31;
-static _Thread_Local const enum good_test x32;
-static _Thread_Local volatile enum good_test x33;
-static _Thread_Local const volatile enum good_test x34;
-static _Thread_Local volatile const enum good_test x35;
-_Thread_Local static enum good_test x36;
-_Thread_Local static const enum good_test x37;
-_Thread_Local static volatile enum good_test x38;
-_Thread_Local static const volatile enum good_test x39;
-_Thread_Local static volatile const enum good_test x40;
+// ringing the changes on _Thread_local static
+static _Thread_local enum good_test x31;
+static _Thread_local const enum good_test x32;
+static _Thread_local volatile enum good_test x33;
+static _Thread_local const volatile enum good_test x34;
+static _Thread_local volatile const enum good_test x35;
+_Thread_local static enum good_test x36;
+_Thread_local static const enum good_test x37;
+_Thread_local static volatile enum good_test x38;
+_Thread_local static const volatile enum good_test x39;
+_Thread_local static volatile const enum good_test x40;
 
-// _Thread_Local extern not in first two postions is deprecated, but legal
-extern const _Thread_Local enum good_test x41;
-const extern _Thread_Local enum good_test x42;
-extern volatile _Thread_Local enum good_test x43;
-volatile extern _Thread_Local enum good_test x44;
-extern const _Thread_Local volatile enum good_test x45;
-extern const volatile _Thread_Local enum good_test x46;
-const extern _Thread_Local volatile enum good_test x47;
-const extern volatile _Thread_Local enum good_test x48;
-const volatile extern _Thread_Local enum good_test x49;
-extern volatile _Thread_Local const enum good_test x50;
-extern volatile const _Thread_Local enum good_test x51;
-volatile extern _Thread_Local const enum good_test x52;
-volatile extern const _Thread_Local enum good_test x53;
-volatile const extern _Thread_Local enum good_test x54;
-_Thread_Local const extern enum good_test x55;
-const _Thread_Local extern enum good_test x56;
-_Thread_Local volatile extern enum good_test x57;
-volatile _Thread_Local extern enum good_test x58;
-_Thread_Local const extern volatile enum good_test x59;
-_Thread_Local const volatile extern enum good_test x60;
-const _Thread_Local extern volatile enum good_test x61;
-const _Thread_Local volatile extern enum good_test x62;
-const volatile _Thread_Local extern enum good_test x63;
-_Thread_Local volatile extern const enum good_test x64;
-_Thread_Local volatile const extern enum good_test x65;
-volatile _Thread_Local extern const enum good_test x66;
-volatile _Thread_Local const extern enum good_test x67;
-volatile const _Thread_Local extern enum good_test x68;
+// _Thread_local extern not in first two postions is deprecated, but legal
+extern const _Thread_local enum good_test x41;
+const extern _Thread_local enum good_test x42;
+extern volatile _Thread_local enum good_test x43;
+volatile extern _Thread_local enum good_test x44;
+extern const _Thread_local volatile enum good_test x45;
+extern const volatile _Thread_local enum good_test x46;
+const extern _Thread_local volatile enum good_test x47;
+const extern volatile _Thread_local enum good_test x48;
+const volatile extern _Thread_local enum good_test x49;
+extern volatile _Thread_local const enum good_test x50;
+extern volatile const _Thread_local enum good_test x51;
+volatile extern _Thread_local const enum good_test x52;
+volatile extern const _Thread_local enum good_test x53;
+volatile const extern _Thread_local enum good_test x54;
+_Thread_local const extern enum good_test x55;
+const _Thread_local extern enum good_test x56;
+_Thread_local volatile extern enum good_test x57;
+volatile _Thread_local extern enum good_test x58;
+_Thread_local const extern volatile enum good_test x59;
+_Thread_local const volatile extern enum good_test x60;
+const _Thread_local extern volatile enum good_test x61;
+const _Thread_local volatile extern enum good_test x62;
+const volatile _Thread_local extern enum good_test x63;
+_Thread_local volatile extern const enum good_test x64;
+_Thread_local volatile const extern enum good_test x65;
+volatile _Thread_local extern const enum good_test x66;
+volatile _Thread_local const extern enum good_test x67;
+volatile const _Thread_local extern enum good_test x68;
 
-// _Thread_Local static not in first two postions is deprecated, but legal
-static const _Thread_Local enum good_test x69;
-const static _Thread_Local enum good_test x70;
-static volatile _Thread_Local enum good_test x71;
-volatile static _Thread_Local enum good_test x72;
-static const _Thread_Local volatile enum good_test x73;
-static const volatile _Thread_Local enum good_test x74;
-const static _Thread_Local volatile enum good_test x75;
-const static volatile _Thread_Local enum good_test x76;
-const volatile static _Thread_Local enum good_test x77;
-static volatile _Thread_Local const enum good_test x78;
-static volatile const _Thread_Local enum good_test x79;
-volatile static _Thread_Local const enum good_test x80;
-volatile static const _Thread_Local enum good_test x81;
-volatile const static _Thread_Local enum good_test x82;
-_Thread_Local const static enum good_test x83;
-const _Thread_Local static enum good_test x84;
-_Thread_Local volatile static enum good_test x85;
-volatile _Thread_Local static enum good_test x86;
-_Thread_Local const static volatile enum good_test x87;
-_Thread_Local const volatile static enum good_test x88;
-const _Thread_Local static volatile enum good_test x89;
-const _Thread_Local volatile static enum good_test x90;
-const volatile _Thread_Local static enum good_test x91;
-_Thread_Local volatile static const enum good_test x92;
-_Thread_Local volatile const static enum good_test x93;
-volatile _Thread_Local static const enum good_test x94;
-volatile _Thread_Local const static enum good_test x95;
-volatile const _Thread_Local static enum good_test x96;
+// _Thread_local static not in first two postions is deprecated, but legal
+static const _Thread_local enum good_test x69;
+const static _Thread_local enum good_test x70;
+static volatile _Thread_local enum good_test x71;
+volatile static _Thread_local enum good_test x72;
+static const _Thread_local volatile enum good_test x73;
+static const volatile _Thread_local enum good_test x74;
+const static _Thread_local volatile enum good_test x75;
+const static volatile _Thread_local enum good_test x76;
+const volatile static _Thread_local enum good_test x77;
+static volatile _Thread_local const enum good_test x78;
+static volatile const _Thread_local enum good_test x79;
+volatile static _Thread_local const enum good_test x80;
+volatile static const _Thread_local enum good_test x81;
+volatile const static _Thread_local enum good_test x82;
+_Thread_local const static enum good_test x83;
+const _Thread_local static enum good_test x84;
+_Thread_local volatile static enum good_test x85;
+volatile _Thread_local static enum good_test x86;
+_Thread_local const static volatile enum good_test x87;
+_Thread_local const volatile static enum good_test x88;
+const _Thread_local static volatile enum good_test x89;
+const _Thread_local volatile static enum good_test x90;
+const volatile _Thread_local static enum good_test x91;
+_Thread_local volatile static const enum good_test x92;
+_Thread_local volatile const static enum good_test x93;
+volatile _Thread_local static const enum good_test x94;
+volatile _Thread_local const static enum good_test x95;
+volatile const _Thread_local static enum good_test x96;
 

Modified: trunk/tests/zcc/decl.C99/Pass_struct_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_struct_def.h	2011-06-10 17:46:01 UTC (rev 669)
+++ trunk/tests/zcc/decl.C99/Pass_struct_def.h	2011-06-10 17:47:21 UTC (rev 670)
@@ -33,89 +33,89 @@
 volatile static const struct good_test x19;
 volatile const static struct good_test x20;
 
-// ringing the changes on _Thread_Local extern
-extern _Thread_Local struct good_test x21;
-extern _Thread_Local const struct good_test x22;
-extern _Thread_Local volatile struct good_test x23;
-extern _Thread_Local const volatile struct good_test x24;
-extern _Thread_Local volatile const struct good_test x25;
-_Thread_Local extern struct good_test x26;
-_Thread_Local extern const struct good_test x27;
-_Thread_Local extern volatile struct good_test x28;
-_Thread_Local extern const volatile struct good_test x29;
-_Thread_Local extern volatile const struct good_test x30;
+// ringing the changes on _Thread_local extern
+extern _Thread_local struct good_test x21;
+extern _Thread_local const struct good_test x22;
+extern _Thread_local volatile struct good_test x23;
+extern _Thread_local const volatile struct good_test x24;
+extern _Thread_local volatile const struct good_test x25;
+_Thread_local extern struct good_test x26;
+_Thread_local extern const struct good_test x27;
+_Thread_local extern volatile struct good_test x28;
+_Thread_local extern const volatile struct good_test x29;
+_Thread_local extern volatile const struct good_test x30;
 
-// ringing the changes on _Thread_Local static
-static _Thread_Local struct good_test x31;
-static _Thread_Local const struct good_test x32;
-static _Thread_Local volatile struct good_test x33;
-static _Thread_Local const volatile struct good_test x34;
-static _Thread_Local volatile const struct good_test x35;
-_Thread_Local static struct good_test x36;
-_Thread_Local static const struct good_test x37;
-_Thread_Local static volatile struct good_test x38;
-_Thread_Local static const volatile struct good_test x39;
-_Thread_Local static volatile const struct good_test x40;
+// ringing the changes on _Thread_local static
+static _Thread_local struct good_test x31;
+static _Thread_local const struct good_test x32;
+static _Thread_local volatile struct good_test x33;
+static _Thread_local const volatile struct good_test x34;
+static _Thread_local volatile const struct good_test x35;
+_Thread_local static struct good_test x36;
+_Thread_local static const struct good_test x37;
+_Thread_local static volatile struct good_test x38;
+_Thread_local static const volatile struct good_test x39;
+_Thread_local static volatile const struct good_test x40;
 
-// _Thread_Local extern not in first two postions is deprecated, but legal
-extern const _Thread_Local struct good_test x41;
-const extern _Thread_Local struct good_test x42;
-extern volatile _Thread_Local struct good_test x43;
-volatile extern _Thread_Local struct good_test x44;
-extern const _Thread_Local volatile struct good_test x45;
-extern const volatile _Thread_Local struct good_test x46;
-const extern _Thread_Local volatile struct good_test x47;
-const extern volatile _Thread_Local struct good_test x48;
-const volatile extern _Thread_Local struct good_test x49;
-extern volatile _Thread_Local const struct good_test x50;
-extern volatile const _Thread_Local struct good_test x51;
-volatile extern _Thread_Local const struct good_test x52;
-volatile extern const _Thread_Local struct good_test x53;
-volatile const extern _Thread_Local struct good_test x54;
-_Thread_Local const extern struct good_test x55;
-const _Thread_Local extern struct good_test x56;
-_Thread_Local volatile extern struct good_test x57;
-volatile _Thread_Local extern struct good_test x58;
-_Thread_Local const extern volatile struct good_test x59;
-_Thread_Local const volatile extern struct good_test x60;
-const _Thread_Local extern volatile struct good_test x61;
-const _Thread_Local volatile extern struct good_test x62;
-const volatile _Thread_Local extern struct good_test x63;
-_Thread_Local volatile extern const struct good_test x64;
-_Thread_Local volatile const extern struct good_test x65;
-volatile _Thread_Local extern const struct good_test x66;
-volatile _Thread_Local const extern struct good_test x67;
-volatile const _Thread_Local extern struct good_test x68;
+// _Thread_local extern not in first two postions is deprecated, but legal
+extern const _Thread_local struct good_test x41;
+const extern _Thread_local struct good_test x42;
+extern volatile _Thread_local struct good_test x43;
+volatile extern _Thread_local struct good_test x44;
+extern const _Thread_local volatile struct good_test x45;
+extern const volatile _Thread_local struct good_test x46;
+const extern _Thread_local volatile struct good_test x47;
+const extern volatile _Thread_local struct good_test x48;
+const volatile extern _Thread_local struct good_test x49;
+extern volatile _Thread_local const struct good_test x50;
+extern volatile const _Thread_local struct good_test x51;
+volatile extern _Thread_local const struct good_test x52;
+volatile extern const _Thread_local struct good_test x53;
+volatile const extern _Thread_local struct good_test x54;
+_Thread_local const extern struct good_test x55;
+const _Thread_local extern struct good_test x56;
+_Thread_local volatile extern struct good_test x57;
+volatile _Thread_local extern struct good_test x58;
+_Thread_local const extern volatile struct good_test x59;
+_Thread_local const volatile extern struct good_test x60;
+const _Thread_local extern volatile struct good_test x61;
+const _Thread_local volatile extern struct good_test x62;
+const volatile _Thread_local extern struct good_test x63;
+_Thread_local volatile extern const struct good_test x64;
+_Thread_local volatile const extern struct good_test x65;
+volatile _Thread_local extern const struct good_test x66;
+volatile _Thread_local const extern struct good_test x67;
+volatile const _Thread_local extern struct good_test x68;
 
-// _Thread_Local static not in first two postions is deprecated, but legal
-static const _Thread_Local struct good_test x69;
-const static _Thread_Local struct good_test x70;
-static volatile _Thread_Local struct good_test x71;
-volatile static _Thread_Local struct good_test x72;
-static const _Thread_Local volatile struct good_test x73;
-static const volatile _Thread_Local struct good_test x74;
-const static _Thread_Local volatile struct good_test x75;
-const static volatile _Thread_Local struct good_test x76;
-const volatile static _Thread_Local struct good_test x77;
-static volatile _Thread_Local const struct good_test x78;
-static volatile const _Thread_Local struct good_test x79;
-volatile static _Thread_Local const struct good_test x80;
-volatile static const _Thread_Local struct good_test x81;
-volatile const static _Thread_Local struct good_test x82;
-_Thread_Local const static struct good_test x83;
-const _Thread_Local static struct good_test x84;
-_Thread_Local volatile static struct good_test x85;
-volatile _Thread_Local static struct good_test x86;
-_Thread_Local const static volatile struct good_test x87;
-_Thread_Local const volatile static struct good_test x88;
-const _Thread_Local static volatile struct good_test x89;
-const _Thread_Local volatile static struct good_test x90;
-const volatile _Thread_Local static struct good_test x91;
-_Thread_Local volatile static const struct good_test x92;
-_Thread_Local volatile const static struct good_test x93;
-volatile _Thread_Local static const struct good_test x94;
-volatile _Thread_Local const static struct good_test x95;
-volatile const _Thread_Local static struct good_test x96;
+// _Thread_local static not in first two postions is deprecated, but legal
+static const _Thread_local struct good_test x69;
+const static _Thread_local struct good_test x70;
+static volatile _Thread_local struct good_test x71;
+volatile static _Thread_local struct good_test x72;
+static const _Thread_local volatile struct good_test x73;
+static const volatile _Thread_local struct good_test x74;
+const static _Thread_local volatile struct good_test x75;
+const static volatile _Thread_local struct good_test x76;
+const volatile static _Thread_local struct good_test x77;
+static volatile _Thread_local const struct good_test x78;
+static volatile const _Thread_local struct good_test x79;
+volatile static _Thread_local const struct good_test x80;
+volatile static const _Thread_local struct good_test x81;
+volatile const static _Thread_local struct good_test x82;
+_Thread_local const static struct good_test x83;
+const _Thread_local static struct good_test x84;
+_Thread_local volatile static struct good_test x85;
+volatile _Thread_local static struct good_test x86;
+_Thread_local const static volatile struct good_test x87;
+_Thread_local const volatile static struct good_test x88;
+const _Thread_local static volatile struct good_test x89;
+const _Thread_local volatile static struct good_test x90;
+const volatile _Thread_local static struct good_test x91;
+_Thread_local volatile static const struct good_test x92;
+_Thread_local volatile const static struct good_test x93;
+volatile _Thread_local static const struct good_test x94;
+volatile _Thread_local const static struct good_test x95;
+volatile const _Thread_local static struct good_test x96;
 
 // define-declares
 // ringing the changes on extern
@@ -145,87 +145,87 @@
 volatile static const struct good_test19 { int x_factor19; } x_19;
 volatile const static struct good_test20 { int x_factor20; } x_20;
 
-// ringing the changes on _Thread_Local extern
-extern _Thread_Local struct good_test21 { int x_factor21; } x_21;
-extern _Thread_Local const struct good_test22 { int x_factor22; } x_22;
-extern _Thread_Local volatile struct good_test23 { int x_factor23; } x_23;
-extern _Thread_Local const volatile struct good_test24 { int x_factor24; } x_24;
-extern _Thread_Local volatile const struct good_test25 { int x_factor25; } x_25;
-_Thread_Local extern struct good_test26 { int x_factor26; } x_26;
-_Thread_Local extern const struct good_test27 { int x_factor27; } x_27;
-_Thread_Local extern volatile struct good_test28 { int x_factor28; } x_28;
-_Thread_Local extern const volatile struct good_test29 { int x_factor29; } x_29;
-_Thread_Local extern volatile const struct good_test30 { int x_factor30; } x_30;
+// ringing the changes on _Thread_local extern
+extern _Thread_local struct good_test21 { int x_factor21; } x_21;
+extern _Thread_local const struct good_test22 { int x_factor22; } x_22;
+extern _Thread_local volatile struct good_test23 { int x_factor23; } x_23;
+extern _Thread_local const volatile struct good_test24 { int x_factor24; } x_24;
+extern _Thread_local volatile const struct good_test25 { int x_factor25; } x_25;
+_Thread_local extern struct good_test26 { int x_factor26; } x_26;
+_Thread_local extern const struct good_test27 { int x_factor27; } x_27;
+_Thread_local extern volatile struct good_test28 { int x_factor28; } x_28;
+_Thread_local extern const volatile struct good_test29 { int x_factor29; } x_29;
+_Thread_local extern volatile const struct good_test30 { int x_factor30; } x_30;
 
-// ringing the changes on _Thread_Local static
-static _Thread_Local struct good_test31 { int x_factor31; } x_31;
-static _Thread_Local const struct good_test32 { int x_factor32; } x_32;
-static _Thread_Local volatile struct good_test33 { int x_factor33; } x_33;
-static _Thread_Local const volatile struct good_test34 { int x_factor34; } x_34;
-static _Thread_Local volatile const struct good_test35 { int x_factor35; } x_35;
-_Thread_Local static struct good_test36 { int x_factor36; } x_36;
-_Thread_Local static const struct good_test37 { int x_factor37; } x_37;
-_Thread_Local static volatile struct good_test38 { int x_factor38; } x_38;
-_Thread_Local static const volatile struct good_test39 { int x_factor39; } x_39;
-_Thread_Local static volatile const struct good_test40 { int x_factor40; } x_40;
+// ringing the changes on _Thread_local static
+static _Thread_local struct good_test31 { int x_factor31; } x_31;
+static _Thread_local const struct good_test32 { int x_factor32; } x_32;
+static _Thread_local volatile struct good_test33 { int x_factor33; } x_33;
+static _Thread_local const volatile struct good_test34 { int x_factor34; } x_34;
+static _Thread_local volatile const struct good_test35 { int x_factor35; } x_35;
+_Thread_local static struct good_test36 { int x_factor36; } x_36;
+_Thread_local static const struct good_test37 { int x_factor37; } x_37;
+_Thread_local static volatile struct good_test38 { int x_factor38; } x_38;
+_Thread_local static const volatile struct good_test39 { int x_factor39; } x_39;
+_Thread_local static volatile const struct good_test40 { int x_factor40; } x_40;
 
-// _Thread_Local extern not in first two postions is deprecated, but legal
-extern const _Thread_Local struct good_test41 { int x_factor41; } x_41;
-const extern _Thread_Local struct good_test42 { int x_factor42; } x_42;
-extern volatile _Thread_Local struct good_test43 { int x_factor43; } x_43;
-volatile extern _Thread_Local struct good_test44 { int x_factor44; } x_44;
-extern const _Thread_Local volatile struct good_test45 { int x_factor45; } x_45;
-extern const volatile _Thread_Local struct good_test46 { int x_factor46; } x_46;
-const extern _Thread_Local volatile struct good_test47 { int x_factor47; } x_47;
-const extern volatile _Thread_Local struct good_test48 { int x_factor48; } x_48;
-const volatile extern _Thread_Local struct good_test49 { int x_factor49; } x_49;
-extern volatile _Thread_Local const struct good_test50 { int x_factor50; } x_50;
-extern volatile const _Thread_Local struct good_test51 { int x_factor51; } x_51;
-volatile extern _Thread_Local const struct good_test52 { int x_factor52; } x_52;
-volatile extern const _Thread_Local struct good_test53 { int x_factor53; } x_53;
-volatile const extern _Thread_Local struct good_test54 { int x_factor54; } x_54;
-_Thread_Local const extern struct good_test55 { int x_factor55; } x_55;
-const _Thread_Local extern struct good_test56 { int x_factor56; } x_56;
-_Thread_Local volatile extern struct good_test57 { int x_factor57; } x_57;
-volatile _Thread_Local extern struct good_test58 { int x_factor58; } x_58;
-_Thread_Local const extern volatile struct good_test59 { int x_factor59; } x_59;
-_Thread_Local const volatile extern struct good_test60 { int x_factor60; } x_60;
-const _Thread_Local extern volatile struct good_test61 { int x_factor61; } x_61;
-const _Thread_Local volatile extern struct good_test62 { int x_factor62; } x_62;
-const volatile _Thread_Local extern struct good_test63 { int x_factor63; } x_63;
-_Thread_Local volatile extern const struct good_test64 { int x_factor64; } x_64;
-_Thread_Local volatile const extern struct good_test65 { int x_factor65; } x_65;
-volatile _Thread_Local extern const struct good_test66 { int x_factor66; } x_66;
-volatile _Thread_Local const extern struct good_test67 { int x_factor67; } x_67;
-volatile const _Thread_Local extern struct good_test68 { int x_factor68; } x_68;
+// _Thread_local extern not in first two postions is deprecated, but legal
+extern const _Thread_local struct good_test41 { int x_factor41; } x_41;
+const extern _Thread_local struct good_test42 { int x_factor42; } x_42;
+extern volatile _Thread_local struct good_test43 { int x_factor43; } x_43;
+volatile extern _Thread_local struct good_test44 { int x_factor44; } x_44;
+extern const _Thread_local volatile struct good_test45 { int x_factor45; } x_45;
+extern const volatile _Thread_local struct good_test46 { int x_factor46; } x_46;
+const extern _Thread_local volatile struct good_test47 { int x_factor47; } x_47;
+const extern volatile _Thread_local struct good_test48 { int x_factor48; } x_48;
+const volatile extern _Thread_local struct good_test49 { int x_factor49; } x_49;
+extern volatile _Thread_local const struct good_test50 { int x_factor50; } x_50;
+extern volatile const _Thread_local struct good_test51 { int x_factor51; } x_51;
+volatile extern _Thread_local const struct good_test52 { int x_factor52; } x_52;
+volatile extern const _Thread_local struct good_test53 { int x_factor53; } x_53;
+volatile const extern _Thread_local struct good_test54 { int x_factor54; } x_54;
+_Thread_local const extern struct good_test55 { int x_factor55; } x_55;
+const _Thread_local extern struct good_test56 { int x_factor56; } x_56;
+_Thread_local volatile extern struct good_test57 { int x_factor57; } x_57;
+volatile _Thread_local extern struct good_test58 { int x_factor58; } x_58;
+_Thread_local const extern volatile struct good_test59 { int x_factor59; } x_59;
+_Thread_local const volatile extern struct good_test60 { int x_factor60; } x_60;
+const _Thread_local extern volatile struct good_test61 { int x_factor61; } x_61;
+const _Thread_local volatile extern struct good_test62 { int x_factor62; } x_62;
+const volatile _Thread_local extern struct good_test63 { int x_factor63; } x_63;
+_Thread_local volatile extern const struct good_test64 { int x_factor64; } x_64;
+_Thread_local volatile const extern struct good_test65 { int x_factor65; } x_65;
+volatile _Thread_local extern const struct good_test66 { int x_factor66; } x_66;
+volatile _Thread_local const extern struct good_test67 { int x_factor67; } x_67;
+volatile const _Thread_local extern struct good_test68 { int x_factor68; } x_68;
 
-// _Thread_Local static not in first two postions is deprecated, but legal
-static const _Thread_Local struct good_test69 { int x_factor69; } x_69;
-const static _Thread_Local struct good_test70 { int x_factor70; } x_70;
-static volatile _Thread_Local struct good_test71 { int x_factor71; } x_71;
-volatile static _Thread_Local struct good_test72 { int x_factor72; } x_72;
-static const _Thread_Local volatile struct good_test73 { int x_factor73; } x_73;
-static const volatile _Thread_Local struct good_test74 { int x_factor74; } x_74;
-const static _Thread_Local volatile struct good_test75 { int x_factor75; } x_75;
-const static volatile _Thread_Local struct good_test76 { int x_factor76; } x_76;
-const volatile static _Thread_Local struct good_test77 { int x_factor77; } x_77;
-static volatile _Thread_Local const struct good_test78 { int x_factor78; } x_78;
-static volatile const _Thread_Local struct good_test79 { int x_factor79; } x_79;
-volatile static _Thread_Local const struct good_test80 { int x_factor80; } x_80;
-volatile static const _Thread_Local struct good_test81 { int x_factor81; } x_81;
-volatile const static _Thread_Local struct good_test82 { int x_factor82; } x_82;
-_Thread_Local const static struct good_test83 { int x_factor83; } x_83;
-const _Thread_Local static struct good_test84 { int x_factor84; } x_84;
-_Thread_Local volatile static struct good_test85 { int x_factor85; } x_85;
-volatile _Thread_Local static struct good_test86 { int x_factor86; } x_86;
-_Thread_Local const static volatile struct good_test87 { int x_factor87; } x_87;
-_Thread_Local const volatile static struct good_test88 { int x_factor88; } x_88;
-const _Thread_Local static volatile struct good_test89 { int x_factor89; } x_89;
-const _Thread_Local volatile static struct good_test90 { int x_factor90; } x_90;
-const volatile _Thread_Local static struct good_test91 { int x_factor91; } x_91;
-_Thread_Local volatile static const struct good_test92 { int x_factor92; } x_92;
-_Thread_Local volatile const static struct good_test93 { int x_factor93; } x_93;
-volatile _Thread_Local static const struct good_test94 { int x_factor94; } x_94;
-volatile _Thread_Local const static struct good_test95 { int x_factor95; } x_95;
-volatile const _Thread_Local static struct good_test96 { int x_factor96; } x_96;
+// _Thread_local static not in first two postions is deprecated, but legal
+static const _Thread_local struct good_test69 { int x_factor69; } x_69;
+const static _Thread_local struct good_test70 { int x_factor70; } x_70;
+static volatile _Thread_local struct good_test71 { int x_factor71; } x_71;
+volatile static _Thread_local struct good_test72 { int x_factor72; } x_72;
+static const _Thread_local volatile struct good_test73 { int x_factor73; } x_73;
+static const volatile _Thread_local struct good_test74 { int x_factor74; } x_74;
+const static _Thread_local volatile struct good_test75 { int x_factor75; } x_75;
+const static volatile _Thread_local struct good_test76 { int x_factor76; } x_76;
+const volatile static _Thread_local struct good_test77 { int x_factor77; } x_77;
+static volatile _Thread_local const struct good_test78 { int x_factor78; } x_78;
+static volatile const _Thread_local struct good_test79 { int x_factor79; } x_79;
+volatile static _Thread_local const struct good_test80 { int x_factor80; } x_80;
+volatile static const _Thread_local struct good_test81 { int x_factor81; } x_81;
+volatile const static _Thread_local struct good_test82 { int x_factor82; } x_82;
+_Thread_local const static struct good_test83 { int x_factor83; } x_83;
+const _Thread_local static struct good_test84 { int x_factor84; } x_84;
+_Thread_local volatile static struct good_test85 { int x_factor85; } x_85;
+volatile _Thread_local static struct good_test86 { int x_factor86; } x_86;
+_Thread_local const static volatile struct good_test87 { int x_factor87; } x_87;
+_Thread_local const volatile static struct good_test88 { int x_factor88; } x_88;
+const _Thread_local static volatile struct good_test89 { int x_factor89; } x_89;
+const _Thread_local volatile static struct good_test90 { int x_factor90; } x_90;
+const volatile _Thread_local static struct good_test91 { int x_factor91; } x_91;
+_Thread_local volatile static const struct good_test92 { int x_factor92; } x_92;
+_Thread_local volatile const static struct good_test93 { int x_factor93; } x_93;
+volatile _Thread_local static const struct good_test94 { int x_factor94; } x_94;
+volatile _Thread_local const static struct good_test95 { int x_factor95; } x_95;
+volatile const _Thread_local static struct good_test96 { int x_factor96; } x_96;
 

Modified: trunk/tests/zcc/decl.C99/Pass_struct_def_decl.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_struct_def_decl.h	2011-06-10 17:46:01 UTC (rev 669)
+++ trunk/tests/zcc/decl.C99/Pass_struct_def_decl.h	2011-06-10 17:47:21 UTC (rev 670)
@@ -33,87 +33,87 @@
 volatile static const struct good_test x19;
 volatile const static struct good_test x20;
 
-// ringing the changes on _Thread_Local extern
-extern _Thread_Local struct good_test x21;
-extern _Thread_Local const struct good_test x22;
-extern _Thread_Local volatile struct good_test x23;
-extern _Thread_Local const volatile struct good_test x24;
-extern _Thread_Local volatile const struct good_test x25;
-_Thread_Local extern struct good_test x26;
-_Thread_Local extern const struct good_test x27;
-_Thread_Local extern volatile struct good_test x28;
-_Thread_Local extern const volatile struct good_test x29;
-_Thread_Local extern volatile const struct good_test x30;
+// ringing the changes on _Thread_local extern
+extern _Thread_local struct good_test x21;
+extern _Thread_local const struct good_test x22;
+extern _Thread_local volatile struct good_test x23;
+extern _Thread_local const volatile struct good_test x24;
+extern _Thread_local volatile const struct good_test x25;
+_Thread_local extern struct good_test x26;
+_Thread_local extern const struct good_test x27;
+_Thread_local extern volatile struct good_test x28;
+_Thread_local extern const volatile struct good_test x29;
+_Thread_local extern volatile const struct good_test x30;
 
-// ringing the changes on _Thread_Local static
-static _Thread_Local struct good_test x31;
-static _Thread_Local const struct good_test x32;
-static _Thread_Local volatile struct good_test x33;
-static _Thread_Local const volatile struct good_test x34;
-static _Thread_Local volatile const struct good_test x35;
-_Thread_Local static struct good_test x36;
-_Thread_Local static const struct good_test x37;
-_Thread_Local static volatile struct good_test x38;
-_Thread_Local static const volatile struct good_test x39;
-_Thread_Local static volatile const struct good_test x40;
+// ringing the changes on _Thread_local static
+static _Thread_local struct good_test x31;
+static _Thread_local const struct good_test x32;
+static _Thread_local volatile struct good_test x33;
+static _Thread_local const volatile struct good_test x34;
+static _Thread_local volatile const struct good_test x35;
+_Thread_local static struct good_test x36;
+_Thread_local static const struct good_test x37;
+_Thread_local static volatile struct good_test x38;
+_Thread_local static const volatile struct good_test x39;
+_Thread_local static volatile const struct good_test x40;
 
-// _Thread_Local extern not in first two postions is deprecated, but legal
-extern const _Thread_Local struct good_test x41;
-const extern _Thread_Local struct good_test x42;
-extern volatile _Thread_Local struct good_test x43;
-volatile extern _Thread_Local struct good_test x44;
-extern const _Thread_Local volatile struct good_test x45;
-extern const volatile _Thread_Local struct good_test x46;
-const extern _Thread_Local volatile struct good_test x47;
-const extern volatile _Thread_Local struct good_test x48;
-const volatile extern _Thread_Local struct good_test x49;
-extern volatile _Thread_Local const struct good_test x50;
-extern volatile const _Thread_Local struct good_test x51;
-volatile extern _Thread_Local const struct good_test x52;
-volatile extern const _Thread_Local struct good_test x53;
-volatile const extern _Thread_Local struct good_test x54;
-_Thread_Local const extern struct good_test x55;
-const _Thread_Local extern struct good_test x56;
-_Thread_Local volatile extern struct good_test x57;
-volatile _Thread_Local extern struct good_test x58;
-_Thread_Local const extern volatile struct good_test x59;
-_Thread_Local const volatile extern struct good_test x60;
-const _Thread_Local extern volatile struct good_test x61;
-const _Thread_Local volatile extern struct good_test x62;
-const volatile _Thread_Local extern struct good_test x63;
-_Thread_Local volatile extern const struct good_test x64;
-_Thread_Local volatile const extern struct good_test x65;
-volatile _Thread_Local extern const struct good_test x66;
-volatile _Thread_Local const extern struct good_test x67;
-volatile const _Thread_Local extern struct good_test x68;
+// _Thread_local extern not in first two postions is deprecated, but legal
+extern const _Thread_local struct good_test x41;
+const extern _Thread_local struct good_test x42;
+extern volatile _Thread_local struct good_test x43;
+volatile extern _Thread_local struct good_test x44;
+extern const _Thread_local volatile struct good_test x45;
+extern const volatile _Thread_local struct good_test x46;
+const extern _Thread_local volatile struct good_test x47;
+const extern volatile _Thread_local struct good_test x48;
+const volatile extern _Thread_local struct good_test x49;
+extern volatile _Thread_local const struct good_test x50;
+extern volatile const _Thread_local struct good_test x51;
+volatile extern _Thread_local const struct good_test x52;
+volatile extern const _Thread_local struct good_test x53;
+volatile const extern _Thread_local struct good_test x54;
+_Thread_local const extern struct good_test x55;
+const _Thread_local extern struct good_test x56;
+_Thread_local volatile extern struct good_test x57;
+volatile _Thread_local extern struct good_test x58;
+_Thread_local const extern volatile struct good_test x59;
+_Thread_local const volatile extern struct good_test x60;
+const _Thread_local extern volatile struct good_test x61;
+const _Thread_local volatile extern struct good_test x62;
+const volatile _Thread_local extern struct good_test x63;
+_Thread_local volatile extern const struct good_test x64;
+_Thread_local volatile const extern struct good_test x65;
+volatile _Thread_local extern const struct good_test x66;
+volatile _Thread_local const extern struct good_test x67;
+volatile const _Thread_local extern struct good_test x68;
 
-// _Thread_Local static not in first two postions is deprecated, but legal
-static const _Thread_Local struct good_test x69;
-const static _Thread_Local struct good_test x70;
-static volatile _Thread_Local struct good_test x71;
-volatile static _Thread_Local struct good_test x72;
-static const _Thread_Local volatile struct good_test x73;
-static const volatile _Thread_Local struct good_test x74;
-const static _Thread_Local volatile struct good_test x75;
-const static volatile _Thread_Local struct good_test x76;
-const volatile static _Thread_Local struct good_test x77;
-static volatile _Thread_Local const struct good_test x78;
-static volatile const _Thread_Local struct good_test x79;
-volatile static _Thread_Local const struct good_test x80;
-volatile static const _Thread_Local struct good_test x81;
-volatile const static _Thread_Local struct good_test x82;
-_Thread_Local const static struct good_test x83;
-const _Thread_Local static struct good_test x84;
-_Thread_Local volatile static struct good_test x85;
-volatile _Thread_Local static struct good_test x86;
-_Thread_Local const static volatile struct good_test x87;
-_Thread_Local const volatile static struct good_test x88;
-const _Thread_Local static volatile struct good_test x89;
-const _Thread_Local volatile static struct good_test x90;
-const volatile _Thread_Local static struct good_test x91;
-_Thread_Local volatile static const struct good_test x92;
-_Thread_Local volatile const static struct good_test x93;
-volatile _Thread_Local static const struct good_test x94;
-volatile _Thread_Local const static struct good_test x95;
-volatile const _Thread_Local static struct good_test x96;
+// _Thread_local static not in first two postions is deprecated, but legal
+static const _Thread_local struct good_test x69;
+const static _Thread_local struct good_test x70;
+static volatile _Thread_local struct good_test x71;
+volatile static _Thread_local struct good_test x72;
+static const _Thread_local volatile struct good_test x73;
+static const volatile _Thread_local struct good_test x74;
+const static _Thread_local volatile struct good_test x75;
+const static volatile _Thread_local struct good_test x76;
+const volatile static _Thread_local struct good_test x77;
+static volatile _Thread_local const struct good_test x78;
+static volatile const _Thread_local struct good_test x79;
+volatile static _Thread_local const struct good_test x80;
+volatile static const _Thread_local struct good_test x81;
+volatile const static _Thread_local struct good_test x82;
+_Thread_local const static struct good_test x83;
+const _Thread_local static struct good_test x84;
+_Thread_local volatile static struct good_test x85;
+volatile _Thread_local static struct good_test x86;
+_Thread_local const static volatile struct good_test x87;
+_Thread_local const volatile static struct good_test x88;
+const _Thread_local static volatile struct good_test x89;
+const _Thread_local volatile static struct good_test x90;
+const volatile _Thread_local static struct good_test x91;
+_Thread_local volatile static const struct good_test x92;
+_Thread_local volatile const static struct good_test x93;
+volatile _Thread_local static const struct good_test x94;
+volatile _Thread_local const static struct good_test x95;
+volatile const _Thread_local static struct good_test x96;
 

Modified: trunk/tests/zcc/decl.C99/Pass_union_def.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_union_def.h	2011-06-10 17:46:01 UTC (rev 669)
+++ trunk/tests/zcc/decl.C99/Pass_union_def.h	2011-06-10 17:47:21 UTC (rev 670)
@@ -33,89 +33,89 @@
 volatile static const union good_test x19;
 volatile const static union good_test x20;
 
-// ringing the changes on _Thread_Local extern
-extern _Thread_Local union good_test x21;
-extern _Thread_Local const union good_test x22;
-extern _Thread_Local volatile union good_test x23;
-extern _Thread_Local const volatile union good_test x24;
-extern _Thread_Local volatile const union good_test x25;
-_Thread_Local extern union good_test x26;
-_Thread_Local extern const union good_test x27;
-_Thread_Local extern volatile union good_test x28;
-_Thread_Local extern const volatile union good_test x29;
-_Thread_Local extern volatile const union good_test x30;
+// ringing the changes on _Thread_local extern
+extern _Thread_local union good_test x21;
+extern _Thread_local const union good_test x22;
+extern _Thread_local volatile union good_test x23;
+extern _Thread_local const volatile union good_test x24;
+extern _Thread_local volatile const union good_test x25;
+_Thread_local extern union good_test x26;
+_Thread_local extern const union good_test x27;
+_Thread_local extern volatile union good_test x28;
+_Thread_local extern const volatile union good_test x29;
+_Thread_local extern volatile const union good_test x30;
 
-// ringing the changes on _Thread_Local static
-static _Thread_Local union good_test x31;
-static _Thread_Local const union good_test x32;
-static _Thread_Local volatile union good_test x33;
-static _Thread_Local const volatile union good_test x34;
-static _Thread_Local volatile const union good_test x35;
-_Thread_Local static union good_test x36;
-_Thread_Local static const union good_test x37;
-_Thread_Local static volatile union good_test x38;
-_Thread_Local static const volatile union good_test x39;
-_Thread_Local static volatile const union good_test x40;
+// ringing the changes on _Thread_local static
+static _Thread_local union good_test x31;
+static _Thread_local const union good_test x32;
+static _Thread_local volatile union good_test x33;
+static _Thread_local const volatile union good_test x34;
+static _Thread_local volatile const union good_test x35;
+_Thread_local static union good_test x36;
+_Thread_local static const union good_test x37;
+_Thread_local static volatile union good_test x38;
+_Thread_local static const volatile union good_test x39;
+_Thread_local static volatile const union good_test x40;
 
-// _Thread_Local extern not in first two postions is deprecated, but legal
-extern const _Thread_Local union good_test x41;
-const extern _Thread_Local union good_test x42;
-extern volatile _Thread_Local union good_test x43;
-volatile extern _Thread_Local union good_test x44;
-extern const _Thread_Local volatile union good_test x45;
-extern const volatile _Thread_Local union good_test x46;
-const extern _Thread_Local volatile union good_test x47;
-const extern volatile _Thread_Local union good_test x48;
-const volatile extern _Thread_Local union good_test x49;
-extern volatile _Thread_Local const union good_test x50;
-extern volatile const _Thread_Local union good_test x51;
-volatile extern _Thread_Local const union good_test x52;
-volatile extern const _Thread_Local union good_test x53;
-volatile const extern _Thread_Local union good_test x54;
-_Thread_Local const extern union good_test x55;
-const _Thread_Local extern union good_test x56;
-_Thread_Local volatile extern union good_test x57;
-volatile _Thread_Local extern union good_test x58;
-_Thread_Local const extern volatile union good_test x59;
-_Thread_Local const volatile extern union good_test x60;
-const _Thread_Local extern volatile union good_test x61;
-const _Thread_Local volatile extern union good_test x62;
-const volatile _Thread_Local extern union good_test x63;
-_Thread_Local volatile extern const union good_test x64;
-_Thread_Local volatile const extern union good_test x65;
-volatile _Thread_Local extern const union good_test x66;
-volatile _Thread_Local const extern union good_test x67;
-volatile const _Thread_Local extern union good_test x68;
+// _Thread_local extern not in first two postions is deprecated, but legal
+extern const _Thread_local union good_test x41;
+const extern _Thread_local union good_test x42;
+extern volatile _Thread_local union good_test x43;
+volatile extern _Thread_local union good_test x44;
+extern const _Thread_local volatile union good_test x45;
+extern const volatile _Thread_local union good_test x46;
+const extern _Thread_local volatile union good_test x47;
+const extern volatile _Thread_local union good_test x48;
+const volatile extern _Thread_local union good_test x49;
+extern volatile _Thread_local const union good_test x50;
+extern volatile const _Thread_local union good_test x51;
+volatile extern _Thread_local const union good_test x52;
+volatile extern const _Thread_local union good_test x53;
+volatile const extern _Thread_local union good_test x54;
+_Thread_local const extern union good_test x55;
+const _Thread_local extern union good_test x56;
+_Thread_local volatile extern union good_test x57;
+volatile _Thread_local extern union good_test x58;
+_Thread_local const extern volatile union good_test x59;
+_Thread_local const volatile extern union good_test x60;
+const _Thread_local extern volatile union good_test x61;
+const _Thread_local volatile extern union good_test x62;
+const volatile _Thread_local extern union good_test x63;
+_Thread_local volatile extern const union good_test x64;
+_Thread_local volatile const extern union good_test x65;
+volatile _Thread_local extern const union good_test x66;
+volatile _Thread_local const extern union good_test x67;
+volatile const _Thread_local extern union good_test x68;
 
-// _Thread_Local static not in first two postions is deprecated, but legal
-static const _Thread_Local union good_test x69;
-const static _Thread_Local union good_test x70;
-static volatile _Thread_Local union good_test x71;
-volatile static _Thread_Local union good_test x72;
-static const _Thread_Local volatile union good_test x73;
-static const volatile _Thread_Local union good_test x74;
-const static _Thread_Local volatile union good_test x75;
-const static volatile _Thread_Local union good_test x76;
-const volatile static _Thread_Local union good_test x77;
-static volatile _Thread_Local const union good_test x78;
-static volatile const _Thread_Local union good_test x79;
-volatile static _Thread_Local const union good_test x80;
-volatile static const _Thread_Local union good_test x81;
-volatile const static _Thread_Local union good_test x82;
-_Thread_Local const static union good_test x83;
-const _Thread_Local static union good_test x84;
-_Thread_Local volatile static union good_test x85;
-volatile _Thread_Local static union good_test x86;
-_Thread_Local const static volatile union good_test x87;
-_Thread_Local const volatile static union good_test x88;
-const _Thread_Local static volatile union good_test x89;
-const _Thread_Local volatile static union good_test x90;
-const volatile _Thread_Local static union good_test x91;
-_Thread_Local volatile static const union good_test x92;
-_Thread_Local volatile const static union good_test x93;
-volatile _Thread_Local static const union good_test x94;
-volatile _Thread_Local const static union good_test x95;
-volatile const _Thread_Local static union good_test x96;
+// _Thread_local static not in first two postions is deprecated, but legal
+static const _Thread_local union good_test x69;
+const static _Thread_local union good_test x70;
+static volatile _Thread_local union good_test x71;
+volatile static _Thread_local union good_test x72;
+static const _Thread_local volatile union good_test x73;
+static const volatile _Thread_local union good_test x74;
+const static _Thread_local volatile union good_test x75;
+const static volatile _Thread_local union good_test x76;
+const volatile static _Thread_local union good_test x77;
+static volatile _Thread_local const union good_test x78;
+static volatile const _Thread_local union good_test x79;
+volatile static _Thread_local const union good_test x80;
+volatile static const _Thread_local union good_test x81;
+volatile const static _Thread_local union good_test x82;
+_Thread_local const static union good_test x83;
+const _Thread_local static union good_test x84;
+_Thread_local volatile static union good_test x85;
+volatile _Thread_local static union good_test x86;
+_Thread_local const static volatile union good_test x87;
+_Thread_local const volatile static union good_test x88;
+const _Thread_local static volatile union good_test x89;
+const _Thread_local volatile static union good_test x90;
+const volatile _Thread_local static union good_test x91;
+_Thread_local volatile static const union good_test x92;
+_Thread_local volatile const static union good_test x93;
+volatile _Thread_local static const union good_test x94;
+volatile _Thread_local const static union good_test x95;
+volatile const _Thread_local static union good_test x96;
 
 // define-declares
 // ringing the changes on extern
@@ -145,87 +145,87 @@
 volatile static const union good_test19 { int x_factor19; } x_19;
 volatile const static union good_test20 { int x_factor20; } x_20;
 
-// ringing the changes on _Thread_Local extern
-extern _Thread_Local union good_test21 { int x_factor21; } x_21;
-extern _Thread_Local const union good_test22 { int x_factor22; } x_22;
-extern _Thread_Local volatile union good_test23 { int x_factor23; } x_23;
-extern _Thread_Local const volatile union good_test24 { int x_factor24; } x_24;
-extern _Thread_Local volatile const union good_test25 { int x_factor25; } x_25;
-_Thread_Local extern union good_test26 { int x_factor26; } x_26;
-_Thread_Local extern const union good_test27 { int x_factor27; } x_27;
-_Thread_Local extern volatile union good_test28 { int x_factor28; } x_28;
-_Thread_Local extern const volatile union good_test29 { int x_factor29; } x_29;
-_Thread_Local extern volatile const union good_test30 { int x_factor30; } x_30;
+// ringing the changes on _Thread_local extern
+extern _Thread_local union good_test21 { int x_factor21; } x_21;
+extern _Thread_local const union good_test22 { int x_factor22; } x_22;
+extern _Thread_local volatile union good_test23 { int x_factor23; } x_23;
+extern _Thread_local const volatile union good_test24 { int x_factor24; } x_24;
+extern _Thread_local volatile const union good_test25 { int x_factor25; } x_25;
+_Thread_local extern union good_test26 { int x_factor26; } x_26;
+_Thread_local extern const union good_test27 { int x_factor27; } x_27;
+_Thread_local extern volatile union good_test28 { int x_factor28; } x_28;
+_Thread_local extern const volatile union good_test29 { int x_factor29; } x_29;
+_Thread_local extern volatile const union good_test30 { int x_factor30; } x_30;
 
-// ringing the changes on _Thread_Local static
-static _Thread_Local union good_test31 { int x_factor31; } x_31;
-static _Thread_Local const union good_test32 { int x_factor32; } x_32;
-static _Thread_Local volatile union good_test33 { int x_factor33; } x_33;
-static _Thread_Local const volatile union good_test34 { int x_factor34; } x_34;
-static _Thread_Local volatile const union good_test35 { int x_factor35; } x_35;
-_Thread_Local static union good_test36 { int x_factor36; } x_36;
-_Thread_Local static const union good_test37 { int x_factor37; } x_37;
-_Thread_Local static volatile union good_test38 { int x_factor38; } x_38;
-_Thread_Local static const volatile union good_test39 { int x_factor39; } x_39;
-_Thread_Local static volatile const union good_test40 { int x_factor40; } x_40;
+// ringing the changes on _Thread_local static
+static _Thread_local union good_test31 { int x_factor31; } x_31;
+static _Thread_local const union good_test32 { int x_factor32; } x_32;
+static _Thread_local volatile union good_test33 { int x_factor33; } x_33;
+static _Thread_local const volatile union good_test34 { int x_factor34; } x_34;
+static _Thread_local volatile const union good_test35 { int x_factor35; } x_35;
+_Thread_local static union good_test36 { int x_factor36; } x_36;
+_Thread_local static const union good_test37 { int x_factor37; } x_37;
+_Thread_local static volatile union good_test38 { int x_factor38; } x_38;
+_Thread_local static const volatile union good_test39 { int x_factor39; } x_39;
+_Thread_local static volatile const union good_test40 { int x_factor40; } x_40;
 
-// _Thread_Local extern not in first two postions is deprecated, but legal
-extern const _Thread_Local union good_test41 { int x_factor41; } x_41;
-const extern _Thread_Local union good_test42 { int x_factor42; } x_42;
-extern volatile _Thread_Local union good_test43 { int x_factor43; } x_43;
-volatile extern _Thread_Local union good_test44 { int x_factor44; } x_44;
-extern const _Thread_Local volatile union good_test45 { int x_factor45; } x_45;
-extern const volatile _Thread_Local union good_test46 { int x_factor46; } x_46;
-const extern _Thread_Local volatile union good_test47 { int x_factor47; } x_47;
-const extern volatile _Thread_Local union good_test48 { int x_factor48; } x_48;
-const volatile extern _Thread_Local union good_test49 { int x_factor49; } x_49;
-extern volatile _Thread_Local const union good_test50 { int x_factor50; } x_50;
-extern volatile const _Thread_Local union good_test51 { int x_factor51; } x_51;
-volatile extern _Thread_Local const union good_test52 { int x_factor52; } x_52;
-volatile extern const _Thread_Local union good_test53 { int x_factor53; } x_53;
-volatile const extern _Thread_Local union good_test54 { int x_factor54; } x_54;
-_Thread_Local const extern union good_test55 { int x_factor55; } x_55;
-const _Thread_Local extern union good_test56 { int x_factor56; } x_56;
-_Thread_Local volatile extern union good_test57 { int x_factor57; } x_57;
-volatile _Thread_Local extern union good_test58 { int x_factor58; } x_58;
-_Thread_Local const extern volatile union good_test59 { int x_factor59; } x_59;
-_Thread_Local const volatile extern union good_test60 { int x_factor60; } x_60;
-const _Thread_Local extern volatile union good_test61 { int x_factor61; } x_61;
-const _Thread_Local volatile extern union good_test62 { int x_factor62; } x_62;
-const volatile _Thread_Local extern union good_test63 { int x_factor63; } x_63;
-_Thread_Local volatile extern const union good_test64 { int x_factor64; } x_64;
-_Thread_Local volatile const extern union good_test65 { int x_factor65; } x_65;
-volatile _Thread_Local extern const union good_test66 { int x_factor66; } x_66;
-volatile _Thread_Local const extern union good_test67 { int x_factor67; } x_67;
-volatile const _Thread_Local extern union good_test68 { int x_factor68; } x_68;
+// _Thread_local extern not in first two postions is deprecated, but legal
+extern const _Thread_local union good_test41 { int x_factor41; } x_41;
+const extern _Thread_local union good_test42 { int x_factor42; } x_42;
+extern volatile _Thread_local union good_test43 { int x_factor43; } x_43;
+volatile extern _Thread_local union good_test44 { int x_factor44; } x_44;
+extern const _Thread_local volatile union good_test45 { int x_factor45; } x_45;
+extern const volatile _Thread_local union good_test46 { int x_factor46; } x_46;
+const extern _Thread_local volatile union good_test47 { int x_factor47; } x_47;
+const extern volatile _Thread_local union good_test48 { int x_factor48; } x_48;
+const volatile extern _Thread_local union good_test49 { int x_factor49; } x_49;
+extern volatile _Thread_local const union good_test50 { int x_factor50; } x_50;
+extern volatile const _Thread_local union good_test51 { int x_factor51; } x_51;
+volatile extern _Thread_local const union good_test52 { int x_factor52; } x_52;
+volatile extern const _Thread_local union good_test53 { int x_factor53; } x_53;
+volatile const extern _Thread_local union good_test54 { int x_factor54; } x_54;
+_Thread_local const extern union good_test55 { int x_factor55; } x_55;
+const _Thread_local extern union good_test56 { int x_factor56; } x_56;
+_Thread_local volatile extern union good_test57 { int x_factor57; } x_57;
+volatile _Thread_local extern union good_test58 { int x_factor58; } x_58;
+_Thread_local const extern volatile union good_test59 { int x_factor59; } x_59;
+_Thread_local const volatile extern union good_test60 { int x_factor60; } x_60;
+const _Thread_local extern volatile union good_test61 { int x_factor61; } x_61;
+const _Thread_local volatile extern union good_test62 { int x_factor62; } x_62;
+const volatile _Thread_local extern union good_test63 { int x_factor63; } x_63;
+_Thread_local volatile extern const union good_test64 { int x_factor64; } x_64;
+_Thread_local volatile const extern union good_test65 { int x_factor65; } x_65;
+volatile _Thread_local extern const union good_test66 { int x_factor66; } x_66;
+volatile _Thread_local const extern union good_test67 { int x_factor67; } x_67;
+volatile const _Thread_local extern union good_test68 { int x_factor68; } x_68;
 
-// _Thread_Local static not in first two postions is deprecated, but legal
-static const _Thread_Local union good_test69 { int x_factor69; } x_69;
-const static _Thread_Local union good_test70 { int x_factor70; } x_70;
-static volatile _Thread_Local union good_test71 { int x_factor71; } x_71;
-volatile static _Thread_Local union good_test72 { int x_factor72; } x_72;
-static const _Thread_Local volatile union good_test73 { int x_factor73; } x_73;
-static const volatile _Thread_Local union good_test74 { int x_factor74; } x_74;
-const static _Thread_Local volatile union good_test75 { int x_factor75; } x_75;
-const static volatile _Thread_Local union good_test76 { int x_factor76; } x_76;
-const volatile static _Thread_Local union good_test77 { int x_factor77; } x_77;
-static volatile _Thread_Local const union good_test78 { int x_factor78; } x_78;
-static volatile const _Thread_Local union good_test79 { int x_factor79; } x_79;
-volatile static _Thread_Local const union good_test80 { int x_factor80; } x_80;
-volatile static const _Thread_Local union good_test81 { int x_factor81; } x_81;
-volatile const static _Thread_Local union good_test82 { int x_factor82; } x_82;
-_Thread_Local const static union good_test83 { int x_factor83; } x_83;
-const _Thread_Local static union good_test84 { int x_factor84; } x_84;
-_Thread_Local volatile static union good_test85 { int x_factor85; } x_85;
-volatile _Thread_Local static union good_test86 { int x_factor86; } x_86;
-_Thread_Local const static volatile union good_test87 { int x_factor87; } x_87;
-_Thread_Local const volatile static union good_test88 { int x_factor88; } x_88;
-const _Thread_Local static volatile union good_test89 { int x_factor89; } x_89;
-const _Thread_Local volatile static union good_test90 { int x_factor90; } x_90;
-const volatile _Thread_Local static union good_test91 { int x_factor91; } x_91;
-_Thread_Local volatile static const union good_test92 { int x_factor92; } x_92;
-_Thread_Local volatile const static union good_test93 { int x_factor93; } x_93;
-volatile _Thread_Local static const union good_test94 { int x_factor94; } x_94;
-volatile _Thread_Local const static union good_test95 { int x_factor95; } x_95;
-volatile const _Thread_Local static union good_test96 { int x_factor96; } x_96;
+// _Thread_local static not in first two postions is deprecated, but legal
+static const _Thread_local union good_test69 { int x_factor69; } x_69;
+const static _Thread_local union good_test70 { int x_factor70; } x_70;
+static volatile _Thread_local union good_test71 { int x_factor71; } x_71;
+volatile static _Thread_local union good_test72 { int x_factor72; } x_72;
+static const _Thread_local volatile union good_test73 { int x_factor73; } x_73;
+static const volatile _Thread_local union good_test74 { int x_factor74; } x_74;
+const static _Thread_local volatile union good_test75 { int x_factor75; } x_75;
+const static volatile _Thread_local union good_test76 { int x_factor76; } x_76;
+const volatile static _Thread_local union good_test77 { int x_factor77; } x_77;
+static volatile _Thread_local const union good_test78 { int x_factor78; } x_78;
+static volatile const _Thread_local union good_test79 { int x_factor79; } x_79;
+volatile static _Thread_local const union good_test80 { int x_factor80; } x_80;
+volatile static const _Thread_local union good_test81 { int x_factor81; } x_81;
+volatile const static _Thread_local union good_test82 { int x_factor82; } x_82;
+_Thread_local const static union good_test83 { int x_factor83; } x_83;
+const _Thread_local static union good_test84 { int x_factor84; } x_84;
+_Thread_local volatile static union good_test85 { int x_factor85; } x_85;
+volatile _Thread_local static union good_test86 { int x_factor86; } x_86;
+_Thread_local const static volatile union good_test87 { int x_factor87; } x_87;
+_Thread_local const volatile static union good_test88 { int x_factor88; } x_88;
+const _Thread_local static volatile union good_test89 { int x_factor89; } x_89;
+const _Thread_local volatile static union good_test90 { int x_factor90; } x_90;
+const volatile _Thread_local static union good_test91 { int x_factor91; } x_91;
+_Thread_local volatile static const union good_test92 { int x_factor92; } x_92;
+_Thread_local volatile const static union good_test93 { int x_factor93; } x_93;
+volatile _Thread_local static const union good_test94 { int x_factor94; } x_94;
+volatile _Thread_local const static union good_test95 { int x_factor95; } x_95;
+volatile const _Thread_local static union good_test96 { int x_factor96; } x_96;
 

Modified: trunk/tests/zcc/decl.C99/Pass_union_def_decl.h
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_union_def_decl.h	2011-06-10 17:46:01 UTC (rev 669)
+++ trunk/tests/zcc/decl.C99/Pass_union_def_decl.h	2011-06-10 17:47:21 UTC (rev 670)
@@ -33,87 +33,87 @@
 volatile static const union good_test x19;
 volatile const static union good_test x20;
 
-// ringing the changes on _Thread_Local extern
-extern _Thread_Local union good_test x21;
-extern _Thread_Local const union good_test x22;
-extern _Thread_Local volatile union good_test x23;
-extern _Thread_Local const volatile union good_test x24;
-extern _Thread_Local volatile const union good_test x25;
-_Thread_Local extern union good_test x26;
-_Thread_Local extern const union good_test x27;
-_Thread_Local extern volatile union good_test x28;
-_Thread_Local extern const volatile union good_test x29;
-_Thread_Local extern volatile const union good_test x30;
+// ringing the changes on _Thread_local extern
+extern _Thread_local union good_test x21;
+extern _Thread_local const union good_test x22;
+extern _Thread_local volatile union good_test x23;
+extern _Thread_local const volatile union good_test x24;
+extern _Thread_local volatile const union good_test x25;
+_Thread_local extern union good_test x26;
+_Thread_local extern const union good_test x27;
+_Thread_local extern volatile union good_test x28;
+_Thread_local extern const volatile union good_test x29;
+_Thread_local extern volatile const union good_test x30;
 
-// ringing the changes on _Thread_Local static
-static _Thread_Local union good_test x31;
-static _Thread_Local const union good_test x32;
-static _Thread_Local volatile union good_test x33;
-static _Thread_Local const volatile union good_test x34;
-static _Thread_Local volatile const union good_test x35;
-_Thread_Local static union good_test x36;
-_Thread_Local static const union good_test x37;
-_Thread_Local static volatile union good_test x38;
-_Thread_Local static const volatile union good_test x39;
-_Thread_Local static volatile const union good_test x40;
+// ringing the changes on _Thread_local static
+static _Thread_local union good_test x31;
+static _Thread_local const union good_test x32;
+static _Thread_local volatile union good_test x33;
+static _Thread_local const volatile union good_test x34;
+static _Thread_local volatile const union good_test x35;
+_Thread_local static union good_test x36;
+_Thread_local static const union good_test x37;
+_Thread_local static volatile union good_test x38;
+_Thread_local static const volatile union good_test x39;
+_Thread_local static volatile const union good_test x40;
 
-// _Thread_Local extern not in first two postions is deprecated, but legal
-extern const _Thread_Local union good_test x41;
-const extern _Thread_Local union good_test x42;
-extern volatile _Thread_Local union good_test x43;
-volatile extern _Thread_Local union good_test x44;
-extern const _Thread_Local volatile union good_test x45;
-extern const volatile _Thread_Local union good_test x46;
-const extern _Thread_Local volatile union good_test x47;
-const extern volatile _Thread_Local union good_test x48;
-const volatile extern _Thread_Local union good_test x49;
-extern volatile _Thread_Local const union good_test x50;
-extern volatile const _Thread_Local union good_test x51;
-volatile extern _Thread_Local const union good_test x52;
-volatile extern const _Thread_Local union good_test x53;
-volatile const extern _Thread_Local union good_test x54;
-_Thread_Local const extern union good_test x55;
-const _Thread_Local extern union good_test x56;
-_Thread_Local volatile extern union good_test x57;
-volatile _Thread_Local extern union good_test x58;
-_Thread_Local const extern volatile union good_test x59;
-_Thread_Local const volatile extern union good_test x60;
-const _Thread_Local extern volatile union good_test x61;
-const _Thread_Local volatile extern union good_test x62;
-const volatile _Thread_Local extern union good_test x63;
-_Thread_Local volatile extern const union good_test x64;
-_Thread_Local volatile const extern union good_test x65;
-volatile _Thread_Local extern const union good_test x66;
-volatile _Thread_Local const extern union good_test x67;
-volatile const _Thread_Local extern union good_test x68;
+// _Thread_local extern not in first two postions is deprecated, but legal
+extern const _Thread_local union good_test x41;
+const extern _Thread_local union good_test x42;
+extern volatile _Thread_local union good_test x43;
+volatile extern _Thread_local union good_test x44;
+extern const _Thread_local volatile union good_test x45;
+extern const volatile _Thread_local union good_test x46;
+const extern _Thread_local volatile union good_test x47;
+const extern volatile _Thread_local union good_test x48;
+const volatile extern _Thread_local union good_test x49;
+extern volatile _Thread_local const union good_test x50;
+extern volatile const _Thread_local union good_test x51;
+volatile extern _Thread_local const union good_test x52;
+volatile extern const _Thread_local union good_test x53;
+volatile const extern _Thread_local union good_test x54;
+_Thread_local const extern union good_test x55;
+const _Thread_local extern union good_test x56;
+_Thread_local volatile extern union good_test x57;
+volatile _Thread_local extern union good_test x58;
+_Thread_local const extern volatile union good_test x59;
+_Thread_local const volatile extern union good_test x60;
+const _Thread_local extern volatile union good_test x61;
+const _Thread_local volatile extern union good_test x62;
+const volatile _Thread_local extern union good_test x63;
+_Thread_local volatile extern const union good_test x64;
+_Thread_local volatile const extern union good_test x65;
+volatile _Thread_local extern const union good_test x66;
+volatile _Thread_local const extern union good_test x67;
+volatile const _Thread_local extern union good_test x68;
 
-// _Thread_Local static not in first two postions is deprecated, but legal
-static const _Thread_Local union good_test x69;
-const static _Thread_Local union good_test x70;
-static volatile _Thread_Local union good_test x71;
-volatile static _Thread_Local union good_test x72;
-static const _Thread_Local volatile union good_test x73;
-static const volatile _Thread_Local union good_test x74;
-const static _Thread_Local volatile union good_test x75;
-const static volatile _Thread_Local union good_test x76;
-const volatile static _Thread_Local union good_test x77;
-static volatile _Thread_Local const union good_test x78;
-static volatile const _Thread_Local union good_test x79;
-volatile static _Thread_Local const union good_test x80;
-volatile static const _Thread_Local union good_test x81;
-volatile const static _Thread_Local union good_test x82;
-_Thread_Local const static union good_test x83;
-const _Thread_Local static union good_test x84;
-_Thread_Local volatile static union good_test x85;
-volatile _Thread_Local static union good_test x86;
-_Thread_Local const static volatile union good_test x87;
-_Thread_Local const volatile static union good_test x88;
-const _Thread_Local static volatile union good_test x89;
-const _Thread_Local volatile static union good_test x90;
-const volatile _Thread_Local static union good_test x91;
-_Thread_Local volatile static const union good_test x92;
-_Thread_Local volatile const static union good_test x93;
-volatile _Thread_Local static const union good_test x94;
-volatile _Thread_Local const static union good_test x95;
-volatile const _Thread_Local static union good_test x96;
+// _Thread_local static not in first two postions is deprecated, but legal
+static const _Thread_local union good_test x69;
+const static _Thread_local union good_test x70;
+static volatile _Thread_local union good_test x71;
+volatile static _Thread_local union good_test x72;
+static const _Thread_local volatile union good_test x73;
+static const volatile _Thread_local union good_test x74;
+const static _Thread_local volatile union good_test x75;
+const static volatile _Thread_local union good_test x76;
+const volatile static _Thread_local union good_test x77;
+static volatile _Thread_local const union good_test x78;
+static volatile const _Thread_local union good_test x79;
+volatile static _Thread_local const union good_test x80;
+volatile static const _Thread_local union good_test x81;
+volatile const static _Thread_local union good_test x82;
+_Thread_local const static union good_test x83;
+const _Thread_local static union good_test x84;
+_Thread_local volatile static union good_test x85;
+volatile _Thread_local static union good_test x86;
+_Thread_local const static volatile union good_test x87;
+_Thread_local const volatile static union good_test x88;
+const _Thread_local static volatile union good_test x89;
+const _Thread_local volatile static union good_test x90;
+const volatile _Thread_local static union good_test x91;
+_Thread_local volatile static const union good_test x92;
+_Thread_local volatile const static union good_test x93;
+volatile _Thread_local static const union good_test x94;
+volatile _Thread_local const static union good_test x95;
+volatile const _Thread_local static union good_test x96;
 



From zaimoni at mail.berlios.de  Fri Jun 10 19:53:33 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 10 Jun 2011 19:53:33 +0200
Subject: [Zcplusplus-commits] r671 - trunk
Message-ID: <20110610175333.CC1D74801AA@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-10 19:53:33 +0200 (Fri, 10 Jun 2011)
New Revision: 671

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/CSupport_pp.cpp
Log:
C keyword is _Thread_local, not _Thread_Local #4/final

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-06-10 17:47:21 UTC (rev 670)
+++ trunk/CSupport.cpp	2011-06-10 17:53:33 UTC (rev 671)
@@ -415,7 +415,7 @@
 static const POD_pair<const char*,size_t> valid_keyword[]
 	=	{	DICT_STRUCT("__asm"),		// reserved to the implementation, so OK to make a keyword for C only
 			DICT_STRUCT("_Static_Assert"),	// C1X keywords not in C++0X
-			DICT_STRUCT("_Thread_Local"),
+			DICT_STRUCT("_Thread_local"),
 			DICT_STRUCT("restrict"),	// C99 keywords not in C++98
 			DICT_STRUCT("_Bool"),
 			DICT_STRUCT("_Complex"),
@@ -912,7 +912,7 @@
 		DICT_STRUCT("extern"),
 		DICT_STRUCT("inline"),
 		DICT_STRUCT("auto"),
-		DICT_STRUCT("_Thread_Local")	// C1X, but in reserved class of identifiers
+		DICT_STRUCT("_Thread_local")	// C1X, but in reserved class of identifiers
 	};
 
 // we implement C++0X, not C++98.  auto as storage specifier is pretty much a waste of source code anyway.
@@ -974,7 +974,7 @@
 		DICT_STRUCT("unsigned"),
 		DICT_STRUCT("_Complex"),
 		DICT_STRUCT("_Bool"),
-		DICT_STRUCT("_Thread_Local"),	// C1X, actually
+		DICT_STRUCT("_Thread_local"),	// C1X, actually
 	};
 
 // we implement C++0X, not C++98.  auto as storage specifier is pretty much a waste of source code anyway.
@@ -10642,7 +10642,7 @@
 		DICT_STRUCT("extern"),
 		DICT_STRUCT("inline"),
 		DICT_STRUCT("auto"),
-		DICT_STRUCT("_Thread_Local"),	// C1X, actually
+		DICT_STRUCT("_Thread_local"),	// C1X, actually
 	};
 
 static const POD_pair<const char*,size_t> CPP0X_nontype_decl_specifier_list[] =
@@ -11879,7 +11879,7 @@
 				specs[storage_count++] = "extern";
 			if (C99_CPP0X_DECLSPEC_THREAD_LOCAL & flags)
 				{
-				specs[storage_count++] = "_Thread_Local";
+				specs[storage_count++] = "_Thread_local";
 				thread_local_compat = ((C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN) & flags);
 				}
 			if (C99_CPP0X_DECLSPEC_REGISTER & flags)
@@ -15912,7 +15912,7 @@
 	assert(C99_CPP_COMPLEX_IDX==linear_find("_Complex",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
 	assert(C99_CPP_COMPLEX_IDX==linear_find("_Complex",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
 	assert(C99_CPP_COMPLEX_IDX==linear_find("_Complex",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
-	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("_Thread_Local",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("_Thread_local",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
 	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("thread_local",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
 	assert(CPP_MUTABLE_IDX==linear_find("mutable",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
 

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-06-10 17:47:21 UTC (rev 670)
+++ trunk/CSupport.cpp.in	2011-06-10 17:53:33 UTC (rev 671)
@@ -440,7 +440,7 @@
 static const POD_pair<const char*,size_t> valid_keyword[]
 	=	{	DICT_STRUCT("__asm"),		// reserved to the implementation, so OK to make a keyword for C only
 			DICT_STRUCT("_Static_Assert"),	// C1X keywords not in C++0X
-			DICT_STRUCT("_Thread_Local"),
+			DICT_STRUCT("_Thread_local"),
 			DICT_STRUCT("restrict"),	// C99 keywords not in C++98
 			DICT_STRUCT("_Bool"),
 			DICT_STRUCT("_Complex"),
@@ -966,7 +966,7 @@
 		DICT_STRUCT("extern"),
 		DICT_STRUCT("inline"),
 		DICT_STRUCT("auto"),
-		DICT_STRUCT("_Thread_Local")	// C1X, but in reserved class of identifiers
+		DICT_STRUCT("_Thread_local")	// C1X, but in reserved class of identifiers
 	};
 
 // we implement C++0X, not C++98.  auto as storage specifier is pretty much a waste of source code anyway.
@@ -1028,7 +1028,7 @@
 		DICT_STRUCT("unsigned"),
 		DICT_STRUCT("_Complex"),
 		DICT_STRUCT("_Bool"),
-		DICT_STRUCT("_Thread_Local"),	// C1X, actually
+		DICT_STRUCT("_Thread_local"),	// C1X, actually
 	};
 
 // we implement C++0X, not C++98.  auto as storage specifier is pretty much a waste of source code anyway.
@@ -10782,7 +10782,7 @@
 		DICT_STRUCT("extern"),
 		DICT_STRUCT("inline"),
 		DICT_STRUCT("auto"),
-		DICT_STRUCT("_Thread_Local"),	// C1X, actually
+		DICT_STRUCT("_Thread_local"),	// C1X, actually
 	};
 
 static const POD_pair<const char*,size_t> CPP0X_nontype_decl_specifier_list[] =
@@ -12027,7 +12027,7 @@
 				specs[storage_count++] = "extern";
 			if (C99_CPP0X_DECLSPEC_THREAD_LOCAL & flags)
 				{
-				specs[storage_count++] = "_Thread_Local";
+				specs[storage_count++] = "_Thread_local";
 				thread_local_compat = ((C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN) & flags);
 				}
 			if (C99_CPP0X_DECLSPEC_REGISTER & flags)
@@ -16066,7 +16066,7 @@
 	assert(C99_CPP_COMPLEX_IDX==linear_find("_Complex",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
 	assert(C99_CPP_COMPLEX_IDX==linear_find("_Complex",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
 	assert(C99_CPP_COMPLEX_IDX==linear_find("_Complex",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
-	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("_Thread_Local",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("_Thread_local",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
 	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("thread_local",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
 	assert(CPP_MUTABLE_IDX==linear_find("mutable",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
 #/*cut-cpp*/

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2011-06-10 17:47:21 UTC (rev 670)
+++ trunk/CSupport_pp.cpp	2011-06-10 17:53:33 UTC (rev 671)
@@ -408,7 +408,7 @@
 static const POD_pair<const char*,size_t> valid_keyword[]
 	=	{	DICT_STRUCT("__asm"),		// reserved to the implementation, so OK to make a keyword for C only
 			DICT_STRUCT("_Static_Assert"),	// C1X keywords not in C++0X
-			DICT_STRUCT("_Thread_Local"),
+			DICT_STRUCT("_Thread_local"),
 			DICT_STRUCT("restrict"),	// C99 keywords not in C++98
 			DICT_STRUCT("_Bool"),
 			DICT_STRUCT("_Complex"),



From zaimoni at mail.berlios.de  Sat Jun 11 03:40:33 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 11 Jun 2011 03:40:33 +0200
Subject: [Zcplusplus-commits] r672 - in trunk/tests/zcc.in:
	default/staticassert staticassert.C1X
Message-ID: <20110611014033.743864803E5@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-11 03:40:33 +0200 (Sat, 11 Jun 2011)
New Revision: 672

Modified:
   trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
Log:
C keyword is _Static_assert not _Static_Assert #1

Modified: trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2011-06-10 17:53:33 UTC (rev 671)
+++ trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2011-06-11 01:40:33 UTC (rev 672)
@@ -1,5 +1,5 @@
 SUFFIXES h hpp
-OBJECTLIKE_MACRO STATIC_ASSERT _Static_Assert static_assert
+OBJECTLIKE_MACRO STATIC_ASSERT _Static_assert static_assert
 // ZCC-specific check on extended constant expressions common to C and C++
 // (C)2010 Kenneth Boyd, license: MIT.txt
 

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2011-06-10 17:53:33 UTC (rev 671)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2011-06-11 01:40:33 UTC (rev 672)
@@ -1,5 +1,5 @@
 SUFFIXES h hpp
-OBJECTLIKE_MACRO STATIC_ASSERT _Static_Assert static_assert
+OBJECTLIKE_MACRO STATIC_ASSERT _Static_assert static_assert
 // (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #include <limits.h>

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2011-06-10 17:53:33 UTC (rev 671)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2011-06-11 01:40:33 UTC (rev 672)
@@ -1,5 +1,5 @@
 SUFFIXES h hpp
-OBJECTLIKE_MACRO STATIC_ASSERT _Static_Assert static_assert
+OBJECTLIKE_MACRO STATIC_ASSERT _Static_assert static_assert
 // (C)2010 Kenneth Boyd, license: MIT.txt
 
 enum test {



From zaimoni at mail.berlios.de  Sat Jun 11 03:41:41 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 11 Jun 2011 03:41:41 +0200
Subject: [Zcplusplus-commits] r673 - in trunk: . tests/cpp/default/keywords
	tests/zcc tests/zcc/default/staticassert tests/zcc/staticassert.C1X
Message-ID: <20110611014141.7B8464803E5@sheep.berlios.de>

Author: zaimoni
Date: 2011-06-11 03:41:41 +0200 (Sat, 11 Jun 2011)
New Revision: 673

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/CSupport_pp.cpp
   trunk/tests/cpp/default/keywords/Error__Thread_Local.h
   trunk/tests/zcc/Pass_stddef_h.h
   trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Error_autofail.h
   trunk/tests/zcc/staticassert.C1X/Error_badarg1.h
   trunk/tests/zcc/staticassert.C1X/Error_badarg2.h
   trunk/tests/zcc/staticassert.C1X/Error_badarg3.h
   trunk/tests/zcc/staticassert.C1X/Error_badarg4.h
   trunk/tests/zcc/staticassert.C1X/Error_badarg5.h
   trunk/tests/zcc/staticassert.C1X/Error_badarg6.h
   trunk/tests/zcc/staticassert.C1X/Error_badarg7.h
   trunk/tests/zcc/staticassert.C1X/Error_scope1.h
   trunk/tests/zcc/staticassert.C1X/Error_scope2.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
Log:
C keyword is _Static_assert not _Static_Assert #2/final

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/CSupport.cpp	2011-06-11 01:41:41 UTC (rev 673)
@@ -414,7 +414,7 @@
 
 static const POD_pair<const char*,size_t> valid_keyword[]
 	=	{	DICT_STRUCT("__asm"),		// reserved to the implementation, so OK to make a keyword for C only
-			DICT_STRUCT("_Static_Assert"),	// C1X keywords not in C++0X
+			DICT_STRUCT("_Static_assert"),	// C1X keywords not in C++0X
 			DICT_STRUCT("_Thread_local"),
 			DICT_STRUCT("restrict"),	// C99 keywords not in C++98
 			DICT_STRUCT("_Bool"),
@@ -13322,8 +13322,8 @@
 		{
 		conserve_tokens(src.c_array<0>()[i]);
 		// C static assertion scanner
-		if (robust_token_is_string<14>(src.data<0>()[i],"_Static_Assert"))
-			{	// _Static_Assert ( constant-expression , string-literal ) ;
+		if (robust_token_is_string<14>(src.data<0>()[i],"_Static_assert"))
+			{	// _Static_assert ( constant-expression , string-literal ) ;
 			C99_CPP_handle_static_assertion(src,*CLexer->pp_support,i,"control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)",NULL);
 			continue;
 			};

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/CSupport.cpp.in	2011-06-11 01:41:41 UTC (rev 673)
@@ -439,7 +439,7 @@
 
 static const POD_pair<const char*,size_t> valid_keyword[]
 	=	{	DICT_STRUCT("__asm"),		// reserved to the implementation, so OK to make a keyword for C only
-			DICT_STRUCT("_Static_Assert"),	// C1X keywords not in C++0X
+			DICT_STRUCT("_Static_assert"),	// C1X keywords not in C++0X
 			DICT_STRUCT("_Thread_local"),
 			DICT_STRUCT("restrict"),	// C99 keywords not in C++98
 			DICT_STRUCT("_Bool"),
@@ -13470,8 +13470,8 @@
 		{
 		conserve_tokens(src.c_array<0>()[i]);
 		// C static assertion scanner
-		if (robust_token_is_string<14>(src.data<0>()[i],"_Static_Assert"))
-			{	// _Static_Assert ( constant-expression , string-literal ) ;
+		if (robust_token_is_string<14>(src.data<0>()[i],"_Static_assert"))
+			{	// _Static_assert ( constant-expression , string-literal ) ;
 			C99_CPP_handle_static_assertion(src,*CLexer->pp_support,i,"control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)",NULL);
 			continue;
 			};

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/CSupport_pp.cpp	2011-06-11 01:41:41 UTC (rev 673)
@@ -407,7 +407,7 @@
 
 static const POD_pair<const char*,size_t> valid_keyword[]
 	=	{	DICT_STRUCT("__asm"),		// reserved to the implementation, so OK to make a keyword for C only
-			DICT_STRUCT("_Static_Assert"),	// C1X keywords not in C++0X
+			DICT_STRUCT("_Static_assert"),	// C1X keywords not in C++0X
 			DICT_STRUCT("_Thread_local"),
 			DICT_STRUCT("restrict"),	// C99 keywords not in C++98
 			DICT_STRUCT("_Bool"),

Modified: trunk/tests/cpp/default/keywords/Error__Thread_Local.h
===================================================================
--- trunk/tests/cpp/default/keywords/Error__Thread_Local.h	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/tests/cpp/default/keywords/Error__Thread_Local.h	2011-06-11 01:41:41 UTC (rev 673)
@@ -1,5 +1,5 @@
 // default\keywords\Error__Thread_Local.h
 // check that #define of _Thread_Local errors
 // (C)2010 Kenneth Boyd, license: MIT.txt
-#define _Thread_Local 1
+#define _Thread_local 1
 #include <stdbool.h>

Modified: trunk/tests/zcc/Pass_stddef_h.h
===================================================================
--- trunk/tests/zcc/Pass_stddef_h.h	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/tests/zcc/Pass_stddef_h.h	2011-06-11 01:41:41 UTC (rev 673)
@@ -118,7 +118,7 @@
 #if 9<=10000*__ZCC__+100*__ZCC_MINOR__+__ZCC_PATCHLEVEL__
 // ZC++ 0.0.9 supports __zcc_linkage
 // typedefs have no linkage in C
-_Static_Assert(0==__zcc_linkage(ptrdiff_t),"ptrdiff_t should be defined with no linkage");
-_Static_Assert(0==__zcc_linkage(size_t),"ptrdiff_t should be defined with no linkage");
-_Static_Assert(0==__zcc_linkage(wchar_t),"wchar_t should be defined with no linkage");
+_Static_assert(0==__zcc_linkage(ptrdiff_t),"ptrdiff_t should be defined with no linkage");
+_Static_assert(0==__zcc_linkage(size_t),"ptrdiff_t should be defined with no linkage");
+_Static_assert(0==__zcc_linkage(wchar_t),"wchar_t should be defined with no linkage");
 #endif

Modified: trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2011-06-11 01:41:41 UTC (rev 673)
@@ -3,34 +3,34 @@
 // (C)2010 Kenneth Boyd, license: MIT.txt
 
 // exercise string literal uses in (extended) integer constant expressions
-_Static_Assert("A","automatic success has failed");
+_Static_assert("A","automatic success has failed");
 
-_Static_Assert("A"[0],"automatic success has failed");
-_Static_Assert(+"A"[0],"automatic success has failed");
-_Static_Assert(-"A"[0],"automatic success has failed");
-_Static_Assert(!"A"[1],"automatic success has failed");
-_Static_Assert(*"A","automatic success has failed");
-_Static_Assert(!*"","automatic success has failed");
+_Static_assert("A"[0],"automatic success has failed");
+_Static_assert(+"A"[0],"automatic success has failed");
+_Static_assert(-"A"[0],"automatic success has failed");
+_Static_assert(!"A"[1],"automatic success has failed");
+_Static_assert(*"A","automatic success has failed");
+_Static_assert(!*"","automatic success has failed");
 
-_Static_Assert("A"+0,"automatic success has failed");
-_Static_Assert(0+"A","automatic success has failed");
-_Static_Assert("A"+1,"automatic success has failed");
-_Static_Assert(1+"A","automatic success has failed");
+_Static_assert("A"+0,"automatic success has failed");
+_Static_assert(0+"A","automatic success has failed");
+_Static_assert("A"+1,"automatic success has failed");
+_Static_assert(1+"A","automatic success has failed");
 
-_Static_Assert("A"-0,"automatic success has failed");
+_Static_assert("A"-0,"automatic success has failed");
 
-_Static_Assert("A"=="A","automatic success has failed");
-_Static_Assert("A"!="B","automatic success has failed");
-_Static_Assert("A"!=0,"automatic success has failed");
-_Static_Assert(0!="B","automatic success has failed");
+_Static_assert("A"=="A","automatic success has failed");
+_Static_assert("A"!="B","automatic success has failed");
+_Static_assert("A"!=0,"automatic success has failed");
+_Static_assert(0!="B","automatic success has failed");
 
-_Static_Assert(1==sizeof "","automatic success has failed");
-_Static_Assert(sizeof ""==1,"automatic success has failed");
-_Static_Assert(2==sizeof "A","automatic success has failed");
-_Static_Assert(sizeof "A"==2,"automatic success has failed");
+_Static_assert(1==sizeof "","automatic success has failed");
+_Static_assert(sizeof ""==1,"automatic success has failed");
+_Static_assert(2==sizeof "A","automatic success has failed");
+_Static_assert(sizeof "A"==2,"automatic success has failed");
 
-_Static_Assert(1==sizeof *"A","automatic success has failed");
-_Static_Assert(sizeof *"A"==1,"automatic success has failed");
-_Static_Assert(1==sizeof *"","automatic success has failed");
-_Static_Assert(sizeof *""==1,"automatic success has failed");
+_Static_assert(1==sizeof *"A","automatic success has failed");
+_Static_assert(sizeof *"A"==1,"automatic success has failed");
+_Static_assert(1==sizeof *"","automatic success has failed");
+_Static_assert(sizeof *""==1,"automatic success has failed");
 

Modified: trunk/tests/zcc/staticassert.C1X/Error_autofail.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_autofail.h	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/tests/zcc/staticassert.C1X/Error_autofail.h	2011-06-11 01:41:41 UTC (rev 673)
@@ -1,5 +1,5 @@
 // tests/zcc/staticassert.C99/Error_autofail.h
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-_Static_Assert(0,"automatic failure");
+_Static_assert(0,"automatic failure");
 

Modified: trunk/tests/zcc/staticassert.C1X/Error_badarg1.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg1.h	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg1.h	2011-06-11 01:41:41 UTC (rev 673)
@@ -1,5 +1,5 @@
 // tests/zcc/staticassert.C99/Error_badarg1.h
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-_Static_Assert();
+_Static_assert();
 

Modified: trunk/tests/zcc/staticassert.C1X/Error_badarg2.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg2.h	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg2.h	2011-06-11 01:41:41 UTC (rev 673)
@@ -1,5 +1,5 @@
 // tests/zcc/staticassert.C99/Error_badarg2.h
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-_Static_Assert(,);
+_Static_assert(,);
 

Modified: trunk/tests/zcc/staticassert.C1X/Error_badarg3.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg3.h	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg3.h	2011-06-11 01:41:41 UTC (rev 673)
@@ -1,5 +1,5 @@
 // tests/zcc/staticassert.C99/Error_badarg3.h
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-_Static_Assert(,"bad form");
+_Static_assert(,"bad form");
 

Modified: trunk/tests/zcc/staticassert.C1X/Error_badarg4.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg4.h	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg4.h	2011-06-11 01:41:41 UTC (rev 673)
@@ -1,5 +1,5 @@
 // tests/zcc/staticassert.C99/Error_badarg4.h
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-_Static_Assert(1,"good form") intercalating junk;
+_Static_assert(1,"good form") intercalating junk;
 

Modified: trunk/tests/zcc/staticassert.C1X/Error_badarg5.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg5.h	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg5.h	2011-06-11 01:41:41 UTC (rev 673)
@@ -1,5 +1,5 @@
 // tests/zcc/staticassert.C99/Error_badarg5.h
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-_Static_Assert;
+_Static_assert;
 

Modified: trunk/tests/zcc/staticassert.C1X/Error_badarg6.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg6.h	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg6.h	2011-06-11 01:41:41 UTC (rev 673)
@@ -1,5 +1,5 @@
 // tests/zcc/staticassert.C99/Error_badarg6.h
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-_Static_Assert(1()"bad form");
+_Static_assert(1()"bad form");
 

Modified: trunk/tests/zcc/staticassert.C1X/Error_badarg7.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg7.h	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg7.h	2011-06-11 01:41:41 UTC (rev 673)
@@ -1,5 +1,5 @@
 // tests/zcc/staticassert.C99/Error_badarg7.h
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-_Static_Assert(1,());
+_Static_assert(1,());
 

Modified: trunk/tests/zcc/staticassert.C1X/Error_scope1.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_scope1.h	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/tests/zcc/staticassert.C1X/Error_scope1.h	2011-06-11 01:41:41 UTC (rev 673)
@@ -1,5 +1,5 @@
 // tests/zcc/staticassert.C99/Error_scope1.h
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-_Static_Assert
+_Static_assert
 

Modified: trunk/tests/zcc/staticassert.C1X/Error_scope2.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_scope2.h	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/tests/zcc/staticassert.C1X/Error_scope2.h	2011-06-11 01:41:41 UTC (rev 673)
@@ -1,5 +1,5 @@
 // tests/zcc/staticassert.C99/Error_scope2.h
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-_Static_Assert(1,"bad form")
+_Static_assert(1,"bad form")
 

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2011-06-11 01:41:41 UTC (rev 673)
@@ -3,247 +3,247 @@
 
 #include <limits.h>
 
-_Static_Assert(1,"automatic success has failed");
+_Static_assert(1,"automatic success has failed");
 
 // check unary +
-_Static_Assert(+1,"automatic success has failed");
-_Static_Assert(+'A',"automatic success has failed");
+_Static_assert(+1,"automatic success has failed");
+_Static_assert(+'A',"automatic success has failed");
 
 // check unary -
-_Static_Assert(-1,"automatic success has failed");
-_Static_Assert(-'A',"automatic success has failed");
+_Static_assert(-1,"automatic success has failed");
+_Static_assert(-'A',"automatic success has failed");
 
 // check unary !
-_Static_Assert(!0,"automatic success has failed");
+_Static_assert(!0,"automatic success has failed");
 
 // check unary ~ (unsigned only, signed is target-specific testing)
-_Static_Assert(~0U,"automatic success has failed");
-_Static_Assert(~0UL,"automatic success has failed");
-_Static_Assert(~0ULL,"automatic success has failed");
-_Static_Assert(~1U,"automatic success has failed");
-_Static_Assert(~1UL,"automatic success has failed");
-_Static_Assert(~1ULL,"automatic success has failed");
-_Static_Assert(!~UINT_MAX,"automatic success has failed");
-_Static_Assert(!~ULONG_MAX,"automatic success has failed");
-_Static_Assert(!~ULLONG_MAX,"automatic success has failed");
+_Static_assert(~0U,"automatic success has failed");
+_Static_assert(~0UL,"automatic success has failed");
+_Static_assert(~0ULL,"automatic success has failed");
+_Static_assert(~1U,"automatic success has failed");
+_Static_assert(~1UL,"automatic success has failed");
+_Static_assert(~1ULL,"automatic success has failed");
+_Static_assert(!~UINT_MAX,"automatic success has failed");
+_Static_assert(!~ULONG_MAX,"automatic success has failed");
+_Static_assert(!~ULLONG_MAX,"automatic success has failed");
 
 // check %
-_Static_Assert(1%2,"automatic success has failed");
-_Static_Assert(!(0%2),"automatic success has failed");
-_Static_Assert(!(1%1),"automatic success has failed");
-_Static_Assert(!(0%1),"automatic success has failed");
+_Static_assert(1%2,"automatic success has failed");
+_Static_assert(!(0%2),"automatic success has failed");
+_Static_assert(!(1%1),"automatic success has failed");
+_Static_assert(!(0%1),"automatic success has failed");
 
 // check /
-_Static_Assert(2/1,"automatic success has failed");
-_Static_Assert(1/1,"automatic success has failed");
-_Static_Assert(!(1/2),"automatic success has failed");
+_Static_assert(2/1,"automatic success has failed");
+_Static_assert(1/1,"automatic success has failed");
+_Static_assert(!(1/2),"automatic success has failed");
 
 // check *
-_Static_Assert(!(0*-1),"automatic success has failed");
-_Static_Assert(!(0*1),"automatic success has failed");
-_Static_Assert(!(0*2),"automatic success has failed");
-_Static_Assert(!(-1*0),"automatic success has failed");
-_Static_Assert(!(1*0),"automatic success has failed");
-_Static_Assert(!(2*0),"automatic success has failed");
-_Static_Assert(-1*-1,"automatic success has failed");
-_Static_Assert(-1*1,"automatic success has failed");
-_Static_Assert(-1*2,"automatic success has failed");
-_Static_Assert(1*-1,"automatic success has failed");
-_Static_Assert(1*1,"automatic success has failed");
-_Static_Assert(1*2,"automatic success has failed");
-_Static_Assert(2*-1,"automatic success has failed");
-_Static_Assert(2*1,"automatic success has failed");
-_Static_Assert(2*2,"automatic success has failed");
+_Static_assert(!(0*-1),"automatic success has failed");
+_Static_assert(!(0*1),"automatic success has failed");
+_Static_assert(!(0*2),"automatic success has failed");
+_Static_assert(!(-1*0),"automatic success has failed");
+_Static_assert(!(1*0),"automatic success has failed");
+_Static_assert(!(2*0),"automatic success has failed");
+_Static_assert(-1*-1,"automatic success has failed");
+_Static_assert(-1*1,"automatic success has failed");
+_Static_assert(-1*2,"automatic success has failed");
+_Static_assert(1*-1,"automatic success has failed");
+_Static_assert(1*1,"automatic success has failed");
+_Static_assert(1*2,"automatic success has failed");
+_Static_assert(2*-1,"automatic success has failed");
+_Static_assert(2*1,"automatic success has failed");
+_Static_assert(2*2,"automatic success has failed");
 
 // check +
-_Static_Assert(-1+-1,"automatic success has failed");
-_Static_Assert(-1+0,"automatic success has failed");
-_Static_Assert(!(-1+1),"automatic success has failed");
-_Static_Assert(0+-1,"automatic success has failed");
-_Static_Assert(!(0+0),"automatic success has failed");
-_Static_Assert(0+1,"automatic success has failed");
-_Static_Assert(!(1+-1),"automatic success has failed");
-_Static_Assert(1+0,"automatic success has failed");
-_Static_Assert(1+1,"automatic success has failed");
+_Static_assert(-1+-1,"automatic success has failed");
+_Static_assert(-1+0,"automatic success has failed");
+_Static_assert(!(-1+1),"automatic success has failed");
+_Static_assert(0+-1,"automatic success has failed");
+_Static_assert(!(0+0),"automatic success has failed");
+_Static_assert(0+1,"automatic success has failed");
+_Static_assert(!(1+-1),"automatic success has failed");
+_Static_assert(1+0,"automatic success has failed");
+_Static_assert(1+1,"automatic success has failed");
 
 // check -
-_Static_Assert(!(-1- -1),"automatic success has failed");
-_Static_Assert(-1-0,"automatic success has failed");
-_Static_Assert(-1-1,"automatic success has failed");
-_Static_Assert(0- -1,"automatic success has failed");
-_Static_Assert(!(0-0),"automatic success has failed");
-_Static_Assert(0-1,"automatic success has failed");
-_Static_Assert(1- -1,"automatic success has failed");
-_Static_Assert(1-0,"automatic success has failed");
-_Static_Assert(!(1-1),"automatic success has failed");
+_Static_assert(!(-1- -1),"automatic success has failed");
+_Static_assert(-1-0,"automatic success has failed");
+_Static_assert(-1-1,"automatic success has failed");
+_Static_assert(0- -1,"automatic success has failed");
+_Static_assert(!(0-0),"automatic success has failed");
+_Static_assert(0-1,"automatic success has failed");
+_Static_assert(1- -1,"automatic success has failed");
+_Static_assert(1-0,"automatic success has failed");
+_Static_assert(!(1-1),"automatic success has failed");
 
 // check <<, >>
-_Static_Assert(!(0<<0),"automatic success has failed");
-_Static_Assert(!(0<<1),"automatic success has failed");
-_Static_Assert(1<<0,"automatic success has failed");
-_Static_Assert(1<<1,"automatic success has failed");
+_Static_assert(!(0<<0),"automatic success has failed");
+_Static_assert(!(0<<1),"automatic success has failed");
+_Static_assert(1<<0,"automatic success has failed");
+_Static_assert(1<<1,"automatic success has failed");
 
 // check <, <=, >=, >
-_Static_Assert(!(-1< -1),"automatic success has failed");
-_Static_Assert(-1<0,"automatic success has failed");
-_Static_Assert(-1<1,"automatic success has failed");
-_Static_Assert(!(0< -1),"automatic success has failed");
-_Static_Assert(!(0<0),"automatic success has failed");
-_Static_Assert(0<1,"automatic success has failed");
-_Static_Assert(!(1< -1),"automatic success has failed");
-_Static_Assert(!(1<0),"automatic success has failed");
-_Static_Assert(!(1<1),"automatic success has failed");
+_Static_assert(!(-1< -1),"automatic success has failed");
+_Static_assert(-1<0,"automatic success has failed");
+_Static_assert(-1<1,"automatic success has failed");
+_Static_assert(!(0< -1),"automatic success has failed");
+_Static_assert(!(0<0),"automatic success has failed");
+_Static_assert(0<1,"automatic success has failed");
+_Static_assert(!(1< -1),"automatic success has failed");
+_Static_assert(!(1<0),"automatic success has failed");
+_Static_assert(!(1<1),"automatic success has failed");
 
-_Static_Assert(-1<= -1,"automatic success has failed");
-_Static_Assert(-1<=0,"automatic success has failed");
-_Static_Assert(-1<=1,"automatic success has failed");
-_Static_Assert(!(0<= -1),"automatic success has failed");
-_Static_Assert(0<=0,"automatic success has failed");
-_Static_Assert(0<=1,"automatic success has failed");
-_Static_Assert(!(1<= -1),"automatic success has failed");
-_Static_Assert(!(1<=0),"automatic success has failed");
-_Static_Assert(1<=1,"automatic success has failed");
+_Static_assert(-1<= -1,"automatic success has failed");
+_Static_assert(-1<=0,"automatic success has failed");
+_Static_assert(-1<=1,"automatic success has failed");
+_Static_assert(!(0<= -1),"automatic success has failed");
+_Static_assert(0<=0,"automatic success has failed");
+_Static_assert(0<=1,"automatic success has failed");
+_Static_assert(!(1<= -1),"automatic success has failed");
+_Static_assert(!(1<=0),"automatic success has failed");
+_Static_assert(1<=1,"automatic success has failed");
 
-_Static_Assert(-1>= -1,"automatic success has failed");
-_Static_Assert(!(-1>=0),"automatic success has failed");
-_Static_Assert(!(-1>=1),"automatic success has failed");
-_Static_Assert(0>= -1,"automatic success has failed");
-_Static_Assert(0>=0,"automatic success has failed");
-_Static_Assert(!(0>=1),"automatic success has failed");
-_Static_Assert(1>= -1,"automatic success has failed");
-_Static_Assert(1>=0,"automatic success has failed");
-_Static_Assert(1>=1,"automatic success has failed");
+_Static_assert(-1>= -1,"automatic success has failed");
+_Static_assert(!(-1>=0),"automatic success has failed");
+_Static_assert(!(-1>=1),"automatic success has failed");
+_Static_assert(0>= -1,"automatic success has failed");
+_Static_assert(0>=0,"automatic success has failed");
+_Static_assert(!(0>=1),"automatic success has failed");
+_Static_assert(1>= -1,"automatic success has failed");
+_Static_assert(1>=0,"automatic success has failed");
+_Static_assert(1>=1,"automatic success has failed");
 
-_Static_Assert(!(-1> -1),"automatic success has failed");
-_Static_Assert(!(-1>0),"automatic success has failed");
-_Static_Assert(!(-1>1),"automatic success has failed");
-_Static_Assert(0> -1,"automatic success has failed");
-_Static_Assert(!(0>0),"automatic success has failed");
-_Static_Assert(!(0>1),"automatic success has failed");
-_Static_Assert(1> -1,"automatic success has failed");
-_Static_Assert(1>0,"automatic success has failed");
-_Static_Assert(!(1>1),"automatic success has failed");
+_Static_assert(!(-1> -1),"automatic success has failed");
+_Static_assert(!(-1>0),"automatic success has failed");
+_Static_assert(!(-1>1),"automatic success has failed");
+_Static_assert(0> -1,"automatic success has failed");
+_Static_assert(!(0>0),"automatic success has failed");
+_Static_assert(!(0>1),"automatic success has failed");
+_Static_assert(1> -1,"automatic success has failed");
+_Static_assert(1>0,"automatic success has failed");
+_Static_assert(!(1>1),"automatic success has failed");
 
 // check ==, !=
-_Static_Assert(-1== -1,"automatic success has failed");
-_Static_Assert(!(-1==0),"automatic success has failed");
-_Static_Assert(!(-1==1),"automatic success has failed");
-_Static_Assert(!(0== -1),"automatic success has failed");
-_Static_Assert(0==0,"automatic success has failed");
-_Static_Assert(!(0==1),"automatic success has failed");
-_Static_Assert(!(1== -1),"automatic success has failed");
-_Static_Assert(!(1==0),"automatic success has failed");
-_Static_Assert(1==1,"automatic success has failed");
+_Static_assert(-1== -1,"automatic success has failed");
+_Static_assert(!(-1==0),"automatic success has failed");
+_Static_assert(!(-1==1),"automatic success has failed");
+_Static_assert(!(0== -1),"automatic success has failed");
+_Static_assert(0==0,"automatic success has failed");
+_Static_assert(!(0==1),"automatic success has failed");
+_Static_assert(!(1== -1),"automatic success has failed");
+_Static_assert(!(1==0),"automatic success has failed");
+_Static_assert(1==1,"automatic success has failed");
 
-_Static_Assert(!(-1!= -1),"automatic success has failed");
-_Static_Assert(-1!=0,"automatic success has failed");
-_Static_Assert(-1!=1,"automatic success has failed");
-_Static_Assert(0!= -1,"automatic success has failed");
-_Static_Assert(!(0!=0),"automatic success has failed");
-_Static_Assert(0!=1,"automatic success has failed");
-_Static_Assert(1!= -1,"automatic success has failed");
-_Static_Assert(1!=0,"automatic success has failed");
-_Static_Assert(!(1!=1),"automatic success has failed");
+_Static_assert(!(-1!= -1),"automatic success has failed");
+_Static_assert(-1!=0,"automatic success has failed");
+_Static_assert(-1!=1,"automatic success has failed");
+_Static_assert(0!= -1,"automatic success has failed");
+_Static_assert(!(0!=0),"automatic success has failed");
+_Static_assert(0!=1,"automatic success has failed");
+_Static_assert(1!= -1,"automatic success has failed");
+_Static_assert(1!=0,"automatic success has failed");
+_Static_assert(!(1!=1),"automatic success has failed");
 
 // check & ^ | 
-_Static_Assert(!(0&0),"automatic success has failed");
-_Static_Assert(!(0&1),"automatic success has failed");
-_Static_Assert(!(1&0),"automatic success has failed");
-_Static_Assert(1&1,"automatic success has failed");
+_Static_assert(!(0&0),"automatic success has failed");
+_Static_assert(!(0&1),"automatic success has failed");
+_Static_assert(!(1&0),"automatic success has failed");
+_Static_assert(1&1,"automatic success has failed");
 
-_Static_Assert(!(0^0),"automatic success has failed");
-_Static_Assert(0^1,"automatic success has failed");
-_Static_Assert(1^0,"automatic success has failed");
-_Static_Assert(!(1^1),"automatic success has failed");
+_Static_assert(!(0^0),"automatic success has failed");
+_Static_assert(0^1,"automatic success has failed");
+_Static_assert(1^0,"automatic success has failed");
+_Static_assert(!(1^1),"automatic success has failed");
 
-_Static_Assert(!(0|0),"automatic success has failed");
-_Static_Assert(0|1,"automatic success has failed");
-_Static_Assert(1|0,"automatic success has failed");
-_Static_Assert(1|1,"automatic success has failed");
+_Static_assert(!(0|0),"automatic success has failed");
+_Static_assert(0|1,"automatic success has failed");
+_Static_assert(1|0,"automatic success has failed");
+_Static_assert(1|1,"automatic success has failed");
 
 // check && ||
-_Static_Assert(-1&& -1,"automatic success has failed");
-_Static_Assert(!(-1&&0),"automatic success has failed");
-_Static_Assert(-1&&1,"automatic success has failed");
-_Static_Assert(!(0&& -1),"automatic success has failed");
-_Static_Assert(!(0&&0),"automatic success has failed");
-_Static_Assert(!(0&&1),"automatic success has failed");
-_Static_Assert(1&& -1,"automatic success has failed");
-_Static_Assert(!(1&&0),"automatic success has failed");
-_Static_Assert(1&&1,"automatic success has failed");
+_Static_assert(-1&& -1,"automatic success has failed");
+_Static_assert(!(-1&&0),"automatic success has failed");
+_Static_assert(-1&&1,"automatic success has failed");
+_Static_assert(!(0&& -1),"automatic success has failed");
+_Static_assert(!(0&&0),"automatic success has failed");
+_Static_assert(!(0&&1),"automatic success has failed");
+_Static_assert(1&& -1,"automatic success has failed");
+_Static_assert(!(1&&0),"automatic success has failed");
+_Static_assert(1&&1,"automatic success has failed");
 
-_Static_Assert(-1|| -1,"automatic success has failed");
-_Static_Assert(-1||0,"automatic success has failed");
-_Static_Assert(-1||1,"automatic success has failed");
-_Static_Assert(0|| -1,"automatic success has failed");
-_Static_Assert(!(0||0),"automatic success has failed");
-_Static_Assert(0||1,"automatic success has failed");
-_Static_Assert(1|| -1,"automatic success has failed");
-_Static_Assert(1||0,"automatic success has failed");
-_Static_Assert(1||1,"automatic success has failed");
+_Static_assert(-1|| -1,"automatic success has failed");
+_Static_assert(-1||0,"automatic success has failed");
+_Static_assert(-1||1,"automatic success has failed");
+_Static_assert(0|| -1,"automatic success has failed");
+_Static_assert(!(0||0),"automatic success has failed");
+_Static_assert(0||1,"automatic success has failed");
+_Static_assert(1|| -1,"automatic success has failed");
+_Static_assert(1||0,"automatic success has failed");
+_Static_assert(1||1,"automatic success has failed");
 
 // check ? :
-_Static_Assert(-1 ? -1 : -1,"automatic success has failed");
-_Static_Assert(-1 ? -1 : 0,"automatic success has failed");
-_Static_Assert(-1 ? -1 : 1,"automatic success has failed");
-_Static_Assert(!(-1 ? 0 : -1),"automatic success has failed");
-_Static_Assert(!(-1 ? 0 : 0),"automatic success has failed");
-_Static_Assert(!(-1 ? 0 : 1),"automatic success has failed");
-_Static_Assert(-1 ? 1 : -1,"automatic success has failed");
-_Static_Assert(-1 ? 1 : 0,"automatic success has failed");
-_Static_Assert(-1 ? 1 : 1,"automatic success has failed");
-_Static_Assert(0 ? -1 : -1,"automatic success has failed");
-_Static_Assert(!(0 ? -1 : 0),"automatic success has failed");
-_Static_Assert(0 ? -1 : 1,"automatic success has failed");
-_Static_Assert(0 ? 0 : -1,"automatic success has failed");
-_Static_Assert(!(0 ? 0 : 0),"automatic success has failed");
-_Static_Assert(0 ? 0 : 1,"automatic success has failed");
-_Static_Assert(0 ? 1 : -1,"automatic success has failed");
-_Static_Assert(!(0 ? 1 : 0),"automatic success has failed");
-_Static_Assert(0 ? 1 : 1,"automatic success has failed");
-_Static_Assert(1 ? -1 : -1,"automatic success has failed");
-_Static_Assert(1 ? -1 : 0,"automatic success has failed");
-_Static_Assert(1 ? -1 : 1,"automatic success has failed");
-_Static_Assert(!(1 ? 0 : -1),"automatic success has failed");
-_Static_Assert(!(1 ? 0 : 0),"automatic success has failed");
-_Static_Assert(!(1 ? 0 : 1),"automatic success has failed");
-_Static_Assert(1 ? 1 : -1,"automatic success has failed");
-_Static_Assert(1 ? 1 : 0,"automatic success has failed");
-_Static_Assert(1 ? 1 : 1,"automatic success has failed");
+_Static_assert(-1 ? -1 : -1,"automatic success has failed");
+_Static_assert(-1 ? -1 : 0,"automatic success has failed");
+_Static_assert(-1 ? -1 : 1,"automatic success has failed");
+_Static_assert(!(-1 ? 0 : -1),"automatic success has failed");
+_Static_assert(!(-1 ? 0 : 0),"automatic success has failed");
+_Static_assert(!(-1 ? 0 : 1),"automatic success has failed");
+_Static_assert(-1 ? 1 : -1,"automatic success has failed");
+_Static_assert(-1 ? 1 : 0,"automatic success has failed");
+_Static_assert(-1 ? 1 : 1,"automatic success has failed");
+_Static_assert(0 ? -1 : -1,"automatic success has failed");
+_Static_assert(!(0 ? -1 : 0),"automatic success has failed");
+_Static_assert(0 ? -1 : 1,"automatic success has failed");
+_Static_assert(0 ? 0 : -1,"automatic success has failed");
+_Static_assert(!(0 ? 0 : 0),"automatic success has failed");
+_Static_assert(0 ? 0 : 1,"automatic success has failed");
+_Static_assert(0 ? 1 : -1,"automatic success has failed");
+_Static_assert(!(0 ? 1 : 0),"automatic success has failed");
+_Static_assert(0 ? 1 : 1,"automatic success has failed");
+_Static_assert(1 ? -1 : -1,"automatic success has failed");
+_Static_assert(1 ? -1 : 0,"automatic success has failed");
+_Static_assert(1 ? -1 : 1,"automatic success has failed");
+_Static_assert(!(1 ? 0 : -1),"automatic success has failed");
+_Static_assert(!(1 ? 0 : 0),"automatic success has failed");
+_Static_assert(!(1 ? 0 : 1),"automatic success has failed");
+_Static_assert(1 ? 1 : -1,"automatic success has failed");
+_Static_assert(1 ? 1 : 0,"automatic success has failed");
+_Static_assert(1 ? 1 : 1,"automatic success has failed");
 
 // check sizeof: sizeof(char)==1 and so on
-_Static_Assert(1==sizeof 'A',"automatic success has failed");
-_Static_Assert(1==sizeof(char),"automatic success has failed");
-_Static_Assert(1==sizeof(signed char),"automatic success has failed");
-_Static_Assert(1==sizeof(unsigned char),"automatic success has failed");
+_Static_assert(1==sizeof 'A',"automatic success has failed");
+_Static_assert(1==sizeof(char),"automatic success has failed");
+_Static_assert(1==sizeof(signed char),"automatic success has failed");
+_Static_assert(1==sizeof(unsigned char),"automatic success has failed");
 
-_Static_Assert(sizeof 'A'==1,"automatic success has failed");
-_Static_Assert(sizeof(char)==1,"automatic success has failed");
-_Static_Assert(sizeof(signed char)==1,"automatic success has failed");
-_Static_Assert(sizeof(unsigned char)==1,"automatic success has failed");
+_Static_assert(sizeof 'A'==1,"automatic success has failed");
+_Static_assert(sizeof(char)==1,"automatic success has failed");
+_Static_assert(sizeof(signed char)==1,"automatic success has failed");
+_Static_assert(sizeof(unsigned char)==1,"automatic success has failed");
 
 // other target-independent reality checks on sizeof
-_Static_Assert(sizeof(short),"automatic success has failed");
-_Static_Assert(sizeof(signed short),"automatic success has failed");
-_Static_Assert(sizeof(unsigned short),"automatic success has failed");
+_Static_assert(sizeof(short),"automatic success has failed");
+_Static_assert(sizeof(signed short),"automatic success has failed");
+_Static_assert(sizeof(unsigned short),"automatic success has failed");
 
-_Static_Assert(sizeof(int),"automatic success has failed");
-_Static_Assert(sizeof(signed int),"automatic success has failed");
-_Static_Assert(sizeof(unsigned int),"automatic success has failed");
-_Static_Assert(sizeof(signed),"automatic success has failed");
-_Static_Assert(sizeof(unsigned),"automatic success has failed");
+_Static_assert(sizeof(int),"automatic success has failed");
+_Static_assert(sizeof(signed int),"automatic success has failed");
+_Static_assert(sizeof(unsigned int),"automatic success has failed");
+_Static_assert(sizeof(signed),"automatic success has failed");
+_Static_assert(sizeof(unsigned),"automatic success has failed");
 
-_Static_Assert(sizeof(long),"automatic success has failed");
-_Static_Assert(sizeof(signed long),"automatic success has failed");
-_Static_Assert(sizeof(unsigned long),"automatic success has failed");
-_Static_Assert(sizeof(long int),"automatic success has failed");
-_Static_Assert(sizeof(signed long int),"automatic success has failed");
-_Static_Assert(sizeof(unsigned long int),"automatic success has failed");
+_Static_assert(sizeof(long),"automatic success has failed");
+_Static_assert(sizeof(signed long),"automatic success has failed");
+_Static_assert(sizeof(unsigned long),"automatic success has failed");
+_Static_assert(sizeof(long int),"automatic success has failed");
+_Static_assert(sizeof(signed long int),"automatic success has failed");
+_Static_assert(sizeof(unsigned long int),"automatic success has failed");
 
-_Static_Assert(sizeof(long long),"automatic success has failed");
-_Static_Assert(sizeof(signed long long),"automatic success has failed");
-_Static_Assert(sizeof(unsigned long long),"automatic success has failed");
-_Static_Assert(sizeof(long long int),"automatic success has failed");
-_Static_Assert(sizeof(signed long long int),"automatic success has failed");
-_Static_Assert(sizeof(unsigned long long int),"automatic success has failed");
+_Static_assert(sizeof(long long),"automatic success has failed");
+_Static_assert(sizeof(signed long long),"automatic success has failed");
+_Static_assert(sizeof(unsigned long long),"automatic success has failed");
+_Static_assert(sizeof(long long int),"automatic success has failed");
+_Static_assert(sizeof(signed long long int),"automatic success has failed");
+_Static_assert(sizeof(unsigned long long int),"automatic success has failed");
 

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2011-06-11 01:40:33 UTC (rev 672)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2011-06-11 01:41:41 UTC (rev 673)
@@ -8,201 +8,201 @@
 	two
 };
 
-_Static_Assert(neg_one,"automatic success has failed");
-_Static_Assert(one,"automatic success has failed");
+_Static_assert(neg_one,"automatic success has failed");
+_Static_assert(one,"automatic success has failed");
 
 // check unary +
-_Static_Assert(+neg_one,"automatic success has failed");
-_Static_Assert(+one,"automatic success has failed");
+_Static_assert(+neg_one,"automatic success has failed");
+_Static_assert(+one,"automatic success has failed");
 
 // check unary -
-_Static_Assert(-neg_one,"automatic success has failed");
-_Static_Assert(-one,"automatic success has failed");
+_Static_assert(-neg_one,"automatic success has failed");
+_Static_assert(-one,"automatic success has failed");
 
 // check unary !
-_Static_Assert(!zero,"automatic success has failed");
+_Static_assert(!zero,"automatic success has failed");
 
 // check %
-_Static_Assert(one%two,"automatic success has failed");
-_Static_Assert(!(zero%two),"automatic success has failed");
-_Static_Assert(!(one%one),"automatic success has failed");
-_Static_Assert(!(zero%one),"automatic success has failed");
+_Static_assert(one%two,"automatic success has failed");
+_Static_assert(!(zero%two),"automatic success has failed");
+_Static_assert(!(one%one),"automatic success has failed");
+_Static_assert(!(zero%one),"automatic success has failed");
 
 // check /
-_Static_Assert(two/one,"automatic success has failed");
-_Static_Assert(one/one,"automatic success has failed");
-_Static_Assert(!(one/two),"automatic success has failed");
+_Static_assert(two/one,"automatic success has failed");
+_Static_assert(one/one,"automatic success has failed");
+_Static_assert(!(one/two),"automatic success has failed");
 
 // check *
-_Static_Assert(!(zero*neg_one),"automatic success has failed");
-_Static_Assert(!(zero*one),"automatic success has failed");
-_Static_Assert(!(zero*two),"automatic success has failed");
-_Static_Assert(!(neg_one*zero),"automatic success has failed");
-_Static_Assert(!(one*zero),"automatic success has failed");
-_Static_Assert(!(two*zero),"automatic success has failed");
-_Static_Assert(neg_one*neg_one,"automatic success has failed");
-_Static_Assert(neg_one*one,"automatic success has failed");
-_Static_Assert(neg_one*two,"automatic success has failed");
-_Static_Assert(one*neg_one,"automatic success has failed");
-_Static_Assert(one*one,"automatic success has failed");
-_Static_Assert(one*two,"automatic success has failed");
-_Static_Assert(two*neg_one,"automatic success has failed");
-_Static_Assert(two*one,"automatic success has failed");
-_Static_Assert(two*two,"automatic success has failed");
+_Static_assert(!(zero*neg_one),"automatic success has failed");
+_Static_assert(!(zero*one),"automatic success has failed");
+_Static_assert(!(zero*two),"automatic success has failed");
+_Static_assert(!(neg_one*zero),"automatic success has failed");
+_Static_assert(!(one*zero),"automatic success has failed");
+_Static_assert(!(two*zero),"automatic success has failed");
+_Static_assert(neg_one*neg_one,"automatic success has failed");
+_Static_assert(neg_one*one,"automatic success has failed");
+_Static_assert(neg_one*two,"automatic success has failed");
+_Static_assert(one*neg_one,"automatic success has failed");
+_Static_assert(one*one,"automatic success has failed");
+_Static_assert(one*two,"automatic success has failed");
+_Static_assert(two*neg_one,"automatic success has failed");
+_Static_assert(two*one,"automatic success has failed");
+_Static_assert(two*two,"automatic success has failed");
 
 // check +
-_Static_Assert(neg_one+neg_one,"automatic success has failed");
-_Static_Assert(neg_one+zero,"automatic success has failed");
-_Static_Assert(!(neg_one+one),"automatic success has failed");
-_Static_Assert(zero+neg_one,"automatic success has failed");
-_Static_Assert(!(zero+zero),"automatic success has failed");
-_Static_Assert(zero+one,"automatic success has failed");
-_Static_Assert(!(one+neg_one),"automatic success has failed");
-_Static_Assert(one+zero,"automatic success has failed");
-_Static_Assert(one+one,"automatic success has failed");
+_Static_assert(neg_one+neg_one,"automatic success has failed");
+_Static_assert(neg_one+zero,"automatic success has failed");
+_Static_assert(!(neg_one+one),"automatic success has failed");
+_Static_assert(zero+neg_one,"automatic success has failed");
+_Static_assert(!(zero+zero),"automatic success has failed");
+_Static_assert(zero+one,"automatic success has failed");
+_Static_assert(!(one+neg_one),"automatic success has failed");
+_Static_assert(one+zero,"automatic success has failed");
+_Static_assert(one+one,"automatic success has failed");
 
 // check -
-_Static_Assert(!(neg_one-neg_one),"automatic success has failed");
-_Static_Assert(neg_one-zero,"automatic success has failed");
-_Static_Assert(neg_one-one,"automatic success has failed");
-_Static_Assert(zero-neg_one,"automatic success has failed");
-_Static_Assert(!(zero-zero),"automatic success has failed");
-_Static_Assert(zero-one,"automatic success has failed");
-_Static_Assert(one-neg_one,"automatic success has failed");
-_Static_Assert(one-zero,"automatic success has failed");
-_Static_Assert(!(one-one),"automatic success has failed");
+_Static_assert(!(neg_one-neg_one),"automatic success has failed");
+_Static_assert(neg_one-zero,"automatic success has failed");
+_Static_assert(neg_one-one,"automatic success has failed");
+_Static_assert(zero-neg_one,"automatic success has failed");
+_Static_assert(!(zero-zero),"automatic success has failed");
+_Static_assert(zero-one,"automatic success has failed");
+_Static_assert(one-neg_one,"automatic success has failed");
+_Static_assert(one-zero,"automatic success has failed");
+_Static_assert(!(one-one),"automatic success has failed");
 
 // check <<, >>
-_Static_Assert(!(zero<<zero),"automatic success has failed");
-_Static_Assert(!(zero<<one),"automatic success has failed");
-_Static_Assert(one<<zero,"automatic success has failed");
-_Static_Assert(one<<one,"automatic success has failed");
+_Static_assert(!(zero<<zero),"automatic success has failed");
+_Static_assert(!(zero<<one),"automatic success has failed");
+_Static_assert(one<<zero,"automatic success has failed");
+_Static_assert(one<<one,"automatic success has failed");
 
 // check <, <=, >=, >
-_Static_Assert(!(neg_one<neg_one),"automatic success has failed");
-_Static_Assert(neg_one<zero,"automatic success has failed");
-_Static_Assert(neg_one<one,"automatic success has failed");
-_Static_Assert(!(zero<neg_one),"automatic success has failed");
-_Static_Assert(!(zero<zero),"automatic success has failed");
-_Static_Assert(zero<one,"automatic success has failed");
-_Static_Assert(!(one<neg_one),"automatic success has failed");
-_Static_Assert(!(one<zero),"automatic success has failed");
-_Static_Assert(!(one<one),"automatic success has failed");
+_Static_assert(!(neg_one<neg_one),"automatic success has failed");
+_Static_assert(neg_one<zero,"automatic success has failed");
+_Static_assert(neg_one<one,"automatic success has failed");
+_Static_assert(!(zero<neg_one),"automatic success has failed");
+_Static_assert(!(zero<zero),"automatic success has failed");
+_Static_assert(zero<one,"automatic success has failed");
+_Static_assert(!(one<neg_one),"automatic success has failed");
+_Static_assert(!(one<zero),"automatic success has failed");
+_Static_assert(!(one<one),"automatic success has failed");
 
-_Static_Assert(neg_one<=neg_one,"automatic success has failed");
-_Static_Assert(neg_one<=zero,"automatic success has failed");
-_Static_Assert(neg_one<=one,"automatic success has failed");
-_Static_Assert(!(zero<=neg_one),"automatic success has failed");
-_Static_Assert(zero<=zero,"automatic success has failed");
-_Static_Assert(zero<=one,"automatic success has failed");
-_Static_Assert(!(one<=neg_one),"automatic success has failed");
-_Static_Assert(!(one<=zero),"automatic success has failed");
-_Static_Assert(one<=one,"automatic success has failed");
+_Static_assert(neg_one<=neg_one,"automatic success has failed");
+_Static_assert(neg_one<=zero,"automatic success has failed");
+_Static_assert(neg_one<=one,"automatic success has failed");
+_Static_assert(!(zero<=neg_one),"automatic success has failed");
+_Static_assert(zero<=zero,"automatic success has failed");
+_Static_assert(zero<=one,"automatic success has failed");
+_Static_assert(!(one<=neg_one),"automatic success has failed");
+_Static_assert(!(one<=zero),"automatic success has failed");
+_Static_assert(one<=one,"automatic success has failed");
 
-_Static_Assert(neg_one>=neg_one,"automatic success has failed");
-_Static_Assert(!(neg_one>=zero),"automatic success has failed");
-_Static_Assert(!(neg_one>=one),"automatic success has failed");
-_Static_Assert(zero>=neg_one,"automatic success has failed");
-_Static_Assert(zero>=zero,"automatic success has failed");
-_Static_Assert(!(zero>=one),"automatic success has failed");
-_Static_Assert(one>=neg_one,"automatic success has failed");
-_Static_Assert(one>=zero,"automatic success has failed");
-_Static_Assert(one>=one,"automatic success has failed");
+_Static_assert(neg_one>=neg_one,"automatic success has failed");
+_Static_assert(!(neg_one>=zero),"automatic success has failed");
+_Static_assert(!(neg_one>=one),"automatic success has failed");
+_Static_assert(zero>=neg_one,"automatic success has failed");
+_Static_assert(zero>=zero,"automatic success has failed");
+_Static_assert(!(zero>=one),"automatic success has failed");
+_Static_assert(one>=neg_one,"automatic success has failed");
+_Static_assert(one>=zero,"automatic success has failed");
+_Static_assert(one>=one,"automatic success has failed");
 
-_Static_Assert(!(neg_one>neg_one),"automatic success has failed");
-_Static_Assert(!(neg_one>zero),"automatic success has failed");
-_Static_Assert(!(neg_one>one),"automatic success has failed");
-_Static_Assert(zero>neg_one,"automatic success has failed");
-_Static_Assert(!(zero>zero),"automatic success has failed");
-_Static_Assert(!(zero>one),"automatic success has failed");
-_Static_Assert(one>neg_one,"automatic success has failed");
-_Static_Assert(one>zero,"automatic success has failed");
-_Static_Assert(!(one>one),"automatic success has failed");
+_Static_assert(!(neg_one>neg_one),"automatic success has failed");
+_Static_assert(!(neg_one>zero),"automatic success has failed");
+_Static_assert(!(neg_one>one),"automatic success has failed");
+_Static_assert(zero>neg_one,"automatic success has failed");
+_Static_assert(!(zero>zero),"automatic success has failed");
+_Static_assert(!(zero>one),"automatic success has failed");
+_Static_assert(one>neg_one,"automatic success has failed");
+_Static_assert(one>zero,"automatic success has failed");
+_Static_assert(!(one>one),"automatic success has failed");
 
 // check ==, !=
-_Static_Assert(neg_one==neg_one,"automatic success has failed");
-_Static_Assert(!(neg_one==zero),"automatic success has failed");
-_Static_Assert(!(neg_one==one),"automatic success has failed");
-_Static_Assert(!(zero==neg_one),"automatic success has failed");
-_Static_Assert(zero==zero,"automatic success has failed");
-_Static_Assert(!(zero==one),"automatic success has failed");
-_Static_Assert(!(one==neg_one),"automatic success has failed");
-_Static_Assert(!(one==zero),"automatic success has failed");
-_Static_Assert(one==one,"automatic success has failed");
+_Static_assert(neg_one==neg_one,"automatic success has failed");
+_Static_assert(!(neg_one==zero),"automatic success has failed");
+_Static_assert(!(neg_one==one),"automatic success has failed");
+_Static_assert(!(zero==neg_one),"automatic success has failed");
+_Static_assert(zero==zero,"automatic success has failed");
+_Static_assert(!(zero==one),"automatic success has failed");
+_Static_assert(!(one==neg_one),"automatic success has failed");
+_Static_assert(!(one==zero),"automatic success has failed");
+_Static_assert(one==one,"automatic success has failed");
 
-_Static_Assert(!(neg_one!=neg_one),"automatic success has failed");
-_Static_Assert(neg_one!=zero,"automatic success has failed");
-_Static_Assert(neg_one!=one,"automatic success has failed");
-_Static_Assert(zero!=neg_one,"automatic success has failed");
-_Static_Assert(!(zero!=zero),"automatic success has failed");
-_Static_Assert(zero!=one,"automatic success has failed");
-_Static_Assert(one!=neg_one,"automatic success has failed");
-_Static_Assert(one!=zero,"automatic success has failed");
-_Static_Assert(!(one!=one),"automatic success has failed");
+_Static_assert(!(neg_one!=neg_one),"automatic success has failed");
+_Static_assert(neg_one!=zero,"automatic success has failed");
+_Static_assert(neg_one!=one,"automatic success has failed");
+_Static_assert(zero!=neg_one,"automatic success has failed");
+_Static_assert(!(zero!=zero),"automatic success has failed");
+_Static_assert(zero!=one,"automatic success has failed");
+_Static_assert(one!=neg_one,"automatic success has failed");
+_Static_assert(one!=zero,"automatic success has failed");
+_Static_assert(!(one!=one),"automatic success has failed");
 
 // check & ^ | 
-_Static_Assert(!(zero&zero),"automatic success has failed");
-_Static_Assert(!(zero&one),"automatic success has failed");
-_Static_Assert(!(one&zero),"automatic success has failed");
-_Static_Assert(one&one,"automatic success has failed");
+_Static_assert(!(zero&zero),"automatic success has failed");
+_Static_assert(!(zero&one),"automatic success has failed");
+_Static_assert(!(one&zero),"automatic success has failed");
+_Static_assert(one&one,"automatic success has failed");
 
-_Static_Assert(!(zero^zero),"automatic success has failed");
-_Static_Assert(zero^one,"automatic success has failed");
-_Static_Assert(one^zero,"automatic success has failed");
-_Static_Assert(!(one^one),"automatic success has failed");
+_Static_assert(!(zero^zero),"automatic success has failed");
+_Static_assert(zero^one,"automatic success has failed");
+_Static_assert(one^zero,"automatic success has failed");
+_Static_assert(!(one^one),"automatic success has failed");
 
-_Static_Assert(!(zero|zero),"automatic success has failed");
-_Static_Assert(zero|one,"automatic success has failed");
-_Static_Assert(one|zero,"automatic success has failed");
-_Static_Assert(one|one,"automatic success has failed");
+_Static_assert(!(zero|zero),"automatic success has failed");
+_Static_assert(zero|one,"automatic success has failed");
+_Static_assert(one|zero,"automatic success has failed");
+_Static_assert(one|one,"automatic success has failed");
 
 // check && ||
-_Static_Assert(neg_one&&neg_one,"automatic success has failed");
-_Static_Assert(!(neg_one&&zero),"automatic success has failed");
-_Static_Assert(neg_one&&one,"automatic success has failed");
-_Static_Assert(!(zero&&neg_one),"automatic success has failed");
-_Static_Assert(!(zero&&zero),"automatic success has failed");
-_Static_Assert(!(zero&&one),"automatic success has failed");
-_Static_Assert(one&&neg_one,"automatic success has failed");
-_Static_Assert(!(one&&zero),"automatic success has failed");
-_Static_Assert(one&&one,"automatic success has failed");
+_Static_assert(neg_one&&neg_one,"automatic success has failed");
+_Static_assert(!(neg_one&&zero),"automatic success has failed");
+_Static_assert(neg_one&&one,"automatic success has failed");
+_Static_assert(!(zero&&neg_one),"automatic success has failed");
+_Static_assert(!(zero&&zero),"automatic success has failed");
+_Static_assert(!(zero&&one),"automatic success has failed");
+_Static_assert(one&&neg_one,"automatic success has failed");
+_Static_assert(!(one&&zero),"automatic success has failed");
+_Static_assert(one&&one,"automatic success has failed");
 
-_Static_Assert(neg_one||neg_one,"automatic success has failed");
-_Static_Assert(neg_one||zero,"automatic success has failed");
-_Static_Assert(neg_one||one,"automatic success has failed");
-_Static_Assert(zero||neg_one,"automatic success has failed");
-_Static_Assert(!(zero||zero),"automatic success has failed");
-_Static_Assert(zero||one,"automatic success has failed");
-_Static_Assert(one||neg_one,"automatic success has failed");
-_Static_Assert(one||zero,"automatic success has failed");
-_Static_Assert(one||one,"automatic success has failed");
+_Static_assert(neg_one||neg_one,"automatic success has failed");
+_Static_assert(neg_one||zero,"automatic success has failed");
+_Static_assert(neg_one||one,"automatic success has failed");
+_Static_assert(zero||neg_one,"automatic success has failed");
+_Static_assert(!(zero||zero),"automatic success has failed");
+_Static_assert(zero||one,"automatic success has failed");
+_Static_assert(one||neg_one,"automatic success has failed");
+_Static_assert(one||zero,"automatic success has failed");
+_Static_assert(one||one,"automatic success has failed");
 
 // check ? :
-_Static_Assert(neg_one ? neg_one : neg_one,"automatic success has failed");
-_Static_Assert(neg_one ? neg_one : zero,"automatic success has failed");
-_Static_Assert(neg_one ? neg_one : one,"automatic success has failed");
-_Static_Assert(!(neg_one ? zero : neg_one),"automatic success has failed");
-_Static_Assert(!(neg_one ? zero : zero),"automatic success has failed");
-_Static_Assert(!(neg_one ? zero : one),"automatic success has failed");
-_Static_Assert(neg_one ? one : neg_one,"automatic success has failed");
-_Static_Assert(neg_one ? one : zero,"automatic success has failed");
-_Static_Assert(neg_one ? one : one,"automatic success has failed");
-_Static_Assert(zero ? neg_one : neg_one,"automatic success has failed");
-_Static_Assert(!(zero ? neg_one : zero),"automatic success has failed");
-_Static_Assert(zero ? neg_one : one,"automatic success has failed");
-_Static_Assert(zero ? zero : neg_one,"automatic success has failed");
-_Static_Assert(!(zero ? zero : zero),"automatic success has failed");
-_Static_Assert(zero ? zero : one,"automatic success has failed");
-_Static_Assert(zero ? one : neg_one,"automatic success has failed");
-_Static_Assert(!(zero ? one : zero),"automatic success has failed");
-_Static_Assert(zero ? one : one,"automatic success has failed");
-_Static_Assert(one ? neg_one : neg_one,"automatic success has failed");
-_Static_Assert(one ? neg_one : zero,"automatic success has failed");
-_Static_Assert(one ? neg_one : one,"automatic success has failed");
-_Static_Assert(!(one ? zero : neg_one),"automatic success has failed");
-_Static_Assert(!(one ? zero : zero),"automatic success has failed");
-_Static_Assert(!(one ? zero : one),"automatic success has failed");
-_Static_Assert(one ? one : neg_one,"automatic success has failed");
-_Static_Assert(one ? one : zero,"automatic success has failed");
-_Static_Assert(one ? one : one,"automatic success has failed");
+_Static_assert(neg_one ? neg_one : neg_one,"automatic success has failed");
+_Static_assert(neg_one ? neg_one : zero,"automatic success has failed");
+_Static_assert(neg_one ? neg_one : one,"automatic success has failed");
+_Static_assert(!(neg_one ? zero : neg_one),"automatic success has failed");
+_Static_assert(!(neg_one ? zero : zero),"automatic success has failed");
+_Static_assert(!(neg_one ? zero : one),"automatic success has failed");
+_Static_assert(neg_one ? one : neg_one,"automatic success has failed");
+_Static_assert(neg_one ? one : zero,"automatic success has failed");
+_Static_assert(neg_one ? one : one,"automatic success has failed");
+_Static_assert(zero ? neg_one : neg_one,"automatic success has failed");
+_Static_assert(!(zero ? neg_one : zero),"automatic success has failed");
+_Static_assert(zero ? neg_one : one,"automatic success has failed");
+_Static_assert(zero ? zero : neg_one,"automatic success has failed");
+_Static_assert(!(zero ? zero : zero),"automatic success has failed");
+_Static_assert(zero ? zero : one,"automatic success has failed");
+_Static_assert(zero ? one : neg_one,"automatic success has failed");
+_Static_assert(!(zero ? one : zero),"automatic success has failed");
+_Static_assert(zero ? one : one,"automatic success has failed");
+_Static_assert(one ? neg_one : neg_one,"automatic success has failed");
+_Static_assert(one ? neg_one : zero,"automatic success has failed");
+_Static_assert(one ? neg_one : one,"automatic success has failed");
+_Static_assert(!(one ? zero : neg_one),"automatic success has failed");
+_Static_assert(!(one ? zero : zero),"automatic success has failed");
+_Static_assert(!(one ? zero : one),"automatic success has failed");
+_Static_assert(one ? one : neg_one,"automatic success has failed");
+_Static_assert(one ? one : zero,"automatic success has failed");
+_Static_assert(one ? one : one,"automatic success has failed");
 



