From zaimoni at mail.berlios.de  Tue Dec  1 03:45:10 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 1 Dec 2009 03:45:10 +0100
Subject: [Zcplusplus-commits] r292 - trunk
Message-ID: <200912010245.nB12jA8h009082@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-01 03:45:06 +0100 (Tue, 01 Dec 2009)
New Revision: 292

Modified:
   trunk/CSupport.cpp
   trunk/type_system.cpp
   trunk/type_system.hpp
Log:
bring up CPP register type functions in type_system

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-11-30 06:03:15 UTC (rev 291)
+++ trunk/CSupport.cpp	2009-12-01 02:45:06 UTC (rev 292)
@@ -11214,7 +11214,7 @@
 				//! \test zcc\decl.C99\Pass_enum_def.hpp
 				// enum-specifier doesn't have a specific declaration mode
 				enum_def* tmp2 = new enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-				types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,tmp2);
+				types.register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp2);
 				if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
 					{
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
@@ -11225,7 +11225,7 @@
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 				enum_def* tmp = new enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-				types.register_enum_def("<unknown>",tmp);
+				types.register_enum_def_CPP("<unknown>",active_namespace,tmp);
 				if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
 					{
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
@@ -11288,7 +11288,7 @@
 					// forward-declare
 					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 					union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first);
-					types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
+					types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp);
 					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
 					assert(types.get_structdecl(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)));
 					i += 2;
@@ -11307,7 +11307,7 @@
 					// forward-declare
 					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 					union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first);
-					types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
+					types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp);
 					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
 					assert(types.get_structdecl(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
 					i += 2;
@@ -11318,15 +11318,15 @@
 					if (types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
 						{	// but if already (forward-)declared then this is a no-op
 							// think this is common enough to not warrant OAOO/DRY treatment
-						//! \bug needs test case
+						//! \test zcc/decl.C99/Pass_class_forward_def.hpp
 						// remove from parse
 						src.DeleteNSlotsAt<0>(2,i);
 						continue;					
 						}
 					// forward-declare
-					//! \bug needs test case
+					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
 					union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].token.first);
-					types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
+					types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp);
 					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
 					assert(types.get_structdecl(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
 					i += 2;
@@ -11351,7 +11351,7 @@
 							//! \test zcc/decl.C99/Pass_union_def.hpp
 						tmp2 = new C_union_struct_def(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 						//! \todo record field structure, etc.
-						types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,tmp2);
+						types.register_C_structdef_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp2);
 						assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
 						assert(types.get_C_structdef(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)));
 						}
@@ -11377,7 +11377,7 @@
 							//! \test zcc/decl.C99/Pass_struct_def.hpp
 						tmp2 = new C_union_struct_def(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 						//! \todo record field structure, etc.
-						types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,tmp2);
+						types.register_C_structdef_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp2);
 						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
 						assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
 						}
@@ -11390,7 +11390,7 @@
 					C_union_struct_def* tmp2 = NULL;
 					if (tmp)
 						{	// promoting forward-declare to definition
-							//! \bug needs test case
+							//! \test zcc/decl.C99/Pass_class_forward_def.hpp
 						const union_struct_decl* tmp3 = types.get_structdecl(tmp);
 						assert(tmp3);
 						tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
@@ -11403,7 +11403,7 @@
 							//! \test zcc/decl.C99/Pass_class_def.hpp
 						tmp2 = new C_union_struct_def(union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 						//! \todo record field structure, etc.
-						types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,tmp2);
+						types.register_C_structdef_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp2);
 						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
 						assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
 						}

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2009-11-30 06:03:15 UTC (rev 291)
+++ trunk/type_system.cpp	2009-12-01 02:45:06 UTC (rev 292)
@@ -111,17 +111,16 @@
 	src.clear();
 }
 
-void type_system::set_typedef_CPP(const char* const name, const char* const active_namespace, const char* filename, const size_t lineno, type_spec& src)
+void type_system::set_typedef_CPP(const char* name, const char* const active_namespace, const char* filename, const size_t lineno, type_spec& src)
 {
 	assert(name && *name);
 	assert(filename && *filename);
 
-	// if no active namespace, treat as C
-	if (!active_namespace || !*active_namespace)
-		return set_typedef(name,filename,lineno,src);
+	// use active namespace if present
+	if (active_namespace && *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
 
-	const char* const alias = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
-	return set_typedef(alias,filename,lineno,src);
+	return set_typedef(name,filename,lineno,src);
 }
 
 const zaimoni::POD_triple<type_spec,const char*,size_t>* type_system::get_typedef(const char* const alias) const
@@ -410,6 +409,18 @@
 	return dynamic_types_size+2+core_types_size;
 }
 
+type_system::type_index type_system::register_functype_CPP(const char* name, const char* const active_namespace, function_type*& src)
+{
+	assert(name && *name);
+	assert(src);
+
+	// use active namespace if present
+	if (active_namespace && *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	return register_functype(name,src);
+}
+
 type_system::type_index type_system::register_structdecl(const char* const alias, union_struct_decl*& src)
 {
 	assert(alias && *alias);
@@ -427,6 +438,18 @@
 	return dynamic_types_size+2+core_types_size;
 }
 
+type_system::type_index type_system::register_structdecl_CPP(const char* name, const char* const active_namespace, union_struct_decl*& src)
+{
+	assert(name && *name);
+	assert(src);
+
+	// use active namespace if present
+	if (active_namespace && *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	return register_structdecl(name,src);
+}
+
 type_system::type_index type_system::register_C_structdef(const char* const alias, C_union_struct_def*& src)
 {
 	assert(alias && *alias);
@@ -444,6 +467,18 @@
 	return dynamic_types_size+2+core_types_size;
 }
 
+type_system::type_index type_system::register_C_structdef_CPP(const char* name, const char* const active_namespace, C_union_struct_def*& src)
+{
+	assert(name && *name);
+	assert(src);
+
+	// use active namespace if present
+	if (active_namespace && *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	return register_C_structdef(name,src);
+}
+
 type_system::type_index type_system::register_enum_def(const char* const alias, enum_def*& src)
 {
 	assert(alias && *alias);
@@ -461,6 +496,18 @@
 	return dynamic_types_size+2+core_types_size;
 }
 
+type_system::type_index type_system::register_enum_def_CPP(const char* name, const char* const active_namespace, enum_def*& src)
+{
+	assert(name && *name);
+	assert(src);
+
+	// use active namespace if present
+	if (active_namespace && *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	return register_enum_def(name,src);
+}
+
 const function_type* type_system::get_functype(type_system::type_index i)
 {
 	if (core_types_size>=i) return NULL;

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2009-11-30 06:03:15 UTC (rev 291)
+++ trunk/type_system.hpp	2009-12-01 02:45:06 UTC (rev 292)
@@ -116,9 +116,13 @@
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* get_typedef_CPP(const char* alias,const char* active_namespace) const;
 
 	type_index register_functype(const char* const alias, function_type*& src);
+	type_index register_functype_CPP(const char* name, const char* active_namespace, function_type*& src);
 	type_index register_structdecl(const char* const alias, union_struct_decl*& src);
+	type_index register_structdecl_CPP(const char* name, const char* active_namespace, union_struct_decl*& src);
 	type_index register_C_structdef(const char* const alias, C_union_struct_def*& src);
+	type_index register_C_structdef_CPP(const char* name, const char* active_namespace, C_union_struct_def*& src);
 	type_index register_enum_def(const char* const alias, enum_def*& src);
+	type_index register_enum_def_CPP(const char* name, const char* active_namespace, enum_def*& src);
 	const function_type* get_functype(type_index i);
 	const union_struct_decl* get_structdecl(type_index i);
 	const C_union_struct_def* get_C_structdef(type_index i);



From zaimoni at mail.berlios.de  Thu Dec  3 06:37:59 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 3 Dec 2009 06:37:59 +0100
Subject: [Zcplusplus-commits] r293 - trunk
Message-ID: <200912030537.nB35bxVF022806@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-03 06:37:51 +0100 (Thu, 03 Dec 2009)
New Revision: 293

Modified:
   trunk/type_system.cpp
   trunk/type_system.hpp
Log:
remove unused public interfaces in type_system that would otherwise need C++ namespace lookup variants

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2009-12-01 02:45:06 UTC (rev 292)
+++ trunk/type_system.cpp	2009-12-03 05:37:51 UTC (rev 293)
@@ -14,9 +14,9 @@
 #define DYNAMIC_C_STRUCTDEF 3
 #define DYNAMIC_ENUMDEF 4
 
-type_system::type_index
-type_system::_get_id_union(const char* const x,size_t x_len) const
+type_system::type_index type_system::_get_id_union(const char* const x) const
 {
+	const size_t x_len = strlen(x);
 	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
 	while(0<=tmp)
 		{
@@ -42,8 +42,9 @@
 }
 
 type_system::type_index
-type_system::_get_id_struct_class(const char* const x,size_t x_len) const
+type_system::_get_id_struct_class(const char* const x) const
 {
+	const size_t x_len = strlen(x);
 	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
 	while(0<=tmp)
 		{
@@ -68,9 +69,9 @@
 	return 0;
 }
 
-type_system::type_index
-type_system::_get_id_enum(const char* const x,size_t x_len) const
+type_system::type_index type_system::_get_id_enum(const char* const x) const
 {
+	const size_t x_len = strlen(x);
 	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
 	while(0<=tmp)
 		{

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2009-12-01 02:45:06 UTC (rev 292)
+++ trunk/type_system.hpp	2009-12-03 05:37:51 UTC (rev 293)
@@ -38,41 +38,20 @@
 		core_types_size((assert(0<_core_types_size),_core_types_size)),
 		int_priority_size((assert(0<_int_priority_size),_int_priority_size)) {};
 
-	type_index get_id_union(const char* x,size_t x_len) const
-		{
-		assert(x && *x);
-		assert(0<x_len);
-		assert(x_len<=strlen(x));
-		return _get_id_union(x,x_len);
-		}
 	type_index get_id_union(const char* x) const
 		{
 		assert(x && *x);
-		return _get_id_union(x,strlen(x));
+		return _get_id_union(x);
 		}
-	type_index get_id_struct_class(const char* x,size_t x_len) const
-		{
-		assert(x && *x);
-		assert(0<x_len);
-		assert(x_len<=strlen(x));
-		return _get_id_struct_class(x,x_len);
-		}
 	type_index get_id_struct_class(const char* x) const
 		{
 		assert(x && *x);
-		return _get_id_struct_class(x,strlen(x));
+		return _get_id_struct_class(x);
 		}
-	type_index get_id_enum(const char* x,size_t x_len) const
-		{
-		assert(x && *x);
-		assert(0<x_len);
-		assert(x_len<=strlen(x));
-		return _get_id_enum(x,x_len);
-		}
 	type_index get_id_enum(const char* x) const
 		{
 		assert(x && *x);
-		return _get_id_enum(x,strlen(x));
+		return _get_id_enum(x);
 		}
 	const char* name(type_index id) const
 		{
@@ -129,9 +108,9 @@
 	const enum_def* get_enum_def(type_index i);
 	void upgrade_decl_to_def(type_index i,C_union_struct_def*& src);
 private:
-	type_index _get_id_union(const char* const x,size_t x_len) const;
-	type_index _get_id_enum(const char* const x,size_t x_len) const;
-	type_index _get_id_struct_class(const char* const x,size_t x_len) const;
+	type_index _get_id_union(const char* const x) const;
+	type_index _get_id_enum(const char* const x) const;
+	type_index _get_id_struct_class(const char* const x) const;
 	const char* _name(type_index id) const;
 	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> dealias_inline_namespace_index(const char* alias) const;
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* _get_typedef_CPP(const char* alias) const;



From zaimoni at mail.berlios.de  Fri Dec  4 10:49:20 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 4 Dec 2009 10:49:20 +0100
Subject: [Zcplusplus-commits] r294 - trunk
Message-ID: <200912040949.nB49nKWa024216@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-04 10:49:05 +0100 (Fri, 04 Dec 2009)
New Revision: 294

Modified:
   trunk/type_system.cpp
   trunk/type_system.hpp
Log:
bring up C++ name lookup for union/struct/class/enum

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2009-12-03 05:37:51 UTC (rev 293)
+++ trunk/type_system.cpp	2009-12-04 09:49:05 UTC (rev 294)
@@ -42,6 +42,66 @@
 }
 
 type_system::type_index
+type_system::_get_id_union_CPP(const char* const x) const
+{
+	errr tmp = _get_id_union(x);
+	if (0<tmp) return tmp;
+
+	// hmm...not an exact match
+	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(x);
+	if (0>tmp2.first) return 0;
+
+	// it was remapped
+	while(tmp2.first<tmp2.second)
+		{
+		tmp = _get_id_union(inline_namespace_alias_map.data()[tmp2.first].second);
+		if (0<tmp) return tmp;
+		++tmp2.first;
+		}
+	return _get_id_union(inline_namespace_alias_map.data()[tmp2.first].second);
+}
+
+type_system::type_index
+type_system::get_id_union_CPP(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+
+	if (!strncmp(alias,"::",2))
+		{	// fully-qualified
+		// pretend not fully qualified, but no surrounding namespace
+		alias += 2;
+		active_namespace = NULL;
+		};
+	if (active_namespace && *active_namespace)
+		{
+		// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		if (is_string_registered(tmp_alias))
+			{	// registered, so could be indexed
+			const type_index tmp2 = _get_id_union_CPP(tmp_alias);
+			if (tmp2) return (free(tmp_alias),tmp2);
+			}
+
+		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
+		if (extra_namespaces)
+			{
+			zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
+			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				--i;
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,"::");
+				const type_index tmp2 = _get_id_union_CPP(tmp_alias);
+				if (tmp2) return (free(tmp_alias),tmp2);
+				}
+			while(0<i);
+			}
+		free(tmp_alias);
+		}
+	return _get_id_union_CPP(alias);
+}
+
+type_system::type_index
 type_system::_get_id_struct_class(const char* const x) const
 {
 	const size_t x_len = strlen(x);
@@ -69,6 +129,66 @@
 	return 0;
 }
 
+type_system::type_index
+type_system::_get_id_struct_class_CPP(const char* const x) const
+{
+	errr tmp = _get_id_struct_class(x);
+	if (0<tmp) return tmp;
+
+	// hmm...not an exact match
+	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(x);
+	if (0>tmp2.first) return 0;
+
+	// it was remapped
+	while(tmp2.first<tmp2.second)
+		{
+		tmp = _get_id_struct_class(inline_namespace_alias_map.data()[tmp2.first].second);
+		if (0<tmp) return tmp;
+		++tmp2.first;
+		}
+	return _get_id_struct_class(inline_namespace_alias_map.data()[tmp2.first].second);
+}
+
+type_system::type_index
+type_system::get_id_struct_class_CPP(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+
+	if (!strncmp(alias,"::",2))
+		{	// fully-qualified
+		// pretend not fully qualified, but no surrounding namespace
+		alias += 2;
+		active_namespace = NULL;
+		};
+	if (active_namespace && *active_namespace)
+		{
+		// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		if (is_string_registered(tmp_alias))
+			{	// registered, so could be indexed
+			const type_index tmp2 = _get_id_struct_class_CPP(tmp_alias);
+			if (tmp2) return (free(tmp_alias),tmp2);
+			}
+
+		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
+		if (extra_namespaces)
+			{
+			zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
+			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				--i;
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,"::");
+				const type_index tmp2 = _get_id_struct_class_CPP(tmp_alias);
+				if (tmp2) return (free(tmp_alias),tmp2);
+				}
+			while(0<i);
+			}
+		free(tmp_alias);
+		}
+	return _get_id_struct_class_CPP(alias);
+}
+
 type_system::type_index type_system::_get_id_enum(const char* const x) const
 {
 	const size_t x_len = strlen(x);
@@ -87,6 +207,66 @@
 	return 0;
 }
 
+type_system::type_index
+type_system::_get_id_enum_CPP(const char* const x) const
+{
+	errr tmp = _get_id_enum(x);
+	if (0<tmp) return tmp;
+
+	// hmm...not an exact match
+	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(x);
+	if (0>tmp2.first) return 0;
+
+	// it was remapped
+	while(tmp2.first<tmp2.second)
+		{
+		tmp = _get_id_enum(inline_namespace_alias_map.data()[tmp2.first].second);
+		if (0<tmp) return tmp;
+		++tmp2.first;
+		}
+	return _get_id_enum(inline_namespace_alias_map.data()[tmp2.first].second);
+}
+
+type_system::type_index
+type_system::get_id_enum_CPP(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+
+	if (!strncmp(alias,"::",2))
+		{	// fully-qualified
+		// pretend not fully qualified, but no surrounding namespace
+		alias += 2;
+		active_namespace = NULL;
+		};
+	if (active_namespace && *active_namespace)
+		{
+		// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		if (is_string_registered(tmp_alias))
+			{	// registered, so could be indexed
+			const type_index tmp2 = _get_id_enum_CPP(tmp_alias);
+			if (tmp2) return (free(tmp_alias),tmp2);
+			}
+
+		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
+		if (extra_namespaces)
+			{
+			zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
+			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				--i;
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,"::");
+				const type_index tmp2 = _get_id_enum_CPP(tmp_alias);
+				if (tmp2) return (free(tmp_alias),tmp2);
+				}
+			while(0<i);
+			}
+		free(tmp_alias);
+		}
+	return _get_id_enum_CPP(alias);
+}
+
 const char* type_system::_name(size_t id) const
 {
 	if (0==id) return "(?)";

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2009-12-03 05:37:51 UTC (rev 293)
+++ trunk/type_system.hpp	2009-12-04 09:49:05 UTC (rev 294)
@@ -43,16 +43,19 @@
 		assert(x && *x);
 		return _get_id_union(x);
 		}
+	type_index get_id_union_CPP(const char* alias,const char* active_namespace) const;
 	type_index get_id_struct_class(const char* x) const
 		{
 		assert(x && *x);
 		return _get_id_struct_class(x);
 		}
+	type_index get_id_struct_class_CPP(const char* alias,const char* active_namespace) const;
 	type_index get_id_enum(const char* x) const
 		{
 		assert(x && *x);
 		return _get_id_enum(x);
 		}
+	type_index get_id_enum_CPP(const char* alias,const char* active_namespace) const;
 	const char* name(type_index id) const
 		{
 		assert(core_types_size+dynamic_types.size()>=id);
@@ -108,9 +111,13 @@
 	const enum_def* get_enum_def(type_index i);
 	void upgrade_decl_to_def(type_index i,C_union_struct_def*& src);
 private:
-	type_index _get_id_union(const char* const x) const;
-	type_index _get_id_enum(const char* const x) const;
-	type_index _get_id_struct_class(const char* const x) const;
+	type_index _get_id_union(const char* x) const;
+	type_index _get_id_union_CPP(const char* x) const;
+	type_index _get_id_enum(const char* x) const;
+	type_index _get_id_enum_CPP(const char* x) const;
+	type_index _get_id_struct_class(const char* x) const;
+	type_index _get_id_struct_class_CPP(const char* x) const;
+
 	const char* _name(type_index id) const;
 	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> dealias_inline_namespace_index(const char* alias) const;
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* _get_typedef_CPP(const char* alias) const;



From zaimoni at mail.berlios.de  Sat Dec  5 06:21:52 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 5 Dec 2009 06:21:52 +0100
Subject: [Zcplusplus-commits] r295 - trunk
Message-ID: <200912050521.nB55LqfP004122@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-05 06:21:46 +0100 (Sat, 05 Dec 2009)
New Revision: 295

Modified:
   trunk/CSupport.cpp
   trunk/type_system.cpp
Log:
relatively low-noise introduction of proper C++ namespaces for enum/union/struct/class; augment assert test harness for C as well; fix bug exposed by new asserts

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-12-04 09:49:05 UTC (rev 294)
+++ trunk/CSupport.cpp	2009-12-05 05:21:46 UTC (rev 295)
@@ -10775,9 +10775,11 @@
 				// forward-declare
 				//! \test zcc/decl.C99/Pass_union_forward_def.h
 				union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first);
-				types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
+				type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
 				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_structdecl(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)));
+				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array<0>()[i].type_code.set_type(tmp2);
 				i += 2;
 				continue;
 				}
@@ -10794,15 +10796,17 @@
 				// forward-declare
 				//! \test zcc/decl.C99/Pass_struct_forward_def.h
 				union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first);
-				types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
+				type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
 				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_structdecl(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array<0>()[i].type_code.set_type(tmp2);
 				i += 2;
 				continue;
 				}
 			else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
 				{	// definitions...fine
-				type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
+				const type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
 				C_union_struct_def* tmp2 = NULL;
 				if (tmp)
 					{	// promoting forward-declare to definition
@@ -10812,23 +10816,25 @@
 					tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 					//! \todo record field structure, etc.
 					types.upgrade_decl_to_def(tmp,tmp2);
-					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-					assert(types.get_C_structdef(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)));
+					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp);
+					assert(types.get_C_structdef(tmp));
 					}
 				else{	// definition
 						//! \test zcc/decl.C99/Pass_union_def.h
 					tmp2 = new C_union_struct_def(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 					//! \todo record field structure, etc.
-					types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,tmp2);
+					const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,tmp2);
 					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-					assert(types.get_C_structdef(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)));
+					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
+					assert(types.get_C_structdef(tmp3));
+					src.c_array<0>()[i].type_code.set_type(tmp3);
 					}
 				i += 2;
 				continue;
 				}
 			else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
 				{	// definitions...fine
-				type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+				const type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
 				C_union_struct_def* tmp2 = NULL;
 				if (tmp)
 					{	// promoting forward-declare to definition
@@ -10838,16 +10844,18 @@
 					tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 					//! \todo record field structure, etc.
 					types.upgrade_decl_to_def(tmp,tmp2);
-					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-					assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp);
+					assert(types.get_C_structdef(tmp));
 					}
 				else{	// definition
 						//! \test zcc/decl.C99/Pass_struct_def.h
 					tmp2 = new C_union_struct_def(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 					//! \todo record field structure, etc.
-					types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,tmp2);
+					const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,tmp2);
 					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-					assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
+					assert(types.get_C_structdef(tmp3));
+					src.c_array<0>()[i].type_code.set_type(tmp3);
 					}
 				i += 2;
 				continue;
@@ -11096,32 +11104,35 @@
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// check naked declarations first; handle namespaces later
-		if (NULL==active_namespace)
-			{
+//		if (NULL==active_namespace)
+//			{
 			if (is_C99_named_specifier(src.data<0>()[i],"union"))
 				{
-				type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
+				type_system::type_index tmp = types.get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				}
 			else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
 				{
-				type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+				type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				}
 			else if (is_C99_named_specifier(src.data<0>()[i],"class"))
 				{
-				type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+				type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				}
 			else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
 				{	// can only define once
-				const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+				const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_union(fullname));
 				if (tmp)
 					{	//! \test zcc/decl.C99/Error_union_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'union ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INC_INFORM(fullname);
+					free(namespace_name);
 					INFORM("' already defined (C++98 3.2p1)");
 					message_header(*tmp);
 					INFORM("prior definition here");
@@ -11131,16 +11142,20 @@
 					src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
 					continue;
 					}
+				free(namespace_name);
 				}
 			else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
 				{	// can only define once
-				const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+				const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(fullname));
 				if (tmp)
 					{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'struct ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INC_INFORM(fullname);
+					free(namespace_name);
 					INFORM("' already defined (C++98 3.2p1)");
 					message_header(*tmp);
 					INFORM("prior definition here");
@@ -11150,16 +11165,20 @@
 					src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
 					continue;
 					}
+				free(namespace_name);
 				}
 			else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
 				{	// can only define once
-				const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+				const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(fullname));
 				if (tmp)
 					{	//! \test zcc/decl.C99/Error_class_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'class ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INC_INFORM(fullname);
+					free(namespace_name);
 					INFORM("' already defined (C++98 3.2p1)");
 					message_header(*tmp);
 					INFORM("prior definition here");
@@ -11169,6 +11188,7 @@
 					src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
 					continue;
 					}
+				free(namespace_name);
 				}
 			// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
 			//! \todo actually, we can try forward-declare both scoped enums and enum-based enums (C++0X 7.2p3, these have enough size information); but other parts of the standard get in the way
@@ -11176,7 +11196,7 @@
 				{
 				if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
 					{
-					type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+					type_system::type_index tmp = types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 					src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
 					if (!tmp)
 						{	// this belongs elsewhere
@@ -11194,13 +11214,16 @@
 				}
 			else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
 				{	// can only define once
-				type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+				type_system::type_index tmp = types.get_id_enum(fullname);
 				if (tmp)
 					{	//! \test zcc\decl.C99\Error_enum_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INC_INFORM("'enum ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INC_INFORM(fullname);
+					free(namespace_name);
 					INFORM("' already defined (C++98 3.2p1)");
 					const enum_def* const tmp2 = types.get_enum_def(tmp);
 					assert(tmp2);
@@ -11211,8 +11234,10 @@
 					src.DeleteNSlotsAt<0>(1,i);
 					continue;
 					};
+				free(namespace_name);
 				//! \test zcc\decl.C99\Pass_enum_def.hpp
 				// enum-specifier doesn't have a specific declaration mode
+				//! \todo fix up the fully-qualified name in the enum_def
 				enum_def* tmp2 = new enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 				types.register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp2);
 				if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
@@ -11224,6 +11249,7 @@
 			else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
+				//! \todo fix up the fully-qualified name in the enum_def
 				enum_def* tmp = new enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 				types.register_enum_def_CPP("<unknown>",active_namespace,tmp);
 				if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
@@ -11277,64 +11303,88 @@
 					}
 				else if (is_C99_named_specifier(src.data<0>()[i],"union"))
 					{	// forward-declare, fine
-					if (types.get_id_union(src.data<0>()[i].index_tokens[1].token.first))
+					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+					const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+					if (types.get_id_union(fullname))
 						{	// but if already (forward-)declared then this is a no-op
 							// think this is common enough to not warrant OAOO/DRY treatment
 						//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 						// remove from parse
+						free(namespace_name);
 						src.DeleteNSlotsAt<0>(2,i);
 						continue;					
 						}
+					free(namespace_name);
 					// forward-declare
 					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+					//! \todo fix up fully-qualified name
 					union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first);
-					types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp);
+					const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp);
 					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-					assert(types.get_structdecl(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)));
+					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+					assert(types.get_structdecl(tmp2));
+					src.c_array<0>()[i].type_code.set_type(tmp2);
 					i += 2;
 					continue;
 					}
 				else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
 					{	// forward-declare, fine
-					if (types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
+					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+					const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+					if (types.get_id_struct_class(fullname))
 						{	// but if already (forward-)declared then this is a no-op
 							// think this is common enough to not warrant OAOO/DRY treatment
 						//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 						// remove from parse
+						free(namespace_name);
 						src.DeleteNSlotsAt<0>(2,i);
 						continue;					
 						}
+					free(namespace_name);
 					// forward-declare
 					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+					//! \todo fix up fully-qualified name
 					union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first);
-					types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp);
+					const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp);
 					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-					assert(types.get_structdecl(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+					assert(types.get_structdecl(tmp2));
+					src.c_array<0>()[i].type_code.set_type(tmp2);
 					i += 2;
 					continue;
 					}
 				else if (is_C99_named_specifier(src.data<0>()[i],"class"))
 					{	// forward-declare, fine
-					if (types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
+					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+					const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+					if (types.get_id_struct_class(fullname))
 						{	// but if already (forward-)declared then this is a no-op
 							// think this is common enough to not warrant OAOO/DRY treatment
 						//! \test zcc/decl.C99/Pass_class_forward_def.hpp
 						// remove from parse
+						free(namespace_name);
 						src.DeleteNSlotsAt<0>(2,i);
 						continue;					
 						}
+					free(namespace_name);
 					// forward-declare
 					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+					//! \todo fix up fully-qualified name
 					union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].token.first);
-					types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp);
+					const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp);
 					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-					assert(types.get_structdecl(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+					assert(types.get_structdecl(tmp2));
+					src.c_array<0>()[i].type_code.set_type(tmp2);
 					i += 2;
 					continue;
 					}
 				else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
 					{	// definitions...fine
-					type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
+					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+					const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+					const type_system::type_index tmp = types.get_id_union(fullname);
+					free(namespace_name);
 					C_union_struct_def* tmp2 = NULL;
 					if (tmp)
 						{	// promoting forward-declare to definition
@@ -11344,23 +11394,29 @@
 						tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 						//! \todo record field structure, etc.
 						types.upgrade_decl_to_def(tmp,tmp2);
-						assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-						assert(types.get_C_structdef(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)));
+						assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp);
+						assert(types.get_C_structdef(tmp));
 						}
 					else{	// definition
 							//! \test zcc/decl.C99/Pass_union_def.hpp
 						tmp2 = new C_union_struct_def(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 						//! \todo record field structure, etc.
-						types.register_C_structdef_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp2);
+						//! \todo fix up fully-qualified name
+						const type_system::type_index tmp3 = types.register_C_structdef_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp2);
 						assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-						assert(types.get_C_structdef(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)));
+						assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
+						assert(types.get_C_structdef(tmp3));
+						src.c_array<0>()[i].type_code.set_type(tmp3);
 						}
 					i += 2;
 					continue;
 					}
 				else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
 					{	// definitions...fine
-					type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+					const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+					const type_system::type_index tmp = types.get_id_struct_class(fullname);
+					free(namespace_name);
 					C_union_struct_def* tmp2 = NULL;
 					if (tmp)
 						{	// promoting forward-declare to definition
@@ -11370,23 +11426,29 @@
 						tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 						//! \todo record field structure, etc.
 						types.upgrade_decl_to_def(tmp,tmp2);
-						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-						assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp);
+						assert(types.get_C_structdef(tmp));
 						}
 					else{	// definition
 							//! \test zcc/decl.C99/Pass_struct_def.hpp
 						tmp2 = new C_union_struct_def(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 						//! \todo record field structure, etc.
-						types.register_C_structdef_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp2);
+						//! \todo fix up fully-qualified name
+						const type_system::type_index tmp3 = types.register_C_structdef_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp2);
 						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
 						assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+						src.c_array<0>()[i].type_code.set_type(tmp3);
 						}
 					i += 2;
 					continue;
 					}
 				else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
 					{	// definitions...fine
-					type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+					const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+					const type_system::type_index tmp = types.get_id_struct_class(fullname);
+					free(namespace_name);
 					C_union_struct_def* tmp2 = NULL;
 					if (tmp)
 						{	// promoting forward-declare to definition
@@ -11396,22 +11458,25 @@
 						tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 						//! \todo record field structure, etc.
 						types.upgrade_decl_to_def(tmp,tmp2);
-						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-						assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp);
+						assert(types.get_C_structdef(tmp));
 						}
 					else{	// definition
 							//! \test zcc/decl.C99/Pass_class_def.hpp
 						tmp2 = new C_union_struct_def(union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 						//! \todo record field structure, etc.
-						types.register_C_structdef_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp2);
+						//! \todo fix up fully-qualified name
+						const type_system::type_index tmp3 = types.register_C_structdef_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp2);
 						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-						assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
+						assert(types.get_C_structdef(tmp3));
+						src.c_array<0>()[i].type_code.set_type(tmp3);
 						}
 					i += 2;
 					continue;
 					};
 				};
-			}
+//			}
 		// namespace scanner
 		// need some scheme to handle unnamed namespaces (probably alphabetical counter after something illegal so unmatchable)
 		// C++0X has inline namespaces; ignore these for now (well, maybe not: consuming the inline will prevent problems)
@@ -11641,18 +11706,14 @@
 					if (C99_CPP0X_DECLSPEC_TYPEDEF & declFind.get_flags())
 						{	// typedef
 						register_token<0>(src.c_array<0>()[initdecl_identifier_idx]);
-						const char* fullname = src.c_array<0>()[initdecl_identifier_idx].index_tokens[0].token.first;
-						// deal with namespaces
-						if (NULL!=active_namespace)
-							{
-							char* const actual_name = type_system::namespace_concatenate(fullname,active_namespace,"::");
-							fullname = register_string(actual_name);	//! \todo would like to use "consume string" to avoid frivolous memory allocation
-							free(actual_name);
-							}
+						char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.c_array<0>()[initdecl_identifier_idx].index_tokens[0].token.first,active_namespace,"::") : NULL;
+						const char* fullname = namespace_name ? namespace_name : src.c_array<0>()[initdecl_identifier_idx].index_tokens[0].token.first;
+						// We could run an is_string_registered check to try to conserve RAM, but in this case conserving RAM 
+						// doesn't actually reduce maximum RAM loading before the types.set_typedef_CPP call.
 
 						// verify that there is no prior definition
 						// we're fine redeclaring at a different level, so do not use full C++ typedef lookup
-						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(fullname);
+						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(fullname);					
 						if (NULL!=tmp)
 							{
 							if (bootstrap==tmp->first)
@@ -11683,9 +11744,12 @@
 								zcc_errors.inc_error();
 								}
 							// do not re-register if there is a prior definition
+							free(namespace_name);
 							}
-						else	// register this with types object
+						else{	// register this with types object
+							free(namespace_name);
 							types.set_typedef_CPP(src.c_array<0>()[initdecl_identifier_idx].index_tokens[0].token.first,active_namespace,src.data<0>()[initdecl_identifier_idx].index_tokens[0].src_filename,src.data<0>()[initdecl_identifier_idx].index_tokens[0].logical_line.first,bootstrap);
+							}
 						}
 #if 0
 					else{	// something else

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2009-12-04 09:49:05 UTC (rev 294)
+++ trunk/type_system.cpp	2009-12-05 05:21:46 UTC (rev 295)
@@ -587,7 +587,7 @@
 		FATAL("Host implementation limit exceeded: cannot record function type used in program");
 	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
 	src = NULL;
-	return dynamic_types_size+2+core_types_size;
+	return dynamic_types_size+1+core_types_size;
 }
 
 type_system::type_index type_system::register_functype_CPP(const char* name, const char* const active_namespace, function_type*& src)
@@ -616,7 +616,7 @@
 		FATAL("Host implementation limit exceeded: cannot record union/struct type used in program");
 	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
 	src = NULL;
-	return dynamic_types_size+2+core_types_size;
+	return dynamic_types_size+1+core_types_size;
 }
 
 type_system::type_index type_system::register_structdecl_CPP(const char* name, const char* const active_namespace, union_struct_decl*& src)
@@ -645,7 +645,7 @@
 		FATAL("Host implementation limit exceeded: cannot record union/struct type used in program");
 	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
 	src = NULL;
-	return dynamic_types_size+2+core_types_size;
+	return dynamic_types_size+1+core_types_size;
 }
 
 type_system::type_index type_system::register_C_structdef_CPP(const char* name, const char* const active_namespace, C_union_struct_def*& src)
@@ -674,7 +674,7 @@
 		FATAL("Host implementation limit exceeded: cannot record enum type used in program");
 	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
 	src = NULL;
-	return dynamic_types_size+2+core_types_size;
+	return dynamic_types_size+1+core_types_size;
 }
 
 type_system::type_index type_system::register_enum_def_CPP(const char* name, const char* const active_namespace, enum_def*& src)



From zaimoni at mail.berlios.de  Sat Dec  5 20:19:23 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 5 Dec 2009 20:19:23 +0100
Subject: [Zcplusplus-commits] r296 - trunk
Message-ID: <200912051919.nB5JJNdm009973@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-05 20:19:18 +0100 (Sat, 05 Dec 2009)
New Revision: 296

Modified:
   trunk/CSupport.cpp
   trunk/POSIX.dep
   trunk/type_system.cpp
   trunk/type_system.hpp
Log:
unbreak SVN; interface cleanup

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-12-05 05:21:46 UTC (rev 295)
+++ trunk/CSupport.cpp	2009-12-05 19:19:18 UTC (rev 296)
@@ -10693,7 +10693,7 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
 			{	// can only define once
-			type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{	//! \test zcc\decl.C99\Error_enum_multidef.h
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -10712,9 +10712,8 @@
 				};
 			// enum-specifier doesn't have a specific declaration mode
 			//! \test zcc\decl.C99\Pass_enum_def.h
-			enum_def* tmp2 = new enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,tmp2);
-			assert(types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first));
+			const type_system::type_index tmp2 = types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			assert(types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
 			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,false,C99_echo_reserved_keyword))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
@@ -10724,8 +10723,7 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			enum_def* tmp = new enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			types.register_enum_def("<unknown>",tmp);
+			types.register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,NULL,NULL,false,C99_echo_reserved_keyword))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
@@ -10774,8 +10772,7 @@
 					}
 				// forward-declare
 				//! \test zcc/decl.C99/Pass_union_forward_def.h
-				union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first);
-				type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
+				const type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
 				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
 				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
 				assert(types.get_structdecl(tmp2));
@@ -10795,8 +10792,7 @@
 					}
 				// forward-declare
 				//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first);
-				type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,tmp);
+				const type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
 				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
 				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
 				assert(types.get_structdecl(tmp2));
@@ -10821,9 +10817,8 @@
 					}
 				else{	// definition
 						//! \test zcc/decl.C99/Pass_union_def.h
-					tmp2 = new C_union_struct_def(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 					//! \todo record field structure, etc.
-					const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,tmp2);
+					const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_union);
 					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
 					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
 					assert(types.get_C_structdef(tmp3));
@@ -10849,9 +10844,8 @@
 					}
 				else{	// definition
 						//! \test zcc/decl.C99/Pass_struct_def.h
-					tmp2 = new C_union_struct_def(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 					//! \todo record field structure, etc.
-					const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,tmp2);
+					const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_struct);
 					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
 					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
 					assert(types.get_C_structdef(tmp3));
@@ -11104,6 +11098,7 @@
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// check naked declarations first; handle namespaces later
+		//! \bug indentation fixup needed (stage 3)
 //		if (NULL==active_namespace)
 //			{
 			if (is_C99_named_specifier(src.data<0>()[i],"union"))
@@ -11237,9 +11232,8 @@
 				free(namespace_name);
 				//! \test zcc\decl.C99\Pass_enum_def.hpp
 				// enum-specifier doesn't have a specific declaration mode
-				//! \todo fix up the fully-qualified name in the enum_def
-				enum_def* tmp2 = new enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-				types.register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp2);
+				const type_system::type_index tmp2 = types.register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+				assert(types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 				if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
 					{
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
@@ -11249,9 +11243,7 @@
 			else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-				//! \todo fix up the fully-qualified name in the enum_def
-				enum_def* tmp = new enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-				types.register_enum_def_CPP("<unknown>",active_namespace,tmp);
+				types.register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 				if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
 					{
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
@@ -11318,8 +11310,7 @@
 					// forward-declare
 					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 					//! \todo fix up fully-qualified name
-					union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first);
-					const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp);
+					const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
 					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
 					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
 					assert(types.get_structdecl(tmp2));
@@ -11344,8 +11335,7 @@
 					// forward-declare
 					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 					//! \todo fix up fully-qualified name
-					union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first);
-					const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp);
+					const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
 					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
 					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
 					assert(types.get_structdecl(tmp2));
@@ -11370,8 +11360,7 @@
 					// forward-declare
 					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
 					//! \todo fix up fully-qualified name
-					union_struct_decl* tmp = new union_struct_decl(union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].token.first);
-					const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp);
+					const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
 					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
 					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
 					assert(types.get_structdecl(tmp2));
@@ -11399,10 +11388,8 @@
 						}
 					else{	// definition
 							//! \test zcc/decl.C99/Pass_union_def.hpp
-						tmp2 = new C_union_struct_def(union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 						//! \todo record field structure, etc.
-						//! \todo fix up fully-qualified name
-						const type_system::type_index tmp3 = types.register_C_structdef_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp2);
+						const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_union);
 						assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
 						assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
 						assert(types.get_C_structdef(tmp3));
@@ -11431,10 +11418,8 @@
 						}
 					else{	// definition
 							//! \test zcc/decl.C99/Pass_struct_def.hpp
-						tmp2 = new C_union_struct_def(union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 						//! \todo record field structure, etc.
-						//! \todo fix up fully-qualified name
-						const type_system::type_index tmp3 = types.register_C_structdef_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp2);
+						const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_struct);
 						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
 						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
 						assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
@@ -11463,10 +11448,8 @@
 						}
 					else{	// definition
 							//! \test zcc/decl.C99/Pass_class_def.hpp
-						tmp2 = new C_union_struct_def(union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 						//! \todo record field structure, etc.
-						//! \todo fix up fully-qualified name
-						const type_system::type_index tmp3 = types.register_C_structdef_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,tmp2);
+						const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_class);
 						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
 						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
 						assert(types.get_C_structdef(tmp3));

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2009-12-05 05:21:46 UTC (rev 295)
+++ trunk/POSIX.dep	2009-12-05 19:19:18 UTC (rev 296)
@@ -1,8 +1,8 @@
 OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o CPUInfo.o enum_type.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
-OBJECTS_Z_CPP_LINK_PRIORITY = str_aux.o CSupport.o type_system.o CPreproc.o errors.o z_cpp.o enum_type.o struct_type.o ParseTree.o type_spec.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_Z_CPP_LINK_PRIORITY = CSupport.o type_system.o str_aux.o CPreproc.o errors.o z_cpp.o enum_type.o struct_type.o ParseTree.o type_spec.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
 OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o CPUInfo.o enum_type.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = str_aux.o CSupport.o type_system.o CPreproc.o errors.o zcc.o enum_type.o struct_type.o ParseTree.o type_spec.o ZParser.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_ZCC_LINK_PRIORITY = CSupport.o type_system.o str_aux.o CPreproc.o errors.o zcc.o enum_type.o struct_type.o ParseTree.o type_spec.o ZParser.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
 # dependencies
 z_cpp.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_aux.hpp
@@ -14,7 +14,7 @@
 CPUInfo.o: CPUInfo.hpp unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 enum_type.o: enum_type.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp CPUInfo.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_aux.hpp
 struct_type.o: struct_type.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
-type_system.o: type_system.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
+type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp CPUInfo.hpp unsigned_fixed_int.hpp unsigned_aux.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 CSupport.o: CSupport.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2009-12-05 05:21:46 UTC (rev 295)
+++ trunk/type_system.cpp	2009-12-05 19:19:18 UTC (rev 296)
@@ -2,6 +2,7 @@
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
 #include "type_system.hpp"
+#include "enum_type.hpp"
 #include "struct_type.hpp"
 #include "Zaimoni.STL/search.hpp"
 #include "Zaimoni.STL/Pure.C/auto_int.h"
@@ -602,70 +603,72 @@
 	return register_functype(name,src);
 }
 
-type_system::type_index type_system::register_structdecl(const char* const alias, union_struct_decl*& src)
+type_system::type_index type_system::register_structdecl(const char* const alias, int keyword)
 {
 	assert(alias && *alias);
-	assert(src);
-	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_STRUCTDECL}};
-	tmp.third.first.second = src;
-
 	const size_t dynamic_types_size = dynamic_types.size();
 	const size_t dynamic_types_max_size = dynamic_types.max_size();
 	if (	dynamic_types_max_size<2+core_types_size
 		|| 	dynamic_types_max_size-(2+core_types_size)<dynamic_types_size)
 		FATAL("Host implementation limit exceeded: cannot record union/struct type used in program");
-	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
-	src = NULL;
+
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_STRUCTDECL}};
+	tmp.third.first.second = new union_struct_decl((union_struct_decl::keywords)keyword,alias);
+
+	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp))
+		{
+		delete tmp.third.first.second;
+		throw std::bad_alloc();
+		}
 	return dynamic_types_size+1+core_types_size;
 }
 
-type_system::type_index type_system::register_structdecl_CPP(const char* name, const char* const active_namespace, union_struct_decl*& src)
+type_system::type_index type_system::register_structdecl_CPP(const char* name, const char* const active_namespace, int keyword)
 {
 	assert(name && *name);
-	assert(src);
 
 	// use active namespace if present
 	if (active_namespace && *active_namespace)
 		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
 
-	return register_structdecl(name,src);
+	return register_structdecl(name,keyword);
 }
 
-type_system::type_index type_system::register_C_structdef(const char* const alias, C_union_struct_def*& src)
+type_system::type_index type_system::register_C_structdef(const char* const alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename, int keyword)
 {
 	assert(alias && *alias);
-	assert(src);
-	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_C_STRUCTDEF}};
-	tmp.third.first.third = src;
-
+	assert(src_filename && *src_filename);
 	const size_t dynamic_types_size = dynamic_types.size();
 	const size_t dynamic_types_max_size = dynamic_types.max_size();
 	if (	dynamic_types_max_size<2+core_types_size
 		|| 	dynamic_types_max_size-(2+core_types_size)<dynamic_types_size)
 		FATAL("Host implementation limit exceeded: cannot record union/struct type used in program");
+
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_C_STRUCTDEF}};
+	tmp.third.first.third = new C_union_struct_def((union_struct_decl::keywords)keyword,alias,logical_line,src_filename);
+
 	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
-	src = NULL;
 	return dynamic_types_size+1+core_types_size;
 }
 
-type_system::type_index type_system::register_C_structdef_CPP(const char* name, const char* const active_namespace, C_union_struct_def*& src)
+type_system::type_index type_system::register_C_structdef_CPP(const char* name, const char* const active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename, int keyword)
 {
 	assert(name && *name);
-	assert(src);
+	assert(src_filename && *src_filename);
 
 	// use active namespace if present
 	if (active_namespace && *active_namespace)
 		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
 
-	return register_C_structdef(name,src);
+	return register_C_structdef(name,logical_line,src_filename,keyword);
 }
 
-type_system::type_index type_system::register_enum_def(const char* const alias, enum_def*& src)
+type_system::type_index type_system::register_enum_def(const char* const alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename)
 {
 	assert(alias && *alias);
-	assert(src);
+	assert(src_filename && *src_filename);
 	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_ENUMDEF}};
-	tmp.third.first.fourth = src;
+	tmp.third.first.fourth = new enum_def(alias,logical_line,src_filename);
 
 	const size_t dynamic_types_size = dynamic_types.size();
 	const size_t dynamic_types_max_size = dynamic_types.max_size();
@@ -673,20 +676,19 @@
 		|| 	dynamic_types_max_size-(2+core_types_size)<dynamic_types_size)
 		FATAL("Host implementation limit exceeded: cannot record enum type used in program");
 	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
-	src = NULL;
 	return dynamic_types_size+1+core_types_size;
 }
 
-type_system::type_index type_system::register_enum_def_CPP(const char* name, const char* const active_namespace, enum_def*& src)
+type_system::type_index type_system::register_enum_def_CPP(const char* name, const char* const active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename)
 {
 	assert(name && *name);
-	assert(src);
+	assert(src_filename && *src_filename);
 
 	// use active namespace if present
 	if (active_namespace && *active_namespace)
 		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
 
-	return register_enum_def(name,src);
+	return register_enum_def(name,logical_line,src_filename);
 }
 
 const function_type* type_system::get_functype(type_system::type_index i)

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2009-12-05 05:21:46 UTC (rev 295)
+++ trunk/type_system.hpp	2009-12-05 19:19:18 UTC (rev 296)
@@ -99,12 +99,13 @@
 
 	type_index register_functype(const char* const alias, function_type*& src);
 	type_index register_functype_CPP(const char* name, const char* active_namespace, function_type*& src);
-	type_index register_structdecl(const char* const alias, union_struct_decl*& src);
-	type_index register_structdecl_CPP(const char* name, const char* active_namespace, union_struct_decl*& src);
-	type_index register_C_structdef(const char* const alias, C_union_struct_def*& src);
-	type_index register_C_structdef_CPP(const char* name, const char* active_namespace, C_union_struct_def*& src);
-	type_index register_enum_def(const char* const alias, enum_def*& src);
-	type_index register_enum_def_CPP(const char* name, const char* active_namespace, enum_def*& src);
+//	keyword actually should be type union_struct_decl::keywords, but that increases coupling unacceptably
+	type_index register_structdecl(const char* alias, int keyword);
+	type_index register_structdecl_CPP(const char* name, const char* active_namespace, int keyword);
+	type_index register_C_structdef(const char* alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename, int keyword);
+	type_index register_C_structdef_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename, int keyword);
+	type_index register_enum_def(const char* alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename);
+	type_index register_enum_def_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename);
 	const function_type* get_functype(type_index i);
 	const union_struct_decl* get_structdecl(type_index i);
 	const C_union_struct_def* get_C_structdef(type_index i);



From zaimoni at mail.berlios.de  Mon Dec  7 01:05:56 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 7 Dec 2009 01:05:56 +0100
Subject: [Zcplusplus-commits] r297 - trunk
Message-ID: <200912070005.nB705uwY000672@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-07 01:05:46 +0100 (Mon, 07 Dec 2009)
New Revision: 297

Modified:
   trunk/CSupport.cpp
   trunk/type_spec.cpp
   trunk/type_spec.hpp
Log:
be slightly nicer to vi in type_spec.hpp|cpp (qualifier_vector |-> q_vector)

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-12-05 19:19:18 UTC (rev 296)
+++ trunk/CSupport.cpp	2009-12-07 00:05:46 UTC (rev 297)
@@ -4828,7 +4828,7 @@
 			cancel_outermost_parentheses(src.c_array<0>()[i].c_array<1>()[0]);
 			cancel_outermost_parentheses(src.c_array<0>()[i].c_array<0>()[0]);
 			src.type_code.set_type(C_TYPE::NOT_VOID);
-			src.c_array<0>()[i].type_code.qualifier_vector.second[0] |= type_spec::lvalue;
+			src.c_array<0>()[i].type_code.q_vector.second[0] |= type_spec::lvalue;
 			assert(is_array_deref(src.data<0>()[i]));
 			return true;
 			};

Modified: trunk/type_spec.cpp
===================================================================
--- trunk/type_spec.cpp	2009-12-05 19:19:18 UTC (rev 296)
+++ trunk/type_spec.cpp	2009-12-07 00:05:46 UTC (rev 297)
@@ -11,9 +11,9 @@
 	static_array_size = _size;
 	if (0==_size) return;
 	if (sizeof(unsigned char*)<=pointer_power_after_array_decay())
-		qualifier_vector.first[0] |= lvalue;
+		q_vector.first[0] |= lvalue;
 	else
-		qualifier_vector.second[0] |= lvalue;
+		q_vector.second[0] |= lvalue;
 }
 
 void type_spec::set_pointer_power(size_t _size)
@@ -34,10 +34,10 @@
 		memset(extent_vector+pointer_power,0,sizeof(uintmax_t)*(_size-pointer_power));
 		if (NULL!=tmp_first)
 			{
-			memcpy(tmp_first,sizeof(unsigned char*)>old_ptr_power ? qualifier_vector.second : qualifier_vector.first,old_ptr_power+1);
+			memcpy(tmp_first,sizeof(unsigned char*)>old_ptr_power ? q_vector.second : q_vector.first,old_ptr_power+1);
 			size_t i = old_ptr_power;
-			while(i<new_ptr_power) qualifier_vector.first[i++] = lvalue;
-			qualifier_vector.first[new_ptr_power] = '\0';
+			while(i<new_ptr_power) q_vector.first[i++] = lvalue;
+			q_vector.first[new_ptr_power] = '\0';
 			}
 		};
 	if (sizeof(unsigned char*)>old_ptr_power)
@@ -45,30 +45,30 @@
 		if (sizeof(unsigned char*)>new_ptr_power)
 			{
 			if (shrinking)
-				memset(qualifier_vector.second+new_ptr_power,0,old_ptr_power-new_ptr_power);
+				memset(q_vector.second+new_ptr_power,0,old_ptr_power-new_ptr_power);
 			else{
 				size_t i = old_ptr_power;
-				while(i<new_ptr_power) qualifier_vector.second[i++] = lvalue;
-				qualifier_vector.second[new_ptr_power] = '\0';
+				while(i<new_ptr_power) q_vector.second[i++] = lvalue;
+				q_vector.second[new_ptr_power] = '\0';
 				}
 			}
 		else
-			qualifier_vector.first = tmp_first;
+			q_vector.first = tmp_first;
 		}
 	else if (sizeof(unsigned char*)>new_ptr_power)
 		{
 		unsigned char tmp[sizeof(unsigned char*)];
-		memcpy(tmp,qualifier_vector.first,new_ptr_power+1);
-		free(qualifier_vector.first);
-		memset(qualifier_vector.second,0,sizeof(unsigned char*));
-		memcpy(qualifier_vector.second,tmp,new_ptr_power+1);
+		memcpy(tmp,q_vector.first,new_ptr_power+1);
+		free(q_vector.first);
+		memset(q_vector.second,0,sizeof(unsigned char*));
+		memcpy(q_vector.second,tmp,new_ptr_power+1);
 		}
 	else{
 		if (shrinking)
-			ZAIMONI_PASSTHROUGH_ASSERT(zaimoni::_resize(qualifier_vector.first,new_ptr_power+1));
+			ZAIMONI_PASSTHROUGH_ASSERT(zaimoni::_resize(q_vector.first,new_ptr_power+1));
 		else{
-			free(qualifier_vector.first);
-			qualifier_vector.first = tmp_first;
+			free(q_vector.first);
+			q_vector.first = tmp_first;
 			}
 		}
 	pointer_power = _size;
@@ -90,9 +90,9 @@
 
 	const size_t new_ptr_power = dest.pointer_power_after_array_decay();
 	if (sizeof(unsigned char*)<=new_ptr_power)
-		memmove(dest.qualifier_vector.first,src.qualifier_vector.first,new_ptr_power+1);
+		memmove(dest.q_vector.first,src.q_vector.first,new_ptr_power+1);
 	else
-		memmove(dest.qualifier_vector.second,src.qualifier_vector.second,new_ptr_power+1);
+		memmove(dest.q_vector.second,src.q_vector.second,new_ptr_power+1);
 	if (0<dest.pointer_power) memmove(dest.extent_vector,src.extent_vector,sizeof(uintmax_t)*dest.pointer_power);
 }
 
@@ -105,28 +105,28 @@
 		if (0== --pointer_power)
 			{
 			FREE_AND_NULL(extent_vector);
-			qualifier_vector.second[old_ptr_power] = '\0';
-			assert(lvalue & qualifier_vector.second[old_ptr_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
+			q_vector.second[old_ptr_power] = '\0';
+			assert(lvalue & q_vector.second[old_ptr_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
 			}
 		else if (sizeof(unsigned char*)==old_ptr_power)
 			{
 			unsigned char tmp[4];
-			memcpy(tmp,qualifier_vector.first,sizeof(unsigned char*));
-			free(qualifier_vector.first);
-			memcpy(qualifier_vector.second,tmp,sizeof(unsigned char*));
-			assert(lvalue & qualifier_vector.second[old_ptr_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
+			memcpy(tmp,q_vector.first,sizeof(unsigned char*));
+			free(q_vector.first);
+			memcpy(q_vector.second,tmp,sizeof(unsigned char*));
+			assert(lvalue & q_vector.second[old_ptr_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
 			}
 		else{
-			qualifier_vector.first[old_ptr_power] = '\0';
-			assert(lvalue & qualifier_vector.first[old_ptr_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
+			q_vector.first[old_ptr_power] = '\0';
+			assert(lvalue & q_vector.first[old_ptr_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
 			}
 		return true;
 		}
 	else if (0<static_array_size)
 		{
 		static_array_size = 0;
-		qualifier_vector.second[1] = '\0';
-		assert(lvalue & qualifier_vector.second[0]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
+		q_vector.second[1] = '\0';
+		assert(lvalue & q_vector.second[0]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
 		return true;
 		};
 	return false;
@@ -137,7 +137,7 @@
 	base_type_index = 0;
 	pointer_power = 0;
 	static_array_size = 0;
-	memset(qualifier_vector.second,0,sizeof(qualifier_vector.second));
+	memset(q_vector.second,0,sizeof(q_vector.second));
 	extent_vector = NULL;
 }
 
@@ -148,12 +148,12 @@
 		FREE_AND_NULL(extent_vector);
 		if (sizeof(unsigned char*)<=pointer_power_after_array_decay())
 			{
-			free(qualifier_vector.first);
-			memset(qualifier_vector.second,0,sizeof(qualifier_vector.second));
+			free(q_vector.first);
+			memset(q_vector.second,0,sizeof(q_vector.second));
 			}
 		}
 	else
-		qualifier_vector.second[0] = '\0';
+		q_vector.second[0] = '\0';
 	base_type_index = 0;
 	pointer_power = 0;
 	static_array_size = 0;
@@ -166,12 +166,12 @@
 		FREE_AND_NULL(extent_vector);
 		if (sizeof(unsigned char*)<=pointer_power_after_array_decay())
 			{
-			free(qualifier_vector.first);
-			memset(qualifier_vector.second,0,sizeof(qualifier_vector.second));
+			free(q_vector.first);
+			memset(q_vector.second,0,sizeof(q_vector.second));
 			}
 		}
 	else
-		qualifier_vector.second[0] = '\0';
+		q_vector.second[0] = '\0';
 	base_type_index = _base_type_index;
 	pointer_power = 0;
 	static_array_size = 0;
@@ -182,7 +182,7 @@
 	return 	base_type_index==rhs.base_type_index
 		&&	pointer_power==rhs.pointer_power
 		&& 	static_array_size==rhs.static_array_size
-		&& (sizeof(unsigned char*)<=pointer_power_after_array_decay() ? !memcmp(qualifier_vector.first,rhs.qualifier_vector.first,pointer_power_after_array_decay()+1) : !memcmp(qualifier_vector.second,rhs.qualifier_vector.second,pointer_power_after_array_decay()+1))
+		&& (sizeof(unsigned char*)<=pointer_power_after_array_decay() ? !memcmp(q_vector.first,rhs.q_vector.first,pointer_power_after_array_decay()+1) : !memcmp(q_vector.second,rhs.q_vector.second,pointer_power_after_array_decay()+1))
 		&& (0==pointer_power || !memcmp(extent_vector,rhs.extent_vector,sizeof(uintmax_t)*pointer_power));
 }
 

Modified: trunk/type_spec.hpp
===================================================================
--- trunk/type_spec.hpp	2009-12-05 19:19:18 UTC (rev 296)
+++ trunk/type_spec.hpp	2009-12-07 00:05:46 UTC (rev 297)
@@ -28,7 +28,7 @@
 	size_t pointer_power;		// use wrappers for altering this (affects valid memory representations) [implement]
 	size_t static_array_size;	// C-ish, but mitigates bloating the type manager; use wrappers for altering this [implement]
 
-	zaimoni::union_pair<unsigned char*,unsigned char[sizeof(unsigned char*)]> qualifier_vector;
+	zaimoni::union_pair<unsigned char*,unsigned char[sizeof(unsigned char*)]> q_vector;	// q(ualifier)_vector
 	uintmax_t* extent_vector;
 
 	enum typetrait_list {
@@ -44,8 +44,8 @@
 	void set_static_array_size(size_t _size);
 	void set_pointer_power(size_t _size);	// ACID, throws std::bad_alloc on failure
 	bool dereference();
-	unsigned char& qualifier(size_t i) {return sizeof(unsigned char*)>pointer_power_after_array_decay() ? qualifier_vector.second[i] : qualifier_vector.first[i];};
-	template<size_t i> unsigned char& qualifier() {return sizeof(unsigned char*)>pointer_power_after_array_decay() ? qualifier_vector.second[i] : qualifier_vector.first[i];}
+	unsigned char& qualifier(size_t i) {return sizeof(unsigned char*)>pointer_power_after_array_decay() ? q_vector.second[i] : q_vector.first[i];};
+	template<size_t i> unsigned char& qualifier() {return sizeof(unsigned char*)>pointer_power_after_array_decay() ? q_vector.second[i] : q_vector.first[i];}
 
 	void clear();	// XXX should be constructor; good way to leak memory in other contexts
 	void destroy();	// XXX should be destructor



From zaimoni at mail.berlios.de  Mon Dec  7 02:09:13 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 7 Dec 2009 02:09:13 +0100
Subject: [Zcplusplus-commits] r298 - trunk
Message-ID: <200912070109.nB719DlN003082@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-07 02:09:09 +0100 (Mon, 07 Dec 2009)
New Revision: 298

Modified:
   trunk/ParseTree.cpp
Log:
theoretical ISO-mode fix; be nicer to vi

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2009-12-07 00:05:46 UTC (rev 297)
+++ trunk/ParseTree.cpp	2009-12-07 01:09:09 UTC (rev 298)
@@ -90,7 +90,7 @@
 #ifdef ZAIMONI_FORCE_ISO
 static void _destroy(zaimoni::POD_pair<parse_tree*,size_t>& target)
 {
-	if (NULL!=target)
+	if (NULL!=target.first)
 		{
 		size_t i = target.second;
 		do	target.first[--i].destroy();
@@ -130,25 +130,25 @@
 	size_t i = size<0>();
 	bool is_constant = true;
 	bool is_invalid = false;
-	flags &= parse_tree::RESERVED_MASK;	// just in case
+	flags &= RESERVED_MASK;	// just in case
 	while(0<i)
 		{
-		if (!(parse_tree::CONSTANT_EXPRESSION & data<0>()[--i].flags)) is_constant = false;
-		if (parse_tree::INVALID & data<0>()[i].flags) is_invalid = true;
+		if (!(CONSTANT_EXPRESSION & data<0>()[--i].flags)) is_constant = false;
+		if (INVALID & data<0>()[i].flags) is_invalid = true;
 		};
 	i = size<1>();
 	while(0<i)
 		{
-		if (!(parse_tree::CONSTANT_EXPRESSION & data<1>()[--i].flags)) is_constant = false;
-		if (parse_tree::INVALID & data<1>()[i].flags) is_invalid = true;
+		if (!(CONSTANT_EXPRESSION & data<1>()[--i].flags)) is_constant = false;
+		if (INVALID & data<1>()[i].flags) is_invalid = true;
 		};
 	i = size<2>();
 	while(0<i)
 		{
-		if (!(parse_tree::CONSTANT_EXPRESSION & data<2>()[--i].flags)) is_constant = false;
-		if (parse_tree::INVALID & data<2>()[i].flags) is_invalid = true;
+		if (!(CONSTANT_EXPRESSION & data<2>()[--i].flags)) is_constant = false;
+		if (INVALID & data<2>()[i].flags) is_invalid = true;
 		};
-	flags |= parse_tree::CONSTANT_EXPRESSION*is_constant+parse_tree::INVALID*is_invalid;
+	flags |= CONSTANT_EXPRESSION*is_constant+INVALID*is_invalid;
 }
 
 bool
@@ -276,65 +276,65 @@
 #define USER_MASK (ULONG_MAX-((1U<<parse_tree::PREDEFINED_STRICT_UB)-1))
 	const lex_flags my_rank = src.flags & USER_MASK;
 	bool need_parens = (1==src.size<1>()) ? my_rank>(src.data<1>()->flags & USER_MASK) : false;
-	bool need_space = false;
+	bool sp = false;	// "need space here"
 	if (need_parens) INC_INFORM('(');
 	size_t i = 0;
 	while(src.size<1>()>i)
 		{
-		if (need_space) INC_INFORM(' ');
-		need_space = !(src.data<1>()[i].flags & parse_tree::GOOD_LINE_BREAK);
+		if (sp) INC_INFORM(' ');
+		sp = !(src.data<1>()[i].flags & parse_tree::GOOD_LINE_BREAK);
 		INC_INFORM(src.data<1>()[i++]);
 		}
 	if (need_parens)
 		{
 		INC_INFORM(')');
-		need_space = false;
+		sp = false;
 		};
 	// first index token
 	if (NULL!=src.index_tokens[0].token.first)
 		{
-		if (need_space) INC_INFORM(' ');
+		if (sp) INC_INFORM(' ');
 		INC_INFORM(src.index_tokens[0].token.first,src.index_tokens[0].token.second);
-		need_space = true;
+		sp = true;
 		}
 	// infix data
 	need_parens = (1==src.size<0>()) ? my_rank>(src.data<0>()->flags & USER_MASK) : false;
 	if (need_parens)
 		{
 		INC_INFORM('(');
-		need_space = false;
+		sp = false;
 		}
 	i = 0;
 	while(src.size<0>()>i)
 		{
-		if (need_space) INC_INFORM(' ');
-		need_space = !(src.data<0>()[i].flags & parse_tree::GOOD_LINE_BREAK);
+		if (sp) INC_INFORM(' ');
+		sp = !(src.data<0>()[i].flags & parse_tree::GOOD_LINE_BREAK);
 		INC_INFORM(src.data<0>()[i++]);
 		}
 	if (need_parens)
 		{
 		INC_INFORM(')');
-		need_space = false;
+		sp = false;
 		};
 	// second index token
 	if (NULL!=src.index_tokens[1].token.first)
 		{
-		if (need_space) INC_INFORM(' ');
+		if (sp) INC_INFORM(' ');
 		INC_INFORM(src.index_tokens[1].token.first,src.index_tokens[1].token.second);
-		need_space = true;
+		sp = true;
 		}
 	// postfix data
 	need_parens = (1==src.size<2>()) ? my_rank>(src.data<2>()->flags & USER_MASK) : false;
 	if (need_parens)
 		{
 		INC_INFORM('(');
-		need_space = false;
+		sp = false;
 		}
 	i = 0;
 	while(src.size<2>()>i)
 		{
-		if (need_space) INC_INFORM(' ');
-		need_space = !(src.data<2>()[i].flags & parse_tree::GOOD_LINE_BREAK);
+		if (sp) INC_INFORM(' ');
+		sp = !(src.data<2>()[i].flags & parse_tree::GOOD_LINE_BREAK);
 		INC_INFORM(src.data<2>()[i++]);
 		}
 	if (need_parens) INC_INFORM(')');



From zaimoni at mail.berlios.de  Mon Dec  7 02:23:32 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 7 Dec 2009 02:23:32 +0100
Subject: [Zcplusplus-commits] r299 - trunk
Message-ID: <200912070123.nB71NWOO004080@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-07 02:23:29 +0100 (Mon, 07 Dec 2009)
New Revision: 299

Modified:
   trunk/struct_type.cpp
Log:
theoretical fix

Modified: trunk/struct_type.cpp
===================================================================
--- trunk/struct_type.cpp	2009-12-07 01:09:09 UTC (rev 298)
+++ trunk/struct_type.cpp	2009-12-07 01:23:29 UTC (rev 299)
@@ -39,8 +39,6 @@
 
 const C_union_struct_def& C_union_struct_def::operator=(const C_union_struct_def& src)
 {
-	zaimoni::autovalarray_ptr_throws<type_spec> data_field_spec;
-	
 	const size_t src_field_count = src.data_field_spec.size();
 	const size_t now_field_count = data_field_spec.size();
 	if (0==src_field_count)



From zaimoni at mail.berlios.de  Mon Dec  7 02:40:06 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 7 Dec 2009 02:40:06 +0100
Subject: [Zcplusplus-commits] r300 - trunk
Message-ID: <200912070140.nB71e6ld004773@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-07 02:40:00 +0100 (Mon, 07 Dec 2009)
New Revision: 300

Removed:
   trunk/enum_type.cpp
Modified:
   trunk/MakeMake.cfg
   trunk/POSIX.dep
   trunk/enum_type.hpp
Log:
remove never-to-be-used name-value mapping from enum_type

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2009-12-07 01:23:29 UTC (rev 299)
+++ trunk/MakeMake.cfg	2009-12-07 01:40:00 UTC (rev 300)
@@ -1,6 +1,6 @@
 ########
-ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','filesystem','CPUInfo','enum_type','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
-				'zcc':('zcc','errors','langroute','AtomicString','str_aux','filesystem','CPUInfo','enum_type','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
+ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','filesystem','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
+				'zcc':('zcc','errors','langroute','AtomicString','str_aux','filesystem','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
 MainPrograms = ['z_cpp','zcc']
 
 # process control

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2009-12-07 01:23:29 UTC (rev 299)
+++ trunk/POSIX.dep	2009-12-07 01:40:00 UTC (rev 300)
@@ -1,8 +1,8 @@
-OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o CPUInfo.o enum_type.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
-OBJECTS_Z_CPP_LINK_PRIORITY = CSupport.o type_system.o str_aux.o CPreproc.o errors.o z_cpp.o enum_type.o struct_type.o ParseTree.o type_spec.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
+OBJECTS_Z_CPP_LINK_PRIORITY = struct_type.o ParseTree.o CSupport.o type_spec.o type_system.o str_aux.o CPreproc.o errors.o z_cpp.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
-OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o CPUInfo.o enum_type.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = CSupport.o type_system.o str_aux.o CPreproc.o errors.o zcc.o enum_type.o struct_type.o ParseTree.o type_spec.o ZParser.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
+OBJECTS_ZCC_LINK_PRIORITY = struct_type.o ParseTree.o CSupport.o type_spec.o type_system.o str_aux.o CPreproc.o errors.o zcc.o ZParser.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o CPreproc_autogen.o unsigned_aux.o AtomicString.o CPUInfo.o langroute.o load_src.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
 # dependencies
 z_cpp.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_aux.hpp
@@ -12,9 +12,8 @@
 str_aux.o: str_aux.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 filesystem.o: filesystem.h Zaimoni.STL/Compiler.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h
 CPUInfo.o: CPUInfo.hpp unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
-enum_type.o: enum_type.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp CPUInfo.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_aux.hpp
 struct_type.o: struct_type.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
-type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp CPUInfo.hpp unsigned_fixed_int.hpp unsigned_aux.hpp
+type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 CSupport.o: CSupport.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp

Deleted: trunk/enum_type.cpp
===================================================================
--- trunk/enum_type.cpp	2009-12-07 01:23:29 UTC (rev 299)
+++ trunk/enum_type.cpp	2009-12-07 01:40:00 UTC (rev 300)
@@ -1,36 +0,0 @@
-// enum_type.cpp
-
-#include "enum_type.hpp"
-
-const enum_def& enum_def::operator=(const enum_def& src)
-{
-	if (src.enum_names.empty())
-		{
-		enum_names.reset();
-		enum_values.reset();
-		}
-	else if (src.enum_names.size()<=enum_names.size())
-		{
-		enum_names = src.enum_names;
-		enum_values = src.enum_values;
-		}
-	else{
-		zaimoni::autovalarray_ptr_throws<unsigned_fixed_int<VM_MAX_BIT_PLATFORM> > tmp_enum_values(src.enum_values);
-		enum_names = src.enum_names;
-		tmp_enum_values.MoveInto(enum_values);
-		}
-	_tag = src._tag;
-	_logical_line = src._logical_line;
-	_src_filename = src._src_filename;
-	represent_as = src.represent_as;
-	assert(syntax_ok());
-	return *this;
-}
-
-#ifndef NDEBUG
-bool enum_def::syntax_ok() const
-{
-	return enum_names.size()==enum_values.size();
-}
-#endif
-

Modified: trunk/enum_type.hpp
===================================================================
--- trunk/enum_type.hpp	2009-12-07 01:23:29 UTC (rev 299)
+++ trunk/enum_type.hpp	2009-12-07 01:40:00 UTC (rev 300)
@@ -3,8 +3,6 @@
 #define ENUM_TYPE_HPP 1
 
 #include "Zaimoni.STL/POD.hpp"
-#include "Zaimoni.STL/AutoPtr.hpp"
-#include "CPUInfo.hpp"
 
 class enum_def
 {
@@ -13,21 +11,19 @@
 	zaimoni::POD_pair<size_t,size_t> _logical_line;
 	const char* _src_filename;
 public:
-	zaimoni::weakautovalarray_ptr_throws<const char*> enum_names;	// using registered strings
-	zaimoni::autovalarray_ptr_throws<unsigned_fixed_int<VM_MAX_BIT_PLATFORM> > enum_values;
 	unsigned char represent_as;
 
-	enum_def(const char* tag,zaimoni::POD_pair<size_t,size_t> logical_line,const char* src_filename): _tag((tag && *tag ? tag : NULL)),_logical_line(logical_line),_src_filename((src_filename && *src_filename ? src_filename : NULL)),represent_as(0) {};
-	// default ok for: copy constructor, destructor
-	const enum_def& operator=(const enum_def& src);	// ACID/strong guarantee
+	enum_def(const char* tag,zaimoni::POD_pair<size_t,size_t> logical_line,const char* src_filename):
+		_tag((tag && *tag ? tag : NULL)),
+		_logical_line(logical_line),
+		_src_filename((src_filename && *src_filename ? src_filename : NULL)),
+		represent_as(0) {};
+	// default ok for: copy constructor, destructor, operator=
 
 	// accessors are to make editing difficult
 	const char* tag() const {return _tag;};
 	const char* filename() const {return _src_filename;};
 	zaimoni::POD_pair<size_t,size_t> loc() const {return _logical_line;};
-#ifndef NDEBUG
-	bool syntax_ok() const;
-#endif
 };
 
 #endif



From zaimoni at mail.berlios.de  Mon Dec  7 03:34:19 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 7 Dec 2009 03:34:19 +0100
Subject: [Zcplusplus-commits] r301 - trunk
Message-ID: <200912070234.nB72YJsF007761@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-07 03:34:13 +0100 (Mon, 07 Dec 2009)
New Revision: 301

Modified:
   trunk/errors.cpp
   trunk/errors.hpp
   trunk/z_cpp.cpp
   trunk/zcc.cpp
Log:
minor code cleanup

Modified: trunk/errors.cpp
===================================================================
--- trunk/errors.cpp	2009-12-07 01:40:00 UTC (rev 300)
+++ trunk/errors.cpp	2009-12-07 02:34:13 UTC (rev 301)
@@ -80,3 +80,21 @@
 	INC_INFORM(": ");
 }
 
+void enforce_mutually_exclusive_exhaustive_options(void)
+{
+	// platform-specific goo
+	// for now, go with Intel
+	// this should be overridable by command-line options
+	// deal with the int-format options
+	{	// handle integer representation trait options
+	const unsigned int int_opt_count = bool_options[boolopt::int_sign_magnitude]+bool_options[boolopt::int_ones_complement]+bool_options[boolopt::int_twos_complement];
+	if (2<=int_opt_count) FATAL("error: the integer format options are mutually exclusive");
+	if (0==int_opt_count) bool_options[boolopt::int_twos_complement] = true;	// go with intel for now
+	}
+	{	// handle char as signed/unsigned char
+	const unsigned int char_opt_count = bool_options[boolopt::char_is_signed]+bool_options[boolopt::char_is_unsigned];
+	if (2<=char_opt_count) FATAL("error: the character format options are mutually exclusive");
+	if (0==char_opt_count) bool_options[boolopt::char_is_unsigned] = true;	// unsigned makes our life easier
+	}
+}
+

Modified: trunk/errors.hpp
===================================================================
--- trunk/errors.hpp	2009-12-07 01:40:00 UTC (rev 300)
+++ trunk/errors.hpp	2009-12-07 02:34:13 UTC (rev 301)
@@ -128,5 +128,6 @@
 int recognize_parameter_option(const char* const x,const zaimoni::POD_triple<const char*, size_t, const char*>* option_map,size_t j);
 
 void message_header(const char* const filename, size_t line_number);
+void enforce_mutually_exclusive_exhaustive_options(void);
 
 #endif

Modified: trunk/z_cpp.cpp
===================================================================
--- trunk/z_cpp.cpp	2009-12-07 01:40:00 UTC (rev 300)
+++ trunk/z_cpp.cpp	2009-12-07 02:34:13 UTC (rev 301)
@@ -65,22 +65,25 @@
 
 void guess_lang_from_filename(const char* const x)
 {
-	if (zaimoni::is_empty_string(x)) return;
+	if (!x || !*x) return;
 	if (NULL!=string_options[stringopt::lang]) return;
 	const size_t name_len = strlen(x);
 	if (2<=name_len && '.'==x[name_len-2])
 		{
-		if ('c'==x[name_len-1] || 'h'==x[name_len-1] || 'C'==x[name_len-1] || 'H'==x[name_len-1])
+		if (	'c'==x[name_len-1]
+			||  'h'==x[name_len-1]
+			||  'C'==x[name_len-1]
+			||  'H'==x[name_len-1])
 			interpret_stringopt_lang("C");
 		return;
 		}
 	if (4<=name_len && '.'==x[name_len-4])
 		{
 		if (	!stricmp(x+(name_len-3),"hpp")
-			||	!stricmp(x+(name_len-3),"hxx")
+			||  !stricmp(x+(name_len-3),"hxx")
 			||  !stricmp(x+(name_len-3),"h++")
-			||	!stricmp(x+(name_len-3),"cpp")
-			||	!stricmp(x+(name_len-3),"cxx")
+			||  !stricmp(x+(name_len-3),"cpp")
+			||  !stricmp(x+(name_len-3),"cxx")
 			||  !stricmp(x+(name_len-3),"c++"))
 			interpret_stringopt_lang("C++");
 		return;
@@ -116,19 +119,6 @@
 static string_opt_handler* option_handler_int[MAX_OPT_STRING]
 	=	{default_handler(int_option(0))};
 
-#if 0
-// include path goo
-char** local_paths = NULL;
-char** system_paths = NULL;
-
-// note: stdlib.h; microsoft _fullpath, POSIX realpath
-// _fullpath(buf,relpath,sizeof(buf))
-// realpath(buf,relpath)
-
-const char* const * const default_local_paths = NULL;
-const char* const * const default_system_paths = NULL;
-#endif
-
 static bool process_options(const size_t argc, char* argv[])
 {
 	size_t last_arg_used_in_option = 0;
@@ -241,22 +231,8 @@
 	bootstrap_filesystem(argv[0]);
 	const bool last_arg_used_in_option = process_options(argc,argv);
 	if (!last_arg_used_in_option) guess_lang_from_filename(argv[argc-1]);
+	enforce_mutually_exclusive_exhaustive_options();
 
-	// platform-specific goo
-	// for now, go with Intel
-	// this should be overridable by command-line options
-	// deal with the int-format options
-	{	// handle integer representation trait options
-	const unsigned int int_opt_count = bool_options[boolopt::int_sign_magnitude]+bool_options[boolopt::int_ones_complement]+bool_options[boolopt::int_twos_complement];
-	if (2<=int_opt_count) FATAL("error: the integer format options are mutually exclusive");
-	if (0==int_opt_count) bool_options[boolopt::int_twos_complement] = true;	// go with intel for now
-	}
-	{	// handle char as signed/unsigned char
-	const unsigned int char_opt_count = bool_options[boolopt::char_is_signed]+bool_options[boolopt::char_is_unsigned];
-	if (2<=char_opt_count) FATAL("error: the character format options are mutually exclusive");
-	if (0==char_opt_count) bool_options[boolopt::char_is_unsigned] = true;	// unsigned makes our life easier
-	}
-
 	// error count enforcement
 	zcc_errors.set_error_ub(int_options[intopt::error_ub]);
 

Modified: trunk/zcc.cpp
===================================================================
--- trunk/zcc.cpp	2009-12-07 01:40:00 UTC (rev 300)
+++ trunk/zcc.cpp	2009-12-07 02:34:13 UTC (rev 301)
@@ -69,22 +69,25 @@
 
 void guess_lang_from_filename(const char* const x)
 {
-	if (zaimoni::is_empty_string(x)) return;
+	if (!x || !*x) return;
 	if (NULL!=string_options[stringopt::lang]) return;
 	const size_t name_len = strlen(x);
 	if (2<=name_len && '.'==x[name_len-2])
 		{
-		if ('c'==x[name_len-1] || 'h'==x[name_len-1] || 'C'==x[name_len-1] || 'H'==x[name_len-1])
+		if (	'c'==x[name_len-1]
+			||  'h'==x[name_len-1]
+			||  'C'==x[name_len-1]
+			||  'H'==x[name_len-1])
 			interpret_stringopt_lang("C");
 		return;
 		}
 	if (4<=name_len && '.'==x[name_len-4])
 		{
 		if (	!stricmp(x+(name_len-3),"hpp")
-			||	!stricmp(x+(name_len-3),"hxx")
+			||  !stricmp(x+(name_len-3),"hxx")
 			||  !stricmp(x+(name_len-3),"h++")
-			||	!stricmp(x+(name_len-3),"cpp")
-			||	!stricmp(x+(name_len-3),"cxx")
+			||  !stricmp(x+(name_len-3),"cpp")
+			||  !stricmp(x+(name_len-3),"cxx")
 			||  !stricmp(x+(name_len-3),"c++"))
 			interpret_stringopt_lang("C++");
 		return;
@@ -120,19 +123,6 @@
 static string_opt_handler* option_handler_int[MAX_OPT_STRING]
 	=	{default_handler(int_option(0))};
 
-#if 0
-// include path goo
-char** local_paths = NULL;
-char** system_paths = NULL;
-
-// note: stdlib.h; microsoft _fullpath, POSIX realpath
-// _fullpath(buf,relpath,sizeof(buf))
-// realpath(buf,relpath)
-
-const char* const * const default_local_paths = NULL;
-const char* const * const default_system_paths = NULL;
-#endif
-
 static bool process_options(const size_t argc, char* argv[])
 {
 	size_t last_arg_used_in_option = 0;
@@ -245,22 +235,8 @@
 	bootstrap_filesystem(argv[0]);
 	const bool last_arg_used_in_option = process_options(argc,argv);
 	if (!last_arg_used_in_option) guess_lang_from_filename(argv[argc-1]);
+	enforce_mutually_exclusive_exhaustive_options();
 
-	// platform-specific goo
-	// for now, go with Intel
-	// this should be overridable by command-line options
-	// deal with the int-format options
-	{	// handle integer representation trait options
-	const unsigned int int_opt_count = bool_options[boolopt::int_sign_magnitude]+bool_options[boolopt::int_ones_complement]+bool_options[boolopt::int_twos_complement];
-	if (2<=int_opt_count) FATAL("error: the integer format options are mutually exclusive");
-	if (0==int_opt_count) bool_options[boolopt::int_twos_complement] = true;	// go with intel for now
-	}
-	{	// handle char as signed/unsigned char
-	const unsigned int char_opt_count = bool_options[boolopt::char_is_signed]+bool_options[boolopt::char_is_unsigned];
-	if (2<=char_opt_count) FATAL("error: the character format options are mutually exclusive");
-	if (0==char_opt_count) bool_options[boolopt::char_is_unsigned] = true;	// unsigned makes our life easier
-	}
-
 	// error count enforcement
 	zcc_errors.set_error_ub(int_options[intopt::error_ub]);
 



From zaimoni at mail.berlios.de  Mon Dec  7 08:32:55 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 7 Dec 2009 08:32:55 +0100
Subject: [Zcplusplus-commits] r302 - trunk
Message-ID: <200912070732.nB77WtOF016409@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-07 08:32:47 +0100 (Mon, 07 Dec 2009)
New Revision: 302

Modified:
   trunk/CPreproc.cpp
Log:
mostly object file size reduction.  One vi readability fix, one theoretical overflow bug fix

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2009-12-07 02:34:13 UTC (rev 301)
+++ trunk/CPreproc.cpp	2009-12-07 07:32:47 UTC (rev 302)
@@ -272,16 +272,16 @@
 {
 	switch(lang_code)
 	{
-	case Lang::C:			{
-							macro_identifier_default = C99_macro_identifier_default;
-							macro_identifier_default_count = STATIC_SIZE(C99_macro_identifier_default);
-							break;
-							};
-	case Lang::CPlusPlus:	{
-							macro_identifier_default = CPP0x_macro_identifier_default;
-							macro_identifier_default_count = STATIC_SIZE(CPP0x_macro_identifier_default);
-							break;
-							};
+	case Lang::C: {
+			macro_identifier_default = C99_macro_identifier_default;
+			macro_identifier_default_count = STATIC_SIZE(C99_macro_identifier_default);
+			break;
+		};
+	case Lang::CPlusPlus: {
+			macro_identifier_default = CPP0x_macro_identifier_default;
+			macro_identifier_default_count = STATIC_SIZE(CPP0x_macro_identifier_default);
+			break;
+		};
 	default: FATAL("Invalid language code");
 	}
 	init_fixed_system_include_search();
@@ -844,24 +844,17 @@
 static unsigned int
 detect_hardcoded_system_header(const char* const look_for,size_t lang_code)
 {
-	// C,C++: limits.h is hardcoded
-	// C++: climits is hardcoded
-	if (	(!strcmp(look_for,"limits.h") && (Lang::C==lang_code || Lang::CPlusPlus==lang_code))
-		||	(!strcmp(look_for,"climits") && Lang::CPlusPlus==lang_code))
-		return 1;
-
-	// C,C++: stddef.h is hardcoded
-	// C++: cstddef is hardcoded
-	if (	(!strcmp(look_for,"stddef.h") && (Lang::C==lang_code || Lang::CPlusPlus==lang_code))
-		||	(!strcmp(look_for,"cstddef") && Lang::CPlusPlus==lang_code))
-		return 2;
-
-	// C,C++: stdint.h is hardcoded
-	// C++: cstdint is hardcoded
-	if (	(!strcmp(look_for,"stdint.h") && (Lang::C==lang_code || Lang::CPlusPlus==lang_code))
-		||	(!strcmp(look_for,"cstdint") && Lang::CPlusPlus==lang_code))
-		return 3;
-
+	switch(lang_code)
+	{
+	case Lang::CPlusPlus:	// C++ hard-coded system headers
+		if (!strcmp(look_for,"climits")) return 1;
+		if (!strcmp(look_for,"cstddef")) return 2;
+		if (!strcmp(look_for,"cstdint")) return 3;
+	case Lang::C:	// C, C++ hard-coded system headers
+		if (!strcmp(look_for,"limits.h")) return 1;
+		if (!strcmp(look_for,"stddef.h")) return 2;
+		if (!strcmp(look_for,"stdint.h")) return 3;
+	}
 	return 0;
 }
 
@@ -2129,32 +2122,22 @@
 	char buf[FILENAME_MAX];
 	// raw system include has minimal macro context, so don't worry about legality check
 
-	// C,C++: limits.h is hardcoded
-	// C++: climits is hardcoded
-	if (	(!strcmp(look_for,"limits.h") && (Lang::C==lang_code || Lang::CPlusPlus==lang_code))
-		||	(!strcmp(look_for,"climits") && Lang::CPlusPlus==lang_code))
-		{	// header is limits.h
+	switch(detect_hardcoded_system_header(look_for,lang_code))
+	{
+#ifndef NDEBUG
+	default: FATAL("detect_hardcoded_system_header() return value out of 0..3 range");
+#endif
+	case 1:	// header is limits.h/climits
 		create_limits_header(IncludeTokenList,look_for);	// not included yet
 		return true;
-		};
-
-	// C,C++: stddef.h is hardcoded
-	// C++: cstddef is hardcoded
-	if (	(!strcmp(look_for,"stddef.h") && (Lang::C==lang_code || Lang::CPlusPlus==lang_code))
-		||	(!strcmp(look_for,"cstddef") && Lang::CPlusPlus==lang_code))
-		{	// header is stddef.h
+	case 2:	// header is stddef.h/cstddef
 		create_stddef_header(IncludeTokenList,look_for);	// not included yet
 		return true;
-		};
-
-	// C,C++: stddef.h is hardcoded
-	// C++: cstddef is hardcoded
-	if (	(!strcmp(look_for,"stdint.h") && (Lang::C==lang_code || Lang::CPlusPlus==lang_code))
-		||	(!strcmp(look_for,"cstdint") && Lang::CPlusPlus==lang_code))
-		{	// header is stddef.h
+	case 3:	// header is stdint.h/cstdint
 		create_stdint_header(IncludeTokenList,look_for);	// not included yet
 		return true;
-		};
+	case 0:;
+	}
 
 	if (find_system_include(look_for, buf))
 		return load_raw_sourcefile(IncludeTokenList,buf);
@@ -2645,18 +2628,15 @@
 static void _construct_matched_pairs(const Token<char>& x, const autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized, autovalarray_ptr<POD_pair<size_t,size_t> >& pair_stack,const char l_match,const char r_match)
 {
 	POD_pair<size_t,size_t> depth = balanced_character_count(x.data(),pretokenized,l_match,r_match);	// pre-scan
-	size_t err_count = 0;
+	DEBUG_STATEMENT(size_t err_count = 0;)
 	if (0<depth.first && 0<depth.second)
 		{
 		// reality-check: balanced parentheses
-		autovalarray_ptr<size_t> lparen_fixedstack(depth.first);
-		autovalarray_ptr<POD_pair<size_t,size_t> > parenpair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
+		autovalarray_ptr_throws<size_t> lparen_fixedstack(depth.first);
+		autovalarray_ptr_throws<POD_pair<size_t,size_t> > parenpair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 		size_t balanced_paren = 0;
 		size_t i = 0;
 
-		if (lparen_fixedstack.empty()) throw std::bad_alloc();
-		if (parenpair_fixedstack.empty()) throw std::bad_alloc();
-
 		depth.first = 0;
 		depth.second = 0;
 		do	if (1==pretokenized[i].second)
@@ -2666,7 +2646,7 @@
 					if (0<depth.second)
 						{
 						depth.second = 0;
-						++err_count;
+						DEBUG_STATEMENT(++err_count;)
 						}
 					lparen_fixedstack[depth.first++] = i;
 					}
@@ -2682,7 +2662,7 @@
 					};
 				}
 		while(pretokenized.size() > ++i);
-		if (0==depth.first && 0==depth.second && 0==err_count)
+		if (0==depth.first && 0==depth.second DEBUG_STATEMENT(&& 0==err_count))
 			{
 			assert(parenpair_fixedstack.size()==balanced_paren);
 			parenpair_fixedstack.MoveInto(pair_stack);
@@ -2690,8 +2670,8 @@
 		};
 
 	assert(0==depth.first || 0==depth.second);
-	if (0<depth.second) ++err_count;
-	if (0<depth.first) ++err_count;
+	DEBUG_STATEMENT(if (0<depth.second) ++err_count;)
+	DEBUG_STATEMENT(if (0<depth.first) ++err_count;)
 	assert(0==err_count);
 }
 
@@ -2705,18 +2685,15 @@
 void construct_matched_pairs<'[',']'>(const Token<char>& x, const autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized, autovalarray_ptr<POD_pair<size_t,size_t> >& pair_stack)
 {
 	POD_pair<size_t,size_t> depth = balanced_character_count(x.data(),pretokenized,'[',']');	// pre-scan
-	size_t err_count = 0;
+	DEBUG_STATEMENT(size_t err_count = 0;)
 	if (0<depth.first && 0<depth.second)
 		{
 		// reality-check: balanced parentheses
-		autovalarray_ptr<size_t> lparen_fixedstack(depth.first);
-		autovalarray_ptr<POD_pair<size_t,size_t> > parenpair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
+		autovalarray_ptr_throws<size_t> lparen_fixedstack(depth.first);
+		autovalarray_ptr_throws<POD_pair<size_t,size_t> > parenpair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 		size_t balanced_paren = 0;
 		size_t i = 0;
 
-		if (lparen_fixedstack.empty()) throw std::bad_alloc();
-		if (parenpair_fixedstack.empty()) throw std::bad_alloc();
-
 		depth.first = 0;
 		depth.second = 0;
 		do	if 		(detect_C_left_bracket_op(x.data()+pretokenized[i].first,pretokenized[i].second))
@@ -2724,7 +2701,7 @@
 				if (0<depth.second)
 					{
 					depth.second = 0;
-					++err_count;
+					DEBUG_STATEMENT(++err_count;)
 					}
 				lparen_fixedstack[depth.first++] = i;
 				}
@@ -2739,7 +2716,7 @@
 					++depth.second;
 				}
 		while(pretokenized.size() > ++i);
-		if (0==depth.first && 0==depth.second && 0==err_count)
+		if (0==depth.first && 0==depth.second DEBUG_STATEMENT(&& 0==err_count))
 			{
 			assert(parenpair_fixedstack.size()==balanced_paren);
 			parenpair_fixedstack.MoveInto(pair_stack);
@@ -2747,8 +2724,8 @@
 		};
 
 	assert(0==depth.first || 0==depth.second);
-	if (0<depth.second) ++err_count;
-	if (0<depth.first) ++err_count;
+	DEBUG_STATEMENT(if (0<depth.second) ++err_count;)
+	DEBUG_STATEMENT(if (0<depth.first) ++err_count;)
 	assert(0==err_count);
 }
 
@@ -3467,9 +3444,8 @@
 	size_t var_origin = 0;
 	size_t offset = 1;
 	size_t count_args = 0;
-	assert(!arglist.empty());
-	assert('('==arglist.front());
 	assert(2<=arglist.size());
+	assert('('==arglist.front());
 	assert(')'==arglist.back());
 	if (2==arglist.size())
 		{
@@ -3529,7 +3505,7 @@
 CPreprocessor::dynamic_macro_replace_once(Token<char>& x, size_t& critical_offset, size_t token_len, const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<Token<char>*>& macros_object_expansion, const autovalarray_ptr<char*>& macros_function, const autovalarray_ptr<Token<char>*>& macros_function_arglist, const autovalarray_ptr<Token<char>*>& macros_function_expansion, autovalarray_ptr<char*>* const used_macro_stack)
 {
 	assert(x.size()>critical_offset);
-	assert(x.size()>=critical_offset+token_len);
+	assert(x.size()-critical_offset>=token_len);
 	assert(macros_object.size()==macros_object_expansion.size());
 	assert(macros_function.size()==macros_function_expansion.size());
 	const errr object_macro_index = binary_find(x.data()+critical_offset,token_len,macros_object);
@@ -4068,7 +4044,6 @@
 bool
 CPreprocessor::C99_VA_ARGS_flinch(const Token<char>& x, const size_t critical_offset) const
 {	//! \todo option to bypass this
-	assert(!x.empty());
 	assert(x.size()>critical_offset);
 	if (SIZE_MAX!=lang.lex_find(x.data()+critical_offset,x.size()-critical_offset,"__VA_ARGS__",sizeof("__VA_ARGS__")-1))
 		{



From zaimoni at mail.berlios.de  Wed Dec  9 00:58:34 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 9 Dec 2009 00:58:34 +0100
Subject: [Zcplusplus-commits] r303 - trunk
Message-ID: <200912082358.nB8NwY5x019268@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-09 00:58:29 +0100 (Wed, 09 Dec 2009)
New Revision: 303

Modified:
   trunk/CSupport.cpp
Log:
object file size reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-12-07 07:32:47 UTC (rev 302)
+++ trunk/CSupport.cpp	2009-12-08 23:58:29 UTC (rev 303)
@@ -260,10 +260,10 @@
 size_t LengthOfCIdentifier(const char* const x)
 {	//! \todo should handle universal character names
 	assert(NULL!=x);
-	if (!IsAlphabeticChar(*x) && '_'!=*x) return 0;
-	size_t Length = 1;
-	while(IsCIdentifierChar(x[Length])) Length++;
-	return Length;
+	const char* x2 = x;
+	if (IsAlphabeticChar(*x2) || '_'==*x2)
+		while(IsCIdentifierChar(*++x2));
+	return x2-x;
 }
 
 #if 0
@@ -306,7 +306,7 @@
 	size_t Length = 0;
 	if ('\''==*x)
 		Length = 1;
-	else if (0==strncmp(x,"L'",2))
+	else if ('L'==x[0] && '\''==x[1])
 		Length = 2;
 	if (0==Length) return 0;
 
@@ -329,24 +329,22 @@
 	size_t Length = 0;
 	if ('"'==*x)
 		Length = 1;
-	else if (0==strncmp(x,"L\"",2))
+	else if ('L'==x[0] && '"'==x[1])
 		Length = 2;
-	if (0<Length)
+	if (0==Length) return 0;
+
+	const char* base = x+Length;
+	const char* find_end = strpbrk(base,"\\\"\n");
+	while(NULL!=find_end)
 		{
-		const char* base = x+Length;
-		const char* find_end = strpbrk(base,"\\\"\n");
-		while(NULL!=find_end)
-			{
-			Length = find_end-x+1;
-			if ('"'==find_end[0]) return Length;
-			if ('\n'==find_end[0]) return Length-1;
-			if ('\0'==find_end[1]) return Length;
-			base = find_end+2;
-			find_end = ('\0'==base[0]) ? NULL : strpbrk(base,"\\\"\n");
-			};
-		return strlen(x);
-		}
-	return 0;
+		Length = find_end-x+1;
+		if ('"'==find_end[0]) return Length;
+		if ('\n'==find_end[0]) return Length-1;
+		if ('\0'==find_end[1]) return Length;
+		base = find_end+2;
+		find_end = ('\0'==base[0]) ? NULL : strpbrk(base,"\\\"\n");
+		};
+	return strlen(x);
 }
 
 #if 0
@@ -1217,10 +1215,8 @@
 	if (0<depth.first && 0<depth.second)
 		{
 		// reality-check: balanced parentheses
-		autovalarray_ptr<size_t> fixedstack(depth.first);
-		if (fixedstack.empty()) throw std::bad_alloc();
-		autovalarray_ptr<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
-		if (pair_fixedstack.empty()) throw std::bad_alloc();
+		autovalarray_ptr_throws<size_t> fixedstack(depth.first);
+		autovalarray_ptr_throws<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 
 		depth.first = 0;
 		depth.second = 0;
@@ -1289,10 +1285,8 @@
 	if (0<depth.first && 0<depth.second)
 		{
 		// reality-check: balanced parentheses
-		autovalarray_ptr<size_t> fixedstack(depth.first);
-		autovalarray_ptr<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
-		if (fixedstack.empty()) throw std::bad_alloc();
-		if (pair_fixedstack.empty()) throw std::bad_alloc();
+		autovalarray_ptr_throws<size_t> fixedstack(depth.first);
+		autovalarray_ptr_throws<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 
 		depth.first = 0;
 		depth.second = 0;
@@ -1351,10 +1345,8 @@
 	if (0<depth.first && 0<depth.second)
 		{
 		// reality-check: balanced parentheses
-		autovalarray_ptr<size_t> fixedstack(depth.first);
-		autovalarray_ptr<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
-		if (fixedstack.empty()) throw std::bad_alloc();
-		if (pair_fixedstack.empty()) throw std::bad_alloc();
+		autovalarray_ptr_throws<size_t> fixedstack(depth.first);
+		autovalarray_ptr_throws<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 
 		depth.first = 0;
 		depth.second = 0;
@@ -2580,8 +2572,7 @@
 		tmp_escape = strchr(c99_symbolic_escapes,src[1]);
 		if (tmp_escape) return (unsigned char)(c99_symbolic_escaped_escapes[tmp_escape-c99_symbolic_escapes]);
 
-		tmp_escape = strchr(C99_COPY_ESCAPES,src[1]);
-		assert(NULL!=tmp_escape);
+		assert(strchr(C99_COPY_ESCAPES,src[1]));
 		return (unsigned char)(src[1]);
 		}
 	assert((strchr("uUx",src[1])));
@@ -3231,13 +3222,7 @@
 			case 2:	// signed long long
 				{
 				const bool signed_long_long_int = i<src.size<0>()-3 && robust_token_is_string<3>(src.c_array<0>()[i+3].index_tokens[0].token,"int");
-				if (signed_long_long_int)
-					{	// signed long long int
-					x.grab_index_token_from_str_literal<0>("signed long long int",0);	//! \bug should use something informative; identifier not fine
-					}
-				else{	// signed long long
-					x.grab_index_token_from_str_literal<0>("signed long long",0);	//! \bug should use something informative; identifier not fine
-					};
+				x.grab_index_token_from_str_literal<0>(signed_long_long_int ? "signed long long int" : "signed long long",0);	//! \todo should use something informative; identifier not fine
 				x.type_code.set_type(C_TYPE::LLONG);
 				x.flags |= PARSE_PRIMARY_TYPE;
 				return 2+signed_long_long_int;
@@ -3298,13 +3283,7 @@
 			case 2:	// unsigned long long
 				{
 				const bool unsigned_long_long_int = i<src.size<0>()-3 && robust_token_is_string<3>(src.c_array<0>()[i+3].index_tokens[0].token,"int");
-				if (unsigned_long_long_int)
-					{	// unsigned long long int
-					x.grab_index_token_from_str_literal<0>("unsigned long long int",0);	//! \bug should use something informative; identifier not fine
-					}
-				else{	// unsigned long long
-					x.grab_index_token_from_str_literal<0>("unsigned long long",0);	//! \bug should use something informative; identifier not fine
-					};
+				x.grab_index_token_from_str_literal<0>(unsigned_long_long_int ? "unsigned long long int" : "unsigned long long",0);	//! \todo should use something informative; identifier not fine
 				x.type_code.set_type(C_TYPE::ULLONG);
 				x.flags |= PARSE_PRIMARY_TYPE;
 				return 2+unsigned_long_long_int;
@@ -3376,14 +3355,17 @@
 	size_t offset = 0;
 	while(i+offset<src.size<0>())
 		{
-		C99_notice_primary_type(src.c_array<0>()[i]);
-		const size_t truncate_by = (!(PARSE_PRIMARY_TYPE & src.data<0>()[i].flags) && NULL!=src.data<0>()[i].index_tokens[0].token.first) 
+		{
+		parse_tree& tmp_ref = src.c_array<0>()[i];
+		C99_notice_primary_type(tmp_ref);
+		const size_t truncate_by = (!(PARSE_PRIMARY_TYPE & tmp_ref.flags) && NULL!=tmp_ref.index_tokens[0].token.first) 
 								 ? _C99_CPP_notice_multitoken_primary_type(src,i) : 0;
 		if (0<truncate_by)
 			{
 			src.DestroyNAtAndRotateTo<0>(truncate_by,i+1,src.size<0>()-offset);
 			offset += truncate_by;
 			}
+		}
 		// disallow consecutive primary types
 		if (0<i && (PARSE_TYPE & src.c_array<0>()[i].flags) && (PARSE_TYPE & src.c_array<0>()[i-1].flags))
 			simple_error(src.c_array<0>()[i]," immediately after another type");
@@ -3420,14 +3402,17 @@
 	size_t offset = 0;
 	while(i+offset<src.size<0>())
 		{
-		CPP_notice_primary_type(src.c_array<0>()[i]);
-		const size_t truncate_by = (!(PARSE_PRIMARY_TYPE & src.data<0>()[i].flags) && NULL!=src.data<0>()[i].index_tokens[0].token.first) 
+		{
+		parse_tree& tmp_ref = src.c_array<0>()[i];
+		CPP_notice_primary_type(tmp_ref);
+		const size_t truncate_by = (!(PARSE_PRIMARY_TYPE & tmp_ref.flags) && NULL!=tmp_ref.index_tokens[0].token.first) 
 								 ? _C99_CPP_notice_multitoken_primary_type(src,i) : 0;
 		if (0<truncate_by)
 			{
 			src.DestroyNAtAndRotateTo<0>(truncate_by,i+1,src.size<0>()-offset);
 			offset += truncate_by;
 			}
+		}
 		// disallow consecutive types
 		if (0<i && (PARSE_TYPE & src.c_array<0>()[i].flags) && (PARSE_TYPE & src.c_array<0>()[i-1].flags))
 			simple_error(src.c_array<0>()[i]," immediately after another primary type");
@@ -3849,7 +3834,6 @@
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 }
 
-#ifndef NDEBUG
 static bool is_C99_anonymous_specifier(const parse_tree& src,const char* const spec_name)
 {
 	if (	robust_token_is_string(src.index_tokens[0].token,spec_name)
@@ -3891,15 +3875,13 @@
 		return true;
 	return false;
 }
-#endif
 
 static bool C99_looks_like_identifier(const parse_tree& x)
 {
 	if (!x.is_atomic()) return false;
 	if (PARSE_TYPE & x.flags) return false;
 	if (C99_echo_reserved_keyword(x.index_tokens[0].token.first,x.index_tokens[0].token.second)) return false;
-	if (C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags) return true;
-	return false;
+	return C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags;
 }
 
 static bool CPP_looks_like_identifier(const parse_tree& x)
@@ -3907,8 +3889,7 @@
 	if (!x.is_atomic()) return false;
 	if (PARSE_TYPE & x.flags) return false;
 	if (CPP_echo_reserved_keyword(x.index_tokens[0].token.first,x.index_tokens[0].token.second)) return false;
-	if (C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags) return true;
-	return false;
+	return C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags;
 }
 
 static void make_target_postfix_arg(parse_tree& src,size_t& offset,const size_t i,const size_t j)
@@ -4560,14 +4541,10 @@
 	assert(depth_brackets.first==depth_brackets.second);
 	assert(depth_braces.first==depth_braces.second);
 	if (0==depth_parens.first && 0==depth_brackets.first && 0==depth_braces.first) return true;
-	autovalarray_ptr<size_t> paren_stack(depth_parens.first);
-	autovalarray_ptr<size_t> bracket_stack(depth_brackets.first);
-	autovalarray_ptr<size_t> brace_stack(depth_braces.first);
+	autovalarray_ptr_throws<size_t> paren_stack(depth_parens.first);
+	autovalarray_ptr_throws<size_t> bracket_stack(depth_brackets.first);
+	autovalarray_ptr_throws<size_t> brace_stack(depth_braces.first);
 
-	if (0<depth_parens.first && paren_stack.empty()) throw std::bad_alloc();
-	if (0<depth_brackets.first && bracket_stack.empty()) throw std::bad_alloc();
-	if (0<depth_braces.first && brace_stack.empty()) throw std::bad_alloc();
-
 	const size_t starting_errors = zcc_errors.err_count();
 	size_t paren_idx = 0;
 	size_t bracket_idx = 0;
@@ -4687,7 +4664,11 @@
 #endif
 		src.c_array<0>()->destroy();
 		parse_tree* const tmp2 = src.c_array<0>();
+#ifdef ZAIMONI_FORCE_ISO
+		src.args[0].first = tmp;
+#else
 		src.args[0] = tmp;
+#endif
 		return tmp2;
 		};
 	return _new_buffer_nonNULL_throws<parse_tree>(1);
@@ -4705,7 +4686,11 @@
 #endif
 		src.c_array<0>()->destroy();
 		free(src.c_array<0>());
+#ifdef ZAIMONI_FORCE_ISO
+		src.args[0].first = tmp;
+#else
 		src.args[0] = tmp;
+#endif
 		}
 }
 
@@ -7731,8 +7716,8 @@
 			assert(old.bitcount>=rhs.bitcount);
 			const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>());
 			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
-			if (lhs_converted) target_machine->C_promote_integer(lhs_int,lhs,old);
-			if (rhs_converted) target_machine->C_promote_integer(rhs_int,rhs,old);
+			const bool lhs_negative = lhs_converted && target_machine->C_promote_integer(lhs_int,lhs,old);
+			const bool rhs_negative = rhs_converted && target_machine->C_promote_integer(rhs_int,rhs,old);
 			if (lhs_converted && rhs_converted)
 				{
 				force_decimal_literal(src,(lhs_int==rhs_int)==is_equal_op ? "1" : "0",types);
@@ -10191,7 +10176,14 @@
 			&& !CPP_echo_reserved_keyword(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second)
 			&& (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags))
 			{	// shove Koenig lookup into type_system
+#if 0
+			if (check_for_typedef(base_type,x.data<0>()[i].index_tokens[0].token.first+2,active_namespace,types)) return true;
+			if (check_for_enum(base_type,x.data<0>()[i].index_tokens[0].token.first+2,active_namespace,types)) return true;
+			if (check_for_class_struct_union(base_type,x.data<0>()[i].index_tokens[0].token.first+2,active_namespace,types)) return true;
+			return false;
+#else
 			return check_for_typedef(base_type,x.data<0>()[i].index_tokens[0].token.first,active_namespace,types);
+#endif
 			}
 		}
 		//! \todo handle other known types
@@ -10346,6 +10338,33 @@
 	return iter-first;
 }
 
+#if 0
+static bool is_identifier_list(const parse_tree& src,func_traits<const char* (*)(const char* x,size_t x_len)>::function_ref_type EchoReservedKeyword)
+{
+	assert(!src.empty());
+	size_t j = src.size<0>();
+	if (!(j%2)) return false;
+	const parse_tree* const x = src.data<0>();
+	assert(x);
+	do	{
+		if (!x[--j].is_atomic()) return false;
+		if (0==j%2)
+			{	// identifier needed
+			if (   C_TESTFLAG_IDENTIFIER!=x[j].index_tokens[0].flags	// must be identifier
+				|| (PARSE_TYPE & x[j].flags) 	// internal representation could land some types here, especially primary types
+				|| EchoReservedKeyword(x[j].index_tokens[0].token.first,x[j].index_tokens[0].token.second))	// keywords are only lexically identifiers, they'll cause problems
+				return false;
+			}
+		else{	// comma needed
+			if (!token_is_char<','>(x[j].index_tokens[0].token))
+				return false;
+			}
+		}
+	while(0<j);
+	return true;
+}
+#endif
+
 static void C99_CPP_handle_static_assertion(parse_tree& src,type_system& types,PP_auxfunc& langinfo,const size_t i,const char* const err)
 {
 	assert(err && *err);
@@ -10587,6 +10606,74 @@
 		src.DeleteIdx<0>(src.size<0>()-1); // clean up anyway
 		}
 	//! \todo actually record enumerator matchings
+#if 0
+	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> latest_value(0);
+	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> prior_value;
+	i = 0;
+	while(src.size<0>()>i)
+		{	// require identifier that is neither keyword nor a primitive type
+			// C++ will have problems with enum/struct/class/union names, verify status of both of these (could be -Wc-c++-compat issue if legal in C)
+			// if identifier, verify next is = or ,
+			// if next is =, locate comma afterwards (do not do expression parsing yet)
+			//! \todo: enforce One Definition Rule for C++ vs types; determine how much of the effect is in C as well
+		assert(src.data<0>()[i].is_atomic());
+		assert(C_TESTFLAG_IDENTIFIER==src.data<0>()[i].index_tokens[0].flags);
+		assert(!(PARSE_TYPE & src.data<0>()[i].flags));
+		assert(!echo_reserved_keyword(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].token.second));
+		char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[0].token.first,active_namespace,"::") : NULL;
+		const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[0].token.first;
+
+		if (types.enumerator_already_defined(fullname,prior_value))
+			{	// --do-what-i-mean could recover if the prior definition were identical
+				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined
+				// C++: One Definition Rule wipes out
+			free(namespace_name);
+			return false;
+			};
+		// next proposed function call is a bit handwavish right now...
+		// C++0X 3.3.1p4: enumerator gets to hide class names and enum names, nothing else [in particular dies against typedefs and functions]
+		if (types.enum_already_defined(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
+			{	// -Wbackport warn in C++, fail in C
+			};
+		if (types.union_class_struct_already_declared(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
+			{	// -Wbackport warn in C++, fail in C
+			};
+		if (types.function_already_declared(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
+			{	// C++: One Definition Rule
+			};
+		if (types.typedef_already_defined(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
+			{	// C++: One Definition Rule
+			};
+		if (1>=src.size<0>()-i)
+			{	// default-update
+			types.register_enum(enum_name,active_namespace,src.data<0>()[i].index_tokens[0].token.first,latest_value);
+			break;
+			}
+		// complete conversion
+		if (robust_token_is_char<','>(src.data<0>()[i+1]))
+			{	// would default-update
+			types.register_enum(enum_name,active_namespace,src.data<0>()[i].index_tokens[0].token.first,latest_value);
+			i += 2;
+			continue;
+			};
+		assert(robust_token_is_char<'='>(src.data<0>()[i+1]));
+		i += 2;
+		assert(src.size<0>()>i && !robust_token_is_char<','>(src.data<0>()[i]));
+		size_t origin = i;
+		while(++i < src.size<0>())
+			{
+			if (robust_token_is_char<','>(src.data<0>()[i]))
+				{
+				++i;
+				break;
+				}
+			};
+		// probably have this already....
+		if (!eval_expression(src,origin,i,latest_value))
+			return false;
+		types.register_enum(enum_name,active_namespace,src.data<0>()[i].index_tokens[0].token.first,latest_value);
+		}
+#endif
 	return true;
 }
 
@@ -10723,7 +10810,7 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			types.register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
+			const type_system::type_index tmp = types.register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,NULL,NULL,false,C99_echo_reserved_keyword))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
@@ -11012,6 +11099,72 @@
 					return;
 					};
 				//! \todo function declarations can be self-terminating
+#if 0
+				if (   initdecl_identifier_idx==i+decl_count+decl_offset-1
+					&& is_naked_parentheses_pair(src.data<0>()[i+decl_count+decl_offset]))
+					{	// function declaration or function definition intended
+					if (src.size<0>()-(i+decl_count+decl_offset)<=1)
+						{	// unterminated declaration
+							//! \bug needs test case
+						if (src.size<0>()>i) message_header(src.data<0>()[i].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("declaration cut off by end of scope (C99 6.7p1)");
+						zcc_errors.inc_error();
+						// remove from parse
+						if (src.size<0>()>i)
+							src.DeleteNSlotsAt<0>(decl_count+decl_offset,i);
+						return;
+						};
+					// build function type here
+					size_t j = src.data<0>()[i+decl_count+decl_offset].size<0>();
+					const bool is_varadic = !j || (src.data<0>()[i+decl_count+decl_offset].back<0>().is_atomic()
+												&& token_is_string<3>(src.data<0>()[i+decl_count+decl_offset].back<0>(),"..."));
+					const bool is_zeroary = 1==j && src.data<0>()[i+decl_count+decl_offset].back<0>().is_atomic() && token_is_string<4>(src.data<0>()[i+decl_count+decl_offset].back<0>(),"void");
+					const bool have_identifier_list = is_identifier_list(src.data<0>()[i+decl_count+decl_offset]);
+					size_t comma_count = 0;
+					{
+					while(0<j) comma_count += robust_token_is_char<','>(src.data<0>()[i+decl_count+decl_offset].data<0>()[--j].index_tokens[0].token);
+					}
+					zaimoni::autovalarray_ptr_throws<size_t> comma_positions(comma_count);
+					if (0<comma_count)
+						{
+						size_t offset = comma_count;
+						j = src.data<0>()[i+decl_count+decl_offset].size<0>();
+						while(0<j)
+							if (robust_token_is_char<','>(src.data<0>()[i+decl_count+decl_offset].data<0>()[--j].index_tokens[0].token))
+								comma_positions[--offset] = j;
+						assert(0==offset);
+						assert(0<comma_positions.front());
+						assert(2<=src.data<0>()[i+decl_count+decl_offset].size<0>()-comma_positions.back());
+						}
+					// identifier-lists are disallowed outside of full definitions
+
+					function_type want_this_type(is_zeroary ? 0 : is_varadic ? comma_count : comma_count+1,is_varadic);
+					{
+					type_spec tmp;
+					tmp.clear();
+					declFind.value_copy_type(tmp);
+					//! \bug need to reject function types and arrays as return type
+					want_this_type.movein_result_type(tmp);
+					}
+					// other parameter types; note that the parameter names have to be isolated for later
+					j = want_this_type.size();
+					zaimoni::weakautoarray_ptr_throws<size_t> names_temp(j+is_varadic);
+					if (is_varadic) names_temp.back() = "...";
+					while(0<j)
+						{
+						};
+
+					// function attributes would go here
+					if (robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset+1]))
+						{	// function declaration; discard names_temp
+							// check that any prior declarations are consistent
+						};
+					if (is_naked_brace_pair(src.data<0>()[i+decl_count+decl_offset+1]))
+						{	// function definition; need names_temp; also must locate any prior declarations
+						};					
+					}
+#endif
 				// ;: done
 				if (robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset]))
 					{
@@ -11243,7 +11396,7 @@
 			else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
 				{	// enum-specifier doesn't have a specific declaration mode
 					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-				types.register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
+				const type_system::type_index tmp = types.register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 				if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
 					{
 					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");



From zaimoni at mail.berlios.de  Wed Dec  9 02:41:16 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 9 Dec 2009 02:41:16 +0100
Subject: [Zcplusplus-commits] r304 - trunk
Message-ID: <200912090141.nB91fGcm026571@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-09 02:41:13 +0100 (Wed, 09 Dec 2009)
New Revision: 304

Modified:
   trunk/CSupport.cpp
Log:
stricter interpretation of memory failure return code

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-12-08 23:58:29 UTC (rev 303)
+++ trunk/CSupport.cpp	2009-12-09 01:41:13 UTC (rev 304)
@@ -5654,6 +5654,9 @@
 	return false;
 }
 
+// This is called from the eval_ family of functions.  Use a return value
+// rather than throw std::bad_alloc because as we're hoping eval will 
+// eventually recover enough memory for this to complete.
 static bool construct_twos_complement_int_min(parse_tree& dest, const type_system& types, const virtual_machine::std_int_enum machine_type, const parse_tree& src_loc)
 {
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp_int(target_machine->signed_max(machine_type));
@@ -5727,9 +5730,9 @@
 		if (	virtual_machine::twos_complement==target_machine->C_signed_int_representation()
 			&& 	0==(old_type.base_type_index-C_TYPE::INT)%2
 			&& 	!bool_options[boolopt::int_traps]
-			&&	res_int>target_machine->signed_max(machine_type)
-			&&	construct_twos_complement_int_min(src,types,machine_type,src))
+			&&	res_int>target_machine->signed_max(machine_type))
 			{	// trap representation; need to get it into -INT_MAX-1 form
+			if (!construct_twos_complement_int_min(src,types,machine_type,src)) return false;
 			src.type_code = old_type;
 			return true;
 			}
@@ -7919,9 +7922,9 @@
 			if (	virtual_machine::twos_complement==target_machine->C_signed_int_representation()
 				&& 	old.is_signed
 				&& 	!bool_options[boolopt::int_traps]
-				&&	res_int>target_machine->signed_max(old.machine_type)
-				&&	construct_twos_complement_int_min(src,types,old.machine_type,src))
+				&&	res_int>target_machine->signed_max(old.machine_type))
 				{	// trap representation; need to get it into -INT_MAX-1 form
+				if (!construct_twos_complement_int_min(src,types,old.machine_type,src)) return false;
 				src.type_code = old_type;
 				return true;
 				}
@@ -8087,9 +8090,9 @@
 		if (	virtual_machine::twos_complement==target_machine->C_signed_int_representation()
 			&& 	old.is_signed
 			&& 	!bool_options[boolopt::int_traps]
-			&&	res_int>target_machine->signed_max(old.machine_type)
-			&&	construct_twos_complement_int_min(src,types,old.machine_type,src))
+			&&	res_int>target_machine->signed_max(old.machine_type))
 			{	// trap representation; need to get it into -INT_MAX-1 form
+			if (!construct_twos_complement_int_min(src,types,old.machine_type,src)) return false;
 			src.type_code = old_type;
 			return true;
 			}



From zaimoni at mail.berlios.de  Wed Dec  9 05:10:22 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 9 Dec 2009 05:10:22 +0100
Subject: [Zcplusplus-commits] r305 - trunk
Message-ID: <200912090410.nB94AM8g009672@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-09 05:10:18 +0100 (Wed, 09 Dec 2009)
New Revision: 305

Modified:
   trunk/CSupport.cpp
Log:
object file size reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-12-09 01:41:13 UTC (rev 304)
+++ trunk/CSupport.cpp	2009-12-09 04:10:18 UTC (rev 305)
@@ -6028,32 +6028,40 @@
 static void assemble_binary_infix_arguments(parse_tree& src, size_t& i, const lex_flags _flags)
 {
 	assert(1<=i && 2<=src.size<0>()-i);
-	parse_tree* const tmp = repurpose_inner_parentheses(src.c_array<0>()[i-1]);	// RAM conservation
-	*tmp = src.data<0>()[i-1];
-	parse_tree* const tmp2 = repurpose_inner_parentheses(src.c_array<0>()[i+1]);	// RAM conservation
-	*tmp2 = src.data<0>()[i+1];
-	src.c_array<0>()[i].fast_set_arg<1>(tmp);
-	src.c_array<0>()[i].fast_set_arg<2>(tmp2);
-	src.c_array<0>()[i].core_flag_update();
-	src.c_array<0>()[i].flags |= _flags;
-	src.c_array<0>()[i-1].clear();
-	src.c_array<0>()[i+1].clear();
+	{
+	parse_tree* tmp_c_array = src.c_array<0>()+(i-1);
+	parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
+	*tmp = tmp_c_array[0];
+	parse_tree* const tmp2 = repurpose_inner_parentheses(tmp_c_array[2]);	// RAM conservation
+	*tmp2 = tmp_c_array[2];
+	tmp_c_array[1].fast_set_arg<1>(tmp);
+	tmp_c_array[1].fast_set_arg<2>(tmp2);
+	tmp_c_array[1].core_flag_update();
+	tmp_c_array[1].flags |= _flags;
+	tmp_c_array[0].clear();
+	tmp_c_array[2].clear();
+	}
 	src.DeleteIdx<0>(i+1);
 	src.DeleteIdx<0>(--i);
-	cancel_outermost_parentheses(src.c_array<0>()[i].c_array<1>()[0]);
-	cancel_outermost_parentheses(src.c_array<0>()[i].c_array<2>()[0]);
+
+	parse_tree& tmp = src.c_array<0>()[i];
+	cancel_outermost_parentheses(tmp.c_array<1>()[0]);
+	cancel_outermost_parentheses(tmp.c_array<2>()[0]);
 }
 
 static void merge_binary_infix_argument(parse_tree& src, size_t& i, const lex_flags _flags)
 {
 	assert(1<=i);
-	parse_tree* const tmp = repurpose_inner_parentheses(src.c_array<0>()[i-1]);	// RAM conservation
-	*tmp = src.data<0>()[i-1];
+	{
+	parse_tree* tmp_c_array = src.c_array<0>()+(i-1);
+	parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
+	*tmp = tmp_c_array[0];
 
-	src.c_array<0>()[i].fast_set_arg<1>(tmp);
-	src.c_array<0>()[i].core_flag_update();
-	src.c_array<0>()[i].flags |= _flags;
-	src.c_array<0>()[i-1].clear();
+	tmp_c_array[1].fast_set_arg<1>(tmp);
+	tmp_c_array[1].core_flag_update();
+	tmp_c_array[1].flags |= _flags;
+	tmp_c_array[0].clear();
+	}
 	src.DeleteIdx<0>(--i);
 	cancel_outermost_parentheses(src.c_array<0>()[i].c_array<1>()[0]);
 }
@@ -6112,15 +6120,19 @@
 	if (mult_subtype)
 		{
 		if (1>i || 2>src.size<0>()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (	(PARSE_MULT_EXPRESSION & src.data<0>()[i-1].flags)
-			&&	(PARSE_PM_EXPRESSION & src.data<0>()[i+1].flags))
+		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_MULT_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_PM_EXPRESSION & tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_MULT_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_MULT_EXPRESSION);	// tmp_c_array goes invalid here
 			assert(is_C99_mult_operator_expression(src.data<0>()[i]));
-			src.c_array<0>()[i].subtype = mult_subtype;
-			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
+			{
+			parse_tree& tmp = src.c_array<0>()[i];
+			tmp.subtype = mult_subtype;
+			tmp.type_code.set_type(0);	// handle type inference later
+			}
 			assert(is_C99_mult_operator_expression(src.data<0>()[i]));
 			return true;
 			}



From zaimoni at mail.berlios.de  Wed Dec  9 12:37:42 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 9 Dec 2009 12:37:42 +0100
Subject: [Zcplusplus-commits] r306 - in trunk/Zaimoni.STL: . LexParse
Message-ID: <200912091137.nB9Bbgu3000853@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-09 12:37:37 +0100 (Wed, 09 Dec 2009)
New Revision: 306

Modified:
   trunk/Zaimoni.STL/AutoPtr.hpp
   trunk/Zaimoni.STL/LexParse/GNUmakefile
   trunk/Zaimoni.STL/LexParse/LangConf.cpp
   trunk/Zaimoni.STL/MetaRAM2.hpp
Log:
repair ISO build of Zaimoni.STL; make the usual Windows GNUmakefile build ISO in parallel with non-ISO

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2009-12-09 04:10:18 UTC (rev 305)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2009-12-09 11:37:37 UTC (rev 306)
@@ -186,7 +186,11 @@
 	void TransferOutAndNULL(T*& Target) {_weak_flush(Target); Target = _ptr; this->NULLPtr();}
 	bool Resize(size_t n) {return _weak_resize(_ptr,n);};
 	void FastDeleteIdx(size_t n) {_weak_delete_idx(_ptr,n);};
+#ifndef ZAIMONI_FORCE_ISO
 	void DeleteIdx(size_t n) {_safe_weak_delete_idx(_ptr,n);};
+#else
+	void DeleteIdx(size_t n) {_safe_weak_delete_idx(_ptr,_size,n);};
+#endif
 	void DeleteNSlotsAt(size_t n, size_t Idx) {_weak_delete_n_slots_at(_ptr,n,Idx);};
 
 	// Perl grep

Modified: trunk/Zaimoni.STL/LexParse/GNUmakefile
===================================================================
--- trunk/Zaimoni.STL/LexParse/GNUmakefile	2009-12-09 04:10:18 UTC (rev 305)
+++ trunk/Zaimoni.STL/LexParse/GNUmakefile	2009-12-09 11:37:37 UTC (rev 306)
@@ -9,7 +9,7 @@
 
 CXXFLAGS := -Os -Wall -Wextra -finline -Winline -Wdisabled-optimization --param max-inline-insns-single=500 -c -pipe -DNDEBUG
 
-LIBS := libz_langconf.a
+LIBS := libz_langconf.a libz_langconf_iso.a
 
 # GNU targets we know about
 all: $(LIBS)
@@ -24,13 +24,23 @@
 
 # rules
 LangConf.o: LangConf.cpp $(LangConf_hpp) $(addprefix ../, $(POD_hpp))
+LangConf_iso.o: LangConf.cpp $(LangConf_hpp) $(addprefix ../, $(POD_hpp))
 
 .cpp.o:
-	$(CXX) -c $< $(CXXFLAGS) $(ARCH_FLAGS) $(FORCE_ISO) -o $*.o
+	$(CXX) -c $< $(CXXFLAGS) $(ARCH_FLAGS) -o $*.o
 
+LangConf_iso.o:
+	$(CXX) -c $< $(CXXFLAGS) $(ARCH_FLAGS) -DZAIMONI_FORCE_ISO -o $*.o
+
 libz_langconf.a: LangConf.o
 	$(AR) -ru libz_langconf.a LangConf.o
 
+libz_langconf_iso.a: LangConf_iso.o
+	$(AR) -ru libz_langconf_iso.a LangConf_iso.o
+
 $(libdir)/libz_langconf.a: libz_langconf.a
 	cp libz_langconf.a $(libdir)/libz_langconf.a
 
+$(libdir)/libz_langconf_iso.a: libz_langconf_iso.a
+	cp libz_langconf_iso.a $(libdir)/libz_langconf_iso.a
+

Modified: trunk/Zaimoni.STL/LexParse/LangConf.cpp
===================================================================
--- trunk/Zaimoni.STL/LexParse/LangConf.cpp	2009-12-09 04:10:18 UTC (rev 305)
+++ trunk/Zaimoni.STL/LexParse/LangConf.cpp	2009-12-09 11:37:37 UTC (rev 306)
@@ -53,7 +53,7 @@
 
 void LangConf::ExtractLineFromTextBuffer(char*& Buffer, char*& NewLine) const
 {
-#ifdef ZAIMONI_FORCE_ISO
+#ifndef ZAIMONI_FORCE_ISO
 	size_t BufferLength = _msize(Buffer);
 #else
 	size_t BufferLength = strlen(Buffer);
@@ -87,7 +87,7 @@
 				}
 			if (strchr(Quotes,Buffer[SweepIdx]))
 				InQuotes = !InQuotes;
-			else if ((InQuotes || !EscapeOnlyWithinQuotes) && SweepIdx+1<ArraySize(Buffer))
+			else if ((InQuotes || !EscapeOnlyWithinQuotes) && SweepIdx+1<BufferLength)
 				{
 				if (	(   EscapeEscape==Buffer[SweepIdx]
 						 && Escape==Buffer[SweepIdx+1])

Modified: trunk/Zaimoni.STL/MetaRAM2.hpp
===================================================================
--- trunk/Zaimoni.STL/MetaRAM2.hpp	2009-12-09 04:10:18 UTC (rev 305)
+++ trunk/Zaimoni.STL/MetaRAM2.hpp	2009-12-09 11:37:37 UTC (rev 306)
@@ -120,12 +120,21 @@
 }
 #endif
 
+#ifndef ZAIMONI_FORCE_ISO
 template<typename T>
 inline void _safe_weak_delete_idx(T*& __ptr, size_t Idx)
 {
 	if (NULL!=__ptr && Idx<ArraySize(__ptr))
 		_weak_delete_idx(__ptr,Idx);
 }
+#else
+template<typename T>
+inline void _safe_weak_delete_idx(T*& __ptr, size_t& _ptr_size, size_t Idx)
+{
+	if (NULL!=__ptr && Idx<_ptr_size)
+		_weak_delete_idx(__ptr,_ptr_size,Idx);
+}
+#endif
 
 // How to tell difference between T* (single) and T* (array) in resize/shrink?
 // we don't, assume single
@@ -681,21 +690,32 @@
 }
 
 template<typename T>
-void
-_weak_delete_idx(T**& _ptr, size_t Idx)
+#ifndef ZAIMONI_FORCE_ISO
+void _weak_delete_idx(T**& _ptr, size_t Idx)
 {
 	assert(NULL!=_ptr);
 	const size_t _ptr_size = ArraySize(_ptr);
+#else
+void _weak_delete_idx(T**& _ptr, size_t& _ptr_size, size_t Idx)
+{
+	assert(NULL!=_ptr);
+#endif
 	assert(Idx<_ptr_size);
 	if (1==_ptr_size)
 		{
 		_weak_flush(_ptr);
 		_ptr = NULL;
+#ifdef ZAIMONI_FORCE_ISO
+		_ptr_size = 0;
+#endif
 		return;
 		}
 	if (2<=_ptr_size-Idx)
 		memmove(_ptr+Idx,_ptr+Idx+1,sizeof(T*)*(_ptr_size-Idx-1));
 	_ptr=REALLOC(_ptr,sizeof(T*)*(_ptr_size-1));
+#ifdef ZAIMONI_FORCE_ISO
+	--_ptr_size;
+#endif
 }
 
 template<typename T>



From zaimoni at mail.berlios.de  Thu Dec 10 22:48:50 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 10 Dec 2009 22:48:50 +0100
Subject: [Zcplusplus-commits] r307 - trunk
Message-ID: <200912102148.nBALmoR8003665@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-10 22:48:47 +0100 (Thu, 10 Dec 2009)
New Revision: 307

Modified:
   trunk/CSupport.cpp
Log:
object file size reduction, some format tweaks

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-12-09 11:37:37 UTC (rev 306)
+++ trunk/CSupport.cpp	2009-12-10 21:48:47 UTC (rev 307)
@@ -5154,6 +5154,7 @@
 
 // can't do much syntax-checking or immediate-evaluation here because of binary +/-
 // unary +/- syntax checking out out of place as it's needed by all of the unary operators
+// return code is true for success, false for memory failure
 static bool VM_to_token(const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
 {
 	const char* const suffix = literal_suffix(base_type_index);
@@ -5171,6 +5172,7 @@
 	return true;
 }
 
+// return code is true for success, false for memory failure
 static bool VM_to_literal(parse_tree& dest, const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,const parse_tree& src,const type_system& types)
 {
 	POD_pair<char*,lex_flags> new_token;
@@ -6029,7 +6031,7 @@
 {
 	assert(1<=i && 2<=src.size<0>()-i);
 	{
-	parse_tree* tmp_c_array = src.c_array<0>()+(i-1);
+	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
 	parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
 	*tmp = tmp_c_array[0];
 	parse_tree* const tmp2 = repurpose_inner_parentheses(tmp_c_array[2]);	// RAM conservation
@@ -6053,7 +6055,7 @@
 {
 	assert(1<=i);
 	{
-	parse_tree* tmp_c_array = src.c_array<0>()+(i-1);
+	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
 	parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
 	*tmp = tmp_c_array[0];
 
@@ -6635,6 +6637,7 @@
 		CPP_mult_expression_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
+// Law of Demeter conversion is object-size neutral [Dec. 9 2009], so don't do it
 static bool C_string_literal_equal_content(const parse_tree& lhs, const parse_tree& rhs,bool& is_equal)
 {
 	if (C_TESTFLAG_STRING_LITERAL==lhs.index_tokens[0].flags && C_TESTFLAG_STRING_LITERAL==rhs.index_tokens[0].flags)
@@ -6730,15 +6733,17 @@
 	if (add_subtype)
 		{
 		if (1>i || 2>src.size<0>()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (	(PARSE_ADD_EXPRESSION & src.data<0>()[i-1].flags)
-			&&	(PARSE_MULT_EXPRESSION & src.data<0>()[i+1].flags))
+		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_ADD_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_MULT_EXPRESSION & tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_ADD_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_ADD_EXPRESSION);	// tmp_c_array goes invalid here
 			assert(is_C99_add_operator_expression(src.data<0>()[i]));
-			src.c_array<0>()[i].subtype = add_subtype;
-			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
+			parse_tree& tmp = src.c_array<0>()[i];
+			tmp.subtype = add_subtype;
+			tmp.type_code.set_type(0);	// handle type inference later
 			assert(is_C99_add_operator_expression(src.data<0>()[i]));
 			return true;
 			}
@@ -6747,6 +6752,7 @@
 }
 
 // this one hides a slight inefficiency: negative literals take 2 dynamic memory allocations, positive literals take one
+// return code is true for success, false for memory failure
 static bool VM_to_signed_literal(parse_tree& x,const bool is_negative, const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,const parse_tree& src,const type_system& types)
 {
 	if (is_negative)
@@ -7288,15 +7294,17 @@
 	if (shift_subtype)
 		{
 		if (1>i || 2>src.size<0>()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (	(PARSE_SHIFT_EXPRESSION & src.data<0>()[i-1].flags)
-			&&	(PARSE_ADD_EXPRESSION & src.data<0>()[i+1].flags))
+		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_SHIFT_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_ADD_EXPRESSION & tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_SHIFT_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_SHIFT_EXPRESSION);	// tmp_c_array goes invalid here
 			assert(is_C99_shift_expression(src.data<0>()[i]));
-			src.c_array<0>()[i].subtype = shift_subtype;
-			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
+			parse_tree& tmp = src.c_array<0>()[i];
+			tmp.subtype = shift_subtype;
+			tmp.type_code.set_type(0);	// handle type inference later
 			assert(is_C99_shift_expression(src.data<0>()[i]));
 			return true;
 			}
@@ -7457,15 +7465,17 @@
 	if (rel_subtype)
 		{
 		if (1>i || 2>src.size<0>()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (	(PARSE_SHIFT_EXPRESSION & src.data<0>()[i-1].flags)
-			&&	(PARSE_ADD_EXPRESSION & src.data<0>()[i+1].flags))
+		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_SHIFT_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_ADD_EXPRESSION & tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_RELATIONAL_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_RELATIONAL_EXPRESSION);	// tmp_c_array goes invalid here
 			assert(is_C99_relation_expression(src.data<0>()[i]));
-			src.c_array<0>()[i].subtype = rel_subtype;
-			src.c_array<0>()[i].type_code.set_type(C_TYPE::BOOL);
+			parse_tree& tmp = src.c_array<0>()[i];
+			tmp.subtype = rel_subtype;
+			tmp.type_code.set_type(C_TYPE::BOOL);
 			assert(is_C99_relation_expression(src.data<0>()[i]));
 			return true;
 			}
@@ -7613,15 +7623,17 @@
 	if (eq_subtype)
 		{
 		if (1>i || 2>src.size<0>()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (	(PARSE_EQUALITY_EXPRESSION & src.data<0>()[i-1].flags)
-			&&	(PARSE_RELATIONAL_EXPRESSION & src.data<0>()[i+1].flags))
+		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_EQUALITY_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_RELATIONAL_EXPRESSION & tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_EQUALITY_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_EQUALITY_EXPRESSION);	// tmp_c_array becomes invalid here
 			assert(is_C99_equality_expression(src.data<0>()[i]));
-			src.c_array<0>()[i].subtype = eq_subtype;
-			src.c_array<0>()[i].type_code.set_type(C_TYPE::BOOL);
+			parse_tree& tmp = src.c_array<0>()[i];
+			tmp.subtype = eq_subtype;
+			tmp.type_code.set_type(C_TYPE::BOOL);
 			assert(is_C99_equality_expression(src.data<0>()[i]));
 			return true;
 			}
@@ -7642,15 +7654,17 @@
 	if (eq_subtype)
 		{
 		if (1>i || 2>src.size<0>()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (	(PARSE_EQUALITY_EXPRESSION & src.data<0>()[i-1].flags)
-			&&	(PARSE_RELATIONAL_EXPRESSION & src.data<0>()[i+1].flags))
+		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_EQUALITY_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_RELATIONAL_EXPRESSION & tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_EQUALITY_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_EQUALITY_EXPRESSION);	// tmp_c_array becomes invalid here
 			assert(is_CPP_equality_expression(src.data<0>()[i]));
-			src.c_array<0>()[i].subtype = eq_subtype;
-			src.c_array<0>()[i].type_code.set_type(C_TYPE::BOOL);
+			parse_tree& tmp = src.c_array<0>()[i];
+			tmp.subtype = eq_subtype;
+			tmp.type_code.set_type(C_TYPE::BOOL);
 			assert(is_CPP_equality_expression(src.data<0>()[i]));
 			return true;
 			}
@@ -7731,10 +7745,13 @@
 			assert(old.bitcount>=rhs.bitcount);
 			const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>());
 			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
-			const bool lhs_negative = lhs_converted && target_machine->C_promote_integer(lhs_int,lhs,old);
-			const bool rhs_negative = rhs_converted && target_machine->C_promote_integer(rhs_int,rhs,old);
+			// general case here in case we try to do with converted/not converted mixed cases
+//			if (lhs_converted) target_machine->C_promote_integer(lhs_int,lhs,old);
+//			if (rhs_converted) target_machine->C_promote_integer(rhs_int,rhs,old);
 			if (lhs_converted && rhs_converted)
 				{
+				target_machine->C_promote_integer(lhs_int,lhs,old);
+				target_machine->C_promote_integer(rhs_int,rhs,old);
 				force_decimal_literal(src,(lhs_int==rhs_int)==is_equal_op ? "1" : "0",types);
 				return true;
 				};
@@ -7839,15 +7856,16 @@
 	assert(src.data<0>()[i].is_atomic());
 
 	//! \todo deal with unary & parses
-	if (token_is_char<'&'>(src.data<0>()[i].index_tokens[0].token))
+	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+	if (token_is_char<'&'>(tmp_c_array[1].index_tokens[0].token))
 		{
 		if (1>i || 2>src.size<0>()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (	(PARSE_BITAND_EXPRESSION & src.data<0>()[i-1].flags)
-			&&	(PARSE_EQUALITY_EXPRESSION & src.data<0>()[i+1].flags))
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_BITAND_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_EQUALITY_EXPRESSION & tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITAND_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITAND_EXPRESSION);	// tmp_c_array becomes invalid here
 			assert(is_C99_bitwise_AND_expression(src.data<0>()[i]));
 			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
 			assert(is_C99_bitwise_AND_expression(src.data<0>()[i]));
@@ -8013,15 +8031,16 @@
 	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
 	assert(src.data<0>()[i].is_atomic());
 
-	if (token_is_char<'^'>(src.data<0>()[i].index_tokens[0].token))
+	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+	if (token_is_char<'^'>(tmp_c_array[1].index_tokens[0].token))
 		{
 		if (1>i || 2>src.size<0>()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (	(PARSE_BITXOR_EXPRESSION & src.data<0>()[i-1].flags)
-			&&	(PARSE_BITAND_EXPRESSION & src.data<0>()[i+1].flags))
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_BITXOR_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_BITAND_EXPRESSION & tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITXOR_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITXOR_EXPRESSION);	// tmp_c_array becomes invalid here
 			assert(is_C99_bitwise_XOR_expression(src.data<0>()[i]));
 			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
 			assert(is_C99_bitwise_XOR_expression(src.data<0>()[i]));
@@ -8180,15 +8199,16 @@
 	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
 	assert(src.data<0>()[i].is_atomic());
 
-	if (token_is_char<'|'>(src.data<0>()[i].index_tokens[0].token))
+	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+	if (token_is_char<'|'>(tmp_c_array[1].index_tokens[0].token))
 		{
 		if (1>i || 2>src.size<0>()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (	(PARSE_BITOR_EXPRESSION & src.data<0>()[i-1].flags)
-			&&	(PARSE_BITXOR_EXPRESSION & src.data<0>()[i+1].flags))
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_BITOR_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_BITXOR_EXPRESSION & tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITOR_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITOR_EXPRESSION);	// tmp_c_array becomes invalid here
 			assert(is_C99_bitwise_OR_expression(src.data<0>()[i]));
 			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
 			assert(is_C99_bitwise_OR_expression(src.data<0>()[i]));
@@ -8323,7 +8343,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_C99_bitwise_OR(src,i)) C_bitwise_OR_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_C99_bitwise_OR(src,i))
+		C_bitwise_OR_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 /*
@@ -8370,15 +8391,16 @@
 	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
 	assert(src.data<0>()[i].is_atomic());
 
-	if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"&&"))
+	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+	if (token_is_string<2>(tmp_c_array[1].index_tokens[0].token,"&&"))
 		{
 		if (1>i || 2>src.size<0>()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (	(PARSE_LOGICAND_EXPRESSION & src.data<0>()[i-1].flags)
-			&&	(PARSE_BITOR_EXPRESSION & src.data<0>()[i+1].flags))
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_LOGICAND_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_BITOR_EXPRESSION & tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_LOGICAND_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_LOGICAND_EXPRESSION);	// tmp_c_array becomes invalid here
 			assert(is_C99_logical_AND_expression(src.data<0>()[i]));
 			src.c_array<0>()[i].type_code.set_type(C_TYPE::BOOL);	// technically wrong, but range is correct
 			assert(is_C99_logical_AND_expression(src.data<0>()[i]));
@@ -8484,7 +8506,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_C99_logical_AND(src,i)) C_logical_AND_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_C99_logical_AND(src,i))
+		C_logical_AND_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 /*
@@ -8512,15 +8535,16 @@
 	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
 	assert(src.data<0>()[i].is_atomic());
 
-	if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"||"))
+	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+	if (token_is_string<2>(tmp_c_array[1].index_tokens[0].token,"||"))
 		{
 		if (1>i || 2>src.size<0>()-i) return false;
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
-		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-		if (	(PARSE_LOGICOR_EXPRESSION & src.data<0>()[i-1].flags)
-			&&	(PARSE_LOGICAND_EXPRESSION & src.data<0>()[i+1].flags))
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_LOGICOR_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_LOGICAND_EXPRESSION & tmp_c_array[2].flags))
 			{
-			assemble_binary_infix_arguments(src,i,PARSE_STRICT_LOGICOR_EXPRESSION);
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_LOGICOR_EXPRESSION);	// tmp_c_array becomes invalid here
 			assert(is_C99_logical_OR_expression(src.data<0>()[i]));
 			src.c_array<0>()[i].type_code.set_type(C_TYPE::BOOL);	// technically wrong, but range is correct
 			assert(is_C99_logical_OR_expression(src.data<0>()[i]));
@@ -8657,39 +8681,41 @@
 		{
 		// ? as first might be space deficiency (check uniqueness of construction)
 		if (1>i || 3>src.size<0>()-i) return false;
-		if (	src.data<0>()[i+2].is_atomic()
-			&&	token_is_char<':'>(src.data<0>()[i+2].index_tokens[0].token))
+		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+		if (	tmp_c_array[3].is_atomic()
+			&&	token_is_char<':'>(tmp_c_array[3].index_tokens[0].token))
 			{
-			inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
-			inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
-			inspect_potential_paren_primary_expression(src.c_array<0>()[i+3]);
+			inspect_potential_paren_primary_expression(tmp_c_array[0]);
+			inspect_potential_paren_primary_expression(tmp_c_array[2]);
+			inspect_potential_paren_primary_expression(tmp_c_array[4]);
 			if (	(PARSE_LOGICOR_EXPRESSION & src.data<0>()[i-1].flags)
 				&&	(PARSE_EXPRESSION & src.data<0>()[i+1].flags)
 				&&	(PARSE_CONDITIONAL_EXPRESSION & src.data<0>()[i+3].flags))
 				{
-				parse_tree* const tmp = repurpose_inner_parentheses(src.c_array<0>()[i-1]);	// RAM conservation
-				*tmp = src.data<0>()[i-1];
-				parse_tree* const tmp2 = repurpose_inner_parentheses(src.c_array<0>()[i+1]);	// RAM conservation
-				*tmp2 = src.data<0>()[i+1];
-				parse_tree* const tmp3 = repurpose_inner_parentheses(src.c_array<0>()[i+3]);	// RAM conservation
-				*tmp3 = src.data<0>()[i+3];
-				src.c_array<0>()[i].grab_index_token_from<1,0>(src.c_array<0>()[i+2]);
-				src.c_array<0>()[i].grab_index_token_location_from<1,0>(src.c_array<0>()[i+2]);
-				src.c_array<0>()[i].fast_set_arg<0>(tmp2);
-				src.c_array<0>()[i].fast_set_arg<1>(tmp);
-				src.c_array<0>()[i].fast_set_arg<2>(tmp3);
-				src.c_array<0>()[i].core_flag_update();
-				src.c_array<0>()[i].flags |= PARSE_STRICT_CONDITIONAL_EXPRESSION;
-				src.c_array<0>()[i-1].clear();
-				src.c_array<0>()[i+1].clear();
-				src.c_array<0>()[i+2].clear();
-				src.c_array<0>()[i+3].clear();
-				src.DeleteNSlotsAt<0>(3,i+1);
+				parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
+				*tmp = tmp_c_array[0];
+				parse_tree* const tmp2 = repurpose_inner_parentheses(tmp_c_array[2]);	// RAM conservation
+				*tmp2 = tmp_c_array[2];
+				parse_tree* const tmp3 = repurpose_inner_parentheses(tmp_c_array[4]);	// RAM conservation
+				*tmp3 = tmp_c_array[4];
+				tmp_c_array[1].grab_index_token_from<1,0>(tmp_c_array[3]);
+				tmp_c_array[1].grab_index_token_location_from<1,0>(tmp_c_array[3]);
+				tmp_c_array[1].fast_set_arg<0>(tmp2);
+				tmp_c_array[1].fast_set_arg<1>(tmp);
+				tmp_c_array[1].fast_set_arg<2>(tmp3);
+				tmp_c_array[1].core_flag_update();
+				tmp_c_array[1].flags |= PARSE_STRICT_CONDITIONAL_EXPRESSION;
+				tmp_c_array[0].clear();
+				tmp_c_array[2].clear();
+				tmp_c_array[3].clear();
+				tmp_c_array[4].clear();
+				src.DeleteNSlotsAt<0>(3,i+1);	// tmp_c_array becomes invalid here
 				src.DeleteIdx<0>(--i);
 				assert(is_C99_conditional_operator_expression_strict(src.data<0>()[i]));
-				cancel_outermost_parentheses(src.c_array<0>()[i].c_array<0>()[0]);
-				cancel_outermost_parentheses(src.c_array<0>()[i].c_array<1>()[0]);
-				cancel_outermost_parentheses(src.c_array<0>()[i].c_array<2>()[0]);
+				parse_tree& tmp4 = src.c_array<0>()[i];
+				cancel_outermost_parentheses(tmp4.front<0>());
+				cancel_outermost_parentheses(tmp4.front<1>());
+				cancel_outermost_parentheses(tmp4.front<2>());
 				assert(is_C99_conditional_operator_expression(src.data<0>()[i]));
 				return true;
 				}
@@ -8921,46 +8947,6 @@
 	if (terse_locate_conditional_op(src,i)) CPP_conditional_op_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
-#if 0
-static bool terse_locate_x(parse_tree& src, size_t& i)
-{
-	assert(!src.empty<0>());
-	assert(i<src.size<0>());
-	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
-	assert(src.data<0>()[i].is_atomic());
-}
-
-static void C_x_easy_syntax_check(parse_tree& src,const type_system& types)
-{
-}
-
-static void CPP_x_easy_syntax_check(parse_tree& src,const type_system& types)
-{
-}
-
-static void locate_C99_x(parse_tree& src, size_t& i, const type_system& types)
-{
-	assert(!src.empty<0>());
-	assert(i<src.size<0>());
-	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
-		|| !src.data<0>()[i].is_atomic())
-		return;
-
-	if (terse_locate_x(src,i)) C_x_easy_syntax_check(src.c_array<0>()[i],types);
-}
-
-static void locate_CPP_x(parse_tree& src, size_t& i, const type_system& types)
-{
-	assert(!src.empty<0>());
-	assert(i<src.size<0>());
-	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
-		|| !src.data<0>()[i].is_atomic())
-		return;
-
-	if (terse_locate_x(src,i)) CPP_x_easy_syntax_check(src.c_array<0>()[i],types);
-}
-#endif
-
 template<class T>
 static void parse_forward(parse_tree& src,const type_system& types, T parse_handler)
 {
@@ -9208,7 +9194,7 @@
 	return false;
 }
 
-void CPP_notice_scope_glue(parse_tree& src)
+static void CPP_notice_scope_glue(parse_tree& src)
 {
 	assert(!src.empty<0>());
 	size_t i = 0;
@@ -9301,23 +9287,24 @@
 	i = 0;
 	while(i<src.size<0>())
 		{
-		if (is_naked_parentheses_pair(src.data<0>()[i]))
+		parse_tree& tmp = src.c_array<0>()[i];
+		if (is_naked_parentheses_pair(tmp))
 			{
-			if (!src.data<0>()[i].empty<0>())
+			if (!tmp.empty<0>())
 				// recurse into (...)
-				CPP_notice_scope_glue(src.c_array<0>()[i]);
+				CPP_notice_scope_glue(tmp);
 			}
-		else if (is_naked_brace_pair(src.data<0>()[i]))
+		else if (is_naked_brace_pair(tmp))
 			{
-			if (!src.data<0>()[i].empty<0>())
+			if (!tmp.empty<0>())
 				// recurse into {...}
-				CPP_notice_scope_glue(src.c_array<0>()[i]);
+				CPP_notice_scope_glue(tmp);
 			}
-		else if (is_naked_bracket_pair(src.data<0>()[i]))
+		else if (is_naked_bracket_pair(tmp))
 			{
-			if (!src.data<0>()[i].empty<0>())
+			if (!tmp.empty<0>())
 				// recurse into [...]
-				CPP_notice_scope_glue(src.c_array<0>()[i]);
+				CPP_notice_scope_glue(tmp);
 			}
 		++i;
 		};
@@ -11114,72 +11101,6 @@
 					return;
 					};
 				//! \todo function declarations can be self-terminating
-#if 0
-				if (   initdecl_identifier_idx==i+decl_count+decl_offset-1
-					&& is_naked_parentheses_pair(src.data<0>()[i+decl_count+decl_offset]))
-					{	// function declaration or function definition intended
-					if (src.size<0>()-(i+decl_count+decl_offset)<=1)
-						{	// unterminated declaration
-							//! \bug needs test case
-						if (src.size<0>()>i) message_header(src.data<0>()[i].index_tokens[0]);
-						INC_INFORM(ERR_STR);
-						INFORM("declaration cut off by end of scope (C99 6.7p1)");
-						zcc_errors.inc_error();
-						// remove from parse
-						if (src.size<0>()>i)
-							src.DeleteNSlotsAt<0>(decl_count+decl_offset,i);
-						return;
-						};
-					// build function type here
-					size_t j = src.data<0>()[i+decl_count+decl_offset].size<0>();
-					const bool is_varadic = !j || (src.data<0>()[i+decl_count+decl_offset].back<0>().is_atomic()
-												&& token_is_string<3>(src.data<0>()[i+decl_count+decl_offset].back<0>(),"..."));
-					const bool is_zeroary = 1==j && src.data<0>()[i+decl_count+decl_offset].back<0>().is_atomic() && token_is_string<4>(src.data<0>()[i+decl_count+decl_offset].back<0>(),"void");
-					const bool have_identifier_list = is_identifier_list(src.data<0>()[i+decl_count+decl_offset]);
-					size_t comma_count = 0;
-					{
-					while(0<j) comma_count += robust_token_is_char<','>(src.data<0>()[i+decl_count+decl_offset].data<0>()[--j].index_tokens[0].token);
-					}
-					zaimoni::autovalarray_ptr_throws<size_t> comma_positions(comma_count);
-					if (0<comma_count)
-						{
-						size_t offset = comma_count;
-						j = src.data<0>()[i+decl_count+decl_offset].size<0>();
-						while(0<j)
-							if (robust_token_is_char<','>(src.data<0>()[i+decl_count+decl_offset].data<0>()[--j].index_tokens[0].token))
-								comma_positions[--offset] = j;
-						assert(0==offset);
-						assert(0<comma_positions.front());
-						assert(2<=src.data<0>()[i+decl_count+decl_offset].size<0>()-comma_positions.back());
-						}
-					// identifier-lists are disallowed outside of full definitions
-
-					function_type want_this_type(is_zeroary ? 0 : is_varadic ? comma_count : comma_count+1,is_varadic);
-					{
-					type_spec tmp;
-					tmp.clear();
-					declFind.value_copy_type(tmp);
-					//! \bug need to reject function types and arrays as return type
-					want_this_type.movein_result_type(tmp);
-					}
-					// other parameter types; note that the parameter names have to be isolated for later
-					j = want_this_type.size();
-					zaimoni::weakautoarray_ptr_throws<size_t> names_temp(j+is_varadic);
-					if (is_varadic) names_temp.back() = "...";
-					while(0<j)
-						{
-						};
-
-					// function attributes would go here
-					if (robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset+1]))
-						{	// function declaration; discard names_temp
-							// check that any prior declarations are consistent
-						};
-					if (is_naked_brace_pair(src.data<0>()[i+decl_count+decl_offset+1]))
-						{	// function definition; need names_temp; also must locate any prior declarations
-						};					
-					}
-#endif
 				// ;: done
 				if (robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset]))
 					{
@@ -11267,367 +11188,364 @@
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// check naked declarations first; handle namespaces later
 		//! \bug indentation fixup needed (stage 3)
-//		if (NULL==active_namespace)
-//			{
-			if (is_C99_named_specifier(src.data<0>()[i],"union"))
+		if (is_C99_named_specifier(src.data<0>()[i],"union"))
+			{
+			type_system::type_index tmp = types.get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			src.c_array<0>()[i].type_code.set_type(tmp);
+			}
+		else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
+			{
+			type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			src.c_array<0>()[i].type_code.set_type(tmp);
+			}
+		else if (is_C99_named_specifier(src.data<0>()[i],"class"))
+			{
+			type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			src.c_array<0>()[i].type_code.set_type(tmp);
+			}
+		else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
+			{	// can only define once
+			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+			const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_union(fullname));
+			if (tmp)
+				{	//! \test zcc/decl.C99/Error_union_multidef.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("'union ");
+				INC_INFORM(fullname);
+				free(namespace_name);
+				INFORM("' already defined (C++98 3.2p1)");
+				message_header(*tmp);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				// now it's gone
+				// remove trailing semicolon if present
+				src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
+				continue;
+				}
+			free(namespace_name);
+			}
+		else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
+			{	// can only define once
+			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+			const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(fullname));
+			if (tmp)
+				{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("'struct ");
+				INC_INFORM(fullname);
+				free(namespace_name);
+				INFORM("' already defined (C++98 3.2p1)");
+				message_header(*tmp);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				// now it's gone
+				// remove trailing semicolon if present
+				src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
+				continue;
+				}
+			free(namespace_name);
+			}
+		else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
+			{	// can only define once
+			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+			const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(fullname));
+			if (tmp)
+				{	//! \test zcc/decl.C99/Error_class_multidef.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("'class ");
+				INC_INFORM(fullname);
+				free(namespace_name);
+				INFORM("' already defined (C++98 3.2p1)");
+				message_header(*tmp);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				// now it's gone
+				// remove trailing semicolon if present
+				src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
+				continue;
+				}
+			free(namespace_name);
+			}
+		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
+		//! \todo actually, we can try forward-declare both scoped enums and enum-based enums (C++0X 7.2p3, these have enough size information); but other parts of the standard get in the way
+		else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
+			{
+			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
 				{
-				type_system::type_index tmp = types.get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-				src.c_array<0>()[i].type_code.set_type(tmp);
+				type_system::type_index tmp = types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+				src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
+				if (!tmp)
+					{	// this belongs elsewhere
+						//! \test zcc\decl.C99\Error_enum_undef.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'enum ");
+					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
+					zcc_errors.inc_error();
+					src.c_array<0>()[i].flags |= parse_tree::INVALID;
+					}
 				}
-			else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
+			//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
+			}
+		else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
+			{	// can only define once
+			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+			const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+			type_system::type_index tmp = types.get_id_enum(fullname);
+			if (tmp)
+				{	//! \test zcc\decl.C99\Error_enum_multidef.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("'enum ");
+				INC_INFORM(fullname);
+				free(namespace_name);
+				INFORM("' already defined (C++98 3.2p1)");
+				const enum_def* const tmp2 = types.get_enum_def(tmp);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				// now it's gone
+				src.DeleteNSlotsAt<0>(1,i);
+				continue;
+				};
+			free(namespace_name);
+			//! \test zcc\decl.C99\Pass_enum_def.hpp
+			// enum-specifier doesn't have a specific declaration mode
+			const type_system::type_index tmp2 = types.register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			assert(types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
 				{
-				type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-				src.c_array<0>()[i].type_code.set_type(tmp);
+				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+				return;
 				}
-			else if (is_C99_named_specifier(src.data<0>()[i],"class"))
+			}
+		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
+			{	// enum-specifier doesn't have a specific declaration mode
+				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
+			const type_system::type_index tmp = types.register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
 				{
-				type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-				src.c_array<0>()[i].type_code.set_type(tmp);
+				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+				return;
 				}
-			else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
-				{	// can only define once
+			}
+
+		if (	1<src.size<0>()-i
+			&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
+			{	// is_C99_named_specifier(src.data<0>()[i],"enum") will cause an error later, in variable parsing
+			if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous union declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous struct declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			else if (is_C99_anonymous_specifier(src.data<0>()[i],"class"))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous class declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			else if (is_C99_named_specifier(src.data<0>()[i],"union"))
+				{	// forward-declare, fine
 				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
 				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-				const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_union(fullname));
-				if (tmp)
-					{	//! \test zcc/decl.C99/Error_union_multidef.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'union ");
-					INC_INFORM(fullname);
+				if (types.get_id_union(fullname))
+					{	// but if already (forward-)declared then this is a no-op
+						// think this is common enough to not warrant OAOO/DRY treatment
+					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+					// remove from parse
 					free(namespace_name);
-					INFORM("' already defined (C++98 3.2p1)");
-					message_header(*tmp);
-					INFORM("prior definition here");
-					zcc_errors.inc_error();
-					// now it's gone
-					// remove trailing semicolon if present
-					src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
-					continue;
+					src.DeleteNSlotsAt<0>(2,i);
+					continue;					
 					}
 				free(namespace_name);
+				// forward-declare
+				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+				//! \todo fix up fully-qualified name
+				const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array<0>()[i].type_code.set_type(tmp2);
+				i += 2;
+				continue;
 				}
-			else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
-				{	// can only define once
+			else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
+				{	// forward-declare, fine
 				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
 				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-				const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(fullname));
-				if (tmp)
-					{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'struct ");
-					INC_INFORM(fullname);
+				if (types.get_id_struct_class(fullname))
+					{	// but if already (forward-)declared then this is a no-op
+						// think this is common enough to not warrant OAOO/DRY treatment
+					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+					// remove from parse
 					free(namespace_name);
-					INFORM("' already defined (C++98 3.2p1)");
-					message_header(*tmp);
-					INFORM("prior definition here");
-					zcc_errors.inc_error();
-					// now it's gone
-					// remove trailing semicolon if present
-					src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
-					continue;
+					src.DeleteNSlotsAt<0>(2,i);
+					continue;					
 					}
 				free(namespace_name);
+				// forward-declare
+				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+				//! \todo fix up fully-qualified name
+				const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array<0>()[i].type_code.set_type(tmp2);
+				i += 2;
+				continue;
 				}
-			else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
-				{	// can only define once
+			else if (is_C99_named_specifier(src.data<0>()[i],"class"))
+				{	// forward-declare, fine
 				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
 				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-				const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(fullname));
-				if (tmp)
-					{	//! \test zcc/decl.C99/Error_class_multidef.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'class ");
-					INC_INFORM(fullname);
+				if (types.get_id_struct_class(fullname))
+					{	// but if already (forward-)declared then this is a no-op
+						// think this is common enough to not warrant OAOO/DRY treatment
+					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+					// remove from parse
 					free(namespace_name);
-					INFORM("' already defined (C++98 3.2p1)");
-					message_header(*tmp);
-					INFORM("prior definition here");
-					zcc_errors.inc_error();
-					// now it's gone
-					// remove trailing semicolon if present
-					src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
-					continue;
+					src.DeleteNSlotsAt<0>(2,i);
+					continue;					
 					}
 				free(namespace_name);
+				// forward-declare
+				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+				//! \todo fix up fully-qualified name
+				const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array<0>()[i].type_code.set_type(tmp2);
+				i += 2;
+				continue;
 				}
-			// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
-			//! \todo actually, we can try forward-declare both scoped enums and enum-based enums (C++0X 7.2p3, these have enough size information); but other parts of the standard get in the way
-			else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
-				{
-				if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
-					{
-					type_system::type_index tmp = types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-					src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
-					if (!tmp)
-						{	// this belongs elsewhere
-							//! \test zcc\decl.C99\Error_enum_undef.hpp
-						message_header(src.data<0>()[i].index_tokens[0]);
-						INC_INFORM(ERR_STR);
-						INC_INFORM("'enum ");
-						INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-						INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
-						zcc_errors.inc_error();
-						src.c_array<0>()[i].flags |= parse_tree::INVALID;
-						}
-					}
-				//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
-				}
-			else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
-				{	// can only define once
+			else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
+				{	// definitions...fine
 				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
 				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-				type_system::type_index tmp = types.get_id_enum(fullname);
-				if (tmp)
-					{	//! \test zcc\decl.C99\Error_enum_multidef.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'enum ");
-					INC_INFORM(fullname);
-					free(namespace_name);
-					INFORM("' already defined (C++98 3.2p1)");
-					const enum_def* const tmp2 = types.get_enum_def(tmp);
-					assert(tmp2);
-					message_header(*tmp2);
-					INFORM("prior definition here");
-					zcc_errors.inc_error();
-					// now it's gone
-					src.DeleteNSlotsAt<0>(1,i);
-					continue;
-					};
+				const type_system::type_index tmp = types.get_id_union(fullname);
 				free(namespace_name);
-				//! \test zcc\decl.C99\Pass_enum_def.hpp
-				// enum-specifier doesn't have a specific declaration mode
-				const type_system::type_index tmp2 = types.register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-				assert(types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-				if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
-					{
-					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
-					return;
-					}
-				}
-			else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
-				{	// enum-specifier doesn't have a specific declaration mode
-					//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-				const type_system::type_index tmp = types.register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-				if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,src.data<0>()[i].index_tokens[1].token.first,NULL,true,CPP_echo_reserved_keyword))
-					{
-					INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
-					return;
-					}
-				}
-
-			if (	1<src.size<0>()-i
-				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
-				{	// is_C99_named_specifier(src.data<0>()[i],"enum") will cause an error later, in variable parsing
-				if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
-					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-						//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-						//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("unreferenceable anonymous union declaration");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// remove from parse
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;
-					}
-				else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
-					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-						//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-						//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("unreferenceable anonymous struct declaration");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// remove from parse
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;
-					}
-				else if (is_C99_anonymous_specifier(src.data<0>()[i],"class"))
-					{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-						//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-						//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("unreferenceable anonymous class declaration");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// remove from parse
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;
-					}
-				else if (is_C99_named_specifier(src.data<0>()[i],"union"))
-					{	// forward-declare, fine
-					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-					const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-					if (types.get_id_union(fullname))
-						{	// but if already (forward-)declared then this is a no-op
-							// think this is common enough to not warrant OAOO/DRY treatment
+				C_union_struct_def* tmp2 = NULL;
+				if (tmp)
+					{	// promoting forward-declare to definition
 						//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-						// remove from parse
-						free(namespace_name);
-						src.DeleteNSlotsAt<0>(2,i);
-						continue;					
-						}
-					free(namespace_name);
-					// forward-declare
-					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-					//! \todo fix up fully-qualified name
-					const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
+					assert(tmp3);
+					tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+					//! \todo record field structure, etc.
+					types.upgrade_decl_to_def(tmp,tmp2);
+					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp);
+					assert(types.get_C_structdef(tmp));
+					}
+				else{	// definition
+						//! \test zcc/decl.C99/Pass_union_def.hpp
+					//! \todo record field structure, etc.
+					const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_union);
 					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-					assert(types.get_structdecl(tmp2));
-					src.c_array<0>()[i].type_code.set_type(tmp2);
-					i += 2;
-					continue;
+					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
+					assert(types.get_C_structdef(tmp3));
+					src.c_array<0>()[i].type_code.set_type(tmp3);
 					}
-				else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
-					{	// forward-declare, fine
-					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-					const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-					if (types.get_id_struct_class(fullname))
-						{	// but if already (forward-)declared then this is a no-op
-							// think this is common enough to not warrant OAOO/DRY treatment
+				i += 2;
+				continue;
+				}
+			else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
+				{	// definitions...fine
+				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+				const type_system::type_index tmp = types.get_id_struct_class(fullname);
+				free(namespace_name);
+				C_union_struct_def* tmp2 = NULL;
+				if (tmp)
+					{	// promoting forward-declare to definition
 						//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-						// remove from parse
-						free(namespace_name);
-						src.DeleteNSlotsAt<0>(2,i);
-						continue;					
-						}
-					free(namespace_name);
-					// forward-declare
-					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-					//! \todo fix up fully-qualified name
-					const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
+					assert(tmp3);
+					tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+					//! \todo record field structure, etc.
+					types.upgrade_decl_to_def(tmp,tmp2);
+					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp);
+					assert(types.get_C_structdef(tmp));
+					}
+				else{	// definition
+						//! \test zcc/decl.C99/Pass_struct_def.hpp
+					//! \todo record field structure, etc.
+					const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_struct);
 					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-					assert(types.get_structdecl(tmp2));
-					src.c_array<0>()[i].type_code.set_type(tmp2);
-					i += 2;
-					continue;
+					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
+					assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
+					src.c_array<0>()[i].type_code.set_type(tmp3);
 					}
-				else if (is_C99_named_specifier(src.data<0>()[i],"class"))
-					{	// forward-declare, fine
-					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-					const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-					if (types.get_id_struct_class(fullname))
-						{	// but if already (forward-)declared then this is a no-op
-							// think this is common enough to not warrant OAOO/DRY treatment
+				i += 2;
+				continue;
+				}
+			else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
+				{	// definitions...fine
+				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+				const type_system::type_index tmp = types.get_id_struct_class(fullname);
+				free(namespace_name);
+				C_union_struct_def* tmp2 = NULL;
+				if (tmp)
+					{	// promoting forward-declare to definition
 						//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-						// remove from parse
-						free(namespace_name);
-						src.DeleteNSlotsAt<0>(2,i);
-						continue;					
-						}
-					free(namespace_name);
-					// forward-declare
-					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-					//! \todo fix up fully-qualified name
-					const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
+					assert(tmp3);
+					tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+					//! \todo record field structure, etc.
+					types.upgrade_decl_to_def(tmp,tmp2);
+					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp);
+					assert(types.get_C_structdef(tmp));
+					}
+				else{	// definition
+						//! \test zcc/decl.C99/Pass_class_def.hpp
+					//! \todo record field structure, etc.
+					const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_class);
 					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-					assert(types.get_structdecl(tmp2));
-					src.c_array<0>()[i].type_code.set_type(tmp2);
-					i += 2;
-					continue;
+					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
+					assert(types.get_C_structdef(tmp3));
+					src.c_array<0>()[i].type_code.set_type(tmp3);
 					}
-				else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
-					{	// definitions...fine
-					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-					const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-					const type_system::type_index tmp = types.get_id_union(fullname);
-					free(namespace_name);
-					C_union_struct_def* tmp2 = NULL;
-					if (tmp)
-						{	// promoting forward-declare to definition
-							//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-						const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-						assert(tmp3);
-						tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-						//! \todo record field structure, etc.
-						types.upgrade_decl_to_def(tmp,tmp2);
-						assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp);
-						assert(types.get_C_structdef(tmp));
-						}
-					else{	// definition
-							//! \test zcc/decl.C99/Pass_union_def.hpp
-						//! \todo record field structure, etc.
-						const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_union);
-						assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-						assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
-						assert(types.get_C_structdef(tmp3));
-						src.c_array<0>()[i].type_code.set_type(tmp3);
-						}
-					i += 2;
-					continue;
-					}
-				else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
-					{	// definitions...fine
-					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-					const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-					const type_system::type_index tmp = types.get_id_struct_class(fullname);
-					free(namespace_name);
-					C_union_struct_def* tmp2 = NULL;
-					if (tmp)
-						{	// promoting forward-declare to definition
-							//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-						const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-						assert(tmp3);
-						tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-						//! \todo record field structure, etc.
-						types.upgrade_decl_to_def(tmp,tmp2);
-						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp);
-						assert(types.get_C_structdef(tmp));
-						}
-					else{	// definition
-							//! \test zcc/decl.C99/Pass_struct_def.hpp
-						//! \todo record field structure, etc.
-						const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_struct);
-						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
-						assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
-						src.c_array<0>()[i].type_code.set_type(tmp3);
-						}
-					i += 2;
-					continue;
-					}
-				else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
-					{	// definitions...fine
-					char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-					const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-					const type_system::type_index tmp = types.get_id_struct_class(fullname);
-					free(namespace_name);
-					C_union_struct_def* tmp2 = NULL;
-					if (tmp)
-						{	// promoting forward-declare to definition
-							//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-						const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-						assert(tmp3);
-						tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-						//! \todo record field structure, etc.
-						types.upgrade_decl_to_def(tmp,tmp2);
-						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp);
-						assert(types.get_C_structdef(tmp));
-						}
-					else{	// definition
-							//! \test zcc/decl.C99/Pass_class_def.hpp
-						//! \todo record field structure, etc.
-						const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_class);
-						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-						assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
-						assert(types.get_C_structdef(tmp3));
-						src.c_array<0>()[i].type_code.set_type(tmp3);
-						}
-					i += 2;
-					continue;
-					};
+				i += 2;
+				continue;
 				};
-//			}
+			};
 		// namespace scanner
 		// need some scheme to handle unnamed namespaces (probably alphabetical counter after something illegal so unmatchable)
 		// C++0X has inline namespaces; ignore these for now (well, maybe not: consuming the inline will prevent problems)
@@ -11933,9 +11851,8 @@
 					INC_INFORM(ERR_STR);
 					INFORM("declaration disoriented by missing , (C++98 7p1)");
 					// find the next semicolon
-					size_t j = i+decl_count+decl_offset;
-					while(!robust_token_is_char<';'>(src.data<0>()[j]) && src.size<0>()> ++j);
-					src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
+					const size_t span = span_to_semicolon(src.begin<0>()+(i+decl_count+decl_offset),src.end<0>());
+					src.DeleteNSlotsAt<0>(span,i+decl_count+decl_offset);
 					continue;
 					}
 				++decl_offset;



From zaimoni at mail.berlios.de  Sat Dec 19 07:15:19 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 19 Dec 2009 07:15:19 +0100
Subject: [Zcplusplus-commits] r308 - in trunk/Zaimoni.STL: . Pure.C
Message-ID: <200912190615.nBJ6FJ4Z005879@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-19 07:14:59 +0100 (Sat, 19 Dec 2009)
New Revision: 308

Modified:
   trunk/Zaimoni.STL/MetaRAM2.hpp
   trunk/Zaimoni.STL/Pure.C/int_probe.c
Log:
unbreak build on MingW32 4.3.3; warning suppression for intprobe.c

Modified: trunk/Zaimoni.STL/MetaRAM2.hpp
===================================================================
--- trunk/Zaimoni.STL/MetaRAM2.hpp	2009-12-10 21:48:47 UTC (rev 307)
+++ trunk/Zaimoni.STL/MetaRAM2.hpp	2009-12-19 06:14:59 UTC (rev 308)
@@ -9,6 +9,8 @@
 #include "MetaRAM.hpp"
 #ifndef ZAIMONI_FORCE_ISO
 #include "z_memory.h"
+#else
+#include <stdlib.h>
 #endif
 #include "Logging.h"
 

Modified: trunk/Zaimoni.STL/Pure.C/int_probe.c
===================================================================
--- trunk/Zaimoni.STL/Pure.C/int_probe.c	2009-12-10 21:48:47 UTC (rev 307)
+++ trunk/Zaimoni.STL/Pure.C/int_probe.c	2009-12-19 06:14:59 UTC (rev 308)
@@ -35,7 +35,7 @@
 	fflush(stdout);
 }
 
-int main(int argc, char* argv[])
+int main()
 {
 	unsigned int i;
 	int null_is_zero = 1;



From zaimoni at mail.berlios.de  Sat Dec 19 19:38:32 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 19 Dec 2009 19:38:32 +0100
Subject: [Zcplusplus-commits] r309 - in trunk: . POSIX/cmp Zaimoni.STL
	Zaimoni.STL/Pure.C Zaimoni.STL/Pure.C/compile.test
Message-ID: <200912191838.nBJIcWOi003690@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-19 19:38:23 +0100 (Sat, 19 Dec 2009)
New Revision: 309

Added:
   trunk/Zaimoni.STL/Pure.C/compile.test/
   trunk/Zaimoni.STL/Pure.C/compile.test/exists_MS_io_h.c
   trunk/Zaimoni.STL/Pure.C/comptest.in
Modified:
   trunk/NMake.inc
   trunk/POSIX/cmp/cmp.c
   trunk/Zaimoni.STL/Compiler.h
   trunk/Zaimoni.STL/Pure.C/GNUmakefile
   trunk/Zaimoni.STL/Pure.C/NMakefile
   trunk/Zaimoni.STL/cstdio
Log:
use a compile test to detect Microsoft io.h

Modified: trunk/NMake.inc
===================================================================
--- trunk/NMake.inc	2009-12-19 06:14:59 UTC (rev 308)
+++ trunk/NMake.inc	2009-12-19 18:38:23 UTC (rev 309)
@@ -6,6 +6,12 @@
 includedir = $(exec_prefix)\include
 libdir = $(exec_prefix)\lib
 
+host_prefix = c:\MSVC9.0\VC
+host_exec_prefix = $(host_prefix)
+host_bindir = $(host_exec_prefix)\bin
+host_includedir = $(host_exec_prefix)\include
+host_libdir = $(host_exec_prefix)\lib
+
 AR = lib
 
 EXEEXT = exe

Modified: trunk/POSIX/cmp/cmp.c
===================================================================
--- trunk/POSIX/cmp/cmp.c	2009-12-19 06:14:59 UTC (rev 308)
+++ trunk/POSIX/cmp/cmp.c	2009-12-19 18:38:23 UTC (rev 309)
@@ -9,6 +9,7 @@
 #include <limits.h>
 #include <fcntl.h>
 #include "../../Zaimoni.STL/Logging.h"
+#include "../../Zaimoni.STL/Pure.C/comptest.h"
 
 #define OUTPUT_DEFAULT 0
 #define OUTPUT_VERBOSE 1

Modified: trunk/Zaimoni.STL/Compiler.h
===================================================================
--- trunk/Zaimoni.STL/Compiler.h	2009-12-19 06:14:59 UTC (rev 308)
+++ trunk/Zaimoni.STL/Compiler.h	2009-12-19 18:38:23 UTC (rev 309)
@@ -92,11 +92,6 @@
 #	define z_realpath(TARGET,SRC) realpath(TARGET,SRC)
 #endif
 
-/* detection of Microsoftish io.h : provides _filelength and _fileno */
-#if defined(__MINGW32__)
-#define ZAIMONI_HAVE_MICROSOFT_IO_H 1
-#endif
-
 /* hooks for properties of the libraries */
 /* undefine this if C/C++ library sqrt() is inaccurate [use _root(x,2) in med_alg.hpp to replace] */
 #define ZAIMONI_ALLOW_SQRT 1

Modified: trunk/Zaimoni.STL/Pure.C/GNUmakefile
===================================================================
--- trunk/Zaimoni.STL/Pure.C/GNUmakefile	2009-12-19 06:14:59 UTC (rev 308)
+++ trunk/Zaimoni.STL/Pure.C/GNUmakefile	2009-12-19 18:38:23 UTC (rev 309)
@@ -11,10 +11,10 @@
 LIBS := libz_format_util.a
 
 # GNU targets we know about
-all: $(LIBS) auto_int.h
+all: $(LIBS) auto_int.h comptest.h
 
 clean:
-	rm -f *.a *.o auto_int.h
+	rm -f *.a *.o auto_int.h comptest.h
 
 install: $(addprefix $(libdir)/, $(LIBS))
 
@@ -29,6 +29,12 @@
 	./int_probe.exe > auto_int.h
 	rm int_probe.exe
 
+comptest.h : comptest.in compile.test/exists_MS_io_h.c
+	cp comptest.in comptest.h
+	-$(CC) -oexists_MS_io_h.exe $(CFLAGS) -mconsole $(ARCH_FLAGS) compile.test/exists_MS_io_h.c
+	-./exists_MS_io_h.exe >> comptest.h
+	-rm exists_MS_io_h.exe
+
 .c.o:
 	$(CC) -c $< $(CFLAGS) $(ARCH_FLAGS) -o $*.o
 

Modified: trunk/Zaimoni.STL/Pure.C/NMakefile
===================================================================
--- trunk/Zaimoni.STL/Pure.C/NMakefile	2009-12-19 06:14:59 UTC (rev 308)
+++ trunk/Zaimoni.STL/Pure.C/NMakefile	2009-12-19 18:38:23 UTC (rev 309)
@@ -12,10 +12,10 @@
 LIBS = z_format_util.lib
 
 # GNU targets we know about
-all: $(LIBS) auto_int.h
+all: $(LIBS) auto_int.h comptest.h
 
 clean:
-	del *.lib *.obj auto_int.h
+	del *.lib *.obj auto_int.h comptest.h
 
 install: $(libdir)\z_format_util.lib $(libdir)\z_logging.lib
 
@@ -31,6 +31,13 @@
 	del int_probe.exe.manifest
 	del int_probe.exe
 
+comptest.h : comptest.in compile.test/exists_MS_io_h.c
+	copy comptest.in comptest.h
+	$(CC) /OUT:exists_MS_io_h.exe $(CFLAGS) compile.test/exists_MS_io_h.c
+	.\exists_MS_io_h.exe >> comptest.h
+	del exists_MS_io_h.exe.manifest
+	del exists_MS_io_h.exe
+
 # defaulting .c.obj
 z_format_util.lib: format_util.obj
 	$(AR) /OUT:z_format_util.lib format_util.obj

Added: trunk/Zaimoni.STL/Pure.C/compile.test/exists_MS_io_h.c
===================================================================
--- trunk/Zaimoni.STL/Pure.C/compile.test/exists_MS_io_h.c	2009-12-19 06:14:59 UTC (rev 308)
+++ trunk/Zaimoni.STL/Pure.C/compile.test/exists_MS_io_h.c	2009-12-19 18:38:23 UTC (rev 309)
@@ -0,0 +1,19 @@
+/* exists_MS_io_h.c */
+/* tests for Microsoftish io.h */
+/* (C)2009 Kenneth Boyd, license: MIT.txt */
+
+#include <stdio.h>
+#include <io.h>
+
+#define STRING_LITERAL_TO_STDOUT(A) fwrite(A,sizeof(A)-1,1,stdout)
+
+long get_filelength(FILE* src)
+{
+	return _filelength(_fileno(src));
+}
+
+int main()
+{
+	STRING_LITERAL_TO_STDOUT("#define ZAIMONI_HAS_MICROSOFT_IO_H 1\n");
+	return 0;
+}

Added: trunk/Zaimoni.STL/Pure.C/comptest.in
===================================================================
--- trunk/Zaimoni.STL/Pure.C/comptest.in	2009-12-19 06:14:59 UTC (rev 308)
+++ trunk/Zaimoni.STL/Pure.C/comptest.in	2009-12-19 18:38:23 UTC (rev 309)
@@ -0,0 +1,6 @@
+/* comptest.h */
+/* compile test summary */
+/* (C)2009 Kenneth Boyd, license: MIT.txt */
+
+/* HAVE_MICROSOFT_IO_H: #include <io.h> works and allows compiling Microsoft-specific idioms */
+

Modified: trunk/Zaimoni.STL/cstdio
===================================================================
--- trunk/Zaimoni.STL/cstdio	2009-12-19 06:14:59 UTC (rev 308)
+++ trunk/Zaimoni.STL/cstdio	2009-12-19 18:38:23 UTC (rev 309)
@@ -7,7 +7,8 @@
 
 #include "Logging.h"
 #include "MetaRAM.hpp"
-#include <cstdio>
+#include <stdio.h>
+#include "Pure.C/comptest.h"
 
 #ifdef ZAIMONI_HAVE_MICROSOFT_IO_H
 #include <io.h>



From zaimoni at mail.berlios.de  Sun Dec 20 08:46:01 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 20 Dec 2009 08:46:01 +0100
Subject: [Zcplusplus-commits] r310 - in trunk: . Zaimoni.STL
Message-ID: <200912200746.nBK7k1Oe005140@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-20 08:45:57 +0100 (Sun, 20 Dec 2009)
New Revision: 310

Modified:
   trunk/CPreproc.cpp
   trunk/Zaimoni.STL/cstdio
Log:
object size reduction; trying to track down a self-hosting assert in the preprocessor

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2009-12-19 18:38:23 UTC (rev 309)
+++ trunk/CPreproc.cpp	2009-12-20 07:45:57 UTC (rev 310)
@@ -2310,12 +2310,12 @@
 	if (0==ub)
 		{
 		if (!TokenList[i]->flags) TokenList[i]->flags = pretokenized[ub].third;
+		assert(ZAIMONI_LEN_WITH_NULL(pretokenized[ub].second)==TokenList[i]->size());
 		complete_string_character_literal(*TokenList[i]);
 		}
 	else{
 		size_t lb = 0;
-		autovalarray_ptr<Token<char>* > TokenListAlt(ub+1);
-		if (TokenListAlt.empty()) throw std::bad_alloc();
+		autovalarray_ptr_throws<Token<char>* > TokenListAlt(ub+1);
 		if (!TokenList.InsertNSlotsAt(ub,i+1)) throw std::bad_alloc();
 		{
 		const Token<char>& tmp = *TokenList[i];

Modified: trunk/Zaimoni.STL/cstdio
===================================================================
--- trunk/Zaimoni.STL/cstdio	2009-12-19 18:38:23 UTC (rev 309)
+++ trunk/Zaimoni.STL/cstdio	2009-12-20 07:45:57 UTC (rev 310)
@@ -19,38 +19,39 @@
 template<class T>
 inline typename boost::enable_if<boost::has_trivial_assign<T>, void>::type
 #ifndef ZAIMONI_FORCE_ISO
-ConvertBinaryModeToTextMode(T*& Buffer)
+ConvertBinaryModeToTextMode(T*& buf)
 #else
-ConvertBinaryModeToTextMode(T*& Buffer, size_t& BufferLen)
+ConvertBinaryModeToTextMode(T*& buf, size_t& buf_len)
 #endif
-{	//! \todo VERIFY
-	if (NULL!=Buffer)
+{
+	if (buf)
 		{
 #ifndef ZAIMONI_FORCE_ISO 
-		const size_t BufferLen = ArraySize(Buffer);
+		const size_t buf_len = ArraySize(buf);
 #else
-		assert(0<BufferLen);
+		assert(0<buf_len);
 #endif
 		size_t Displace = 0;
-		size_t ScanIdx = 0;
-		do	if ('\r'==Buffer[ScanIdx])
+		size_t i = 0;
+		do	if ('\r'==buf[i])
 				{	// oops.  We're either Windows ['\r\n'] or wrong-platform ['\r': UNIX on Mac, or Mac on Unix; '\n\r': Windows on UNIX]
-				const bool WindowsOnMac = (1<=ScanIdx && '\n'==Buffer[ScanIdx-1]);
-				const bool Windows = BufferLen>ScanIdx+1 && '\n'==Buffer[ScanIdx+1];
+				const bool WindowsOnMac = (1<=i && '\n'==buf[i-1]);
+				const bool Windows = buf_len>i+1 && '\n'==buf[i+1];
 				const bool WrongPlatform = !WindowsOnMac && !Windows;	// no problem if both
 				if (WrongPlatform)
-					Buffer[ScanIdx]='\n';
+					buf[i]='\n';
 				else{
-					if (BufferLen>(ScanIdx+1)) memmove(&Buffer[ScanIdx],&Buffer[ScanIdx+1],BufferLen-(ScanIdx+1));
+					if (buf_len>(i+1)) memmove(&buf[i],&buf[i+1],buf_len-(i+1));
 					++Displace;
+					--i;
 					}
 				}
-		while(BufferLen-Displace>++ScanIdx);
+		while(buf_len-Displace> ++i);
 		if (0<Displace)
 #ifndef ZAIMONI_FORCE_ISO
-			Buffer = zaimoni::REALLOC(Buffer,_msize(Buffer)-Displace);
+			buf = REALLOC(buf,_msize(buf)-Displace);
 #else
-			Buffer = zaimoni::REALLOC(Buffer,(BufferLen -= Displace));
+			buf = REALLOC(buf,(buf_len -= Displace));
 #endif
 		}
 }



From zaimoni at mail.berlios.de  Sun Dec 20 18:20:00 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 20 Dec 2009 18:20:00 +0100
Subject: [Zcplusplus-commits] r311 - trunk
Message-ID: <200912201720.nBKHK0pd031536@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-20 18:19:55 +0100 (Sun, 20 Dec 2009)
New Revision: 311

Modified:
   trunk/CPreproc.cpp
Log:
make load_src.hpp not assert

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2009-12-20 07:45:57 UTC (rev 310)
+++ trunk/CPreproc.cpp	2009-12-20 17:19:55 UTC (rev 311)
@@ -2310,7 +2310,9 @@
 	if (0==ub)
 		{
 		if (!TokenList[i]->flags) TokenList[i]->flags = pretokenized[ub].third;
-		assert(ZAIMONI_LEN_WITH_NULL(pretokenized[ub].second)==TokenList[i]->size());
+		// handle trailing whitespace
+		if (ZAIMONI_LEN_WITH_NULL(pretokenized[ub].second)<TokenList[i]->size())
+			TokenList[i]->lslice(pretokenized[ub].second);
 		complete_string_character_literal(*TokenList[i]);
 		}
 	else{



From zaimoni at mail.berlios.de  Sun Dec 20 22:18:38 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 20 Dec 2009 22:18:38 +0100
Subject: [Zcplusplus-commits] r312 - in trunk: . Zaimoni.STL
Message-ID: <200912202118.nBKLIcuZ003694@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-20 22:18:33 +0100 (Sun, 20 Dec 2009)
New Revision: 312

Modified:
   trunk/CPreproc_autogen.cpp
   trunk/Zaimoni.STL/AutoPtr.hpp
   trunk/Zaimoni.STL/MetaRAM2.hpp
Log:
optimize number of realloc() calls when generating stdint.h/cstdint

Modified: trunk/CPreproc_autogen.cpp
===================================================================
--- trunk/CPreproc_autogen.cpp	2009-12-20 17:19:55 UTC (rev 311)
+++ trunk/CPreproc_autogen.cpp	2009-12-20 21:18:33 UTC (rev 312)
@@ -873,51 +873,65 @@
 	size_t inject_C_index = STDINT_LEAST_FAST_INJECT_LINE;
 	size_t inject_CPP_index = STDINT_CPP_LEAST_FAST_INJECT_LINE;
 	// C++ typedef cleanup
+	{
+	size_t stack[9];
+	size_t stack_size = 0;
 	if (!target_is_twos_complement || suppress[virtual_machine::std_int_long_long-2])
 		{
-		TokenList.DeleteIdx(STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_LLONG_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_LLONG_OFFSET;
 		--inject_CPP_index;
 		}
 	if (!target_is_twos_complement || suppress[virtual_machine::std_int_long-2])
 		{
-		TokenList.DeleteIdx(STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_LONG_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_LONG_OFFSET;
 		--inject_CPP_index;
 		}
 	if (!target_is_twos_complement)
 		{
-		TokenList.DeleteIdx(STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_INT_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_INT_OFFSET;
 		--inject_CPP_index;
 		}
 	if (!target_is_twos_complement || suppress[virtual_machine::std_int_short-1])
 		{
-		TokenList.DeleteIdx(STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_SHRT_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_SHRT_OFFSET;
 		--inject_CPP_index;
 		}
 	if (!target_is_twos_complement || suppress[virtual_machine::std_int_char-1])
 		{
-		TokenList.DeleteIdx(STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_SCHAR_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_SCHAR_OFFSET;
 		--inject_CPP_index;
 		}
 	if (suppress[virtual_machine::std_int_long_long-2])
 		{
-		TokenList.DeleteIdx(STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_ULLONG_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_ULLONG_OFFSET;
 		--inject_CPP_index;
 		}
 	if (suppress[virtual_machine::std_int_long-2])
 		{
-		TokenList.DeleteIdx(STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_ULONG_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_ULONG_OFFSET;
 		--inject_CPP_index;
 		}
 	if (suppress[virtual_machine::std_int_short-1])
 		{
-		TokenList.DeleteIdx(STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_USHRT_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_USHRT_OFFSET;
 		--inject_CPP_index;
 		}
 	if (suppress[virtual_machine::std_int_char-1])
 		{
-		TokenList.DeleteIdx(STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_UCHAR_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_UCHAR_OFFSET;
 		--inject_CPP_index;
-		}
+		}	
+	if (0<stack_size) TokenList.DeleteNSlots(stack,stack_size);
+	}
 
 	// limits macros cleanup
 	char lock_buf[sizeof("#pragma ZCC lock INT_LEAST_MIN INT_LEAST_MAX UINT_LEAST_MAX INT_FAST_MIN INT_FAST_MAX UINT_FAST_MAX INT_C UINT_C")+8*2] = "#pragma ZCC lock ";	// should be dependent on base 10 logarithm of VM_MAX_BIT_PLATFORM: fix auto_int.h
@@ -1051,60 +1065,75 @@
 		}
 
 	// C typedef cleanup
+	{
+	size_t stack[9];
+	size_t stack_size = 0;
+
 	if (!target_is_twos_complement || suppress[virtual_machine::std_int_long_long-2])
 		{
-		TokenList.DeleteIdx(STDINT_EXACT_LINEORIGIN+STDINT_EXACT_LLONG_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_EXACT_LINEORIGIN+STDINT_EXACT_LLONG_OFFSET;
 		--inject_CPP_index;
 		--inject_C_index;
 		}
 	if (!target_is_twos_complement || suppress[virtual_machine::std_int_long-2])
 		{
-		TokenList.DeleteIdx(STDINT_EXACT_LINEORIGIN+STDINT_EXACT_LONG_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_EXACT_LINEORIGIN+STDINT_EXACT_LONG_OFFSET;
 		--inject_CPP_index;
 		--inject_C_index;
 		}
 	if (!target_is_twos_complement)
 		{
-		TokenList.DeleteIdx(STDINT_EXACT_LINEORIGIN+STDINT_EXACT_INT_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_EXACT_LINEORIGIN+STDINT_EXACT_INT_OFFSET;
 		--inject_CPP_index;
 		--inject_C_index;
 		}
 	if (!target_is_twos_complement || suppress[virtual_machine::std_int_short-1])
 		{
-		TokenList.DeleteIdx(STDINT_EXACT_LINEORIGIN+STDINT_EXACT_SHRT_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_EXACT_LINEORIGIN+STDINT_EXACT_SHRT_OFFSET;
 		--inject_CPP_index;
 		--inject_C_index;
 		}
 	if (!target_is_twos_complement || suppress[virtual_machine::std_int_char-1])
 		{
-		TokenList.DeleteIdx(STDINT_EXACT_LINEORIGIN+STDINT_EXACT_SCHAR_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_EXACT_LINEORIGIN+STDINT_EXACT_SCHAR_OFFSET;
 		--inject_CPP_index;
 		--inject_C_index;
 		}
 	if (suppress[virtual_machine::std_int_long_long-2])
 		{
-		TokenList.DeleteIdx(STDINT_EXACT_LINEORIGIN+STDINT_EXACT_ULLONG_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_EXACT_LINEORIGIN+STDINT_EXACT_ULLONG_OFFSET;
 		--inject_CPP_index;
 		--inject_C_index;
 		}
 	if (suppress[virtual_machine::std_int_long-2])
 		{
-		TokenList.DeleteIdx(STDINT_EXACT_LINEORIGIN+STDINT_EXACT_ULONG_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_EXACT_LINEORIGIN+STDINT_EXACT_ULONG_OFFSET;
 		--inject_CPP_index;
 		--inject_C_index;
 		}
 	if (suppress[virtual_machine::std_int_short-1])
 		{
-		TokenList.DeleteIdx(STDINT_EXACT_LINEORIGIN+STDINT_EXACT_USHRT_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_EXACT_LINEORIGIN+STDINT_EXACT_USHRT_OFFSET;
 		--inject_CPP_index;
 		--inject_C_index;
 		}
 	if (suppress[virtual_machine::std_int_char-1])
 		{
-		TokenList.DeleteIdx(STDINT_EXACT_LINEORIGIN+STDINT_EXACT_UCHAR_OFFSET);
+		assert(STATIC_SIZE(stack)>stack_size);
+		stack[stack_size++] = STDINT_EXACT_LINEORIGIN+STDINT_EXACT_UCHAR_OFFSET;
 		--inject_CPP_index;
 		--inject_C_index;
 		}
+	if (0<stack_size) TokenList.DeleteNSlots(stack,stack_size);	
+	}
 
 	// prepare to inject least/fast types and their adapter macros
 	// span...start with *8_t and go up to long long bits

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2009-12-20 17:19:55 UTC (rev 311)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2009-12-20 21:18:33 UTC (rev 312)
@@ -334,10 +334,12 @@
 #ifndef ZAIMONI_FORCE_ISO
 	void DeleteIdx(size_t n) {_safe_delete_idx(_ptr,n);};
 	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(_ptr,n,Idx);};
+	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(_ptr,indexes,n);};
 	template<typename U> bool InsertSlotAt(size_t Idx, U __default) {return _insert_slot_at(_ptr,Idx,__default);}
 #else
 	void DeleteIdx(size_t n) {_safe_delete_idx(_ptr,_size,n);};
 	void DeleteNSlotsAt(size_t n, size_t Idx) {_delete_n_slots_at(_ptr,_size,n,Idx);};
+	void DeleteNSlots(size_t* indexes,size_t n) {_delete_n_slots(_ptr,_size,indexes,n);};
 	template<typename U> bool InsertSlotAt(size_t Idx, U __default) {return _insert_slot_at(_ptr,_size,Idx,__default);}
 #endif
 

Modified: trunk/Zaimoni.STL/MetaRAM2.hpp
===================================================================
--- trunk/Zaimoni.STL/MetaRAM2.hpp	2009-12-20 17:19:55 UTC (rev 311)
+++ trunk/Zaimoni.STL/MetaRAM2.hpp	2009-12-20 21:18:33 UTC (rev 312)
@@ -812,6 +812,90 @@
 }
 
 template<typename T>
+typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_destructor<T>::value, boost::has_trivial_assign<T>::value >, void>::type
+#ifndef ZAIMONI_FORCE_ISO
+_delete_n_slots(T*& _ptr, size_t* _indexes, size_t n)
+{
+	assert(_ptr);
+	assert(_indexes);
+	const size_t _ptr_size = ArraySize(_ptr);
+#else
+_delete_n_slots(T*& _ptr, size_t& _ptr_size, size_t* _indexes, size_t n)
+{
+	assert(_ptr);
+	assert(_indexes);
+	assert(0<_ptr_size);
+#endif
+	if (0>=n) return;
+	assert(_indexes[0]<_ptr_size);
+	if (_ptr_size<=n)
+		{
+		_flush(_ptr);
+		_ptr = NULL;
+#ifdef ZAIMONI_FORCE_ISO
+		_ptr_size = 0;
+#endif
+		return;
+		}
+
+	size_t i = 0;
+	while(i<n)
+		{
+		assert(i+1>=n || _indexes[i]>_indexes[i+1]);
+		if (_indexes[i]+i<_ptr_size)
+			memmove(_ptr+_indexes[i],_ptr+_indexes[i]+1,sizeof(*_ptr)*(_ptr_size-(_indexes[i]+i)));
+		++i;
+		}
+
+	_ptr = REALLOC(_ptr,sizeof(*_ptr)*(_ptr_size-n));
+#ifdef ZAIMONI_FORCE_ISO
+	_ptr_size -= n;
+#endif
+}
+
+template<typename T>
+#ifndef ZAIMONI_FORCE_ISO
+void _delete_n_slots(T**& _ptr, size_t* _indexes, size_t n)
+{
+	assert(_ptr);
+	assert(_indexes);
+	const size_t _ptr_size = ArraySize(_ptr);
+#else
+void _delete_n_slots(T**& _ptr, size_t& _ptr_size, size_t* _indexes, size_t n)
+{
+	assert(_ptr);
+	assert(_indexes);
+	assert(0<_ptr_size);
+#endif
+	if (0>=n) return;
+	assert(_indexes[0]<_ptr_size);
+	if (_ptr_size<=n)
+		{
+		_flush(_ptr);
+		_ptr = NULL;
+#ifdef ZAIMONI_FORCE_ISO
+		_ptr_size = 0;
+#endif
+		return;
+		}
+
+	size_t i = 0;
+	while(i<n)
+		{
+		assert(i+1>=n || _indexes[i]>_indexes[i+1]);
+		_single_flush(_ptr[_indexes[i]]);
+		if (_indexes[i]+i<_ptr_size)
+			memmove(_ptr+_indexes[i],_ptr+_indexes[i]+1,sizeof(*_ptr)*(_ptr_size-(_indexes[i]+i)));
+		++i;
+		}
+
+	_ptr = REALLOC(_ptr,sizeof(*_ptr)*(_ptr_size-n));
+#ifdef ZAIMONI_FORCE_ISO
+	_ptr_size -= n;
+#endif
+}
+
+template<typename T>
 void
 _weak_delete_n_slots_at(T**& _ptr, size_t n, size_t Idx)
 {



From zaimoni at mail.berlios.de  Sun Dec 20 23:08:15 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 20 Dec 2009 23:08:15 +0100
Subject: [Zcplusplus-commits] r313 - trunk
Message-ID: <200912202208.nBKM8F0i008340@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-20 23:08:12 +0100 (Sun, 20 Dec 2009)
New Revision: 313

Modified:
   trunk/CPreproc.cpp
Log:
object file size reduction

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2009-12-20 21:18:33 UTC (rev 312)
+++ trunk/CPreproc.cpp	2009-12-20 22:08:12 UTC (rev 313)
@@ -1654,8 +1654,7 @@
 							TokenList[i+2]->ltrim(1);
 						if (2<TokenList[i+2]->size())
 							{	//! \test Pass_pragma_STDC.hpp
-							autovalarray_ptr<char> pragma_string(lang.UnescapeStringLength(TokenList[i+2]->data()+1,TokenList[i+2]->size()-2));
-							if (pragma_string.empty()) throw std::bad_alloc();
+							autovalarray_ptr_throws<char> pragma_string(lang.UnescapeStringLength(TokenList[i+2]->data()+1,TokenList[i+2]->size()-2));
 							lang.UnescapeString(pragma_string.c_array(),TokenList[i+2]->data()+1,TokenList[i+2]->size()-2);
 							interpret_pragma(pragma_string.data(),pragma_string.size(),locked_macros);
 							};
@@ -3663,8 +3662,7 @@
 static bool _concatenate_single(Token<char>& x,const POD_triple<size_t,size_t,lex_flags>* pretokenized, LangConf& lang)
 {
 	assert(NULL!=pretokenized);
-	autovalarray_ptr<char> new_token(pretokenized[0].second+pretokenized[2].second);
-	if (new_token.empty()) throw std::bad_alloc();
+	autovalarray_ptr_throws<char> new_token(pretokenized[0].second+pretokenized[2].second);
 	strncpy(new_token.c_array(),x.data()+pretokenized[0].first,pretokenized[0].second);
 	strncpy(new_token.c_array()+pretokenized[0].second,x.data()+pretokenized[2].first,pretokenized[2].second);
 	lex_flags scratch_flags;
@@ -4210,10 +4208,13 @@
 		const size_t escape_length = lang.UnescapeStringLength(TokenList[i]->data()+critical_offset+1,second_token_len-2);
 		if (escape_length<second_token_len-2)
 			{
-			autovalarray_ptr<char> tmp(escape_length);
-			if (tmp.empty() && 0<escape_length) throw std::bad_alloc();
-			if (0<escape_length) lang.UnescapeString(tmp.c_array(),TokenList[i]->data()+critical_offset+1,second_token_len-2);
-			new_FILE = register_string(tmp.empty() ? "" : tmp.data());
+			if (0==escape_length)
+				new_FILE = "";
+			else{
+				autovalarray_ptr_throws<char> tmp(escape_length);
+				lang.UnescapeString(tmp.c_array(),TokenList[i]->data()+critical_offset+1,second_token_len-2);
+				new_FILE = register_string(tmp.data());
+				}
 			}
 		else
 			new_FILE = register_substring(TokenList[i]->data()+critical_offset+1,second_token_len-2);



From zaimoni at mail.berlios.de  Wed Dec 30 20:47:57 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 30 Dec 2009 20:47:57 +0100
Subject: [Zcplusplus-commits] r314 - trunk
Message-ID: <200912301947.nBUJlvnK008458@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-30 20:47:53 +0100 (Wed, 30 Dec 2009)
New Revision: 314

Modified:
   trunk/z_cpp.cpp
   trunk/zcc.cpp
Log:
unbreak MingW32 4.4.1

Modified: trunk/z_cpp.cpp
===================================================================
--- trunk/z_cpp.cpp	2009-12-20 22:08:12 UTC (rev 313)
+++ trunk/z_cpp.cpp	2009-12-30 19:47:53 UTC (rev 314)
@@ -17,6 +17,8 @@
 #include "Zaimoni.STL/POD.hpp"
 #include "Zaimoni.STL/Pure.C/format_util.h"
 
+#include <stdio.h>
+
 error_counter<size_t> zcc_errors(100,"FATAL: too many preprocessing errors");
 
 using namespace zaimoni;

Modified: trunk/zcc.cpp
===================================================================
--- trunk/zcc.cpp	2009-12-20 22:08:12 UTC (rev 313)
+++ trunk/zcc.cpp	2009-12-30 19:47:53 UTC (rev 314)
@@ -19,6 +19,8 @@
 #include "Zaimoni.STL/POD.hpp"
 #include "Zaimoni.STL/Pure.C/format_util.h"
 
+#include <stdio.h>
+
 error_counter<size_t> zcc_errors(100,"FATAL: too many errors");
 
 using namespace zaimoni;



From zaimoni at mail.berlios.de  Wed Dec 30 21:11:17 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 30 Dec 2009 21:11:17 +0100
Subject: [Zcplusplus-commits] r315 - trunk/Zaimoni.STL
Message-ID: <200912302011.nBUKBH6g010135@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-30 21:11:15 +0100 (Wed, 30 Dec 2009)
New Revision: 315

Modified:
   trunk/Zaimoni.STL/Logging.h
Log:
let Z.C++ cmp build cleanly in release mode

Modified: trunk/Zaimoni.STL/Logging.h
===================================================================
--- trunk/Zaimoni.STL/Logging.h	2009-12-30 19:47:53 UTC (rev 314)
+++ trunk/Zaimoni.STL/Logging.h	2009-12-30 20:11:15 UTC (rev 315)
@@ -176,7 +176,6 @@
 #define DEBUG_STATEMENT(A)
 #define DEBUG_FAIL_OR_LEAVE(A,B) if (A) B
 
-#define FATAL(A) FATAL(A);
 #define VERIFY(A,B) if (A) FATAL(B)
 #define REPORT(A,B) if (A) INFORM(B)
 #define DEBUG_LOG(A)



From zaimoni at mail.berlios.de  Wed Dec 30 22:16:19 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 30 Dec 2009 22:16:19 +0100
Subject: [Zcplusplus-commits] r316 - trunk
Message-ID: <200912302116.nBULGJo1014554@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-30 22:16:15 +0100 (Wed, 30 Dec 2009)
New Revision: 316

Modified:
   trunk/z_cpp.cpp
   trunk/zcc.cpp
Log:
more informative help

Modified: trunk/z_cpp.cpp
===================================================================
--- trunk/z_cpp.cpp	2009-12-30 20:11:15 UTC (rev 315)
+++ trunk/z_cpp.cpp	2009-12-30 21:16:15 UTC (rev 316)
@@ -193,6 +193,7 @@
 
 static void help(void)
 {
+	STRING_LITERAL_TO_STDOUT("Z.C++ 0.0.3 z_cpp\n");
 	STRING_LITERAL_TO_STDOUT("usage: z_cpp [options] infile\n");
 	STRING_LITERAL_TO_STDOUT("boolean options\n");
 	size_t i = 0;

Modified: trunk/zcc.cpp
===================================================================
--- trunk/zcc.cpp	2009-12-30 20:11:15 UTC (rev 315)
+++ trunk/zcc.cpp	2009-12-30 21:16:15 UTC (rev 316)
@@ -197,7 +197,8 @@
 
 static void help(void)
 {
-	STRING_LITERAL_TO_STDOUT("usage: z_cpp [options] infile\n");
+	STRING_LITERAL_TO_STDOUT("Z.C++ 0.0.3 zcc\n");
+	STRING_LITERAL_TO_STDOUT("usage: zcc [options] infile\n");
 	STRING_LITERAL_TO_STDOUT("boolean options\n");
 	size_t i = 0;
 	do	{



From zaimoni at mail.berlios.de  Wed Dec 30 22:18:52 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 30 Dec 2009 22:18:52 +0100
Subject: [Zcplusplus-commits] r317 - trunk/doc
Message-ID: <200912302118.nBULIqE6014729@sheep.berlios.de>

Author: zaimoni
Date: 2009-12-30 22:18:48 +0100 (Wed, 30 Dec 2009)
New Revision: 317

Modified:
   trunk/doc/OPTIONS.txt
Log:
update documentation

Modified: trunk/doc/OPTIONS.txt
===================================================================
--- trunk/doc/OPTIONS.txt	2009-12-30 21:16:15 UTC (rev 316)
+++ trunk/doc/OPTIONS.txt	2009-12-30 21:18:48 UTC (rev 317)
@@ -1,3 +1,24 @@
+Z.C++ 0.0.3 zcc
+usage: zcc [options] infile
+boolean options
+ --test: final internal state to stderr
+ -Werror: all warnings are now errors
+ --pedantic: try to be standard-compliant rather than pragmatic
+ --int-sign-magnitude: compile for a sign-magnitude integer machine
+ --int-ones-complement: compile for a one's complement integer machine
+ --int-twos-complement: compile for a two's complement integer machine (default)
+ --int-traps: signed int has a trap representation (-0 for sign-magnitude and one's complement, -(2^CHAR_BIT) for two's complement
+ -fsigned-char: char acts like signed char
+ -funsigned-char: char acts like unsigned char (default)
+ --int-neg-div-rounds-away-from-zero: make -3/-2==-2 contrary to C99 recommendation
+ -Wc-c++-compat: Warn when something legal in C/C++ would be an error in C++/C for C/C++
+ -Wbackport: Warn when something legal would be an error under an older standard
+override-default options
+ -x: language override
+ --system-include: unpreprocessed #include<...> to stdout
+ -fmax-errors: how many errors are too many (default 100)
+
+Z.C++ 0.0.3 z_cpp
 usage: z_cpp [options] infile
 boolean options
  --test: final internal state to stderr
@@ -14,3 +35,13 @@
  -x: language override
  --system-include: unpreprocessed #include<...> to stdout
  -fmax-errors: how many errors are too many (default 100)
+
+Z.C++ cmp 0.1
+usage: cmp [options] file1 file2
+options
+ -: use this by itself for STDIN on either file1 or file2
+ -l: POSIX 2/3 verbose listing on stdout
+ -s: print nothing to stdout
+
+This cmp doesn't respond to the following environment variables:
+	LANG LC_ALL LC_TYPE LC_MESSAGES NLSPATH



