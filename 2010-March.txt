From zaimoni at mail.berlios.de  Wed Mar  3 09:04:30 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 3 Mar 2010 09:04:30 +0100
Subject: [Zcplusplus-commits] r335 - trunk
Message-ID: <201003030804.o2384Utw015205@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-03 09:04:22 +0100 (Wed, 03 Mar 2010)
New Revision: 335

Modified:
   trunk/CPUInfo.cpp
   trunk/CPUInfo.hpp
   trunk/CPreproc_autogen.cpp
   trunk/CSupport.cpp
Log:
introduce typedef to reduce code bloat from supporting ZCC_LEGACY_FIXED_INT

Modified: trunk/CPUInfo.cpp
===================================================================
--- trunk/CPUInfo.cpp	2010-02-17 15:45:35 UTC (rev 334)
+++ trunk/CPUInfo.cpp	2010-03-03 08:04:22 UTC (rev 335)
@@ -43,8 +43,7 @@
 	while(std_int_long_long> ++i);
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-bool CPUInfo::trap_int(const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type) const
+bool CPUInfo::trap_int(const umaxint& src_int,std_int_enum machine_type) const
 {
 	switch(machine_type)
 	{
@@ -56,43 +55,11 @@
 	const unsigned int bitcount = C_bit(machine_type);
 	const int target_bytecount = bitcount/CHAR_BIT;
 	const unsigned int target_bitcount = bitcount%CHAR_BIT;
+#ifdef ZCC_LEGACY_FIXED_INT
 	assert(VM_MAX_BIT_PLATFORM>=bitcount && 1<=bitcount);
-
-	switch(C_signed_int_representation())
-	{
-	case ones_complement:	{	// bitwise all-ones may be trap (-0)
-							if (0<target_bytecount && target_bytecount>std::count(src_int._x,src_int._x+target_bytecount,UCHAR_MAX)) return false;
-							return 0==target_bitcount || (UCHAR_MAX>>(CHAR_BIT-target_bitcount))==((UCHAR_MAX>>(CHAR_BIT-target_bitcount)) & src_int._x[target_bytecount]);
-							}
-	case twos_complement:		// sign bit only set may be trap -(2^N)
-	case sign_and_magnitude:{	// sign bit only set may be trap (-0)
-							if (0==target_bitcount)
-								{
-								if (1<target_bytecount && target_bytecount-1>std::count(src_int._x,src_int._x+(target_bytecount-1U),0)) return false;
-								return (1U<<(CHAR_BIT-1))==src_int._x[target_bytecount-1];
-								}
-							else{
-								if (0<target_bytecount && target_bytecount>std::count(src_int._x,src_int._x+target_bytecount,0)) return false;
-								return (1U<<(CHAR_BIT-1-target_bitcount))==((UCHAR_MAX>>(CHAR_BIT-target_bitcount)) & src_int._x[target_bytecount]);
-								}
-							}
-	}
-	return false;
-}
 #else
-bool CPUInfo::trap_int(const unsigned_var_int& src_int,std_int_enum machine_type) const
-{
-	switch(machine_type)
-	{
-	default: return false;
-	case std_int_int:
-	case std_int_long:
-	case std_int_long_long:;
-	}
-	const unsigned int bitcount = C_bit(machine_type);
-	const int target_bytecount = bitcount/CHAR_BIT;
-	const unsigned int target_bitcount = bitcount%CHAR_BIT;
 	assert(C_bit<std_int_long_long>()>=bitcount && 1<=bitcount);
+#endif
 
 	switch(C_signed_int_representation())
 	{
@@ -115,10 +82,8 @@
 	}
 	return false;
 }
-#endif
 
-#ifdef ZCC_LEGACY_FIXED_INT
-void CPUInfo::signed_additive_inverse(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type) const
+void CPUInfo::signed_additive_inverse(umaxint& src_int,std_int_enum machine_type) const
 {
 	assert(machine_type);
 	const int signed_int_rep = C_signed_int_representation();
@@ -127,60 +92,39 @@
 		src_int.toggle(C_bit(machine_type)-1);
 		return;
 		}
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp(unsigned_max(machine_type));
+	umaxint tmp(unsigned_max(machine_type));
 	tmp -= src_int;
 	if (twos_complement==signed_int_rep)
 		{
 		tmp += 1;
 		tmp.mask_to(C_bit(machine_type));
 		}
+#ifdef ZCC_LEGACY_FIXED_INT
 	src_int = tmp;
-}
 #else
-void CPUInfo::signed_additive_inverse(unsigned_var_int& src_int,std_int_enum machine_type) const
-{
-	assert(machine_type);
-	const int signed_int_rep = C_signed_int_representation();
-	if (sign_and_magnitude==signed_int_rep)
-		{
-		src_int.toggle(C_bit(machine_type)-1);
-		return;
-		}
-	unsigned_var_int tmp(unsigned_max(machine_type));
-	tmp -= src_int;
-	if (twos_complement==signed_int_rep)
-		{
-		tmp += 1;
-		tmp.mask_to(C_bit(machine_type));
-		}
 	tmp.MoveInto(src_int);
-}
 #endif
+}
 
-#ifdef ZCC_LEGACY_FIXED_INT
-void CPUInfo::unsigned_additive_inverse(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type) const
+void CPUInfo::unsigned_additive_inverse(umaxint& src_int,std_int_enum machine_type) const
 {
 	assert(machine_type);
 	assert(src_int<=unsigned_max(machine_type));
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp(0);
+#ifdef ZCC_LEGACY_FIXED_INT
+	umaxint tmp(0);
+#else
+	umaxint tmp(0,src_int.size());
+#endif
 	tmp -= src_int;
 	tmp.mask_to(C_bit(machine_type));
+#ifdef ZCC_LEGACY_FIXED_INT
 	src_int = tmp;
-}
 #else
-void CPUInfo::unsigned_additive_inverse(unsigned_var_int& src_int,std_int_enum machine_type) const
-{
-	assert(machine_type);
-	assert(src_int<=unsigned_max(machine_type));
-	unsigned_var_int tmp(0,src_int.size());
-	tmp -= src_int;
-	tmp.mask_to(C_bit(machine_type));
 	tmp.MoveInto(src_int);
-}
 #endif
+}
 
-#ifdef ZCC_LEGACY_FIXED_INT
-bool CPUInfo::C_promote_integer(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& x,const promotion_info& src_type, const promotion_info& dest_type) const
+bool CPUInfo::C_promote_integer(umaxint& x,const promotion_info& src_type, const promotion_info& dest_type) const
 {
 	if (src_type.is_signed && x.test(src_type.bitcount-1))
 		{
@@ -192,20 +136,6 @@
 		};
 	return dest_type.is_signed && x.test(dest_type.bitcount-1);
 }
-#else
-bool CPUInfo::C_promote_integer(unsigned_var_int& x,const promotion_info& src_type, const promotion_info& dest_type) const
-{
-	if (src_type.is_signed && x.test(src_type.bitcount-1))
-		{
-		if (!dest_type.is_signed)
-			// unsigned integer result: C99 6.3.1.3p2 dictates modulo conversion to unsigned
-			C_cast_signed_to_unsigned(x,src_type.machine_type);
-		else if (dest_type.bitcount>src_type.bitcount)
-			sign_extend(x,src_type.machine_type,dest_type.machine_type);
-		};
-	return dest_type.is_signed && x.test(dest_type.bitcount-1);
-}
-#endif
 
 }	// end namespace virtual_machine
 

Modified: trunk/CPUInfo.hpp
===================================================================
--- trunk/CPUInfo.hpp	2010-02-17 15:45:35 UTC (rev 334)
+++ trunk/CPUInfo.hpp	2010-03-03 08:04:22 UTC (rev 335)
@@ -51,6 +51,12 @@
 #define VM_MAX_BIT_PLATFORM target_machine->C_bit<virtual_machine::std_int_long_long>()
 #endif
 
+#ifdef ZCC_LEGACY_FIXED_INT
+	typedef unsigned_fixed_int<VM_MAX_BIT_PLATFORM> umaxint;
+#else
+	typedef unsigned_var_int umaxint;
+#endif	
+
 // names of macro parameters match names of constructor variables
 // target wchar_t is assumed to be an unsigned integral type
 // we first try to choose the smallest type that can represent a 32-bit UNICODE point
@@ -76,13 +82,8 @@
 	CPUInfo(const CPUInfo& src);		// disable copy-construction
 	void operator=(const CPUInfo& src);
 
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> unsigned_maxima[std_int_enum_max];
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> signed_maxima[std_int_enum_max];
-#else
-	unsigned_var_int unsigned_maxima[std_int_enum_max];
-	unsigned_var_int signed_maxima[std_int_enum_max];
-#endif
+	umaxint unsigned_maxima[std_int_enum_max];
+	umaxint signed_maxima[std_int_enum_max];
 
 	const unsigned short char_bit;
 	const unsigned short sizeof_short;
@@ -126,26 +127,15 @@
 																	(std_int_long==x) ? C_char_bit()*C_sizeof_long() : C_char_bit()*C_sizeof_long_long() ;}
 
 	signed_int_rep C_signed_int_representation() const {return (signed_int_rep)(signed_int_representation & 3U);};
-#ifdef ZCC_LEGACY_FIXED_INT
-	bool trap_int(const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type) const;
-	void signed_additive_inverse(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type) const;
-	void unsigned_additive_inverse(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type) const;
-	void sign_extend(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type_from,std_int_enum machine_type_to) const
-#else
-	bool trap_int(const unsigned_var_int& src_int,std_int_enum machine_type) const;
-	void signed_additive_inverse(unsigned_var_int& src_int,std_int_enum machine_type) const;
-	void unsigned_additive_inverse(unsigned_var_int& src_int,std_int_enum machine_type) const;
-	void sign_extend(unsigned_var_int& src_int,std_int_enum machine_type_from,std_int_enum machine_type_to) const
-#endif
+	bool trap_int(const umaxint& src_int,std_int_enum machine_type) const;
+	void signed_additive_inverse(umaxint& src_int,std_int_enum machine_type) const;
+	void unsigned_additive_inverse(umaxint& src_int,std_int_enum machine_type) const;
+	void sign_extend(umaxint& src_int,std_int_enum machine_type_from,std_int_enum machine_type_to) const
 		{
 		signed_additive_inverse(src_int,machine_type_from);
 		signed_additive_inverse(src_int,machine_type_to);
 		};
-#ifdef ZCC_LEGACY_FIXED_INT
-	void C_cast_signed_to_unsigned(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,std_int_enum machine_type) const
-#else
-	void C_cast_signed_to_unsigned(unsigned_var_int& src_int,std_int_enum machine_type) const
-#endif
+	void C_cast_signed_to_unsigned(umaxint& src_int,std_int_enum machine_type) const
 		{	// C99 6.3.1.3p2 dictates modulo conversion to unsigned
 		if (twos_complement!=C_signed_int_representation() && src_int.test(C_bit(machine_type)-1))
 			{
@@ -160,24 +150,13 @@
 	// use different functions for ptrdiff_t and size_t to future-proof (e.g., DOS has ptrdiff 2 bytes but can go larger than that in object size in some memory models)
 	std_int_enum ptrdiff_t_type() const {return (std_int_enum)((signed_int_representation>>7) & 7U);};
 	std_int_enum size_t_type() const {return (std_int_enum)((signed_int_representation>>7) & 7U);};
-#ifdef ZCC_LEGACY_FIXED_INT
-	const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& unsigned_max(std_int_enum x) const {return unsigned_maxima[x-1];};
-	template<std_int_enum x> const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& unsigned_max() const {return unsigned_maxima[x-1];}
-	const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& signed_max(std_int_enum x) const {return signed_maxima[x-1];};
-	template<std_int_enum x> const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& signed_max() const {return signed_maxima[x-1];}
-#else
-	const unsigned_var_int& unsigned_max(std_int_enum x) const {return unsigned_maxima[x-1];};
-	template<std_int_enum x> const unsigned_var_int& unsigned_max() const {return unsigned_maxima[x-1];}
-	const unsigned_var_int& signed_max(std_int_enum x) const {return signed_maxima[x-1];};
-	template<std_int_enum x> const unsigned_var_int& signed_max() const {return signed_maxima[x-1];}
-#endif
+	const umaxint& unsigned_max(std_int_enum x) const {return unsigned_maxima[x-1];};
+	template<std_int_enum x> const umaxint& unsigned_max() const {return unsigned_maxima[x-1];}
+	const umaxint& signed_max(std_int_enum x) const {return signed_maxima[x-1];};
+	template<std_int_enum x> const umaxint& signed_max() const {return signed_maxima[x-1];}
 
 	// return value is weird...it's true iff the promoted x is a negative numeral
-#ifdef ZCC_LEGACY_FIXED_INT
-	bool C_promote_integer(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& x,const promotion_info& src_type, const promotion_info& dest_type) const;
-#else
-	bool C_promote_integer(unsigned_var_int& x,const promotion_info& src_type, const promotion_info& dest_type) const;
-#endif
+	bool C_promote_integer(umaxint& x,const promotion_info& src_type, const promotion_info& dest_type) const;
 };
 
 #undef SELECT_TARGET_WCHAR_T

Modified: trunk/CPreproc_autogen.cpp
===================================================================
--- trunk/CPreproc_autogen.cpp	2010-02-17 15:45:35 UTC (rev 334)
+++ trunk/CPreproc_autogen.cpp	2010-03-03 08:04:22 UTC (rev 335)
@@ -9,6 +9,8 @@
 #include "Zaimoni.STL/LexParse/Token.hpp"
 #include "Zaimoni.STL/pure.C/format_util.h"
 
+using virtual_machine::umaxint;
+
 #ifndef ZCC_LEGACY_FIXED_INT
 // XXX adjust VM_MAX_BIT_PLATFORM to work inside of CPreprocessor XXX
 #undef VM_MAX_BIT_PLATFORM
@@ -454,11 +456,7 @@
 		if (1==target_machine.C_sizeof_int()) tmp[LIMITS_CHAR_MAX_LINE]->append('U');
 		}
 	// signed character limits
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> s_max(target_machine.signed_max<virtual_machine::std_int_char>());
-#else
-	unsigned_var_int s_max(target_machine.signed_max<virtual_machine::std_int_char>());
-#endif
+	umaxint s_max(target_machine.signed_max<virtual_machine::std_int_char>());
 	tmp[LIMITS_SCHAR_MAX_LINE]->append(z_ucharint_toa(s_max,buf+1,10)-1);
 	if (target_machine.char_is_signed_char()) tmp[LIMITS_CHAR_MAX_LINE]->append(buf);
 	const bool twos_complement_non_trapping = virtual_machine::twos_complement==target_machine.C_signed_int_representation() && !bool_options[boolopt::int_traps];
@@ -756,11 +754,7 @@
 	zaimoni::autovalarray_ptr_throws<char> signed_min_metabuf(virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+4));
 #endif
 	char* signed_min_buf[virtual_machine::std_int_enum_max] = {signed_min_metabuf, signed_min_metabuf+(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+2*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+3*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+4*(2+(VM_MAX_BIT_PLATFORM/3)+2)};
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp_VM;
-#else
-	unsigned_var_int tmp_VM;
-#endif
+	umaxint tmp_VM;
 	if (target_is_twos_complement && !bool_options[boolopt::int_traps])
 		{
 		*signed_min_buf[0] = '-';

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-02-17 15:45:35 UTC (rev 334)
+++ trunk/CSupport.cpp	2010-03-03 08:04:22 UTC (rev 335)
@@ -29,6 +29,7 @@
 #include "CheckReturn.hpp"
 
 using namespace zaimoni;
+using virtual_machine::umaxint;
 
 #define C_OCTAL_DIGITS "01234567"
 #define C_HEXADECIMAL_DIGITS "0123456789ABCDEFabcdef"
@@ -2450,11 +2451,7 @@
 	return (ub<hex_len) ? ub : hex_len;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static unsigned_fixed_int<VM_MAX_BIT_PLATFORM> eval_hex_escape(const char* src, size_t src_len)
-#else
-static unsigned_var_int eval_hex_escape(const char* src, size_t src_len)
-#endif
+static umaxint eval_hex_escape(const char* src, size_t src_len)
 {
 	assert(NULL!=src);
 	assert(0<src_len);
@@ -2464,11 +2461,7 @@
 	unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 #endif
 #ifndef NDEBUG
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> uchar_max(target_machine->unsigned_max<virtual_machine::std_int_long_long>());
-#else
-	unsigned_var_int uchar_max(target_machine->unsigned_max<virtual_machine::std_int_long_long>());
-#endif
+	umaxint uchar_max(target_machine->unsigned_max<virtual_machine::std_int_long_long>());
 	uchar_max >>= 4;
 #endif
 	do	{
@@ -2638,11 +2631,7 @@
 		}
 	if ('"' != *(x++)) return false;
 	if (0 == --x_len) return true;	// empty string is legal
-#ifdef ZCC_LEGACY_FIXED_INT
-	const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& uchar_max = target_machine->unsigned_max((wide_string) ? target_machine->UNICODE_wchar_t() : virtual_machine::std_int_char);
-#else
-	const unsigned_var_int& uchar_max = target_machine->unsigned_max((wide_string) ? target_machine->UNICODE_wchar_t() : virtual_machine::std_int_char);
-#endif
+	const umaxint& uchar_max = target_machine->unsigned_max((wide_string) ? target_machine->UNICODE_wchar_t() : virtual_machine::std_int_char);
 
 	size_t i = 0;
 	do	{
@@ -2669,11 +2658,7 @@
 		}
 	if ('\'' != *(x++)) return false;
 	if (0 == --x_len) return false;	// empty character literal is illegal
-#ifdef ZCC_LEGACY_FIXED_INT
-	const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& uchar_max = target_machine->unsigned_max((wide_string) ? target_machine->UNICODE_wchar_t() : virtual_machine::std_int_char);
-#else
-	const unsigned_var_int& uchar_max = target_machine->unsigned_max((wide_string) ? target_machine->UNICODE_wchar_t() : virtual_machine::std_int_char);
-#endif
+	const umaxint& uchar_max = target_machine->unsigned_max((wide_string) ? target_machine->UNICODE_wchar_t() : virtual_machine::std_int_char);
 
 	size_t i = 0;
 	do	{
@@ -4123,11 +4108,7 @@
 	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-bool convert_to(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& dest,const C_PPIntCore& src)
-#else
-bool convert_to(unsigned_var_int& dest,const C_PPIntCore& src)
-#endif
+bool convert_to(umaxint& dest,const C_PPIntCore& src)
 {
 	assert(8==src.radix || 10==src.radix || 16==src.radix);
 	assert(NULL!=src.ptr && 0<src.digit_span);
@@ -4169,17 +4150,9 @@
 }
 
 // forward-declare to handle recursion
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool C99_intlike_literal_to_VM(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& dest, const parse_tree& src);
-#else
-static bool C99_intlike_literal_to_VM(unsigned_var_int& dest, const parse_tree& src);
-#endif
+static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src);
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool _C99_intlike_literal_to_VM(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& dest, const parse_tree& src)
-#else
-static bool _C99_intlike_literal_to_VM(unsigned_var_int& dest, const parse_tree& src)
-#endif
+static bool _C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src)
 {
 	assert(C_TYPE::INTEGERLIKE!=src.type_code.base_type_index);
 
@@ -4194,13 +4167,8 @@
 			assert(old.bitcount>=lhs.bitcount);
 			if (lhs.is_signed)
 				{
-#ifdef ZCC_LEGACY_FIXED_INT
-				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_int;
-				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-#else
-				unsigned_var_int lhs_int;
-				unsigned_var_int rhs_int;
-#endif
+				umaxint lhs_int;
+				umaxint rhs_int;
 				if (	C99_intlike_literal_to_VM(lhs_int,*src.data<1>())
 					&&	C99_intlike_literal_to_VM(rhs_int,*src.data<2>()))
 					{
@@ -4241,11 +4209,7 @@
 	return true;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool _CPP_intlike_literal_to_VM(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& dest, const parse_tree& src)
-#else
-static bool _CPP_intlike_literal_to_VM(unsigned_var_int& dest, const parse_tree& src)
-#endif
+static bool _CPP_intlike_literal_to_VM(umaxint& dest, const parse_tree& src)
 {
 	//! \todo: similar code for handling LLONG_MIN as above.  Need that only for zcc; can't test in preprocessor as the true reserved word won't make it this far.
 	if (!src.is_atomic()) return false;
@@ -4290,11 +4254,7 @@
 	return ret;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool C99_intlike_literal_to_VM(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& dest, const parse_tree& src)
-#else
-static bool C99_intlike_literal_to_VM(unsigned_var_int& dest, const parse_tree& src)
-#endif
+static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src)
 {
 	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src);
 
@@ -4313,11 +4273,7 @@
 	return true;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool CPP_intlike_literal_to_VM(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& dest, const parse_tree& src)
-#else
-static bool CPP_intlike_literal_to_VM(unsigned_var_int& dest, const parse_tree& src)
-#endif
+static bool CPP_intlike_literal_to_VM(umaxint& dest, const parse_tree& src)
 {
 	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src);
 
@@ -4345,18 +4301,10 @@
  * \return -1 : can't decide quickly whether this is a null 
  *         pointer constant
  */
-#ifdef ZCC_LEGACY_FIXED_INT
-int is_null_pointer_constant(const parse_tree& src, func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-int is_null_pointer_constant(const parse_tree& src, func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+int is_null_pointer_constant(const parse_tree& src, func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	if (!converts_to_integerlike(src.type_code)) return 0;
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp;
-#else
-	unsigned_var_int tmp;
-#endif
+	umaxint tmp;
 	if (intlike_literal_to_VM(tmp,src)) return tmp==0;
 	return -1;
 }
@@ -4385,11 +4333,7 @@
 			src.type_code.set_type(C_TYPE::INTEGERLIKE);
 			C_PPIntCore parse_tmp;
 			ZAIMONI_PASSTHROUGH_ASSERT(C_PPIntCore::is(src.index_tokens[0].token.first,src.index_tokens[0].token.second,parse_tmp));
-#ifdef ZCC_LEGACY_FIXED_INT
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp;
-#else
-			unsigned_var_int tmp;
-#endif
+			umaxint tmp;
 			const unsigned char type_hint = parse_tmp.hinted_type;
 			const bool no_signed = 1==type_hint%2;
 			const bool no_unsigned = !no_signed && 10==parse_tmp.radix;
@@ -5225,11 +5169,7 @@
 // can't do much syntax-checking or immediate-evaluation here because of binary +/-
 // unary +/- syntax checking out out of place as it's needed by all of the unary operators
 // return code is true for success, false for memory failure
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool VM_to_token(const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
-#else
-static bool VM_to_token(const unsigned_var_int& src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
-#endif
+static bool VM_to_token(const umaxint& src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
 {
 	const char* const suffix = literal_suffix(base_type_index);
 #ifdef ZCC_LEGACY_FIXED_INT
@@ -5263,11 +5203,7 @@
 }
 
 // return code is true for success, false for memory failure
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool VM_to_literal(parse_tree& dest, const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,const parse_tree& src,const type_system& types)
-#else
-static bool VM_to_literal(parse_tree& dest, const unsigned_var_int& src_int,const parse_tree& src,const type_system& types)
-#endif
+static bool VM_to_literal(parse_tree& dest, const umaxint& src_int,const parse_tree& src,const type_system& types)
 {
 	POD_pair<char*,lex_flags> new_token;
 	if (!VM_to_token(src_int,src.type_code.base_type_index,new_token)) return false;
@@ -5326,11 +5262,7 @@
 	return false;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool eval_unary_minus(parse_tree& src, const type_system& types,func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-static bool eval_unary_minus(parse_tree& src, const type_system& types,func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+static bool eval_unary_minus(parse_tree& src, const type_system& types,func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	assert(is_C99_unary_operator_expression<'-'>(src));
 	bool is_true = false;
@@ -5346,11 +5278,7 @@
 		{	// unsigned...we're fine
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
 		const type_spec old_type = src.type_code;
-#ifdef ZCC_LEGACY_FIXED_INT
-		unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
-#else
-		unsigned_var_int res_int;
-#endif
+		umaxint res_int;
 		intlike_literal_to_VM(res_int,*src.data<2>());
 		target_machine->unsigned_additive_inverse(res_int,machine_type);
 
@@ -5653,11 +5581,7 @@
 	return false;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool int_has_trapped(parse_tree& src,const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,bool hard_error)
-#else
-static bool int_has_trapped(parse_tree& src,const unsigned_var_int& src_int,bool hard_error)
-#endif
+static bool int_has_trapped(parse_tree& src,const umaxint& src_int,bool hard_error)
 {
 	assert(C_TYPE::INT<=src.type_code.base_type_index && C_TYPE::INTEGERLIKE>src.type_code.base_type_index);
 	// check for trap representation for signed types
@@ -5767,11 +5691,7 @@
 // eventually recover enough memory for this to complete.
 static bool construct_twos_complement_int_min(parse_tree& dest, const type_system& types, const virtual_machine::std_int_enum machine_type, const parse_tree& src_loc)
 {
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp_int(target_machine->signed_max(machine_type));
-#else
-	unsigned_var_int tmp_int(target_machine->signed_max(machine_type));	// of course, throwing constructor gets in the way
-#endif
+	umaxint tmp_int(target_machine->signed_max(machine_type));
 	parse_tree* const tmp = _new_buffer<parse_tree>(1);	// XXX we recycle this variable later
 	if (NULL==tmp) return false;
 	if (!VM_to_literal(*tmp,tmp_int,src_loc,types)) return false;
@@ -5823,19 +5743,11 @@
 	return true;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool eval_bitwise_compl(parse_tree& src, const type_system& types,bool hard_error,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-static bool eval_bitwise_compl(parse_tree& src, const type_system& types,bool hard_error,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+static bool eval_bitwise_compl(parse_tree& src, const type_system& types,bool hard_error,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	assert(is_bitwise_complement_expression(src));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
-#else
-	unsigned_var_int res_int;
-#endif
+	umaxint res_int;
 	if (intlike_literal_to_VM(res_int,*src.data<2>())) 
 		{
 		const type_spec old_type = src.type_code;
@@ -6260,11 +6172,7 @@
 	return false;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool eval_mult_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-static bool eval_mult_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+static bool eval_mult_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'*'>(src));
 
@@ -6293,13 +6201,8 @@
 		return true;
 		};
 
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-#else
-	unsigned_var_int res_int;
-	unsigned_var_int rhs_int;
-#endif
+	umaxint res_int;
+	umaxint rhs_int;
 	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
 	if (lhs_converted && 1==res_int)
@@ -6327,15 +6230,9 @@
 		const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
 		if (old.is_signed)
 			{	// signed integer result: overflow is undefined
-#ifdef ZCC_LEGACY_FIXED_INT
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
-#else
-			unsigned_var_int lhs_test(res_int);
-			unsigned_var_int rhs_test(rhs_int);
-			unsigned_var_int ub(target_machine->signed_max(old.machine_type));
-#endif
+			umaxint lhs_test(res_int);
+			umaxint rhs_test(rhs_int);
+			umaxint ub(target_machine->signed_max(old.machine_type));
 			const bool tweak_ub = rhs_negative!=lhs_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation() && !bool_options[boolopt::int_traps];
 			if (rhs_negative) target_machine->signed_additive_inverse(rhs_test,old.machine_type);
 			if (lhs_negative) target_machine->signed_additive_inverse(lhs_test,old.machine_type);
@@ -6388,11 +6285,7 @@
 	return false;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-static bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+static bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'/'>(src));
 
@@ -6430,13 +6323,8 @@
 		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
 		};
 
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-#else
-	unsigned_var_int res_int;
-	unsigned_var_int rhs_int;
-#endif
+	umaxint res_int;
+	umaxint rhs_int;
 	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
 	if (rhs_converted && rhs_int==1)
@@ -6461,15 +6349,9 @@
 		const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
 		if (old.is_signed)
 			{	// signed integer result
-#ifdef ZCC_LEGACY_FIXED_INT
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
-#else
-			unsigned_var_int lhs_test(res_int);
-			unsigned_var_int rhs_test(rhs_int);
-			unsigned_var_int ub(target_machine->signed_max(old.machine_type));
-#endif
+			umaxint lhs_test(res_int);
+			umaxint rhs_test(rhs_int);
+			umaxint ub(target_machine->signed_max(old.machine_type));
 			if (rhs_negative) target_machine->signed_additive_inverse(rhs_test,old.machine_type);
 			if (lhs_negative) target_machine->signed_additive_inverse(lhs_test,old.machine_type);
 			if (rhs_negative!=lhs_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation()) ub += 1;
@@ -6497,11 +6379,7 @@
 			bool round_away = false;
 			if (rhs_negative!=lhs_negative && bool_options[boolopt::int_neg_div_rounds_away_from_zero])
 				{
-#ifdef ZCC_LEGACY_FIXED_INT
-				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_mod_test(lhs_test);
-#else
-				unsigned_var_int lhs_mod_test(lhs_test);
-#endif
+				umaxint lhs_mod_test(lhs_test);
 				lhs_mod_test %= rhs_test;
 				round_away = 0!=lhs_mod_test;
 				}
@@ -6544,11 +6422,7 @@
 	return false;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool eval_mod_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-static bool eval_mod_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+static bool eval_mod_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'%'>(src));
 
@@ -6586,13 +6460,8 @@
 		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
 		};
 
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-#else
-	unsigned_var_int res_int;
-	unsigned_var_int rhs_int;
-#endif
+	umaxint res_int;
+	umaxint rhs_int;
 	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
 	if (rhs_converted && rhs_int==1)
@@ -6619,15 +6488,9 @@
 		const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
 		if (old.is_signed)
 			{	// signed integer result
-#ifdef ZCC_LEGACY_FIXED_INT
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
-#else
-			unsigned_var_int lhs_test(res_int);
-			unsigned_var_int rhs_test(rhs_int);
-			unsigned_var_int ub(target_machine->signed_max(old.machine_type));
-#endif
+			umaxint lhs_test(res_int);
+			umaxint rhs_test(rhs_int);
+			umaxint ub(target_machine->signed_max(old.machine_type));
 			if (rhs_negative) target_machine->signed_additive_inverse(rhs_test,old.machine_type);
 			if (lhs_negative) target_machine->signed_additive_inverse(lhs_test,old.machine_type);
 			if (rhs_negative!=lhs_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation()) ub += 1;
@@ -6920,11 +6783,7 @@
 
 // this one hides a slight inefficiency: negative literals take 2 dynamic memory allocations, positive literals take one
 // return code is true for success, false for memory failure
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool VM_to_signed_literal(parse_tree& x,const bool is_negative, const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& src_int,const parse_tree& src,const type_system& types)
-#else
-static bool VM_to_signed_literal(parse_tree& x,const bool is_negative, const unsigned_var_int& src_int,const parse_tree& src,const type_system& types)
-#endif
+static bool VM_to_signed_literal(parse_tree& x,const bool is_negative, const umaxint& src_int,const parse_tree& src,const type_system& types)
 {
 	if (is_negative)
 		{
@@ -6938,11 +6797,7 @@
 	return true;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool eval_add_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-static bool eval_add_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+static bool eval_add_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'+'>(src));
 
@@ -6974,13 +6829,8 @@
 				src.type_code = old_type;
 				return true;
 				};
-#ifdef ZCC_LEGACY_FIXED_INT
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-#else
-			unsigned_var_int res_int;
-			unsigned_var_int rhs_int;
-#endif
+			umaxint res_int;
+			umaxint rhs_int;
 			const promote_aux old(old_type.base_type_index);
 			const promote_aux lhs(src.data<1>()->type_code.base_type_index);
 			assert(old.bitcount>=lhs.bitcount);
@@ -6994,15 +6844,9 @@
 				{
 				if (old.is_signed)
 					{	// signed integer result
-#ifdef ZCC_LEGACY_FIXED_INT
-					unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
-					unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
-					unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
-#else
-					unsigned_var_int lhs_test(res_int);
-					unsigned_var_int rhs_test(rhs_int);
-					unsigned_var_int ub(target_machine->signed_max(old.machine_type));
-#endif
+					umaxint lhs_test(res_int);
+					umaxint rhs_test(rhs_int);
+					umaxint ub(target_machine->signed_max(old.machine_type));
 					bool result_is_negative = false;
 					if (rhs_negative) target_machine->signed_additive_inverse(rhs_test,old.machine_type);
 					if (lhs_negative) target_machine->signed_additive_inverse(lhs_test,old.machine_type);
@@ -7099,11 +6943,7 @@
 	return false;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'-'>(src));
 
@@ -7139,13 +6979,8 @@
 				src.type_code = old_type;
 				return true;
 				}
-#ifdef ZCC_LEGACY_FIXED_INT
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-#else
-			unsigned_var_int res_int;
-			unsigned_var_int rhs_int;
-#endif
+			umaxint res_int;
+			umaxint rhs_int;
 			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
 			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
 			if (lhs_converted && rhs_converted)
@@ -7161,15 +6996,9 @@
 				const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
 				if (old.is_signed)
 					{	// signed integer result
-#ifdef ZCC_LEGACY_FIXED_INT
-					unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
-					unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
-					unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
-#else
-					unsigned_var_int lhs_test(res_int);
-					unsigned_var_int rhs_test(rhs_int);
-					unsigned_var_int ub(target_machine->signed_max(old.machine_type));
-#endif
+					umaxint lhs_test(res_int);
+					umaxint rhs_test(rhs_int);
+					umaxint ub(target_machine->signed_max(old.machine_type));
 					bool result_is_negative = false;
 					if (rhs_negative) target_machine->signed_additive_inverse(rhs_test,old.machine_type);
 					if (lhs_negative) target_machine->signed_additive_inverse(lhs_test,old.machine_type);
@@ -7268,11 +7097,7 @@
 
 // +: either both are arithmetic, or one is raw pointer and one is integer
 // -: either both are arithmetic, or both are compatible raw pointer, or left is raw pointer and right is integer
-#ifdef ZCC_LEGACY_FIXED_INT
-static void C_CPP_add_expression_easy_syntax_check(parse_tree& src,const type_system& types,func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-static void C_CPP_add_expression_easy_syntax_check(parse_tree& src,const type_system& types,func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+static void C_CPP_add_expression_easy_syntax_check(parse_tree& src,const type_system& types,func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	assert((C99_ADD_SUBTYPE_PLUS==src.subtype && is_C99_add_operator_expression<'+'>(src)) || (C99_ADD_SUBTYPE_MINUS==src.subtype && is_C99_add_operator_expression<'-'>(src)));
 	BOOST_STATIC_ASSERT(1==C99_ADD_SUBTYPE_MINUS-C99_ADD_SUBTYPE_PLUS);
@@ -7517,11 +7342,7 @@
 	return false;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool eval_shift(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-static bool eval_shift(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+static bool eval_shift(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -7546,11 +7367,7 @@
 			}
 		};
 
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-#else
-	unsigned_var_int rhs_int;
-#endif
+	umaxint rhs_int;
 	if (intlike_literal_to_VM(rhs_int,*src.data<2>()))
 		{
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(old_type.base_type_index);
@@ -7571,11 +7388,7 @@
 			};
 		if (undefined_behavior) return false;
 
-#ifdef ZCC_LEGACY_FIXED_INT
-		unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
-#else
-		unsigned_var_int res_int;
-#endif
+		umaxint res_int;
 		if (intlike_literal_to_VM(res_int,*src.data<1>()))
 			{
 			// note that incoming negative signed integers are not handled by this code path
@@ -7700,23 +7513,14 @@
 	return false;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool eval_relation_expression(parse_tree& src, const type_system& types,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-static bool eval_relation_expression(parse_tree& src, const type_system& types,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+static bool eval_relation_expression(parse_tree& src, const type_system& types,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_GT-C99_RELATION_SUBTYPE_LT);
 	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_LTE-C99_RELATION_SUBTYPE_GT);
 	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_GTE-C99_RELATION_SUBTYPE_LTE);
 	assert(C99_RELATION_SUBTYPE_LT<=src.subtype && C99_RELATION_SUBTYPE_GTE>=src.subtype);
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_int;
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-#else
-	unsigned_var_int lhs_int;
-	unsigned_var_int rhs_int;
-#endif
+	umaxint lhs_int;
+	umaxint rhs_int;
 
 	const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>());
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
@@ -7898,21 +7702,12 @@
 	return false;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool eval_equality_expression(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-static bool eval_equality_expression(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+static bool eval_equality_expression(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {	
 	BOOST_STATIC_ASSERT(1==C99_EQUALITY_SUBTYPE_NEQ-C99_EQUALITY_SUBTYPE_EQ);
 	assert(C99_EQUALITY_SUBTYPE_EQ<=src.subtype && C99_EQUALITY_SUBTYPE_NEQ>=src.subtype);
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_int;
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-#else
-	unsigned_var_int lhs_int;
-	unsigned_var_int rhs_int;
-#endif
+	umaxint lhs_int;
+	umaxint rhs_int;
 	const unsigned int integer_literal_case = 	  converts_to_integer(src.data<1>()->type_code)
 											+	2*converts_to_integer(src.data<2>()->type_code);
 	const bool is_equal_op = src.subtype==C99_EQUALITY_SUBTYPE_EQ;
@@ -8135,11 +7930,7 @@
 	return false;
 }
 
-#if ZCC_LEGACY_FIXED_INT
-static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -8168,21 +7959,12 @@
 		return true;
 		};
 
-#if ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_int;
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-#else
-	unsigned_var_int lhs_int;
-	unsigned_var_int rhs_int;
-#endif
+	umaxint lhs_int;
+	umaxint rhs_int;
 	if (intlike_literal_to_VM(lhs_int,*src.data<1>()) && intlike_literal_to_VM(rhs_int,*src.data<2>()))
 		{
 		const promote_aux old(old_type.base_type_index);
-#if ZCC_LEGACY_FIXED_INT
-		unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int(lhs_int);
-#else
-		unsigned_var_int res_int(lhs_int);
-#endif
+		umaxint res_int(lhs_int);
 		res_int &= rhs_int;
 
 		// check for trap representation for signed types
@@ -8323,11 +8105,7 @@
 	return false;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -8356,22 +8134,13 @@
 			}
 		};
 
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_int;
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-#else
-	unsigned_var_int lhs_int;
-	unsigned_var_int rhs_int;
-#endif
+	umaxint lhs_int;
+	umaxint rhs_int;
 	if (intlike_literal_to_VM(lhs_int,*src.data<1>()) && intlike_literal_to_VM(rhs_int,*src.data<2>()))
 		{
 		const type_spec old_type = src.type_code;
 		const promote_aux old(old_type.base_type_index);
-#ifdef ZCC_LEGACY_FIXED_INT
-		unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int(lhs_int);
-#else
-		unsigned_var_int res_int(lhs_int);
-#endif
+		umaxint res_int(lhs_int);
 		res_int ^= rhs_int;
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
 
@@ -8504,11 +8273,7 @@
 	return false;
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static bool eval_bitwise_OR(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-static bool eval_bitwise_OR(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+static bool eval_bitwise_OR(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -8537,22 +8302,13 @@
 			}
 		};
 
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_int;
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-#else
-	unsigned_var_int lhs_int;
-	unsigned_var_int rhs_int;
-#endif
+	umaxint lhs_int;
+	umaxint rhs_int;
 	if (intlike_literal_to_VM(lhs_int,*src.data<1>()) && intlike_literal_to_VM(rhs_int,*src.data<2>()))
 		{
 		const type_spec old_type = src.type_code;
+		umaxint res_int(lhs_int);
 
-#ifdef ZCC_LEGACY_FIXED_INT
-		unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int(lhs_int);
-#else
-		unsigned_var_int res_int(lhs_int);
-#endif
 		res_int |= rhs_int;
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
 		if 		(res_int==lhs_int)
@@ -9637,11 +9393,7 @@
 #endif
 }
 
-#ifdef ZCC_LEGACY_FIXED_INT
-static void eval_string_literal_deref(parse_tree& src,const type_system& types,const POD_pair<const char*,size_t>& str_lit,const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& tmp,bool is_negative,bool index_src_is_char)
-#else
-static void eval_string_literal_deref(parse_tree& src,const type_system& types,const POD_pair<const char*,size_t>& str_lit,const unsigned_var_int& tmp,bool is_negative,bool index_src_is_char)
-#endif
+static void eval_string_literal_deref(parse_tree& src,const type_system& types,const POD_pair<const char*,size_t>& str_lit,const umaxint& tmp,bool is_negative,bool index_src_is_char)
 {
 	const size_t strict_ub = LengthOfCStringLiteral(str_lit.first,str_lit.second);
 	// C99 6.2.6.2p3 -0 is not actually allowed to generate the bitpattern -0, so no trapping
@@ -9702,11 +9454,7 @@
 eval_array_deref(parse_tree& src,const type_system& types,
 				 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 				 func_traits<bool (*)(const parse_tree&)>::function_ref_type literal_converts_to_integer,
-#ifdef ZCC_LEGACY_FIXED_INT
-				 func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-				 func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+				 func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	if (!is_array_deref(src)) return false;
 	// crunch __[...]
@@ -9719,11 +9467,7 @@
 										(C_TESTFLAG_STRING_LITERAL==src.data<1>()->index_tokens[0].flags) ? 1 : UINT_MAX;
 		if (UINT_MAX>str_index)
 			{
-#ifdef ZCC_LEGACY_FIXED_INT
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp; 
-#else
-			unsigned_var_int tmp; 
-#endif
+			umaxint tmp; 
 			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index))) return false;
 			const size_t promoted_type = default_promote_type(src.type_code.base_type_index);
 			const virtual_machine::std_int_enum machine_type = (virtual_machine::std_int_enum)((promoted_type-C_TYPE::INT)/2+virtual_machine::std_int_int);
@@ -9748,11 +9492,7 @@
 			//! \test default/Pass_if_zero.h
 			//! \test default/Pass_if_nonzero.hpp
 			//! \test default/Pass_if_nonzero.h
-#ifdef ZCC_LEGACY_FIXED_INT
-			eval_string_literal_deref(src,types,src.data<2>()->index_tokens[0].token,unsigned_fixed_int<VM_MAX_BIT_PLATFORM>(0),false,false);
-#else
-			eval_string_literal_deref(src,types,src.data<2>()->index_tokens[0].token,unsigned_var_int(0),false,false);
-#endif
+			eval_string_literal_deref(src,types,src.data<2>()->index_tokens[0].token,umaxint(0),false,false);
 			return true;
 			}
 		}
@@ -9775,11 +9515,7 @@
 static bool eval_bitwise_compl(	parse_tree& src, const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,
-#ifdef ZCC_LEGACY_FIXED_INT
-								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-								func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+								func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	if (is_bitwise_complement_expression(src))
 		{
@@ -9803,11 +9539,7 @@
 static bool eval_unary_minus(parse_tree& src, const type_system& types,
 							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							 func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,
-#ifdef ZCC_LEGACY_FIXED_INT
-							 func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-							 func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+							 func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	if (is_C99_unary_operator_expression<'-'>(src))
 		{
@@ -9820,11 +9552,7 @@
 static bool eval_mult_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-#ifdef ZCC_LEGACY_FIXED_INT
-								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-								func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+								func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	if (is_C99_mult_operator_expression<'*'>(src))
 		{
@@ -9838,11 +9566,7 @@
 static bool eval_div_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-#ifdef ZCC_LEGACY_FIXED_INT
-								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-								func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+								func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	if (is_C99_mult_operator_expression<'/'>(src))
 		{
@@ -9856,11 +9580,7 @@
 static bool eval_mod_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-#ifdef ZCC_LEGACY_FIXED_INT
-								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-								func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+								func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	if (is_C99_mult_operator_expression<'%'>(src))
 		{
@@ -9875,11 +9595,7 @@
 static bool eval_add_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-#ifdef ZCC_LEGACY_FIXED_INT
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	if (is_C99_add_operator_expression<'+'>(src))
 		{
@@ -9893,11 +9609,7 @@
 static bool eval_sub_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-#ifdef ZCC_LEGACY_FIXED_INT
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	if (is_C99_add_operator_expression<'-'>(src))
 		{
@@ -9911,11 +9623,7 @@
 static bool eval_shift(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-#ifdef ZCC_LEGACY_FIXED_INT
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	if (is_C99_shift_expression(src))
 		{
@@ -9928,11 +9636,7 @@
 
 static bool eval_relation_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-#ifdef ZCC_LEGACY_FIXED_INT
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	if (is_C99_relation_expression(src))
 		{
@@ -9947,11 +9651,7 @@
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_equality_expression,
 							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-#ifdef ZCC_LEGACY_FIXED_INT
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	if (is_equality_expression(src))
 		{
@@ -9966,11 +9666,7 @@
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_AND_expression,
 							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-#ifdef ZCC_LEGACY_FIXED_INT
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	if (is_bitwise_AND_expression(src))
 		{
@@ -9985,11 +9681,7 @@
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_XOR_expression,
 							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-#ifdef ZCC_LEGACY_FIXED_INT
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	if (is_bitwise_XOR_expression(src))
 		{
@@ -10004,11 +9696,7 @@
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_OR_expression,
 							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-#ifdef ZCC_LEGACY_FIXED_INT
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#else
-							func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-#endif
+							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	if (is_bitwise_OR_expression(src))
 		{
@@ -10168,13 +9856,8 @@
 			};
 		if (non_representable_int_min)
 			{
-#ifdef ZCC_LEGACY_FIXED_INT
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-#else
-			unsigned_var_int res_int;
-			unsigned_var_int rhs_int;
-#endif
+			umaxint res_int;
+			umaxint rhs_int;
 			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data<1>());
 			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data<2>());
 			if (lhs_converted && rhs_converted)
@@ -10195,15 +9878,9 @@
 				target_machine->C_promote_integer(rhs_int,rhs,old);
 #endif
 				assert(lhs_negative && !rhs_negative);
-#ifdef ZCC_LEGACY_FIXED_INT
-				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
-				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
-				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
-#else
-				unsigned_var_int lhs_test(res_int);
-				unsigned_var_int rhs_test(rhs_int);
-				unsigned_var_int ub(target_machine->signed_max(old.machine_type));
-#endif
+				umaxint lhs_test(res_int);
+				umaxint rhs_test(rhs_int);
+				umaxint ub(target_machine->signed_max(old.machine_type));
 				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
 				ub += 1;
 				assert(ub>=lhs_test && ub>=rhs_test);
@@ -10247,13 +9924,8 @@
 			};
 		if (non_representable_int_min)
 			{
-#ifdef ZCC_LEGACY_FIXED_INT
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-#else
-			unsigned_var_int res_int;
-			unsigned_var_int rhs_int;
-#endif
+			umaxint res_int;
+			umaxint rhs_int;
 			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data<1>());
 			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data<2>());
 			if (lhs_converted && rhs_converted)
@@ -10274,15 +9946,9 @@
 				target_machine->C_promote_integer(rhs_int,rhs,old);
 #endif
 				assert(lhs_negative && !rhs_negative);
-#ifdef ZCC_LEGACY_FIXED_INT
-				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
-				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
-				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
-#else
-				unsigned_var_int lhs_test(res_int);
-				unsigned_var_int rhs_test(rhs_int);
-				unsigned_var_int ub(target_machine->signed_max(old.machine_type));
-#endif
+				umaxint lhs_test(res_int);
+				umaxint rhs_test(rhs_int);
+				umaxint ub(target_machine->signed_max(old.machine_type));
 				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
 				ub += 1;
 				assert(ub>=lhs_test && ub>=rhs_test);



From zaimoni at mail.berlios.de  Wed Mar  3 22:57:19 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 3 Mar 2010 22:57:19 +0100
Subject: [Zcplusplus-commits] r340 - trunk
Message-ID: <201003032157.o23LvJwp014986@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-03 22:57:11 +0100 (Wed, 03 Mar 2010)
New Revision: 340

Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc_autogen_pp.cpp
   trunk/CPreproc_pp.cpp
   trunk/CPreproc_pp.hpp
   trunk/CSupport_pp.cpp
   trunk/CSupport_pp.hpp
   trunk/POSIX.dep
Log:
switch over z_cpp to using its version of the forked files

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2010-03-03 21:32:38 UTC (rev 339)
+++ trunk/CPreproc.cpp	2010-03-03 21:57:11 UTC (rev 340)
@@ -3,8 +3,8 @@
 
 #include "CPreproc.hpp"
 
-#include <climits>
-#include <ctime>
+#include <limits.h>
+#include <time.h>
 #include <stdexcept>
 #include <unistd.h>
 

Modified: trunk/CPreproc_autogen_pp.cpp
===================================================================
--- trunk/CPreproc_autogen_pp.cpp	2010-03-03 21:32:38 UTC (rev 339)
+++ trunk/CPreproc_autogen_pp.cpp	2010-03-03 21:57:11 UTC (rev 340)
@@ -1,8 +1,8 @@
-// CPreproc_autogen.cpp
+// CPreproc_autogen_pp.cpp
 // (C)2009,2010 Kenneth Boyd, license: MIT.txt
 // class CPreprocessor support for autogenerating headers for arbitrary machine targets.
 
-#include "CPreproc.hpp"
+#include "CPreproc_pp.hpp"
 #include "CPUInfo.hpp"
 #include "errors.hpp"
 #include "Zaimoni.STL/POD.hpp"

Modified: trunk/CPreproc_pp.cpp
===================================================================
--- trunk/CPreproc_pp.cpp	2010-03-03 21:32:38 UTC (rev 339)
+++ trunk/CPreproc_pp.cpp	2010-03-03 21:57:11 UTC (rev 340)
@@ -1,15 +1,15 @@
-// CPreproc.cpp
+// CPreproc_pp.cpp
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-#include "CPreproc.hpp"
+#include "CPreproc_pp.hpp"
 
-#include <climits>
-#include <ctime>
+#include <limits.h>
+#include <time.h>
 #include <stdexcept>
 #include <unistd.h>
 
 #include "AtomicString.h"
-#include "CSupport.hpp"
+#include "CSupport_pp.hpp"
 #include "C_PPDecimalInteger.hpp"
 #include "CPUInfo.hpp"
 #include "errors.hpp"

Modified: trunk/CPreproc_pp.hpp
===================================================================
--- trunk/CPreproc_pp.hpp	2010-03-03 21:32:38 UTC (rev 339)
+++ trunk/CPreproc_pp.hpp	2010-03-03 21:57:11 UTC (rev 340)
@@ -1,4 +1,4 @@
-// CPreproc.hpp
+// CPreproc_pp.hpp
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
 #ifndef CPREPROC_HPP

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-03 21:32:38 UTC (rev 339)
+++ trunk/CSupport_pp.cpp	2010-03-03 21:57:11 UTC (rev 340)
@@ -1,8 +1,8 @@
-// CSupport.cpp
+// CSupport_pp.cpp
 // support for C/C++ parsing
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
-#include "CSupport.hpp"
+#include "CSupport_pp.hpp"
 #include "_CSupport1.hpp"
 #include "_CSupport2.hpp"
 

Modified: trunk/CSupport_pp.hpp
===================================================================
--- trunk/CSupport_pp.hpp	2010-03-03 21:32:38 UTC (rev 339)
+++ trunk/CSupport_pp.hpp	2010-03-03 21:57:11 UTC (rev 340)
@@ -1,4 +1,4 @@
-// CSupport.hpp
+// CSupport_pp.hpp
 // support for C/C++ language parsing
 // (C)2009 Kenneth Boyd, license: MIT.txt
 

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-03-03 21:32:38 UTC (rev 339)
+++ trunk/POSIX.dep	2010-03-03 21:57:11 UTC (rev 340)
@@ -1,8 +1,8 @@
 OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
-OBJECTS_Z_CPP_LINK_PRIORITY = CPreproc_autogen_pp.o CSupport_pp.o CPreproc_pp.o z_cpp.o Flat_UNI.o langroute.o lex_core.o C_PPHexInteger.o CPUInfo.o AtomicString.o ParseTree.o type_system.o errors.o unsigned_var_int.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
+OBJECTS_Z_CPP_LINK_PRIORITY = z_cpp.o CPreproc_autogen_pp.o CSupport_pp.o CPreproc_pp.o Flat_UNI.o langroute.o lex_core.o C_PPHexInteger.o CPUInfo.o AtomicString.o ParseTree.o type_system.o errors.o unsigned_var_int.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
 
 OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = CSupport.o Flat_UNI.o zcc.o langroute.o lex_core.o C_PPHexInteger.o CPreproc_autogen.o CPUInfo.o AtomicString.o ParseTree.o type_system.o errors.o unsigned_var_int.o CPreproc.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
+OBJECTS_ZCC_LINK_PRIORITY = CPreproc.o CSupport.o Flat_UNI.o zcc.o langroute.o lex_core.o C_PPHexInteger.o CPreproc_autogen.o CPUInfo.o AtomicString.o ParseTree.o type_system.o errors.o unsigned_var_int.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
 
 # dependencies
 z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc_pp.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
@@ -19,7 +19,7 @@
 type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport_pp.o: CSupport.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL!
 /Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.!
 STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -30,8 +30,8 @@
 Trigraph.o: Trigraph.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 Flat_UNI.o: Flat_UNI.hpp lex_core.h Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/comptest.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
-CPreproc_pp.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/M!
 etaToken.hpp
-CPreproc_autogen_pp.o: CPreproc.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
+CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexP!
 arse/MetaToken.hpp
+CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
 CSupport.o: CSupport.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Le!
 xparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/Meta!
 Token.hpp



From zaimoni at mail.berlios.de  Wed Mar  3 22:32:52 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 3 Mar 2010 22:32:52 +0100
Subject: [Zcplusplus-commits] r339 - trunk
Message-ID: <201003032132.o23LWqhk012358@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-03 22:32:38 +0100 (Wed, 03 Mar 2010)
New Revision: 339

Added:
   trunk/CPreproc_autogen_pp.cpp
   trunk/CPreproc_pp.cpp
   trunk/CPreproc_pp.hpp
   trunk/CSupport_pp.cpp
   trunk/CSupport_pp.hpp
Modified:
   trunk/MakeMake.cfg
   trunk/POSIX.dep
   trunk/z_cpp.cpp
Log:
Fork CSupport/CPreproc/CPreproc_autogen.?pp files into z_cpp and zcc variants

Copied: trunk/CPreproc_autogen_pp.cpp (from rev 335, trunk/CPreproc_autogen.cpp)

Copied: trunk/CPreproc_pp.cpp (from rev 313, trunk/CPreproc.cpp)

Copied: trunk/CPreproc_pp.hpp (from rev 338, trunk/CPreproc.hpp)

Copied: trunk/CSupport_pp.cpp (from rev 337, trunk/CSupport.cpp)

Copied: trunk/CSupport_pp.hpp (from rev 338, trunk/CSupport.hpp)

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2010-03-03 21:17:45 UTC (rev 338)
+++ trunk/MakeMake.cfg	2010-03-03 21:32:38 UTC (rev 339)
@@ -1,5 +1,5 @@
 ########
-ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
+ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport_pp','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc_pp','CPreproc_autogen_pp'),
 				'zcc':('zcc','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
 MainPrograms = ['z_cpp','zcc']
 

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-03-03 21:17:45 UTC (rev 338)
+++ trunk/POSIX.dep	2010-03-03 21:32:38 UTC (rev 339)
@@ -1,11 +1,11 @@
-OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
-OBJECTS_Z_CPP_LINK_PRIORITY = z_cpp.o CSupport.o langroute.o lex_core.o C_PPHexInteger.o Flat_UNI.o CPreproc_autogen.o CPUInfo.o AtomicString.o ParseTree.o type_system.o errors.o unsigned_var_int.o CPreproc.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
+OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
+OBJECTS_Z_CPP_LINK_PRIORITY = CPreproc_autogen_pp.o CSupport_pp.o CPreproc_pp.o z_cpp.o Flat_UNI.o langroute.o lex_core.o C_PPHexInteger.o CPUInfo.o AtomicString.o ParseTree.o type_system.o errors.o unsigned_var_int.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
 
 OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = zcc.o CSupport.o langroute.o lex_core.o C_PPHexInteger.o Flat_UNI.o CPreproc_autogen.o CPUInfo.o AtomicString.o ParseTree.o type_system.o errors.o unsigned_var_int.o CPreproc.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
+OBJECTS_ZCC_LINK_PRIORITY = CSupport.o Flat_UNI.o zcc.o langroute.o lex_core.o C_PPHexInteger.o CPreproc_autogen.o CPUInfo.o AtomicString.o ParseTree.o type_system.o errors.o unsigned_var_int.o CPreproc.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
 
 # dependencies
-z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
+z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc_pp.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
 errors.o: errors.hpp langroute.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 langroute.o: langroute.hpp _CSupport1.hpp Zaimoni.STL/Logging.h Zaimoni.STL/POD.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp
 AtomicString.o: AtomicString.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -19,7 +19,7 @@
 type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport.o: CSupport.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Le!
 xparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport_pp.o: CSupport.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL!
 /Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -30,7 +30,10 @@
 Trigraph.o: Trigraph.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 Flat_UNI.o: Flat_UNI.hpp lex_core.h Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/comptest.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
+CPreproc_pp.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/M!
 etaToken.hpp
+CPreproc_autogen_pp.o: CPreproc.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
+zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
+CSupport.o: CSupport.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Le!
 xparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/Meta!
 Token.hpp
 CPreproc_autogen.o: CPreproc.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
-zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
 ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp

Modified: trunk/z_cpp.cpp
===================================================================
--- trunk/z_cpp.cpp	2010-03-03 21:17:45 UTC (rev 338)
+++ trunk/z_cpp.cpp	2010-03-03 21:32:38 UTC (rev 339)
@@ -5,7 +5,7 @@
 #include "Zaimoni.STL/LexParse/Token.hpp"
 #include "_CSupport2.hpp"
 
-#include "CPreproc.hpp"
+#include "CPreproc_pp.hpp"
 #include "load_src.hpp"
 #include "AtomicString.h"
 #include "filesystem.h"



From zaimoni at mail.berlios.de  Wed Mar  3 22:17:49 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 3 Mar 2010 22:17:49 +0100
Subject: [Zcplusplus-commits] r338 - trunk
Message-ID: <201003032117.o23LHnEM011665@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-03 22:17:45 +0100 (Wed, 03 Mar 2010)
New Revision: 338

Modified:
   trunk/CPreproc.hpp
   trunk/CSupport.hpp
Log:
minor cleanup

Modified: trunk/CPreproc.hpp
===================================================================
--- trunk/CPreproc.hpp	2010-03-03 19:22:46 UTC (rev 337)
+++ trunk/CPreproc.hpp	2010-03-03 21:17:45 UTC (rev 338)
@@ -4,7 +4,7 @@
 #ifndef CPREPROC_HPP
 #define CPREPROC_HPP 1
 
-#include <cstddef>
+#include <stddef.h>
 #include <stdint.h>
 #include "Zaimoni.STL/LexParse/std.h"
 

Modified: trunk/CSupport.hpp
===================================================================
--- trunk/CSupport.hpp	2010-03-03 19:22:46 UTC (rev 337)
+++ trunk/CSupport.hpp	2010-03-03 21:17:45 UTC (rev 338)
@@ -18,12 +18,6 @@
 struct parse_tree;
 class type_system;
 
-namespace virtual_machine {
-
-class CPUInfo;
-
-}
-
 /* the current draft of UNICODE only uses 17 planes so far */
 /* unfortunately, we can't assume wchar_t is correctly defined */
 /* pick the smallest type that works: need 21 bits, do not want more than 32 bits */
@@ -133,12 +127,6 @@
 
 }
 
-namespace virtual_machine {
-
-class CPUInfo;
-
-}
-
 extern const zaimoni::POD_pair<const char* const,size_t> C_atomic_types[];	// to help out the preprocessor, etc.
 extern const zaimoni::POD_pair<const char* const,size_t> CPP_atomic_types[];	// to help out the preprocessor, etc.
 extern const size_t C_int_priority[];



From zaimoni at mail.berlios.de  Wed Mar  3 20:22:49 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 3 Mar 2010 20:22:49 +0100
Subject: [Zcplusplus-commits] r337 - trunk
Message-ID: <201003031922.o23JMnc2000400@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-03 20:22:46 +0100 (Wed, 03 Mar 2010)
New Revision: 337

Modified:
   trunk/CSupport.cpp
Log:
finish include dependency fixes

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-03 18:24:17 UTC (rev 336)
+++ trunk/CSupport.cpp	2010-03-03 19:22:46 UTC (rev 337)
@@ -30,9 +30,6 @@
 #include "struct_type.hpp"
 #include "CheckReturn.hpp"
 
-// call before use; defined later
-void InitializeCLexerDefs(const virtual_machine::CPUInfo& target);
-
 using namespace zaimoni;
 using virtual_machine::umaxint;
 



From zaimoni at mail.berlios.de  Wed Mar  3 19:24:33 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 3 Mar 2010 19:24:33 +0100
Subject: [Zcplusplus-commits] r336 - trunk
Message-ID: <201003031824.o23IOXlV028407@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-03 19:24:17 +0100 (Wed, 03 Mar 2010)
New Revision: 336

Added:
   trunk/_CSupport1.hpp
   trunk/_CSupport2.hpp
   trunk/lex_core.cpp
   trunk/lex_core.h
Modified:
   trunk/CSupport.cpp
   trunk/CSupport.hpp
   trunk/C_PPHexInteger.cpp
   trunk/Flat_UNI.cpp
   trunk/MakeMake.cfg
   trunk/POSIX.dep
   trunk/langroute.cpp
   trunk/z_cpp.cpp
   trunk/zcc.cpp
Log:
include dependency control -- does obfuscate a bit, but minimizes the files exposed to a planned fork of CSupport.cpp

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-03 08:04:22 UTC (rev 335)
+++ trunk/CSupport.cpp	2010-03-03 18:24:17 UTC (rev 336)
@@ -3,6 +3,8 @@
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
 #include "CSupport.hpp"
+#include "_CSupport1.hpp"
+#include "_CSupport2.hpp"
 
 #include "Zaimoni.STL/MetaRAM2.hpp"
 #include "Zaimoni.STL/lite_alg.hpp"
@@ -28,11 +30,12 @@
 #include "struct_type.hpp"
 #include "CheckReturn.hpp"
 
+// call before use; defined later
+void InitializeCLexerDefs(const virtual_machine::CPUInfo& target);
+
 using namespace zaimoni;
 using virtual_machine::umaxint;
 
-#define C_OCTAL_DIGITS "01234567"
-#define C_HEXADECIMAL_DIGITS "0123456789ABCDEFabcdef"
 const char* const list_hexadecimal_digits = C_HEXADECIMAL_DIGITS;
 
 LangConf* CLexer = NULL;
@@ -180,23 +183,6 @@
 
 */
 
-bool IsHexadecimalDigit(unsigned char x)
-{	// FORMALLY CORRECT: Kenneth Boyd, 8/1/2002
-	if (   in_range<'0','9'>(x)
-		|| in_range<'A','F'>(x)
-		|| in_range<'a','f'>(x))
-		return true;
-	return false;
-}
-
-unsigned int InterpretHexadecimalDigit(unsigned char x)
-{	// FORMALLY CORRECT: Kenneth Boyd, 8/1/2002
-	if (in_range<'0','9'>(x)) return x-(unsigned char)'0';
-	if (in_range<'A','F'>(x)) return x-(unsigned char)'A'+10;
-	if (in_range<'a','f'>(x)) return x-(unsigned char)'a'+10;
-	return 0;
-}
-
 bool IsUnaccentedAlphabeticChar(unsigned char x)
 {	// FORMALLY CORRECT: Kenneth Boyd, 7/29/2001
 	if (   in_range<'A','Z'>(x)

Modified: trunk/CSupport.hpp
===================================================================
--- trunk/CSupport.hpp	2010-03-03 08:04:22 UTC (rev 335)
+++ trunk/CSupport.hpp	2010-03-03 18:24:17 UTC (rev 336)
@@ -5,11 +5,12 @@
 #ifndef C_SUPPORT_HPP
 #define C_SUPPORT_HPP 1
 
-#include <cstddef>
+#include <stddef.h>
 #include <stdint.h>
 #include <string.h>
 #include <limits.h>
 #include "type_algebra.hpp"
+#include "lex_core.h"
 #include "Zaimoni.STL/pure.C/auto_int.h"
 #include "Zaimoni.STL/LexParse/std.h"
 
@@ -79,7 +80,6 @@
 
 namespace zaimoni {
 
-class LangConf;
 template<class T1,class T2> struct POD_pair;
 
 // C preprocessor class has to know about this type
@@ -139,8 +139,6 @@
 
 }
 
-extern zaimoni::LangConf* CLexer;			// C99
-extern zaimoni::LangConf* CPlusPlusLexer;	// C++0x
 extern const zaimoni::POD_pair<const char* const,size_t> C_atomic_types[];	// to help out the preprocessor, etc.
 extern const zaimoni::POD_pair<const char* const,size_t> CPP_atomic_types[];	// to help out the preprocessor, etc.
 extern const size_t C_int_priority[];
@@ -152,9 +150,6 @@
 
 // character classification
 // utilities to consider more generally
-inline bool IsNumericChar(unsigned char x) {return 10U>((unsigned int)x-(unsigned int)'0');}
-bool IsHexadecimalDigit(unsigned char x);
-unsigned int InterpretHexadecimalDigit(unsigned char x);
 bool IsUnaccentedAlphabeticChar(unsigned char x);
 bool IsAlphabeticChar(unsigned char x);
 inline bool IsCIdentifierChar(char x) { return '_'==x || IsAlphabeticChar(x) || IsNumericChar(x); }
@@ -180,9 +175,6 @@
 bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const zaimoni::lex_flags flags);
 void C99_literal_is_legal(const char* const x,const size_t x_len,const zaimoni::lex_flags flags,const char* src_filename,size_t line,const type_system& types);
 
-// call before use
-void InitializeCLexerDefs(const virtual_machine::CPUInfo& target);
-
 // equivalent tokens
 // following six are dictated by C99 6.4.6 p3, C++98 2.5 p2
 inline bool detect_C_concatenation_op(const char* const src,const size_t src_len)

Modified: trunk/C_PPHexInteger.cpp
===================================================================
--- trunk/C_PPHexInteger.cpp	2010-03-03 08:04:22 UTC (rev 335)
+++ trunk/C_PPHexInteger.cpp	2010-03-03 18:24:17 UTC (rev 336)
@@ -2,7 +2,7 @@
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
 #include "C_PPHexInteger.hpp"
-#include "CSupport.hpp"
+#include "lex_core.h"
 #include "unsigned_aux.hpp"
 
 #include <stdlib.h>

Modified: trunk/Flat_UNI.cpp
===================================================================
--- trunk/Flat_UNI.cpp	2010-03-03 08:04:22 UTC (rev 335)
+++ trunk/Flat_UNI.cpp	2010-03-03 18:24:17 UTC (rev 336)
@@ -3,7 +3,7 @@
 
 #include "Flat_UNI.hpp"
 
-#include "CSupport.hpp"
+#include "lex_core.h"
 #include "Zaimoni.STL/MetaRAM2.hpp"
 
 using namespace zaimoni;
@@ -44,7 +44,7 @@
 		char* bloat_unicode = strstr(Text,"\\U0000");
 		while(NULL!=bloat_unicode)
 			{
-			if (4<=strspn(bloat_unicode+6,list_hexadecimal_digits))
+			if (4<=strspn(bloat_unicode+6,C_HEXADECIMAL_DIGITS))
 				{
 				const size_t block_length = bloat_unicode-Text+2;
 				bloat_unicode[1] = 'u';
@@ -65,7 +65,7 @@
 			{	// we down-convert a subset of allowed characters, excluding anything lower than ASCII space to avoid real weirdness
 				//! \todo portability target: want to adapt to preprocessor CHAR_BIT/UCHAR_MAX, this assumes 8/255; also assumes ASCII
 				// we restrict our attention here to the utterly safe \u00A0 - \u00FF conversion
-			if (strchr(list_hexadecimal_digits+10,bloat_unicode[4]) && strchr(list_hexadecimal_digits,bloat_unicode[5]))
+			if (strchr(C_HEXADECIMAL_DIGITS+10,bloat_unicode[4]) && strchr(C_HEXADECIMAL_DIGITS,bloat_unicode[5]))
 				{
 				const size_t block_length = bloat_unicode-Text+1;
 				const unsigned char tmp = (unsigned char)(16*InterpretHexadecimalDigit(bloat_unicode[4]+InterpretHexadecimalDigit(bloat_unicode[5])));

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2010-03-03 08:04:22 UTC (rev 335)
+++ trunk/MakeMake.cfg	2010-03-03 18:24:17 UTC (rev 336)
@@ -1,6 +1,6 @@
 ########
-ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
-				'zcc':('zcc','errors','langroute','AtomicString','str_aux','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
+ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen'),
+				'zcc':('zcc','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
 MainPrograms = ['z_cpp','zcc']
 
 # process control

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-03-03 08:04:22 UTC (rev 335)
+++ trunk/POSIX.dep	2010-03-03 18:24:17 UTC (rev 336)
@@ -1,15 +1,16 @@
-OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
-OBJECTS_Z_CPP_LINK_PRIORITY = z_cpp.o errors.o CPreproc_autogen.o CSupport.o CPUInfo.o unsigned_var_int.o CPreproc.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o ParseTree.o type_system.o str_aux.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o AtomicString.o langroute.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
+OBJECTS_Z_CPP_LINK_PRIORITY = z_cpp.o CSupport.o langroute.o lex_core.o C_PPHexInteger.o Flat_UNI.o CPreproc_autogen.o CPUInfo.o AtomicString.o ParseTree.o type_system.o errors.o unsigned_var_int.o CPreproc.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
 
-OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = zcc.o errors.o CPreproc_autogen.o CSupport.o CPUInfo.o unsigned_var_int.o CPreproc.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o ParseTree.o type_system.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPHexInteger.o C_PPOctalInteger.o AtomicString.o langroute.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
+OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
+OBJECTS_ZCC_LINK_PRIORITY = zcc.o CSupport.o langroute.o lex_core.o C_PPHexInteger.o Flat_UNI.o CPreproc_autogen.o CPUInfo.o AtomicString.o ParseTree.o type_system.o errors.o unsigned_var_int.o CPreproc.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
 
 # dependencies
-z_cpp.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
+z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
 errors.o: errors.hpp langroute.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
-langroute.o: langroute.hpp CSupport.hpp Zaimoni.STL/Logging.h Zaimoni.STL/POD.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp
+langroute.o: langroute.hpp _CSupport1.hpp Zaimoni.STL/Logging.h Zaimoni.STL/POD.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp
 AtomicString.o: AtomicString.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 str_aux.o: str_aux.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
+lex_core.o: lex_core.h Zaimoni.STL/lite_alg.hpp Zaimoni.STL/Logging.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 filesystem.o: filesystem.h Zaimoni.STL/Compiler.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h
 uchar_blob.o: uchar_blob.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp
 unsigned_var_int.o: unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp
@@ -18,18 +19,18 @@
 type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport.o: CSupport.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_ut!
 il.h C_PPNumCore.hpp
+CSupport.o: CSupport.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Le!
 xparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
-C_PPHexInteger.o: C_PPHexInteger.hpp CSupport.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h
+C_PPHexInteger.o: C_PPHexInteger.hpp lex_core.h unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalFloat.o: C_PPDecimalFloat.hpp C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPHexFloat.o: C_PPHexFloat.hpp C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 unsigned_aux.o: unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 Trigraph.o: Trigraph.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
-Flat_UNI.o: Flat_UNI.hpp CSupport.hpp Zaimoni.STL/MetaRAM2.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
+Flat_UNI.o: Flat_UNI.hpp lex_core.h Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/comptest.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
-CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/Meta!
 Token.hpp
 CPreproc_autogen.o: CPreproc.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
-zcc.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
-ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
+ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp

Added: trunk/_CSupport1.hpp
===================================================================
--- trunk/_CSupport1.hpp	2010-03-03 08:04:22 UTC (rev 335)
+++ trunk/_CSupport1.hpp	2010-03-03 18:24:17 UTC (rev 336)
@@ -0,0 +1,11 @@
+// _CSupport1.hpp
+// (C)2009, 2010 Kenneth Boyd, license: MIT.txt
+
+namespace zaimoni {
+	class LangConf;
+}
+
+// these are defined in CSupport.cpp
+extern zaimoni::LangConf* CLexer;			// C99
+extern zaimoni::LangConf* CPlusPlusLexer;	// C++0x
+

Added: trunk/_CSupport2.hpp
===================================================================
--- trunk/_CSupport2.hpp	2010-03-03 08:04:22 UTC (rev 335)
+++ trunk/_CSupport2.hpp	2010-03-03 18:24:17 UTC (rev 336)
@@ -0,0 +1,10 @@
+// _CSupport2.hpp
+// (C)2009, 2010 Kenneth Boyd, license: MIT.txt
+
+namespace virtual_machine {
+	class CPUInfo;
+}
+
+// call before first use
+void InitializeCLexerDefs(const virtual_machine::CPUInfo& target);
+

Modified: trunk/langroute.cpp
===================================================================
--- trunk/langroute.cpp	2010-03-03 08:04:22 UTC (rev 335)
+++ trunk/langroute.cpp	2010-03-03 18:24:17 UTC (rev 336)
@@ -1,7 +1,7 @@
 // langroute.cpp
 
 #include "langroute.hpp"
-#include "CSupport.hpp"
+#include "_CSupport1.hpp"
 #include "Zaimoni.STL/Logging.h"
 #include "Zaimoni.STL/POD.hpp"
 

Added: trunk/lex_core.cpp
===================================================================
--- trunk/lex_core.cpp	2010-03-03 08:04:22 UTC (rev 335)
+++ trunk/lex_core.cpp	2010-03-03 18:24:17 UTC (rev 336)
@@ -0,0 +1,28 @@
+// lex_core.cpp
+// (C)2009, 2010 Kenneth Boyd, license: MIT.txt
+
+#include "lex_core.h"
+#include "Zaimoni.STL/lite_alg.hpp"
+
+extern "C" {
+
+bool IsHexadecimalDigit(unsigned char x)
+{	// FORMALLY CORRECT: Kenneth Boyd, 8/1/2002
+	if (   zaimoni::in_range<'0','9'>(x)
+		|| zaimoni::in_range<'A','F'>(x)
+		|| zaimoni::in_range<'a','f'>(x))
+		return true;
+	return false;
+}
+
+unsigned int InterpretHexadecimalDigit(unsigned char x)
+{	// FORMALLY CORRECT: Kenneth Boyd, 8/1/2002
+	if (zaimoni::in_range<'0','9'>(x)) return x-(unsigned char)'0';
+	if (zaimoni::in_range<'A','F'>(x)) return x-(unsigned char)'A'+10;
+	if (zaimoni::in_range<'a','f'>(x)) return x-(unsigned char)'a'+10;
+	return 0;
+}
+
+}
+
+

Added: trunk/lex_core.h
===================================================================
--- trunk/lex_core.h	2010-03-03 08:04:22 UTC (rev 335)
+++ trunk/lex_core.h	2010-03-03 18:24:17 UTC (rev 336)
@@ -0,0 +1,27 @@
+/* 
+ * lex_core.h
+ * C-ish hexadecimal/octal support, etc.
+ * (C)2009, 2010 Kenneth Boyd, license: MIT.txt
+ */
+ 
+#ifndef LEX_CORE_H
+#define LEX_CORE_H 1
+
+#define C_OCTAL_DIGITS "01234567"
+#define C_HEXADECIMAL_DIGITS "0123456789ABCDEFabcdef"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+inline bool IsNumericChar(unsigned char x) {return 10U>((unsigned int)x-(unsigned int)'0');}
+bool IsHexadecimalDigit(unsigned char x);
+unsigned int InterpretHexadecimalDigit(unsigned char x);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+

Modified: trunk/z_cpp.cpp
===================================================================
--- trunk/z_cpp.cpp	2010-03-03 08:04:22 UTC (rev 335)
+++ trunk/z_cpp.cpp	2010-03-03 18:24:17 UTC (rev 336)
@@ -3,7 +3,7 @@
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
 #include "Zaimoni.STL/LexParse/Token.hpp"
-#include "CSupport.hpp"
+#include "_CSupport2.hpp"
 
 #include "CPreproc.hpp"
 #include "load_src.hpp"
@@ -15,7 +15,6 @@
 #include "errcount.hpp"
 
 #include "Zaimoni.STL/POD.hpp"
-
 #include <stdio.h>
 
 error_counter<size_t> zcc_errors(100,"FATAL: too many preprocessing errors");

Modified: trunk/zcc.cpp
===================================================================
--- trunk/zcc.cpp	2010-03-03 08:04:22 UTC (rev 335)
+++ trunk/zcc.cpp	2010-03-03 18:24:17 UTC (rev 336)
@@ -3,7 +3,7 @@
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
 #include "Zaimoni.STL/LexParse/Token.hpp"
-#include "CSupport.hpp"
+#include "_CSupport2.hpp"
 
 #include "CPreproc.hpp"
 #include "load_src.hpp"



From zaimoni at mail.berlios.de  Thu Mar  4 03:54:45 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 4 Mar 2010 03:54:45 +0100
Subject: [Zcplusplus-commits] r341 - trunk
Message-ID: <201003040254.o242sjZo022168@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-04 03:54:34 +0100 (Thu, 04 Mar 2010)
New Revision: 341

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.hpp
   trunk/CSupport_pp.cpp
   trunk/CSupport_pp.hpp
Log:
z_cpp object file reduction, pass #1

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-03 21:57:11 UTC (rev 340)
+++ trunk/CSupport.cpp	2010-03-04 02:54:34 UTC (rev 341)
@@ -537,6 +537,7 @@
 	return NULL;
 }
 
+#/*cut-cpp*/
 static const char* C99_echo_reserved_symbol(const char* x,size_t x_len)
 {
 	assert(NULL!=x);
@@ -558,6 +559,7 @@
 	while(0<i);
 	return NULL;
 }
+#/*cut-cpp*/
 
 namespace C_TYPE {
 
@@ -1049,6 +1051,7 @@
 	message_header(src.src_filename,src.logical_line.first);
 }
 
+#/*cut-cpp*/
 /* XXX this may belong with enum_type XXX */
 static void message_header(const enum_def& src)
 {
@@ -1062,6 +1065,7 @@
 	assert(src.filename() && *src.filename());
 	message_header(src.filename(),src.loc().first);
 }
+#/*cut-cpp*/
 
 // balanced character count
 static POD_pair<size_t,size_t>
@@ -4497,6 +4501,7 @@
 		}
 }
 
+#/*cut-cpp*/
 // returns true if and only if no errors
 static bool _this_vaguely_where_it_could_be_cplusplus(const parse_tree& src)
 {
@@ -4531,6 +4536,7 @@
 	while(0<j);
 	return starting_errors==zcc_errors.err_count();
 }
+#/*cut-cpp*/
 
 // this handles: ( ), [ ], { }
 // the content of ( ), [ ], { } fills the zeroth argument array
@@ -9177,14 +9183,17 @@
 	_label_literals(src,types);
 	std::for_each(src.begin<0>(),src.end<0>(),_label_CPP_literal);	// intercepts: true, false, this
 	if (!_match_pairs(src)) return false;
+#/*cut-cpp*/
 	// check that this is at least within a brace pair or a parentheses pair (it is actually required to be in a non-static member function, or constructor mem-initializer
 	if (!_this_vaguely_where_it_could_be_cplusplus(src)) return false;
+#/*cut-cpp*/	
 	CPP_locate_expressions(src,SIZE_MAX,types);
 	if (starting_errors<zcc_errors.err_count()) return false;
 	while(src.is_raw_list() && 1==src.size<0>()) src.eval_to_arg<0>(0);
 	return true;
 }
 
+#/*cut-cpp*/
 //! \todo check that the fact all literals are already legal-form is used
 static void C99_ContextFreeParse(parse_tree& src,const type_system& types)
 {
@@ -9196,6 +9205,7 @@
 	// struct/union/enum specifiers can occur in all sorts of strange places
 	C99_notice_struct_union_enum(src);
 }
+#/*cut-cpp*/
 
 bool CPP_ok_for_toplevel_qualified_name(const parse_tree& x)
 {
@@ -9323,6 +9333,7 @@
 		};
 }
 
+#/*cut-cpp*/
 //! \todo check that the fact all literals are already legal-form is used
 static void CPP_ContextFreeParse(parse_tree& src,const type_system& types)
 {
@@ -9337,6 +9348,7 @@
 	// class/struct/union/enum specifiers can occur in all sorts of strange places
 	CPP_notice_class_struct_union_enum(src);
 }
+#/*cut-cpp*/
 
 //! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
 bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
@@ -9947,6 +9959,7 @@
 		}
 }
 
+#/*cut-cpp*/
 static void conserve_tokens(parse_tree& x)
 {
 	if (x.own_index_token<0>())
@@ -9972,6 +9985,7 @@
 			}
 		}
 }
+#/*cut-cpp*/
 
 //! \todo really should be somewhere in natural-language output
 void INFORM_separated_list(const char* const* x,size_t x_len, const char* const sep)
@@ -10345,6 +10359,7 @@
 	return 0;
 }
 
+#/*cut-cpp*/
 static size_t span_to_semicolon(const parse_tree* const first,const parse_tree* const last)
 {
 	assert(first);
@@ -12129,6 +12144,7 @@
 {
 	CPP_ParseNamespace(src,types,NULL);
 }
+#/*cut-cpp*/
 
 PP_auxfunc C99_aux
  = 	{
@@ -12143,12 +12159,14 @@
 	C99_PPHackTree,
 	ConcatenateCStringLiterals,
 	C99_bad_syntax_tokenized,
+#/*cut-cpp*/
 	C99_echo_reserved_keyword,
 	C99_echo_reserved_symbol,
 	C99_ContextFreeParse,
 	C99_ContextParse,
 	C99_locate_expressions,
 	C99_literal_converts_to_bool
+#/*cut-cpp*/
 	};
 
 PP_auxfunc CPlusPlus_aux
@@ -12164,12 +12182,14 @@
 	CPP_PPHackTree,
 	ConcatenateCStringLiterals,
 	CPP_bad_syntax_tokenized,
+#/*cut-cpp*/
 	CPP_echo_reserved_keyword,
 	CPP_echo_reserved_symbol,
 	CPP_ContextFreeParse,
 	CPP_ContextParse,
 	CPP_locate_expressions,
 	CPP_literal_converts_to_bool
+#/*cut-cpp*/
 	};
 
 #if 0

Modified: trunk/CSupport.hpp
===================================================================
--- trunk/CSupport.hpp	2010-03-03 21:57:11 UTC (rev 340)
+++ trunk/CSupport.hpp	2010-03-04 02:54:34 UTC (rev 341)
@@ -115,6 +115,7 @@
 	func_traits<int (*)(const char* src, size_t src_len, const char* src2, size_t src2_len, char*& target)>::function_ref_type EscapedStringConcatenate;
 	// z_cpp 0.0.2
 	func_traits<void (*)(const char* const x, size_t x_len, lex_flags& flags, const char* const src_filename, size_t line_no)>::function_ref_type AddPostLexFlags;
+#/*cut-cpp*/
 	// zcc 0.0.2
 	func_traits<const char* (*)(const char* x,size_t x_len)>::function_ref_type EchoReservedKeyword;
 	func_traits<const char* (*)(const char* x,size_t x_len)>::function_ref_type EchoReservedSymbol;
@@ -123,6 +124,7 @@
 	// zcc 0.0.3
 	func_traits<void (*)(parse_tree&,const size_t,const type_system&)>::function_ref_type LocateExpression;
 	func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type LiteralConvertsToBool;
+#/*cut-cpp*/
 };
 
 }

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-03 21:57:11 UTC (rev 340)
+++ trunk/CSupport_pp.cpp	2010-03-04 02:54:34 UTC (rev 341)
@@ -537,28 +537,7 @@
 	return NULL;
 }
 
-static const char* C99_echo_reserved_symbol(const char* x,size_t x_len)
-{
-	assert(NULL!=x);
-	assert(x_len<=strlen(x));
-	size_t i = C_PREPROC_OP_STRICT_UB;
-	do	if (x_len==valid_pure_preprocessing_op_punc[--i].second && !strncmp(valid_pure_preprocessing_op_punc[i].first,x,x_len))
-			return valid_pure_preprocessing_op_punc[i].first;
-	while(0<i);
-	return NULL;
-}
 
-static const char* CPP_echo_reserved_symbol(const char* x,size_t x_len)
-{
-	assert(NULL!=x);
-	assert(x_len<=strlen(x));
-	size_t i = CPP_PREPROC_OP_STRICT_UB;
-	do	if (x_len==valid_pure_preprocessing_op_punc[--i].second && !strncmp(valid_pure_preprocessing_op_punc[i].first,x,x_len))
-			return valid_pure_preprocessing_op_punc[i].first;
-	while(0<i);
-	return NULL;
-}
-
 namespace C_TYPE {
 
 enum hard_type_indexes {
@@ -1049,20 +1028,7 @@
 	message_header(src.src_filename,src.logical_line.first);
 }
 
-/* XXX this may belong with enum_type XXX */
-static void message_header(const enum_def& src)
-{
-	assert(src.filename() && *src.filename());
-	message_header(src.filename(),src.loc().first);
-}
 
-/* XXX this may belong with C_union_struct_def XXX */
-static void message_header(const C_union_struct_def& src)
-{
-	assert(src.filename() && *src.filename());
-	message_header(src.filename(),src.loc().first);
-}
-
 // balanced character count
 static POD_pair<size_t,size_t>
 _balanced_character_count(const weak_token* tokenlist,size_t tokenlist_len,const char l_match,const char r_match)
@@ -4497,41 +4463,7 @@
 		}
 }
 
-// returns true if and only if no errors
-static bool _this_vaguely_where_it_could_be_cplusplus(const parse_tree& src)
-{
-	const size_t starting_errors = zcc_errors.err_count();
-	if (robust_token_is_string<4>(src.index_tokens[0].token,"this"))
-		{
-		message_header(src.index_tokens[0]);
-		INC_INFORM(ERR_STR);
-		INFORM("keyword this is allowed only within a non-static member function body or a constructor memory initializer (C++98 5.1p3)");
-		zcc_errors.inc_error();
-		};
 
-	size_t j = STATIC_SIZE(src.args);
-	do	{
-		if (0== --j && NULL!=src.index_tokens[0].token.first && NULL!=src.index_tokens[1].token.first)
-			{
-			if (token_is_char<'('>(src.index_tokens[0].token) && token_is_char<')'>(src.index_tokens[1].token)) break;	// need to parse to rule out constructor memory initializer
-			if (token_is_char<'{'>(src.index_tokens[0].token) && token_is_char<'}'>(src.index_tokens[1].token)) break;	// need to parse to rule out non-static member function
-			}
-		size_t i = src.size(j);
-		while(0<i)
-			{
-			if (robust_token_is_string<4>(src.data(j)[--i].index_tokens[0].token,"this"))
-				{
-				message_header(src.data(j)[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("keyword this is allowed only within a non-static member function body or a constructor memory initializer (C++98 5.1p3)");
-				zcc_errors.inc_error();
-				};
-			}
-		}
-	while(0<j);
-	return starting_errors==zcc_errors.err_count();
-}
-
 // this handles: ( ), [ ], { }
 // the content of ( ), [ ], { } fills the zeroth argument array
 // C++ *sometimes* wants to match < > as well, but its approaches are...painful.  Do that elsewhere
@@ -9177,25 +9109,12 @@
 	_label_literals(src,types);
 	std::for_each(src.begin<0>(),src.end<0>(),_label_CPP_literal);	// intercepts: true, false, this
 	if (!_match_pairs(src)) return false;
-	// check that this is at least within a brace pair or a parentheses pair (it is actually required to be in a non-static member function, or constructor mem-initializer
-	if (!_this_vaguely_where_it_could_be_cplusplus(src)) return false;
 	CPP_locate_expressions(src,SIZE_MAX,types);
 	if (starting_errors<zcc_errors.err_count()) return false;
 	while(src.is_raw_list() && 1==src.size<0>()) src.eval_to_arg<0>(0);
 	return true;
 }
 
-//! \todo check that the fact all literals are already legal-form is used
-static void C99_ContextFreeParse(parse_tree& src,const type_system& types)
-{
-	assert(src.is_raw_list());
-	_label_literals(src,types);
-	if (!_match_pairs(src)) return;
-	// handle core type specifiers
-	C99_notice_primary_type(src);
-	// struct/union/enum specifiers can occur in all sorts of strange places
-	C99_notice_struct_union_enum(src);
-}
 
 bool CPP_ok_for_toplevel_qualified_name(const parse_tree& x)
 {
@@ -9323,20 +9242,6 @@
 		};
 }
 
-//! \todo check that the fact all literals are already legal-form is used
-static void CPP_ContextFreeParse(parse_tree& src,const type_system& types)
-{
-	assert(src.is_raw_list());
-	_label_literals(src,types);
-	std::for_each(src.begin<0>(),src.end<0>(),_label_CPP_literal);	// intercepts: true, false, this
-	if (!_match_pairs(src)) return;
-	// handle core type specifiers
-	CPP_notice_primary_type(src);
-	// do context-free part of qualified-names
-	CPP_notice_scope_glue(src);
-	// class/struct/union/enum specifiers can occur in all sorts of strange places
-	CPP_notice_class_struct_union_enum(src);
-}
 
 //! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
 bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
@@ -9947,31 +9852,6 @@
 		}
 }
 
-static void conserve_tokens(parse_tree& x)
-{
-	if (x.own_index_token<0>())
-		{
-		const char* const tmp = is_substring_registered(x.index_tokens[0].token.first,x.index_tokens[0].token.second);
-		if (tmp)
-			{
-			assert(tmp!=x.index_tokens[0].token.first);
-			free(const_cast<char*>(x.index_tokens[0].token.first));
-			x.index_tokens[0].token.first = tmp;
-			x.control_index_token<0>(false);
-			}
-		}
-	if (x.own_index_token<1>())
-		{
-		const char* const tmp = is_substring_registered(x.index_tokens[1].token.first,x.index_tokens[1].token.second);
-		if (tmp)
-			{
-			assert(tmp!=x.index_tokens[1].token.first);
-			free(const_cast<char*>(x.index_tokens[1].token.first));
-			x.index_tokens[1].token.first = tmp;
-			x.control_index_token<1>(false);
-			}
-		}
-}
 
 //! \todo really should be somewhere in natural-language output
 void INFORM_separated_list(const char* const* x,size_t x_len, const char* const sep)
@@ -10345,1791 +10225,7 @@
 	return 0;
 }
 
-static size_t span_to_semicolon(const parse_tree* const first,const parse_tree* const last)
-{
-	assert(first);
-	assert(last);
-	const parse_tree* iter = first;
-	while(iter!=last && !robust_token_is_char<';'>(*iter)) ++iter;
-	return iter-first;
-}
 
-#if 0
-static bool is_identifier_list(const parse_tree& src,func_traits<const char* (*)(const char* x,size_t x_len)>::function_ref_type EchoReservedKeyword)
-{
-	assert(!src.empty());
-	size_t j = src.size<0>();
-	if (!(j%2)) return false;
-	const parse_tree* const x = src.data<0>();
-	assert(x);
-	do	{
-		if (!x[--j].is_atomic()) return false;
-		if (0==j%2)
-			{	// identifier needed
-			if (   C_TESTFLAG_IDENTIFIER!=x[j].index_tokens[0].flags	// must be identifier
-				|| (PARSE_TYPE & x[j].flags) 	// internal representation could land some types here, especially primary types
-				|| EchoReservedKeyword(x[j].index_tokens[0].token.first,x[j].index_tokens[0].token.second))	// keywords are only lexically identifiers, they'll cause problems
-				return false;
-			}
-		else{	// comma needed
-			if (!token_is_char<','>(x[j].index_tokens[0].token))
-				return false;
-			}
-		}
-	while(0<j);
-	return true;
-}
-#endif
-
-static void C99_CPP_handle_static_assertion(parse_tree& src,type_system& types,PP_auxfunc& langinfo,const size_t i,const char* const err)
-{
-	assert(err && *err);
-	// find the next ';'
-	const size_t j = i+span_to_semicolon(src.data<0>()+i,src.end<0>());
-	if (src.size<0>()<=j)
-		{	//! \test zcc/staticassert.C99/Error_scope1.h, zcc/staticassert.C99/Error_scope1.hpp
-			//! \test zcc/staticassert.C99/Error_scope2.h, zcc/staticassert.C99/Error_scope2.hpp
-		message_header(src.data<0>()[i].index_tokens[0]);
-		INC_INFORM(ERR_STR);
-		INFORM("static assertion cut off by end of scope");
-		zcc_errors.inc_error();
-		src.DeleteNSlotsAt<0>(j-i,i);
-		return;
-		};
-	if (   !is_naked_parentheses_pair(src.data<0>()[i+1])
-		|| 3>src.data<0>()[i+1].size<0>()
-		|| !robust_token_is_char<','>(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-2])
-		|| !src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].is_atomic()
-		|| C_TESTFLAG_STRING_LITERAL!=src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].flags)
-		{	//! \test zcc/staticassert.C99/Error_badarg1.h, zcc/staticassert.C99/Error_badarg1.hpp
-			//! \test zcc/staticassert.C99/Error_badarg2.h, zcc/staticassert.C99/Error_badarg2.hpp
-			//! \test zcc/staticassert.C99/Error_badarg3.h, zcc/staticassert.C99/Error_badarg3.hpp
-			//! \test zcc/staticassert.C99/Error_badarg5.h, zcc/staticassert.C99/Error_badarg5.hpp
-			//! \test zcc/staticassert.C99/Error_badarg6.h, zcc/staticassert.C99/Error_badarg6.hpp
-			//! \test zcc/staticassert.C99/Error_badarg7.h, zcc/staticassert.C99/Error_badarg7.hpp
-		message_header(src.data<0>()[i].index_tokens[0]);
-		INC_INFORM(ERR_STR);
-		INFORM("malformed static assertion");
-		zcc_errors.inc_error();
-		src.DeleteNSlotsAt<0>(j-i+1,i);
-		return;
-		};
-	if (2!=j-i)
-		{	//! \test zcc/staticassert.C99/Error_badarg4.h, zcc/staticassert.C99/Error_badarg4.hpp
-		message_header(src.data<0>()[i].index_tokens[0]);
-		INC_INFORM(ERR_STR);
-		INFORM("garbage between static assertion arguments and terminating ;");
-		zcc_errors.inc_error();
-		src.DeleteNSlotsAt<0>(j-i+1,i);
-		return;
-		};
-	// actually use the static assertion correctly.
-	parse_tree_class parsetree;
-	{
-	const size_t k = src.data<0>()[i+1].size<0>()-2;
-	if (!parsetree.resize<0>(k))
-		{
-		message_header(src.data<0>()[i].index_tokens[0]);
-		INC_INFORM(ERR_STR);
-		_fatal("insufficient RAM to parse static assertion");
-		};
-	zaimoni::autotransform_n<void (*)(parse_tree&,const parse_tree&)>(parsetree.c_array<0>(),src.data<0>()[i+1].data<0>(),k,value_copy);
-	}
-	// init above correctly
-	// snip from Condense
-	const size_t starting_errors = zcc_errors.err_count();
-	(langinfo.LocateExpression)(parsetree,SIZE_MAX,types);
-	if (starting_errors==zcc_errors.err_count())
-		{
-		while(parsetree.is_raw_list() && 1==parsetree.size<0>()) parsetree.eval_to_arg<0>(0);
-		// end snip from Condense
-		// snip from CPreproc
-		if (!parsetree.is_atomic() && !(langinfo.EvalParseTree)(parsetree,types))
-			{
-			parsetree.destroy();	// efficiency
-			message_header(src.data<0>()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM(err);
-			zcc_errors.inc_error();
-			src.DeleteNSlotsAt<0>(j-i+1,i);
-			return;
-			}
-		(langinfo.PPHackTree)(parsetree,types);
-		// final, when above is working properly
-		if (!parsetree.is_atomic())
-			{	//! \bug need test cases
-			parsetree.destroy();	// efficiency
-			message_header(src.data<0>()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM(err);
-			zcc_errors.inc_error();
-			src.DeleteNSlotsAt<0>(j-i+1,i);
-			return;
-			}
-		// end snip from CPreproc
-		bool is_true = false;
-		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true))
-			{	//! \bug need test cases
-			parsetree.destroy();	// efficiency
-			message_header(src.data<0>()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM(err);
-			zcc_errors.inc_error();
-			src.DeleteNSlotsAt<0>(j-i+1,i);
-			return;
-			};
-		parsetree.destroy();	// efficiency
-		//! \test zcc/staticassert.C1X/Pass_autosucceed.h, zcc/staticassert.C1X/Pass_autosucceed.hpp
-		if (!is_true)
-			{	//! \test zcc/staticassert.C1X/Error_autofail.h, zcc/staticassert.C1X/Error_autofail.hpp
-			message_header(src.data<0>()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			// hmm...really should unescape string before emitting
-			const size_t tmp_size = LengthOfCStringLiteral(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.second);
-			if (1U>=tmp_size || 'L'== *src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first)
-				{	//! \todo handle wide-strings later
-				INFORM("(static assertion failure)");
-				zcc_errors.inc_error();
-				src.DeleteNSlotsAt<0>(j-i+1,i);
-				return;
-				};
-
-			char* tmp = _new_buffer<char>(tmp_size);
-			if (NULL==tmp)
-				{
-				INFORM("(static assertion failure)");
-				zcc_errors.inc_error();
-				src.DeleteNSlotsAt<0>(j-i+1,i);
-				return;
-				}
-			UnescapeCString(tmp,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first+1,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.second-2);
-			INFORM(tmp);
-			free(tmp);
-			zcc_errors.inc_error();
-			src.DeleteNSlotsAt<0>(j-i+1,i);
-			return;
-			};
-		}
-	src.DeleteNSlotsAt<0>(j-i+1,i);
-}
-
-static bool default_enumerator_init_legal(const bool allow_empty, unsigned char& current_enumerator_type, const unsigned_var_int& prior_value, const weak_token& src)
-{
-	if (allow_empty)
-		{	// C++
-		//! \todo research how to rewrite this without the goto
-cpp_enum_was_retyped:
-		const promote_aux test(current_enumerator_type);
-		//! \bug need -Wc-c++-compat to go off here
-		if (test.is_signed)
-			{
-			if (prior_value==target_machine->signed_max(test.machine_type))
-				{
-				++current_enumerator_type;	// smallest type that can handle this
-				goto cpp_enum_was_retyped;
-				}
-			}
-		else{
-			if (prior_value==target_machine->unsigned_max(test.machine_type))
-				{
-				if (C_TYPE::INTEGERLIKE == ++current_enumerator_type)	// smallest type that can handle this
-					{	// unsigned long long overflow, fact it's defined doesn't save us
-					//! \test decl.C99/Error_enum_overflow.hpp
-					message_header(src);
-					INC_INFORM(ERR_STR);
-					INFORM("default-initialization of enumerator requires uintmax_t overflow (C++0X 7.2p5)");
-					zcc_errors.inc_error();
-					return false;
-					}
-				goto cpp_enum_was_retyped;
-				}
-			}
-		}
-	else{	// C
-		if (prior_value==target_machine->signed_max<virtual_machine::std_int_int>())
-			{	// signed integer overflow
-				//! \test decl.C99/Error_enum_overflow.h
-			message_header(src);
-			INC_INFORM(ERR_STR);
-			INFORM("default-initialization of enumerator requires signed int overflow (C99 6.7.2.2p3)");
-			zcc_errors.inc_error();
-			return false;
-			}
-		}
-	return true;
-}
-
-static bool record_enum_values(parse_tree& src, type_system& types, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits<const char* (*)(const char*, size_t)>::function_ref_type echo_reserved_keyword, func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type CondenseParseTree, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
-{
-	assert(enum_type_index);
-	assert(!active_namespace || *active_namespace);
-	assert(is_naked_brace_pair(src));
-	// enumeration idea:
-	// * identifer [= ...] ,
-	// terminal , is optional (and in fact should trigger a warning for -Wbackport)
-	// empty collection of enumerators is fine for C++, rejected by C (should be error in C and -Wc-c++-compat for C++)
-	// XXX use allow_empty to signal C vs. C++ language
-	// values would be unsigned_var_int
-	if (src.empty<0>())
-		{
-		if (!allow_empty)
-			{	//! \test zcc/decl.C99/Error_enum_empty.h
-			message_header(src.index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM("enumeration has no enumerators (C99 6.7.2.2p1)");
-			zcc_errors.inc_error();
-			return false;
-			}
-		else if (bool_options[boolopt::warn_crosslang_compatibility])
-			{	//! \test zcc/compat/Warn_enum_empty.hpp
-			message_header(src.index_tokens[0]);
-			INC_INFORM(WARN_STR);
-			INFORM("enumeration with no enumerators is an error in C90/C99/C1X");
-			if (bool_options[boolopt::warnings_are_errors])
-				{
-				zcc_errors.inc_error();
-				return false;
-				}
-			}
-		//! \test zcc/decl.C99/Pass_enum_empty.hpp
-		return true;
-		};
-	// determine if format generally there
-	// stage 1: top-level comma check
-	// * terminal comma is optional, zap it and warn if -Wbackport
-	// * one more enumerator possible than surviving commas; use this to construct buffers
-	size_t i = 0;
-	while(src.size<0>()>i)
-		{	// require identifier that is neither keyword nor a primitive type
-			// C++ will have problems with enum/struct/class/union names, verify status of both of these (could be -Wc-c++-compat issue if legal in C)
-			// if identifier, verify next is = or ,
-			// if next is =, locate comma afterwards (do not do expression parsing yet)
-			//! \todo: enforce One Definition Rule for C++ vs types; determine how much of the effect is in C as well
-		if (   !src.data<0>()[i].is_atomic()
-			||  C_TESTFLAG_IDENTIFIER!=src.data<0>()[i].index_tokens[0].flags
-			|| (PARSE_TYPE & src.data<0>()[i].flags)
-			|| echo_reserved_keyword(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].token.second))
-			{	//! \test zcc/decl.C99/Error_enum_brace.h, zcc/decl.C99/Error_enum_brace.hpp
-				//! \test zcc/decl.C99/Error_enum_symbol.h, zcc/decl.C99/Error_enum_symbol.hpp
-				//! \test zcc/decl.C99/Error_enum_type.h, zcc/decl.C99/Error_enum_type.hpp
-				//! \test zcc/decl.C99/Error_enum_keyword.h, zcc/decl.C99/Error_enum_keyword.hpp
-			message_header(0==i ? src.index_tokens[0] : src.data<0>()[i-i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM("non-keyword identifier expected as enumerator (C99 6.4.4.3p1/C++0X 7.2p1)");
-			zcc_errors.inc_error();
-			return false;
-			}
-		if (1>=src.size<0>()-i) break;	// fine, would default-update
-		if (robust_token_is_char<','>(src.data<0>()[i+1]))
-			{	// would default-update
-			i += 2;
-			continue;
-			};
-		if (!robust_token_is_char<'='>(src.data<0>()[i+1]))
-			{	//! \test zcc/decl.C99/Error_enum_no_init.h, zcc/decl.C99/Error_enum_no_init.hpp
-			message_header(src.data<0>()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM("enumerator neither explicitly initialized nor default-initialized (C99 6.4.4.3p1/C++0X 7.2p1)");
-			zcc_errors.inc_error();
-			return false;
-			};
-		i += 2;
-		if (src.size<0>()<=i || robust_token_is_char<','>(src.data<0>()[i]))
-			{	//! \test zcc/decl.C99/Error_enum_init_truncated.h, zcc/decl.C99/Error_enum_init_truncated.hpp
-			message_header(src.data<0>()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM("enumerator initializer cut off by , (C99 6.4.4.3p1/C++0X 7.2p1)");
-			zcc_errors.inc_error();
-			return false;
-			};
-		while(++i < src.size<0>())
-			{
-			if (robust_token_is_char<','>(src.data<0>()[i]))
-				{
-				++i;
-				break;
-				}
-			};
-		}
-	if (robust_token_is_char<','>(src.back<0>()))
-		{	// warn for -Wbackport
-			//! \test zcc/decl.C99/Pass_enum_trailing_comma.h, zcc/decl.C99/Pass_enum_trailing_comma.hpp
-			//! \test zcc/backport/Warn_enum_trailing_comma.h, zcc/backport/Warn_enum_trailing_comma.hpp
-		if (bool_options[boolopt::warn_backport])
-			{
-			message_header(src.back<0>().index_tokens[0]);
-			INC_INFORM(WARN_STR);
-			INFORM("trailing , in enumeration definition would be an error in C90/C++98");
-			if (bool_options[boolopt::warnings_are_errors])
-				{
-				zcc_errors.inc_error();
-				return false;
-				}
-			}
-		src.DeleteIdx<0>(src.size<0>()-1); // clean up anyway
-		}
-	//! \todo actually record enumerator matchings
-	unsigned_var_int latest_value(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
-	unsigned_var_int prior_value(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
-	unsigned char current_enumerator_type = C_TYPE::INT;
-//	bool cpp_using_negative = false;
-//	bool cpp_using_above_LLONG_MAX = false;
-	i = 0;
-	while(src.size<0>()>i)
-		{	// require identifier that is neither keyword nor a primitive type
-			// C++ will have problems with enum/struct/class/union names, verify status of both of these (could be -Wc-c++-compat issue if legal in C)
-			// if identifier, verify next is = or ,
-			// if next is =, locate comma afterwards (do not do expression parsing yet)
-			//! \todo: enforce One Definition Rule for C++ vs types; determine how much of the effect is in C as well
-		assert(src.data<0>()[i].is_atomic());
-		assert(C_TESTFLAG_IDENTIFIER==src.data<0>()[i].index_tokens[0].flags);
-		assert(!(PARSE_TYPE & src.data<0>()[i].flags));
-		assert(!echo_reserved_keyword(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].token.second));
-		{
-		char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[0].token.first,active_namespace,"::") : NULL;
-		const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[0].token.first;
-		{
-		const type_system::enumerator_info* tmp = types.get_enumerator(fullname);
-		if (tmp)
-			{	// --do-what-i-mean could recover if the prior definition were identical
-				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined
-				// C++: One Definition Rule wipes out
-				//! \test decl.C99/Error_enum_multidef.h, decl.C99/Error_enum_multidef.hpp 
-			message_header(src.data<0>()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM("enumerator is already defined (C99 6.7.2.2p3/C++98 3.2)");
-			zcc_errors.inc_error();
-			free(namespace_name);
-			return false;
-			};
-		}
-		free(namespace_name);
-		}
-#if 0
-		// next proposed function call is a bit handwavish right now...
-		// C++0X 3.3.1p4: enumerator gets to hide class names and enum names, nothing else [in particular dies against typedefs and functions]
-		if (types.enum_already_defined(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
-			{	// -Wbackport warn in C++, fail in C
-			if (allow_empty)
-				{	// C++0X
-				if (bool_options[boolopt::warn_crosslang_compatibility] || bool_options[boolopt::warn_backport])
-					{
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("enum with same name as enumerator is already defined (C99 6.7.2.2p3/C++98 3.2/C++0X 3.2)");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					}
-			else{	// C
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("enum with same name as enumerator is already defined (C99 6.7.2.2p3)");
-				zcc_errors.inc_error();
-				return false;
-				}	
-			};
-		if (types.union_class_struct_already_declared(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
-			{	// -Wbackport warn in C++, fail in C
-			if (allow_empty)
-				{	// C++0X
-				if (bool_options[boolopt::warn_crosslang_compatibility] || bool_options[boolopt::warn_backport])
-					{
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("union, struct, or class with same name as enumerator is already defined (C99 6.7.2.2p3/C++98 3.2/C++0X 3.2)");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					}
-				}
-			else{	// C
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("union or struct with same name as enumerator is already defined (C99 6.7.2.2p3)");
-				zcc_errors.inc_error();
-				return false;
-				}	
-			};
-		if (types.function_already_declared(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
-			{	// C++: One Definition Rule
-			};
-#endif
-		{
-		const zaimoni::POD_triple<type_spec,const char*,size_t>* const tmp = types.get_typedef_CPP(src.data<0>()[i].index_tokens[0].token.first,active_namespace); 
-		if (tmp)
-			{	// C++: One Definition Rule
-				//! \test decl.C99/Error_enum_typedef.h, decl.C99/Error_enum_typedef.hpp 
-			message_header(src.data<0>()[i].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM("typedef is already defined, conflicts with enumerator (C99 6.7.2.2p3/C++98 3.2)");
-			INC_INFORM(tmp->second);
-			INC_INFORM(":");
-			INC_INFORM(tmp->third);
-			INFORM(": typedef definition here");
-			zcc_errors.inc_error();
-			return false;
-			};
-		}
-
-		// The type and representation of an enumeration varies by language
-		// C: values are type int; actual representation can be decided after seeing all enumeration values.
-		// C++: if the underlying type is fixed, then the enumerator is of that type.  Othewise,
-		// each enumerator has the same type as its initializing expression, and the underlying type of
-		// the enumeration is large enough to represent all values.
-		// So, for the default-update cases
-		// C: type int, hard-error if going above INT_MAX
-		// C++: type per language specification,
-		// * hard-error if going above ULONG_MAX
-		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
-		// in any case, do not react if the default-init isn't used
-		value_copy(prior_value,latest_value);
-		bool value_is_nonnegative_or_twos_complement = true;
-		if (virtual_machine::twos_complement!=target_machine->C_signed_int_representation())
-			{
-			const promote_aux test(current_enumerator_type);
-			if (test.is_signed && latest_value.test(test.bitcount-1))
-				{
-				target_machine->signed_additive_inverse(latest_value,test.machine_type);
-				if (0<latest_value)
-					{
-					latest_value -= 1;
-					if (0<latest_value) target_machine->signed_additive_inverse(latest_value,test.machine_type);
-					value_is_nonnegative_or_twos_complement = false;
-					}
-				}
-			}
-		if (value_is_nonnegative_or_twos_complement) latest_value += 1;
-
-		if (1>=src.size<0>()-i)
-			{	// default-update
-			// handle type errors
-			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0]))
-				return false;
-			uchar_blob latest_value_copy;
-			latest_value_copy.init(0);
-			value_copy(latest_value_copy,latest_value);
-			if (active_namespace)
-				types.set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
-			else
-				types.set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
-			break;
-			}
-		// complete conversion
-		// C: type int, hard-error if not within INT_MIN..INT_MAX
-		// C++: type per language specification
-		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
-		if (robust_token_is_char<','>(src.data<0>()[i+1]))
-			{	// would default-update
-			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0]))
-				return false;
-			uchar_blob latest_value_copy;
-			latest_value_copy.init(0);
-			value_copy(latest_value_copy,latest_value);
-			if (active_namespace)
-				types.set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
-			else
-				types.set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
-			i += 2;
-			continue;
-			};
-		assert(robust_token_is_char<'='>(src.data<0>()[i+1]));
-		i += 2;
-		const size_t origin = i;
-		assert(src.size<0>()>i && !robust_token_is_char<','>(src.data<0>()[i]));
-		bool comma_overextended = false;
-		while(++i < src.size<0>())
-			{
-			if (robust_token_is_char<','>(src.data<0>()[i]))
-				{
-				++i;
-				comma_overextended = true;
-				break;
-				}
-			};
-		{	// see if it's a compile-time constant
-		parse_tree_class tmp(src,origin,i-comma_overextended,0);
-		if (tmp.is_raw_list() && !CondenseParseTree(tmp,types)) return false;
-		if (!EvalParseTree(tmp,types)) return false;
-		if (!intlike_literal_to_VM(latest_value,tmp))
-			{	//! \bug need test case
-			message_header(src.data<0>()[origin-2].index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INFORM("enumerator can only be explicitly initialized by a compile-time constant (C99 6.7.2.2p3/C++98 7.2p1)");
-			zcc_errors.inc_error();
-			return false;
-			}
-		// range checks
-		if (allow_empty)
-			{	// C++
-			current_enumerator_type = tmp.type_code.base_type_index;
-			}
-		else{	// C
-			const promote_aux test(tmp.type_code.base_type_index);
-			const promote_aux dest_type(C_TYPE::INT);
-			const bool is_negative = test.is_signed && latest_value.test(test.bitcount-1);
-			if (is_negative)
-				target_machine->signed_additive_inverse(latest_value,test.machine_type);
-			bool out_of_range = latest_value>target_machine->signed_max<virtual_machine::std_int_int>();
-			if (out_of_range && is_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation())
-				{	// handle two's complement INT_MIN
-				latest_value -= 1;
-				if (latest_value<=target_machine->signed_max<virtual_machine::std_int_int>()) 
-					out_of_range = false;
-				latest_value += 1;
-				}
-			if (out_of_range)
-				{	//! \test decl.C99/Error_enum_overflow2.h
-					//! \bug need -Wc-c++-compat to go off here
-				message_header(src.data<0>()[origin-2].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("initializer of enumerator not representable as signed int (C99 6.7.2.2p3)");
-				zcc_errors.inc_error();
-				return false;
-				}
-			if (is_negative)
-				target_machine->signed_additive_inverse(latest_value,dest_type.machine_type);
-			tmp.type_code.base_type_index = C_TYPE::INT;
-			}
-#if 0
-		if (origin+1<i-comma_overextended)
-			{	// net token reduction, do source code optimization?
-			}
-#endif
-		}
-
-		{	// actually register the enumerator
-		uchar_blob latest_value_copy;
-		latest_value_copy.init(0);
-		value_copy(latest_value_copy,latest_value);
-		if (active_namespace)
-			types.set_enumerator_def_CPP(src.data<0>()[origin-2].index_tokens[0].token.first, active_namespace,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
-		else
-			types.set_enumerator_def(src.data<0>()[origin-2].index_tokens[0].token.first,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
-		}
-		}
-	// now ok to crunch underlying type/machine representation
-	return true;
-}
-
-// will need: "function-type vector"
-// return: 1 typespec record (for now, other languages may have more demanding requirements)
-// incoming: n typespec records, flag for trailing ...
-// will need: typedef map: identifier |-> typespec record
-//! \todo check that the fact all literals are already legal-form is used
-static void C99_ContextParse(parse_tree& src,type_system& types)
-{
-	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle in type_spec, which is required to be POD to allow C memory management:
-	// * indirection depth n (already have this in practice)
-	// * const, volatile at each level of indirection 0..n
-	// * extent at each level of indirection 1..n (0 := raw-ptr, positive := array that can be bounds-checked for undefined behavior
-	// * top-level reference (check standards to see if reference-in-middle is illegal, never seen it in real source)
-	// * C99: restrict qualifier at each level of indirection 1..n (this is *not* in C++0x as of April 8 2009!)
-	// * storage-qualifiers extern, static, register, auto
-	// * fake type-qualifier typedef
-	// Exploit uintptr_t to mitigate dynamic memory management.
-	// * union of uintptr_t,unsigned char[sizeof(uintptr_t)] is probably best way to handle the qualifier-vector
-	// * extent-vector will be painful: properly should be a CPUInfo-controlled type.  Can get away with uintmax_t for now.  (size_t won't work because we're
-	//   a cross-compiler; target size_t could be larger than host size_t.  size_t does work for string literals since we have to represent those on the host.)
-	// note that typedefs and struct/union declarations/definitions create new types; if this happens we are no longer context-free (so second pass with context-based parsing)
-	// ask GCC: struct/class/union/enum collides with each other (both C and C++), does not collide with namespace
-	// think we can handle this as "disallow conflicting definitions"
-	size_t i = 0;
-	while(i<src.size<0>())
-		{
-		conserve_tokens(src.c_array<0>()[i]);
-		// C static assertion scanner
-		if (robust_token_is_string<14>(src.data<0>()[i],"_Static_Assert"))
-			{	// _Static_Assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CLexer->pp_support,i," : control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)");
-			continue;
-			};
-		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
-		// check naked declarations first
-		if (is_C99_named_specifier(src.data<0>()[i],"union"))
-			{
-			type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
-			src.c_array<0>()[i].type_code.set_type(tmp);
-			}
-		else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
-			{
-			type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
-			src.c_array<0>()[i].type_code.set_type(tmp);
-			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
-			{	// can only define once
-			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-			if (tmp)
-				{	//! \test zcc/decl.C99/Error_union_multidef.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'union ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-				INFORM("' already defined (C99 6.7.2.3p1)");
-				message_header(*tmp);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				// now it's gone
-				// remove trailing semicolon if present
-				src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
-				continue;
-				}
-			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
-			{	// can only define once
-			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-			if (tmp)
-				{	//! \test zcc/decl.C99/Error_struct_multidef.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'struct ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-				INFORM("' already defined (C99 6.7.2.3p1)");
-				message_header(*tmp);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				// now it's gone
-				// remove trailing semicolon if present
-				src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
-				continue;
-				}
-			}
-		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
-		else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
-			{	// C99 6.7.2.3: allowed only after name is defined
-			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
-				{
-				type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
-				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
-				if (!tmp)
-					{	//! \test zcc\decl.C99\Error_enum_undef.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'enum ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
-					zcc_errors.inc_error();
-					src.c_array<0>()[i].flags |= parse_tree::INVALID;
-					}
-				}
-			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
-			{	// can only define once
-			const type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
-			if (tmp)
-				{	//! \test zcc\decl.C99\Error_enum_multidef.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'enum ");
-				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-				INFORM("' already defined (C99 6.7.2.3p1)");
-				const enum_def* const tmp2 = types.get_enum_def(tmp);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				// now it's gone
-				src.DeleteNSlotsAt<0>(1,i);
-				continue;
-				};
-			// enum-specifier doesn't have a specific declaration mode
-			//! \test zcc\decl.C99\Pass_enum_def.h
-			const type_system::type_index tmp2 = types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			assert(types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
-				{
-				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
-				return;
-				}
-			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
-			{	// enum-specifier doesn't have a specific declaration mode
-				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = types.register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
-				{
-				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
-				return;
-				}
-			}
-
-		if (	1<src.size<0>()-i
-			&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
-			{	// is_C99_named_specifier(src.data<0>()[i],"enum") will cause an error later, in variable parsing
-			if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_union.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous union declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_struct.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous struct declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			else if (is_C99_named_specifier(src.data<0>()[i],"union"))
-				{	// forward-declare, fine
-				if (types.get_id_union(src.data<0>()[i].index_tokens[1].token.first))
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_union_forward_def.h
-					// remove from parse
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;					
-					}
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_union_forward_def.h
-				const type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
-				{	// forward-declare, fine
-				if (types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_struct_forward_def.h
-					// remove from parse
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;					
-					}
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				const type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
-				{	// definitions...fine
-				const type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
-				C_union_struct_def* tmp2 = NULL;
-				if (tmp)
-					{	// promoting forward-declare to definition
-						//! \test zcc/decl.C99/Pass_union_forward_def.h
-					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-					assert(tmp3);
-					tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-					//! \todo record field structure, etc.
-					types.upgrade_decl_to_def(tmp,tmp2);
-					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp);
-					assert(types.get_C_structdef(tmp));
-					}
-				else{	// definition
-						//! \test zcc/decl.C99/Pass_union_def.h
-					//! \todo record field structure, etc.
-					const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_union);
-					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
-					assert(types.get_C_structdef(tmp3));
-					src.c_array<0>()[i].type_code.set_type(tmp3);
-					}
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
-				{	// definitions...fine
-				const type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
-				C_union_struct_def* tmp2 = NULL;
-				if (tmp)
-					{	// promoting forward-declare to definition
-						//! \test zcc/decl.C99/Pass_struct_forward_def.h
-					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-					assert(tmp3);
-					tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-					//! \todo record field structure, etc.
-					types.upgrade_decl_to_def(tmp,tmp2);
-					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp);
-					assert(types.get_C_structdef(tmp));
-					}
-				else{	// definition
-						//! \test zcc/decl.C99/Pass_struct_def.h
-					//! \todo record field structure, etc.
-					const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_struct);
-					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
-					assert(types.get_C_structdef(tmp3));
-					src.c_array<0>()[i].type_code.set_type(tmp3);
-					}
-				i += 2;
-				continue;
-				};
-			};
-		// general declaration scanner 
-		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
-		// intercept declarations as follows
-		// * storage-class specifiers
-		// ** C: extern static auto register
-		// ** C: taking address of a register-qualified var is an error; not so for C++ (just downgrades register to auto implicitly)
-		// * typedef (pretty much a fake storage-class specifier)
-		// * function specifiers
-		// ** C: inline
-		// * cv-qualification
-		// ** C: const volatile restrict (but pointer type required for restrict)
-		// * atomic types have already been parsed, we need to catch the others
-		{
-		C99_decl_specifier_scanner declFind(types);
-		size_t decl_count = src.get_span<0>(i,declFind);
-		if (decl_count)
-			{
-			const bool coherent_storage_specifiers = declFind.analyze_flags_global(src,i,decl_count);
-			if (src.size<0>()-i<=decl_count)
-				{	// unterminated declaration
-					//! \test zcc/decl.C99/Error_extern_scope.h
-					//! \test zcc/decl.C99/Error_static_scope.h
-					//! \test zcc/decl.C99/Error_typedef_scope.h
-					//! \test zcc/decl.C99/Error_register_scope.h
-					//! \test zcc/decl.C99/Error_auto_scope.h
-				if (src.size<0>()>i) message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("declaration cut off by end of scope (C99 6.7p1)");
-				zcc_errors.inc_error();
-				// remove from parse
-				if (src.size<0>()>i)
-					src.DeleteNSlotsAt<0>(decl_count,i);
-				return;
-				};
-			if (robust_token_is_char<';'>(src.data<0>()[i+decl_count]))
-				{	// C99 7p2 error: must declare something
-					//! \test zcc/decl.C99/Error_extern_semicolon.h
-					//! \test zcc/decl.C99/Error_static_semicolon.h
-					//! \test zcc/decl.C99/Error_typedef_semicolon.h
-					//! \test zcc/decl.C99/Error_register_semicolon.h
-					//! \test zcc/decl.C99/Error_auto_semicolon.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("declaration must declare something (C99 6.7p2)");
-				zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(decl_count+1,i);
-				continue;
-				};
-			declFind.fixup_type();	// apply const, volatile
-
-			size_t decl_offset = 0;
-			bool have_we_parsed_yet = false;
-			do	{
-				type_spec bootstrap;
-				bootstrap.clear();
-				declFind.value_copy_type(bootstrap);
-				size_t initdecl_identifier_idx = 0;
-				size_t initdecl_span = C99_init_declarator_scanner(src,i+decl_count+decl_offset,bootstrap,initdecl_identifier_idx);
-				assert(0<initdecl_span || 0==initdecl_identifier_idx);
-				if (0==initdecl_span)
-					{	// no declarator where expected
-						// a botched function-declarator will have non-zero length
-					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("declarator missing (C99 6.7p1)");
-					zcc_errors.inc_error();
-					// find the next semicolon
-					const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
-					if (have_we_parsed_yet)
-						src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
-					else
-						src.DeleteNSlotsAt<0>((j-i)+(src.size<0>()>j),i);
-					break;
-					};
-				if (!initdecl_identifier_idx)
-					{	// didn't find identifier when needed
-					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("declarator has no identifier to declare (C99 6.7p1)");
-					zcc_errors.inc_error();
-					// find the next semicolon, unless we have () immediately in which case we have nothing to look for
-					const bool unwind_to_compound_statement = is_naked_parentheses_pair(src.data<0>()[i+decl_count+decl_offset]);
-					if (unwind_to_compound_statement)
-						{
-						assert(!have_we_parsed_yet);
-						src.DeleteNSlotsAt<0>(decl_count+decl_offset+initdecl_span,i);
-						}
-					else{
-						const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
-						if (have_we_parsed_yet)
-							src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
-						else
-							src.DeleteNSlotsAt<0>((j-i)+1,i);
-						}
-					break;
-					};
-				//! \todo analyze decl_specifiers for errors (now have full target type)
-				// something is being declared
-				have_we_parsed_yet = true;
-				if (coherent_storage_specifiers)
-					{
-					if (C99_CPP0X_DECLSPEC_TYPEDEF & declFind.get_flags())
-						{	// typedef
-						register_token<0>(src.c_array<0>()[initdecl_identifier_idx]);
-						// verify that there is no prior definition
-						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(src.data<0>()[initdecl_identifier_idx].index_tokens[0].token.first);
-						if (NULL!=tmp)
-							{
-							if (bootstrap==tmp->first)
-								{	// warn if there is a prior, consistent definition
-									//! \test zcc/decl.C99/Warn_redeclare_typedef.h
-									//! \todo control this warning with an option --no-OAOO or --no-DRY
-								message_header(src.data<0>()[initdecl_identifier_idx].index_tokens[0]);
-								INC_INFORM(WARN_STR);
-								INC_INFORM("redeclaring typedef ");
-								INFORM(src.data<0>()[initdecl_identifier_idx].index_tokens[0].token.first);
-								INC_INFORM(tmp->second);
-								INC_INFORM(':');
-								INC_INFORM(tmp->third);
-								INFORM(": prior typedef");
-								if (bool_options[boolopt::warnings_are_errors])
-									zcc_errors.inc_error();
-								}
-							else{	// error if there is a prior, inconsistent definition
-									//! \test zcc/decl.C99/Warn_redeclare_typedef.h
-								message_header(src.data<0>()[initdecl_identifier_idx].index_tokens[0]);
-								INC_INFORM(ERR_STR);
-								INC_INFORM("redeclaring typedef ");
-								INFORM(src.data<0>()[initdecl_identifier_idx].index_tokens[0].token.first);
-								INC_INFORM(tmp->second);
-								INC_INFORM(':');
-								INC_INFORM(tmp->third);
-								INFORM(": prior typedef");
-								zcc_errors.inc_error();
-								}	
-							// do not re-register if there is a prior definition
-							}
-						else{	// prepare to register this with types object
-							const type_system::enumerator_info* tmp2 = types.get_enumerator(src.data<0>()[initdecl_identifier_idx].index_tokens[0].token.first);
-							if (tmp2)
-								{	//! \bug needs test case
-								message_header(src.data<0>()[i].index_tokens[0]);
-								INC_INFORM(ERR_STR);
-//								INFORM("enumerator is already defined, conflicts with typedef (C99 6.7.2.2p3/C++98 3.2)");
-								INFORM("enumerator is already defined, conflicts with typedef (C99 6.7.2.2p3)");
-								INC_INFORM(tmp2->second.second.first);
-								INC_INFORM(":");
-								INC_INFORM(tmp2->second.second.second.first);
-								INFORM(": enumerator definition here");
-								zcc_errors.inc_error();
-								return;
-								}
-							types.set_typedef(src.data<0>()[initdecl_identifier_idx].index_tokens[0].token.first,src.data<0>()[initdecl_identifier_idx].index_tokens[0].src_filename,src.data<0>()[initdecl_identifier_idx].index_tokens[0].logical_line.first,bootstrap);
-							}
-						}
-#if 0
-					else{	// something else
-						};
-#endif
-					}
-				decl_offset += initdecl_span;
-				if (src.size<0>()-(i+decl_count)<=decl_offset)
-					{	// unterminated declaration: error
-						//! \test zcc/decl.C99/Error_scope.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("declaration cut off by end of scope (C99 6.7p1)");
-					zcc_errors.inc_error();
-					return;
-					};
-				//! \todo function declarations can be self-terminating
-				// ;: done
-				if (robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset]))
-					{
-					src.c_array<0>()[i+decl_count+decl_offset].flags |= parse_tree::GOOD_LINE_BREAK;
-					++decl_offset;
-					break;
-					};
-				// ,: iterate
-				// anything else: error
-				if (!robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset]))
-					{
-					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("declaration disoriented by missing , (C99 6.7p1)");
-					// find the next semicolon
-					size_t j = i+decl_count+decl_offset;
-					while(!robust_token_is_char<';'>(src.data<0>()[j]) && src.size<0>()> ++j);
-					src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
-					continue;
-					}
-				++decl_offset;
-				}
-			while(src.size<0>()>(i+decl_count+decl_offset));
-			i += decl_count+decl_offset;
-			continue;
-			}
-		}
-		++i;
-		}
-}
-
-#ifndef NDEBUG
-static bool is_CPP_namespace(const parse_tree& src)
-{
-	return		robust_token_is_string<9>(src.index_tokens[0].token,"namespace")
-			&&	2==src.size<2>()
-			&&	src.data<2>()[0].is_atomic()
-#ifndef NDEBUG
-			&&	C_TESTFLAG_IDENTIFIER==src.data<2>()[0].index_tokens[0].flags
-#endif
-			&&	robust_token_is_char<'{'>(src.data<2>()[1].index_tokens[0].token)
-			&&	robust_token_is_char<'}'>(src.data<2>()[1].index_tokens[1].token);
-}
-#endif
-
-// handle namespaces or else
-//! \todo check that the fact all literals are already legal-form is used
-static void CPP_ParseNamespace(parse_tree& src,type_system& types,const char* const active_namespace)
-{
-	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle
-	// * indirection depth n (already have this in practice)
-	// * const, volatile at each level of indirection 0..n
-	// * extent at each level of indirection 1..n (0 := raw-ptr, positive := array that can be bounds-checked for undefined behavior
-	// * top-level reference (check standards to see if reference-in-middle is illegal, never seen it in real source)
-	// * storage-qualifiers extern, static, register, mutable, thread_local
-	// * fake type-qualifier typedef
-	// note that typedefs and struct/union declarations/definitions create new types
-	// C++: note that class declarations/definitions create new types
-	// note that we need a sense of "current namespace" in C++
-	// ask GCC: struct/class/union/enum collides with each other (both C and C++), does not collide with namespace
-	// think we can handle this as "disallow conflicting definitions"
-	// should be able to disable this warning (it's about bloat)
-	if (src.empty<0>())
-		{	//! \test zcc\namespace.CPP\Warn_emptybody1.hpp
-			//! \test zcc\namespace.CPP\Warn_emptybody2.hpp
-			//! \todo -Wno-bloat turns off 
-		message_header(src.index_tokens[0]);
-		INC_INFORM(WARN_STR);
-		INFORM("namespace contains no declarations");
-		if (bool_options[boolopt::warnings_are_errors])
-			zcc_errors.inc_error();
-		return;
-		}
-
-	size_t i = 0;
-	while(i<src.size<0>())
-		{
-		conserve_tokens(src.c_array<0>()[i]);
-		// C++ static assertion scanner
-		if (robust_token_is_string<13>(src.data<0>()[i],"static_assert"))
-			{	// static_assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CPlusPlusLexer->pp_support,i," : control expression for static assertion must be a constant convertible to bool (C++0X 7p4)");
-			continue;
-			};
-		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
-		// check naked declarations first; handle namespaces later
-		//! \bug indentation fixup needed (stage 3)
-		if (is_C99_named_specifier(src.data<0>()[i],"union"))
-			{
-			type_system::type_index tmp = types.get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			src.c_array<0>()[i].type_code.set_type(tmp);
-			}
-		else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
-			{
-			type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			src.c_array<0>()[i].type_code.set_type(tmp);
-			}
-		else if (is_C99_named_specifier(src.data<0>()[i],"class"))
-			{
-			type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			src.c_array<0>()[i].type_code.set_type(tmp);
-			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
-			{	// can only define once
-			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-			const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_union(fullname));
-			if (tmp)
-				{	//! \test zcc/decl.C99/Error_union_multidef.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'union ");
-				INC_INFORM(fullname);
-				free(namespace_name);
-				INFORM("' already defined (C++98 3.2p1)");
-				message_header(*tmp);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				// now it's gone
-				// remove trailing semicolon if present
-				src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
-				continue;
-				}
-			free(namespace_name);
-			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
-			{	// can only define once
-			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-			const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(fullname));
-			if (tmp)
-				{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'struct ");
-				INC_INFORM(fullname);
-				free(namespace_name);
-				INFORM("' already defined (C++98 3.2p1)");
-				message_header(*tmp);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				// now it's gone
-				// remove trailing semicolon if present
-				src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
-				continue;
-				}
-			free(namespace_name);
-			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
-			{	// can only define once
-			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-			const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-			const C_union_struct_def* const tmp = types.get_C_structdef(types.get_id_struct_class(fullname));
-			if (tmp)
-				{	//! \test zcc/decl.C99/Error_class_multidef.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'class ");
-				INC_INFORM(fullname);
-				free(namespace_name);
-				INFORM("' already defined (C++98 3.2p1)");
-				message_header(*tmp);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				// now it's gone
-				// remove trailing semicolon if present
-				src.DeleteNSlotsAt<0>((1<src.size<0>()-i && robust_token_is_char<';'>(src.data<0>()[i+1])) ? 2 : 1,i);
-				continue;
-				}
-			free(namespace_name);
-			}
-		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
-		//! \todo actually, we can try forward-declare both scoped enums and enum-based enums (C++0X 7.2p3, these have enough size information); but other parts of the standard get in the way
-		else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
-			{
-			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
-				{
-				type_system::type_index tmp = types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-				src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
-				if (!tmp)
-					{	// this belongs elsewhere
-						//! \test zcc\decl.C99\Error_enum_undef.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'enum ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
-					zcc_errors.inc_error();
-					src.c_array<0>()[i].flags |= parse_tree::INVALID;
-					}
-				}
-			//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
-			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
-			{	// can only define once
-			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-			const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-			type_system::type_index tmp = types.get_id_enum(fullname);
-			if (tmp)
-				{	//! \test zcc\decl.C99\Error_enum_multidef.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'enum ");
-				INC_INFORM(fullname);
-				free(namespace_name);
-				INFORM("' already defined (C++98 3.2p1)");
-				const enum_def* const tmp2 = types.get_enum_def(tmp);
-				assert(tmp2);
-				message_header(*tmp2);
-				INFORM("prior definition here");
-				zcc_errors.inc_error();
-				// now it's gone
-				src.DeleteNSlotsAt<0>(1,i);
-				continue;
-				};
-			free(namespace_name);
-			//! \test zcc\decl.C99\Pass_enum_def.hpp
-			// enum-specifier doesn't have a specific declaration mode
-			const type_system::type_index tmp2 = types.register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			assert(types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp2,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
-				{
-				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
-				return;
-				}
-			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
-			{	// enum-specifier doesn't have a specific declaration mode
-				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = types.register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
-				{
-				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
-				return;
-				}
-			}
-
-		if (	1<src.size<0>()-i
-			&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
-			{	// is_C99_named_specifier(src.data<0>()[i],"enum") will cause an error later, in variable parsing
-			if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous union declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous struct declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			else if (is_C99_anonymous_specifier(src.data<0>()[i],"class"))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous class declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			else if (is_C99_named_specifier(src.data<0>()[i],"union"))
-				{	// forward-declare, fine
-				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-				if (types.get_id_union(fullname))
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-					// remove from parse
-					free(namespace_name);
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;					
-					}
-				free(namespace_name);
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				//! \todo fix up fully-qualified name
-				const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
-				{	// forward-declare, fine
-				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-				if (types.get_id_struct_class(fullname))
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-					// remove from parse
-					free(namespace_name);
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;					
-					}
-				free(namespace_name);
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				//! \todo fix up fully-qualified name
-				const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier(src.data<0>()[i],"class"))
-				{	// forward-declare, fine
-				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-				if (types.get_id_struct_class(fullname))
-					{	// but if already (forward-)declared then this is a no-op
-						// think this is common enough to not warrant OAOO/DRY treatment
-					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-					// remove from parse
-					free(namespace_name);
-					src.DeleteNSlotsAt<0>(2,i);
-					continue;					
-					}
-				free(namespace_name);
-				// forward-declare
-				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				//! \todo fix up fully-qualified name
-				const type_system::type_index tmp2 = types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
-				{	// definitions...fine
-				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-				const type_system::type_index tmp = types.get_id_union(fullname);
-				free(namespace_name);
-				C_union_struct_def* tmp2 = NULL;
-				if (tmp)
-					{	// promoting forward-declare to definition
-						//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-					assert(tmp3);
-					tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-					//! \todo record field structure, etc.
-					types.upgrade_decl_to_def(tmp,tmp2);
-					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp);
-					assert(types.get_C_structdef(tmp));
-					}
-				else{	// definition
-						//! \test zcc/decl.C99/Pass_union_def.hpp
-					//! \todo record field structure, etc.
-					const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_union);
-					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-					assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
-					assert(types.get_C_structdef(tmp3));
-					src.c_array<0>()[i].type_code.set_type(tmp3);
-					}
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
-				{	// definitions...fine
-				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-				const type_system::type_index tmp = types.get_id_struct_class(fullname);
-				free(namespace_name);
-				C_union_struct_def* tmp2 = NULL;
-				if (tmp)
-					{	// promoting forward-declare to definition
-						//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-					assert(tmp3);
-					tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-					//! \todo record field structure, etc.
-					types.upgrade_decl_to_def(tmp,tmp2);
-					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp);
-					assert(types.get_C_structdef(tmp));
-					}
-				else{	// definition
-						//! \test zcc/decl.C99/Pass_struct_def.hpp
-					//! \todo record field structure, etc.
-					const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_struct);
-					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
-					assert(types.get_C_structdef(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)));
-					src.c_array<0>()[i].type_code.set_type(tmp3);
-					}
-				i += 2;
-				continue;
-				}
-			else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
-				{	// definitions...fine
-				char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-				const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-				const type_system::type_index tmp = types.get_id_struct_class(fullname);
-				free(namespace_name);
-				C_union_struct_def* tmp2 = NULL;
-				if (tmp)
-					{	// promoting forward-declare to definition
-						//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-					const union_struct_decl* tmp3 = types.get_structdecl(tmp);
-					assert(tmp3);
-					tmp2 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-					//! \todo record field structure, etc.
-					types.upgrade_decl_to_def(tmp,tmp2);
-					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp);
-					assert(types.get_C_structdef(tmp));
-					}
-				else{	// definition
-						//! \test zcc/decl.C99/Pass_class_def.hpp
-					//! \todo record field structure, etc.
-					const type_system::type_index tmp3 = types.register_C_structdef(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename,union_struct_decl::decl_class);
-					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-					assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp3);
-					assert(types.get_C_structdef(tmp3));
-					src.c_array<0>()[i].type_code.set_type(tmp3);
-					}
-				i += 2;
-				continue;
-				};
-			};
-		// namespace scanner
-		// need some scheme to handle unnamed namespaces (probably alphabetical counter after something illegal so unmatchable)
-		// C++0X has inline namespaces; ignore these for now (well, maybe not: consuming the inline will prevent problems)
-		// C++0X has more complicated using namespace directives: ignore these for now
-		// basic namespace; C++98 and C++0X agree on what this is
-		if (robust_token_is_string<9>(src.data<0>()[i],"namespace"))
-			{	// fail if: end of token stream
-				// fail if: next token is a type
-				// accept if: next token is {} (unnamed namespace)
-				// accept if: next token is an identifier, and the token after that is {} (typical namespace)
-				// fail otherwise
-			if (1>=src.size<0>()-i)
-				{	//! \test zcc\namespace.CPP\Error_premature1.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("namespace declaration cut off by end of scope");
-				zcc_errors.inc_error();
-				src.DeleteIdx<0>(i);
-				break;
-				};
-			if (	robust_token_is_char<'{'>(src.data<0>()[i+1].index_tokens[0].token)
-				&&	robust_token_is_char<'}'>(src.data<0>()[i+1].index_tokens[1].token))
-				{	//! handle unnamed namespace
-					//! \test zcc\namespace.CPP\Warn_emptybody2.hpp
-					// regardless of official linkage, entities in anonymous namespaces aren't very accessible outside of the current translation unit;
-					// any reasonable linker thinks they have static linkage
-				src.c_array<0>()[i].resize<2>(2);
-				src.c_array<0>()[i].c_array<2>()[1] = src.data<0>()[i+1];
-				src.c_array<0>()[i+1].clear();
-				src.DeleteIdx<0>(i+1);
-
-				// anonymous namespace names are technically illegal
-				// GCC uses <unknown> and handles uniqueness at link time
-				src.c_array<0>()[i].c_array<2>()[0].grab_index_token_from_str_literal<0>("<unknown>",C_TESTFLAG_IDENTIFIER);	// pretend it's an identifier
-				src.c_array<0>()[i].c_array<2>()[0].grab_index_token_location_from<0,0>(src.data<0>()[i].data<2>()[1]);	// inject it at where the namespace body starts
-				src.c_array<0>()[i].flags |= parse_tree::GOOD_LINE_BREAK;
-				assert(is_CPP_namespace(src.data<0>()[i]));
-
-				if (active_namespace)
-					{
-					char* new_active_namespace = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(strlen(active_namespace)+11 /*sizeof("::<unknown>")-1*/));
-					strcpy(new_active_namespace,active_namespace);
-					strcat(new_active_namespace,"::<unknown>");
-					strcat(new_active_namespace,"");
-					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[1],types,new_active_namespace);
-					free(new_active_namespace);
-					}
-				else{
-					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[1],types,"<unknown>");
-					}
-				++i;
-				continue;
-				}
-			const bool namespace_has_body = (	3<=src.size<0>()-i
-											&&	robust_token_is_char<'{'>(src.data<0>()[i+2].index_tokens[0].token)
-											&&	robust_token_is_char<'}'>(src.data<0>()[i+2].index_tokens[1].token));
-			// next token must be an atomic identifier
-			// already-parsed primary types are no good, neither are reserved keywords
-			if (	!src.data<0>()[i+1].is_atomic()
-				|| 	!(C_TESTFLAG_IDENTIFIER & src.data<0>()[i+1].index_tokens[0].flags)
-				||	(PARSE_TYPE & src.data<0>()[i+1].flags)
-				||	CPP_echo_reserved_keyword(src.data<0>()[i+1].index_tokens[0].token.first,src.data<0>()[i+1].index_tokens[0].token.second))
-				{	//! \test zcc/namespace.CPP/Error_badname1.hpp
-					//! \test zcc/namespace.CPP/Error_badname2.hpp
-					//! \test zcc/namespace.CPP/Error_badname3.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("named namespace declaration must use non-reserved identifier (C++98 7.3.1p1, 7.3.2p1)");
-				zcc_errors.inc_error();
-				src.DeleteNSlotsAt<0>(2+namespace_has_body,i);
-				continue;
-				};
-			if (!namespace_has_body)
-				{	//! \test zcc\namespace.CPP\Error_premature2.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("'namespace ");
-				INC_INFORM(src.data<0>()[i+1]);
-				INFORM("' definition needs a body (C++98 7.3.1p1)");
-				zcc_errors.inc_error();
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				};
-			//! \test zcc\namespace.CPP\Warn_emptybody1.hpp
-			// process namespace
-			// namespace name: postfix arg 1
-			// namespace definition body: postfix arg 2
-			// the namespace name is likely to be reused: atomic string target
-			register_token<0>(src.c_array<0>()[i+1]);
-			src.c_array<0>()[i].resize<2>(2);
-			src.c_array<0>()[i].c_array<2>()[0] = src.data<0>()[i+1];
-			src.c_array<0>()[i].c_array<2>()[1] = src.data<0>()[i+2];
-			src.c_array<0>()[i+1].clear();
-			src.c_array<0>()[i+2].clear();
-			src.DeleteNSlotsAt<0>(2,i+1);
-			src.c_array<0>()[i].flags |= parse_tree::GOOD_LINE_BREAK;
-			assert(is_CPP_namespace(src.data<0>()[i]));
-			// handle named namespace
-			if (NULL==active_namespace)
-				{	// global
-					//! \todo expand namespace aliases
-				CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[1],types,src.c_array<0>()[i].c_array<2>()[0].index_tokens[0].token.first);
-				}
-			else{	// nested
-					//! \todo expand namespace aliases
-				char* const new_active_namespace = type_system::namespace_concatenate(src.c_array<0>()[i].c_array<2>()[0].index_tokens[0].token.first,active_namespace,"::");
-				CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[1],types,new_active_namespace);
-				free(new_active_namespace);
-				}
-			++i;
-			continue;
-			};
-		// C++0X also has inline namespaces; all anonymous namespaces are already inline
-		// general declaration scanner (have to catch C++0X inline namespaces first when those come up)
-		// ideally would cope with both C++98 and C++0X
-		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
-		// intercept declarations as follows
-		// * storage-class specifiers
-		// ** C++98: auto register static extern mutable [class-data only]
-		// ** C++0x: register static thread_local extern mutable [class-data only]
-		// ** C: taking address of a register-qualified var is an error; not so for C++ (just downgrades register to auto implicitly)
-		// * typedef (pretty much a fake storage-class specifier)
-		// * C++0X: constexpr
-		// * function specifiers
-		// ** C++: inline virtual [nonstatic class-member-function only] explicit [constructors only]
-		// * C++: friend (inside class declaration only)
-		// * cv-qualification
-		// ** C++: const volatile
-		// * atomic types have already been parsed, we need to catch the others
-		// * C++0x: auto is a possible type!
-		{
-		CPP0X_decl_specifier_scanner declFind(types,active_namespace);
-		size_t decl_count = src.destructive_get_span<0>(i,declFind);
-		if (decl_count)
-			{
-			const bool coherent_storage_specifiers = declFind.analyze_flags_global(src,i,decl_count);
-			if (src.size<0>()-i<=decl_count)
-				{	// unterminated declaration
-					//! \test zcc/decl.C99/Error_extern_scope.hpp
-					//! \test zcc/decl.C99/Error_static_scope.hpp
-					//! \test zcc/decl.C99/Error_typedef_scope.hpp
-					//! \test zcc/decl.C99/Error_register_scope.hpp
-					//! \test zcc/decl.C99/Error_mutable_scope.hpp
-					//! \test zcc/decl.C99/Error_virtual_scope.hpp
-					//! \test zcc/decl.C99/Error_friend_scope.hpp
-					//! \test zcc/decl.C99/Error_explicit_scope.hpp
-				if (src.size<0>()>i) message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("declaration cut off by end of scope (C++98 7p1)");
-				zcc_errors.inc_error();
-				// remove from parse
-				if (src.size<0>()>i)
-					src.DeleteNSlotsAt<0>(decl_count,i);
-				return;
-				};
-			if (robust_token_is_char<';'>(src.data<0>()[i+decl_count]))
-				{	// must declare something
-					//! \test zcc/decl.C99/Error_extern_semicolon.hpp
-					//! \test zcc/decl.C99/Error_static_semicolon.hpp
-					//! \test zcc/decl.C99/Error_typedef_semicolon.hpp
-					//! \test zcc/decl.C99/Error_register_semicolon.hpp
-					//! \test zcc/decl.C99/Error_mutable_semicolon.hpp
-					//! \test zcc/decl.C99/Error_virtual_semicolon.hpp
-					//! \test zcc/decl.C99/Error_friend_semicolon.hpp
-					//! \test zcc/decl.C99/Error_explicit_semicolon.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("declaration must declare something (C++98 7p4)");
-				zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(decl_count+1,i);
-				continue;
-				};
-			declFind.fixup_type();	// apply const, volatile
-
-			size_t decl_offset = 0;
-			bool have_we_parsed_yet = false;
-			do	{
-				type_spec bootstrap;
-				bootstrap.clear();
-				declFind.value_copy_type(bootstrap);
-				size_t initdecl_identifier_idx = 0;
-				size_t initdecl_span = CPP_init_declarator_scanner(src,i+decl_count+decl_offset,bootstrap,initdecl_identifier_idx);
-				assert(0<initdecl_span || 0==initdecl_identifier_idx);
-				if (0==initdecl_span)
-					{	// no declarator where expected
-						// a botched function-declarator will have non-zero length
-					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("declarator missing (C++98 7p1)");
-					zcc_errors.inc_error();
-					// find the next semicolon
-					const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
-					if (have_we_parsed_yet)
-						src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
-					else
-						src.DeleteNSlotsAt<0>((j-i)+(src.size<0>()>j),i);
-					break;
-					};
-				if (!initdecl_identifier_idx)
-					{	// didn't find identifier when needed
-					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("declarator has no name to declare (C++98 7p1)");
-					zcc_errors.inc_error();
-					// find the next semicolon, unless we have () immediately in which case we have nothing to look for
-					const bool unwind_to_compound_statement = is_naked_parentheses_pair(src.data<0>()[i+decl_count+decl_offset]);
-					if (unwind_to_compound_statement)
-						{
-						assert(!have_we_parsed_yet);
-						src.DeleteNSlotsAt<0>(decl_count+decl_offset+initdecl_span,i);
-						}
-					else{
-						const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
-						if (have_we_parsed_yet)
-							src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
-						else
-							src.DeleteNSlotsAt<0>((j-i)+1,i);
-						}
-					break;
-					};
-				//! \todo analyze decl_specifiers for errors (now have full target type)
-				// something is being declared
-				have_we_parsed_yet = true;
-				if (coherent_storage_specifiers)
-					{
-					if (C99_CPP0X_DECLSPEC_TYPEDEF & declFind.get_flags())
-						{	// typedef
-						register_token<0>(src.c_array<0>()[initdecl_identifier_idx]);
-						char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.c_array<0>()[initdecl_identifier_idx].index_tokens[0].token.first,active_namespace,"::") : NULL;
-						const char* fullname = namespace_name ? namespace_name : src.c_array<0>()[initdecl_identifier_idx].index_tokens[0].token.first;
-						// We could run an is_string_registered check to try to conserve RAM, but in this case conserving RAM 
-						// doesn't actually reduce maximum RAM loading before the types.set_typedef_CPP call.
-
-						// verify that there is no prior definition
-						// we're fine redeclaring at a different level, so do not use full C++ typedef lookup
-						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(fullname);					
-						if (NULL!=tmp)
-							{
-							if (bootstrap==tmp->first)
-								{	// warn if there is a prior, consistent definition
-									//! \test zcc/decl.C99/Warn_redeclare_typedef.hpp
-									//! \todo control this warning with an option --no-OAOO or --no-DRY
-								message_header(src.data<0>()[initdecl_identifier_idx].index_tokens[0]);
-								INC_INFORM(WARN_STR);
-								INC_INFORM("redeclaring typedef ");
-								INFORM(fullname);
-								INC_INFORM(tmp->second);
-								INC_INFORM(':');
-								INC_INFORM(tmp->third);
-								INFORM(": prior typedef");
-								if (bool_options[boolopt::warnings_are_errors])
-									zcc_errors.inc_error();
-								}
-							else{	// error if there is a prior, inconsistent definition
-									//! \test zcc/decl.C99/Error_redeclare_typedef.hpp
-								message_header(src.data<0>()[initdecl_identifier_idx].index_tokens[0]);
-								INC_INFORM(ERR_STR);
-								INC_INFORM("redeclaring typedef ");
-								INFORM(fullname);
-								INC_INFORM(tmp->second);
-								INC_INFORM(':');
-								INC_INFORM(tmp->third);
-								INFORM(": prior typedef");
-								zcc_errors.inc_error();
-								}
-							// do not re-register if there is a prior definition
-							free(namespace_name);
-							}
-						else{	// register this with types object
-							free(namespace_name);
-							const type_system::enumerator_info* tmp2 = types.get_enumerator_CPP(src.data<0>()[initdecl_identifier_idx].index_tokens[0].token.first,active_namespace);
-							if (tmp2)
-								{	//! \bug needs test case
-								message_header(src.data<0>()[i].index_tokens[0]);
-								INC_INFORM(ERR_STR);
-								INFORM("enumerator is already defined, conflicts with typedef (C++98 3.2)");
-								INC_INFORM(tmp2->second.second.first);
-								INC_INFORM(":");
-								INC_INFORM(tmp2->second.second.second.first);
-								INFORM(": enumerator definition here");
-								zcc_errors.inc_error();
-								return;
-								}							
-							types.set_typedef_CPP(src.c_array<0>()[initdecl_identifier_idx].index_tokens[0].token.first,active_namespace,src.data<0>()[initdecl_identifier_idx].index_tokens[0].src_filename,src.data<0>()[initdecl_identifier_idx].index_tokens[0].logical_line.first,bootstrap);
-							}
-						}
-#if 0
-					else{	// something else
-						};
-#endif
-					};
-				decl_offset += initdecl_span;
-				if (src.size<0>()-(i+decl_count)<=decl_offset)
-					{	// unterminated declaration: error
-						//! \test zcc/decl.C99/Error_scope.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("declaration cut off by end of scope (C++98 7p1)");
-					zcc_errors.inc_error();
-					return;
-					};
-				//! \todo function declarations can be self-terminating
-				// ;: done
-				if (robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset]))
-					{
-					src.c_array<0>()[i+decl_count+decl_offset].flags |= parse_tree::GOOD_LINE_BREAK;
-					++decl_offset;
-					break;
-					};
-				// ,: iterate
-				// anything else: error
-				if (!robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset]))
-					{
-					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("declaration disoriented by missing , (C++98 7p1)");
-					// find the next semicolon
-					const size_t span = span_to_semicolon(src.begin<0>()+(i+decl_count+decl_offset),src.end<0>());
-					src.DeleteNSlotsAt<0>(span,i+decl_count+decl_offset);
-					continue;
-					}
-				++decl_offset;
-				}
-			while(src.size<0>()>(i+decl_count+decl_offset));
-			i += decl_count+decl_offset;
-			continue;
-			}
-		}
-		++i;
-		}
-}
-
-static void CPP_ContextParse(parse_tree& src,type_system& types)
-{
-	CPP_ParseNamespace(src,types,NULL);
-}
-
 PP_auxfunc C99_aux
  = 	{
 	LengthOfCSystemHeader,
@@ -12143,12 +10239,6 @@
 	C99_PPHackTree,
 	ConcatenateCStringLiterals,
 	C99_bad_syntax_tokenized,
-	C99_echo_reserved_keyword,
-	C99_echo_reserved_symbol,
-	C99_ContextFreeParse,
-	C99_ContextParse,
-	C99_locate_expressions,
-	C99_literal_converts_to_bool
 	};
 
 PP_auxfunc CPlusPlus_aux
@@ -12164,12 +10254,6 @@
 	CPP_PPHackTree,
 	ConcatenateCStringLiterals,
 	CPP_bad_syntax_tokenized,
-	CPP_echo_reserved_keyword,
-	CPP_echo_reserved_symbol,
-	CPP_ContextFreeParse,
-	CPP_ContextParse,
-	CPP_locate_expressions,
-	CPP_literal_converts_to_bool
 	};
 
 #if 0

Modified: trunk/CSupport_pp.hpp
===================================================================
--- trunk/CSupport_pp.hpp	2010-03-03 21:57:11 UTC (rev 340)
+++ trunk/CSupport_pp.hpp	2010-03-04 02:54:34 UTC (rev 341)
@@ -115,14 +115,6 @@
 	func_traits<int (*)(const char* src, size_t src_len, const char* src2, size_t src2_len, char*& target)>::function_ref_type EscapedStringConcatenate;
 	// z_cpp 0.0.2
 	func_traits<void (*)(const char* const x, size_t x_len, lex_flags& flags, const char* const src_filename, size_t line_no)>::function_ref_type AddPostLexFlags;
-	// zcc 0.0.2
-	func_traits<const char* (*)(const char* x,size_t x_len)>::function_ref_type EchoReservedKeyword;
-	func_traits<const char* (*)(const char* x,size_t x_len)>::function_ref_type EchoReservedSymbol;
-	func_traits<void (*)(parse_tree&,const type_system&)>::function_ref_type ContextFreeParse;		// return true iff no errors
-	func_traits<void (*)(parse_tree&,type_system&)>::function_ref_type ContextParse;		// return true iff no errors
-	// zcc 0.0.3
-	func_traits<void (*)(parse_tree&,const size_t,const type_system&)>::function_ref_type LocateExpression;
-	func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type LiteralConvertsToBool;
 };
 
 }



From zaimoni at mail.berlios.de  Fri Mar  5 21:31:56 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 5 Mar 2010 21:31:56 +0100
Subject: [Zcplusplus-commits] r342 - in trunk: . tools
Message-ID: <201003052031.o25KVuCU031109@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-05 21:31:49 +0100 (Fri, 05 Mar 2010)
New Revision: 342

Added:
   trunk/tools/suppress_cut.py
Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/tools/selective_cut.py
Log:
#include cleanup; add suppress_cut.py

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-04 02:54:34 UTC (rev 341)
+++ trunk/CSupport.cpp	2010-03-05 20:31:49 UTC (rev 342)
@@ -2,7 +2,10 @@
 // support for C/C++ parsing
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
+#/*cut-cpp*/
 #include "CSupport.hpp"
+#/*cut-cpp*/
+#include "CSupport_pp.hpp"
 #include "_CSupport1.hpp"
 #include "_CSupport2.hpp"
 
@@ -26,8 +29,10 @@
 #include "C_PPOctalInteger.hpp"
 #include "C_PPDecimalFloat.hpp"
 #include "C_PPHexFloat.hpp"
+#/*cut-cpp*/
 #include "enum_type.hpp"
 #include "struct_type.hpp"
+#/*cut-cpp*/
 #include "CheckReturn.hpp"
 
 using namespace zaimoni;

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-04 02:54:34 UTC (rev 341)
+++ trunk/CSupport_pp.cpp	2010-03-05 20:31:49 UTC (rev 342)
@@ -26,8 +26,6 @@
 #include "C_PPOctalInteger.hpp"
 #include "C_PPDecimalFloat.hpp"
 #include "C_PPHexFloat.hpp"
-#include "enum_type.hpp"
-#include "struct_type.hpp"
 #include "CheckReturn.hpp"
 
 using namespace zaimoni;

Modified: trunk/tools/selective_cut.py
===================================================================
--- trunk/tools/selective_cut.py	2010-03-04 02:54:34 UTC (rev 341)
+++ trunk/tools/selective_cut.py	2010-03-05 20:31:49 UTC (rev 342)
@@ -12,6 +12,8 @@
 # a null preprocessing directive which is removed by the preprocessor.
 #   Languages with native shell comments just treat these lines as comments
 
+# flip-side: suppress_cut.py, which just suppresses these comments.
+
 def SelectiveCut(cut_id,srcfile,destfile):
 	test_lines = []
 	old_line_ok = 1
@@ -32,7 +34,7 @@
 	# online help
 	if 4!=len(argv):
 		print "Usage: cut_id srcfile destfile"
-		print "\texcises text lines contained between #cut-cut_id comments"
+		print "\texcises text lines contained between #/*cut-cut_id*/ comments"
 		exit(0)
 
 	SelectiveCut(argv[1],argv[2],argv[3])

Added: trunk/tools/suppress_cut.py
===================================================================
--- trunk/tools/suppress_cut.py	2010-03-04 02:54:34 UTC (rev 341)
+++ trunk/tools/suppress_cut.py	2010-03-05 20:31:49 UTC (rev 342)
@@ -0,0 +1,36 @@
+#!/usr/bin/python
+# designed for Python 2.6, may work with other versions
+# (C)2010 Kenneth Boyd, license: MIT.txt
+
+from sys import argv,exit;
+
+# this suppresses the comments used by selective_cut.py
+
+#   This is inspired by Perl's Plain Old Documentation format, but 
+# works generically with languages that use shell one-line comments
+# (e.g.: Python, Perl, PHP, Ruby, C/C++
+#   Idea is that lines #/* cut-cut_id */ act like =cut in Perl.
+#   C,C++ are fine because the C-comment becomes whitespace, leaving behind 
+# a null preprocessing directive which is removed by the preprocessor.
+#   Languages with native shell comments just treat these lines as comments
+
+def SuppressCut(cut_id,srcfile,destfile):
+	test_lines = []
+	TargetFile = open(destfile,'w')	# *.sh
+	with open(srcfile,'r') as f:
+		for line in f:
+			line_proxy = line.strip()
+			if line_proxy!='#/*cut-'+cut_id+'*/':
+				TargetFile.write(line)
+	TargetFile.close()
+
+
+if __name__ == '__main__':
+	# online help
+	if 4!=len(argv):
+		print "Usage: cut_id srcfile destfile"
+		print "\texcises #/*cut-cut_id*/ comments"
+		exit(0)
+
+	SuppressCut(argv[1],argv[2],argv[3])
+



From zaimoni at mail.berlios.de  Fri Mar  5 21:32:48 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 5 Mar 2010 21:32:48 +0100
Subject: [Zcplusplus-commits] r343 - trunk
Message-ID: <201003052032.o25KWmdg031149@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-05 21:32:43 +0100 (Fri, 05 Mar 2010)
New Revision: 343

Added:
   trunk/type_system_pp.cpp
   trunk/type_system_pp.hpp
Log:
fork type_system for simplifying z_cpp

Copied: trunk/type_system_pp.cpp (from rev 329, trunk/type_system.cpp)

Copied: trunk/type_system_pp.hpp (from rev 329, trunk/type_system.hpp)



From zaimoni at mail.berlios.de  Sun Mar  7 04:11:27 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 7 Mar 2010 04:11:27 +0100
Subject: [Zcplusplus-commits] r344 - trunk
Message-ID: <201003070311.o273BRhL004669@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-07 04:11:18 +0100 (Sun, 07 Mar 2010)
New Revision: 344

Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc_autogen.cpp
   trunk/CSupport_pp.hpp
   trunk/type_system.cpp
   trunk/type_system.hpp
   trunk/type_system_pp.cpp
   trunk/type_system_pp.hpp
Log:
strip type_system for z_cpp.exe

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2010-03-05 20:32:43 UTC (rev 343)
+++ trunk/CPreproc.cpp	2010-03-07 03:11:18 UTC (rev 344)
@@ -1,7 +1,10 @@
 // CPreproc.cpp
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
+#/*cut-cpp*/
 #include "CPreproc.hpp"
+#/*cut-cpp*/
+#include "CPreproc_pp.hpp"
 
 #include <limits.h>
 #include <time.h>
@@ -9,7 +12,10 @@
 #include <unistd.h>
 
 #include "AtomicString.h"
+#/*cut-cpp*/
 #include "CSupport.hpp"
+#/*cut-cpp*/
+#include "CSupport_pp.hpp"
 #include "C_PPDecimalInteger.hpp"
 #include "CPUInfo.hpp"
 #include "errors.hpp"

Modified: trunk/CPreproc_autogen.cpp
===================================================================
--- trunk/CPreproc_autogen.cpp	2010-03-05 20:32:43 UTC (rev 343)
+++ trunk/CPreproc_autogen.cpp	2010-03-07 03:11:18 UTC (rev 344)
@@ -2,7 +2,10 @@
 // (C)2009,2010 Kenneth Boyd, license: MIT.txt
 // class CPreprocessor support for autogenerating headers for arbitrary machine targets.
 
+#/*cut-cpp*/
 #include "CPreproc.hpp"
+#/*cut-cpp*/
+#include "CPreproc_pp.hpp"
 #include "CPUInfo.hpp"
 #include "errors.hpp"
 #include "Zaimoni.STL/POD.hpp"

Modified: trunk/CSupport_pp.hpp
===================================================================
--- trunk/CSupport_pp.hpp	2010-03-05 20:32:43 UTC (rev 343)
+++ trunk/CSupport_pp.hpp	2010-03-07 03:11:18 UTC (rev 344)
@@ -1,4 +1,4 @@
-// CSupport_pp.hpp
+// CSupport.hpp
 // support for C/C++ language parsing
 // (C)2009 Kenneth Boyd, license: MIT.txt
 

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2010-03-05 20:32:43 UTC (rev 343)
+++ trunk/type_system.cpp	2010-03-07 03:11:18 UTC (rev 344)
@@ -1,7 +1,10 @@
 // type_system.cpp
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
+#/*cut-cpp*/
 #include "type_system.hpp"
+#/*cut-cpp*/
+#include "type_system_pp.hpp"
 #include "enum_type.hpp"
 #include "struct_type.hpp"
 #include "Zaimoni.STL/search.hpp"
@@ -14,6 +17,7 @@
 #define DYNAMIC_STRUCTDECL 2
 #define DYNAMIC_C_STRUCTDEF 3
 #define DYNAMIC_ENUMDEF 4
+#/*cut-cpp*/
 
 type_system::type_index type_system::_get_id_union(const char* const x) const
 {
@@ -267,6 +271,7 @@
 		}
 	return _get_id_enum_CPP(alias);
 }
+#/*cut-cpp*/
 
 const char* type_system::_name(size_t id) const
 {
@@ -276,6 +281,7 @@
 		return dynamic_types[id].first;
 	return "(?)";
 }
+#/*cut-cpp*/
 
 // implement C/C++ typedef system
 void type_system::set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec& src)
@@ -851,4 +857,5 @@
 	tmp.third.first.third = src;
 	src = NULL;
 }
+#/*cut-cpp*/
 

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2010-03-05 20:32:43 UTC (rev 343)
+++ trunk/type_system.hpp	2010-03-07 03:11:18 UTC (rev 344)
@@ -28,10 +28,12 @@
 private:
 	typedef zaimoni::POD_triple<const char*,size_t,zaimoni::POD_pair<zaimoni::union_quartet<function_type*,union_struct_decl*,C_union_struct_def*,enum_def*>, unsigned char> > dynamic_type_format;
 	zaimoni::autovalarray_ptr<dynamic_type_format> dynamic_types;
+#/*cut-cpp*/
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> > > typedef_registry;
 	zaimoni::weakautovalarray_ptr<const char*> inline_namespace_alias_targets;
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,const char*> > inline_namespace_alias_map;
 	zaimoni::autovalarray_ptr<enumerator_info> enumerator_registry;
+#/*cut-cpp*/
 	// uncopyable
 	type_system(const type_system& src);
 	void operator=(const type_system& src);
@@ -42,6 +44,7 @@
 		core_types_size((assert(0<_core_types_size),_core_types_size)),
 		int_priority_size((assert(0<_int_priority_size),_int_priority_size)) {};
 
+#/*cut-cpp*/
 	type_index get_id_union(const char* x) const
 		{
 		assert(x && *x);
@@ -60,14 +63,16 @@
 		return _get_id_enum(x);
 		}
 	type_index get_id_enum_CPP(const char* alias,const char* active_namespace) const;
+#/*cut-cpp*/
 	const char* name(type_index id) const
 		{
 		assert(core_types_size+dynamic_types.size()>=id);
 		return _name(id);
 		}
+#/*cut-cpp*/
 
 	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
-	// defer seven other variants for now (YAGNI)
+	// defer five other variants for now (YAGNI)
 	static char* namespace_concatenate(const char* const name, const char* const active_namespace,const char* namespace_separator)
 		{
 		assert(name && *name);
@@ -75,8 +80,6 @@
 		assert(namespace_separator && *namespace_separator);
 		return _namespace_concatenate(name,strlen(name),active_namespace,strlen(active_namespace),namespace_separator,strlen(namespace_separator));
 		};
-
-	// defer six other variants for now (YAGNI)
 	static void namespace_concatenate(char* buf, const char* const name, const char* const active_namespace,const char* namespace_separator)
 		{
 		assert(buf);
@@ -95,7 +98,6 @@
 		_namespace_concatenate(buf,name,strlen(name),active_namespace,active_namespace_len,namespace_separator,strlen(namespace_separator));
 		};
 
-
 	void set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec& src);	// invalidates src
 	void set_typedef_CPP(const char* const name, const char* const active_namespace, const char* filename, const size_t lineno, type_spec& src);	// invalidates src
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* get_typedef(const char* const alias) const;
@@ -120,7 +122,9 @@
 	const C_union_struct_def* get_C_structdef(type_index i);
 	const enum_def* get_enum_def(type_index i);
 	void upgrade_decl_to_def(type_index i,C_union_struct_def*& src);
+#/*cut-cpp*/
 private:
+#/*cut-cpp*/
 	type_index _get_id_union(const char* x) const;
 	type_index _get_id_union_CPP(const char* x) const;
 	type_index _get_id_enum(const char* x) const;
@@ -128,11 +132,12 @@
 	type_index _get_id_struct_class(const char* x) const;
 	type_index _get_id_struct_class_CPP(const char* x) const;
 
+#/*cut-cpp*/
 	const char* _name(type_index id) const;
+#/*cut-cpp*/
 	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> dealias_inline_namespace_index(const char* alias) const;
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* _get_typedef_CPP(const char* alias) const;
 	const enumerator_info* _get_enumerator_CPP(const char* alias) const;
-
 	bool is_inline_namespace_CPP(const char* active_namespace, size_t active_namespace_len) const;
 	const char* canonical_name_is_inline_namespace_alias_target(const char* name, size_t name_len, const char* active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len) const;
 	const char* construct_canonical_name_and_aliasing_CPP(const char* name, size_t name_len, const char* active_namespace, size_t active_namespace_len);
@@ -140,5 +145,6 @@
 	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
 	static char* _namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
 	static void _namespace_concatenate(char* buf, const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
+#/*cut-cpp*/
 };
 #endif

Modified: trunk/type_system_pp.cpp
===================================================================
--- trunk/type_system_pp.cpp	2010-03-05 20:32:43 UTC (rev 343)
+++ trunk/type_system_pp.cpp	2010-03-07 03:11:18 UTC (rev 344)
@@ -1,7 +1,7 @@
-// type_system.cpp
+// type_system_pp.cpp
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
-#include "type_system.hpp"
+#include "type_system_pp.hpp"
 #include "enum_type.hpp"
 #include "struct_type.hpp"
 #include "Zaimoni.STL/search.hpp"
@@ -15,259 +15,6 @@
 #define DYNAMIC_C_STRUCTDEF 3
 #define DYNAMIC_ENUMDEF 4
 
-type_system::type_index type_system::_get_id_union(const char* const x) const
-{
-	const size_t x_len = strlen(x);
-	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
-	while(0<=tmp)
-		{
-		if (DYNAMIC_STRUCTDECL==dynamic_types[tmp].third.second)
-			{
-			if (union_struct_decl::decl_union==dynamic_types[tmp].third.first.second->keyword())
-				return tmp+1+core_types_size;
-			return 0;
-			};
-		if (DYNAMIC_C_STRUCTDEF==dynamic_types[tmp].third.second)
-			{
-			if (union_struct_decl::decl_union==dynamic_types[tmp].third.first.third->_decl.keyword())
-				return tmp+1+core_types_size;
-			return 0;
-			}
-		// in a different tag space...retry
-		if (1>=dynamic_types.size()-tmp) break;
-		errr tmp2 = linear_find_lencached(x,x_len,dynamic_types.data()+tmp+1,dynamic_types.size()-(tmp+1));
-		if (0>tmp2) break;
-		tmp += 1+tmp2;
-		}
-	return 0;
-}
-
-type_system::type_index
-type_system::_get_id_union_CPP(const char* const x) const
-{
-	errr tmp = _get_id_union(x);
-	if (0<tmp) return tmp;
-
-	// hmm...not an exact match
-	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(x);
-	if (0>tmp2.first) return 0;
-
-	// it was remapped
-	while(tmp2.first<tmp2.second)
-		{
-		tmp = _get_id_union(inline_namespace_alias_map.data()[tmp2.first].second);
-		if (0<tmp) return tmp;
-		++tmp2.first;
-		}
-	return _get_id_union(inline_namespace_alias_map.data()[tmp2.first].second);
-}
-
-type_system::type_index
-type_system::get_id_union_CPP(const char* alias,const char* active_namespace) const
-{
-	assert(alias && *alias);
-
-	if (!strncmp(alias,"::",2))
-		{	// fully-qualified
-		// pretend not fully qualified, but no surrounding namespace
-		alias += 2;
-		active_namespace = NULL;
-		};
-	if (active_namespace && *active_namespace)
-		{
-		// ok..march up to global
-		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
-		if (is_string_registered(tmp_alias))
-			{	// registered, so could be indexed
-			const type_index tmp2 = _get_id_union_CPP(tmp_alias);
-			if (tmp2) return (free(tmp_alias),tmp2);
-			}
-
-		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
-		if (extra_namespaces)
-			{
-			zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
-			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
-			size_t i = extra_namespaces;
-			do	{
-				--i;
-				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,"::");
-				const type_index tmp2 = _get_id_union_CPP(tmp_alias);
-				if (tmp2) return (free(tmp_alias),tmp2);
-				}
-			while(0<i);
-			}
-		free(tmp_alias);
-		}
-	return _get_id_union_CPP(alias);
-}
-
-type_system::type_index
-type_system::_get_id_struct_class(const char* const x) const
-{
-	const size_t x_len = strlen(x);
-	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
-	while(0<=tmp)
-		{
-		if (DYNAMIC_STRUCTDECL==dynamic_types[tmp].third.second)
-			{
-			if (union_struct_decl::decl_union!=dynamic_types[tmp].third.first.second->keyword())
-				return tmp+1+core_types_size;
-			return 0;
-			};
-		if (DYNAMIC_C_STRUCTDEF==dynamic_types[tmp].third.second)
-			{
-			if (union_struct_decl::decl_union!=dynamic_types[tmp].third.first.third->_decl.keyword())
-				return tmp+1+core_types_size;
-			return 0;
-			}
-		// in a different tag space...retry
-		if (1>=dynamic_types.size()-tmp) break;
-		errr tmp2 = linear_find_lencached(x,x_len,dynamic_types.data()+tmp+1,dynamic_types.size()-(tmp+1));
-		if (0>tmp2) break;
-		tmp += 1+tmp2;
-		}
-	return 0;
-}
-
-type_system::type_index
-type_system::_get_id_struct_class_CPP(const char* const x) const
-{
-	errr tmp = _get_id_struct_class(x);
-	if (0<tmp) return tmp;
-
-	// hmm...not an exact match
-	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(x);
-	if (0>tmp2.first) return 0;
-
-	// it was remapped
-	while(tmp2.first<tmp2.second)
-		{
-		tmp = _get_id_struct_class(inline_namespace_alias_map.data()[tmp2.first].second);
-		if (0<tmp) return tmp;
-		++tmp2.first;
-		}
-	return _get_id_struct_class(inline_namespace_alias_map.data()[tmp2.first].second);
-}
-
-type_system::type_index
-type_system::get_id_struct_class_CPP(const char* alias,const char* active_namespace) const
-{
-	assert(alias && *alias);
-
-	if (!strncmp(alias,"::",2))
-		{	// fully-qualified
-		// pretend not fully qualified, but no surrounding namespace
-		alias += 2;
-		active_namespace = NULL;
-		};
-	if (active_namespace && *active_namespace)
-		{
-		// ok..march up to global
-		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
-		if (is_string_registered(tmp_alias))
-			{	// registered, so could be indexed
-			const type_index tmp2 = _get_id_struct_class_CPP(tmp_alias);
-			if (tmp2) return (free(tmp_alias),tmp2);
-			}
-
-		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
-		if (extra_namespaces)
-			{
-			zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
-			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
-			size_t i = extra_namespaces;
-			do	{
-				--i;
-				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,"::");
-				const type_index tmp2 = _get_id_struct_class_CPP(tmp_alias);
-				if (tmp2) return (free(tmp_alias),tmp2);
-				}
-			while(0<i);
-			}
-		free(tmp_alias);
-		}
-	return _get_id_struct_class_CPP(alias);
-}
-
-type_system::type_index type_system::_get_id_enum(const char* const x) const
-{
-	const size_t x_len = strlen(x);
-	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
-	while(0<=tmp)
-		{
-		if (DYNAMIC_ENUMDEF==dynamic_types[tmp].third.second)
-			return tmp+1+core_types_size;
-
-		// in a different tag space...retry
-		if (1>=dynamic_types.size()-tmp) break;
-		errr tmp2 = linear_find_lencached(x,x_len,dynamic_types.data()+tmp+1,dynamic_types.size()-(tmp+1));
-		if (0>tmp2) break;
-		tmp += 1+tmp2;
-		}
-	return 0;
-}
-
-type_system::type_index
-type_system::_get_id_enum_CPP(const char* const x) const
-{
-	errr tmp = _get_id_enum(x);
-	if (0<tmp) return tmp;
-
-	// hmm...not an exact match
-	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(x);
-	if (0>tmp2.first) return 0;
-
-	// it was remapped
-	while(tmp2.first<tmp2.second)
-		{
-		tmp = _get_id_enum(inline_namespace_alias_map.data()[tmp2.first].second);
-		if (0<tmp) return tmp;
-		++tmp2.first;
-		}
-	return _get_id_enum(inline_namespace_alias_map.data()[tmp2.first].second);
-}
-
-type_system::type_index
-type_system::get_id_enum_CPP(const char* alias,const char* active_namespace) const
-{
-	assert(alias && *alias);
-
-	if (!strncmp(alias,"::",2))
-		{	// fully-qualified
-		// pretend not fully qualified, but no surrounding namespace
-		alias += 2;
-		active_namespace = NULL;
-		};
-	if (active_namespace && *active_namespace)
-		{
-		// ok..march up to global
-		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
-		if (is_string_registered(tmp_alias))
-			{	// registered, so could be indexed
-			const type_index tmp2 = _get_id_enum_CPP(tmp_alias);
-			if (tmp2) return (free(tmp_alias),tmp2);
-			}
-
-		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
-		if (extra_namespaces)
-			{
-			zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
-			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
-			size_t i = extra_namespaces;
-			do	{
-				--i;
-				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,"::");
-				const type_index tmp2 = _get_id_enum_CPP(tmp_alias);
-				if (tmp2) return (free(tmp_alias),tmp2);
-				}
-			while(0<i);
-			}
-		free(tmp_alias);
-		}
-	return _get_id_enum_CPP(alias);
-}
-
 const char* type_system::_name(size_t id) const
 {
 	if (0==id) return "(?)";
@@ -277,578 +24,3 @@
 	return "(?)";
 }
 
-// implement C/C++ typedef system
-void type_system::set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec& src)
-{
-	assert(alias && *alias);
-	assert(filename && *filename);
-	errr tmp = binary_find(alias,strlen(alias),typedef_registry.data(),typedef_registry.size());
-	assert(0>tmp);		// error to call with conflicting prior definition
-	if (0<=tmp) return;	// conflicting prior definition
-#if UINTMAX_MAX==SIZE_MAX
-	if (-1==tmp) _fatal("implementation limit exceeded (typedefs registered at once)");
-#endif
-	zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> > tmp2 = {alias, {src, filename, lineno}};
-	if (!typedef_registry.InsertSlotAt(BINARY_SEARCH_DECODE_INSERTION_POINT(tmp),tmp2)) throw std::bad_alloc();
-	src.clear();
-}
-
-void type_system::set_typedef_CPP(const char* name, const char* const active_namespace, const char* filename, const size_t lineno, type_spec& src)
-{
-	assert(name && *name);
-	assert(filename && *filename);
-
-	// use active namespace if present
-	if (active_namespace && *active_namespace)
-		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
-
-	return set_typedef(name,filename,lineno,src);
-}
-
-const zaimoni::POD_triple<type_spec,const char*,size_t>* type_system::get_typedef(const char* const alias) const
-{
-	assert(alias && *alias);
-	//! \todo: strip off trailing inline namespaces
-	// <unknown> is the hack for anonymous namespaces taken from GCC, it's always inline
-	errr tmp = binary_find(alias,strlen(alias),typedef_registry.data(),typedef_registry.size());
-	if (0<=tmp) return &typedef_registry[tmp].second;
-	return NULL;
-}
-
-const zaimoni::POD_triple<type_spec,const char*,size_t>* type_system::_get_typedef_CPP(const char* const alias) const
-{
-	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = get_typedef(alias);
-	if (tmp) return tmp;
-
-	// hmm...not an exact match
-	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(alias);
-	if (0>tmp2.first) return NULL;
-
-	// it was remapped
-	while(tmp2.first<tmp2.second)
-		{
-		tmp = get_typedef(inline_namespace_alias_map.data()[tmp2.first].second);
-		if (tmp) return tmp;
-		++tmp2.first;
-		}
-	return get_typedef(inline_namespace_alias_map.data()[tmp2.first].second);
-}
-
-const zaimoni::POD_triple<type_spec,const char*,size_t>* type_system::get_typedef_CPP(const char* alias,const char* active_namespace) const
-{
-	assert(alias && *alias);
-
-	if (!strncmp(alias,"::",2))
-		{	// fully-qualified typedef name
-			// cheat: pretend not fully qualified but no surrounding namespace
-		alias += 2;
-		active_namespace = NULL;
-		};
-	if (active_namespace && *active_namespace)
-		{
-		// ok..march up to global
-		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
-		if (is_string_registered(tmp_alias))
-			{	// registered, so could be indexed
-			const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp2 = _get_typedef_CPP(tmp_alias);
-			if (tmp2) return (free(tmp_alias),tmp2);
-			}
-
-		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
-		if (extra_namespaces)
-			{
-			zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
-			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
-			size_t i = extra_namespaces;
-			do	{
-				--i;
-				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,"::");
-				const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp2 = _get_typedef_CPP(tmp_alias);
-				if (tmp2) return (free(tmp_alias),tmp2);
-				}
-			while(0<i);
-			}
-		free(tmp_alias);
-		}
-	return _get_typedef_CPP(alias);
-}
-
-void type_system::set_enumerator_def(const char* const alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename,unsigned char representation,const uchar_blob& src,type_index type)
-{
-	assert(alias && *alias);
-	assert(src_filename && *src_filename);
-	errr tmp = binary_find(alias,strlen(alias),enumerator_registry.data(),enumerator_registry.size());
-	assert(0>tmp);		// error to call with conflicting prior definition
-	if (0<=tmp) return;	// conflicting prior definition
-#if UINTMAX_MAX==SIZE_MAX
-	if (-1==tmp) _fatal("implementation limit exceeded (enumerators registered at once)");
-#endif
-	enumerator_info tmp2 = {alias, { {type, representation, src}, {src_filename, logical_line} } };
-	if (!enumerator_registry.InsertSlotAt(BINARY_SEARCH_DECODE_INSERTION_POINT(tmp),tmp2)) throw std::bad_alloc();
-}
-
-void type_system::set_enumerator_def_CPP(const char* name, const char* const active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename,unsigned char representation,const uchar_blob& src,type_index type)
-{
-	assert(name && *name);
-	assert(src_filename && *src_filename);
-
-	// use active namespace if present
-	if (active_namespace && *active_namespace)
-		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
-
-	set_enumerator_def(name,logical_line,src_filename,representation,src,type);
-}
-
-const type_system::enumerator_info* type_system::get_enumerator(const char* const alias) const
-{
-	assert(alias && *alias);
-	//! \todo: strip off trailing inline namespaces
-	// <unknown> is the hack for anonymous namespaces taken from GCC, it's always inline
-	errr tmp = binary_find(alias,strlen(alias),enumerator_registry.data(),enumerator_registry.size());
-	if (0<=tmp) return &enumerator_registry[tmp];
-	return NULL;
-}
-
-const type_system::enumerator_info* type_system::_get_enumerator_CPP(const char* const alias) const
-{
-	const enumerator_info* tmp = get_enumerator(alias);
-	if (tmp) return tmp;
-
-	// hmm...not an exact match
-	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(alias);
-	if (0>tmp2.first) return NULL;
-
-	// it was remapped
-	while(tmp2.first<tmp2.second)
-		{
-		tmp = get_enumerator(inline_namespace_alias_map.data()[tmp2.first].second);
-		if (tmp) return tmp;
-		++tmp2.first;
-		}
-	return get_enumerator(inline_namespace_alias_map.data()[tmp2.first].second);
-}
-
-const type_system::enumerator_info* type_system::get_enumerator_CPP(const char* alias,const char* active_namespace) const
-{
-	assert(alias && *alias);
-
-	if (!strncmp(alias,"::",2))
-		{	// fully-qualified typedef name
-			// cheat: pretend not fully qualified but no surrounding namespace
-		alias += 2;
-		active_namespace = NULL;
-		};
-	if (active_namespace && *active_namespace)
-		{
-		// ok..march up to global
-		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
-		if (is_string_registered(tmp_alias))
-			{	// registered, so could be indexed
-			const enumerator_info* tmp2 = _get_enumerator_CPP(tmp_alias);
-			if (tmp2) return (free(tmp_alias),tmp2);
-			}
-
-		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
-		if (extra_namespaces)
-			{
-			zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
-			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
-			size_t i = extra_namespaces;
-			do	{
-				--i;
-				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,"::");
-				const enumerator_info* tmp2 = _get_enumerator_CPP(tmp_alias);
-				if (tmp2) return (free(tmp_alias),tmp2);
-				}
-			while(0<i);
-			}
-		free(tmp_alias);
-		}
-	return _get_enumerator_CPP(alias);
-}
-
-char* type_system::_namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len)
-{	// remove comment after other seven wrapper variants implemented
-//	assert(active_namespace && *active_namespace && 0<active_namespace_len && active_namespace_len<=strlen(active_namespace));
-//	assert(name && *name && 0<name_len && name_len<=strlen(name));
-//	assert(namespace_separator && *namespace_separator && 0<namespace_separator_len && namespace_separator_len<=strlen(namespace_separator));
-	char* const actual_name = zaimoni::_new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(active_namespace_len+2+name_len));
-	strncpy(actual_name,active_namespace,active_namespace_len);
-	strncpy(actual_name+active_namespace_len,namespace_separator,namespace_separator_len);
-	strncpy(actual_name+active_namespace_len+namespace_separator_len,name,name_len);
-	return actual_name;
-}
-
-void type_system::_namespace_concatenate(char* buf, const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len)
-{	// remove comment after other seven wrapper variants implemented
-//	assert(buf)
-//	assert(active_namespace && *active_namespace && 0<active_namespace_len && active_namespace_len<=strlen(active_namespace));
-//	assert(name && *name && 0<name_len && name_len<=strlen(name));
-//	assert(namespace_separator && *namespace_separator && 0<namespace_separator_len && namespace_separator_len<=strlen(namespace_separator));
-	strncpy(buf,active_namespace,active_namespace_len);
-	strncpy(buf+active_namespace_len,namespace_separator,namespace_separator_len);
-	strncpy(buf+active_namespace_len+namespace_separator_len,name,name_len);
-	ZAIMONI_NULL_TERMINATE(buf[active_namespace_len+namespace_separator_len+name_len]);
-}
-
-zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> type_system::dealias_inline_namespace_index(const char* const alias) const
-{
-	assert(alias && *alias);
-	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp = {-1,-1};
-	size_t strict_ub = inline_namespace_alias_map.size();
-	size_t lb = 0;
-	// binary search
-	// is inline_namespace_alias_map.data() a code size optimization target?
-	while(strict_ub>lb)
-		{
-		const size_t midpoint = lb+(strict_ub-lb)/2;
-		switch(strcmp(inline_namespace_alias_map.data()[midpoint].first,alias))
-		{
-#ifndef NDEBUG
-		default: FATAL("strcmp out of range -1,0,1");
-#endif
-		case 0: {
-			tmp.first = midpoint;
-			tmp.second = midpoint;
-			while(lb<(size_t)tmp.first && !strcmp(inline_namespace_alias_map.data()[tmp.first-1].first,alias)) --tmp.first;
-			while(strict_ub-1>(size_t)tmp.second && !strcmp(inline_namespace_alias_map.data()[tmp.second+1].first,alias)) ++tmp.second;
-			return tmp;
-			}
-		case 1: {
-			strict_ub = midpoint;
-			break;
-			}
-		case -1:{
-			lb = midpoint+1;
-			}
-		}
-		}
-	return tmp;
-}
-
-bool type_system::is_inline_namespace_CPP(const char* const active_namespace, const size_t active_namespace_len) const
-{
-	assert(active_namespace && *active_namespace && 0<active_namespace_len);
-	assert(strncmp(active_namespace,"::",2));
-	
-	// ::<unknown>, our hack for anonymous namespaces, is always an inline namespace 
-	if (sizeof("<unknown>")-1==active_namespace_len && !strncmp(active_namespace,"<unknown>",sizeof("<unknown>")-1)) return true;
-	if (sizeof("::<unknown>")-1<active_namespace_len && !strncmp(active_namespace+(active_namespace_len-(sizeof("::<unknown>")-1)),"::<unknown>",sizeof("::<unknown>")-1)) return true;
-
-	//! \todo check for C++0X inline namespaces
-	// should be fine with binary search against canonical names
-	return false;
-}
-
-const char* type_system::canonical_name_is_inline_namespace_alias_target(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len) const
-{
-	assert(active_namespace && *active_namespace && 0<active_namespace_len);
-	assert(name && *name && 0<name_len);
-	assert(namespace_separator && *namespace_separator && 0<namespace_separator_len);
-	size_t strict_ub = inline_namespace_alias_targets.size();
-	size_t lb = 0;
-	// classic binary search.
-	// is inline_namespace_alias_targets.data() a code-size optimization target?
-	while(strict_ub>lb)
-		{
-		const size_t midpoint = lb+(strict_ub-lb)/2;
-		int tmp = strncmp(inline_namespace_alias_targets.data()[midpoint],active_namespace,active_namespace_len);
-		if (!tmp) tmp = strncmp(inline_namespace_alias_targets.data()[midpoint]+active_namespace_len,namespace_separator,namespace_separator_len);
-		if (!tmp) tmp = strncmp(inline_namespace_alias_targets.data()[midpoint]+active_namespace_len+namespace_separator_len,name,name_len);
-		switch(tmp)
-		{
-#ifndef NDEBUG
-		default: FATAL("strncmp out of range -1,0,1");
-#endif
-		case 0: return  inline_namespace_alias_targets.data()[midpoint];
-		case 1: {
-			strict_ub = midpoint;
-			break;
-			}
-		case -1:{
-			lb = midpoint+1;
-			}
-		}
-		}
-	return NULL;
-}
-
-const char* type_system::construct_canonical_name_and_aliasing_CPP(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len)
-{
-	assert(active_namespace && *active_namespace && 0<active_namespace_len);
-	assert(name && *name && 0<name_len);
-	assert(strncmp(active_namespace,"::",2));
-	// check for whether we already are aliased
-	const char* retval = canonical_name_is_inline_namespace_alias_target(name,name_len,active_namespace,active_namespace_len,"::",2);
-	if (NULL!=retval) return retval;
-
-	// canonical name is simply active_namespace::name
-	zaimoni::autoval_ptr<char> retval_tmp;
-	retval_tmp = _namespace_concatenate(name,name_len,active_namespace,active_namespace_len,"::",2);
-
-	// aliasing is built by removing trailing inline namespaces incrementally
-	const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
-	if (is_inline_namespace_CPP(active_namespace,active_namespace_len))
-		{
-		zaimoni::autovalarray_ptr_throws<char*> namespace_tmp(extra_namespaces);
-#ifndef ZAIMONI_NULL_REALLY_IS_ZERO
-#error need to null-initialize pointers for namespace_tmp
-#endif
-		bool can_be_completely_gone = false;
-		{
-		zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
-		if (extra_namespaces)
-			{
-			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
-			size_t i = extra_namespaces;
-			do	{
-				if (!is_inline_namespace_CPP(active_namespace,i==extra_namespaces ? active_namespace_len : intra_namespace[i]-active_namespace))
-					break;
-				--i;
-				namespace_tmp[i] = _namespace_concatenate(name,name_len,active_namespace,intra_namespace[i]-active_namespace,"::",2);
-				}
-			while(0<i);
-			can_be_completely_gone = (0==i && is_inline_namespace_CPP(active_namespace,intra_namespace[0]-active_namespace));
-			if (0<i) namespace_tmp.DeleteNSlotsAt(i,0);
-			}
-		else{
-			can_be_completely_gone = true;
-			}
-		}
-		assert(can_be_completely_gone || !namespace_tmp.empty());
-
-		size_t origin = inline_namespace_alias_map.size();
-		size_t origin2 = inline_namespace_alias_targets.size();
-		inline_namespace_alias_targets.resize(origin2+1);
-		try	{
-			inline_namespace_alias_map.resize(origin+namespace_tmp.size()+can_be_completely_gone);
-			}
-		catch(std::bad_alloc& e)
-			{
-			inline_namespace_alias_targets.resize(origin2);
-			throw;
-			}
-
-		retval = register_string(retval_tmp);	//! \todo would prefer to consume the string; changes reset() to NULLPtr() to be safe
-		retval_tmp.reset();
-		/* do a downward insertsort against the second index*/
-		while(origin2 && 1==strcmp(inline_namespace_alias_targets.c_array()[origin2-1],retval))
-			{
-			inline_namespace_alias_targets.c_array()[origin2] = inline_namespace_alias_targets.c_array()[origin2-1];
-			--origin2;
-			};
-		inline_namespace_alias_targets.c_array()[origin2] = retval;
-
-		size_t i = namespace_tmp.size();
-		while(0<i)
-			{
-			const zaimoni::POD_pair<const char*,const char*> tmp = {register_string(namespace_tmp[--i]), retval};
-			size_t j = origin;
-			while(j && 1==strcmp(inline_namespace_alias_map.c_array()[j-1].first,tmp.first))
-				{
-				inline_namespace_alias_map.c_array()[j] = inline_namespace_alias_map.c_array()[j-1];
-				--j;
-				};
-			inline_namespace_alias_map.c_array()[origin++] = tmp;
-			free(namespace_tmp[i]);
-			namespace_tmp[i] = NULL;
-			};
-		if (can_be_completely_gone)
-			{
-			const zaimoni::POD_pair<const char*,const char*> tmp = {register_substring(name,name_len), retval};
-			size_t j = origin;
-			while(j && 1==strcmp(inline_namespace_alias_map.c_array()[j-1].first,tmp.first))
-				{
-				inline_namespace_alias_map.c_array()[j] = inline_namespace_alias_map.c_array()[j-1];
-				--j;
-				};
-			inline_namespace_alias_map.c_array()[origin++] = tmp;
-			}
-		}
-
-	if (!retval)
-		{
-		retval = register_string(retval_tmp);	//! \todo would prefer to consume the string; changes reset() to NULLPtr() to be safe
-		retval_tmp.reset();
-		};
-	// return the canonical name
-	return retval;
-}
-
-type_system::type_index type_system::register_functype(const char* const alias, function_type*& src)
-{
-	assert(alias && *alias);
-	assert(src);
-	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_FUNCTYPE}};
-	tmp.third.first.first = src;
-
-	const size_t dynamic_types_size = dynamic_types.size();
-	const size_t dynamic_types_max_size = dynamic_types.max_size();
-	if (	dynamic_types_max_size<1+core_types_size
-		|| 	dynamic_types_max_size-(1+core_types_size)<dynamic_types_size)
-		FATAL("Host implementation limit exceeded: cannot record function type used in program");
-	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
-	src = NULL;
-	return dynamic_types_size+1+core_types_size;
-}
-
-type_system::type_index type_system::register_functype_CPP(const char* name, const char* const active_namespace, function_type*& src)
-{
-	assert(name && *name);
-	assert(src);
-
-	// use active namespace if present
-	if (active_namespace && *active_namespace)
-		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
-
-	return register_functype(name,src);
-}
-
-type_system::type_index type_system::register_structdecl(const char* const alias, int keyword)
-{
-	assert(alias && *alias);
-	const size_t dynamic_types_size = dynamic_types.size();
-	const size_t dynamic_types_max_size = dynamic_types.max_size();
-	if (	dynamic_types_max_size<2+core_types_size
-		|| 	dynamic_types_max_size-(2+core_types_size)<dynamic_types_size)
-		FATAL("Host implementation limit exceeded: cannot record union/struct type used in program");
-
-	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_STRUCTDECL}};
-	tmp.third.first.second = new union_struct_decl((union_struct_decl::keywords)keyword,alias);
-
-	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp))
-		{
-		delete tmp.third.first.second;
-		throw std::bad_alloc();
-		}
-	return dynamic_types_size+1+core_types_size;
-}
-
-type_system::type_index type_system::register_structdecl_CPP(const char* name, const char* const active_namespace, int keyword)
-{
-	assert(name && *name);
-
-	// use active namespace if present
-	if (active_namespace && *active_namespace)
-		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
-
-	return register_structdecl(name,keyword);
-}
-
-type_system::type_index type_system::register_C_structdef(const char* const alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename, int keyword)
-{
-	assert(alias && *alias);
-	assert(src_filename && *src_filename);
-	const size_t dynamic_types_size = dynamic_types.size();
-	const size_t dynamic_types_max_size = dynamic_types.max_size();
-	if (	dynamic_types_max_size<2+core_types_size
-		|| 	dynamic_types_max_size-(2+core_types_size)<dynamic_types_size)
-		FATAL("Host implementation limit exceeded: cannot record union/struct type used in program");
-
-	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_C_STRUCTDEF}};
-	tmp.third.first.third = new C_union_struct_def((union_struct_decl::keywords)keyword,alias,logical_line,src_filename);
-
-	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
-	return dynamic_types_size+1+core_types_size;
-}
-
-type_system::type_index type_system::register_C_structdef_CPP(const char* name, const char* const active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename, int keyword)
-{
-	assert(name && *name);
-	assert(src_filename && *src_filename);
-
-	// use active namespace if present
-	if (active_namespace && *active_namespace)
-		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
-
-	return register_C_structdef(name,logical_line,src_filename,keyword);
-}
-
-type_system::type_index type_system::register_enum_def(const char* const alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename)
-{
-	assert(alias && *alias);
-	assert(src_filename && *src_filename);
-	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_ENUMDEF}};
-	tmp.third.first.fourth = new enum_def(alias,logical_line,src_filename);
-
-	const size_t dynamic_types_size = dynamic_types.size();
-	const size_t dynamic_types_max_size = dynamic_types.max_size();
-	if (	dynamic_types_max_size<2+core_types_size
-		|| 	dynamic_types_max_size-(2+core_types_size)<dynamic_types_size)
-		FATAL("Host implementation limit exceeded: cannot record enum type used in program");
-	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
-	return dynamic_types_size+1+core_types_size;
-}
-
-type_system::type_index type_system::register_enum_def_CPP(const char* name, const char* const active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename)
-{
-	assert(name && *name);
-	assert(src_filename && *src_filename);
-
-	// use active namespace if present
-	if (active_namespace && *active_namespace)
-		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
-
-	return register_enum_def(name,logical_line,src_filename);
-}
-
-const function_type* type_system::get_functype(type_system::type_index i)
-{
-	if (core_types_size>=i) return NULL;
-	i -= core_types_size;
-	--i;
-	if (dynamic_types.size()<=i) return NULL;
-	const dynamic_type_format& tmp = dynamic_types[i];
-	if (DYNAMIC_FUNCTYPE!=tmp.third.second) return NULL;
-	return tmp.third.first.first;
-}
-
-const union_struct_decl* type_system::get_structdecl(type_system::type_index i)
-{
-	if (core_types_size>=i) return NULL;
-	i -= core_types_size;
-	--i;
-	if (dynamic_types.size()<=i) return NULL;
-	const dynamic_type_format& tmp = dynamic_types[i];
-	if (DYNAMIC_STRUCTDECL!=tmp.third.second) return NULL;
-	return tmp.third.first.second;
-}
-
-const C_union_struct_def* type_system::get_C_structdef(type_system::type_index i)
-{
-	if (core_types_size>=i) return NULL;
-	i -= core_types_size;
-	--i;
-	if (dynamic_types.size()<=i) return NULL;
-	const dynamic_type_format& tmp = dynamic_types[i];
-	if (DYNAMIC_C_STRUCTDEF!=tmp.third.second) return NULL;
-	return tmp.third.first.third;
-}
-
-const enum_def* type_system::get_enum_def(type_index i)
-{
-	if (core_types_size>=i) return NULL;
-	i -= core_types_size;
-	--i;
-	if (dynamic_types.size()<=i) return NULL;
-	const dynamic_type_format& tmp = dynamic_types[i];
-	if (DYNAMIC_ENUMDEF!=tmp.third.second) return NULL;
-	return tmp.third.first.fourth;
-}
-
-void type_system::upgrade_decl_to_def(type_index i,C_union_struct_def*& src)
-{	// cf. get_structdecl
-	assert(src);
-	assert(core_types_size<i);
-	i -= core_types_size;
-	--i;
-	assert(dynamic_types.size()>i);
-	dynamic_type_format& tmp = dynamic_types[i];
-	assert(DYNAMIC_STRUCTDECL==tmp.third.second);
-	assert(*tmp.third.first.second==src->_decl);
-	tmp.third.second = DYNAMIC_C_STRUCTDEF;
-	delete tmp.third.first.second;
-	tmp.third.first.third = src;
-	src = NULL;
-}
-

Modified: trunk/type_system_pp.hpp
===================================================================
--- trunk/type_system_pp.hpp	2010-03-05 20:32:43 UTC (rev 343)
+++ trunk/type_system_pp.hpp	2010-03-07 03:11:18 UTC (rev 344)
@@ -1,4 +1,4 @@
-// type_system.hpp
+// type_system_pp.hpp
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
 #ifndef TYPE_SYSTEM_HPP
@@ -28,10 +28,6 @@
 private:
 	typedef zaimoni::POD_triple<const char*,size_t,zaimoni::POD_pair<zaimoni::union_quartet<function_type*,union_struct_decl*,C_union_struct_def*,enum_def*>, unsigned char> > dynamic_type_format;
 	zaimoni::autovalarray_ptr<dynamic_type_format> dynamic_types;
-	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> > > typedef_registry;
-	zaimoni::weakautovalarray_ptr<const char*> inline_namespace_alias_targets;
-	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,const char*> > inline_namespace_alias_map;
-	zaimoni::autovalarray_ptr<enumerator_info> enumerator_registry;
 	// uncopyable
 	type_system(const type_system& src);
 	void operator=(const type_system& src);
@@ -42,103 +38,12 @@
 		core_types_size((assert(0<_core_types_size),_core_types_size)),
 		int_priority_size((assert(0<_int_priority_size),_int_priority_size)) {};
 
-	type_index get_id_union(const char* x) const
-		{
-		assert(x && *x);
-		return _get_id_union(x);
-		}
-	type_index get_id_union_CPP(const char* alias,const char* active_namespace) const;
-	type_index get_id_struct_class(const char* x) const
-		{
-		assert(x && *x);
-		return _get_id_struct_class(x);
-		}
-	type_index get_id_struct_class_CPP(const char* alias,const char* active_namespace) const;
-	type_index get_id_enum(const char* x) const
-		{
-		assert(x && *x);
-		return _get_id_enum(x);
-		}
-	type_index get_id_enum_CPP(const char* alias,const char* active_namespace) const;
 	const char* name(type_index id) const
 		{
 		assert(core_types_size+dynamic_types.size()>=id);
 		return _name(id);
 		}
-
-	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
-	// defer seven other variants for now (YAGNI)
-	static char* namespace_concatenate(const char* const name, const char* const active_namespace,const char* namespace_separator)
-		{
-		assert(name && *name);
-		assert(active_namespace && *active_namespace);
-		assert(namespace_separator && *namespace_separator);
-		return _namespace_concatenate(name,strlen(name),active_namespace,strlen(active_namespace),namespace_separator,strlen(namespace_separator));
-		};
-
-	// defer six other variants for now (YAGNI)
-	static void namespace_concatenate(char* buf, const char* const name, const char* const active_namespace,const char* namespace_separator)
-		{
-		assert(buf);
-		assert(name && *name);
-		assert(active_namespace && *active_namespace);
-		assert(namespace_separator && *namespace_separator);
-		_namespace_concatenate(buf,name,strlen(name),active_namespace,strlen(active_namespace),namespace_separator,strlen(namespace_separator));
-		};
-	static void namespace_concatenate(char* buf, const char* const name, const char* const active_namespace,size_t active_namespace_len,const char* namespace_separator)
-		{
-		assert(buf);
-		assert(name && *name);
-		assert(active_namespace && *active_namespace);
-		assert(0<active_namespace_len && active_namespace_len<=strlen(active_namespace));
-		assert(namespace_separator && *namespace_separator);
-		_namespace_concatenate(buf,name,strlen(name),active_namespace,active_namespace_len,namespace_separator,strlen(namespace_separator));
-		};
-
-
-	void set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec& src);	// invalidates src
-	void set_typedef_CPP(const char* const name, const char* const active_namespace, const char* filename, const size_t lineno, type_spec& src);	// invalidates src
-	const zaimoni::POD_triple<type_spec,const char*,size_t>* get_typedef(const char* const alias) const;
-	const zaimoni::POD_triple<type_spec,const char*,size_t>* get_typedef_CPP(const char* alias,const char* active_namespace) const;
-
-	void set_enumerator_def(const char* alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename,unsigned char representation,const uchar_blob& src,type_index type);
-	void set_enumerator_def_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename,unsigned char representation,const uchar_blob& src,type_index type);
-	const enumerator_info* get_enumerator(const char* alias) const;
-	const enumerator_info* get_enumerator_CPP(const char* alias,const char* active_namespace) const;
-
-	type_index register_functype(const char* const alias, function_type*& src);
-	type_index register_functype_CPP(const char* name, const char* active_namespace, function_type*& src);
-//	keyword actually should be type union_struct_decl::keywords, but that increases coupling unacceptably
-	type_index register_structdecl(const char* alias, int keyword);
-	type_index register_structdecl_CPP(const char* name, const char* active_namespace, int keyword);
-	type_index register_C_structdef(const char* alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename, int keyword);
-	type_index register_C_structdef_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename, int keyword);
-	type_index register_enum_def(const char* alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename);
-	type_index register_enum_def_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename);
-	const function_type* get_functype(type_index i);
-	const union_struct_decl* get_structdecl(type_index i);
-	const C_union_struct_def* get_C_structdef(type_index i);
-	const enum_def* get_enum_def(type_index i);
-	void upgrade_decl_to_def(type_index i,C_union_struct_def*& src);
 private:
-	type_index _get_id_union(const char* x) const;
-	type_index _get_id_union_CPP(const char* x) const;
-	type_index _get_id_enum(const char* x) const;
-	type_index _get_id_enum_CPP(const char* x) const;
-	type_index _get_id_struct_class(const char* x) const;
-	type_index _get_id_struct_class_CPP(const char* x) const;
-
 	const char* _name(type_index id) const;
-	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> dealias_inline_namespace_index(const char* alias) const;
-	const zaimoni::POD_triple<type_spec,const char*,size_t>* _get_typedef_CPP(const char* alias) const;
-	const enumerator_info* _get_enumerator_CPP(const char* alias) const;
-
-	bool is_inline_namespace_CPP(const char* active_namespace, size_t active_namespace_len) const;
-	const char* canonical_name_is_inline_namespace_alias_target(const char* name, size_t name_len, const char* active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len) const;
-	const char* construct_canonical_name_and_aliasing_CPP(const char* name, size_t name_len, const char* active_namespace, size_t active_namespace_len);
-
-	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
-	static char* _namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
-	static void _namespace_concatenate(char* buf, const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
 };
 #endif



From zaimoni at mail.berlios.de  Sun Mar  7 22:17:36 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 7 Mar 2010 22:17:36 +0100
Subject: [Zcplusplus-commits] r345 - trunk
Message-ID: <201003072117.o27LHabW023171@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-07 22:17:24 +0100 (Sun, 07 Mar 2010)
New Revision: 345

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.hpp
   trunk/CSupport_pp.cpp
   trunk/CSupport_pp.hpp
   trunk/type_system.cpp
   trunk/type_system.hpp
   trunk/type_system_pp.cpp
   trunk/type_system_pp.hpp
Log:
const correctness, debug check

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-07 03:11:18 UTC (rev 344)
+++ trunk/CSupport.cpp	2010-03-07 21:17:24 UTC (rev 345)
@@ -12156,7 +12156,6 @@
 	LengthOfCSystemHeader,
 	CPurePreprocessingOperatorPunctuationCode,
 	CPurePreprocessingOperatorPunctuationFlags,
-	LengthOfCStringLiteral,
 	C_like_BalancingCheck,
 	C99_ControlExpressionContextFreeErrorCount,
 	C99_CondenseParseTree,
@@ -12179,7 +12178,6 @@
 	LengthOfCPPSystemHeader,
 	CPPPurePreprocessingOperatorPunctuationCode,
 	CPPPurePreprocessingOperatorPunctuationFlags,
-	LengthOfCStringLiteral,
 	C_like_BalancingCheck,
 	CPP_ControlExpressionContextFreeErrorCount,
 	CPP_CondenseParseTree,

Modified: trunk/CSupport.hpp
===================================================================
--- trunk/CSupport.hpp	2010-03-07 03:11:18 UTC (rev 344)
+++ trunk/CSupport.hpp	2010-03-07 21:17:24 UTC (rev 345)
@@ -83,7 +83,6 @@
 	func_traits<size_t (*)(const char*)>::function_ref_type LengthOfSystemHeader;			// non-zero iff system header exactly matched
 	func_traits<signed int (*)(const char* const x, size_t x_len)>::function_ref_type EncodePPOpPunc;	// encode pp op/punc; 0>= if not found
 	func_traits<unsigned int (*)(signed int)>::function_ref_type GetPPOpPuncFlags;			// returns flag set, 0 if nothing matched
-	func_traits<size_t (*)(const char*,size_t)>::function_ref_type LengthOfStringLiteral;	// returns length of string literal as an array of its char type
 	func_traits<bool (*)(const weak_token*,size_t,bool,bool)>::function_ref_type BalancingErrorCheck;		// slow; returns true if any errors found
 	func_traits<bool (*)(const weak_token*,size_t,bool,bool)>::function_ref_type ControlExpressionContextFreeErrorCheck;	// returns true if any errors found
 	func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type CondenseParseTree;	// returns number of errors detected

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-07 03:11:18 UTC (rev 344)
+++ trunk/CSupport_pp.cpp	2010-03-07 21:17:24 UTC (rev 345)
@@ -10229,7 +10229,6 @@
 	LengthOfCSystemHeader,
 	CPurePreprocessingOperatorPunctuationCode,
 	CPurePreprocessingOperatorPunctuationFlags,
-	LengthOfCStringLiteral,
 	C_like_BalancingCheck,
 	C99_ControlExpressionContextFreeErrorCount,
 	C99_CondenseParseTree,
@@ -10244,7 +10243,6 @@
 	LengthOfCPPSystemHeader,
 	CPPPurePreprocessingOperatorPunctuationCode,
 	CPPPurePreprocessingOperatorPunctuationFlags,
-	LengthOfCStringLiteral,
 	C_like_BalancingCheck,
 	CPP_ControlExpressionContextFreeErrorCount,
 	CPP_CondenseParseTree,

Modified: trunk/CSupport_pp.hpp
===================================================================
--- trunk/CSupport_pp.hpp	2010-03-07 03:11:18 UTC (rev 344)
+++ trunk/CSupport_pp.hpp	2010-03-07 21:17:24 UTC (rev 345)
@@ -1,4 +1,4 @@
-// CSupport.hpp
+// CSupport_pp.hpp
 // support for C/C++ language parsing
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
@@ -83,7 +83,6 @@
 	func_traits<size_t (*)(const char*)>::function_ref_type LengthOfSystemHeader;			// non-zero iff system header exactly matched
 	func_traits<signed int (*)(const char* const x, size_t x_len)>::function_ref_type EncodePPOpPunc;	// encode pp op/punc; 0>= if not found
 	func_traits<unsigned int (*)(signed int)>::function_ref_type GetPPOpPuncFlags;			// returns flag set, 0 if nothing matched
-	func_traits<size_t (*)(const char*,size_t)>::function_ref_type LengthOfStringLiteral;	// returns length of string literal as an array of its char type
 	func_traits<bool (*)(const weak_token*,size_t,bool,bool)>::function_ref_type BalancingErrorCheck;		// slow; returns true if any errors found
 	func_traits<bool (*)(const weak_token*,size_t,bool,bool)>::function_ref_type ControlExpressionContextFreeErrorCheck;	// returns true if any errors found
 	func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type CondenseParseTree;	// returns number of errors detected

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2010-03-07 03:11:18 UTC (rev 344)
+++ trunk/type_system.cpp	2010-03-07 21:17:24 UTC (rev 345)
@@ -1,5 +1,5 @@
 // type_system.cpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #/*cut-cpp*/
 #include "type_system.hpp"
@@ -383,6 +383,7 @@
 {
 	assert(alias && *alias);
 	assert(src_filename && *src_filename);
+	assert(type);
 	errr tmp = binary_find(alias,strlen(alias),enumerator_registry.data(),enumerator_registry.size());
 	assert(0>tmp);		// error to call with conflicting prior definition
 	if (0<=tmp) return;	// conflicting prior definition
@@ -397,6 +398,7 @@
 {
 	assert(name && *name);
 	assert(src_filename && *src_filename);
+	assert(type);
 
 	// use active namespace if present
 	if (active_namespace && *active_namespace)
@@ -411,7 +413,11 @@
 	//! \todo: strip off trailing inline namespaces
 	// <unknown> is the hack for anonymous namespaces taken from GCC, it's always inline
 	errr tmp = binary_find(alias,strlen(alias),enumerator_registry.data(),enumerator_registry.size());
-	if (0<=tmp) return &enumerator_registry[tmp];
+	if (0<=tmp)
+		{
+		assert(get_enum_def(enumerator_registry[tmp].second.first.first));
+		return &enumerator_registry[tmp];
+		}
 	return NULL;
 }
 
@@ -798,7 +804,7 @@
 	return register_enum_def(name,logical_line,src_filename);
 }
 
-const function_type* type_system::get_functype(type_system::type_index i)
+const function_type* type_system::get_functype(type_system::type_index i)  const
 {
 	if (core_types_size>=i) return NULL;
 	i -= core_types_size;
@@ -809,7 +815,7 @@
 	return tmp.third.first.first;
 }
 
-const union_struct_decl* type_system::get_structdecl(type_system::type_index i)
+const union_struct_decl* type_system::get_structdecl(type_system::type_index i)  const
 {
 	if (core_types_size>=i) return NULL;
 	i -= core_types_size;
@@ -820,7 +826,7 @@
 	return tmp.third.first.second;
 }
 
-const C_union_struct_def* type_system::get_C_structdef(type_system::type_index i)
+const C_union_struct_def* type_system::get_C_structdef(type_system::type_index i)  const
 {
 	if (core_types_size>=i) return NULL;
 	i -= core_types_size;
@@ -831,7 +837,7 @@
 	return tmp.third.first.third;
 }
 
-const enum_def* type_system::get_enum_def(type_index i)
+const enum_def* type_system::get_enum_def(type_index i)  const
 {
 	if (core_types_size>=i) return NULL;
 	i -= core_types_size;

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2010-03-07 03:11:18 UTC (rev 344)
+++ trunk/type_system.hpp	2010-03-07 21:17:24 UTC (rev 345)
@@ -1,5 +1,5 @@
 // type_system.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #ifndef TYPE_SYSTEM_HPP
 #define TYPE_SYSTEM_HPP 1
@@ -117,10 +117,10 @@
 	type_index register_C_structdef_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename, int keyword);
 	type_index register_enum_def(const char* alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename);
 	type_index register_enum_def_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename);
-	const function_type* get_functype(type_index i);
-	const union_struct_decl* get_structdecl(type_index i);
-	const C_union_struct_def* get_C_structdef(type_index i);
-	const enum_def* get_enum_def(type_index i);
+	const function_type* get_functype(type_index i) const;
+	const union_struct_decl* get_structdecl(type_index i) const;
+	const C_union_struct_def* get_C_structdef(type_index i) const;
+	const enum_def* get_enum_def(type_index i) const;
 	void upgrade_decl_to_def(type_index i,C_union_struct_def*& src);
 #/*cut-cpp*/
 private:

Modified: trunk/type_system_pp.cpp
===================================================================
--- trunk/type_system_pp.cpp	2010-03-07 03:11:18 UTC (rev 344)
+++ trunk/type_system_pp.cpp	2010-03-07 21:17:24 UTC (rev 345)
@@ -1,5 +1,5 @@
 // type_system_pp.cpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #include "type_system_pp.hpp"
 #include "enum_type.hpp"

Modified: trunk/type_system_pp.hpp
===================================================================
--- trunk/type_system_pp.hpp	2010-03-07 03:11:18 UTC (rev 344)
+++ trunk/type_system_pp.hpp	2010-03-07 21:17:24 UTC (rev 345)
@@ -1,5 +1,5 @@
 // type_system_pp.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #ifndef TYPE_SYSTEM_HPP
 #define TYPE_SYSTEM_HPP 1



From zaimoni at mail.berlios.de  Mon Mar  8 20:13:27 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 8 Mar 2010 20:13:27 +0100
Subject: [Zcplusplus-commits] r346 - trunk
Message-ID: <201003081913.o28JDRg4027493@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-08 20:13:22 +0100 (Mon, 08 Mar 2010)
New Revision: 346

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/ParseTree.hpp
Log:
checkpoint introducing enum support to expressions

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-07 21:17:24 UTC (rev 345)
+++ trunk/CSupport.cpp	2010-03-08 19:13:22 UTC (rev 346)
@@ -5231,12 +5231,23 @@
 	_label_one_literal(dest,types);
 	return dest;
 }
+#/*cut-cpp*/
 
+static const enum_def* is_noticed_enumerator(const parse_tree& x,const type_system& types)
+{
+	const enum_def* tmp = NULL;
+	if (x.is_atomic() && (C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags))
+		tmp = types.get_enum_def(x.type_code.base_type_index);
+	return tmp;
+}
+#/*cut-cpp*/
+
 static bool eval_unary_plus(parse_tree& src, const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'+'>(src));
 	if (0<src.data<2>()->type_code.pointer_power_after_array_decay())
 		{	// assume C++98 interpretation, as this is illegal in C99
+		//! \test cpp/default/Pass_if_control27.hpp
 		if (!(parse_tree::INVALID & src.flags))
 			{
 			assert(src.type_code==src.data<2>()->type_code);
@@ -5245,7 +5256,26 @@
 			}
 		return false;
 		}
-	// handle integer-like literals like a real integer literal
+#/*cut-cpp*/
+#if 0-0
+	else if (is_noticed_enumerator(*src.data<2>(),types))
+		{
+		parse_tree tmp3;
+		const promote_aux dest_type(src.type_code.base_type_index);
+		const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.data<2>()->index_tokens[0].token.first);
+		assert(tmp2);
+		{
+		umaxint res_int;
+		const bool tmp_negative = target_machine->C_promote_integer(res_int,umaxint(tmp2->second.first.third),dest_type);
+		if (!VM_to_signed_literal(tmp3,tmp_negative,res_int,*src.data<2>(),types) return false;
+		}
+		src.destroy();
+		src = tmp3;
+		return true;
+		}
+#endif
+#/*cut-cpp*/
+ 	// handle integer-like literals like a real integer literal
 	else if (converts_to_integerlike(src.data<2>()->type_code) && (PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
 		{
 		const type_spec old_type = src.type_code;
@@ -5312,7 +5342,16 @@
 	// can type if result is a primitive arithmetic type
 	if (converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index))
 		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index));
-
+#/*cut-cpp*/
+	// can type if an (C++0X unscoped) enumerator
+	else if (is_noticed_enumerator(*src.data<2>(),types))
+		{
+		const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.data<2>()->index_tokens[0].token.first);
+		assert(tmp2);
+		src.type_code.set_type(tmp2->second.first.first);
+		}
+#/*cut-cpp*/
+	
 	const size_t arg_unary_subtype 	= (is_C99_unary_operator_expression<'-'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_NEG
 									: (is_C99_unary_operator_expression<'+'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_PLUS : 0;
 	if (!arg_unary_subtype) return;
@@ -5342,6 +5381,15 @@
 	// can type if result is a primitive arithmetic type
 	if (converts_to_arithmeticlike(src.data<2>()->type_code))
 		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index));
+#/*cut-cpp*/
+	// can type if an (C++0X unscoped) enumerator
+	else if (is_noticed_enumerator(*src.data<2>(),types))
+		{
+		const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.data<2>()->index_tokens[0].token.first);
+		assert(tmp2);
+		src.type_code.set_type(tmp2->second.first.first);
+		}
+#/*cut-cpp*/
 
 	// two deep:
 	// 1) if inner +/- is applied to an arithmetic literal, try to crunch it (but leave - signed alone)
@@ -5769,8 +5817,10 @@
 		if (negative_signed_int)
 			// convert to parsed - literal
 			force_unary_negative_literal(src,tmp);
-		else	// convert to positive literal
+		else{	// convert to positive literal
+			src.destroy();
 			src = tmp;
+			}
 		src.type_code = old_type;
 		return true;
 		};
@@ -10401,8 +10451,22 @@
 }
 #endif
 
-static void C99_CPP_handle_static_assertion(parse_tree& src,type_system& types,PP_auxfunc& langinfo,const size_t i,const char* const err)
+static void notice_enumerator_CPP(parse_tree& x,const type_system& types,const char* const active_namespace)
 {
+	if (x.is_atomic() && (C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags))
+		{
+		const type_system::enumerator_info* const tmp = types.get_enumerator_CPP(x.index_tokens[0].token.first,active_namespace);
+		if (tmp)
+			{
+			x.set_index_token_from_str_literal<0>(tmp->first);
+			x.type_code.set_type(tmp->second.first.first);
+			// XXX would be handy to keep the tmp around, consider as time optimization XXX
+			}
+		}
+}
+
+static void C99_CPP_handle_static_assertion(parse_tree& src,type_system& types,PP_auxfunc& langinfo,const size_t i,const char* const err,const char* const active_namespace)
+{
 	assert(err && *err);
 	// find the next ';'
 	const size_t j = i+span_to_semicolon(src.data<0>()+i,src.end<0>());
@@ -10454,6 +10518,10 @@
 		_fatal("insufficient RAM to parse static assertion");
 		};
 	zaimoni::autotransform_n<void (*)(parse_tree&,const parse_tree&)>(parsetree.c_array<0>(),src.data<0>()[i+1].data<0>(),k,value_copy);
+	// type all enumerators now to make life reasonable later on for the expression-parser
+	size_t enum_scan = k;
+	do	notice_enumerator_CPP(parsetree.c_array<0>()[--enum_scan],types,active_namespace);
+	while(0<enum_scan);
 	}
 	// init above correctly
 	// snip from Condense
@@ -10959,7 +11027,7 @@
 		// C static assertion scanner
 		if (robust_token_is_string<14>(src.data<0>()[i],"_Static_Assert"))
 			{	// _Static_Assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CLexer->pp_support,i," : control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)");
+			C99_CPP_handle_static_assertion(src,types,*CLexer->pp_support,i," : control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)",NULL);
 			continue;
 			};
 		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
@@ -11448,7 +11516,7 @@
 		// C++ static assertion scanner
 		if (robust_token_is_string<13>(src.data<0>()[i],"static_assert"))
 			{	// static_assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CPlusPlusLexer->pp_support,i," : control expression for static assertion must be a constant convertible to bool (C++0X 7p4)");
+			C99_CPP_handle_static_assertion(src,types,*CPlusPlusLexer->pp_support,i," : control expression for static assertion must be a constant convertible to bool (C++0X 7p4)",active_namespace);
 			continue;
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-07 21:17:24 UTC (rev 345)
+++ trunk/CSupport_pp.cpp	2010-03-08 19:13:22 UTC (rev 346)
@@ -5156,6 +5156,7 @@
 	assert(is_C99_unary_operator_expression<'+'>(src));
 	if (0<src.data<2>()->type_code.pointer_power_after_array_decay())
 		{	// assume C++98 interpretation, as this is illegal in C99
+		//! \test cpp/default/Pass_if_control27.hpp
 		if (!(parse_tree::INVALID & src.flags))
 			{
 			assert(src.type_code==src.data<2>()->type_code);
@@ -5164,7 +5165,7 @@
 			}
 		return false;
 		}
-	// handle integer-like literals like a real integer literal
+ 	// handle integer-like literals like a real integer literal
 	else if (converts_to_integerlike(src.data<2>()->type_code) && (PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
 		{
 		const type_spec old_type = src.type_code;
@@ -5231,7 +5232,7 @@
 	// can type if result is a primitive arithmetic type
 	if (converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index))
 		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index));
-
+	
 	const size_t arg_unary_subtype 	= (is_C99_unary_operator_expression<'-'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_NEG
 									: (is_C99_unary_operator_expression<'+'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_PLUS : 0;
 	if (!arg_unary_subtype) return;
@@ -5688,8 +5689,10 @@
 		if (negative_signed_int)
 			// convert to parsed - literal
 			force_unary_negative_literal(src,tmp);
-		else	// convert to positive literal
+		else{	// convert to positive literal
+			src.destroy();
 			src = tmp;
+			}
 		src.type_code = old_type;
 		return true;
 		};

Modified: trunk/ParseTree.hpp
===================================================================
--- trunk/ParseTree.hpp	2010-03-07 21:17:24 UTC (rev 345)
+++ trunk/ParseTree.hpp	2010-03-08 19:13:22 UTC (rev 346)
@@ -341,6 +341,15 @@
 		index_tokens[dest_idx].flags = src_flags;
 		control_index_token<dest_idx>(false);
 		}
+	template<size_t dest_idx> void set_index_token_from_str_literal(const char* const src)
+		{
+		BOOST_STATIC_ASSERT(STATIC_SIZE(index_tokens)>dest_idx);
+		assert(NULL!=src);
+		if (own_index_token<dest_idx>()) { free(const_cast<char*>(index_tokens[dest_idx].token.first)); };
+		index_tokens[dest_idx].token.first = src;
+		index_tokens[dest_idx].token.second = strlen(src);
+		control_index_token<dest_idx>(false);
+		}
 
 	template<size_t src_idx,class scanner> size_t get_span(size_t i,scanner& x) const
 		{



From zaimoni at mail.berlios.de  Mon Mar  8 21:05:41 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 8 Mar 2010 21:05:41 +0100
Subject: [Zcplusplus-commits] r347 - trunk
Message-ID: <201003082005.o28K5fKS031428@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-08 21:05:37 +0100 (Mon, 08 Mar 2010)
New Revision: 347

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
executable size reduction for z_cpp

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-08 19:13:22 UTC (rev 346)
+++ trunk/CSupport.cpp	2010-03-08 20:05:37 UTC (rev 347)
@@ -519,6 +519,7 @@
 
 BOOST_STATIC_ASSERT(C_KEYWORD_NONSTRICT_LB<C_KEYWORD_STRICT_UB);
 BOOST_STATIC_ASSERT(CPP_KEYWORD_NONSTRICT_LB<C_KEYWORD_STRICT_UB);
+#/*cut-cpp*/
 
 static const char* C99_echo_reserved_keyword(const char* x,size_t x_len)
 {
@@ -542,7 +543,6 @@
 	return NULL;
 }
 
-#/*cut-cpp*/
 static const char* C99_echo_reserved_symbol(const char* x,size_t x_len)
 {
 	assert(NULL!=x);
@@ -3450,6 +3450,7 @@
 #endif
 			&&	src.empty<1>() && src.empty<2>();
 }
+#/*cut-cpp*/
 
 static bool is_naked_brace_pair(const parse_tree& src)
 {
@@ -3470,6 +3471,7 @@
 #endif
 			&&	src.empty<1>() && src.empty<2>();
 }
+#/*cut-cpp*/
 
 #ifndef NDEBUG
 static bool is_array_deref_strict(const parse_tree& src)
@@ -3838,6 +3840,7 @@
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<2>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 }
+#/*cut-cpp*/
 
 static bool is_C99_anonymous_specifier(const parse_tree& src,const char* const spec_name)
 {
@@ -3911,7 +3914,7 @@
 	src.c_array<0>()[j].clear();
 }
 
-void C99_notice_struct_union_enum(parse_tree& src)
+static void C99_notice_struct_union_enum(parse_tree& src)
 {
 	assert(!src.empty<0>());
 	size_t i = 0;
@@ -4005,7 +4008,7 @@
 	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
 }
 
-void CPP_notice_class_struct_union_enum(parse_tree& src)
+static void CPP_notice_class_struct_union_enum(parse_tree& src)
 {
 	assert(!src.empty<0>());
 	size_t i = 0;
@@ -4099,6 +4102,7 @@
 		};
 	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
 }
+#/*cut-cpp*/
 
 bool convert_to(umaxint& dest,const C_PPIntCore& src)
 {
@@ -9260,9 +9264,8 @@
 	// struct/union/enum specifiers can occur in all sorts of strange places
 	C99_notice_struct_union_enum(src);
 }
-#/*cut-cpp*/
 
-bool CPP_ok_for_toplevel_qualified_name(const parse_tree& x)
+static bool CPP_ok_for_toplevel_qualified_name(const parse_tree& x)
 {
 	if (!x.is_atomic()) return false;
 	if (PARSE_PRIMARY_TYPE & x.flags) return false;
@@ -9388,7 +9391,6 @@
 		};
 }
 
-#/*cut-cpp*/
 //! \todo check that the fact all literals are already legal-form is used
 static void CPP_ContextFreeParse(parse_tree& src,const type_system& types)
 {
@@ -10057,6 +10059,7 @@
 			}
 		};
 }
+#/*cut-cpp*/
 
 //! \todo should this be a type_system member?
 static bool check_for_typedef(type_spec& dest,const char* const src,const type_system& types)
@@ -10389,6 +10392,7 @@
 	uintmax_t get_flags() const {return flags;};
 	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
 };
+#/*cut-cpp*/
 
 size_t C99_init_declarator_scanner(const parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
 {

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-08 19:13:22 UTC (rev 346)
+++ trunk/CSupport_pp.cpp	2010-03-08 20:05:37 UTC (rev 347)
@@ -513,29 +513,6 @@
 BOOST_STATIC_ASSERT(C_KEYWORD_NONSTRICT_LB<C_KEYWORD_STRICT_UB);
 BOOST_STATIC_ASSERT(CPP_KEYWORD_NONSTRICT_LB<C_KEYWORD_STRICT_UB);
 
-static const char* C99_echo_reserved_keyword(const char* x,size_t x_len)
-{
-	assert(NULL!=x);
-	assert(x_len<=strlen(x));
-	size_t i = C_KEYWORD_STRICT_UB-C_KEYWORD_NONSTRICT_LB;
-	do	if (x_len==valid_keyword[C_KEYWORD_NONSTRICT_LB + --i].second && !strncmp(valid_keyword[C_KEYWORD_NONSTRICT_LB + i].first,x,x_len))
-			return valid_keyword[C_KEYWORD_NONSTRICT_LB + i].first;
-	while(0<i);
-	return NULL;
-}
-
-static const char* CPP_echo_reserved_keyword(const char* x,size_t x_len)
-{
-	assert(NULL!=x);
-	assert(x_len<=strlen(x));
-	size_t i = CPP_KEYWORD_STRICT_UB-CPP_KEYWORD_NONSTRICT_LB;
-	do	if (x_len==valid_keyword[CPP_KEYWORD_NONSTRICT_LB + --i].second && !strncmp(valid_keyword[CPP_KEYWORD_NONSTRICT_LB + i].first,x,x_len))
-			return valid_keyword[CPP_KEYWORD_NONSTRICT_LB + i].first;
-	while(0<i);
-	return NULL;
-}
-
-
 namespace C_TYPE {
 
 enum hard_type_indexes {
@@ -3406,27 +3383,7 @@
 			&&	src.empty<1>() && src.empty<2>();
 }
 
-static bool is_naked_brace_pair(const parse_tree& src)
-{
-	return		robust_token_is_char<'{'>(src.index_tokens[0].token)
-			&&	robust_token_is_char<'}'>(src.index_tokens[1].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
-#endif
-			&&	src.empty<1>() && src.empty<2>();
-}
-
-static bool is_naked_bracket_pair(const parse_tree& src)
-{
-	return		robust_token_is_char<'['>(src.index_tokens[0].token)
-			&&	robust_token_is_char<']'>(src.index_tokens[1].token)
-#ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
-#endif
-			&&	src.empty<1>() && src.empty<2>();
-}
-
-#ifndef NDEBUG
 static bool is_array_deref_strict(const parse_tree& src)
 {
 	return		robust_token_is_char<'['>(src.index_tokens[0].token)
@@ -3794,267 +3751,6 @@
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 }
 
-static bool is_C99_anonymous_specifier(const parse_tree& src,const char* const spec_name)
-{
-	if (	robust_token_is_string(src.index_tokens[0].token,spec_name)
-#ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
-#endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
-			&&	1==src.size<2>() && is_naked_brace_pair(*src.data<2>()))
-		return true;
-	return false;
-}
-
-static bool is_C99_named_specifier(const parse_tree& src,const char* const spec_name)
-{
-	if (	robust_token_is_string(src.index_tokens[0].token,spec_name)
-#ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
-#endif
-			&&	NULL!=src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
-			&&	src.empty<2>())
-		return true;
-	return false;
-}
-
-static bool is_C99_named_specifier_definition(const parse_tree& src,const char* const spec_name)
-{
-	if (	robust_token_is_string(src.index_tokens[0].token,spec_name)
-#ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
-#endif
-			&&	NULL!=src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
-			&&	1==src.size<2>() && is_naked_brace_pair(*src.data<2>()))
-		return true;
-	return false;
-}
-
-static bool C99_looks_like_identifier(const parse_tree& x)
-{
-	if (!x.is_atomic()) return false;
-	if (PARSE_TYPE & x.flags) return false;
-	if (C99_echo_reserved_keyword(x.index_tokens[0].token.first,x.index_tokens[0].token.second)) return false;
-	return C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags;
-}
-
-static bool CPP_looks_like_identifier(const parse_tree& x)
-{
-	if (!x.is_atomic()) return false;
-	if (PARSE_TYPE & x.flags) return false;
-	if (CPP_echo_reserved_keyword(x.index_tokens[0].token.first,x.index_tokens[0].token.second)) return false;
-	return C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags;
-}
-
-static void make_target_postfix_arg(parse_tree& src,size_t& offset,const size_t i,const size_t j)
-{
-	parse_tree* tmp = (0==offset ? _new_buffer_nonNULL_throws<parse_tree>(1) :  _new_buffer<parse_tree>(1));
-	if (NULL==tmp)
-		{	// need that slack space now
-		src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
-		offset = 0;
-		tmp = _new_buffer_nonNULL_throws<parse_tree>(1);
-		}
-	*tmp = src.data<0>()[j];
-	src.c_array<0>()[i].fast_set_arg<2>(tmp);
-	src.c_array<0>()[j].clear();
-}
-
-void C99_notice_struct_union_enum(parse_tree& src)
-{
-	assert(!src.empty<0>());
-	size_t i = 0;
-	size_t offset = 0;
-	while(i+offset<src.size<0>())
-		{
-		const char* const tmp2 = robust_token_is_string<4>(src.data<0>()[i],"enum") ? "enum"
-							: robust_token_is_string<6>(src.data<0>()[i],"struct") ? "struct"
-							: robust_token_is_string<5>(src.data<0>()[i],"union") ? "union" : 0;
-		if (tmp2)
-			{
-			if (1>=src.size<0>()-(i+offset))
-				{	// unterminated declaration
-					//! \test zcc/decl.C99/Error_enum_truncate1.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM(tmp2);
-				INC_INFORM(" specifier cut off by end of scope (");
-				INFORM(strcmp(tmp2,"enum") ? "C99 6.7.2.1p1)" : "C99 6.7.2.2p1)");
-				zcc_errors.inc_error();
-				// remove from parse
-				src.DestroyNAtAndRotateTo<0>(1,i,src.size<0>()-offset);
-				offset += 1;
-				continue;
-				};
-			if (is_naked_brace_pair(src.data<0>()[i+1]))
-				{	// anonymous: postfix arg {...}
-				make_target_postfix_arg(src,offset,i,i+1);
-				src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
-				offset += 1;
-				assert(is_C99_anonymous_specifier(src.data<0>()[i],tmp2));
-				if (!src.data<0>()[i].data<2>()->empty<0>())
-					{	// recurse into { ... }
-					src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
-					offset = 0;
-					C99_notice_struct_union_enum(*src.c_array<0>()[i].c_array<2>());
-					};
-				continue;
-				};
-			if (!C99_looks_like_identifier(src.data<0>()[i+1]))
-				{	//! \test zcc/decl.C99/Error_enum_truncate2.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM(tmp2);
-				INC_INFORM(" neither specifier nor definition (");
-				INFORM(strcmp(tmp2,"enum") ? "C99 6.7.2.1p1)" : "C99 6.7.2.2p1)");
-				zcc_errors.inc_error();
-				// remove from parse
-				src.DestroyNAtAndRotateTo<0>(1,i,src.size<0>()-offset);
-				offset += 1;
-				continue;
-				};
-			src.c_array<0>()[i].grab_index_token_from<1,0>(src.c_array<0>()[i+1]);
-			src.c_array<0>()[i].grab_index_token_location_from<1,0>(src.data<0>()[i+1]);
-			src.c_array<0>()[i+1].clear();
-			if (2<src.size<0>()-(i+offset) && is_naked_brace_pair(src.data<0>()[i+2]))
-				{
-				make_target_postfix_arg(src,offset,i,i+2);
-				src.DestroyNAtAndRotateTo<0>(2,i+1,src.size<0>()-offset);
-				offset += 2;
-				assert(is_C99_named_specifier_definition(src.data<0>()[i],tmp2));
-				if (!src.data<0>()[i].data<2>()->empty<0>())
-					{	// recurse into { ... }
-					src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
-					offset = 0;
-					C99_notice_struct_union_enum(*src.c_array<0>()[i].c_array<2>());
-					};
-				continue;
-				};
-			src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
-			offset += 1;
-			assert(is_C99_named_specifier(src.data<0>()[i],tmp2));
-			continue;
-			}
-		else if (   is_naked_parentheses_pair(src.data<0>()[i])
-				 || is_naked_brace_pair(src.data<0>()[i])
-				 || is_naked_bracket_pair(src.data<0>()[i]))
-			{
-			if (!src.data<0>()[i].empty<0>())
-				{	// recurse into (...)
-				if (0<offset)
-					{
-					src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
-					offset = 0;
-					};
-				C99_notice_struct_union_enum(src.c_array<0>()[i]);
-				}
-			}
-		++i;
-		};
-	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
-}
-
-void CPP_notice_class_struct_union_enum(parse_tree& src)
-{
-	assert(!src.empty<0>());
-	size_t i = 0;
-	size_t offset = 0;
-	while(i+offset<src.size<0>())
-		{
-		const char* const tmp2 = robust_token_is_string<4>(src.data<0>()[i],"enum") ? "enum"
-							: robust_token_is_string<6>(src.data<0>()[i],"struct") ? "struct"
-							: robust_token_is_string<5>(src.data<0>()[i],"union") ? "union"
-							: robust_token_is_string<5>(src.data<0>()[i],"class") ? "class" : 0;
-		if (tmp2)
-			{
-			if (1>=src.size<0>()-(i+offset))
-				{	// unterminated declaration
-					//! \test zcc/decl.C99/Error_enum_truncate1.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM(tmp2);
-				INC_INFORM(" specifier cut off by end of scope (");
-				INFORM(strcmp(tmp2,"enum") ? "C++98 9p1)" : "C++98 7.2p1)");
-				zcc_errors.inc_error();
-				// remove from parse
-				src.DestroyNAtAndRotateTo<0>(1,i,src.size<0>()-offset);
-				offset += 1;
-				continue;
-				};
-			if (is_naked_brace_pair(src.data<0>()[i+1]))
-				{	// anonymous: postfix arg {...}
-				make_target_postfix_arg(src,offset,i,i+1);
-				src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
-				offset += 1;
-				assert(is_C99_anonymous_specifier(src.data<0>()[i],tmp2));
-				if (!src.data<0>()[i].data<2>()->empty<0>())
-					{	// recurse into { ... }
-					src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
-					offset = 0;
-					CPP_notice_class_struct_union_enum(*src.c_array<0>()[i].c_array<2>());
-					};
-				continue;
-				};
-			if (!CPP_looks_like_identifier(src.data<0>()[i+1]))
-				{	//! \test zcc/decl.C99/Error_enum_truncate2.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM(tmp2);
-				INC_INFORM(" neither specifier nor definition (");
-				INFORM(strcmp(tmp2,"enum") ? "C++98 9p1)" : "C++98 7.2p1)");
-				zcc_errors.inc_error();
-				// remove from parse
-				src.DestroyNAtAndRotateTo<0>(1,i,src.size<0>()-offset);
-				offset += 1;
-				continue;
-				};
-			src.c_array<0>()[i].grab_index_token_from<1,0>(src.c_array<0>()[i+1]);
-			src.c_array<0>()[i].grab_index_token_location_from<1,0>(src.data<0>()[i+1]);
-			src.c_array<0>()[i+1].clear();
-			if (2<src.size<0>()-(i+offset) && is_naked_brace_pair(src.data<0>()[i+2]))
-				{
-				make_target_postfix_arg(src,offset,i,i+2);
-				src.DestroyNAtAndRotateTo<0>(2,i+1,src.size<0>()-offset);
-				offset += 2;
-				assert(is_C99_named_specifier_definition(src.data<0>()[i],tmp2));
-				if (!src.data<0>()[i].data<2>()->empty<0>())
-					{	// recurse into { ... }
-					src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
-					offset = 0;
-					CPP_notice_class_struct_union_enum(*src.c_array<0>()[i].c_array<2>());
-					};
-				continue;
-				};
-			src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
-			offset += 1;
-			assert(is_C99_named_specifier(src.data<0>()[i],tmp2));
-			continue;
-			}
-		else if (   is_naked_parentheses_pair(src.data<0>()[i])
-				 || is_naked_brace_pair(src.data<0>()[i])
-				 || is_naked_bracket_pair(src.data<0>()[i]))
-			{
-			if (!src.data<0>()[i].empty<0>())
-				{	// recurse into (...)/{...}/[...]
-				if (0<offset)
-					{
-					src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
-					offset = 0;
-					};
-				CPP_notice_class_struct_union_enum(src.c_array<0>()[i]);
-				}
-			}
-		++i;
-		};
-	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
-}
-
 bool convert_to(umaxint& dest,const C_PPIntCore& src)
 {
 	assert(8==src.radix || 10==src.radix || 16==src.radix);
@@ -9117,133 +8813,6 @@
 }
 
 
-bool CPP_ok_for_toplevel_qualified_name(const parse_tree& x)
-{
-	if (!x.is_atomic()) return false;
-	if (PARSE_PRIMARY_TYPE & x.flags) return false;
-	if (CPP_echo_reserved_keyword(x.index_tokens[0].token.first,x.index_tokens[0].token.second)) return false;
-	if (C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags) return true;
-	if (token_is_string<2>(x.index_tokens[0].token,"::")) return true;
-	return false;
-}
-
-static void CPP_notice_scope_glue(parse_tree& src)
-{
-	assert(!src.empty<0>());
-	size_t i = 0;
-	{
-	size_t offset = 0;
-	while(i+offset<src.size<0>())
-		{
-		if (robust_token_is_string<2>(src.data<0>()[i],"::"))
-			{
-			const bool is_global = (0<i) && !CPP_ok_for_toplevel_qualified_name(src.data<0>()[i-1]);
-			size_t resize_to = src.data<0>()[i].index_tokens[0].token.second;
-			size_t forward_span = 0;
-			bool last_scope = true;
-			bool have_suppressed_consecutive_scope = false;
-			while(i+offset+forward_span+1<src.size<0>() && CPP_ok_for_toplevel_qualified_name(src.data<0>()[i+forward_span+1]))
-				{
-				const bool this_scope = robust_token_is_string<2>(src.data<0>()[i+forward_span+1],"::");
-				if (!last_scope && !this_scope) break;
-				if (last_scope && this_scope)
-					{
-					if (!have_suppressed_consecutive_scope)
-						{	//! \test zcc/decl.C99/Error_consecutive_doublecolon_type.hpp
-						simple_error(src.c_array<0>()[i]," consecutive :: operators in nested-name-specifier");
-						have_suppressed_consecutive_scope = true;
-						}
-					// remove from parse
-					src.DestroyNAtAndRotateTo<0>(1,i+forward_span,src.size<0>()-offset);
-					offset += 1;
-					continue;
-					}
-				last_scope = this_scope;
-				++forward_span;
-				resize_to += src.data<0>()[i+forward_span].index_tokens[0].token.second;
-				};
-			// assemble this into something identifier-like
-			if (!is_global)
-				{
-				--i;
-				++forward_span;
-				resize_to += src.data<0>()[i].index_tokens[0].token.second;
-				};
-			if (0<forward_span)
-				{
-				char* tmp = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(resize_to));
-				if (NULL==tmp)
-					{
-					if (0==offset) throw std::bad_alloc();
-					src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
-					offset = 0;
-					tmp = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(resize_to));
-					};
-				strncpy(tmp,src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].token.second);
-				size_t j = 1;
-				do	strncat(tmp,src.data<0>()[i+j].index_tokens[0].token.first,src.data<0>()[i+j].index_tokens[0].token.second);
-				while(forward_span>= ++j);
-				const char* tmp2 = is_string_registered(tmp);
-				if (NULL==tmp2)
-					{
-					src.c_array<0>()[i].grab_index_token_from_str_literal<0>(tmp,C_TESTFLAG_IDENTIFIER);	// well...not really, but it'll substitute for one
-					src.c_array<0>()[i].control_index_token<0>(true);
-					}
-				else{
-					free(tmp);
-					src.c_array<0>()[i].grab_index_token_from_str_literal<0>(tmp2,C_TESTFLAG_IDENTIFIER);	// well...not really, but it'll substitute for one
-					};
-				j = 1;
-				do	src.c_array<0>()[i+j].destroy();
-				while(forward_span>= ++j);
-				src.DestroyNAtAndRotateTo<0>(forward_span,i+1,src.size<0>()-offset);
-				offset += forward_span;
-				};
-			if (last_scope)
-				{	// might be able to save: new, delete, operator ___, destructor name
-				if (	i+offset+1>=src.size<0>()
-					||	(   !robust_token_is_string<3>(src.data<0>()[i+1],"new")
-						 && !robust_token_is_string<6>(src.data<0>()[i+1],"delete")
-						 && !robust_token_is_string<8>(src.data<0>()[i+1],"operator")
-						 && !robust_token_is_char<'~'>(src.data<0>()[i+1])))	// no, compl does not interoperate for destructor names
-					//! \test zcc/decl.C99/Error_doublecolon_type.hpp
-					simple_error(src.c_array<0>()[i]," nested-name-specifier ending in ::");
-				}
-			};
-		++i;
-		};
-	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
-	}
-
-	// efficiency tuning: we have to have no empty slots at top level before recursing,
-	// to mitigate risk of dynamic memory allocation failure
-	i = 0;
-	while(i<src.size<0>())
-		{
-		parse_tree& tmp = src.c_array<0>()[i];
-		if (is_naked_parentheses_pair(tmp))
-			{
-			if (!tmp.empty<0>())
-				// recurse into (...)
-				CPP_notice_scope_glue(tmp);
-			}
-		else if (is_naked_brace_pair(tmp))
-			{
-			if (!tmp.empty<0>())
-				// recurse into {...}
-				CPP_notice_scope_glue(tmp);
-			}
-		else if (is_naked_bracket_pair(tmp))
-			{
-			if (!tmp.empty<0>())
-				// recurse into [...]
-				CPP_notice_scope_glue(tmp);
-			}
-		++i;
-		};
-}
-
-
 //! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
 bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
 {
@@ -9870,338 +9439,6 @@
 		};
 }
 
-//! \todo should this be a type_system member?
-static bool check_for_typedef(type_spec& dest,const char* const src,const type_system& types)
-{
-	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(src);
-	if (NULL!=tmp)
-		{	//! \todo C++: check for access control if source ends up being a class or struct
-		value_copy(dest,tmp->first);
-		return true;
-		}
-	return false;
-}
-
-//! \todo should this be a type_system member?
-static bool check_for_typedef(type_spec& dest,const char* const src,const char* const active_namespace,const type_system& types)
-{
-	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef_CPP(src,active_namespace);
-	if (NULL!=tmp)
-		{	//! \todo C++: check for access control if source ends up being a class or struct
-		value_copy(dest,tmp->first);
-		return true;
-		}
-	return false;
-}
-
-//! \todo does this need to be in ParseTree.hpp?
-static size_t 
-flush_token(parse_tree& x, const size_t i, const size_t n, const char* const target)
-{
-	assert(x.size<0>()>i);
-	assert(x.size<0>()-i>=n);
-	size_t offset = 0;
-	size_t j = 0;
-	do	if (robust_token_is_string(x.data<0>()[i+j],target))
-			++offset;
-		else if (0<offset)
-			x.c_array<0>()[i+j-offset] = x.data<0>()[i+j];
-	while(n> ++j);
-	if (0<offset)
-		{
-		j = offset;
-		while(0<j) x.c_array<0>()[i+n- j--].clear();
-		x.DeleteNSlotsAt<0>(offset,i+n-offset);
-		}
-	return offset;
-}
-
-class C99_decl_specifier_scanner
-{
-private:
-	size_t decl_count[CHAR_BIT*sizeof(uintmax_t)];
-	uintmax_t flags;
-	type_spec base_type;
-	const type_system& types;
-public:
-	C99_decl_specifier_scanner(const type_system& _types) : flags(0),types(_types)
-		{
-		clear(decl_count);
-		base_type.clear();
-		};
-	// trivial destructor, copy constructor, assignment fine
-	bool operator()(const parse_tree& x)
-		{
-		BOOST_STATIC_ASSERT(CHAR_BIT*sizeof(uintmax_t)>=STATIC_SIZE(C99_decl_specifiers));
-		if (!x.is_atomic()) return false;
-		const errr Idx = linear_find(x.index_tokens[0].token.first,x.index_tokens[0].token.second,C99_decl_specifiers,STATIC_SIZE(C99_decl_specifiers));
-		if (0<=Idx)
-			{
-			flags |= (1ULL<<Idx);
-			++decl_count[Idx];
-			return true;
-			};
-		// not a decl-specifier; bail out if we already have a type
-		if (base_type.base_type_index) return false;
-		if (PARSE_PRIMARY_TYPE & x.flags)
-			{
-			value_copy(base_type,x.type_code);
-			return true;
-			}
-		// handle typedefs
-		if (check_for_typedef(base_type,x.index_tokens[0].token.first,types)) return true;
-		//! \todo handle other known types
-#if 0
-		// we must accept any specifier here: C99 6.7.2p1
-		if (   is_C99_anonymous_specifier(x,"enum")
-			|| is_C99_named_specifier(x,"enum")
-			|| is_C99_named_specifier_definition(x,"enum"))
-			return true;
-		if (   is_C99_anonymous_specifier(x,"struct")
-			|| is_C99_named_specifier(x,"struct")
-			|| is_C99_named_specifier_definition(x,"struct"))
-			return true;
-		if (   is_C99_anonymous_specifier(x,"union")
-			|| is_C99_named_specifier(x,"union")
-			|| is_C99_named_specifier_definition(x,"union"))
-			return true;
-#endif
-		return false;
-		};
-	bool analyze_flags_global(parse_tree& x, size_t i, size_t& decl_count)
-		{
-		assert(x.size<0>()>i);
-		assert(x.size<0>()-i>=decl_count);
-		if ((C99_CPP0X_DECLSPEC_TYPEDEF | C99_CPP0X_DECLSPEC_REGISTER | C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN | C99_DECLSPEC_AUTO) & flags)
-			{	// storage class specifiers
-			const char* specs[5];
-			unsigned int storage_count = 0;
-			unsigned int erased_count = 0;
-			if (C99_CPP0X_DECLSPEC_TYPEDEF & flags)
-				specs[storage_count++] = "typedef";
-			if (C99_CPP0X_DECLSPEC_STATIC & flags)
-				specs[storage_count++] = "static";
-			if (C99_CPP0X_DECLSPEC_EXTERN & flags)
-				specs[storage_count++] = "extern";
-			if (C99_CPP0X_DECLSPEC_REGISTER & flags)
-				{	//! \test zcc/decl.C99/Error_register_global.h
-				//! \todo should be warning for --do-what-i-mean
-				specs[storage_count++] = "register";
-				++erased_count;
-				message_header(x.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("storage-class specifier register disallowed at translation-unit level (C99 6.9p2)");
-				zcc_errors.inc_error();
-				decl_count -= flush_token(x,i,decl_count,"register");
-				flags &= ~C99_CPP0X_DECLSPEC_REGISTER;
-				}
-			if (C99_DECLSPEC_AUTO & flags)
-				{	//! \test zcc/decl.C99/Error_auto_global.h
-				//! \todo should be warning for --do-what-i-mean
-				specs[storage_count++] = "auto";
-				++erased_count;
-				message_header(x.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("storage-class specifier auto disallowed at translation-unit level (C99 6.9p2)");
-				zcc_errors.inc_error();
-				decl_count -= flush_token(x,i,decl_count,"auto");
-				flags &= ~C99_DECLSPEC_AUTO;
-				};
-			if (1<storage_count)
-				{	//! \test zcc/decl.C99/Error_extern_static.h
-					//! \test zcc/decl.C99/Error_extern_typedef.h
-					//! \test zcc/decl.C99/Error_static_typedef.h
-					//! \test zcc/decl.C99/Error_extern_static_typedef.h
-				message_header(x.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("declaration has too many storage-class specifiers: ");
-				INFORM_separated_list(specs,storage_count,", ");
-				INFORM(" (C99 6.7.1p2)");
-				zcc_errors.inc_error();
-				};
-			storage_count -= erased_count;
-			// inline requires a function type
-			// typedef must have a function type to tolerate anything (but kills inline)
-			return 1>=storage_count;
-			};
-		return true;
-		}
-	void fixup_type() { base_type.qualifier<0>() |= ((C99_CPP0X_DECLSPEC_CONST | C99_CPP0X_DECLSPEC_VOLATILE) & flags); };
-	uintmax_t get_flags() const {return flags;};
-	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
-};
-
-class CPP0X_decl_specifier_scanner
-{
-private:
-	size_t decl_count[CHAR_BIT*sizeof(uintmax_t)];
-	uintmax_t flags;
-	type_spec base_type;
-	const type_system& types;
-	// these two might belong in a koenig_lookup object
-	const char* const active_namespace;
-public:
-	CPP0X_decl_specifier_scanner(const type_system& _types,const char* const _active_namespace) : flags(0),types(_types),active_namespace(_active_namespace)
-		{
-		clear(decl_count);
-		base_type.clear();
-		}
-	// trivial destructor, copy constructor, assignment fine
-	bool operator()(parse_tree& x,const size_t i)
-		{
-		BOOST_STATIC_ASSERT(CHAR_BIT*sizeof(uintmax_t)>=STATIC_SIZE(CPP0X_decl_specifiers));
-		assert(x.size<0>()>i);
-		if (!x.data<0>()[i].is_atomic()) return false;
-		const errr Idx = linear_find(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second,CPP0X_decl_specifiers,STATIC_SIZE(CPP0X_decl_specifiers));
-		if (0<=Idx)
-			{
-			flags |= (1ULL<<Idx);
-			++decl_count[Idx];
-			return true;
-			};
-		// not a decl-specifier; bail out if we already have a type
-		if (base_type.base_type_index) return false;
-		if (PARSE_PRIMARY_TYPE & x.data<0>()[i].flags)
-			{
-			value_copy(base_type,x.data<0>()[i].type_code);
-			return true;
-			}
-		{	// handle typedefs
-		// determine what fully-qualified name would be
-		if (   x.data<0>()[i].is_atomic()
-			&& !(PARSE_TYPE & x.data<0>()[i].flags)
-			&& !CPP_echo_reserved_keyword(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second)
-			&& (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags))
-			{	// shove Koenig lookup into type_system
-#if 0
-			if (check_for_typedef(base_type,x.data<0>()[i].index_tokens[0].token.first+2,active_namespace,types)) return true;
-			if (check_for_enum(base_type,x.data<0>()[i].index_tokens[0].token.first+2,active_namespace,types)) return true;
-			if (check_for_class_struct_union(base_type,x.data<0>()[i].index_tokens[0].token.first+2,active_namespace,types)) return true;
-			return false;
-#else
-			return check_for_typedef(base_type,x.data<0>()[i].index_tokens[0].token.first,active_namespace,types);
-#endif
-			}
-		}
-		//! \todo handle other known types
-#if 0
-		// we must accept any specifier here: C++0X 7.1.6.2p1
-		if (   is_C99_anonymous_specifier(x,"enum")
-			|| is_C99_named_specifier(x,"enum")
-			|| is_C99_named_specifier_definition(x,"enum"))
-			return true;
-		if (   is_C99_anonymous_specifier(x,"struct")
-			|| is_C99_named_specifier(x,"struct")
-			|| is_C99_named_specifier_definition(x,"struct"))
-			return true;
-		if (   is_C99_anonymous_specifier(x,"union")
-			|| is_C99_named_specifier(x,"union")
-			|| is_C99_named_specifier_definition(x,"union"))
-			return true;
-		if (   is_C99_anonymous_specifier(x,"class")
-			|| is_C99_named_specifier(x,"class")
-			|| is_C99_named_specifier_definition(x,"class"))
-			return true;
-#endif
-		return false;
-		};
-	bool analyze_flags_global(parse_tree& x, size_t i, size_t& decl_count)
-		{
-		assert(x.size<0>()>i);
-		assert(x.size<0>()-i>=decl_count);
-		if ((C99_CPP0X_DECLSPEC_TYPEDEF | C99_CPP0X_DECLSPEC_REGISTER | C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN | CPP_DECLSPEC_MUTABLE | CPP_DECLSPEC_VIRTUAL | CPP_DECLSPEC_EXPLICIT | CPP_DECLSPEC_FRIEND) & flags)
-			{	// storage class specifiers
-			const char* specs[5];
-			unsigned int storage_count = 0;
-			unsigned int erased_count = 0;
-			if (C99_CPP0X_DECLSPEC_TYPEDEF & flags)
-				specs[storage_count++] = "typedef";
-			if (C99_CPP0X_DECLSPEC_STATIC & flags)
-				specs[storage_count++] = "static";
-			if (C99_CPP0X_DECLSPEC_EXTERN & flags)
-				specs[storage_count++] = "extern";
-			if (C99_CPP0X_DECLSPEC_REGISTER & flags)
-				{	//! \test zcc/default/decl.C99/Error_register_global.hpp
-				//! \todo should be warning for --do-what-i-mean
-				specs[storage_count++] = "register";
-				++erased_count;
-				message_header(x.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("storage-class specifier register allowed only to objects named in a block, or function parameters (C++98 7.1.1p2)");
-				zcc_errors.inc_error();
-				decl_count -= flush_token(x,i,decl_count,"register");
-				flags &= ~C99_CPP0X_DECLSPEC_REGISTER;
-				}
-			if (CPP_DECLSPEC_MUTABLE & flags)
-				{	//! \test zcc/default/decl.C99/Error_mutable_global.hpp
-				//! \todo should be warning for --do-what-i-mean
-				specs[storage_count++] = "mutable";
-				++erased_count;
-				message_header(x.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("storage-class specifier mutable only allowed for non-static non-const non-reference class data members (C++0X 7.1.1p10)");
-				zcc_errors.inc_error();
-				decl_count -= flush_token(x,i,decl_count,"mutable");
-				flags &= ~CPP_DECLSPEC_MUTABLE;
-				};
-			if (1<storage_count)
-				{	//! \test zcc/decl.C99/Error_extern_static.hpp
-					//! \test zcc/decl.C99/Error_extern_typedef.hpp
-					//! \test zcc/decl.C99/Error_static_typedef.hpp
-					//! \test zcc/decl.C99/Error_extern_static_typedef.hpp
-				//! \todo should be warning for --do-what-i-mean
-				message_header(x.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INC_INFORM("declaration has too many storage-class specifiers: ");
-				INFORM_separated_list(specs,storage_count,", ");
-				INFORM(" (C++0X 7.1.1p1)");
-				zcc_errors.inc_error();
-				}
-			storage_count -= erased_count;
-			// thread_local ok at namespace scope for objects/references
-			// inline dies if not a function type
-			// typedef must have a function type to tolerate anything (but kills inline)
-			// virtual and explicit can only be used in class declarations: erase (C++0X 7.1.2p5, 7.1.2p6
-			if (CPP_DECLSPEC_VIRTUAL & flags)
-				{	//! \test zcc/default/decl.C99/Error_virtual_global.hpp
-				//! \todo should be warning for --do-what-i-mean
-				message_header(x.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("function specifier virtual allowed only for class member functions (C++98 7.1.2p5)");
-				zcc_errors.inc_error();
-				decl_count -= flush_token(x,i,decl_count,"virtual");
-				flags &= ~CPP_DECLSPEC_VIRTUAL;
-				};
-			if (CPP_DECLSPEC_EXPLICIT & flags)
-				{	//! \test zcc/default/decl.C99/Error_explicit_global.hpp
-				//! \todo should be warning for --do-what-i-mean
-				message_header(x.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("function specifier explicit allowed only for constructors (C++98 7.1.2p6)");
-				zcc_errors.inc_error();
-				decl_count -= flush_token(x,i,decl_count,"explicit");
-				flags &= ~CPP_DECLSPEC_EXPLICIT;
-				};
-			// friend is only usable within a class
-			if (CPP_DECLSPEC_FRIEND & flags)
-				{	//! \test zcc/default/decl.C99/Error_friend_global.hpp
-				//! \todo should be warning for --do-what-i-mean
-				message_header(x.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("decl-specifier friend only useful within a class definition (C++98 7.1.4)");
-				zcc_errors.inc_error();
-				decl_count -= flush_token(x,i,decl_count,"friend");
-				flags &= ~CPP_DECLSPEC_FRIEND;
-				};
-			return 1>=storage_count;
-			};
-		return true;
-		};
-	void fixup_type() { base_type.qualifier<0>() |= ((C99_CPP0X_DECLSPEC_CONST | C99_CPP0X_DECLSPEC_VOLATILE) & flags); };
-	uintmax_t get_flags() const {return flags;};
-	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
-};
-
 size_t C99_init_declarator_scanner(const parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
 {
 	assert(x.size<0>()>i);



From zaimoni at mail.berlios.de  Tue Mar  9 04:47:10 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 9 Mar 2010 04:47:10 +0100
Subject: [Zcplusplus-commits] r348 - trunk
Message-ID: <201003090347.o293lAHd010126@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-09 04:47:01 +0100 (Tue, 09 Mar 2010)
New Revision: 348

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/unsigned_var_int.cpp
   trunk/unsigned_var_int.hpp
Log:
enumeration support for +- operators

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-08 20:05:37 UTC (rev 347)
+++ trunk/CSupport.cpp	2010-03-09 03:47:01 UTC (rev 348)
@@ -5235,6 +5235,52 @@
 	_label_one_literal(dest,types);
 	return dest;
 }
+
+static void force_unary_positive_literal(parse_tree& dest,const parse_tree& src)
+{
+	assert(0==dest.size<0>());
+	assert(0==dest.size<1>());
+	assert(1==dest.size<2>());
+	assert(NULL==dest.index_tokens[1].token.first);
+	dest.grab_index_token_from_str_literal<0>("+",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
+	*dest.c_array<2>() = src;
+	dest.core_flag_update();
+	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
+	dest.subtype = C99_UNARY_SUBTYPE_PLUS;
+	assert(NULL!=dest.index_tokens[0].src_filename);
+	assert(is_C99_unary_operator_expression<'+'>(dest));
+}
+
+static void force_unary_negative_token(parse_tree& dest,parse_tree* src,const parse_tree& loc_src)
+{
+	assert(NULL!=src);
+	dest.clear();
+	dest.grab_index_token_from_str_literal<0>("-",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
+	dest.grab_index_token_location_from<0,0>(loc_src);
+	dest.fast_set_arg<2>(src);
+	dest.core_flag_update();
+	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
+	dest.subtype = C99_UNARY_SUBTYPE_NEG;
+	// do not handle type here: C++ operator overloading risk
+	assert(NULL!=dest.index_tokens[0].src_filename);
+	assert(is_C99_unary_operator_expression<'-'>(dest));
+}
+
+// this one hides a slight inefficiency: negative literals take 2 dynamic memory allocations, positive literals take one
+// return code is true for success, false for memory failure
+static bool VM_to_signed_literal(parse_tree& x,const bool is_negative, const umaxint& src_int,const parse_tree& src,const type_system& types)
+{
+	if (is_negative)
+		{
+		parse_tree* tmp = _new_buffer<parse_tree>(1);
+		if (NULL==tmp) return false;
+		if (!VM_to_literal(*tmp,src_int,src,types)) return false;
+		force_unary_negative_token(x,tmp,*tmp);
+		}
+	else if (!VM_to_literal(x,src_int,src,types))
+		return false;
+	return true;
+}
 #/*cut-cpp*/
 
 static const enum_def* is_noticed_enumerator(const parse_tree& x,const type_system& types)
@@ -5244,8 +5290,29 @@
 		tmp = types.get_enum_def(x.type_code.base_type_index);
 	return tmp;
 }
+
+static bool enumerator_to_integer_representation(parse_tree& x,const type_system& types)
+{
+	parse_tree tmp3;
+	const type_system::enumerator_info* const tmp2 = types.get_enumerator(x.index_tokens[0].token.first);
+	assert(tmp2);
+	const promote_aux dest_type(tmp2->second.first.second);
+	{
+	umaxint res_int(tmp2->second.first.third);
+	const bool tmp_negative = dest_type.is_signed && res_int.test(dest_type.bitcount-1);
+	if (!VM_to_signed_literal(tmp3,tmp_negative,res_int,x,types)) return false;
+	}
+	x.destroy();
+	x = tmp3;
+	return true;
+}
 #/*cut-cpp*/
 
+static bool is_integerlike_literal(const parse_tree& x)
+{
+	return converts_to_integerlike(x.type_code) && (PARSE_PRIMARY_EXPRESSION & x.flags);
+}
+
 static bool eval_unary_plus(parse_tree& src, const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'+'>(src));
@@ -5259,28 +5326,13 @@
 			return true;
 			}
 		return false;
-		}
+		};
 #/*cut-cpp*/
-#if 0-0
-	else if (is_noticed_enumerator(*src.data<2>(),types))
-		{
-		parse_tree tmp3;
-		const promote_aux dest_type(src.type_code.base_type_index);
-		const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.data<2>()->index_tokens[0].token.first);
-		assert(tmp2);
-		{
-		umaxint res_int;
-		const bool tmp_negative = target_machine->C_promote_integer(res_int,umaxint(tmp2->second.first.third),dest_type);
-		if (!VM_to_signed_literal(tmp3,tmp_negative,res_int,*src.data<2>(),types) return false;
-		}
-		src.destroy();
-		src = tmp3;
-		return true;
-		}
-#endif
+	if (is_noticed_enumerator(*src.data<2>(),types))
+		if (!enumerator_to_integer_representation(*src.c_array<2>(),types)) return false;
 #/*cut-cpp*/
  	// handle integer-like literals like a real integer literal
-	else if (converts_to_integerlike(src.data<2>()->type_code) && (PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+	if (is_integerlike_literal(*src.data<2>()))
 		{
 		const type_spec old_type = src.type_code;
 		src.eval_to_arg<2>(0);
@@ -5302,7 +5354,11 @@
 		src.type_code = old_type;		
 		return true;
 		};
-	if (converts_to_integer(src.data<2>()->type_code) && 1==(src.type_code.base_type_index-C_TYPE::INT)%2 && (PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+#/*cut-cpp*/
+	if (is_noticed_enumerator(*src.data<2>(),types))
+		if (enumerator_to_integer_representation(*src.c_array<2>(),types)) return false;
+#/*cut-cpp*/
+	if (is_integerlike_literal(*src.data<2>()) && 1==(src.type_code.base_type_index-C_TYPE::INT)%2)
 		{	// unsigned...we're fine
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
 		const type_spec old_type = src.type_code;
@@ -5656,36 +5712,6 @@
 	assert(is_C99_unary_operator_expression<'-'>(dest));
 }
 
-static void force_unary_positive_literal(parse_tree& dest,const parse_tree& src)
-{
-	assert(0==dest.size<0>());
-	assert(0==dest.size<1>());
-	assert(1==dest.size<2>());
-	assert(NULL==dest.index_tokens[1].token.first);
-	dest.grab_index_token_from_str_literal<0>("+",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
-	*dest.c_array<2>() = src;
-	dest.core_flag_update();
-	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
-	dest.subtype = C99_UNARY_SUBTYPE_PLUS;
-	assert(NULL!=dest.index_tokens[0].src_filename);
-	assert(is_C99_unary_operator_expression<'+'>(dest));
-}
-
-static void force_unary_negative_token(parse_tree& dest,parse_tree* src,const parse_tree& loc_src)
-{
-	assert(NULL!=src);
-	dest.clear();
-	dest.grab_index_token_from_str_literal<0>("-",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
-	dest.grab_index_token_location_from<0,0>(loc_src);
-	dest.fast_set_arg<2>(src);
-	dest.core_flag_update();
-	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
-	dest.subtype = C99_UNARY_SUBTYPE_NEG;
-	// do not handle type here: C++ operator overloading risk
-	assert(NULL!=dest.index_tokens[0].src_filename);
-	assert(is_C99_unary_operator_expression<'-'>(dest));
-}
-
 static bool terse_locate_C99_bitwise_complement(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6829,22 +6855,6 @@
 	return false;
 }
 
-// this one hides a slight inefficiency: negative literals take 2 dynamic memory allocations, positive literals take one
-// return code is true for success, false for memory failure
-static bool VM_to_signed_literal(parse_tree& x,const bool is_negative, const umaxint& src_int,const parse_tree& src,const type_system& types)
-{
-	if (is_negative)
-		{
-		parse_tree* tmp = _new_buffer<parse_tree>(1);
-		if (NULL==tmp) return false;
-		if (!VM_to_literal(*tmp,src_int,src,types)) return false;
-		force_unary_negative_token(x,tmp,*tmp);
-		}
-	else if (!VM_to_literal(x,src_int,src,types))
-		return false;
-	return true;
-}
-
 static bool eval_add_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'+'>(src));

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-08 20:05:37 UTC (rev 347)
+++ trunk/CSupport_pp.cpp	2010-03-09 03:47:01 UTC (rev 348)
@@ -4847,6 +4847,57 @@
 	return dest;
 }
 
+static void force_unary_positive_literal(parse_tree& dest,const parse_tree& src)
+{
+	assert(0==dest.size<0>());
+	assert(0==dest.size<1>());
+	assert(1==dest.size<2>());
+	assert(NULL==dest.index_tokens[1].token.first);
+	dest.grab_index_token_from_str_literal<0>("+",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
+	*dest.c_array<2>() = src;
+	dest.core_flag_update();
+	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
+	dest.subtype = C99_UNARY_SUBTYPE_PLUS;
+	assert(NULL!=dest.index_tokens[0].src_filename);
+	assert(is_C99_unary_operator_expression<'+'>(dest));
+}
+
+static void force_unary_negative_token(parse_tree& dest,parse_tree* src,const parse_tree& loc_src)
+{
+	assert(NULL!=src);
+	dest.clear();
+	dest.grab_index_token_from_str_literal<0>("-",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
+	dest.grab_index_token_location_from<0,0>(loc_src);
+	dest.fast_set_arg<2>(src);
+	dest.core_flag_update();
+	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
+	dest.subtype = C99_UNARY_SUBTYPE_NEG;
+	// do not handle type here: C++ operator overloading risk
+	assert(NULL!=dest.index_tokens[0].src_filename);
+	assert(is_C99_unary_operator_expression<'-'>(dest));
+}
+
+// this one hides a slight inefficiency: negative literals take 2 dynamic memory allocations, positive literals take one
+// return code is true for success, false for memory failure
+static bool VM_to_signed_literal(parse_tree& x,const bool is_negative, const umaxint& src_int,const parse_tree& src,const type_system& types)
+{
+	if (is_negative)
+		{
+		parse_tree* tmp = _new_buffer<parse_tree>(1);
+		if (NULL==tmp) return false;
+		if (!VM_to_literal(*tmp,src_int,src,types)) return false;
+		force_unary_negative_token(x,tmp,*tmp);
+		}
+	else if (!VM_to_literal(x,src_int,src,types))
+		return false;
+	return true;
+}
+
+static bool is_integerlike_literal(const parse_tree& x)
+{
+	return converts_to_integerlike(x.type_code) && (PARSE_PRIMARY_EXPRESSION & x.flags);
+}
+
 static bool eval_unary_plus(parse_tree& src, const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'+'>(src));
@@ -4860,9 +4911,9 @@
 			return true;
 			}
 		return false;
-		}
+		};
  	// handle integer-like literals like a real integer literal
-	else if (converts_to_integerlike(src.data<2>()->type_code) && (PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+	if (is_integerlike_literal(*src.data<2>()))
 		{
 		const type_spec old_type = src.type_code;
 		src.eval_to_arg<2>(0);
@@ -4884,7 +4935,7 @@
 		src.type_code = old_type;		
 		return true;
 		};
-	if (converts_to_integer(src.data<2>()->type_code) && 1==(src.type_code.base_type_index-C_TYPE::INT)%2 && (PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+	if (is_integerlike_literal(*src.data<2>()) && 1==(src.type_code.base_type_index-C_TYPE::INT)%2)
 		{	// unsigned...we're fine
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
 		const type_spec old_type = src.type_code;
@@ -5220,36 +5271,6 @@
 	assert(is_C99_unary_operator_expression<'-'>(dest));
 }
 
-static void force_unary_positive_literal(parse_tree& dest,const parse_tree& src)
-{
-	assert(0==dest.size<0>());
-	assert(0==dest.size<1>());
-	assert(1==dest.size<2>());
-	assert(NULL==dest.index_tokens[1].token.first);
-	dest.grab_index_token_from_str_literal<0>("+",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
-	*dest.c_array<2>() = src;
-	dest.core_flag_update();
-	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
-	dest.subtype = C99_UNARY_SUBTYPE_PLUS;
-	assert(NULL!=dest.index_tokens[0].src_filename);
-	assert(is_C99_unary_operator_expression<'+'>(dest));
-}
-
-static void force_unary_negative_token(parse_tree& dest,parse_tree* src,const parse_tree& loc_src)
-{
-	assert(NULL!=src);
-	dest.clear();
-	dest.grab_index_token_from_str_literal<0>("-",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
-	dest.grab_index_token_location_from<0,0>(loc_src);
-	dest.fast_set_arg<2>(src);
-	dest.core_flag_update();
-	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
-	dest.subtype = C99_UNARY_SUBTYPE_NEG;
-	// do not handle type here: C++ operator overloading risk
-	assert(NULL!=dest.index_tokens[0].src_filename);
-	assert(is_C99_unary_operator_expression<'-'>(dest));
-}
-
 static bool terse_locate_C99_bitwise_complement(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6393,22 +6414,6 @@
 	return false;
 }
 
-// this one hides a slight inefficiency: negative literals take 2 dynamic memory allocations, positive literals take one
-// return code is true for success, false for memory failure
-static bool VM_to_signed_literal(parse_tree& x,const bool is_negative, const umaxint& src_int,const parse_tree& src,const type_system& types)
-{
-	if (is_negative)
-		{
-		parse_tree* tmp = _new_buffer<parse_tree>(1);
-		if (NULL==tmp) return false;
-		if (!VM_to_literal(*tmp,src_int,src,types)) return false;
-		force_unary_negative_token(x,tmp,*tmp);
-		}
-	else if (!VM_to_literal(x,src_int,src,types))
-		return false;
-	return true;
-}
-
 static bool eval_add_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'+'>(src));

Modified: trunk/unsigned_var_int.cpp
===================================================================
--- trunk/unsigned_var_int.cpp	2010-03-08 20:05:37 UTC (rev 347)
+++ trunk/unsigned_var_int.cpp	2010-03-09 03:47:01 UTC (rev 348)
@@ -20,6 +20,12 @@
 	memmove(_data.c_array(),src._data.data(),src._data.size());
 }
 
+unsigned_var_int::unsigned_var_int(const uchar_blob& src)
+{
+	_data.init(src.size());
+	memmove(_data.c_array(),src.data(),src.size());
+}
+
 unsigned_var_int::unsigned_var_int(uintmax_t src)
 {
 	const size_t n = bytes_to_represent(src);

Modified: trunk/unsigned_var_int.hpp
===================================================================
--- trunk/unsigned_var_int.hpp	2010-03-08 20:05:37 UTC (rev 347)
+++ trunk/unsigned_var_int.hpp	2010-03-09 03:47:01 UTC (rev 348)
@@ -18,6 +18,7 @@
 	explicit unsigned_var_int(uintmax_t src);
 	unsigned_var_int(uintmax_t src,size_t bytecount);
 	unsigned_var_int(const unsigned_var_int& src);
+	unsigned_var_int(const uchar_blob& src);
 
 	unsigned_var_int& operator=(const unsigned_var_int& src);
 	unsigned_var_int& operator=(uintmax_t src);



From zaimoni at mail.berlios.de  Wed Mar 10 19:40:20 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 10 Mar 2010 19:40:20 +0100
Subject: [Zcplusplus-commits] r349 - in trunk: tests/zcc tests/zcc/default
	tests/zcc/default/staticassert tests/zcc/staticassert.C1X
	tests/zcc.in tests/zcc.in/default tests/zcc.in/default/staticassert
	tests/zcc.in/staticassert.C1X tools
Message-ID: <201003101840.o2AIeKYe000091@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-10 19:40:08 +0100 (Wed, 10 Mar 2010)
New Revision: 349

Added:
   trunk/tests/zcc.in/default/
   trunk/tests/zcc.in/default/staticassert/
   trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc/default/
   trunk/tests/zcc/default/staticassert/
   trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
   trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp
   trunk/tests/zcc/default/staticassert/Pass_autosuccess2.hpp
Modified:
   trunk/tests/zcc.in/run_tests.in
   trunk/tests/zcc/run_tests.bat
   trunk/tests/zcc/run_tests.sh
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
   trunk/tools/preproc_testbuilder.py
Log:
augment test cases; adjust preproc_testbuilder.py

Added: trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2010-03-09 03:47:01 UTC (rev 348)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2010-03-10 18:40:08 UTC (rev 349)
@@ -0,0 +1,7 @@
+// default\staticassert\Pass_autosuccess.h
+// ZCC-specific check on extended constant expressions common to C and C++
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+// exercise string literal uses in (extended) integer constant expressions
+_Static_Assert("A","automatic success has failed");
+

Added: trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp	2010-03-09 03:47:01 UTC (rev 348)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp	2010-03-10 18:40:08 UTC (rev 349)
@@ -0,0 +1,7 @@
+// default\staticassert\Pass_autosuccess.hpp
+// ZCC-specific check on extended constant expressions common to C and C++
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+// exercise string literal uses in (extended) integer constant expressions
+static_assert("A","automatic success has failed");
+

Added: trunk/tests/zcc/default/staticassert/Pass_autosuccess2.hpp
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess2.hpp	2010-03-09 03:47:01 UTC (rev 348)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess2.hpp	2010-03-10 18:40:08 UTC (rev 349)
@@ -0,0 +1,6 @@
+// tests/zcc/default/staticassert/Pass_autosuccess2.hpp
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+
+// unary operator + is identity for pointers in C++
+static_assert(+"A","automatic success has failed");
+

Modified: trunk/tests/zcc/run_tests.bat
===================================================================
--- trunk/tests/zcc/run_tests.bat	2010-03-09 03:47:01 UTC (rev 348)
+++ trunk/tests/zcc/run_tests.bat	2010-03-10 18:40:08 UTC (rev 349)
@@ -63,6 +63,13 @@
 @for %%f in (staticassert.C1X\Pass*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
 @for %%f in (staticassert.C1X\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
 
+ at echo Checking ZCC implementation-defined errors and features
+ at echo ====
+ at for %%f in (default\staticassert\Pass*.h) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\staticassert\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\staticassert\Pass*.hpp) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\staticassert\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+
 @echo %BAD_PASS% of %REJECT_TEST% rejection tests accepted
 @if not "%BAD_PASS_NAME%"=="LastAccepted:" @echo %BAD_PASS_NAME%
 @echo %FAILED% of %ACCEPT_TEST% acceptance tests rejected

Modified: trunk/tests/zcc/run_tests.sh
===================================================================
--- trunk/tests/zcc/run_tests.sh	2010-03-09 03:47:01 UTC (rev 348)
+++ trunk/tests/zcc/run_tests.sh	2010-03-10 18:40:08 UTC (rev 349)
@@ -53,6 +53,11 @@
 	for F in staticassert.C1X/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 	for F in staticassert.C1X/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 
+	echo Checking ZCC implementation-defined errors and features
+	echo ====
+	for F in default/staticassert/Pass*.h; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/staticassert/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+
 	echo -E $BAD_PASS of $REJECT_TEST rejection tests accepted
 	if test -n "$BAD_PASS_NAME"; then echo -E $BAD_PASS_NAME; fi
 	echo -E $FAILED of $ACCEPT_TEST acceptance tests rejected

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-03-09 03:47:01 UTC (rev 348)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-03-10 18:40:08 UTC (rev 349)
@@ -1,5 +1,13 @@
-// tests/zcc/staticassert.C99/Error_autosuccess.h
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// staticassert.C1X\Pass_autosuccess.h
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
-_Static_Assert(1,"automatic success");
+_Static_Assert(1,"automatic success has failed");
 
+// check unary +
+_Static_Assert(+1,"automatic success has failed");
+_Static_Assert(+'A',"automatic success has failed");
+
+// check unary -
+_Static_Assert(-1,"automatic success has failed");
+_Static_Assert(-'A',"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-03-09 03:47:01 UTC (rev 348)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-03-10 18:40:08 UTC (rev 349)
@@ -1,5 +1,13 @@
-// tests/zcc/staticassert.C99/Error_autosuccess.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// staticassert.C1X\Pass_autosuccess.hpp
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
-static_assert(1,"automatic success");
+static_assert(1,"automatic success has failed");
 
+// check unary +
+static_assert(+1,"automatic success has failed");
+static_assert(+'A',"automatic success has failed");
+
+// check unary -
+static_assert(-1,"automatic success has failed");
+static_assert(-'A',"automatic success has failed");
+

Added: trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2010-03-09 03:47:01 UTC (rev 348)
+++ trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2010-03-10 18:40:08 UTC (rev 349)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+OBJECTLIKE_MACRO STATIC_ASSERT _Static_Assert static_assert
+// ZCC-specific check on extended constant expressions common to C and C++
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+// exercise string literal uses in (extended) integer constant expressions
+STATIC_ASSERT("A","automatic success has failed");
+

Modified: trunk/tests/zcc.in/run_tests.in
===================================================================
--- trunk/tests/zcc.in/run_tests.in	2010-03-09 03:47:01 UTC (rev 348)
+++ trunk/tests/zcc.in/run_tests.in	2010-03-10 18:40:08 UTC (rev 349)
@@ -24,5 +24,8 @@
 PASS CPP_ISO decl.C99/Pass*
 PASS CPP_ISO staticassert.C1X/Pass*
 
+ECHO Checking ZCC implementation-defined errors and features
+PASS CPP default/staticassert/Pass*
+
 EPILOG
 

Added: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-03-09 03:47:01 UTC (rev 348)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-03-10 18:40:08 UTC (rev 349)
@@ -0,0 +1,14 @@
+SUFFIXES h hpp
+OBJECTLIKE_MACRO STATIC_ASSERT _Static_Assert static_assert
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+
+STATIC_ASSERT(1,"automatic success has failed");
+
+// check unary +
+STATIC_ASSERT(+1,"automatic success has failed");
+STATIC_ASSERT(+'A',"automatic success has failed");
+
+// check unary -
+STATIC_ASSERT(-1,"automatic success has failed");
+STATIC_ASSERT(-'A',"automatic success has failed");
+

Modified: trunk/tools/preproc_testbuilder.py
===================================================================
--- trunk/tools/preproc_testbuilder.py	2010-03-09 03:47:01 UTC (rev 348)
+++ trunk/tools/preproc_testbuilder.py	2010-03-10 18:40:08 UTC (rev 349)
@@ -48,6 +48,7 @@
 	test_lines = []
 	suffixes = []
 	include_files = []
+	object_macros = {}
 	with open(filename,'r') as f:
 		for line in f:
 			if line.startswith('SUFFIXES '):
@@ -62,6 +63,20 @@
 				target = line[17:].strip()
 				test_lines.append('#if '+target+'\n')
 				test_lines.append('#endif\n')
+			elif line.startswith('TRUE_EXPRESSION '):
+				target = line[16:].strip()
+				test_lines.append('#if '+target+'\n')
+				test_lines.append('#else\n')
+				test_lines.append('#error '+target+' is false\n')
+				test_lines.append('#endif\n')
+			elif line.startswith('FALSE_EXPRESSION '):
+				target = line[17:].strip()
+				test_lines.append('#if '+target+'\n')
+				test_lines.append('#error '+target+' is true\n')
+				test_lines.append('#endif\n')
+			elif line.startswith('OBJECTLIKE_MACRO '):
+				target = line[17:].strip().split()
+				object_macros[target[0]] = target[1:]
 			else:
 				test_lines.append(line);
 
@@ -74,6 +89,11 @@
 		for line in test_lines:
 			if line.startswith('INCLUDE_FILES '):
 				TargetFile.write('#include <'+include_files[Idx]+'>\n')
+			elif 0<len(object_macros):
+				for x in object_macros.keys():
+					if -1<line.find(x):
+						line = object_macros[x][Idx].join(line.split(x))
+				TargetFile.write(line)
 			else:
 				TargetFile.write(line)
 		TargetFile.close()



From zaimoni at mail.berlios.de  Thu Mar 11 06:55:46 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 11 Mar 2010 06:55:46 +0100
Subject: [Zcplusplus-commits] r350 - trunk
Message-ID: <201003110555.o2B5tkPq005326@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-11 06:55:39 +0100 (Thu, 11 Mar 2010)
New Revision: 350

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/type_system.cpp
Log:
let enumeration support actually cut in a bit

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-10 18:40:08 UTC (rev 349)
+++ trunk/CSupport.cpp	2010-03-11 05:55:39 UTC (rev 350)
@@ -5208,7 +5208,9 @@
 	dest.clear();
 	dest.grab_index_token_from<0>(new_token.first,new_token.second);
 	dest.grab_index_token_location_from<0,0>(src);
+	assert((C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_STRING_LITERAL | C_TESTFLAG_PP_NUMERAL) & dest.index_tokens[0].flags);
 	_label_one_literal(dest,types);
+	assert(PARSE_EXPRESSION & dest.flags);
 	return true;
 }
 
@@ -5253,7 +5255,8 @@
 
 static void force_unary_negative_token(parse_tree& dest,parse_tree* src,const parse_tree& loc_src)
 {
-	assert(NULL!=src);
+	assert(src);
+	assert(PARSE_EXPRESSION & src->flags);
 	dest.clear();
 	dest.grab_index_token_from_str_literal<0>("-",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
 	dest.grab_index_token_location_from<0,0>(loc_src);
@@ -5275,6 +5278,7 @@
 		parse_tree* tmp = _new_buffer<parse_tree>(1);
 		if (NULL==tmp) return false;
 		if (!VM_to_literal(*tmp,src_int,src,types)) return false;
+		assert(PARSE_EXPRESSION & tmp->flags);
 		force_unary_negative_token(x,tmp,*tmp);
 		}
 	else if (!VM_to_literal(x,src_int,src,types))
@@ -5300,8 +5304,17 @@
 	{
 	umaxint res_int(tmp2->second.first.third);
 	const bool tmp_negative = dest_type.is_signed && res_int.test(dest_type.bitcount-1);
-	if (!VM_to_signed_literal(tmp3,tmp_negative,res_int,x,types)) return false;
+	if (tmp_negative) target_machine->signed_additive_inverse(res_int,dest_type.machine_type);
+	{	// pretend x is the type of the enumerator.
+	const type_system::type_index backup = x.type_code.base_type_index;
+	x.type_code.base_type_index = tmp2->second.first.second;
+	if (!VM_to_signed_literal(tmp3,tmp_negative,res_int,x,types))
+		{
+		x.type_code.base_type_index = backup;
+		return false;
+		}
 	}
+	}
 	x.destroy();
 	x = tmp3;
 	return true;
@@ -10474,6 +10487,7 @@
 			{
 			x.set_index_token_from_str_literal<0>(tmp->first);
 			x.type_code.set_type(tmp->second.first.first);
+			x.flags |= PARSE_PRIMARY_EXPRESSION;
 			// XXX would be handy to keep the tmp around, consider as time optimization XXX
 			}
 		}

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-10 18:40:08 UTC (rev 349)
+++ trunk/CSupport_pp.cpp	2010-03-11 05:55:39 UTC (rev 350)
@@ -4819,7 +4819,9 @@
 	dest.clear();
 	dest.grab_index_token_from<0>(new_token.first,new_token.second);
 	dest.grab_index_token_location_from<0,0>(src);
+	assert((C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_STRING_LITERAL | C_TESTFLAG_PP_NUMERAL) & dest.index_tokens[0].flags);
 	_label_one_literal(dest,types);
+	assert(PARSE_EXPRESSION & dest.flags);
 	return true;
 }
 
@@ -4864,7 +4866,8 @@
 
 static void force_unary_negative_token(parse_tree& dest,parse_tree* src,const parse_tree& loc_src)
 {
-	assert(NULL!=src);
+	assert(src);
+	assert(PARSE_EXPRESSION & src->flags);
 	dest.clear();
 	dest.grab_index_token_from_str_literal<0>("-",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
 	dest.grab_index_token_location_from<0,0>(loc_src);
@@ -4886,6 +4889,7 @@
 		parse_tree* tmp = _new_buffer<parse_tree>(1);
 		if (NULL==tmp) return false;
 		if (!VM_to_literal(*tmp,src_int,src,types)) return false;
+		assert(PARSE_EXPRESSION & tmp->flags);
 		force_unary_negative_token(x,tmp,*tmp);
 		}
 	else if (!VM_to_literal(x,src_int,src,types))

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2010-03-10 18:40:08 UTC (rev 349)
+++ trunk/type_system.cpp	2010-03-11 05:55:39 UTC (rev 350)
@@ -384,6 +384,7 @@
 	assert(alias && *alias);
 	assert(src_filename && *src_filename);
 	assert(type);
+	assert(get_enum_def(type));
 	errr tmp = binary_find(alias,strlen(alias),enumerator_registry.data(),enumerator_registry.size());
 	assert(0>tmp);		// error to call with conflicting prior definition
 	if (0<=tmp) return;	// conflicting prior definition



From zaimoni at mail.berlios.de  Fri Mar 12 01:52:16 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 12 Mar 2010 01:52:16 +0100
Subject: [Zcplusplus-commits] r351 - in trunk: . tests/zcc/staticassert.C1X
	tests/zcc.in/staticassert.C1X
Message-ID: <201003120052.o2C0qGCZ006949@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-12 01:52:02 +0100 (Fri, 12 Mar 2010)
New Revision: 351

Added:
   trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
actually bring up enumerator support for +-

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-11 05:55:39 UTC (rev 350)
+++ trunk/CSupport.cpp	2010-03-12 00:52:02 UTC (rev 351)
@@ -5249,6 +5249,8 @@
 	dest.core_flag_update();
 	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	dest.subtype = C99_UNARY_SUBTYPE_PLUS;
+	if (converts_to_arithmeticlike(dest.data<2>()->type_code))
+		dest.type_code = dest.data<2>()->type_code;
 	assert(NULL!=dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'+'>(dest));
 }
@@ -5264,6 +5266,8 @@
 	dest.core_flag_update();
 	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	dest.subtype = C99_UNARY_SUBTYPE_NEG;
+	if (converts_to_arithmeticlike(dest.data<2>()->type_code))
+		dest.type_code = dest.data<2>()->type_code;
 	// do not handle type here: C++ operator overloading risk
 	assert(NULL!=dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'-'>(dest));
@@ -5342,7 +5346,17 @@
 		};
 #/*cut-cpp*/
 	if (is_noticed_enumerator(*src.data<2>(),types))
+		{
 		if (!enumerator_to_integer_representation(*src.c_array<2>(),types)) return false;
+		if (is_C99_unary_operator_expression<'-'>(*src.data<2>()))
+			{	// enumerator went negative: handle
+			parse_tree tmp = *src.c_array<2>();
+			src.c_array<2>()->clear();
+			src.destroy();
+			src = tmp;
+			return true;
+			}
+		}
 #/*cut-cpp*/
  	// handle integer-like literals like a real integer literal
 	if (is_integerlike_literal(*src.data<2>()))
@@ -5369,7 +5383,18 @@
 		};
 #/*cut-cpp*/
 	if (is_noticed_enumerator(*src.data<2>(),types))
-		if (enumerator_to_integer_representation(*src.c_array<2>(),types)) return false;
+		{
+		if (!enumerator_to_integer_representation(*src.c_array<2>(),types)) return false;
+		if (is_C99_unary_operator_expression<'-'>(*src.data<2>()))
+			{	// enumerator went negative: handle
+			parse_tree tmp = *src.c_array<2>()->c_array<2>();
+			src.c_array<2>()->c_array<2>()->clear();
+			src.destroy();
+			src = tmp;
+			return true;
+			}
+		src.type_code = src.data<2>()->type_code;
+		}
 #/*cut-cpp*/
 	if (is_integerlike_literal(*src.data<2>()) && 1==(src.type_code.base_type_index-C_TYPE::INT)%2)
 		{	// unsigned...we're fine
@@ -5808,7 +5833,6 @@
 		return false;
 		}
 	force_unary_negative_token(*tmp3,tmp,src_loc);
-	tmp3->type_code = tmp->type_code;
 
 	parse_tree tmp4;
 	tmp4.clear();
@@ -6270,21 +6294,19 @@
 	if (	(literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)	// 0 * __
 		||	(literal_converts_to_bool(*src.data<2>(),is_true) && !is_true))	// __ * 0
 		{
+		// construct +0 to defuse 1-0*6
+		parse_tree tmp = decimal_literal("0",src,types);
 		if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
 			{
 			message_header(src.index_tokens[0]);
 			INC_INFORM("invalid ");
 			INC_INFORM(src);
 			INFORM(" optimized to valid 0");
-			};
-		// construct +0 to defuse 1-0*6
-		parse_tree tmp = decimal_literal("0",src,types);
+			tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
+			}
+		else tmp.type_code = old_type;
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp);
-		if (C_TYPE::INTEGERLIKE!=old_type.base_type_index)
-			src.type_code = old_type;
-		else
-			src.type_code.set_type(C_TYPE::LLONG);	// legalize
 		return true;
 		};
 
@@ -6363,10 +6385,9 @@
 		// convert to parsed + literal
 		parse_tree tmp;
 		if (!VM_to_literal(tmp,res_int,src,types)) return false;
-
+		tmp.type_code = old_type;
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp);
-		src.type_code = old_type;
 		return true;
 		}
 	return false;
@@ -6390,21 +6411,19 @@
 		/*! \todo would like a simple comparison of absolute values to auto-detect zero, possibly after mainline code */
 		else if (literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)
 			{
+			// construct +0 to defuse 1-0/6
+			parse_tree tmp = decimal_literal("0",src,types);
 			if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
 				{
 				message_header(src.index_tokens[0]);
 				INC_INFORM("invalid ");
 				INC_INFORM(src);
 				INFORM(" optimized to valid 0");
-				};
-			// construct +0 to defuse 1-0/6
-			parse_tree tmp = decimal_literal("0",src,types);
+				tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
+				}
+			else tmp.type_code = old_type;
 			src.DeleteIdx<1>(0);
 			force_unary_positive_literal(src,tmp);
-			if (C_TYPE::INTEGERLIKE!=old_type.base_type_index)
-				src.type_code = old_type;
-			else
-				src.type_code.set_type(C_TYPE::LLONG);	// legalize
 			return true;
 			}
 		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
@@ -6444,22 +6463,14 @@
 			if (rhs_negative!=lhs_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation()) ub += 1;
 			if (lhs_test<rhs_test)
 				{
-				if (rhs_negative==lhs_negative || !bool_options[boolopt::int_neg_div_rounds_away_from_zero])
-					{	// 0
-					parse_tree tmp = decimal_literal("0",src,types);
-
-					// convert to parsed + literal
-					src.DeleteIdx<1>(0);
-					force_unary_positive_literal(src,tmp);
-					}
-				else{	// -1
-					parse_tree tmp = decimal_literal("1",src,types);
-
-					// convert to parsed - literal
-					src.DeleteIdx<1>(0);
-					force_unary_negative_literal(src,tmp);
-					}
-				src.type_code = old_type;
+				const bool want_zero = rhs_negative==lhs_negative || !bool_options[boolopt::int_neg_div_rounds_away_from_zero];
+				parse_tree tmp = decimal_literal(want_zero ? "0" : "1",src,types);
+				tmp.type_code = old_type;
+				src.DeleteIdx<1>(0);
+				if (want_zero)
+					force_unary_positive_literal(src,tmp); // +0
+				else	
+					force_unary_negative_literal(src,tmp); // -1
 				return true;
 				}
 
@@ -6500,10 +6511,10 @@
 		// convert to parsed + literal
 		parse_tree tmp;
 		if (!VM_to_literal(tmp,res_int,src,types)) return false;
+		tmp.type_code = old_type;
 
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp);
-		src.type_code = old_type;
 		return true;
 		}
 	return false;
@@ -6527,21 +6538,19 @@
 		/*! \todo would like a simple comparison of absolute values to auto-detect zero, possibly after mainline code */
 		else if (literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)
 			{
+			// construct +0 to defuse 1-0%6
+			parse_tree tmp = decimal_literal("0",src,types);
 			if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
 				{
 				message_header(src.index_tokens[0]);
 				INC_INFORM("invalid ");
 				INC_INFORM(src);
 				INFORM(" optimized to valid 0");
-				};
-			// construct +0 to defuse 1-0%6
-			parse_tree tmp = decimal_literal("0",src,types);
+				tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
+				}
+			else tmp.type_code = old_type;
 			src.DeleteIdx<1>(0);
 			force_unary_positive_literal(src,tmp);
-			if (C_TYPE::INTEGERLIKE!=old_type.base_type_index)
-				src.type_code = old_type;
-			else
-				src.type_code.set_type(C_TYPE::LLONG);	// legalize
 			return true;
 			}
 		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
@@ -6554,12 +6563,12 @@
 	if (rhs_converted && rhs_int==1)
 		{	// __%1 |-> +0
 		parse_tree tmp = decimal_literal("0",src,types);
+		if (C_TYPE::INTEGERLIKE!=old_type.base_type_index)
+			tmp.type_code = old_type;
+		else
+			tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp);
-		if (C_TYPE::INTEGERLIKE!=old_type.base_type_index)
-			src.type_code = old_type;
-		else
-			src.type_code.set_type(C_TYPE::LLONG);	// legalize
 		return true;
 		};
 	if (lhs_converted && rhs_converted)
@@ -6610,10 +6619,10 @@
 		// convert to parsed + literal
 		parse_tree tmp;
 		if (!VM_to_literal(tmp,res_int,src,types)) return false;
+		tmp.type_code = old_type;
 
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp);
-		src.type_code = old_type;
 		return true;
 		}
 	return false;
@@ -6977,10 +6986,10 @@
 				// convert to parsed + literal
 				parse_tree tmp;
 				if (!VM_to_literal(tmp,res_int,src,types)) return false;
+				tmp.type_code = old_type;
 
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp);
-				src.type_code = old_type;
 				return true;
 				}
 			break;
@@ -7129,10 +7138,10 @@
 				// convert to parsed + literal
 				parse_tree tmp;
 				if (!VM_to_literal(tmp,res_int,src,types)) return false;
+				tmp.type_code = old_type;
 
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp);
-				src.type_code = old_type;
 				return true;
 				}
 			break;
@@ -10583,6 +10592,11 @@
 			return;
 			}
 		// end snip from CPreproc
+
+		// handle top-level enumerators
+		if (is_noticed_enumerator(parsetree,types))
+			if (!enumerator_to_integer_representation(parsetree,types)) throw std::bad_alloc();
+
 		bool is_true = false;
 		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true))
 			{	//! \bug need test cases

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-11 05:55:39 UTC (rev 350)
+++ trunk/CSupport_pp.cpp	2010-03-12 00:52:02 UTC (rev 351)
@@ -4860,6 +4860,8 @@
 	dest.core_flag_update();
 	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	dest.subtype = C99_UNARY_SUBTYPE_PLUS;
+	if (converts_to_arithmeticlike(dest.data<2>()->type_code))
+		dest.type_code = dest.data<2>()->type_code;
 	assert(NULL!=dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'+'>(dest));
 }
@@ -4875,6 +4877,8 @@
 	dest.core_flag_update();
 	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	dest.subtype = C99_UNARY_SUBTYPE_NEG;
+	if (converts_to_arithmeticlike(dest.data<2>()->type_code))
+		dest.type_code = dest.data<2>()->type_code;
 	// do not handle type here: C++ operator overloading risk
 	assert(NULL!=dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'-'>(dest));
@@ -5358,7 +5362,6 @@
 		return false;
 		}
 	force_unary_negative_token(*tmp3,tmp,src_loc);
-	tmp3->type_code = tmp->type_code;
 
 	parse_tree tmp4;
 	tmp4.clear();
@@ -5820,21 +5823,19 @@
 	if (	(literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)	// 0 * __
 		||	(literal_converts_to_bool(*src.data<2>(),is_true) && !is_true))	// __ * 0
 		{
+		// construct +0 to defuse 1-0*6
+		parse_tree tmp = decimal_literal("0",src,types);
 		if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
 			{
 			message_header(src.index_tokens[0]);
 			INC_INFORM("invalid ");
 			INC_INFORM(src);
 			INFORM(" optimized to valid 0");
-			};
-		// construct +0 to defuse 1-0*6
-		parse_tree tmp = decimal_literal("0",src,types);
+			tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
+			}
+		else tmp.type_code = old_type;
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp);
-		if (C_TYPE::INTEGERLIKE!=old_type.base_type_index)
-			src.type_code = old_type;
-		else
-			src.type_code.set_type(C_TYPE::LLONG);	// legalize
 		return true;
 		};
 
@@ -5913,10 +5914,9 @@
 		// convert to parsed + literal
 		parse_tree tmp;
 		if (!VM_to_literal(tmp,res_int,src,types)) return false;
-
+		tmp.type_code = old_type;
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp);
-		src.type_code = old_type;
 		return true;
 		}
 	return false;
@@ -5940,21 +5940,19 @@
 		/*! \todo would like a simple comparison of absolute values to auto-detect zero, possibly after mainline code */
 		else if (literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)
 			{
+			// construct +0 to defuse 1-0/6
+			parse_tree tmp = decimal_literal("0",src,types);
 			if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
 				{
 				message_header(src.index_tokens[0]);
 				INC_INFORM("invalid ");
 				INC_INFORM(src);
 				INFORM(" optimized to valid 0");
-				};
-			// construct +0 to defuse 1-0/6
-			parse_tree tmp = decimal_literal("0",src,types);
+				tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
+				}
+			else tmp.type_code = old_type;
 			src.DeleteIdx<1>(0);
 			force_unary_positive_literal(src,tmp);
-			if (C_TYPE::INTEGERLIKE!=old_type.base_type_index)
-				src.type_code = old_type;
-			else
-				src.type_code.set_type(C_TYPE::LLONG);	// legalize
 			return true;
 			}
 		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
@@ -5994,22 +5992,14 @@
 			if (rhs_negative!=lhs_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation()) ub += 1;
 			if (lhs_test<rhs_test)
 				{
-				if (rhs_negative==lhs_negative || !bool_options[boolopt::int_neg_div_rounds_away_from_zero])
-					{	// 0
-					parse_tree tmp = decimal_literal("0",src,types);
-
-					// convert to parsed + literal
-					src.DeleteIdx<1>(0);
-					force_unary_positive_literal(src,tmp);
-					}
-				else{	// -1
-					parse_tree tmp = decimal_literal("1",src,types);
-
-					// convert to parsed - literal
-					src.DeleteIdx<1>(0);
-					force_unary_negative_literal(src,tmp);
-					}
-				src.type_code = old_type;
+				const bool want_zero = rhs_negative==lhs_negative || !bool_options[boolopt::int_neg_div_rounds_away_from_zero];
+				parse_tree tmp = decimal_literal(want_zero ? "0" : "1",src,types);
+				tmp.type_code = old_type;
+				src.DeleteIdx<1>(0);
+				if (want_zero)
+					force_unary_positive_literal(src,tmp); // +0
+				else	
+					force_unary_negative_literal(src,tmp); // -1
 				return true;
 				}
 
@@ -6050,10 +6040,10 @@
 		// convert to parsed + literal
 		parse_tree tmp;
 		if (!VM_to_literal(tmp,res_int,src,types)) return false;
+		tmp.type_code = old_type;
 
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp);
-		src.type_code = old_type;
 		return true;
 		}
 	return false;
@@ -6077,21 +6067,19 @@
 		/*! \todo would like a simple comparison of absolute values to auto-detect zero, possibly after mainline code */
 		else if (literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)
 			{
+			// construct +0 to defuse 1-0%6
+			parse_tree tmp = decimal_literal("0",src,types);
 			if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
 				{
 				message_header(src.index_tokens[0]);
 				INC_INFORM("invalid ");
 				INC_INFORM(src);
 				INFORM(" optimized to valid 0");
-				};
-			// construct +0 to defuse 1-0%6
-			parse_tree tmp = decimal_literal("0",src,types);
+				tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
+				}
+			else tmp.type_code = old_type;
 			src.DeleteIdx<1>(0);
 			force_unary_positive_literal(src,tmp);
-			if (C_TYPE::INTEGERLIKE!=old_type.base_type_index)
-				src.type_code = old_type;
-			else
-				src.type_code.set_type(C_TYPE::LLONG);	// legalize
 			return true;
 			}
 		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
@@ -6104,12 +6092,12 @@
 	if (rhs_converted && rhs_int==1)
 		{	// __%1 |-> +0
 		parse_tree tmp = decimal_literal("0",src,types);
-		src.DeleteIdx<1>(0);
-		force_unary_positive_literal(src,tmp);
 		if (C_TYPE::INTEGERLIKE!=old_type.base_type_index)
-			src.type_code = old_type;
+			tmp.type_code = old_type;
 		else
-			src.type_code.set_type(C_TYPE::LLONG);	// legalize
+			tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
+		src.DeleteIdx<1>(0);
+		force_unary_positive_literal(src,tmp);
 		return true;
 		};
 	if (lhs_converted && rhs_converted)
@@ -6160,10 +6148,10 @@
 		// convert to parsed + literal
 		parse_tree tmp;
 		if (!VM_to_literal(tmp,res_int,src,types)) return false;
+		tmp.type_code = old_type;
 
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp);
-		src.type_code = old_type;
 		return true;
 		}
 	return false;
@@ -6527,10 +6515,10 @@
 				// convert to parsed + literal
 				parse_tree tmp;
 				if (!VM_to_literal(tmp,res_int,src,types)) return false;
+				tmp.type_code = old_type;
 
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp);
-				src.type_code = old_type;
 				return true;
 				}
 			break;
@@ -6679,10 +6667,10 @@
 				// convert to parsed + literal
 				parse_tree tmp;
 				if (!VM_to_literal(tmp,res_int,src,types)) return false;
+				tmp.type_code = old_type;
 
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp);
-				src.type_code = old_type;
 				return true;
 				}
 			break;

Added: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-03-11 05:55:39 UTC (rev 350)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-03-12 00:52:02 UTC (rev 351)
@@ -0,0 +1,20 @@
+// staticassert.C1X\Pass_enum_autosuccess.h
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum test {
+	neg_one = -1,
+	zero,
+	one
+}
+
+_Static_Assert(neg_one,"automatic success has failed");
+_Static_Assert(one,"automatic success has failed");
+
+// check unary +
+_Static_Assert(+neg_one,"automatic success has failed");
+_Static_Assert(+one,"automatic success has failed");
+
+// check unary -
+_Static_Assert(-neg_one,"automatic success has failed");
+_Static_Assert(-one,"automatic success has failed");
+

Added: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-03-11 05:55:39 UTC (rev 350)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-03-12 00:52:02 UTC (rev 351)
@@ -0,0 +1,20 @@
+// staticassert.C1X\Pass_enum_autosuccess.hpp
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum test {
+	neg_one = -1,
+	zero,
+	one
+}
+
+static_assert(neg_one,"automatic success has failed");
+static_assert(one,"automatic success has failed");
+
+// check unary +
+static_assert(+neg_one,"automatic success has failed");
+static_assert(+one,"automatic success has failed");
+
+// check unary -
+static_assert(-neg_one,"automatic success has failed");
+static_assert(-one,"automatic success has failed");
+

Added: trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-03-11 05:55:39 UTC (rev 350)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-03-12 00:52:02 UTC (rev 351)
@@ -0,0 +1,21 @@
+SUFFIXES h hpp
+OBJECTLIKE_MACRO STATIC_ASSERT _Static_Assert static_assert
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum test {
+	neg_one = -1,
+	zero,
+	one
+}
+
+STATIC_ASSERT(neg_one,"automatic success has failed");
+STATIC_ASSERT(one,"automatic success has failed");
+
+// check unary +
+STATIC_ASSERT(+neg_one,"automatic success has failed");
+STATIC_ASSERT(+one,"automatic success has failed");
+
+// check unary -
+STATIC_ASSERT(-neg_one,"automatic success has failed");
+STATIC_ASSERT(-one,"automatic success has failed");
+



From zaimoni at mail.berlios.de  Thu Mar 18 06:59:05 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 18 Mar 2010 06:59:05 +0100
Subject: [Zcplusplus-commits] r352 - in trunk: .
	tests/zcc/default/staticassert tests/zcc/staticassert.C1X
	tests/zcc.in/default/staticassert tests/zcc.in/staticassert.C1X
Message-ID: <201003180559.o2I5x5xU013814@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-18 06:58:50 +0100 (Thu, 18 Mar 2010)
New Revision: 352

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
   trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
   trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
Log:
enumerator support for !

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-12 00:52:02 UTC (rev 351)
+++ trunk/CSupport.cpp	2010-03-18 05:58:50 UTC (rev 352)
@@ -630,17 +630,30 @@
 
 static bool converts_to_integerlike(size_t base_type_index)
 {	//! \todo handle cast operator overloading
-	//! \todo handle enum types
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index;
 }
 
 static bool converts_to_integerlike(const type_spec& type_code)
 {	//! \todo handle cast operator overloading
-	//! \todo handle enum types
 	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers
-	return C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>=type_code.base_type_index;
+	return converts_to_integerlike(type_code.base_type_index);
 }
+#/*cut-cpp*/
 
+static bool converts_to_integerlike(size_t base_type_index,const type_system& types)
+{
+	if (converts_to_integerlike(base_type_index)) return true;
+	return types.get_enum_def(base_type_index);
+}
+
+static bool converts_to_integerlike(const type_spec& type_code,const type_system& types)
+{
+	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers
+	if (converts_to_integerlike(type_code.base_type_index)) return true;
+	return types.get_enum_def(type_code.base_type_index);
+}
+#/*cut-cpp*/
+
 static bool converts_to_integer(const type_spec& type_code)
 {	//! \todo handle cast operator overloading
 	//! \todo handle enum types
@@ -664,9 +677,26 @@
 {	//! \todo handle cast operator overloading
 	//! \todo handle enum types
 	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers/floats/complex
-	return C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::LDOUBLE__COMPLEX>=type_code.base_type_index;
+	return converts_to_arithmeticlike(type_code.base_type_index);
 }
+#/*cut-cpp*/
 
+static bool converts_to_arithmeticlike(size_t base_type_index,const type_system& types)
+{	//! \todo handle cast operator overloading
+	//! \todo handle enum types
+	if (converts_to_arithmeticlike(base_type_index)) return true;
+	return types.get_enum_def(base_type_index);
+}
+
+static bool converts_to_arithmeticlike(const type_spec& type_code,const type_system& types)
+{	//! \todo handle cast operator overloading
+	//! \todo handle enum types
+	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers/floats/complex
+	if (converts_to_arithmeticlike(type_code.base_type_index)) return true;
+	return types.get_enum_def(type_code.base_type_index);
+}
+#/*cut-cpp*/
+
 static bool converts_to_bool(const type_spec& type_code)
 {
 	if (0<type_code.pointer_power_after_array_decay()) return true;	// pointers are comparable to NULL
@@ -674,7 +704,18 @@
 	// C++: run through type conversion weirdness
 	return false;
 }
+#/*cut-cpp*/
 
+static bool converts_to_bool(const type_spec& type_code,const type_system& types)
+{
+	if (0<type_code.pointer_power_after_array_decay()) return true;	// pointers are comparable to NULL
+	if (converts_to_arithmeticlike(type_code.base_type_index)) return true;	// arithmetic types are comparable to zero, and include bool
+	if (types.get_enum_def(type_code.base_type_index)) return true;	// (unscoped) enumerators convert to integers
+	// C++: run through type conversion weirdness
+	return false;
+}
+#/*cut-cpp*/
+
 // the integer promotions rely on low-level weirdness, so test that here
 static size_t arithmetic_reconcile(size_t base_type_index1, size_t base_type_index2)
 {
@@ -4298,7 +4339,7 @@
  *         pointer constant
  */
 int is_null_pointer_constant(const parse_tree& src, func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
+{	//! \bug doesn't recognize enumerators with value zero
 	if (!converts_to_integerlike(src.type_code)) return 0;
 	umaxint tmp;
 	if (intlike_literal_to_VM(tmp,src)) return tmp==0;
@@ -4630,12 +4671,12 @@
 			}
 		else if (token_is_char<'['>(src.data<0>()[i].index_tokens[0].token))
 			{
-			assert(bracket_stack.size()>paren_idx);
+			assert(bracket_stack.size()>bracket_idx);
 			bracket_stack[bracket_idx++] = i;
 			}
 		else if (token_is_char<'{'>(src.data<0>()[i].index_tokens[0].token))
 			{
-			assert(brace_stack.size()>paren_idx);
+			assert(brace_stack.size()>brace_idx);
 			brace_stack[brace_idx++] = i;
 			}
 		// introduces sequence points; this causes errors if caught in brackets or parentheses
@@ -4881,7 +4922,11 @@
 			simple_error(src,"array dereference of pointer by pointer (C99 6.5.2.1p1; C++98 5.2.1p1,13.3.1.2p1)");
 			return;
 			}
-		else if (converts_to_integerlike(src.data<0>()->type_code.base_type_index))
+		else if (converts_to_integerlike(src.data<0>()->type_code.base_type_index
+#/*cut-cpp*/
+			,types
+#/*cut-cpp*/
+			))
 			{
 			value_copy(src.type_code,src.data<1>()->type_code);
 			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
@@ -4899,7 +4944,11 @@
 		}
 	else if (0<effective_pointer_power_infix)
 		{
-		if (converts_to_integerlike(src.data<1>()->type_code.base_type_index))
+		if (converts_to_integerlike(src.data<1>()->type_code.base_type_index
+#/*cut-cpp*/
+			,types
+#/*cut-cpp*/
+			))
 			{
 			value_copy(src.type_code,src.data<0>()->type_code);
 			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
@@ -5637,6 +5686,12 @@
 static bool eval_logical_NOT(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_NOT, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool)
 {
 	assert(is_logical_NOT(src));
+#/*cut-cpp*/
+	// unscoped enumerators use their integer representation
+	if (   is_noticed_enumerator(*src.data<2>(),types)
+		&& !enumerator_to_integer_representation(*src.c_array<2>(),types))
+		return false;
+#/*cut-cpp*/
 	{	// deal with literals that convert to bool here
 	bool is_true = false;
 	if (literal_converts_to_bool(*src.data<2>(),is_true))
@@ -5671,8 +5726,12 @@
 	src.type_code.set_type(C_TYPE::BOOL);	// technically wrong for C, but the range is restricted to _Bool's range
 	if (eval_logical_NOT(src,types,is_C99_unary_operator_expression<'!'>,C99_literal_converts_to_bool)) return;
 
-	if (!converts_to_bool(src.data<2>()->type_code))
-		{	// can't test this from preprocessor
+	if (!converts_to_bool(src.data<2>()->type_code
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		))
+		{	// can't test this from preprocessor or static assertion
 		simple_error(src," applies ! to a nonscalar type (C99 6.5.3.3p1)");
 		return;
 		}
@@ -5684,8 +5743,12 @@
 	src.type_code.set_type(C_TYPE::BOOL);	// technically wrong for C, but the range is restricted to _Bool's range
 	if (eval_logical_NOT(src,types,is_CPP_logical_NOT_expression,CPP_literal_converts_to_bool)) return;
 
-	if (!converts_to_bool(src.data<2>()->type_code))
-		{	// can't test this from preprocessor
+	if (!converts_to_bool(src.data<2>()->type_code
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		))
+		{	// can't test this from preprocessor or static assertion
 		simple_error(src," applies ! to a type not convertible to bool (C++98 5.3.1p8)");
 		return;
 		}
@@ -10912,22 +10975,21 @@
 		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
 		// in any case, do not react if the default-init isn't used
 		value_copy(prior_value,latest_value);
-		bool value_is_nonnegative_or_twos_complement = true;
-		if (virtual_machine::twos_complement!=target_machine->C_signed_int_representation())
+		{
+		bool value_is_nonnegative = true;
+		const promote_aux test(current_enumerator_type);
+		if (test.is_signed && latest_value.test(test.bitcount-1))
 			{
-			const promote_aux test(current_enumerator_type);
-			if (test.is_signed && latest_value.test(test.bitcount-1))
+			target_machine->signed_additive_inverse(latest_value,test.machine_type);
+			if (0<latest_value)
 				{
-				target_machine->signed_additive_inverse(latest_value,test.machine_type);
-				if (0<latest_value)
-					{
-					latest_value -= 1;
-					if (0<latest_value) target_machine->signed_additive_inverse(latest_value,test.machine_type);
-					value_is_nonnegative_or_twos_complement = false;
-					}
+				latest_value -= 1;
+				if (0<latest_value) target_machine->signed_additive_inverse(latest_value,test.machine_type);
+				value_is_nonnegative = false;
 				}
 			}
-		if (value_is_nonnegative_or_twos_complement) latest_value += 1;
+		if (value_is_nonnegative) latest_value += 1;
+		}
 
 		if (1>=src.size<0>()-i)
 			{	// default-update

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-12 00:52:02 UTC (rev 351)
+++ trunk/CSupport_pp.cpp	2010-03-18 05:58:50 UTC (rev 352)
@@ -577,15 +577,13 @@
 
 static bool converts_to_integerlike(size_t base_type_index)
 {	//! \todo handle cast operator overloading
-	//! \todo handle enum types
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index;
 }
 
 static bool converts_to_integerlike(const type_spec& type_code)
 {	//! \todo handle cast operator overloading
-	//! \todo handle enum types
 	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers
-	return C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>=type_code.base_type_index;
+	return converts_to_integerlike(type_code.base_type_index);
 }
 
 static bool converts_to_integer(const type_spec& type_code)
@@ -611,7 +609,7 @@
 {	//! \todo handle cast operator overloading
 	//! \todo handle enum types
 	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers/floats/complex
-	return C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::LDOUBLE__COMPLEX>=type_code.base_type_index;
+	return converts_to_arithmeticlike(type_code.base_type_index);
 }
 
 static bool converts_to_bool(const type_spec& type_code)
@@ -3945,7 +3943,7 @@
  *         pointer constant
  */
 int is_null_pointer_constant(const parse_tree& src, func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
+{	//! \bug doesn't recognize enumerators with value zero
 	if (!converts_to_integerlike(src.type_code)) return 0;
 	umaxint tmp;
 	if (intlike_literal_to_VM(tmp,src)) return tmp==0;
@@ -4241,12 +4239,12 @@
 			}
 		else if (token_is_char<'['>(src.data<0>()[i].index_tokens[0].token))
 			{
-			assert(bracket_stack.size()>paren_idx);
+			assert(bracket_stack.size()>bracket_idx);
 			bracket_stack[bracket_idx++] = i;
 			}
 		else if (token_is_char<'{'>(src.data<0>()[i].index_tokens[0].token))
 			{
-			assert(brace_stack.size()>paren_idx);
+			assert(brace_stack.size()>brace_idx);
 			brace_stack[brace_idx++] = i;
 			}
 		// introduces sequence points; this causes errors if caught in brackets or parentheses
@@ -4492,7 +4490,8 @@
 			simple_error(src,"array dereference of pointer by pointer (C99 6.5.2.1p1; C++98 5.2.1p1,13.3.1.2p1)");
 			return;
 			}
-		else if (converts_to_integerlike(src.data<0>()->type_code.base_type_index))
+		else if (converts_to_integerlike(src.data<0>()->type_code.base_type_index
+			))
 			{
 			value_copy(src.type_code,src.data<1>()->type_code);
 			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
@@ -4510,7 +4509,8 @@
 		}
 	else if (0<effective_pointer_power_infix)
 		{
-		if (converts_to_integerlike(src.data<1>()->type_code.base_type_index))
+		if (converts_to_integerlike(src.data<1>()->type_code.base_type_index
+			))
 			{
 			value_copy(src.type_code,src.data<0>()->type_code);
 			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
@@ -5200,8 +5200,9 @@
 	src.type_code.set_type(C_TYPE::BOOL);	// technically wrong for C, but the range is restricted to _Bool's range
 	if (eval_logical_NOT(src,types,is_C99_unary_operator_expression<'!'>,C99_literal_converts_to_bool)) return;
 
-	if (!converts_to_bool(src.data<2>()->type_code))
-		{	// can't test this from preprocessor
+	if (!converts_to_bool(src.data<2>()->type_code
+		))
+		{	// can't test this from preprocessor or static assertion
 		simple_error(src," applies ! to a nonscalar type (C99 6.5.3.3p1)");
 		return;
 		}
@@ -5213,8 +5214,9 @@
 	src.type_code.set_type(C_TYPE::BOOL);	// technically wrong for C, but the range is restricted to _Bool's range
 	if (eval_logical_NOT(src,types,is_CPP_logical_NOT_expression,CPP_literal_converts_to_bool)) return;
 
-	if (!converts_to_bool(src.data<2>()->type_code))
-		{	// can't test this from preprocessor
+	if (!converts_to_bool(src.data<2>()->type_code
+		))
+		{	// can't test this from preprocessor or static assertion
 		simple_error(src," applies ! to a type not convertible to bool (C++98 5.3.1p8)");
 		return;
 		}

Modified: trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2010-03-12 00:52:02 UTC (rev 351)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2010-03-18 05:58:50 UTC (rev 352)
@@ -5,3 +5,8 @@
 // exercise string literal uses in (extended) integer constant expressions
 _Static_Assert("A","automatic success has failed");
 
+_Static_Assert("A"[0],"automatic success has failed");
+_Static_Assert(+"A"[0],"automatic success has failed");
+_Static_Assert(-"A"[0],"automatic success has failed");
+_Static_Assert(!"A"[1],"automatic success has failed");
+

Modified: trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp	2010-03-12 00:52:02 UTC (rev 351)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp	2010-03-18 05:58:50 UTC (rev 352)
@@ -5,3 +5,8 @@
 // exercise string literal uses in (extended) integer constant expressions
 static_assert("A","automatic success has failed");
 
+static_assert("A"[0],"automatic success has failed");
+static_assert(+"A"[0],"automatic success has failed");
+static_assert(-"A"[0],"automatic success has failed");
+static_assert(!"A"[1],"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-03-12 00:52:02 UTC (rev 351)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-03-18 05:58:50 UTC (rev 352)
@@ -11,3 +11,6 @@
 _Static_Assert(-1,"automatic success has failed");
 _Static_Assert(-'A',"automatic success has failed");
 
+// check unary !
+_Static_Assert(!0,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-03-12 00:52:02 UTC (rev 351)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-03-18 05:58:50 UTC (rev 352)
@@ -11,3 +11,6 @@
 static_assert(-1,"automatic success has failed");
 static_assert(-'A',"automatic success has failed");
 
+// check unary !
+static_assert(!0,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-03-12 00:52:02 UTC (rev 351)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-03-18 05:58:50 UTC (rev 352)
@@ -18,3 +18,5 @@
 _Static_Assert(-neg_one,"automatic success has failed");
 _Static_Assert(-one,"automatic success has failed");
 
+// check unary !
+_Static_Assert(!zero,"automatic success has failed");

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-03-12 00:52:02 UTC (rev 351)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-03-18 05:58:50 UTC (rev 352)
@@ -18,3 +18,5 @@
 static_assert(-neg_one,"automatic success has failed");
 static_assert(-one,"automatic success has failed");
 
+// check unary !
+static_assert(!zero,"automatic success has failed");

Modified: trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2010-03-12 00:52:02 UTC (rev 351)
+++ trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2010-03-18 05:58:50 UTC (rev 352)
@@ -6,3 +6,8 @@
 // exercise string literal uses in (extended) integer constant expressions
 STATIC_ASSERT("A","automatic success has failed");
 
+STATIC_ASSERT("A"[0],"automatic success has failed");
+STATIC_ASSERT(+"A"[0],"automatic success has failed");
+STATIC_ASSERT(-"A"[0],"automatic success has failed");
+STATIC_ASSERT(!"A"[1],"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-03-12 00:52:02 UTC (rev 351)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-03-18 05:58:50 UTC (rev 352)
@@ -12,3 +12,6 @@
 STATIC_ASSERT(-1,"automatic success has failed");
 STATIC_ASSERT(-'A',"automatic success has failed");
 
+// check unary !
+STATIC_ASSERT(!0,"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-03-12 00:52:02 UTC (rev 351)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-03-18 05:58:50 UTC (rev 352)
@@ -19,3 +19,5 @@
 STATIC_ASSERT(-neg_one,"automatic success has failed");
 STATIC_ASSERT(-one,"automatic success has failed");
 
+// check unary !
+STATIC_ASSERT(!zero,"automatic success has failed");



From zaimoni at mail.berlios.de  Sun Mar 21 20:23:37 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 21 Mar 2010 20:23:37 +0100
Subject: [Zcplusplus-commits] r353 - trunk
Message-ID: <201003211923.o2LJNbld030288@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-21 20:23:33 +0100 (Sun, 21 Mar 2010)
New Revision: 353

Modified:
   trunk/CPUInfo.cpp
   trunk/CPUInfo.hpp
Log:
identifying is_zero bitpattern for integer types is target-dependent

Modified: trunk/CPUInfo.cpp
===================================================================
--- trunk/CPUInfo.cpp	2010-03-18 05:58:50 UTC (rev 352)
+++ trunk/CPUInfo.cpp	2010-03-21 19:23:33 UTC (rev 353)
@@ -124,6 +124,37 @@
 #endif
 }
 
+bool CPUInfo::is_zero(const unsigned char* x, size_t x_len, const promotion_info& targettype) const
+{
+	assert(x);
+	assert(0<x_len);
+	assert(x_len*CHAR_BIT>=targettype.bitcount);
+	if (targettype.is_signed && ((1U<<((targettype.bitcount-1)%CHAR_BIT)) & x[(targettype.bitcount-1)/CHAR_BIT]))
+		{	// negative
+		switch(C_signed_int_representation())
+		{
+		default: return false;
+		case sign_and_magnitude:
+			x_len = (targettype.bitcount-1)/CHAR_BIT;
+			if (1U<<((targettype.bitcount-1)%CHAR_BIT) != x[x_len]) return false;
+			while(0<x_len)
+				if (0!=x[--x_len]) return false;
+			return true;
+		case ones_complement:
+			x_len = (targettype.bitcount-1)/CHAR_BIT;
+			if (UCHAR_MAX>>((CHAR_BIT-1)-(targettype.bitcount-1)%CHAR_BIT) != x[x_len]) return false;
+			while(0<x_len)
+				if (UCHAR_MAX!=x[--x_len]) return false;
+			return true;
+		}
+		}
+	// positive
+	do	if (0!=x[--x_len]) return false;
+	while(0<x_len);
+	return true;
+}
+
+
 bool CPUInfo::C_promote_integer(umaxint& x,const promotion_info& src_type, const promotion_info& dest_type) const
 {
 	if (src_type.is_signed && x.test(src_type.bitcount-1))

Modified: trunk/CPUInfo.hpp
===================================================================
--- trunk/CPUInfo.hpp	2010-03-18 05:58:50 UTC (rev 352)
+++ trunk/CPUInfo.hpp	2010-03-21 19:23:33 UTC (rev 353)
@@ -130,6 +130,7 @@
 	bool trap_int(const umaxint& src_int,std_int_enum machine_type) const;
 	void signed_additive_inverse(umaxint& src_int,std_int_enum machine_type) const;
 	void unsigned_additive_inverse(umaxint& src_int,std_int_enum machine_type) const;
+	bool is_zero(const unsigned char* x, size_t x_len, const promotion_info& targettype) const;
 	void sign_extend(umaxint& src_int,std_int_enum machine_type_from,std_int_enum machine_type_to) const
 		{
 		signed_additive_inverse(src_int,machine_type_from);



From zaimoni at mail.berlios.de  Sun Mar 21 20:24:31 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 21 Mar 2010 20:24:31 +0100
Subject: [Zcplusplus-commits] r354 - trunk
Message-ID: <201003211924.o2LJOVaA030339@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-21 20:24:26 +0100 (Sun, 21 Mar 2010)
New Revision: 354

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.hpp
   trunk/CSupport_pp.cpp
Log:
misinterpret enumerators as integer-like literals to avoid dynamic memory churning

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-21 19:23:33 UTC (rev 353)
+++ trunk/CSupport.cpp	2010-03-21 19:24:26 UTC (rev 354)
@@ -660,7 +660,17 @@
 	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers
 	return C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index;
 }
+#/*cut-cpp*/
 
+static bool converts_to_integer(const type_spec& type_code,const type_system& types)
+{	//! \todo handle cast operator overloading
+	//! \todo handle enum types
+	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers
+	if (C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index) return true;
+	return types.get_enum_def(type_code.base_type_index);
+}
+#/*cut-cpp*/
+
 static bool converts_to_reallike(size_t base_type_index)
 {	//! \todo handle cast operator overloading
 	//! \todo handle enum types
@@ -4185,11 +4195,29 @@
 		};
 	return true;
 }
+#/*cut-cpp*/
 
+static const enum_def* is_noticed_enumerator(const parse_tree& x,const type_system& types)
+{
+	const enum_def* tmp = NULL;
+	if (x.is_atomic() && (C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags))
+		tmp = types.get_enum_def(x.type_code.base_type_index);
+	return tmp;
+}
+#/*cut-cpp*/
+
 // forward-declare to handle recursion
-static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src);
+static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
+#/*cut-cpp*/
+	, const type_system& types
+#/*cut-cpp*/
+	);
 
-static bool _C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src)
+static bool _C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
+#/*cut-cpp*/
+	, const type_system& types
+#/*cut-cpp*/
+	)
 {
 	assert(C_TYPE::INTEGERLIKE!=src.type_code.base_type_index);
 
@@ -4206,8 +4234,16 @@
 				{
 				umaxint lhs_int;
 				umaxint rhs_int;
-				if (	C99_intlike_literal_to_VM(lhs_int,*src.data<1>())
-					&&	C99_intlike_literal_to_VM(rhs_int,*src.data<2>()))
+				if (	C99_intlike_literal_to_VM(lhs_int,*src.data<1>()
+#/*cut-cpp*/
+					,types
+#/*cut-cpp*/
+					)
+					&&	C99_intlike_literal_to_VM(rhs_int,*src.data<2>()
+#/*cut-cpp*/
+						,types
+#/*cut-cpp*/
+					))
 					{
 					const promote_aux rhs(src.data<2>()->type_code.base_type_index);
 					assert(old.bitcount>=rhs.bitcount);
@@ -4238,7 +4274,18 @@
 		dest.set_bitcount(VM_MAX_BIT_PLATFORM);
 		return true;
 		}	
+#/*cut-cpp*/
 
+	// creative interpretation: enumerators as integer-like literals
+	if (is_noticed_enumerator(src,types))
+		{
+		const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.index_tokens[0].token.first);
+		assert(tmp2);
+		dest = tmp2->second.first.third;
+		return true;
+		}
+#/*cut-cpp*/
+		
 	if (!(C_TESTFLAG_INTEGER & src.index_tokens[0].flags)) return false;
 	C_PPIntCore tmp;
 	ZAIMONI_PASSTHROUGH_ASSERT(C_PPIntCore::is(src.index_tokens[0].token.first,src.index_tokens[0].token.second,tmp));
@@ -4268,11 +4315,19 @@
 
 // return value: literal to parse, whether additive inverse applies
 static POD_pair<const parse_tree*,bool>
-_find_intlike_literal(const parse_tree* src)
+_find_intlike_literal(const parse_tree* src
+#/*cut-cpp*/
+	,const type_system& types
+#/*cut-cpp*/	
+	)
 {
 	assert(NULL!=src);
 	POD_pair<const parse_tree*,bool> ret = {src,false};
-	while(converts_to_integer(ret.first->type_code))
+	while(converts_to_integer(ret.first->type_code
+#/*cut-cpp*/
+	, types
+#/*cut-cpp*/			
+		))
 		{
 		if 		(is_C99_unary_operator_expression<'-'>(*ret.first))
 			{
@@ -4291,14 +4346,33 @@
 	return ret;
 }
 
-static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src)
+// use this typedef to cope with signature varying by build
+typedef bool (intlike_literal_to_VM_func)(umaxint& dest, const parse_tree& src
+#/*cut-cpp*/
+	,const type_system& types
+#/*cut-cpp*/	
+	);
+
+static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
+#/*cut-cpp*/
+	,const type_system& types
+#/*cut-cpp*/	
+	)
 {
-	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src);
+	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src
+#/*cut-cpp*/
+	, types
+#/*cut-cpp*/					
+		);
 
 	if (C_TYPE::INTEGERLIKE==actual.first->type_code.base_type_index)
 		return false;	
 
-	if (!_C99_intlike_literal_to_VM(dest,*actual.first)) return false;
+	if (!_C99_intlike_literal_to_VM(dest,*actual.first
+#/*cut-cpp*/
+		, types
+#/*cut-cpp*/					
+		)) return false;
 	if (actual.second)
 		{
 		const promote_aux old(src.type_code.base_type_index);
@@ -4310,16 +4384,28 @@
 	return true;
 }
 
-static bool CPP_intlike_literal_to_VM(umaxint& dest, const parse_tree& src)
+static bool CPP_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
+#/*cut-cpp*/
+	, const type_system& types
+#/*cut-cpp*/	
+	)
 {
-	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src);
+	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src
+#/*cut-cpp*/
+	, types
+#/*cut-cpp*/					
+		);
 
 	if (!_CPP_intlike_literal_to_VM(dest,*actual.first))
 		{
 		if (C_TYPE::INTEGERLIKE==actual.first->type_code.base_type_index)
 			return false;	
 
-		if (!_C99_intlike_literal_to_VM(dest,*actual.first)) return false;
+		if (!_C99_intlike_literal_to_VM(dest,*actual.first
+#/*cut-cpp*/
+			, types
+#/*cut-cpp*/					
+			)) return false;
 		};
 	if (actual.second)
 		{
@@ -4338,11 +4424,19 @@
  * \return -1 : can't decide quickly whether this is a null 
  *         pointer constant
  */
-int is_null_pointer_constant(const parse_tree& src, func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static int is_null_pointer_constant(const parse_tree& src,intlike_literal_to_VM_func& intlike_literal_to_VM
+#/*cut-cpp*/
+	,const type_system& types
+#/*cut-cpp*/
+	)
 {	//! \bug doesn't recognize enumerators with value zero
 	if (!converts_to_integerlike(src.type_code)) return 0;
 	umaxint tmp;
-	if (intlike_literal_to_VM(tmp,src)) return tmp==0;
+	if (intlike_literal_to_VM(tmp,src
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		)) return tmp==0;
 	return -1;
 }
 
@@ -5146,8 +5240,19 @@
 		}
 }
 
+// typedef to simplify compatibility changes
+typedef bool literal_converts_to_bool_func(const parse_tree& src, bool& is_true
+#/*cut-cpp*/
+	, const type_system& types
+#/*cut-cpp*/
+	);
+
 // Closely related to if_elif_control_is_zero/CPreproc.cpp
-static bool _C99_literal_converts_to_bool(const parse_tree& src, bool& is_true)
+static bool _C99_literal_converts_to_bool(const parse_tree& src, bool& is_true
+#/*cut-cpp*/
+	, const type_system& types
+#/*cut-cpp*/
+	)
 {
 	assert(src.is_atomic());
 	// string literals always test true (decay to non-NULL pointer)
@@ -5161,6 +5266,16 @@
 		is_true = !CCharLiteralIsFalse(src.index_tokens[0].token.first,src.index_tokens[0].token.second);
 		return true;
 		};
+#/*cut-cpp*/
+	if (is_noticed_enumerator(src,types))
+		{	// misintepret enumerators as literals (avoid dynamic memory thrashing)
+		const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.index_tokens[0].token.first);
+		assert(tmp2);
+		const promote_aux dest_type(tmp2->second.first.second);
+		is_true = !target_machine->is_zero(tmp2->second.first.third.data(),tmp2->second.first.third.size(),dest_type);
+		return true;
+		}
+#/*cut-cpp*/
 	if (!(C_TESTFLAG_PP_NUMERAL & src.index_tokens[0].flags)) return false;
 	C_REALITY_CHECK_PP_NUMERAL_FLAGS(src.index_tokens[0].flags);
 	if (C_TESTFLAG_FLOAT & src.index_tokens[0].flags) return false;	//! \todo handle floats as well (underflow to zero is target-sensitive)
@@ -5169,21 +5284,45 @@
 	return true;
 }
 
-static bool C99_literal_converts_to_bool(const parse_tree& src, bool& is_true)
+static bool C99_literal_converts_to_bool(const parse_tree& src, bool& is_true
+#/*cut-cpp*/
+	, const type_system& types
+#/*cut-cpp*/
+	)
 {	// deal with -1 et. al.
-	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return _C99_literal_converts_to_bool(*src.data<2>(),is_true);
+	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return _C99_literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		);
 
 	if (!src.is_atomic()) return false;
-	return _C99_literal_converts_to_bool(src,is_true);
+	return _C99_literal_converts_to_bool(src,is_true
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		);
 }
 
-static bool CPP_literal_converts_to_bool(const parse_tree& src, bool& is_true)
+static bool CPP_literal_converts_to_bool(const parse_tree& src, bool& is_true
+#/*cut-cpp*/
+	, const type_system& types
+#/*cut-cpp*/
+	)
 {
 	// deal with -1 et. al.
-	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return CPP_literal_converts_to_bool(*src.data<2>(),is_true);
+	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return CPP_literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		);
 
 	if (!src.is_atomic()) return false;
-	if (_C99_literal_converts_to_bool(src,is_true)) return true;
+	if (_C99_literal_converts_to_bool(src,is_true
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		)) return true;
 	// deal with: this, true, false
 	if (token_is_string<5>(src.index_tokens[0].token,"false"))
 		{
@@ -5340,14 +5479,6 @@
 }
 #/*cut-cpp*/
 
-static const enum_def* is_noticed_enumerator(const parse_tree& x,const type_system& types)
-{
-	const enum_def* tmp = NULL;
-	if (x.is_atomic() && (C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags))
-		tmp = types.get_enum_def(x.type_code.base_type_index);
-	return tmp;
-}
-
 static bool enumerator_to_integer_representation(parse_tree& x,const type_system& types)
 {
 	parse_tree tmp3;
@@ -5418,11 +5549,15 @@
 	return false;
 }
 
-static bool eval_unary_minus(parse_tree& src, const type_system& types,func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_unary_minus(parse_tree& src, const type_system& types,literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_unary_operator_expression<'-'>(src));
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<2>(),is_true) && !is_true && (1==(src.type_code.base_type_index-C_TYPE::INT)%2 || virtual_machine::twos_complement==target_machine->C_signed_int_representation() || bool_options[boolopt::int_traps]))
+	if (literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		) && !is_true && (1==(src.type_code.base_type_index-C_TYPE::INT)%2 || virtual_machine::twos_complement==target_machine->C_signed_int_representation() || bool_options[boolopt::int_traps]))
 		{	// -0==0
 			// deal with unary - not being allowed to actually return -0 on these machines later
 		const type_spec old_type = src.type_code;
@@ -5450,7 +5585,11 @@
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
 		const type_spec old_type = src.type_code;
 		umaxint res_int;
-		intlike_literal_to_VM(res_int,*src.data<2>());
+		intlike_literal_to_VM(res_int,*src.data<2>()
+#/*cut-cpp*/
+			,types
+#/*cut-cpp*/
+			);
 		target_machine->unsigned_additive_inverse(res_int,machine_type);
 
 		//! \todo flag failures to reduce as RAM-stalled
@@ -5683,7 +5822,7 @@
 	return false;
 }
 
-static bool eval_logical_NOT(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_NOT, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool)
+static bool eval_logical_NOT(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_NOT, literal_converts_to_bool_func& literal_converts_to_bool)
 {
 	assert(is_logical_NOT(src));
 #/*cut-cpp*/
@@ -5694,7 +5833,11 @@
 #/*cut-cpp*/
 	{	// deal with literals that convert to bool here
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<2>(),is_true))
+	if (literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		))
 		{
 		src.destroy();
 		src.index_tokens[0].token.first = (is_true) ? "0" : "1";
@@ -5915,12 +6058,16 @@
 	return true;
 }
 
-static bool eval_bitwise_compl(parse_tree& src, const type_system& types,bool hard_error,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_bitwise_compl(parse_tree& src, const type_system& types,bool hard_error,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_bitwise_complement_expression(src));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
 	umaxint res_int;
-	if (intlike_literal_to_VM(res_int,*src.data<2>())) 
+	if (intlike_literal_to_VM(res_int,*src.data<2>()
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		)) 
 		{
 		const type_spec old_type = src.type_code;
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(old_type.base_type_index);
@@ -6346,7 +6493,7 @@
 	return false;
 }
 
-static bool eval_mult_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_mult_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'*'>(src));
 
@@ -6354,8 +6501,16 @@
 	bool is_true = false;
 
 	// do this first to avoid unnecessary dynamic memory allocation
-	if (	(literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)	// 0 * __
-		||	(literal_converts_to_bool(*src.data<2>(),is_true) && !is_true))	// __ * 0
+	if (	(literal_converts_to_bool(*src.data<1>(),is_true
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+			) && !is_true)	// 0 * __
+		||	(literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+			,types
+#/*cut-cpp*/
+			) && !is_true))	// __ * 0
 		{
 		// construct +0 to defuse 1-0*6
 		parse_tree tmp = decimal_literal("0",src,types);
@@ -6375,8 +6530,16 @@
 
 	umaxint res_int;
 	umaxint rhs_int;
-	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
+	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
+#/*cut-cpp*/
+		, types
+#/*cut-cpp*/
+		);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
+#/*cut-cpp*/
+		, types
+#/*cut-cpp*/
+		);
 	if (lhs_converted && 1==res_int)
 		{
 		src.eval_to_arg<2>(0);
@@ -6456,7 +6619,7 @@
 	return false;
 }
 
-static bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'/'>(src));
 
@@ -6464,7 +6627,11 @@
 	bool is_true = false;
 	if (converts_to_integerlike(src.type_code))
 		{
-		if 		(literal_converts_to_bool(*src.data<2>(),is_true) && !is_true)
+		if 		(literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				) && !is_true)
 			{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
 			if (hard_error)
 				//! \test default/Error_if_control30.hpp, default/Error_if_control30.h
@@ -6472,7 +6639,11 @@
 			return false;
 			}
 		/*! \todo would like a simple comparison of absolute values to auto-detect zero, possibly after mainline code */
-		else if (literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)
+		else if (literal_converts_to_bool(*src.data<1>(),is_true
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				) && !is_true)
 			{
 			// construct +0 to defuse 1-0/6
 			parse_tree tmp = decimal_literal("0",src,types);
@@ -6494,8 +6665,16 @@
 
 	umaxint res_int;
 	umaxint rhs_int;
-	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
+	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
+#/*cut-cpp*/
+		, types
+#/*cut-cpp*/
+		);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
+#/*cut-cpp*/
+		, types
+#/*cut-cpp*/
+		);
 	if (rhs_converted && rhs_int==1)
 		{	// __/1 |-> __
 		src.eval_to_arg<1>(0);
@@ -6583,7 +6762,7 @@
 	return false;
 }
 
-static bool eval_mod_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_mod_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'%'>(src));
 
@@ -6591,7 +6770,11 @@
 	bool is_true = false;
 	if (converts_to_integerlike(src.type_code))
 		{
-		if 		(literal_converts_to_bool(*src.data<2>(),is_true) && !is_true)
+		if 		(literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				) && !is_true)
 			{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
 			if (hard_error)
 				//! \test default/Error_if_control31.hpp, Error_if_control31.h
@@ -6599,7 +6782,11 @@
 			return false;
 			}
 		/*! \todo would like a simple comparison of absolute values to auto-detect zero, possibly after mainline code */
-		else if (literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)
+		else if (literal_converts_to_bool(*src.data<1>(),is_true
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				) && !is_true)
 			{
 			// construct +0 to defuse 1-0%6
 			parse_tree tmp = decimal_literal("0",src,types);
@@ -6621,8 +6808,16 @@
 
 	umaxint res_int;
 	umaxint rhs_int;
-	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
+	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
+#/*cut-cpp*/
+		, types
+#/*cut-cpp*/
+		);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
+#/*cut-cpp*/
+		, types
+#/*cut-cpp*/
+		);
 	if (rhs_converted && rhs_int==1)
 		{	// __%1 |-> +0
 		parse_tree tmp = decimal_literal("0",src,types);
@@ -6940,7 +7135,7 @@
 	return false;
 }
 
-static bool eval_add_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_add_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'+'>(src));
 
@@ -6960,13 +7155,21 @@
 			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index));
 			assert(converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index));
 			bool is_true = false;
-			if 		(literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)
+			if 		(literal_converts_to_bool(*src.data<1>(),is_true
+#/*cut-cpp*/
+					,types
+#/*cut-cpp*/
+					) && !is_true)
 				{	// 0 + __ |-> __
 				src.eval_to_arg<2>(0);
 				src.type_code = old_type;
 				return true;
 				}
-			else if (literal_converts_to_bool(*src.data<2>(),is_true) && !is_true)
+			else if (literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+					,types
+#/*cut-cpp*/
+					) && !is_true)
 				{	// __ + 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -6979,8 +7182,16 @@
 			assert(old.bitcount>=lhs.bitcount);
 			const promote_aux rhs(src.data<2>()->type_code.base_type_index);
 			assert(old.bitcount>=rhs.bitcount);
-			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
-			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
+			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
+#/*cut-cpp*/
+				, types
+#/*cut-cpp*/					
+				);
+			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
+#/*cut-cpp*/
+				, types
+#/*cut-cpp*/					
+				);
 			const bool lhs_negative = lhs_converted && target_machine->C_promote_integer(res_int,lhs,old);
 			const bool rhs_negative = rhs_converted && target_machine->C_promote_integer(rhs_int,rhs,old);
 			if (lhs_converted && rhs_converted)
@@ -7060,7 +7271,11 @@
 	case 1:	{
 			assert(converts_to_integerlike(src.data<2>()->type_code.base_type_index));
 			bool is_true = false;
-			if (literal_converts_to_bool(*src.data<2>(),is_true) && !is_true)
+			if (literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				) && !is_true)
 				{	// __ + 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -7071,7 +7286,11 @@
 	case 2:	{
 			assert(converts_to_integerlike(src.data<1>()->type_code.base_type_index));
 			bool is_true = false;
-			if (literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)
+			if (literal_converts_to_bool(*src.data<1>(),is_true
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				) && !is_true)
 				{	// 0 + __ |-> __
 				src.eval_to_arg<2>(0);
 				src.type_code = old_type;
@@ -7086,7 +7305,7 @@
 	return false;
 }
 
-static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'-'>(src));
 
@@ -7106,7 +7325,11 @@
 			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index));
 			assert(converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index));
 			bool is_true = false;
-			if 		(literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)
+			if 		(literal_converts_to_bool(*src.data<1>(),is_true
+#/*cut-cpp*/
+					,types
+#/*cut-cpp*/
+					) && !is_true)
 				{	// 0 - __ |-> - __
 				src.DeleteIdx<1>(0);
 				src.core_flag_update();
@@ -7116,7 +7339,11 @@
 				src.type_code = old_type;				
 				return true;
 				}
-			else if (literal_converts_to_bool(*src.data<2>(),is_true) && !is_true)
+			else if (literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+					) && !is_true)
 				{	// __ - 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -7124,8 +7351,16 @@
 				}
 			umaxint res_int;
 			umaxint rhs_int;
-			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
-			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
+			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
+#/*cut-cpp*/
+				, types
+#/*cut-cpp*/					
+				);
+			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
+#/*cut-cpp*/
+				, types
+#/*cut-cpp*/					
+				);
 			if (lhs_converted && rhs_converted)
 				{	//! \todo deal with signed integer arithmetic
 				const promote_aux old(old_type.base_type_index);
@@ -7212,7 +7447,11 @@
 	case 1:	{
 			assert(converts_to_integerlike(src.data<2>()->type_code.base_type_index));
 			bool is_true = false;
-			if (literal_converts_to_bool(*src.data<2>(),is_true) && !is_true)
+			if (literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				) && !is_true)
 				{	// __ - 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -7240,7 +7479,7 @@
 
 // +: either both are arithmetic, or one is raw pointer and one is integer
 // -: either both are arithmetic, or both are compatible raw pointer, or left is raw pointer and right is integer
-static void C_CPP_add_expression_easy_syntax_check(parse_tree& src,const type_system& types,func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static void C_CPP_add_expression_easy_syntax_check(parse_tree& src,const type_system& types,literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert((C99_ADD_SUBTYPE_PLUS==src.subtype && is_C99_add_operator_expression<'+'>(src)) || (C99_ADD_SUBTYPE_MINUS==src.subtype && is_C99_add_operator_expression<'-'>(src)));
 	BOOST_STATIC_ASSERT(1==C99_ADD_SUBTYPE_MINUS-C99_ADD_SUBTYPE_PLUS);
@@ -7485,7 +7724,7 @@
 	return false;
 }
 
-static bool eval_shift(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_shift(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -7500,7 +7739,11 @@
 	// error if RHS is literal "out of bounds"
 	const type_spec old_type = src.type_code;
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<2>(),is_true) && !is_true)
+	if (literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		) && !is_true)
 		{
 		if (!is_true)
 			{	// __ << 0 or __ >> 0: lift
@@ -7511,7 +7754,11 @@
 		};
 
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(rhs_int,*src.data<2>()))
+	if (intlike_literal_to_VM(rhs_int,*src.data<2>()
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		))
 		{
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(old_type.base_type_index);
 		const bool undefined_behavior = target_machine->C_bit(machine_type)<=rhs_int;
@@ -7520,7 +7767,11 @@
 		if (undefined_behavior)
 			simple_error(src," : RHS is at least as large as bits of LHS; undefined behavior (C99 6.5.7p3/C++98 5.8p1)");
 
-		if (literal_converts_to_bool(*src.data<1>(),is_true))
+		if (literal_converts_to_bool(*src.data<1>(),is_true
+#/*cut-cpp*/
+			,types
+#/*cut-cpp*/
+			))
 			{
 			if (!is_true)
 				{	// 0 << __ or 0 >> __: zero out (note that we can do this even if we invoked undefined behavior)
@@ -7532,7 +7783,11 @@
 		if (undefined_behavior) return false;
 
 		umaxint res_int;
-		if (intlike_literal_to_VM(res_int,*src.data<1>()))
+		if (intlike_literal_to_VM(res_int,*src.data<1>()
+#/*cut-cpp*/
+			,types
+#/*cut-cpp*/
+			))
 			{
 			// note that incoming negative signed integers are not handled by this code path
 			if (C99_SHIFT_SUBTYPE_LEFT==src.subtype)
@@ -7656,7 +7911,7 @@
 	return false;
 }
 
-static bool eval_relation_expression(parse_tree& src, const type_system& types,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_relation_expression(parse_tree& src, const type_system& types,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_GT-C99_RELATION_SUBTYPE_LT);
 	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_LTE-C99_RELATION_SUBTYPE_GT);
@@ -7665,8 +7920,16 @@
 	umaxint lhs_int;
 	umaxint rhs_int;
 
-	const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>());
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
+	const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>()
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		);
 	if (lhs_converted && rhs_converted)
 		{
 		const char* result 	= NULL;
@@ -7845,7 +8108,7 @@
 	return false;
 }
 
-static bool eval_equality_expression(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_equality_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {	
 	BOOST_STATIC_ASSERT(1==C99_EQUALITY_SUBTYPE_NEQ-C99_EQUALITY_SUBTYPE_EQ);
 	assert(C99_EQUALITY_SUBTYPE_EQ<=src.subtype && C99_EQUALITY_SUBTYPE_NEQ>=src.subtype);
@@ -7869,7 +8132,11 @@
 			break;
 			}
 	case 1:	{
-			if (0<src.data<2>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<1>(),is_true)) 
+			if (0<src.data<2>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<1>(),is_true
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				)) 
 				{
 				if (!is_true)
 					{	
@@ -7890,7 +8157,11 @@
 			break;
 			}
 	case 2:	{
-			if (0<src.data<1>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<2>(),is_true)) 
+			if (0<src.data<1>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				)) 
 				{
 				if (!is_true)
 					{
@@ -7916,8 +8187,16 @@
 			const promote_aux old(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
 			assert(old.bitcount>=lhs.bitcount);
 			assert(old.bitcount>=rhs.bitcount);
-			const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>());
-			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
+			const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>()
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				);
+			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				);
 			// general case here in case we try to do with converted/not converted mixed cases
 //			if (lhs_converted) target_machine->C_promote_integer(lhs_int,lhs,old);
 //			if (rhs_converted) target_machine->C_promote_integer(rhs_int,rhs,old);
@@ -8073,7 +8352,7 @@
 	return false;
 }
 
-static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -8084,8 +8363,16 @@
 	// unary - gives us problems (result is target-specific, could generate a trap representation)
 	const type_spec old_type = src.type_code;
 	bool is_true = false;
-	if (	(literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)	// 0 & __
-		||	(literal_converts_to_bool(*src.data<2>(),is_true) && !is_true))	// __ & 0
+	if (	(literal_converts_to_bool(*src.data<1>(),is_true
+#/*cut-cpp*/
+			,types
+#/*cut-cpp*/
+			) && !is_true)	// 0 & __
+		||	(literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+			,types
+#/*cut-cpp*/
+			) && !is_true))	// __ & 0
 		{
 		if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
 			{
@@ -8104,7 +8391,15 @@
 
 	umaxint lhs_int;
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(lhs_int,*src.data<1>()) && intlike_literal_to_VM(rhs_int,*src.data<2>()))
+	if (intlike_literal_to_VM(lhs_int,*src.data<1>()
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		) && intlike_literal_to_VM(rhs_int,*src.data<2>()
+#/*cut-cpp*/
+			,types
+#/*cut-cpp*/
+			))
 		{
 		const promote_aux old(old_type.base_type_index);
 		umaxint res_int(lhs_int);
@@ -8248,7 +8543,7 @@
 	return false;
 }
 
-static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -8258,7 +8553,11 @@
 	// __ ^ 0 |-> __
 	// also handle double-literal case
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true))
+	if (literal_converts_to_bool(*src.data<1>(),is_true
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		))
 		{
 		if (!is_true)
 			{	// 0 ^ __
@@ -8267,7 +8566,11 @@
 			return true;
 			}
 		};
-	if (literal_converts_to_bool(*src.data<2>(),is_true))
+	if (literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		))
 		{
 		if (!is_true)
 			{	// __ ^ 0
@@ -8279,7 +8582,15 @@
 
 	umaxint lhs_int;
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(lhs_int,*src.data<1>()) && intlike_literal_to_VM(rhs_int,*src.data<2>()))
+	if (intlike_literal_to_VM(lhs_int,*src.data<1>()
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		) && intlike_literal_to_VM(rhs_int,*src.data<2>()
+#/*cut-cpp*/
+			,types
+#/*cut-cpp*/
+		))
 		{
 		const type_spec old_type = src.type_code;
 		const promote_aux old(old_type.base_type_index);
@@ -8416,7 +8727,7 @@
 	return false;
 }
 
-static bool eval_bitwise_OR(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_bitwise_OR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -8426,7 +8737,11 @@
 	// int-literal | int-literal |-> int-literal *if* both fit
 	// unary - gives us problems (result is target-specific, could generate a trap representation)
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true))
+	if (literal_converts_to_bool(*src.data<1>(),is_true
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		))
 		{
 		if (!is_true)
 			{	// 0 | __
@@ -8435,7 +8750,11 @@
 			return true;
 			}
 		};
-	if (literal_converts_to_bool(*src.data<2>(),is_true))
+	if (literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		))
 		{
 		if (!is_true)
 			{	// __ | 0
@@ -8447,7 +8766,15 @@
 
 	umaxint lhs_int;
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(lhs_int,*src.data<1>()) && intlike_literal_to_VM(rhs_int,*src.data<2>()))
+	if (intlike_literal_to_VM(lhs_int,*src.data<1>()
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		) && intlike_literal_to_VM(rhs_int,*src.data<2>()
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		))
 		{
 		const type_spec old_type = src.type_code;
 		umaxint res_int(lhs_int);
@@ -8609,7 +8936,7 @@
 	return false;
 }
 
-static bool eval_logical_AND(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool)
+static bool eval_logical_AND(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool)
 {
 	// deal with literals here.  && short-circuit evaluates.
 	// 1 && __ |-> 0!=__
@@ -8619,7 +8946,11 @@
 	// (__ && 1) && __ |-> __ && 1
 
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true))
+	if (literal_converts_to_bool(*src.data<1>(),is_true
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		))
 		{	// one of 0 && __ or 1 && __
 		if (!is_true)
 			{	// 0 && __
@@ -8633,7 +8964,11 @@
 			force_decimal_literal(src,"0",types);
 			return true;
 			}
-		else if (literal_converts_to_bool(*src.data<2>(),is_true))
+		else if (literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+			,types
+#/*cut-cpp*/
+			))
 			{	// 1 && 1 or 1 && 0
 			force_decimal_literal(src,is_true ? "1" : "0",types);
 			return true;
@@ -8752,7 +9087,7 @@
 	return false;
 }
 
-static bool eval_logical_OR(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool)
+static bool eval_logical_OR(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool)
 {
 	// deal with literals here.  || short-circuit evaluates.
 	// 0 || __ |-> 0!=__
@@ -8762,7 +9097,11 @@
 	// (__ || 1) || __ |-> __ || 1
 
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true))
+	if (literal_converts_to_bool(*src.data<1>(),is_true
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		))
 		{	// one of 0 || __ or 1 || __
 		if (is_true)
 			{	// 1 || __
@@ -8776,7 +9115,11 @@
 			force_decimal_literal(src,"1",types);
 			return true;
 			}
-		else if (literal_converts_to_bool(*src.data<2>(),is_true))
+		else if (literal_converts_to_bool(*src.data<2>(),is_true
+#/*cut-cpp*/
+			,types
+#/*cut-cpp*/
+			))
 			{	// 0 || 1 or 0 || 0
 			force_decimal_literal(src,is_true ? "1" : "0",types);
 			return true;
@@ -8897,10 +9240,18 @@
 	return false;
 }
 
-static bool eval_conditional_op(parse_tree& src, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool)
+static bool eval_conditional_op(parse_tree& src, literal_converts_to_bool_func& literal_converts_to_bool
+#/*cut-cpp*/
+		, const type_system& types
+#/*cut-cpp*/
+	)
 {
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.c_array<1>(),is_true))
+	if (literal_converts_to_bool(*src.c_array<1>(),is_true
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		))
 		{
 		const bool was_invalid = src.flags & parse_tree::INVALID;
 		const type_spec old_type = src.type_code;
@@ -8937,7 +9288,11 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<2>(),C99_intlike_literal_to_VM))
+			else if (is_null_pointer_constant(*src.data<2>(),C99_intlike_literal_to_VM
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				))
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -8956,7 +9311,11 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<0>(),C99_intlike_literal_to_VM))
+			else if (is_null_pointer_constant(*src.data<0>(),C99_intlike_literal_to_VM
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				))
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -9006,7 +9365,11 @@
 		}
 	// 3) RAM conservation: if we have a suitable literal Do It Now
 	// \todo disable this at O0?
-	if (eval_conditional_op(src,C99_literal_converts_to_bool)) return;
+	if (eval_conditional_op(src,C99_literal_converts_to_bool
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		)) return;
 }
 
 static void CPP_conditional_op_easy_syntax_check(parse_tree& src,const type_system& types)
@@ -9027,7 +9390,11 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<2>(),CPP_intlike_literal_to_VM))
+			else if (is_null_pointer_constant(*src.data<2>(),CPP_intlike_literal_to_VM
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				))
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -9046,7 +9413,11 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<0>(),CPP_intlike_literal_to_VM))
+			else if (is_null_pointer_constant(*src.data<0>(),CPP_intlike_literal_to_VM
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				))
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -9095,7 +9466,11 @@
 		}
 	// 3) RAM conservation: if we have a suitable literal Do It Now
 	// \todo disable this at O0?
-	if (eval_conditional_op(src,CPP_literal_converts_to_bool)) return;
+	if (eval_conditional_op(src,CPP_literal_converts_to_bool
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+		)) return;
 }
 
 static void locate_C99_conditional_op(parse_tree& src, size_t& i, const type_system& types)
@@ -9601,7 +9976,7 @@
 eval_array_deref(parse_tree& src,const type_system& types,
 				 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 				 func_traits<bool (*)(const parse_tree&)>::function_ref_type literal_converts_to_integer,
-				 func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+				 intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (!is_array_deref(src)) return false;
 	// crunch __[...]
@@ -9615,7 +9990,11 @@
 		if (UINT_MAX>str_index)
 			{
 			umaxint tmp; 
-			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index))) return false;
+			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index)
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				)) return false;
 			const size_t promoted_type = default_promote_type(src.type_code.base_type_index);
 			const virtual_machine::std_int_enum machine_type = (virtual_machine::std_int_enum)((promoted_type-C_TYPE::INT)/2+virtual_machine::std_int_int);
 			eval_string_literal_deref(src,types,src.data(str_index)->index_tokens[0].token,tmp,tmp.test(target_machine->C_bit(machine_type)-1),C_TESTFLAG_CHAR_LITERAL==src.data(1-str_index)->index_tokens[0].flags);
@@ -9649,7 +10028,7 @@
 static bool eval_logical_NOT(parse_tree& src, const type_system& types,
 							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							 func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_NOT_expression,
-							 func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool)
+							 literal_converts_to_bool_func& literal_converts_to_bool)
 {
 	if (is_logical_NOT_expression(src))
 		{
@@ -9662,7 +10041,7 @@
 static bool eval_bitwise_compl(	parse_tree& src, const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,
-								func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+								intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_bitwise_complement_expression(src))
 		{
@@ -9685,8 +10064,8 @@
 
 static bool eval_unary_minus(parse_tree& src, const type_system& types,
 							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							 func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,
-							 func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							 literal_converts_to_bool_func& literal_converts_to_bool,
+							 intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_unary_operator_expression<'-'>(src))
 		{
@@ -9698,8 +10077,8 @@
 
 static bool eval_mult_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-								func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+								literal_converts_to_bool_func& literal_converts_to_bool,
+								intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_mult_operator_expression<'*'>(src))
 		{
@@ -9712,8 +10091,8 @@
 
 static bool eval_div_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-								func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+								literal_converts_to_bool_func& literal_converts_to_bool,
+								intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_mult_operator_expression<'/'>(src))
 		{
@@ -9726,8 +10105,8 @@
 
 static bool eval_mod_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-								func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+								literal_converts_to_bool_func& literal_converts_to_bool,
+								intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_mult_operator_expression<'%'>(src))
 		{
@@ -9741,8 +10120,8 @@
 
 static bool eval_add_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_add_operator_expression<'+'>(src))
 		{
@@ -9755,8 +10134,8 @@
 
 static bool eval_sub_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_add_operator_expression<'-'>(src))
 		{
@@ -9769,8 +10148,8 @@
 
 static bool eval_shift(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_shift_expression(src))
 		{
@@ -9783,7 +10162,7 @@
 
 static bool eval_relation_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_relation_expression(src))
 		{
@@ -9797,8 +10176,8 @@
 static bool eval_equality_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_equality_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_equality_expression(src))
 		{
@@ -9812,8 +10191,8 @@
 static bool eval_bitwise_AND(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_AND_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_bitwise_AND_expression(src))
 		{
@@ -9827,8 +10206,8 @@
 static bool eval_bitwise_XOR(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_XOR_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_bitwise_XOR_expression(src))
 		{
@@ -9842,8 +10221,8 @@
 static bool eval_bitwise_OR(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_OR_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_bitwise_OR_expression(src))
 		{
@@ -9857,7 +10236,7 @@
 static bool eval_logical_AND(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_AND_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool)
+							literal_converts_to_bool_func& literal_converts_to_bool)
 {
 	if (is_logical_AND_expression(src))
 		{
@@ -9871,7 +10250,7 @@
 static bool eval_logical_OR(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_OR_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool)
+							literal_converts_to_bool_func& literal_converts_to_bool)
 {
 	if (is_logical_OR_expression(src))
 		{
@@ -9884,12 +10263,16 @@
 
 static bool eval_conditional_operator(parse_tree& src,const type_system& types,
 									  func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-									  func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool)
+									  literal_converts_to_bool_func& literal_converts_to_bool)
 {
 	if (is_C99_conditional_operator_expression(src))
 		{	// prefix operator is boolean
 		EvalParseTree(*src.c_array<1>(),types);
-		if (eval_conditional_op(src,literal_converts_to_bool)) return true;
+		if (eval_conditional_op(src,literal_converts_to_bool
+#/*cut-cpp*/
+		,types
+#/*cut-cpp*/
+			)) return true;
 		}
 	return false;
 }
@@ -10005,8 +10388,16 @@
 			{
 			umaxint res_int;
 			umaxint rhs_int;
-			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data<1>());
-			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data<2>());
+			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data<1>()
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				);
+			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data<2>()
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				);
 			if (lhs_converted && rhs_converted)
 				{	//! \todo deal with signed integer arithmetic
 				const promote_aux old(old_type.base_type_index);
@@ -10073,8 +10464,16 @@
 			{
 			umaxint res_int;
 			umaxint rhs_int;
-			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data<1>());
-			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data<2>());
+			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data<1>()
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				);
+			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data<2>()
+#/*cut-cpp*/
+				,types
+#/*cut-cpp*/
+				);
 			if (lhs_converted && rhs_converted)
 				{	//! \todo deal with signed integer arithmetic
 				const promote_aux old(old_type.base_type_index);
@@ -10661,7 +11060,7 @@
 			if (!enumerator_to_integer_representation(parsetree,types)) throw std::bad_alloc();
 
 		bool is_true = false;
-		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true))
+		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true,types))
 			{	//! \bug need test cases
 			parsetree.destroy();	// efficiency
 			message_header(src.data<0>()[i].index_tokens[0]);
@@ -10752,7 +11151,7 @@
 	return true;
 }
 
-static bool record_enum_values(parse_tree& src, type_system& types, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits<const char* (*)(const char*, size_t)>::function_ref_type echo_reserved_keyword, func_traits<bool (*)(unsigned_var_int&,const parse_tree&)>::function_ref_type intlike_literal_to_VM, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type CondenseParseTree, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
+static bool record_enum_values(parse_tree& src, type_system& types, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits<const char* (*)(const char*, size_t)>::function_ref_type echo_reserved_keyword, intlike_literal_to_VM_func& intlike_literal_to_VM, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type CondenseParseTree, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
 {
 	assert(enum_type_index);
 	assert(!active_namespace || *active_namespace);
@@ -11041,7 +11440,7 @@
 		parse_tree_class tmp(src,origin,i-comma_overextended,0);
 		if (tmp.is_raw_list() && !CondenseParseTree(tmp,types)) return false;
 		if (!EvalParseTree(tmp,types)) return false;
-		if (!intlike_literal_to_VM(latest_value,tmp))
+		if (!intlike_literal_to_VM(latest_value,tmp,types))
 			{	//! \bug need test case
 			message_header(src.data<0>()[origin-2].index_tokens[0]);
 			INC_INFORM(ERR_STR);

Modified: trunk/CSupport.hpp
===================================================================
--- trunk/CSupport.hpp	2010-03-21 19:23:33 UTC (rev 353)
+++ trunk/CSupport.hpp	2010-03-21 19:24:26 UTC (rev 354)
@@ -122,7 +122,7 @@
 	func_traits<void (*)(parse_tree&,type_system&)>::function_ref_type ContextParse;		// return true iff no errors
 	// zcc 0.0.3
 	func_traits<void (*)(parse_tree&,const size_t,const type_system&)>::function_ref_type LocateExpression;
-	func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type LiteralConvertsToBool;
+	func_traits<bool (*)(const parse_tree&, bool&,const type_system&)>::function_ref_type LiteralConvertsToBool;
 #/*cut-cpp*/
 };
 

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-21 19:23:33 UTC (rev 353)
+++ trunk/CSupport_pp.cpp	2010-03-21 19:24:26 UTC (rev 354)
@@ -3791,9 +3791,11 @@
 }
 
 // forward-declare to handle recursion
-static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src);
+static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
+	);
 
-static bool _C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src)
+static bool _C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
+	)
 {
 	assert(C_TYPE::INTEGERLIKE!=src.type_code.base_type_index);
 
@@ -3810,8 +3812,10 @@
 				{
 				umaxint lhs_int;
 				umaxint rhs_int;
-				if (	C99_intlike_literal_to_VM(lhs_int,*src.data<1>())
-					&&	C99_intlike_literal_to_VM(rhs_int,*src.data<2>()))
+				if (	C99_intlike_literal_to_VM(lhs_int,*src.data<1>()
+					)
+					&&	C99_intlike_literal_to_VM(rhs_int,*src.data<2>()
+					))
 					{
 					const promote_aux rhs(src.data<2>()->type_code.base_type_index);
 					assert(old.bitcount>=rhs.bitcount);
@@ -3842,7 +3846,7 @@
 		dest.set_bitcount(VM_MAX_BIT_PLATFORM);
 		return true;
 		}	
-
+		
 	if (!(C_TESTFLAG_INTEGER & src.index_tokens[0].flags)) return false;
 	C_PPIntCore tmp;
 	ZAIMONI_PASSTHROUGH_ASSERT(C_PPIntCore::is(src.index_tokens[0].token.first,src.index_tokens[0].token.second,tmp));
@@ -3872,11 +3876,13 @@
 
 // return value: literal to parse, whether additive inverse applies
 static POD_pair<const parse_tree*,bool>
-_find_intlike_literal(const parse_tree* src)
+_find_intlike_literal(const parse_tree* src
+	)
 {
 	assert(NULL!=src);
 	POD_pair<const parse_tree*,bool> ret = {src,false};
-	while(converts_to_integer(ret.first->type_code))
+	while(converts_to_integer(ret.first->type_code
+		))
 		{
 		if 		(is_C99_unary_operator_expression<'-'>(*ret.first))
 			{
@@ -3895,14 +3901,21 @@
 	return ret;
 }
 
-static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src)
+// use this typedef to cope with signature varying by build
+typedef bool (intlike_literal_to_VM_func)(umaxint& dest, const parse_tree& src
+	);
+
+static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
+	)
 {
-	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src);
+	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src
+		);
 
 	if (C_TYPE::INTEGERLIKE==actual.first->type_code.base_type_index)
 		return false;	
 
-	if (!_C99_intlike_literal_to_VM(dest,*actual.first)) return false;
+	if (!_C99_intlike_literal_to_VM(dest,*actual.first
+		)) return false;
 	if (actual.second)
 		{
 		const promote_aux old(src.type_code.base_type_index);
@@ -3914,16 +3927,19 @@
 	return true;
 }
 
-static bool CPP_intlike_literal_to_VM(umaxint& dest, const parse_tree& src)
+static bool CPP_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
+	)
 {
-	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src);
+	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src
+		);
 
 	if (!_CPP_intlike_literal_to_VM(dest,*actual.first))
 		{
 		if (C_TYPE::INTEGERLIKE==actual.first->type_code.base_type_index)
 			return false;	
 
-		if (!_C99_intlike_literal_to_VM(dest,*actual.first)) return false;
+		if (!_C99_intlike_literal_to_VM(dest,*actual.first
+			)) return false;
 		};
 	if (actual.second)
 		{
@@ -3942,11 +3958,13 @@
  * \return -1 : can't decide quickly whether this is a null 
  *         pointer constant
  */
-int is_null_pointer_constant(const parse_tree& src, func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static int is_null_pointer_constant(const parse_tree& src,intlike_literal_to_VM_func& intlike_literal_to_VM
+	)
 {	//! \bug doesn't recognize enumerators with value zero
 	if (!converts_to_integerlike(src.type_code)) return 0;
 	umaxint tmp;
-	if (intlike_literal_to_VM(tmp,src)) return tmp==0;
+	if (intlike_literal_to_VM(tmp,src
+		)) return tmp==0;
 	return -1;
 }
 
@@ -4708,8 +4726,13 @@
 		}
 }
 
+// typedef to simplify compatibility changes
+typedef bool literal_converts_to_bool_func(const parse_tree& src, bool& is_true
+	);
+
 // Closely related to if_elif_control_is_zero/CPreproc.cpp
-static bool _C99_literal_converts_to_bool(const parse_tree& src, bool& is_true)
+static bool _C99_literal_converts_to_bool(const parse_tree& src, bool& is_true
+	)
 {
 	assert(src.is_atomic());
 	// string literals always test true (decay to non-NULL pointer)
@@ -4731,21 +4754,27 @@
 	return true;
 }
 
-static bool C99_literal_converts_to_bool(const parse_tree& src, bool& is_true)
+static bool C99_literal_converts_to_bool(const parse_tree& src, bool& is_true
+	)
 {	// deal with -1 et. al.
-	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return _C99_literal_converts_to_bool(*src.data<2>(),is_true);
+	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return _C99_literal_converts_to_bool(*src.data<2>(),is_true
+		);
 
 	if (!src.is_atomic()) return false;
-	return _C99_literal_converts_to_bool(src,is_true);
+	return _C99_literal_converts_to_bool(src,is_true
+		);
 }
 
-static bool CPP_literal_converts_to_bool(const parse_tree& src, bool& is_true)
+static bool CPP_literal_converts_to_bool(const parse_tree& src, bool& is_true
+	)
 {
 	// deal with -1 et. al.
-	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return CPP_literal_converts_to_bool(*src.data<2>(),is_true);
+	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return CPP_literal_converts_to_bool(*src.data<2>(),is_true
+		);
 
 	if (!src.is_atomic()) return false;
-	if (_C99_literal_converts_to_bool(src,is_true)) return true;
+	if (_C99_literal_converts_to_bool(src,is_true
+		)) return true;
 	// deal with: this, true, false
 	if (token_is_string<5>(src.index_tokens[0].token,"false"))
 		{
@@ -4931,11 +4960,12 @@
 	return false;
 }
 
-static bool eval_unary_minus(parse_tree& src, const type_system& types,func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_unary_minus(parse_tree& src, const type_system& types,literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_unary_operator_expression<'-'>(src));
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<2>(),is_true) && !is_true && (1==(src.type_code.base_type_index-C_TYPE::INT)%2 || virtual_machine::twos_complement==target_machine->C_signed_int_representation() || bool_options[boolopt::int_traps]))
+	if (literal_converts_to_bool(*src.data<2>(),is_true
+		) && !is_true && (1==(src.type_code.base_type_index-C_TYPE::INT)%2 || virtual_machine::twos_complement==target_machine->C_signed_int_representation() || bool_options[boolopt::int_traps]))
 		{	// -0==0
 			// deal with unary - not being allowed to actually return -0 on these machines later
 		const type_spec old_type = src.type_code;
@@ -4948,7 +4978,8 @@
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
 		const type_spec old_type = src.type_code;
 		umaxint res_int;
-		intlike_literal_to_VM(res_int,*src.data<2>());
+		intlike_literal_to_VM(res_int,*src.data<2>()
+			);
 		target_machine->unsigned_additive_inverse(res_int,machine_type);
 
 		//! \todo flag failures to reduce as RAM-stalled
@@ -5163,12 +5194,13 @@
 	return false;
 }
 
-static bool eval_logical_NOT(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_NOT, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool)
+static bool eval_logical_NOT(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_NOT, literal_converts_to_bool_func& literal_converts_to_bool)
 {
 	assert(is_logical_NOT(src));
 	{	// deal with literals that convert to bool here
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<2>(),is_true))
+	if (literal_converts_to_bool(*src.data<2>(),is_true
+		))
 		{
 		src.destroy();
 		src.index_tokens[0].token.first = (is_true) ? "0" : "1";
@@ -5383,12 +5415,13 @@
 	return true;
 }
 
-static bool eval_bitwise_compl(parse_tree& src, const type_system& types,bool hard_error,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_bitwise_compl(parse_tree& src, const type_system& types,bool hard_error,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_bitwise_complement_expression(src));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
 	umaxint res_int;
-	if (intlike_literal_to_VM(res_int,*src.data<2>())) 
+	if (intlike_literal_to_VM(res_int,*src.data<2>()
+		)) 
 		{
 		const type_spec old_type = src.type_code;
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(old_type.base_type_index);
@@ -5814,7 +5847,7 @@
 	return false;
 }
 
-static bool eval_mult_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_mult_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'*'>(src));
 
@@ -5822,8 +5855,10 @@
 	bool is_true = false;
 
 	// do this first to avoid unnecessary dynamic memory allocation
-	if (	(literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)	// 0 * __
-		||	(literal_converts_to_bool(*src.data<2>(),is_true) && !is_true))	// __ * 0
+	if (	(literal_converts_to_bool(*src.data<1>(),is_true
+			) && !is_true)	// 0 * __
+		||	(literal_converts_to_bool(*src.data<2>(),is_true
+			) && !is_true))	// __ * 0
 		{
 		// construct +0 to defuse 1-0*6
 		parse_tree tmp = decimal_literal("0",src,types);
@@ -5843,8 +5878,10 @@
 
 	umaxint res_int;
 	umaxint rhs_int;
-	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
+	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
+		);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
+		);
 	if (lhs_converted && 1==res_int)
 		{
 		src.eval_to_arg<2>(0);
@@ -5924,7 +5961,7 @@
 	return false;
 }
 
-static bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'/'>(src));
 
@@ -5932,7 +5969,8 @@
 	bool is_true = false;
 	if (converts_to_integerlike(src.type_code))
 		{
-		if 		(literal_converts_to_bool(*src.data<2>(),is_true) && !is_true)
+		if 		(literal_converts_to_bool(*src.data<2>(),is_true
+				) && !is_true)
 			{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
 			if (hard_error)
 				//! \test default/Error_if_control30.hpp, default/Error_if_control30.h
@@ -5940,7 +5978,8 @@
 			return false;
 			}
 		/*! \todo would like a simple comparison of absolute values to auto-detect zero, possibly after mainline code */
-		else if (literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)
+		else if (literal_converts_to_bool(*src.data<1>(),is_true
+				) && !is_true)
 			{
 			// construct +0 to defuse 1-0/6
 			parse_tree tmp = decimal_literal("0",src,types);
@@ -5962,8 +6001,10 @@
 
 	umaxint res_int;
 	umaxint rhs_int;
-	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
+	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
+		);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
+		);
 	if (rhs_converted && rhs_int==1)
 		{	// __/1 |-> __
 		src.eval_to_arg<1>(0);
@@ -6051,7 +6092,7 @@
 	return false;
 }
 
-static bool eval_mod_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_mod_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'%'>(src));
 
@@ -6059,7 +6100,8 @@
 	bool is_true = false;
 	if (converts_to_integerlike(src.type_code))
 		{
-		if 		(literal_converts_to_bool(*src.data<2>(),is_true) && !is_true)
+		if 		(literal_converts_to_bool(*src.data<2>(),is_true
+				) && !is_true)
 			{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
 			if (hard_error)
 				//! \test default/Error_if_control31.hpp, Error_if_control31.h
@@ -6067,7 +6109,8 @@
 			return false;
 			}
 		/*! \todo would like a simple comparison of absolute values to auto-detect zero, possibly after mainline code */
-		else if (literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)
+		else if (literal_converts_to_bool(*src.data<1>(),is_true
+				) && !is_true)
 			{
 			// construct +0 to defuse 1-0%6
 			parse_tree tmp = decimal_literal("0",src,types);
@@ -6089,8 +6132,10 @@
 
 	umaxint res_int;
 	umaxint rhs_int;
-	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
+	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
+		);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
+		);
 	if (rhs_converted && rhs_int==1)
 		{	// __%1 |-> +0
 		parse_tree tmp = decimal_literal("0",src,types);
@@ -6408,7 +6453,7 @@
 	return false;
 }
 
-static bool eval_add_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_add_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'+'>(src));
 
@@ -6428,13 +6473,15 @@
 			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index));
 			assert(converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index));
 			bool is_true = false;
-			if 		(literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)
+			if 		(literal_converts_to_bool(*src.data<1>(),is_true
+					) && !is_true)
 				{	// 0 + __ |-> __
 				src.eval_to_arg<2>(0);
 				src.type_code = old_type;
 				return true;
 				}
-			else if (literal_converts_to_bool(*src.data<2>(),is_true) && !is_true)
+			else if (literal_converts_to_bool(*src.data<2>(),is_true
+					) && !is_true)
 				{	// __ + 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -6447,8 +6494,10 @@
 			assert(old.bitcount>=lhs.bitcount);
 			const promote_aux rhs(src.data<2>()->type_code.base_type_index);
 			assert(old.bitcount>=rhs.bitcount);
-			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
-			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
+			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
+				);
+			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
+				);
 			const bool lhs_negative = lhs_converted && target_machine->C_promote_integer(res_int,lhs,old);
 			const bool rhs_negative = rhs_converted && target_machine->C_promote_integer(rhs_int,rhs,old);
 			if (lhs_converted && rhs_converted)
@@ -6528,7 +6577,8 @@
 	case 1:	{
 			assert(converts_to_integerlike(src.data<2>()->type_code.base_type_index));
 			bool is_true = false;
-			if (literal_converts_to_bool(*src.data<2>(),is_true) && !is_true)
+			if (literal_converts_to_bool(*src.data<2>(),is_true
+				) && !is_true)
 				{	// __ + 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -6539,7 +6589,8 @@
 	case 2:	{
 			assert(converts_to_integerlike(src.data<1>()->type_code.base_type_index));
 			bool is_true = false;
-			if (literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)
+			if (literal_converts_to_bool(*src.data<1>(),is_true
+				) && !is_true)
 				{	// 0 + __ |-> __
 				src.eval_to_arg<2>(0);
 				src.type_code = old_type;
@@ -6554,7 +6605,7 @@
 	return false;
 }
 
-static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'-'>(src));
 
@@ -6574,7 +6625,8 @@
 			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index));
 			assert(converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index));
 			bool is_true = false;
-			if 		(literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)
+			if 		(literal_converts_to_bool(*src.data<1>(),is_true
+					) && !is_true)
 				{	// 0 - __ |-> - __
 				src.DeleteIdx<1>(0);
 				src.core_flag_update();
@@ -6584,7 +6636,8 @@
 				src.type_code = old_type;				
 				return true;
 				}
-			else if (literal_converts_to_bool(*src.data<2>(),is_true) && !is_true)
+			else if (literal_converts_to_bool(*src.data<2>(),is_true
+					) && !is_true)
 				{	// __ - 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -6592,8 +6645,10 @@
 				}
 			umaxint res_int;
 			umaxint rhs_int;
-			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>());
-			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
+			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
+				);
+			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
+				);
 			if (lhs_converted && rhs_converted)
 				{	//! \todo deal with signed integer arithmetic
 				const promote_aux old(old_type.base_type_index);
@@ -6680,7 +6735,8 @@
 	case 1:	{
 			assert(converts_to_integerlike(src.data<2>()->type_code.base_type_index));
 			bool is_true = false;
-			if (literal_converts_to_bool(*src.data<2>(),is_true) && !is_true)
+			if (literal_converts_to_bool(*src.data<2>(),is_true
+				) && !is_true)
 				{	// __ - 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -6708,7 +6764,7 @@
 
 // +: either both are arithmetic, or one is raw pointer and one is integer
 // -: either both are arithmetic, or both are compatible raw pointer, or left is raw pointer and right is integer
-static void C_CPP_add_expression_easy_syntax_check(parse_tree& src,const type_system& types,func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static void C_CPP_add_expression_easy_syntax_check(parse_tree& src,const type_system& types,literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert((C99_ADD_SUBTYPE_PLUS==src.subtype && is_C99_add_operator_expression<'+'>(src)) || (C99_ADD_SUBTYPE_MINUS==src.subtype && is_C99_add_operator_expression<'-'>(src)));
 	BOOST_STATIC_ASSERT(1==C99_ADD_SUBTYPE_MINUS-C99_ADD_SUBTYPE_PLUS);
@@ -6953,7 +7009,7 @@
 	return false;
 }
 
-static bool eval_shift(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_shift(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -6968,7 +7024,8 @@
 	// error if RHS is literal "out of bounds"
 	const type_spec old_type = src.type_code;
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<2>(),is_true) && !is_true)
+	if (literal_converts_to_bool(*src.data<2>(),is_true
+		) && !is_true)
 		{
 		if (!is_true)
 			{	// __ << 0 or __ >> 0: lift
@@ -6979,7 +7036,8 @@
 		};
 
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(rhs_int,*src.data<2>()))
+	if (intlike_literal_to_VM(rhs_int,*src.data<2>()
+		))
 		{
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(old_type.base_type_index);
 		const bool undefined_behavior = target_machine->C_bit(machine_type)<=rhs_int;
@@ -6988,7 +7046,8 @@
 		if (undefined_behavior)
 			simple_error(src," : RHS is at least as large as bits of LHS; undefined behavior (C99 6.5.7p3/C++98 5.8p1)");
 
-		if (literal_converts_to_bool(*src.data<1>(),is_true))
+		if (literal_converts_to_bool(*src.data<1>(),is_true
+			))
 			{
 			if (!is_true)
 				{	// 0 << __ or 0 >> __: zero out (note that we can do this even if we invoked undefined behavior)
@@ -7000,7 +7059,8 @@
 		if (undefined_behavior) return false;
 
 		umaxint res_int;
-		if (intlike_literal_to_VM(res_int,*src.data<1>()))
+		if (intlike_literal_to_VM(res_int,*src.data<1>()
+			))
 			{
 			// note that incoming negative signed integers are not handled by this code path
 			if (C99_SHIFT_SUBTYPE_LEFT==src.subtype)
@@ -7124,7 +7184,7 @@
 	return false;
 }
 
-static bool eval_relation_expression(parse_tree& src, const type_system& types,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_relation_expression(parse_tree& src, const type_system& types,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_GT-C99_RELATION_SUBTYPE_LT);
 	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_LTE-C99_RELATION_SUBTYPE_GT);
@@ -7133,8 +7193,10 @@
 	umaxint lhs_int;
 	umaxint rhs_int;
 
-	const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>());
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
+	const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>()
+		);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
+		);
 	if (lhs_converted && rhs_converted)
 		{
 		const char* result 	= NULL;
@@ -7313,7 +7375,7 @@
 	return false;
 }
 
-static bool eval_equality_expression(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_equality_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {	
 	BOOST_STATIC_ASSERT(1==C99_EQUALITY_SUBTYPE_NEQ-C99_EQUALITY_SUBTYPE_EQ);
 	assert(C99_EQUALITY_SUBTYPE_EQ<=src.subtype && C99_EQUALITY_SUBTYPE_NEQ>=src.subtype);
@@ -7337,7 +7399,8 @@
 			break;
 			}
 	case 1:	{
-			if (0<src.data<2>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<1>(),is_true)) 
+			if (0<src.data<2>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<1>(),is_true
+				)) 
 				{
 				if (!is_true)
 					{	
@@ -7358,7 +7421,8 @@
 			break;
 			}
 	case 2:	{
-			if (0<src.data<1>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<2>(),is_true)) 
+			if (0<src.data<1>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<2>(),is_true
+				)) 
 				{
 				if (!is_true)
 					{
@@ -7384,8 +7448,10 @@
 			const promote_aux old(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
 			assert(old.bitcount>=lhs.bitcount);
 			assert(old.bitcount>=rhs.bitcount);
-			const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>());
-			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
+			const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>()
+				);
+			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
+				);
 			// general case here in case we try to do with converted/not converted mixed cases
 //			if (lhs_converted) target_machine->C_promote_integer(lhs_int,lhs,old);
 //			if (rhs_converted) target_machine->C_promote_integer(rhs_int,rhs,old);
@@ -7541,7 +7607,7 @@
 	return false;
 }
 
-static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -7552,8 +7618,10 @@
 	// unary - gives us problems (result is target-specific, could generate a trap representation)
 	const type_spec old_type = src.type_code;
 	bool is_true = false;
-	if (	(literal_converts_to_bool(*src.data<1>(),is_true) && !is_true)	// 0 & __
-		||	(literal_converts_to_bool(*src.data<2>(),is_true) && !is_true))	// __ & 0
+	if (	(literal_converts_to_bool(*src.data<1>(),is_true
+			) && !is_true)	// 0 & __
+		||	(literal_converts_to_bool(*src.data<2>(),is_true
+			) && !is_true))	// __ & 0
 		{
 		if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
 			{
@@ -7572,7 +7640,9 @@
 
 	umaxint lhs_int;
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(lhs_int,*src.data<1>()) && intlike_literal_to_VM(rhs_int,*src.data<2>()))
+	if (intlike_literal_to_VM(lhs_int,*src.data<1>()
+		) && intlike_literal_to_VM(rhs_int,*src.data<2>()
+			))
 		{
 		const promote_aux old(old_type.base_type_index);
 		umaxint res_int(lhs_int);
@@ -7716,7 +7786,7 @@
 	return false;
 }
 
-static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -7726,7 +7796,8 @@
 	// __ ^ 0 |-> __
 	// also handle double-literal case
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true))
+	if (literal_converts_to_bool(*src.data<1>(),is_true
+		))
 		{
 		if (!is_true)
 			{	// 0 ^ __
@@ -7735,7 +7806,8 @@
 			return true;
 			}
 		};
-	if (literal_converts_to_bool(*src.data<2>(),is_true))
+	if (literal_converts_to_bool(*src.data<2>(),is_true
+		))
 		{
 		if (!is_true)
 			{	// __ ^ 0
@@ -7747,7 +7819,9 @@
 
 	umaxint lhs_int;
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(lhs_int,*src.data<1>()) && intlike_literal_to_VM(rhs_int,*src.data<2>()))
+	if (intlike_literal_to_VM(lhs_int,*src.data<1>()
+		) && intlike_literal_to_VM(rhs_int,*src.data<2>()
+		))
 		{
 		const type_spec old_type = src.type_code;
 		const promote_aux old(old_type.base_type_index);
@@ -7884,7 +7958,7 @@
 	return false;
 }
 
-static bool eval_bitwise_OR(parse_tree& src, const type_system& types, bool hard_error, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+static bool eval_bitwise_OR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code));
 	assert(converts_to_integerlike(src.data<2>()->type_code));
@@ -7894,7 +7968,8 @@
 	// int-literal | int-literal |-> int-literal *if* both fit
 	// unary - gives us problems (result is target-specific, could generate a trap representation)
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true))
+	if (literal_converts_to_bool(*src.data<1>(),is_true
+		))
 		{
 		if (!is_true)
 			{	// 0 | __
@@ -7903,7 +7978,8 @@
 			return true;
 			}
 		};
-	if (literal_converts_to_bool(*src.data<2>(),is_true))
+	if (literal_converts_to_bool(*src.data<2>(),is_true
+		))
 		{
 		if (!is_true)
 			{	// __ | 0
@@ -7915,7 +7991,9 @@
 
 	umaxint lhs_int;
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(lhs_int,*src.data<1>()) && intlike_literal_to_VM(rhs_int,*src.data<2>()))
+	if (intlike_literal_to_VM(lhs_int,*src.data<1>()
+		) && intlike_literal_to_VM(rhs_int,*src.data<2>()
+		))
 		{
 		const type_spec old_type = src.type_code;
 		umaxint res_int(lhs_int);
@@ -8077,7 +8155,7 @@
 	return false;
 }
 
-static bool eval_logical_AND(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool)
+static bool eval_logical_AND(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool)
 {
 	// deal with literals here.  && short-circuit evaluates.
 	// 1 && __ |-> 0!=__
@@ -8087,7 +8165,8 @@
 	// (__ && 1) && __ |-> __ && 1
 
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true))
+	if (literal_converts_to_bool(*src.data<1>(),is_true
+		))
 		{	// one of 0 && __ or 1 && __
 		if (!is_true)
 			{	// 0 && __
@@ -8101,7 +8180,8 @@
 			force_decimal_literal(src,"0",types);
 			return true;
 			}
-		else if (literal_converts_to_bool(*src.data<2>(),is_true))
+		else if (literal_converts_to_bool(*src.data<2>(),is_true
+			))
 			{	// 1 && 1 or 1 && 0
 			force_decimal_literal(src,is_true ? "1" : "0",types);
 			return true;
@@ -8220,7 +8300,7 @@
 	return false;
 }
 
-static bool eval_logical_OR(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool)
+static bool eval_logical_OR(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool)
 {
 	// deal with literals here.  || short-circuit evaluates.
 	// 0 || __ |-> 0!=__
@@ -8230,7 +8310,8 @@
 	// (__ || 1) || __ |-> __ || 1
 
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true))
+	if (literal_converts_to_bool(*src.data<1>(),is_true
+		))
 		{	// one of 0 || __ or 1 || __
 		if (is_true)
 			{	// 1 || __
@@ -8244,7 +8325,8 @@
 			force_decimal_literal(src,"1",types);
 			return true;
 			}
-		else if (literal_converts_to_bool(*src.data<2>(),is_true))
+		else if (literal_converts_to_bool(*src.data<2>(),is_true
+			))
 			{	// 0 || 1 or 0 || 0
 			force_decimal_literal(src,is_true ? "1" : "0",types);
 			return true;
@@ -8365,10 +8447,12 @@
 	return false;
 }
 
-static bool eval_conditional_op(parse_tree& src, func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool)
+static bool eval_conditional_op(parse_tree& src, literal_converts_to_bool_func& literal_converts_to_bool
+	)
 {
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.c_array<1>(),is_true))
+	if (literal_converts_to_bool(*src.c_array<1>(),is_true
+		))
 		{
 		const bool was_invalid = src.flags & parse_tree::INVALID;
 		const type_spec old_type = src.type_code;
@@ -8405,7 +8489,8 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<2>(),C99_intlike_literal_to_VM))
+			else if (is_null_pointer_constant(*src.data<2>(),C99_intlike_literal_to_VM
+				))
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -8424,7 +8509,8 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<0>(),C99_intlike_literal_to_VM))
+			else if (is_null_pointer_constant(*src.data<0>(),C99_intlike_literal_to_VM
+				))
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -8474,7 +8560,8 @@
 		}
 	// 3) RAM conservation: if we have a suitable literal Do It Now
 	// \todo disable this at O0?
-	if (eval_conditional_op(src,C99_literal_converts_to_bool)) return;
+	if (eval_conditional_op(src,C99_literal_converts_to_bool
+		)) return;
 }
 
 static void CPP_conditional_op_easy_syntax_check(parse_tree& src,const type_system& types)
@@ -8495,7 +8582,8 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<2>(),CPP_intlike_literal_to_VM))
+			else if (is_null_pointer_constant(*src.data<2>(),CPP_intlike_literal_to_VM
+				))
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -8514,7 +8602,8 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<0>(),CPP_intlike_literal_to_VM))
+			else if (is_null_pointer_constant(*src.data<0>(),CPP_intlike_literal_to_VM
+				))
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -8563,7 +8652,8 @@
 		}
 	// 3) RAM conservation: if we have a suitable literal Do It Now
 	// \todo disable this at O0?
-	if (eval_conditional_op(src,CPP_literal_converts_to_bool)) return;
+	if (eval_conditional_op(src,CPP_literal_converts_to_bool
+		)) return;
 }
 
 static void locate_C99_conditional_op(parse_tree& src, size_t& i, const type_system& types)
@@ -8911,7 +9001,7 @@
 eval_array_deref(parse_tree& src,const type_system& types,
 				 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 				 func_traits<bool (*)(const parse_tree&)>::function_ref_type literal_converts_to_integer,
-				 func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+				 intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (!is_array_deref(src)) return false;
 	// crunch __[...]
@@ -8925,7 +9015,8 @@
 		if (UINT_MAX>str_index)
 			{
 			umaxint tmp; 
-			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index))) return false;
+			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index)
+				)) return false;
 			const size_t promoted_type = default_promote_type(src.type_code.base_type_index);
 			const virtual_machine::std_int_enum machine_type = (virtual_machine::std_int_enum)((promoted_type-C_TYPE::INT)/2+virtual_machine::std_int_int);
 			eval_string_literal_deref(src,types,src.data(str_index)->index_tokens[0].token,tmp,tmp.test(target_machine->C_bit(machine_type)-1),C_TESTFLAG_CHAR_LITERAL==src.data(1-str_index)->index_tokens[0].flags);
@@ -8959,7 +9050,7 @@
 static bool eval_logical_NOT(parse_tree& src, const type_system& types,
 							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							 func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_NOT_expression,
-							 func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool)
+							 literal_converts_to_bool_func& literal_converts_to_bool)
 {
 	if (is_logical_NOT_expression(src))
 		{
@@ -8972,7 +9063,7 @@
 static bool eval_bitwise_compl(	parse_tree& src, const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,
-								func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+								intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_bitwise_complement_expression(src))
 		{
@@ -8995,8 +9086,8 @@
 
 static bool eval_unary_minus(parse_tree& src, const type_system& types,
 							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							 func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,
-							 func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							 literal_converts_to_bool_func& literal_converts_to_bool,
+							 intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_unary_operator_expression<'-'>(src))
 		{
@@ -9008,8 +9099,8 @@
 
 static bool eval_mult_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-								func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+								literal_converts_to_bool_func& literal_converts_to_bool,
+								intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_mult_operator_expression<'*'>(src))
 		{
@@ -9022,8 +9113,8 @@
 
 static bool eval_div_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-								func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+								literal_converts_to_bool_func& literal_converts_to_bool,
+								intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_mult_operator_expression<'/'>(src))
 		{
@@ -9036,8 +9127,8 @@
 
 static bool eval_mod_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-								func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+								literal_converts_to_bool_func& literal_converts_to_bool,
+								intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_mult_operator_expression<'%'>(src))
 		{
@@ -9051,8 +9142,8 @@
 
 static bool eval_add_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_add_operator_expression<'+'>(src))
 		{
@@ -9065,8 +9156,8 @@
 
 static bool eval_sub_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_add_operator_expression<'-'>(src))
 		{
@@ -9079,8 +9170,8 @@
 
 static bool eval_shift(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_shift_expression(src))
 		{
@@ -9093,7 +9184,7 @@
 
 static bool eval_relation_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_relation_expression(src))
 		{
@@ -9107,8 +9198,8 @@
 static bool eval_equality_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_equality_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_equality_expression(src))
 		{
@@ -9122,8 +9213,8 @@
 static bool eval_bitwise_AND(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_AND_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_bitwise_AND_expression(src))
 		{
@@ -9137,8 +9228,8 @@
 static bool eval_bitwise_XOR(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_XOR_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_bitwise_XOR_expression(src))
 		{
@@ -9152,8 +9243,8 @@
 static bool eval_bitwise_OR(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_OR_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(umaxint&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_bitwise_OR_expression(src))
 		{
@@ -9167,7 +9258,7 @@
 static bool eval_logical_AND(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_AND_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool)
+							literal_converts_to_bool_func& literal_converts_to_bool)
 {
 	if (is_logical_AND_expression(src))
 		{
@@ -9181,7 +9272,7 @@
 static bool eval_logical_OR(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_OR_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool)
+							literal_converts_to_bool_func& literal_converts_to_bool)
 {
 	if (is_logical_OR_expression(src))
 		{
@@ -9194,12 +9285,13 @@
 
 static bool eval_conditional_operator(parse_tree& src,const type_system& types,
 									  func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-									  func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool)
+									  literal_converts_to_bool_func& literal_converts_to_bool)
 {
 	if (is_C99_conditional_operator_expression(src))
 		{	// prefix operator is boolean
 		EvalParseTree(*src.c_array<1>(),types);
-		if (eval_conditional_op(src,literal_converts_to_bool)) return true;
+		if (eval_conditional_op(src,literal_converts_to_bool
+			)) return true;
 		}
 	return false;
 }
@@ -9315,8 +9407,10 @@
 			{
 			umaxint res_int;
 			umaxint rhs_int;
-			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data<1>());
-			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data<2>());
+			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data<1>()
+				);
+			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data<2>()
+				);
 			if (lhs_converted && rhs_converted)
 				{	//! \todo deal with signed integer arithmetic
 				const promote_aux old(old_type.base_type_index);
@@ -9383,8 +9477,10 @@
 			{
 			umaxint res_int;
 			umaxint rhs_int;
-			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data<1>());
-			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data<2>());
+			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data<1>()
+				);
+			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data<2>()
+				);
 			if (lhs_converted && rhs_converted)
 				{	//! \todo deal with signed integer arithmetic
 				const promote_aux old(old_type.base_type_index);



From zaimoni at mail.berlios.de  Wed Mar 24 20:16:18 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 24 Mar 2010 20:16:18 +0100
Subject: [Zcplusplus-commits] r355 - trunk
Message-ID: <201003241916.o2OJGIHV015821@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-24 20:16:13 +0100 (Wed, 24 Mar 2010)
New Revision: 355

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
handle the signature changes between z_cpp and zcc the way they should have been in the first place.  Enum support for operator ~ .

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-21 19:24:26 UTC (rev 354)
+++ trunk/CSupport.cpp	2010-03-24 19:16:13 UTC (rev 355)
@@ -35,6 +35,27 @@
 #/*cut-cpp*/
 #include "CheckReturn.hpp"
 
+#ifdef ZCC_NOT_BUILDING_CPP
+#error internal macro ZCC_NOT_BUILDING_CPP already defined 
+#endif
+#/*cut-cpp*/
+#define ZCC_NOT_BUILDING_CPP 1
+#/*cut-cpp*/
+// handle function signature differences between z_cpp and other users
+#ifdef SIG_CONST_TYPES
+#error internal macro SIG_CONST_TYPES already defined 
+#endif
+#ifdef ARG_TYPES
+#error internal macro ARG_TYPES already defined 
+#endif
+#ifdef ZCC_NOT_BUILDING_CPP
+#define SIG_CONST_TYPES ,const type_system& types 
+#define ARG_TYPES ,types 
+#else
+#define SIG_CONST_TYPES 
+#define ARG_TYPES 
+#endif
+
 using namespace zaimoni;
 using virtual_machine::umaxint;
 
@@ -628,107 +649,79 @@
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
 }
 
-static bool converts_to_integerlike(size_t base_type_index)
+static bool converts_to_integerlike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
+#ifdef ZCC_NOT_BUILDING_CPP
+	if (C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index) return true;
+	return types.get_enum_def(base_type_index);
+#else
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index;
+#endif
 }
 
-static bool converts_to_integerlike(const type_spec& type_code)
+static bool converts_to_integerlike(const type_spec& type_code SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
 	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers
-	return converts_to_integerlike(type_code.base_type_index);
+	return converts_to_integerlike(type_code.base_type_index ARG_TYPES);
 }
-#/*cut-cpp*/
 
-static bool converts_to_integerlike(size_t base_type_index,const type_system& types)
-{
-	if (converts_to_integerlike(base_type_index)) return true;
-	return types.get_enum_def(base_type_index);
-}
-
-static bool converts_to_integerlike(const type_spec& type_code,const type_system& types)
-{
-	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers
-	if (converts_to_integerlike(type_code.base_type_index)) return true;
-	return types.get_enum_def(type_code.base_type_index);
-}
-#/*cut-cpp*/
-
-static bool converts_to_integer(const type_spec& type_code)
+static bool converts_to_integer(const type_spec& type_code SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	//! \todo handle enum types
 	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers
-	return C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index;
-}
-#/*cut-cpp*/
-
-static bool converts_to_integer(const type_spec& type_code,const type_system& types)
-{	//! \todo handle cast operator overloading
-	//! \todo handle enum types
-	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers
+#ifdef ZCC_NOT_BUILDING_CPP
 	if (C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index) return true;
 	return types.get_enum_def(type_code.base_type_index);
+#else
+	return C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index;
+#endif
 }
-#/*cut-cpp*/
 
-static bool converts_to_reallike(size_t base_type_index)
+static bool converts_to_reallike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	//! \todo handle enum types
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index;
+#ifdef ZCC_NOT_BUILDING_CPP
+	if (C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index) return true;
+	return types.get_enum_def(base_type_index);
+#else
+	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index;
+#endif
 }
 
-static bool converts_to_arithmeticlike(size_t base_type_index)
+static bool converts_to_arithmeticlike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	//! \todo handle enum types
+#ifdef ZCC_NOT_BUILDING_CPP
+	if (C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index) return true;
+	return types.get_enum_def(base_type_index);
+#else
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
+#endif
 }
 
-static bool converts_to_arithmeticlike(const type_spec& type_code)
+static bool converts_to_arithmeticlike(const type_spec& type_code SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	//! \todo handle enum types
 	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers/floats/complex
-	return converts_to_arithmeticlike(type_code.base_type_index);
+	return converts_to_arithmeticlike(type_code.base_type_index ARG_TYPES);
 }
-#/*cut-cpp*/
 
-static bool converts_to_arithmeticlike(size_t base_type_index,const type_system& types)
-{	//! \todo handle cast operator overloading
-	//! \todo handle enum types
-	if (converts_to_arithmeticlike(base_type_index)) return true;
-	return types.get_enum_def(base_type_index);
-}
-
-static bool converts_to_arithmeticlike(const type_spec& type_code,const type_system& types)
-{	//! \todo handle cast operator overloading
-	//! \todo handle enum types
-	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers/floats/complex
-	if (converts_to_arithmeticlike(type_code.base_type_index)) return true;
-	return types.get_enum_def(type_code.base_type_index);
-}
-#/*cut-cpp*/
-
-static bool converts_to_bool(const type_spec& type_code)
+static bool converts_to_bool(const type_spec& type_code SIG_CONST_TYPES)
 {
 	if (0<type_code.pointer_power_after_array_decay()) return true;	// pointers are comparable to NULL
-	if (converts_to_arithmeticlike(type_code.base_type_index)) return true;	// arithmetic types are comparable to zero, and include bool
+	if (converts_to_arithmeticlike(type_code.base_type_index ARG_TYPES)) return true;	// arithmetic types are comparable to zero, and include bool
 	// C++: run through type conversion weirdness
 	return false;
 }
-#/*cut-cpp*/
 
-static bool converts_to_bool(const type_spec& type_code,const type_system& types)
-{
-	if (0<type_code.pointer_power_after_array_decay()) return true;	// pointers are comparable to NULL
-	if (converts_to_arithmeticlike(type_code.base_type_index)) return true;	// arithmetic types are comparable to zero, and include bool
-	if (types.get_enum_def(type_code.base_type_index)) return true;	// (unscoped) enumerators convert to integers
-	// C++: run through type conversion weirdness
-	return false;
-}
-#/*cut-cpp*/
-
 // the integer promotions rely on low-level weirdness, so test that here
-static size_t arithmetic_reconcile(size_t base_type_index1, size_t base_type_index2)
+static size_t arithmetic_reconcile(size_t base_type_index1, size_t base_type_index2 SIG_CONST_TYPES)
 {
+#/*cut-cpp*/
+	{
+	const enum_def* tmp = types.get_enum_def(base_type_index1);
+	if (tmp) base_type_index1 = tmp->represent_as;
+	tmp = types.get_enum_def(base_type_index2);
+	if (tmp) base_type_index2 = tmp->represent_as;	
+	}
+#/*cut-cpp*/
 	assert(is_innate_definite_type(base_type_index1));
 	assert(is_innate_definite_type(base_type_index2));
 	// identity, do not do anything
@@ -840,8 +833,14 @@
 		}
 }
 
-static size_t default_promote_type(size_t i)
+static size_t default_promote_type(size_t i SIG_CONST_TYPES)
 {
+#/*cut-cpp*/
+	{
+	const enum_def* tmp = types.get_enum_def(i);
+	if (tmp) i = tmp->represent_as;
+	}
+#/*cut-cpp*/
 	switch(i)
 	{
 	case C_TYPE::BOOL: return C_TYPE::INT;
@@ -855,14 +854,25 @@
 	return i;
 }
 
+static POD_pair<size_t,bool> default_promotion_is_integerlike(const type_spec& type_code SIG_CONST_TYPES)
+{	// uses NRVO
+	POD_pair<size_t,bool> tmp = {0,false};
+	if (0==type_code.pointer_power_after_array_decay())	// pointers do not have a standard conversion to integers
+		{
+		tmp.first = default_promote_type(type_code.base_type_index ARG_TYPES);
+		tmp.second = (C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>=type_code.base_type_index);
+		}
+	return tmp;
+}
+
 // auxilliary structure to aggregate useful information for type promotions
 // this will malfunction badly for anything other than an integer type
 class promote_aux : public virtual_machine::promotion_info
 {
 public:
-	promote_aux(size_t base_type_index)
+	promote_aux(size_t base_type_index SIG_CONST_TYPES)
 	{
-		const size_t promoted_type = default_promote_type(base_type_index);
+		const size_t promoted_type = default_promote_type(base_type_index ARG_TYPES);
 		machine_type = machine_type_from_type_index(promoted_type);
 		bitcount = target_machine->C_bit(machine_type);
 		is_signed = !((promoted_type-C_TYPE::INT)%2);
@@ -4207,17 +4217,9 @@
 #/*cut-cpp*/
 
 // forward-declare to handle recursion
-static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
-#/*cut-cpp*/
-	, const type_system& types
-#/*cut-cpp*/
-	);
+static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src SIG_CONST_TYPES);
 
-static bool _C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
-#/*cut-cpp*/
-	, const type_system& types
-#/*cut-cpp*/
-	)
+static bool _C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src SIG_CONST_TYPES)
 {
 	assert(C_TYPE::INTEGERLIKE!=src.type_code.base_type_index);
 
@@ -4225,27 +4227,19 @@
 		&&  !bool_options[boolopt::int_traps]
 		&&	is_C99_add_operator_expression<'-'>(src))
 		{
-		const promote_aux old(src.type_code.base_type_index);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		if (old.is_signed)
 			{
-			const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+			const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 			assert(old.bitcount>=lhs.bitcount);
 			if (lhs.is_signed)
 				{
 				umaxint lhs_int;
 				umaxint rhs_int;
-				if (	C99_intlike_literal_to_VM(lhs_int,*src.data<1>()
-#/*cut-cpp*/
-					,types
-#/*cut-cpp*/
-					)
-					&&	C99_intlike_literal_to_VM(rhs_int,*src.data<2>()
-#/*cut-cpp*/
-						,types
-#/*cut-cpp*/
-					))
+				if (	C99_intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES)
+					&&	C99_intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 					{
-					const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+					const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 					assert(old.bitcount>=rhs.bitcount);
 					assert(old.bitcount>rhs.bitcount || rhs.is_signed);
 					if (lhs_int.test(lhs.bitcount-1) && (!rhs.is_signed || !rhs_int.test(rhs.bitcount-1)))
@@ -4315,19 +4309,11 @@
 
 // return value: literal to parse, whether additive inverse applies
 static POD_pair<const parse_tree*,bool>
-_find_intlike_literal(const parse_tree* src
-#/*cut-cpp*/
-	,const type_system& types
-#/*cut-cpp*/	
-	)
+_find_intlike_literal(const parse_tree* src SIG_CONST_TYPES)
 {
 	assert(NULL!=src);
 	POD_pair<const parse_tree*,bool> ret = {src,false};
-	while(converts_to_integer(ret.first->type_code
-#/*cut-cpp*/
-	, types
-#/*cut-cpp*/			
-		))
+	while(converts_to_integer(ret.first->type_code ARG_TYPES))
 		{
 		if 		(is_C99_unary_operator_expression<'-'>(*ret.first))
 			{
@@ -4347,35 +4333,19 @@
 }
 
 // use this typedef to cope with signature varying by build
-typedef bool (intlike_literal_to_VM_func)(umaxint& dest, const parse_tree& src
-#/*cut-cpp*/
-	,const type_system& types
-#/*cut-cpp*/	
-	);
+typedef bool (intlike_literal_to_VM_func)(umaxint& dest, const parse_tree& src SIG_CONST_TYPES);
 
-static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
-#/*cut-cpp*/
-	,const type_system& types
-#/*cut-cpp*/	
-	)
+static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src SIG_CONST_TYPES)
 {
-	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src
-#/*cut-cpp*/
-	, types
-#/*cut-cpp*/					
-		);
+	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src ARG_TYPES);
 
 	if (C_TYPE::INTEGERLIKE==actual.first->type_code.base_type_index)
 		return false;	
 
-	if (!_C99_intlike_literal_to_VM(dest,*actual.first
-#/*cut-cpp*/
-		, types
-#/*cut-cpp*/					
-		)) return false;
+	if (!_C99_intlike_literal_to_VM(dest,*actual.first ARG_TYPES)) return false;
 	if (actual.second)
 		{
-		const promote_aux old(src.type_code.base_type_index);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		if (old.is_signed)
 			target_machine->signed_additive_inverse(dest,old.machine_type);
 		else
@@ -4384,32 +4354,20 @@
 	return true;
 }
 
-static bool CPP_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
-#/*cut-cpp*/
-	, const type_system& types
-#/*cut-cpp*/	
-	)
+static bool CPP_intlike_literal_to_VM(umaxint& dest, const parse_tree& src SIG_CONST_TYPES)
 {
-	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src
-#/*cut-cpp*/
-	, types
-#/*cut-cpp*/					
-		);
+	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src ARG_TYPES);
 
 	if (!_CPP_intlike_literal_to_VM(dest,*actual.first))
 		{
 		if (C_TYPE::INTEGERLIKE==actual.first->type_code.base_type_index)
 			return false;	
 
-		if (!_C99_intlike_literal_to_VM(dest,*actual.first
-#/*cut-cpp*/
-			, types
-#/*cut-cpp*/					
-			)) return false;
+		if (!_C99_intlike_literal_to_VM(dest,*actual.first ARG_TYPES)) return false;
 		};
 	if (actual.second)
 		{
-		const promote_aux old(src.type_code.base_type_index);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		if (old.is_signed)
 			target_machine->signed_additive_inverse(dest,old.machine_type);
 		else
@@ -4424,19 +4382,11 @@
  * \return -1 : can't decide quickly whether this is a null 
  *         pointer constant
  */
-static int is_null_pointer_constant(const parse_tree& src,intlike_literal_to_VM_func& intlike_literal_to_VM
-#/*cut-cpp*/
-	,const type_system& types
-#/*cut-cpp*/
-	)
+static int is_null_pointer_constant(const parse_tree& src,intlike_literal_to_VM_func& intlike_literal_to_VM SIG_CONST_TYPES)
 {	//! \bug doesn't recognize enumerators with value zero
-	if (!converts_to_integerlike(src.type_code)) return 0;
+	if (!converts_to_integerlike(src.type_code ARG_TYPES)) return 0;
 	umaxint tmp;
-	if (intlike_literal_to_VM(tmp,src
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		)) return tmp==0;
+	if (intlike_literal_to_VM(tmp,src ARG_TYPES)) return tmp==0;
 	return -1;
 }
 
@@ -5016,11 +4966,7 @@
 			simple_error(src,"array dereference of pointer by pointer (C99 6.5.2.1p1; C++98 5.2.1p1,13.3.1.2p1)");
 			return;
 			}
-		else if (converts_to_integerlike(src.data<0>()->type_code.base_type_index
-#/*cut-cpp*/
-			,types
-#/*cut-cpp*/
-			))
+		else if (converts_to_integerlike(src.data<0>()->type_code.base_type_index ARG_TYPES))
 			{
 			value_copy(src.type_code,src.data<1>()->type_code);
 			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
@@ -5038,11 +4984,7 @@
 		}
 	else if (0<effective_pointer_power_infix)
 		{
-		if (converts_to_integerlike(src.data<1>()->type_code.base_type_index
-#/*cut-cpp*/
-			,types
-#/*cut-cpp*/
-			))
+		if (converts_to_integerlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
 			{
 			value_copy(src.type_code,src.data<0>()->type_code);
 			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
@@ -5241,18 +5183,10 @@
 }
 
 // typedef to simplify compatibility changes
-typedef bool literal_converts_to_bool_func(const parse_tree& src, bool& is_true
-#/*cut-cpp*/
-	, const type_system& types
-#/*cut-cpp*/
-	);
+typedef bool literal_converts_to_bool_func(const parse_tree& src, bool& is_true SIG_CONST_TYPES);
 
 // Closely related to if_elif_control_is_zero/CPreproc.cpp
-static bool _C99_literal_converts_to_bool(const parse_tree& src, bool& is_true
-#/*cut-cpp*/
-	, const type_system& types
-#/*cut-cpp*/
-	)
+static bool _C99_literal_converts_to_bool(const parse_tree& src, bool& is_true SIG_CONST_TYPES)
 {
 	assert(src.is_atomic());
 	// string literals always test true (decay to non-NULL pointer)
@@ -5271,7 +5205,7 @@
 		{	// misintepret enumerators as literals (avoid dynamic memory thrashing)
 		const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.index_tokens[0].token.first);
 		assert(tmp2);
-		const promote_aux dest_type(tmp2->second.first.second);
+		const promote_aux dest_type(tmp2->second.first.second,types);
 		is_true = !target_machine->is_zero(tmp2->second.first.third.data(),tmp2->second.first.third.size(),dest_type);
 		return true;
 		}
@@ -5284,45 +5218,21 @@
 	return true;
 }
 
-static bool C99_literal_converts_to_bool(const parse_tree& src, bool& is_true
-#/*cut-cpp*/
-	, const type_system& types
-#/*cut-cpp*/
-	)
+static bool C99_literal_converts_to_bool(const parse_tree& src, bool& is_true SIG_CONST_TYPES)
 {	// deal with -1 et. al.
-	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return _C99_literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		);
+	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return _C99_literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES);
 
 	if (!src.is_atomic()) return false;
-	return _C99_literal_converts_to_bool(src,is_true
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		);
+	return _C99_literal_converts_to_bool(src,is_true ARG_TYPES);
 }
 
-static bool CPP_literal_converts_to_bool(const parse_tree& src, bool& is_true
-#/*cut-cpp*/
-	, const type_system& types
-#/*cut-cpp*/
-	)
+static bool CPP_literal_converts_to_bool(const parse_tree& src, bool& is_true SIG_CONST_TYPES)
 {
 	// deal with -1 et. al.
-	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return CPP_literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		);
+	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return CPP_literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES);
 
 	if (!src.is_atomic()) return false;
-	if (_C99_literal_converts_to_bool(src,is_true
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		)) return true;
+	if (_C99_literal_converts_to_bool(src,is_true ARG_TYPES)) return true;
 	// deal with: this, true, false
 	if (token_is_string<5>(src.index_tokens[0].token,"false"))
 		{
@@ -5426,7 +5336,7 @@
 	return dest;
 }
 
-static void force_unary_positive_literal(parse_tree& dest,const parse_tree& src)
+static void force_unary_positive_literal(parse_tree& dest,const parse_tree& src SIG_CONST_TYPES)
 {
 	assert(0==dest.size<0>());
 	assert(0==dest.size<1>());
@@ -5437,13 +5347,13 @@
 	dest.core_flag_update();
 	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	dest.subtype = C99_UNARY_SUBTYPE_PLUS;
-	if (converts_to_arithmeticlike(dest.data<2>()->type_code))
-		dest.type_code = dest.data<2>()->type_code;
+	if (converts_to_arithmeticlike(dest.data<2>()->type_code ARG_TYPES))
+		dest.type_code = dest.data<2>()->type_code;	//! \bug doesn't work for enumerators
 	assert(NULL!=dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'+'>(dest));
 }
 
-static void force_unary_negative_token(parse_tree& dest,parse_tree* src,const parse_tree& loc_src)
+static void force_unary_negative_token(parse_tree& dest,parse_tree* src,const parse_tree& loc_src SIG_CONST_TYPES)
 {
 	assert(src);
 	assert(PARSE_EXPRESSION & src->flags);
@@ -5454,8 +5364,8 @@
 	dest.core_flag_update();
 	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	dest.subtype = C99_UNARY_SUBTYPE_NEG;
-	if (converts_to_arithmeticlike(dest.data<2>()->type_code))
-		dest.type_code = dest.data<2>()->type_code;
+	if (converts_to_arithmeticlike(dest.data<2>()->type_code ARG_TYPES))
+		dest.type_code = dest.data<2>()->type_code;	//! \bug doesn't work for enumerators
 	// do not handle type here: C++ operator overloading risk
 	assert(NULL!=dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'-'>(dest));
@@ -5471,7 +5381,7 @@
 		if (NULL==tmp) return false;
 		if (!VM_to_literal(*tmp,src_int,src,types)) return false;
 		assert(PARSE_EXPRESSION & tmp->flags);
-		force_unary_negative_token(x,tmp,*tmp);
+		force_unary_negative_token(x,tmp,*tmp ARG_TYPES);
 		}
 	else if (!VM_to_literal(x,src_int,src,types))
 		return false;
@@ -5484,7 +5394,7 @@
 	parse_tree tmp3;
 	const type_system::enumerator_info* const tmp2 = types.get_enumerator(x.index_tokens[0].token.first);
 	assert(tmp2);
-	const promote_aux dest_type(tmp2->second.first.second);
+	const promote_aux dest_type(tmp2->second.first.second ARG_TYPES);
 	{
 	umaxint res_int(tmp2->second.first.third);
 	const bool tmp_negative = dest_type.is_signed && res_int.test(dest_type.bitcount-1);
@@ -5505,9 +5415,9 @@
 }
 #/*cut-cpp*/
 
-static bool is_integerlike_literal(const parse_tree& x)
+static bool is_integerlike_literal(const parse_tree& x SIG_CONST_TYPES)
 {
-	return converts_to_integerlike(x.type_code) && (PARSE_PRIMARY_EXPRESSION & x.flags);
+	return converts_to_integerlike(x.type_code ARG_TYPES) && (PARSE_PRIMARY_EXPRESSION & x.flags);
 }
 
 static bool eval_unary_plus(parse_tree& src, const type_system& types)
@@ -5539,7 +5449,7 @@
 		}
 #/*cut-cpp*/
  	// handle integer-like literals like a real integer literal
-	if (is_integerlike_literal(*src.data<2>()))
+	if (is_integerlike_literal(*src.data<2>() ARG_TYPES))
 		{
 		const type_spec old_type = src.type_code;
 		src.eval_to_arg<2>(0);
@@ -5553,11 +5463,7 @@
 {
 	assert(is_C99_unary_operator_expression<'-'>(src));
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		) && !is_true && (1==(src.type_code.base_type_index-C_TYPE::INT)%2 || virtual_machine::twos_complement==target_machine->C_signed_int_representation() || bool_options[boolopt::int_traps]))
+	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true && (1==(src.type_code.base_type_index-C_TYPE::INT)%2 || virtual_machine::twos_complement==target_machine->C_signed_int_representation() || bool_options[boolopt::int_traps]))
 		{	// -0==0
 			// deal with unary - not being allowed to actually return -0 on these machines later
 		const type_spec old_type = src.type_code;
@@ -5580,16 +5486,12 @@
 		src.type_code = src.data<2>()->type_code;
 		}
 #/*cut-cpp*/
-	if (is_integerlike_literal(*src.data<2>()) && 1==(src.type_code.base_type_index-C_TYPE::INT)%2)
+	if (is_integerlike_literal(*src.data<2>() ARG_TYPES) && 1==(src.type_code.base_type_index-C_TYPE::INT)%2)
 		{	// unsigned...we're fine
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
 		const type_spec old_type = src.type_code;
 		umaxint res_int;
-		intlike_literal_to_VM(res_int,*src.data<2>()
-#/*cut-cpp*/
-			,types
-#/*cut-cpp*/
-			);
+		intlike_literal_to_VM(res_int,*src.data<2>() ARG_TYPES);
 		target_machine->unsigned_additive_inverse(res_int,machine_type);
 
 		//! \todo flag failures to reduce as RAM-stalled
@@ -5600,9 +5502,9 @@
 		src.type_code = old_type;
 		return true;
 		};
-	if (converts_to_integerlike(src.data<2>()->type_code) && is_C99_unary_operator_expression<'-'>(*src.data<2>()))
+	if (converts_to_integerlike(src.data<2>()->type_code ARG_TYPES) && is_C99_unary_operator_expression<'-'>(*src.data<2>()))
 		{	// - - __ |-> __, trap-int machines fine as -0=0 for sign/magnitude and one's complement, and the offending literal for two's complement is an unsigned int
-		assert(converts_to_integerlike(src.data<2>()->data<2>()->type_code));
+		assert(converts_to_integerlike(src.data<2>()->data<2>()->type_code ARG_TYPES));
 		const type_spec old_type = src.type_code;
 		parse_tree tmp = *src.data<2>()->data<2>();
 		src.c_array<2>()->c_array<2>()->clear();
@@ -5625,18 +5527,19 @@
 		simple_error(src,(C99_UNARY_SUBTYPE_PLUS==src.subtype) ? " applies unary + to a pointer (C99 6.5.3.3p1)" : " applies unary - to a pointer (C99 6.5.3.3p1)");
 		return;
 		}
-	// can type if result is a primitive arithmetic type
-	if (converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index))
-		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index));
 #/*cut-cpp*/
 	// can type if an (C++0X unscoped) enumerator
-	else if (is_noticed_enumerator(*src.data<2>(),types))
+	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
 		const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.data<2>()->index_tokens[0].token.first);
 		assert(tmp2);
 		src.type_code.set_type(tmp2->second.first.first);
 		}
+	else
 #/*cut-cpp*/
+	// can type if result is a primitive arithmetic type
+	if (converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
+		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES));
 	
 	const size_t arg_unary_subtype 	= (is_C99_unary_operator_expression<'-'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_NEG
 									: (is_C99_unary_operator_expression<'+'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_PLUS : 0;
@@ -5665,17 +5568,18 @@
 	assert((C99_UNARY_SUBTYPE_PLUS==src.subtype) ? is_C99_unary_operator_expression<'+'>(src) : is_C99_unary_operator_expression<'-'>(src));
 	
 	// can type if result is a primitive arithmetic type
-	if (converts_to_arithmeticlike(src.data<2>()->type_code))
-		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index));
 #/*cut-cpp*/
 	// can type if an (C++0X unscoped) enumerator
-	else if (is_noticed_enumerator(*src.data<2>(),types))
+	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
 		const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.data<2>()->index_tokens[0].token.first);
 		assert(tmp2);
 		src.type_code.set_type(tmp2->second.first.first);
 		}
+	else
 #/*cut-cpp*/
+	if (converts_to_arithmeticlike(src.data<2>()->type_code ARG_TYPES))
+		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES));
 
 	// two deep:
 	// 1) if inner +/- is applied to an arithmetic literal, try to crunch it (but leave - signed alone)
@@ -5825,19 +5729,9 @@
 static bool eval_logical_NOT(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_NOT, literal_converts_to_bool_func& literal_converts_to_bool)
 {
 	assert(is_logical_NOT(src));
-#/*cut-cpp*/
-	// unscoped enumerators use their integer representation
-	if (   is_noticed_enumerator(*src.data<2>(),types)
-		&& !enumerator_to_integer_representation(*src.c_array<2>(),types))
-		return false;
-#/*cut-cpp*/
 	{	// deal with literals that convert to bool here
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		))
+	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES))
 		{
 		src.destroy();
 		src.index_tokens[0].token.first = (is_true) ? "0" : "1";
@@ -5869,11 +5763,7 @@
 	src.type_code.set_type(C_TYPE::BOOL);	// technically wrong for C, but the range is restricted to _Bool's range
 	if (eval_logical_NOT(src,types,is_C99_unary_operator_expression<'!'>,C99_literal_converts_to_bool)) return;
 
-	if (!converts_to_bool(src.data<2>()->type_code
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		))
+	if (!converts_to_bool(src.data<2>()->type_code ARG_TYPES))
 		{	// can't test this from preprocessor or static assertion
 		simple_error(src," applies ! to a nonscalar type (C99 6.5.3.3p1)");
 		return;
@@ -5886,11 +5776,7 @@
 	src.type_code.set_type(C_TYPE::BOOL);	// technically wrong for C, but the range is restricted to _Bool's range
 	if (eval_logical_NOT(src,types,is_CPP_logical_NOT_expression,CPP_literal_converts_to_bool)) return;
 
-	if (!converts_to_bool(src.data<2>()->type_code
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		))
+	if (!converts_to_bool(src.data<2>()->type_code ARG_TYPES))
 		{	// can't test this from preprocessor or static assertion
 		simple_error(src," applies ! to a type not convertible to bool (C++98 5.3.1p8)");
 		return;
@@ -6038,7 +5924,7 @@
 		_flush(tmp);
 		return false;
 		}
-	force_unary_negative_token(*tmp3,tmp,src_loc);
+	force_unary_negative_token(*tmp3,tmp,src_loc ARG_TYPES);
 
 	parse_tree tmp4;
 	tmp4.clear();
@@ -6061,13 +5947,16 @@
 static bool eval_bitwise_compl(parse_tree& src, const type_system& types,bool hard_error,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_bitwise_complement_expression(src));
-	assert(converts_to_integerlike(src.data<2>()->type_code));
-	umaxint res_int;
-	if (intlike_literal_to_VM(res_int,*src.data<2>()
+	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
 #/*cut-cpp*/
-		,types
+	if (is_noticed_enumerator(*src.data<2>(),types))
+		{
+		if (!enumerator_to_integer_representation(*src.c_array<2>(),types)) return false;
+		src.type_code = src.data<2>()->type_code;
+		}
 #/*cut-cpp*/
-		)) 
+	umaxint res_int;
+	if (intlike_literal_to_VM(res_int,*src.data<2>() ARG_TYPES)) 
 		{
 		const type_spec old_type = src.type_code;
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(old_type.base_type_index);
@@ -6116,26 +6005,28 @@
 static void C_bitwise_complement_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'~'>(src));
-	if (!converts_to_integerlike(src.data<2>()->type_code))
+	const POD_pair<size_t,bool> tmp = default_promotion_is_integerlike(src.data<2>()->type_code ARG_TYPES);
+	if (!tmp.second)
 		{	//! \test Error_if_control25.h
 		src.type_code.set_type(0);
 		simple_error(src," applies ~ to a nonintegral type (C99 6.5.3.3p1)");
 		return;
 		}
-	src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index));
+	src.type_code.set_type(tmp.first);
 	if (eval_bitwise_compl(src,types,false,is_C99_unary_operator_expression<'~'>,C99_intlike_literal_to_VM)) return;
 }
 
 static void CPP_bitwise_complement_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_CPP_bitwise_complement_expression(src));
-	if (!converts_to_integerlike(src.data<2>()->type_code))
+	const POD_pair<size_t,bool> tmp = default_promotion_is_integerlike(src.data<2>()->type_code ARG_TYPES);
+	if (!tmp.second)
 		{
 		src.type_code.set_type(0);
 		simple_error(src," applies ~ to a nonintegral type (C99 6.5.3.3p1)");
 		return;
 		}
-	src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index));
+	src.type_code.set_type(tmp.first);
 	if (eval_bitwise_compl(src,types,false,is_CPP_bitwise_complement_expression,CPP_intlike_literal_to_VM)) return;
 }
 
@@ -6501,16 +6392,8 @@
 	bool is_true = false;
 
 	// do this first to avoid unnecessary dynamic memory allocation
-	if (	(literal_converts_to_bool(*src.data<1>(),is_true
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-			) && !is_true)	// 0 * __
-		||	(literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-			,types
-#/*cut-cpp*/
-			) && !is_true))	// __ * 0
+	if (	(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)	// 0 * __
+		||	(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true))	// __ * 0
 		{
 		// construct +0 to defuse 1-0*6
 		parse_tree tmp = decimal_literal("0",src,types);
@@ -6524,22 +6407,14 @@
 			}
 		else tmp.type_code = old_type;
 		src.DeleteIdx<1>(0);
-		force_unary_positive_literal(src,tmp);
+		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
 		};
 
 	umaxint res_int;
 	umaxint rhs_int;
-	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
-#/*cut-cpp*/
-		, types
-#/*cut-cpp*/
-		);
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
-#/*cut-cpp*/
-		, types
-#/*cut-cpp*/
-		);
+	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 	if (lhs_converted && 1==res_int)
 		{
 		src.eval_to_arg<2>(0);
@@ -6554,10 +6429,10 @@
 		};
 	if (lhs_converted && rhs_converted)
 		{
-		const promote_aux old(old_type.base_type_index);
-		const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=lhs.bitcount);
-		const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=rhs.bitcount);
 
 		// handle sign-extension of lhs, rhs
@@ -6613,7 +6488,7 @@
 		if (!VM_to_literal(tmp,res_int,src,types)) return false;
 		tmp.type_code = old_type;
 		src.DeleteIdx<1>(0);
-		force_unary_positive_literal(src,tmp);
+		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
 		}
 	return false;
@@ -6625,13 +6500,9 @@
 
 	const type_spec old_type = src.type_code;
 	bool is_true = false;
-	if (converts_to_integerlike(src.type_code))
+	if (converts_to_integerlike(src.type_code ARG_TYPES))
 		{
-		if 		(literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				) && !is_true)
+		if 		(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 			{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
 			if (hard_error)
 				//! \test default/Error_if_control30.hpp, default/Error_if_control30.h
@@ -6639,11 +6510,7 @@
 			return false;
 			}
 		/*! \todo would like a simple comparison of absolute values to auto-detect zero, possibly after mainline code */
-		else if (literal_converts_to_bool(*src.data<1>(),is_true
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				) && !is_true)
+		else if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 			{
 			// construct +0 to defuse 1-0/6
 			parse_tree tmp = decimal_literal("0",src,types);
@@ -6657,7 +6524,7 @@
 				}
 			else tmp.type_code = old_type;
 			src.DeleteIdx<1>(0);
-			force_unary_positive_literal(src,tmp);
+			force_unary_positive_literal(src,tmp ARG_TYPES);
 			return true;
 			}
 		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
@@ -6665,16 +6532,8 @@
 
 	umaxint res_int;
 	umaxint rhs_int;
-	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
-#/*cut-cpp*/
-		, types
-#/*cut-cpp*/
-		);
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
-#/*cut-cpp*/
-		, types
-#/*cut-cpp*/
-		);
+	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 	if (rhs_converted && rhs_int==1)
 		{	// __/1 |-> __
 		src.eval_to_arg<1>(0);
@@ -6686,10 +6545,10 @@
 	// implementation-defined whether negative results round away or to zero (standard prefers to zero, so default to that)
 	if (lhs_converted && rhs_converted)
 		{
-		const promote_aux old(old_type.base_type_index);
-		const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=lhs.bitcount);
-		const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=rhs.bitcount);
 
 		// handle sign-extension of lhs, rhs
@@ -6710,7 +6569,7 @@
 				tmp.type_code = old_type;
 				src.DeleteIdx<1>(0);
 				if (want_zero)
-					force_unary_positive_literal(src,tmp); // +0
+					force_unary_positive_literal(src,tmp ARG_TYPES); // +0
 				else	
 					force_unary_negative_literal(src,tmp); // -1
 				return true;
@@ -6756,7 +6615,7 @@
 		tmp.type_code = old_type;
 
 		src.DeleteIdx<1>(0);
-		force_unary_positive_literal(src,tmp);
+		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
 		}
 	return false;
@@ -6768,13 +6627,9 @@
 
 	const type_spec old_type = src.type_code;
 	bool is_true = false;
-	if (converts_to_integerlike(src.type_code))
+	if (converts_to_integerlike(src.type_code ARG_TYPES))
 		{
-		if 		(literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				) && !is_true)
+		if 		(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 			{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
 			if (hard_error)
 				//! \test default/Error_if_control31.hpp, Error_if_control31.h
@@ -6782,11 +6637,7 @@
 			return false;
 			}
 		/*! \todo would like a simple comparison of absolute values to auto-detect zero, possibly after mainline code */
-		else if (literal_converts_to_bool(*src.data<1>(),is_true
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				) && !is_true)
+		else if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 			{
 			// construct +0 to defuse 1-0%6
 			parse_tree tmp = decimal_literal("0",src,types);
@@ -6800,7 +6651,7 @@
 				}
 			else tmp.type_code = old_type;
 			src.DeleteIdx<1>(0);
-			force_unary_positive_literal(src,tmp);
+			force_unary_positive_literal(src,tmp ARG_TYPES);
 			return true;
 			}
 		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
@@ -6808,16 +6659,8 @@
 
 	umaxint res_int;
 	umaxint rhs_int;
-	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
-#/*cut-cpp*/
-		, types
-#/*cut-cpp*/
-		);
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
-#/*cut-cpp*/
-		, types
-#/*cut-cpp*/
-		);
+	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 	if (rhs_converted && rhs_int==1)
 		{	// __%1 |-> +0
 		parse_tree tmp = decimal_literal("0",src,types);
@@ -6826,15 +6669,15 @@
 		else
 			tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
 		src.DeleteIdx<1>(0);
-		force_unary_positive_literal(src,tmp);
+		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
 		};
 	if (lhs_converted && rhs_converted)
 		{
-		const promote_aux old(old_type.base_type_index);
-		const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=lhs.bitcount);
-		const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=rhs.bitcount);
 
 		// handle sign-extension of lhs, rhs
@@ -6880,7 +6723,7 @@
 		tmp.type_code = old_type;
 
 		src.DeleteIdx<1>(0);
-		force_unary_positive_literal(src,tmp);
+		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
 		}
 	return false;
@@ -6889,31 +6732,32 @@
 BOOST_STATIC_ASSERT(1==C99_MULT_SUBTYPE_MOD-C99_MULT_SUBTYPE_DIV);
 BOOST_STATIC_ASSERT(1==C99_MULT_SUBTYPE_MULT-C99_MULT_SUBTYPE_MOD);
 
-static bool _mod_expression_typecheck(parse_tree& src)
+static bool _mod_expression_typecheck(parse_tree& src SIG_CONST_TYPES)
 {
 	assert(C99_MULT_SUBTYPE_MOD==src.subtype && is_C99_mult_operator_expression<'%'>(src));
-	const bool rhs_integerlike = converts_to_integerlike(src.data<2>()->type_code);
-	if (!converts_to_integerlike(src.data<1>()->type_code))
+	const POD_pair<size_t,bool> lhs = default_promotion_is_integerlike(src.data<1>()->type_code ARG_TYPES);
+	const POD_pair<size_t,bool> rhs = default_promotion_is_integerlike(src.data<2>()->type_code ARG_TYPES);
+	if (!lhs.second)
 		{	//! \test default/Error_if_control33.hpp, default/Error_if_control33.h
 			//! \test default/Error_if_control34.hpp, default/Error_if_control34.h
-		simple_error(src,rhs_integerlike ? " has nonintegral LHS (C99 6.5.5p2, C++98 5.6p2)" : " has nonintegral LHS and RHS (C99 6.5.5p2, C++98 5.6p2)");
+		simple_error(src,rhs.second ? " has nonintegral LHS (C99 6.5.5p2, C++98 5.6p2)" : " has nonintegral LHS and RHS (C99 6.5.5p2, C++98 5.6p2)");
 		return false;
 		}
-	else if (!rhs_integerlike)
+	else if (!rhs.second)
 		{	//! \test default/Error_if_control32.hpp, default/Error_if_control32.h
 		simple_error(src," has nonintegral RHS (C99 6.5.5p2, C++98 5.6p2)");
 		return false;
 		};
-	src.type_code.set_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
+	src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 	return true;
 }
 
-static bool _mult_div_expression_typecheck(parse_tree& src)
+static bool _mult_div_expression_typecheck(parse_tree& src SIG_CONST_TYPES)
 {
 	assert(C99_MULT_SUBTYPE_DIV==src.subtype || C99_MULT_SUBTYPE_MULT==src.subtype);
 	assert((C99_MULT_SUBTYPE_DIV==src.subtype) ? is_C99_mult_operator_expression<'/'>(src) : is_C99_mult_operator_expression<'*'>(src));
-	const bool rhs_is_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code);
-	if (!converts_to_arithmeticlike(src.data<1>()->type_code))
+	const bool rhs_is_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code ARG_TYPES);
+	if (!converts_to_arithmeticlike(src.data<1>()->type_code ARG_TYPES))
 		{	//! \test default/Error_if_control36.hpp, default/Error_if_control36.h
 			//! \test default/Error_if_control37.hpp, default/Error_if_control37.h
 			//! \test default/Error_if_control39.hpp, default/Error_if_control39.h
@@ -6927,7 +6771,7 @@
 		simple_error(src," has nonarithmetic RHS (C99 6.5.5p2, C++98 5.6p2)");
 		return false;
 		};
-	src.type_code.set_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
+	src.type_code.set_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES));
 	return true;
 }
 
@@ -6938,11 +6782,11 @@
 	// note that 0*integerlike and so on are invalid, but do optimize to valid (but this is probably worth a separate execution path)
 	if (C99_MULT_SUBTYPE_MOD==src.subtype)
 		{	// require integral type
-		if (!_mod_expression_typecheck(src)) return;
+		if (!_mod_expression_typecheck(src ARG_TYPES)) return;
 		eval_mod_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 		}
 	else{	// require arithmetic type
-		if (!_mult_div_expression_typecheck(src)) return;
+		if (!_mult_div_expression_typecheck(src ARG_TYPES)) return;
 		if (C99_MULT_SUBTYPE_MULT==src.subtype)
 			eval_mult_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 		else
@@ -6957,11 +6801,11 @@
 
 	if (C99_MULT_SUBTYPE_MOD==src.subtype)
 		{	// require integral type
-		if (!_mod_expression_typecheck(src)) return;
+		if (!_mod_expression_typecheck(src ARG_TYPES)) return;
 		eval_mod_expression(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
 		}
 	else{	// require arithmetic type
-		if (!_mult_div_expression_typecheck(src)) return;
+		if (!_mult_div_expression_typecheck(src ARG_TYPES)) return;
 		if (C99_MULT_SUBTYPE_MULT==src.subtype)
 			eval_mult_expression(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
 		else
@@ -7152,24 +6996,16 @@
 	default: FATAL_CODE("hardware/compiler error: invalid linear combination in eval_add_expression",3);
 #endif
 	case 0:	{
-			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index));
-			assert(converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index));
+			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES));
+			assert(converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES));
 			bool is_true = false;
-			if 		(literal_converts_to_bool(*src.data<1>(),is_true
-#/*cut-cpp*/
-					,types
-#/*cut-cpp*/
-					) && !is_true)
+			if 		(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 				{	// 0 + __ |-> __
 				src.eval_to_arg<2>(0);
 				src.type_code = old_type;
 				return true;
 				}
-			else if (literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-					,types
-#/*cut-cpp*/
-					) && !is_true)
+			else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ + 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -7177,21 +7013,13 @@
 				};
 			umaxint res_int;
 			umaxint rhs_int;
-			const promote_aux old(old_type.base_type_index);
-			const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+			const promote_aux old(old_type.base_type_index ARG_TYPES);
+			const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 			assert(old.bitcount>=lhs.bitcount);
-			const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+			const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 			assert(old.bitcount>=rhs.bitcount);
-			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
-#/*cut-cpp*/
-				, types
-#/*cut-cpp*/					
-				);
-			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
-#/*cut-cpp*/
-				, types
-#/*cut-cpp*/					
-				);
+			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 			const bool lhs_negative = lhs_converted && target_machine->C_promote_integer(res_int,lhs,old);
 			const bool rhs_negative = rhs_converted && target_machine->C_promote_integer(rhs_int,rhs,old);
 			if (lhs_converted && rhs_converted)
@@ -7263,19 +7091,15 @@
 				tmp.type_code = old_type;
 
 				src.DeleteIdx<1>(0);
-				force_unary_positive_literal(src,tmp);
+				force_unary_positive_literal(src,tmp ARG_TYPES);
 				return true;
 				}
 			break;
 			}
 	case 1:	{
-			assert(converts_to_integerlike(src.data<2>()->type_code.base_type_index));
+			assert(converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES));
 			bool is_true = false;
-			if (literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				) && !is_true)
+			if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ + 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -7284,13 +7108,9 @@
 			break;
 			}
 	case 2:	{
-			assert(converts_to_integerlike(src.data<1>()->type_code.base_type_index));
+			assert(converts_to_integerlike(src.data<1>()->type_code.base_type_index ARG_TYPES));
 			bool is_true = false;
-			if (literal_converts_to_bool(*src.data<1>(),is_true
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				) && !is_true)
+			if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 				{	// 0 + __ |-> __
 				src.eval_to_arg<2>(0);
 				src.type_code = old_type;
@@ -7322,14 +7142,10 @@
 	default: FATAL_CODE("hardware/compiler error: invalid linear combination in eval_add_expression",3);
 #endif
 	case 0:	{
-			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index));
-			assert(converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index));
+			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES));
+			assert(converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES));
 			bool is_true = false;
-			if 		(literal_converts_to_bool(*src.data<1>(),is_true
-#/*cut-cpp*/
-					,types
-#/*cut-cpp*/
-					) && !is_true)
+			if 		(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 				{	// 0 - __ |-> - __
 				src.DeleteIdx<1>(0);
 				src.core_flag_update();
@@ -7339,11 +7155,7 @@
 				src.type_code = old_type;				
 				return true;
 				}
-			else if (literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-					) && !is_true)
+			else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ - 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -7351,22 +7163,14 @@
 				}
 			umaxint res_int;
 			umaxint rhs_int;
-			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
-#/*cut-cpp*/
-				, types
-#/*cut-cpp*/					
-				);
-			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
-#/*cut-cpp*/
-				, types
-#/*cut-cpp*/					
-				);
+			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 			if (lhs_converted && rhs_converted)
 				{	//! \todo deal with signed integer arithmetic
-				const promote_aux old(old_type.base_type_index);
-				const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+				const promote_aux old(old_type.base_type_index ARG_TYPES);
+				const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 				assert(old.bitcount>=lhs.bitcount);
-				const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+				const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 				assert(old.bitcount>=rhs.bitcount);
 
 				// handle sign-extension of lhs, rhs
@@ -7439,19 +7243,15 @@
 				tmp.type_code = old_type;
 
 				src.DeleteIdx<1>(0);
-				force_unary_positive_literal(src,tmp);
+				force_unary_positive_literal(src,tmp ARG_TYPES);
 				return true;
 				}
 			break;
 			}
 	case 1:	{
-			assert(converts_to_integerlike(src.data<2>()->type_code.base_type_index));
+			assert(converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES));
 			bool is_true = false;
-			if (literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				) && !is_true)
+			if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ - 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -7505,8 +7305,8 @@
 	default: FATAL_CODE("hardware/compiler error: invalid linear combination in C_add_expression_easy_syntax_check",3);
 #endif
 	case 0:	{	// cannot test errors from preprocessor
-			const bool rhs_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index);
-			if (!converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index))
+			const bool rhs_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES);
+			if (!converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src,rhs_arithmeticlike ? " has non-arithmetic non-pointer right argument (C99 6.5.6p2; C++98 5.7p1)" : " has non-arithmetic non-pointer arguments (C99 6.5.6p2; C++98 5.7p1)");
 				return;
@@ -7516,14 +7316,14 @@
 				simple_error(src," has non-arithmetic non-pointer left argument (C99 6.5.6p2; C++98 5.7p1)");
 				return;
 				}
-			src.type_code.set_type(arithmetic_reconcile(default_promote_type(src.data<1>()->type_code.base_type_index),default_promote_type(src.data<2>()->type_code.base_type_index)));
+			src.type_code.set_type(arithmetic_reconcile(default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES),default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES));
 			eval_add_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	case 1:	{	// ptr + integer, hopefully
 				// requires floating-point literals to test errors from preprocessor
 			src.type_code = src.data<1>()->type_code;
-			if (!converts_to_integerlike(src.data<2>()->type_code.base_type_index))
+			if (!converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src," adds pointer to non-integer (C99 6.5.6p2; C++98 5.7p1)");
 				return;
@@ -7534,7 +7334,7 @@
 	case 2:	{	// integer + ptr, hopefully
 				// requires floating-point literals to test errors from preprocessor
 			src.type_code = src.data<2>()->type_code;
-			if (!converts_to_integerlike(src.data<1>()->type_code.base_type_index))
+			if (!converts_to_integerlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src," adds pointer to non-integer (C99 6.5.6p2; C++98 5.7p1)");
 				return;
@@ -7548,8 +7348,8 @@
 			return;
 			}
 	case 4:	{	// cannot test errors from preprocessor
-			const bool rhs_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index);
-			if (!converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index))
+			const bool rhs_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES);
+			if (!converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src,rhs_arithmeticlike ? " has non-arithmetic non-pointer right argument (C99 6.5.6p3; C++98 5.7p2)" : " has non-arithmetic non-pointer arguments (C99 6.5.6p3; C++98 5.7p2)");
 				return;
@@ -7559,13 +7359,13 @@
 				simple_error(src," has non-arithmetic non-pointer left argument (C99 6.5.6p3; C++98 5.7p2)");
 				return;
 				}
-			src.type_code.set_type(arithmetic_reconcile(default_promote_type(src.data<1>()->type_code.base_type_index),default_promote_type(src.data<2>()->type_code.base_type_index)));
+			src.type_code.set_type(arithmetic_reconcile(default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES),default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES));
 			eval_sub_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	case 5:	{	// ptr - integer, hopefully; requires floating-point literal to test from preprocessor
 			src.type_code = src.data<1>()->type_code;
-			if (!converts_to_integerlike(src.data<2>()->type_code.base_type_index))
+			if (!converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src," subtracts non-integer from pointer (C99 6.5.6p3; C++98 5.7p2)");
 				return;
@@ -7645,16 +7445,16 @@
 		C_CPP_add_expression_easy_syntax_check(src.c_array<0>()[i],types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
 }
 
-static bool binary_infix_failed_integer_arguments(parse_tree& src, const char* standard)
+static bool binary_infix_failed_integer_arguments(parse_tree& src, const char* standard SIG_CONST_TYPES)
 {
 	assert(NULL!=standard);
 	if (parse_tree::INVALID & src.flags)	// already invalid, don't make noise
-		return !converts_to_integerlike(src.data<1>()->type_code) || !converts_to_integerlike(src.data<2>()->type_code);
+		return !converts_to_integerlike(src.data<1>()->type_code ARG_TYPES) || !converts_to_integerlike(src.data<2>()->type_code ARG_TYPES);
 
 	// hmm... 45-47, 48-50, 51-53, 54-56, 57-59
 	//! \todo need tests for float literal in place of int literal: << >> & ^ |
-	const bool rhs_integerlike = converts_to_integerlike(src.data<2>()->type_code);
-	if (!converts_to_integerlike(src.data<1>()->type_code))
+	const bool rhs_integerlike = converts_to_integerlike(src.data<2>()->type_code ARG_TYPES);
+	if (!converts_to_integerlike(src.data<1>()->type_code ARG_TYPES))
 		{	// tests for string literal in place of integer literal
 			//! \test default/Error_if_control46.hpp, default/Error_if_control46.h
 			//! \test default/Error_if_control47.hpp, default/Error_if_control47.h
@@ -7726,8 +7526,8 @@
 
 static bool eval_shift(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
-	assert(converts_to_integerlike(src.data<1>()->type_code));
-	assert(converts_to_integerlike(src.data<2>()->type_code));
+	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
+	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
 	assert(C99_SHIFT_SUBTYPE_LEFT<=src.subtype && C99_SHIFT_SUBTYPE_RIGHT>=src.subtype);
 	BOOST_STATIC_ASSERT(1==C99_SHIFT_SUBTYPE_RIGHT-C99_SHIFT_SUBTYPE_LEFT);
 	// handle:
@@ -7739,11 +7539,7 @@
 	// error if RHS is literal "out of bounds"
 	const type_spec old_type = src.type_code;
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		) && !is_true)
+	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 		{
 		if (!is_true)
 			{	// __ << 0 or __ >> 0: lift
@@ -7754,11 +7550,7 @@
 		};
 
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(rhs_int,*src.data<2>()
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		))
+	if (intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(old_type.base_type_index);
 		const bool undefined_behavior = target_machine->C_bit(machine_type)<=rhs_int;
@@ -7767,11 +7559,7 @@
 		if (undefined_behavior)
 			simple_error(src," : RHS is at least as large as bits of LHS; undefined behavior (C99 6.5.7p3/C++98 5.8p1)");
 
-		if (literal_converts_to_bool(*src.data<1>(),is_true
-#/*cut-cpp*/
-			,types
-#/*cut-cpp*/
-			))
+		if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES))
 			{
 			if (!is_true)
 				{	// 0 << __ or 0 >> __: zero out (note that we can do this even if we invoked undefined behavior)
@@ -7783,11 +7571,7 @@
 		if (undefined_behavior) return false;
 
 		umaxint res_int;
-		if (intlike_literal_to_VM(res_int,*src.data<1>()
-#/*cut-cpp*/
-			,types
-#/*cut-cpp*/
-			))
+		if (intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES))
 			{
 			// note that incoming negative signed integers are not handled by this code path
 			if (C99_SHIFT_SUBTYPE_LEFT==src.subtype)
@@ -7827,9 +7611,9 @@
 {
 	assert(is_C99_shift_expression(src));
 	// C99 6.5.7p2: requires being an integer type
-	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.7p2)")) return;
-	src.type_code.base_type_index = default_promote_type(src.data<1>()->type_code.base_type_index);
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.7p2)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_shift(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
@@ -7837,9 +7621,9 @@
 {
 	assert(is_C99_shift_expression(src));
 	// C++98 5.8p1: requires being an integer or enumeration type
-	if (binary_infix_failed_integer_arguments(src,"(C++98 5.8p1)")) return;
-	src.type_code.base_type_index = default_promote_type(src.data<1>()->type_code.base_type_index);
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C++98 5.8p1)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_shift(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
@@ -7920,16 +7704,8 @@
 	umaxint lhs_int;
 	umaxint rhs_int;
 
-	const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>()
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		);
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		);
+	const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 	if (lhs_converted && rhs_converted)
 		{
 		const char* result 	= NULL;
@@ -7966,7 +7742,7 @@
 	switch(ptr_case)
 	{
 	case 0:	{	// can't test from preprocessor
-			if (!converts_to_reallike(src.data<1>()->type_code.base_type_index) || !converts_to_reallike(src.data<2>()->type_code.base_type_index))
+			if (!converts_to_reallike(src.data<1>()->type_code.base_type_index ARG_TYPES) || !converts_to_reallike(src.data<2>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src," compares non-real type(s) (C99 6.5.8p2/C++98 5.9p2)");
 				return false;
@@ -7975,7 +7751,7 @@
 			}
 	case 1:	{	//! \todo need floating-point literal to test first half
 				//! \todo figure out how to test second half
-			if (!converts_to_integer(src.data<2>()->type_code) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+			if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
 				{	// oops
 				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
 				return false;
@@ -7984,7 +7760,7 @@
 			}
 	case 2:	{	//! \todo need floating-point literal to test first half
 				//! \todo figure out how to test second half
-			if (!converts_to_integer(src.data<1>()->type_code) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
+			if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
 				{	// oops
 				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
 				return false;
@@ -8114,8 +7890,8 @@
 	assert(C99_EQUALITY_SUBTYPE_EQ<=src.subtype && C99_EQUALITY_SUBTYPE_NEQ>=src.subtype);
 	umaxint lhs_int;
 	umaxint rhs_int;
-	const unsigned int integer_literal_case = 	  converts_to_integer(src.data<1>()->type_code)
-											+	2*converts_to_integer(src.data<2>()->type_code);
+	const unsigned int integer_literal_case = 	  converts_to_integer(src.data<1>()->type_code ARG_TYPES)
+											+	2*converts_to_integer(src.data<2>()->type_code ARG_TYPES);
 	const bool is_equal_op = src.subtype==C99_EQUALITY_SUBTYPE_EQ;
 	bool is_true = false;
 	switch(integer_literal_case)
@@ -8132,11 +7908,7 @@
 			break;
 			}
 	case 1:	{
-			if (0<src.data<2>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<1>(),is_true
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				)) 
+			if (0<src.data<2>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES)) 
 				{
 				if (!is_true)
 					{	
@@ -8157,11 +7929,7 @@
 			break;
 			}
 	case 2:	{
-			if (0<src.data<1>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				)) 
+			if (0<src.data<1>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES)) 
 				{
 				if (!is_true)
 					{
@@ -8182,21 +7950,13 @@
 			break;
 			}
 	case 3:	{	// integer literal == integer literal
-			const promote_aux lhs(src.data<1>()->type_code.base_type_index);
-			const promote_aux rhs(src.data<2>()->type_code.base_type_index);
-			const promote_aux old(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
+			const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
+			const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
+			const promote_aux old(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
 			assert(old.bitcount>=lhs.bitcount);
 			assert(old.bitcount>=rhs.bitcount);
-			const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>()
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				);
-			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				);
+			const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES);
+			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 			// general case here in case we try to do with converted/not converted mixed cases
 //			if (lhs_converted) target_machine->C_promote_integer(lhs_int,lhs,old);
 //			if (rhs_converted) target_machine->C_promote_integer(rhs_int,rhs,old);
@@ -8233,7 +7993,7 @@
 			break;
 			}
 	case 1:	{	// need floating-point literal to test from preprocessor
-			if (!converts_to_integer(src.data<2>()->type_code) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+			if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
 				{	// oops
 				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
 				return false;
@@ -8241,7 +8001,7 @@
 			break;
 			}
 	case 2:	{	// need floating-point literal to test from preprocessor
-			if (!converts_to_integer(src.data<1>()->type_code) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
+			if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
 				{	// oops
 				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
 				return false;
@@ -8354,8 +8114,8 @@
 
 static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
-	assert(converts_to_integerlike(src.data<1>()->type_code));
-	assert(converts_to_integerlike(src.data<2>()->type_code));
+	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
+	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
 	// handle following:
 	// __ & 0 |-> 0
 	// 0 & __ |-> 0
@@ -8363,16 +8123,8 @@
 	// unary - gives us problems (result is target-specific, could generate a trap representation)
 	const type_spec old_type = src.type_code;
 	bool is_true = false;
-	if (	(literal_converts_to_bool(*src.data<1>(),is_true
-#/*cut-cpp*/
-			,types
-#/*cut-cpp*/
-			) && !is_true)	// 0 & __
-		||	(literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-			,types
-#/*cut-cpp*/
-			) && !is_true))	// __ & 0
+	if (	(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)	// 0 & __
+		||	(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true))	// __ & 0
 		{
 		if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
 			{
@@ -8391,17 +8143,9 @@
 
 	umaxint lhs_int;
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(lhs_int,*src.data<1>()
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		) && intlike_literal_to_VM(rhs_int,*src.data<2>()
-#/*cut-cpp*/
-			,types
-#/*cut-cpp*/
-			))
+	if (intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES) && intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
-		const promote_aux old(old_type.base_type_index);
+		const promote_aux old(old_type.base_type_index ARG_TYPES);
 		umaxint res_int(lhs_int);
 		res_int &= rhs_int;
 
@@ -8442,9 +8186,9 @@
 {
 	assert(is_C99_bitwise_AND_expression(src));
 	// C99 6.5.10p2: requires being an integer type
-	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.10p2)")) return;
-	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.10p2)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_bitwise_AND(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
@@ -8452,9 +8196,9 @@
 {
 	assert(is_CPP_bitwise_AND_expression(src));
 	// C++98 5.11p1: requires being an integer or enumeration type
-	if (binary_infix_failed_integer_arguments(src,"(C++98 5.11p1)")) return;
-	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C++98 5.11p1)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_bitwise_AND(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
@@ -8545,19 +8289,15 @@
 
 static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
-	assert(converts_to_integerlike(src.data<1>()->type_code));
-	assert(converts_to_integerlike(src.data<2>()->type_code));
+	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
+	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
 	// handle following
 	// x ^ x |-> 0 [later, need sensible detection of "equal" expressions first]
 	// 0 ^ __ |-> __
 	// __ ^ 0 |-> __
 	// also handle double-literal case
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		))
+	if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES))
 		{
 		if (!is_true)
 			{	// 0 ^ __
@@ -8566,11 +8306,7 @@
 			return true;
 			}
 		};
-	if (literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		))
+	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES))
 		{
 		if (!is_true)
 			{	// __ ^ 0
@@ -8582,18 +8318,10 @@
 
 	umaxint lhs_int;
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(lhs_int,*src.data<1>()
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		) && intlike_literal_to_VM(rhs_int,*src.data<2>()
-#/*cut-cpp*/
-			,types
-#/*cut-cpp*/
-		))
+	if (intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES) && intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
 		const type_spec old_type = src.type_code;
-		const promote_aux old(old_type.base_type_index);
+		const promote_aux old(old_type.base_type_index ARG_TYPES);
 		umaxint res_int(lhs_int);
 		res_int ^= rhs_int;
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
@@ -8626,9 +8354,9 @@
 {
 	assert(is_C99_bitwise_XOR_expression(src));
 	// C99 6.5.11p2: requires being an integer type
-	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.11p2)")) return;
-	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.11p2)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_bitwise_XOR(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
@@ -8636,9 +8364,9 @@
 {
 	assert(is_CPP_bitwise_XOR_expression(src));
 	// C++98 5.12p1: requires being an integer or enumeration type
-	if (binary_infix_failed_integer_arguments(src,"(C++98 5.12p1)")) return;
-	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C++98 5.12p1)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_bitwise_XOR(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
@@ -8729,19 +8457,15 @@
 
 static bool eval_bitwise_OR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
-	assert(converts_to_integerlike(src.data<1>()->type_code));
-	assert(converts_to_integerlike(src.data<2>()->type_code));
+	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
+	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
 	// handle following:
 	// __ | 0 |-> __
 	// 0 | __ |-> __
 	// int-literal | int-literal |-> int-literal *if* both fit
 	// unary - gives us problems (result is target-specific, could generate a trap representation)
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		))
+	if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES))
 		{
 		if (!is_true)
 			{	// 0 | __
@@ -8750,11 +8474,7 @@
 			return true;
 			}
 		};
-	if (literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		))
+	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES))
 		{
 		if (!is_true)
 			{	// __ | 0
@@ -8766,15 +8486,7 @@
 
 	umaxint lhs_int;
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(lhs_int,*src.data<1>()
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		) && intlike_literal_to_VM(rhs_int,*src.data<2>()
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		))
+	if (intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES) && intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
 		const type_spec old_type = src.type_code;
 		umaxint res_int(lhs_int);
@@ -8814,9 +8526,9 @@
 {
 	assert(is_C99_bitwise_OR_expression(src));
 	// C99 6.5.12p2: requires being an integer type
-	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.12p2)")) return;
-	src.type_code.base_type_index = arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index);
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.12p2)" ARG_TYPES)) return;
+	src.type_code.base_type_index = arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_bitwise_OR(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
@@ -8824,9 +8536,9 @@
 {
 	assert(is_CPP_bitwise_OR_expression(src));
 	// C++98 5.13p1: requires being an integer or enumeration type
-	if (binary_infix_failed_integer_arguments(src,"(C++98 5.13p1)")) return;
-	src.type_code.base_type_index = arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index);
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C++98 5.13p1)" ARG_TYPES)) return;
+	src.type_code.base_type_index = arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_bitwise_OR(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
@@ -8865,13 +8577,13 @@
 		CPP_bitwise_OR_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
-static bool binary_infix_failed_boolean_arguments(parse_tree& src, const char* standard)
+static bool binary_infix_failed_boolean_arguments(parse_tree& src, const char* standard SIG_CONST_TYPES)
 {	//! \todo so the error message isn't technically right...convertible to bool in C++ is morally equivalent to scalar in C
 	// cannot test this within preprocessor
 	assert(NULL!=standard);
 
-	const bool rhs_converts_to_bool =  converts_to_bool(src.data<2>()->type_code);
-	if (!converts_to_bool(src.data<1>()->type_code))
+	const bool rhs_converts_to_bool =  converts_to_bool(src.data<2>()->type_code ARG_TYPES);
+	if (!converts_to_bool(src.data<1>()->type_code ARG_TYPES))
 		{
 		simple_error(src,rhs_converts_to_bool ? " has nonscalar LHS " : " has nonscalar LHS and RHS ");
 		return true;
@@ -8946,11 +8658,7 @@
 	// (__ && 1) && __ |-> __ && 1
 
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		))
+	if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES))
 		{	// one of 0 && __ or 1 && __
 		if (!is_true)
 			{	// 0 && __
@@ -8964,11 +8672,7 @@
 			force_decimal_literal(src,"0",types);
 			return true;
 			}
-		else if (literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-			,types
-#/*cut-cpp*/
-			))
+		else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES))
 			{	// 1 && 1 or 1 && 0
 			force_decimal_literal(src,is_true ? "1" : "0",types);
 			return true;
@@ -8988,7 +8692,7 @@
 static void C_logical_AND_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_logical_AND_expression(src));
-	if (binary_infix_failed_boolean_arguments(src,"(C99 6.5.13p2)")) return;
+	if (binary_infix_failed_boolean_arguments(src,"(C99 6.5.13p2)" ARG_TYPES)) return;
 
 	if (eval_logical_AND(src,types,C99_literal_converts_to_bool)) return;
 }
@@ -8996,7 +8700,7 @@
 static void CPP_logical_AND_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_CPP_logical_AND_expression(src));
-	if (binary_infix_failed_boolean_arguments(src,"(C++98 5.14p1)")) return;
+	if (binary_infix_failed_boolean_arguments(src,"(C++98 5.14p1)" ARG_TYPES)) return;
 
 	if (eval_logical_AND(src,types,CPP_literal_converts_to_bool)) return;
 }
@@ -9097,11 +8801,7 @@
 	// (__ || 1) || __ |-> __ || 1
 
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		))
+	if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES))
 		{	// one of 0 || __ or 1 || __
 		if (is_true)
 			{	// 1 || __
@@ -9115,11 +8815,7 @@
 			force_decimal_literal(src,"1",types);
 			return true;
 			}
-		else if (literal_converts_to_bool(*src.data<2>(),is_true
-#/*cut-cpp*/
-			,types
-#/*cut-cpp*/
-			))
+		else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES))
 			{	// 0 || 1 or 0 || 0
 			force_decimal_literal(src,is_true ? "1" : "0",types);
 			return true;
@@ -9139,7 +8835,7 @@
 static void C_logical_OR_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_logical_OR_expression(src));
-	if (binary_infix_failed_boolean_arguments(src,"(C99 6.5.14p2)")) return;
+	if (binary_infix_failed_boolean_arguments(src,"(C99 6.5.14p2)" ARG_TYPES)) return;
 
 	if (eval_logical_OR(src,types,C99_literal_converts_to_bool)) return;
 }
@@ -9147,7 +8843,7 @@
 static void CPP_logical_OR_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_CPP_logical_OR_expression(src));
-	if (binary_infix_failed_boolean_arguments(src,"(C++98 5.15p1)")) return;
+	if (binary_infix_failed_boolean_arguments(src,"(C++98 5.15p1)" ARG_TYPES)) return;
 
 	if (eval_logical_OR(src,types,CPP_literal_converts_to_bool)) return;
 }
@@ -9240,18 +8936,10 @@
 	return false;
 }
 
-static bool eval_conditional_op(parse_tree& src, literal_converts_to_bool_func& literal_converts_to_bool
-#/*cut-cpp*/
-		, const type_system& types
-#/*cut-cpp*/
-	)
+static bool eval_conditional_op(parse_tree& src, literal_converts_to_bool_func& literal_converts_to_bool SIG_CONST_TYPES)
 {
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.c_array<1>(),is_true
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		))
+	if (literal_converts_to_bool(*src.c_array<1>(),is_true ARG_TYPES))
 		{
 		const bool was_invalid = src.flags & parse_tree::INVALID;
 		const type_spec old_type = src.type_code;
@@ -9288,11 +8976,7 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<2>(),C99_intlike_literal_to_VM
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				))
+			else if (is_null_pointer_constant(*src.data<2>(),C99_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -9311,11 +8995,7 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<0>(),C99_intlike_literal_to_VM
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				))
+			else if (is_null_pointer_constant(*src.data<0>(),C99_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -9342,7 +9022,7 @@
 			//! \todo test cases at preprocessor level
 			else if (0==src.data<0>()->type_code.pointer_power_after_array_decay() && is_innate_definite_type(src.data<0>()->type_code.base_type_index) && is_innate_definite_type(src.data<2>()->type_code.base_type_index))
 				// standard arithmetic conversions
-				src.type_code.set_type(arithmetic_reconcile(src.data<0>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
+				src.type_code.set_type(arithmetic_reconcile(src.data<0>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES));
 			//! \todo --do-what-i-mean can handle elementary integer types with same indirection as well
 			else if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index || C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
 				{
@@ -9358,18 +9038,14 @@
 	}
 
 	// 2) prefix arg type convertible to _Bool (control whether expression is evaluatable at all)
-	if (!converts_to_bool(src.data<1>()->type_code))
+	if (!converts_to_bool(src.data<1>()->type_code ARG_TYPES))
 		{	// can't test this from preprocessor
 		simple_error(src," has nonscalar control expression");
 		return;
 		}
 	// 3) RAM conservation: if we have a suitable literal Do It Now
 	// \todo disable this at O0?
-	if (eval_conditional_op(src,C99_literal_converts_to_bool
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		)) return;
+	if (eval_conditional_op(src,C99_literal_converts_to_bool ARG_TYPES)) return;
 }
 
 static void CPP_conditional_op_easy_syntax_check(parse_tree& src,const type_system& types)
@@ -9390,11 +9066,7 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<2>(),CPP_intlike_literal_to_VM
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				))
+			else if (is_null_pointer_constant(*src.data<2>(),CPP_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -9413,11 +9085,7 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<0>(),CPP_intlike_literal_to_VM
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				))
+			else if (is_null_pointer_constant(*src.data<0>(),CPP_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -9443,7 +9111,7 @@
 				}
 			else if (0==src.data<0>()->type_code.pointer_power_after_array_decay() && is_innate_definite_type(src.data<0>()->type_code.base_type_index) && is_innate_definite_type(src.data<2>()->type_code.base_type_index))
 				// standard arithmetic conversions
-				src.type_code.set_type(arithmetic_reconcile(src.data<0>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
+				src.type_code.set_type(arithmetic_reconcile(src.data<0>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES));
 			//! \todo --do-what-i-mean can handle elementary integer types with same indirection as well
 			else if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index || C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
 				{
@@ -9459,18 +9127,14 @@
 	}
 
 	// 2) prefix arg type convertible to bool (control whether expression is evaluatable at all)
-	if (!converts_to_bool(src.data<1>()->type_code))
+	if (!converts_to_bool(src.data<1>()->type_code ARG_TYPES))
 		{	// can't test this from preprocessor
 		simple_error(src," has control expression unconvertible to bool");
 		return;
 		}
 	// 3) RAM conservation: if we have a suitable literal Do It Now
 	// \todo disable this at O0?
-	if (eval_conditional_op(src,CPP_literal_converts_to_bool
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-		)) return;
+	if (eval_conditional_op(src,CPP_literal_converts_to_bool ARG_TYPES)) return;
 }
 
 static void locate_C99_conditional_op(parse_tree& src, size_t& i, const type_system& types)
@@ -9990,12 +9654,8 @@
 		if (UINT_MAX>str_index)
 			{
 			umaxint tmp; 
-			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index)
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				)) return false;
-			const size_t promoted_type = default_promote_type(src.type_code.base_type_index);
+			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index) ARG_TYPES)) return false;
+			const size_t promoted_type = default_promote_type(src.type_code.base_type_index ARG_TYPES);
 			const virtual_machine::std_int_enum machine_type = (virtual_machine::std_int_enum)((promoted_type-C_TYPE::INT)/2+virtual_machine::std_int_int);
 			eval_string_literal_deref(src,types,src.data(str_index)->index_tokens[0].token,tmp,tmp.test(target_machine->C_bit(machine_type)-1),C_TESTFLAG_CHAR_LITERAL==src.data(1-str_index)->index_tokens[0].flags);
 			return true;
@@ -10268,11 +9928,7 @@
 	if (is_C99_conditional_operator_expression(src))
 		{	// prefix operator is boolean
 		EvalParseTree(*src.c_array<1>(),types);
-		if (eval_conditional_op(src,literal_converts_to_bool
-#/*cut-cpp*/
-		,types
-#/*cut-cpp*/
-			)) return true;
+		if (eval_conditional_op(src,literal_converts_to_bool ARG_TYPES)) return true;
 		}
 	return false;
 }
@@ -10388,23 +10044,15 @@
 			{
 			umaxint res_int;
 			umaxint rhs_int;
-			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data<1>()
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				);
-			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data<2>()
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				);
+			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 			if (lhs_converted && rhs_converted)
 				{	//! \todo deal with signed integer arithmetic
-				const promote_aux old(old_type.base_type_index);
+				const promote_aux old(old_type.base_type_index ARG_TYPES);
 				assert(old.is_signed);
-				const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+				const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 				assert(old.bitcount>=lhs.bitcount);
-				const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+				const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 				assert(old.bitcount>=rhs.bitcount);
 
 				// handle sign-extension of lhs, rhs
@@ -10464,23 +10112,15 @@
 			{
 			umaxint res_int;
 			umaxint rhs_int;
-			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data<1>()
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				);
-			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data<2>()
-#/*cut-cpp*/
-				,types
-#/*cut-cpp*/
-				);
+			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 			if (lhs_converted && rhs_converted)
 				{	//! \todo deal with signed integer arithmetic
-				const promote_aux old(old_type.base_type_index);
+				const promote_aux old(old_type.base_type_index ARG_TYPES);
 				assert(old.is_signed);
-				const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+				const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 				assert(old.bitcount>=lhs.bitcount);
-				const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+				const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 				assert(old.bitcount>=rhs.bitcount);
 
 				// handle sign-extension of lhs, rhs
@@ -11105,13 +10745,13 @@
 	src.DeleteNSlotsAt<0>(j-i+1,i);
 }
 
-static bool default_enumerator_init_legal(const bool allow_empty, unsigned char& current_enumerator_type, const unsigned_var_int& prior_value, const weak_token& src)
+static bool default_enumerator_init_legal(const bool allow_empty, unsigned char& current_enumerator_type, const unsigned_var_int& prior_value, const weak_token& src, const type_system& types)
 {
 	if (allow_empty)
 		{	// C++
 		//! \todo research how to rewrite this without the goto
 cpp_enum_was_retyped:
-		const promote_aux test(current_enumerator_type);
+		const promote_aux test(current_enumerator_type,types);
 		//! \bug need -Wc-c++-compat to go off here
 		if (test.is_signed)
 			{
@@ -11376,7 +11016,7 @@
 		value_copy(prior_value,latest_value);
 		{
 		bool value_is_nonnegative = true;
-		const promote_aux test(current_enumerator_type);
+		const promote_aux test(current_enumerator_type,types);
 		if (test.is_signed && latest_value.test(test.bitcount-1))
 			{
 			target_machine->signed_additive_inverse(latest_value,test.machine_type);
@@ -11393,7 +11033,7 @@
 		if (1>=src.size<0>()-i)
 			{	// default-update
 			// handle type errors
-			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0]))
+			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0],types))
 				return false;
 			uchar_blob latest_value_copy;
 			latest_value_copy.init(0);
@@ -11410,7 +11050,7 @@
 		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
 		if (robust_token_is_char<','>(src.data<0>()[i+1]))
 			{	// would default-update
-			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0]))
+			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0],types))
 				return false;
 			uchar_blob latest_value_copy;
 			latest_value_copy.init(0);
@@ -11454,8 +11094,8 @@
 			current_enumerator_type = tmp.type_code.base_type_index;
 			}
 		else{	// C
-			const promote_aux test(tmp.type_code.base_type_index);
-			const promote_aux dest_type(C_TYPE::INT);
+			const promote_aux test(tmp.type_code.base_type_index,types);
+			const promote_aux dest_type(C_TYPE::INT,types);
 			const bool is_negative = test.is_signed && latest_value.test(test.bitcount-1);
 			if (is_negative)
 				target_machine->signed_additive_inverse(latest_value,test.machine_type);

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-21 19:24:26 UTC (rev 354)
+++ trunk/CSupport_pp.cpp	2010-03-24 19:16:13 UTC (rev 355)
@@ -28,6 +28,24 @@
 #include "C_PPHexFloat.hpp"
 #include "CheckReturn.hpp"
 
+#ifdef ZCC_NOT_BUILDING_CPP
+#error internal macro ZCC_NOT_BUILDING_CPP already defined 
+#endif
+// handle function signature differences between z_cpp and other users
+#ifdef SIG_CONST_TYPES
+#error internal macro SIG_CONST_TYPES already defined 
+#endif
+#ifdef ARG_TYPES
+#error internal macro ARG_TYPES already defined 
+#endif
+#ifdef ZCC_NOT_BUILDING_CPP
+#define SIG_CONST_TYPES ,const type_system& types 
+#define ARG_TYPES ,types 
+#else
+#define SIG_CONST_TYPES 
+#define ARG_TYPES 
+#endif
+
 using namespace zaimoni;
 using virtual_machine::umaxint;
 
@@ -575,53 +593,70 @@
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
 }
 
-static bool converts_to_integerlike(size_t base_type_index)
+static bool converts_to_integerlike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
+#ifdef ZCC_NOT_BUILDING_CPP
+	if (C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index) return true;
+	return types.get_enum_def(base_type_index);
+#else
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index;
+#endif
 }
 
-static bool converts_to_integerlike(const type_spec& type_code)
+static bool converts_to_integerlike(const type_spec& type_code SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
 	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers
-	return converts_to_integerlike(type_code.base_type_index);
+	return converts_to_integerlike(type_code.base_type_index ARG_TYPES);
 }
 
-static bool converts_to_integer(const type_spec& type_code)
+static bool converts_to_integer(const type_spec& type_code SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	//! \todo handle enum types
 	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers
+#ifdef ZCC_NOT_BUILDING_CPP
+	if (C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index) return true;
+	return types.get_enum_def(type_code.base_type_index);
+#else
 	return C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index;
+#endif
 }
 
-static bool converts_to_reallike(size_t base_type_index)
+static bool converts_to_reallike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	//! \todo handle enum types
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index;
+#ifdef ZCC_NOT_BUILDING_CPP
+	if (C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index) return true;
+	return types.get_enum_def(base_type_index);
+#else
+	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index;
+#endif
 }
 
-static bool converts_to_arithmeticlike(size_t base_type_index)
+static bool converts_to_arithmeticlike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	//! \todo handle enum types
+#ifdef ZCC_NOT_BUILDING_CPP
+	if (C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index) return true;
+	return types.get_enum_def(base_type_index);
+#else
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
+#endif
 }
 
-static bool converts_to_arithmeticlike(const type_spec& type_code)
+static bool converts_to_arithmeticlike(const type_spec& type_code SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	//! \todo handle enum types
 	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers/floats/complex
-	return converts_to_arithmeticlike(type_code.base_type_index);
+	return converts_to_arithmeticlike(type_code.base_type_index ARG_TYPES);
 }
 
-static bool converts_to_bool(const type_spec& type_code)
+static bool converts_to_bool(const type_spec& type_code SIG_CONST_TYPES)
 {
 	if (0<type_code.pointer_power_after_array_decay()) return true;	// pointers are comparable to NULL
-	if (converts_to_arithmeticlike(type_code.base_type_index)) return true;	// arithmetic types are comparable to zero, and include bool
+	if (converts_to_arithmeticlike(type_code.base_type_index ARG_TYPES)) return true;	// arithmetic types are comparable to zero, and include bool
 	// C++: run through type conversion weirdness
 	return false;
 }
 
 // the integer promotions rely on low-level weirdness, so test that here
-static size_t arithmetic_reconcile(size_t base_type_index1, size_t base_type_index2)
+static size_t arithmetic_reconcile(size_t base_type_index1, size_t base_type_index2 SIG_CONST_TYPES)
 {
 	assert(is_innate_definite_type(base_type_index1));
 	assert(is_innate_definite_type(base_type_index2));
@@ -734,7 +769,7 @@
 		}
 }
 
-static size_t default_promote_type(size_t i)
+static size_t default_promote_type(size_t i SIG_CONST_TYPES)
 {
 	switch(i)
 	{
@@ -749,14 +784,25 @@
 	return i;
 }
 
+static POD_pair<size_t,bool> default_promotion_is_integerlike(const type_spec& type_code SIG_CONST_TYPES)
+{	// uses NRVO
+	POD_pair<size_t,bool> tmp = {0,false};
+	if (0==type_code.pointer_power_after_array_decay())	// pointers do not have a standard conversion to integers
+		{
+		tmp.first = default_promote_type(type_code.base_type_index ARG_TYPES);
+		tmp.second = (C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>=type_code.base_type_index);
+		}
+	return tmp;
+}
+
 // auxilliary structure to aggregate useful information for type promotions
 // this will malfunction badly for anything other than an integer type
 class promote_aux : public virtual_machine::promotion_info
 {
 public:
-	promote_aux(size_t base_type_index)
+	promote_aux(size_t base_type_index SIG_CONST_TYPES)
 	{
-		const size_t promoted_type = default_promote_type(base_type_index);
+		const size_t promoted_type = default_promote_type(base_type_index ARG_TYPES);
 		machine_type = machine_type_from_type_index(promoted_type);
 		bitcount = target_machine->C_bit(machine_type);
 		is_signed = !((promoted_type-C_TYPE::INT)%2);
@@ -3791,11 +3837,9 @@
 }
 
 // forward-declare to handle recursion
-static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
-	);
+static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src SIG_CONST_TYPES);
 
-static bool _C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
-	)
+static bool _C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src SIG_CONST_TYPES)
 {
 	assert(C_TYPE::INTEGERLIKE!=src.type_code.base_type_index);
 
@@ -3803,21 +3847,19 @@
 		&&  !bool_options[boolopt::int_traps]
 		&&	is_C99_add_operator_expression<'-'>(src))
 		{
-		const promote_aux old(src.type_code.base_type_index);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		if (old.is_signed)
 			{
-			const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+			const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 			assert(old.bitcount>=lhs.bitcount);
 			if (lhs.is_signed)
 				{
 				umaxint lhs_int;
 				umaxint rhs_int;
-				if (	C99_intlike_literal_to_VM(lhs_int,*src.data<1>()
-					)
-					&&	C99_intlike_literal_to_VM(rhs_int,*src.data<2>()
-					))
+				if (	C99_intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES)
+					&&	C99_intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 					{
-					const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+					const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 					assert(old.bitcount>=rhs.bitcount);
 					assert(old.bitcount>rhs.bitcount || rhs.is_signed);
 					if (lhs_int.test(lhs.bitcount-1) && (!rhs.is_signed || !rhs_int.test(rhs.bitcount-1)))
@@ -3876,13 +3918,11 @@
 
 // return value: literal to parse, whether additive inverse applies
 static POD_pair<const parse_tree*,bool>
-_find_intlike_literal(const parse_tree* src
-	)
+_find_intlike_literal(const parse_tree* src SIG_CONST_TYPES)
 {
 	assert(NULL!=src);
 	POD_pair<const parse_tree*,bool> ret = {src,false};
-	while(converts_to_integer(ret.first->type_code
-		))
+	while(converts_to_integer(ret.first->type_code ARG_TYPES))
 		{
 		if 		(is_C99_unary_operator_expression<'-'>(*ret.first))
 			{
@@ -3902,23 +3942,19 @@
 }
 
 // use this typedef to cope with signature varying by build
-typedef bool (intlike_literal_to_VM_func)(umaxint& dest, const parse_tree& src
-	);
+typedef bool (intlike_literal_to_VM_func)(umaxint& dest, const parse_tree& src SIG_CONST_TYPES);
 
-static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
-	)
+static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src SIG_CONST_TYPES)
 {
-	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src
-		);
+	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src ARG_TYPES);
 
 	if (C_TYPE::INTEGERLIKE==actual.first->type_code.base_type_index)
 		return false;	
 
-	if (!_C99_intlike_literal_to_VM(dest,*actual.first
-		)) return false;
+	if (!_C99_intlike_literal_to_VM(dest,*actual.first ARG_TYPES)) return false;
 	if (actual.second)
 		{
-		const promote_aux old(src.type_code.base_type_index);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		if (old.is_signed)
 			target_machine->signed_additive_inverse(dest,old.machine_type);
 		else
@@ -3927,23 +3963,20 @@
 	return true;
 }
 
-static bool CPP_intlike_literal_to_VM(umaxint& dest, const parse_tree& src
-	)
+static bool CPP_intlike_literal_to_VM(umaxint& dest, const parse_tree& src SIG_CONST_TYPES)
 {
-	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src
-		);
+	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src ARG_TYPES);
 
 	if (!_CPP_intlike_literal_to_VM(dest,*actual.first))
 		{
 		if (C_TYPE::INTEGERLIKE==actual.first->type_code.base_type_index)
 			return false;	
 
-		if (!_C99_intlike_literal_to_VM(dest,*actual.first
-			)) return false;
+		if (!_C99_intlike_literal_to_VM(dest,*actual.first ARG_TYPES)) return false;
 		};
 	if (actual.second)
 		{
-		const promote_aux old(src.type_code.base_type_index);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		if (old.is_signed)
 			target_machine->signed_additive_inverse(dest,old.machine_type);
 		else
@@ -3958,13 +3991,11 @@
  * \return -1 : can't decide quickly whether this is a null 
  *         pointer constant
  */
-static int is_null_pointer_constant(const parse_tree& src,intlike_literal_to_VM_func& intlike_literal_to_VM
-	)
+static int is_null_pointer_constant(const parse_tree& src,intlike_literal_to_VM_func& intlike_literal_to_VM SIG_CONST_TYPES)
 {	//! \bug doesn't recognize enumerators with value zero
-	if (!converts_to_integerlike(src.type_code)) return 0;
+	if (!converts_to_integerlike(src.type_code ARG_TYPES)) return 0;
 	umaxint tmp;
-	if (intlike_literal_to_VM(tmp,src
-		)) return tmp==0;
+	if (intlike_literal_to_VM(tmp,src ARG_TYPES)) return tmp==0;
 	return -1;
 }
 
@@ -4508,8 +4539,7 @@
 			simple_error(src,"array dereference of pointer by pointer (C99 6.5.2.1p1; C++98 5.2.1p1,13.3.1.2p1)");
 			return;
 			}
-		else if (converts_to_integerlike(src.data<0>()->type_code.base_type_index
-			))
+		else if (converts_to_integerlike(src.data<0>()->type_code.base_type_index ARG_TYPES))
 			{
 			value_copy(src.type_code,src.data<1>()->type_code);
 			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
@@ -4527,8 +4557,7 @@
 		}
 	else if (0<effective_pointer_power_infix)
 		{
-		if (converts_to_integerlike(src.data<1>()->type_code.base_type_index
-			))
+		if (converts_to_integerlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
 			{
 			value_copy(src.type_code,src.data<0>()->type_code);
 			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
@@ -4727,12 +4756,10 @@
 }
 
 // typedef to simplify compatibility changes
-typedef bool literal_converts_to_bool_func(const parse_tree& src, bool& is_true
-	);
+typedef bool literal_converts_to_bool_func(const parse_tree& src, bool& is_true SIG_CONST_TYPES);
 
 // Closely related to if_elif_control_is_zero/CPreproc.cpp
-static bool _C99_literal_converts_to_bool(const parse_tree& src, bool& is_true
-	)
+static bool _C99_literal_converts_to_bool(const parse_tree& src, bool& is_true SIG_CONST_TYPES)
 {
 	assert(src.is_atomic());
 	// string literals always test true (decay to non-NULL pointer)
@@ -4754,27 +4781,21 @@
 	return true;
 }
 
-static bool C99_literal_converts_to_bool(const parse_tree& src, bool& is_true
-	)
+static bool C99_literal_converts_to_bool(const parse_tree& src, bool& is_true SIG_CONST_TYPES)
 {	// deal with -1 et. al.
-	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return _C99_literal_converts_to_bool(*src.data<2>(),is_true
-		);
+	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return _C99_literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES);
 
 	if (!src.is_atomic()) return false;
-	return _C99_literal_converts_to_bool(src,is_true
-		);
+	return _C99_literal_converts_to_bool(src,is_true ARG_TYPES);
 }
 
-static bool CPP_literal_converts_to_bool(const parse_tree& src, bool& is_true
-	)
+static bool CPP_literal_converts_to_bool(const parse_tree& src, bool& is_true SIG_CONST_TYPES)
 {
 	// deal with -1 et. al.
-	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return CPP_literal_converts_to_bool(*src.data<2>(),is_true
-		);
+	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return CPP_literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES);
 
 	if (!src.is_atomic()) return false;
-	if (_C99_literal_converts_to_bool(src,is_true
-		)) return true;
+	if (_C99_literal_converts_to_bool(src,is_true ARG_TYPES)) return true;
 	// deal with: this, true, false
 	if (token_is_string<5>(src.index_tokens[0].token,"false"))
 		{
@@ -4878,7 +4899,7 @@
 	return dest;
 }
 
-static void force_unary_positive_literal(parse_tree& dest,const parse_tree& src)
+static void force_unary_positive_literal(parse_tree& dest,const parse_tree& src SIG_CONST_TYPES)
 {
 	assert(0==dest.size<0>());
 	assert(0==dest.size<1>());
@@ -4889,13 +4910,13 @@
 	dest.core_flag_update();
 	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	dest.subtype = C99_UNARY_SUBTYPE_PLUS;
-	if (converts_to_arithmeticlike(dest.data<2>()->type_code))
-		dest.type_code = dest.data<2>()->type_code;
+	if (converts_to_arithmeticlike(dest.data<2>()->type_code ARG_TYPES))
+		dest.type_code = dest.data<2>()->type_code;	//! \bug doesn't work for enumerators
 	assert(NULL!=dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'+'>(dest));
 }
 
-static void force_unary_negative_token(parse_tree& dest,parse_tree* src,const parse_tree& loc_src)
+static void force_unary_negative_token(parse_tree& dest,parse_tree* src,const parse_tree& loc_src SIG_CONST_TYPES)
 {
 	assert(src);
 	assert(PARSE_EXPRESSION & src->flags);
@@ -4906,8 +4927,8 @@
 	dest.core_flag_update();
 	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	dest.subtype = C99_UNARY_SUBTYPE_NEG;
-	if (converts_to_arithmeticlike(dest.data<2>()->type_code))
-		dest.type_code = dest.data<2>()->type_code;
+	if (converts_to_arithmeticlike(dest.data<2>()->type_code ARG_TYPES))
+		dest.type_code = dest.data<2>()->type_code;	//! \bug doesn't work for enumerators
 	// do not handle type here: C++ operator overloading risk
 	assert(NULL!=dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'-'>(dest));
@@ -4923,16 +4944,16 @@
 		if (NULL==tmp) return false;
 		if (!VM_to_literal(*tmp,src_int,src,types)) return false;
 		assert(PARSE_EXPRESSION & tmp->flags);
-		force_unary_negative_token(x,tmp,*tmp);
+		force_unary_negative_token(x,tmp,*tmp ARG_TYPES);
 		}
 	else if (!VM_to_literal(x,src_int,src,types))
 		return false;
 	return true;
 }
 
-static bool is_integerlike_literal(const parse_tree& x)
+static bool is_integerlike_literal(const parse_tree& x SIG_CONST_TYPES)
 {
-	return converts_to_integerlike(x.type_code) && (PARSE_PRIMARY_EXPRESSION & x.flags);
+	return converts_to_integerlike(x.type_code ARG_TYPES) && (PARSE_PRIMARY_EXPRESSION & x.flags);
 }
 
 static bool eval_unary_plus(parse_tree& src, const type_system& types)
@@ -4950,7 +4971,7 @@
 		return false;
 		};
  	// handle integer-like literals like a real integer literal
-	if (is_integerlike_literal(*src.data<2>()))
+	if (is_integerlike_literal(*src.data<2>() ARG_TYPES))
 		{
 		const type_spec old_type = src.type_code;
 		src.eval_to_arg<2>(0);
@@ -4964,8 +4985,7 @@
 {
 	assert(is_C99_unary_operator_expression<'-'>(src));
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<2>(),is_true
-		) && !is_true && (1==(src.type_code.base_type_index-C_TYPE::INT)%2 || virtual_machine::twos_complement==target_machine->C_signed_int_representation() || bool_options[boolopt::int_traps]))
+	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true && (1==(src.type_code.base_type_index-C_TYPE::INT)%2 || virtual_machine::twos_complement==target_machine->C_signed_int_representation() || bool_options[boolopt::int_traps]))
 		{	// -0==0
 			// deal with unary - not being allowed to actually return -0 on these machines later
 		const type_spec old_type = src.type_code;
@@ -4973,13 +4993,12 @@
 		src.type_code = old_type;		
 		return true;
 		};
-	if (is_integerlike_literal(*src.data<2>()) && 1==(src.type_code.base_type_index-C_TYPE::INT)%2)
+	if (is_integerlike_literal(*src.data<2>() ARG_TYPES) && 1==(src.type_code.base_type_index-C_TYPE::INT)%2)
 		{	// unsigned...we're fine
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
 		const type_spec old_type = src.type_code;
 		umaxint res_int;
-		intlike_literal_to_VM(res_int,*src.data<2>()
-			);
+		intlike_literal_to_VM(res_int,*src.data<2>() ARG_TYPES);
 		target_machine->unsigned_additive_inverse(res_int,machine_type);
 
 		//! \todo flag failures to reduce as RAM-stalled
@@ -4990,9 +5009,9 @@
 		src.type_code = old_type;
 		return true;
 		};
-	if (converts_to_integerlike(src.data<2>()->type_code) && is_C99_unary_operator_expression<'-'>(*src.data<2>()))
+	if (converts_to_integerlike(src.data<2>()->type_code ARG_TYPES) && is_C99_unary_operator_expression<'-'>(*src.data<2>()))
 		{	// - - __ |-> __, trap-int machines fine as -0=0 for sign/magnitude and one's complement, and the offending literal for two's complement is an unsigned int
-		assert(converts_to_integerlike(src.data<2>()->data<2>()->type_code));
+		assert(converts_to_integerlike(src.data<2>()->data<2>()->type_code ARG_TYPES));
 		const type_spec old_type = src.type_code;
 		parse_tree tmp = *src.data<2>()->data<2>();
 		src.c_array<2>()->c_array<2>()->clear();
@@ -5016,8 +5035,8 @@
 		return;
 		}
 	// can type if result is a primitive arithmetic type
-	if (converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index))
-		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index));
+	if (converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
+		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES));
 	
 	const size_t arg_unary_subtype 	= (is_C99_unary_operator_expression<'-'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_NEG
 									: (is_C99_unary_operator_expression<'+'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_PLUS : 0;
@@ -5046,8 +5065,8 @@
 	assert((C99_UNARY_SUBTYPE_PLUS==src.subtype) ? is_C99_unary_operator_expression<'+'>(src) : is_C99_unary_operator_expression<'-'>(src));
 	
 	// can type if result is a primitive arithmetic type
-	if (converts_to_arithmeticlike(src.data<2>()->type_code))
-		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index));
+	if (converts_to_arithmeticlike(src.data<2>()->type_code ARG_TYPES))
+		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES));
 
 	// two deep:
 	// 1) if inner +/- is applied to an arithmetic literal, try to crunch it (but leave - signed alone)
@@ -5199,8 +5218,7 @@
 	assert(is_logical_NOT(src));
 	{	// deal with literals that convert to bool here
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<2>(),is_true
-		))
+	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES))
 		{
 		src.destroy();
 		src.index_tokens[0].token.first = (is_true) ? "0" : "1";
@@ -5232,8 +5250,7 @@
 	src.type_code.set_type(C_TYPE::BOOL);	// technically wrong for C, but the range is restricted to _Bool's range
 	if (eval_logical_NOT(src,types,is_C99_unary_operator_expression<'!'>,C99_literal_converts_to_bool)) return;
 
-	if (!converts_to_bool(src.data<2>()->type_code
-		))
+	if (!converts_to_bool(src.data<2>()->type_code ARG_TYPES))
 		{	// can't test this from preprocessor or static assertion
 		simple_error(src," applies ! to a nonscalar type (C99 6.5.3.3p1)");
 		return;
@@ -5246,8 +5263,7 @@
 	src.type_code.set_type(C_TYPE::BOOL);	// technically wrong for C, but the range is restricted to _Bool's range
 	if (eval_logical_NOT(src,types,is_CPP_logical_NOT_expression,CPP_literal_converts_to_bool)) return;
 
-	if (!converts_to_bool(src.data<2>()->type_code
-		))
+	if (!converts_to_bool(src.data<2>()->type_code ARG_TYPES))
 		{	// can't test this from preprocessor or static assertion
 		simple_error(src," applies ! to a type not convertible to bool (C++98 5.3.1p8)");
 		return;
@@ -5395,7 +5411,7 @@
 		_flush(tmp);
 		return false;
 		}
-	force_unary_negative_token(*tmp3,tmp,src_loc);
+	force_unary_negative_token(*tmp3,tmp,src_loc ARG_TYPES);
 
 	parse_tree tmp4;
 	tmp4.clear();
@@ -5418,10 +5434,9 @@
 static bool eval_bitwise_compl(parse_tree& src, const type_system& types,bool hard_error,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_bitwise_complement_expression(src));
-	assert(converts_to_integerlike(src.data<2>()->type_code));
+	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
 	umaxint res_int;
-	if (intlike_literal_to_VM(res_int,*src.data<2>()
-		)) 
+	if (intlike_literal_to_VM(res_int,*src.data<2>() ARG_TYPES)) 
 		{
 		const type_spec old_type = src.type_code;
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(old_type.base_type_index);
@@ -5470,26 +5485,28 @@
 static void C_bitwise_complement_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'~'>(src));
-	if (!converts_to_integerlike(src.data<2>()->type_code))
+	const POD_pair<size_t,bool> tmp = default_promotion_is_integerlike(src.data<2>()->type_code ARG_TYPES);
+	if (!tmp.second)
 		{	//! \test Error_if_control25.h
 		src.type_code.set_type(0);
 		simple_error(src," applies ~ to a nonintegral type (C99 6.5.3.3p1)");
 		return;
 		}
-	src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index));
+	src.type_code.set_type(tmp.first);
 	if (eval_bitwise_compl(src,types,false,is_C99_unary_operator_expression<'~'>,C99_intlike_literal_to_VM)) return;
 }
 
 static void CPP_bitwise_complement_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_CPP_bitwise_complement_expression(src));
-	if (!converts_to_integerlike(src.data<2>()->type_code))
+	const POD_pair<size_t,bool> tmp = default_promotion_is_integerlike(src.data<2>()->type_code ARG_TYPES);
+	if (!tmp.second)
 		{
 		src.type_code.set_type(0);
 		simple_error(src," applies ~ to a nonintegral type (C99 6.5.3.3p1)");
 		return;
 		}
-	src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index));
+	src.type_code.set_type(tmp.first);
 	if (eval_bitwise_compl(src,types,false,is_CPP_bitwise_complement_expression,CPP_intlike_literal_to_VM)) return;
 }
 
@@ -5855,10 +5872,8 @@
 	bool is_true = false;
 
 	// do this first to avoid unnecessary dynamic memory allocation
-	if (	(literal_converts_to_bool(*src.data<1>(),is_true
-			) && !is_true)	// 0 * __
-		||	(literal_converts_to_bool(*src.data<2>(),is_true
-			) && !is_true))	// __ * 0
+	if (	(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)	// 0 * __
+		||	(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true))	// __ * 0
 		{
 		// construct +0 to defuse 1-0*6
 		parse_tree tmp = decimal_literal("0",src,types);
@@ -5872,16 +5887,14 @@
 			}
 		else tmp.type_code = old_type;
 		src.DeleteIdx<1>(0);
-		force_unary_positive_literal(src,tmp);
+		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
 		};
 
 	umaxint res_int;
 	umaxint rhs_int;
-	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
-		);
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
-		);
+	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 	if (lhs_converted && 1==res_int)
 		{
 		src.eval_to_arg<2>(0);
@@ -5896,10 +5909,10 @@
 		};
 	if (lhs_converted && rhs_converted)
 		{
-		const promote_aux old(old_type.base_type_index);
-		const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=lhs.bitcount);
-		const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=rhs.bitcount);
 
 		// handle sign-extension of lhs, rhs
@@ -5955,7 +5968,7 @@
 		if (!VM_to_literal(tmp,res_int,src,types)) return false;
 		tmp.type_code = old_type;
 		src.DeleteIdx<1>(0);
-		force_unary_positive_literal(src,tmp);
+		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
 		}
 	return false;
@@ -5967,10 +5980,9 @@
 
 	const type_spec old_type = src.type_code;
 	bool is_true = false;
-	if (converts_to_integerlike(src.type_code))
+	if (converts_to_integerlike(src.type_code ARG_TYPES))
 		{
-		if 		(literal_converts_to_bool(*src.data<2>(),is_true
-				) && !is_true)
+		if 		(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 			{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
 			if (hard_error)
 				//! \test default/Error_if_control30.hpp, default/Error_if_control30.h
@@ -5978,8 +5990,7 @@
 			return false;
 			}
 		/*! \todo would like a simple comparison of absolute values to auto-detect zero, possibly after mainline code */
-		else if (literal_converts_to_bool(*src.data<1>(),is_true
-				) && !is_true)
+		else if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 			{
 			// construct +0 to defuse 1-0/6
 			parse_tree tmp = decimal_literal("0",src,types);
@@ -5993,7 +6004,7 @@
 				}
 			else tmp.type_code = old_type;
 			src.DeleteIdx<1>(0);
-			force_unary_positive_literal(src,tmp);
+			force_unary_positive_literal(src,tmp ARG_TYPES);
 			return true;
 			}
 		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
@@ -6001,10 +6012,8 @@
 
 	umaxint res_int;
 	umaxint rhs_int;
-	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
-		);
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
-		);
+	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 	if (rhs_converted && rhs_int==1)
 		{	// __/1 |-> __
 		src.eval_to_arg<1>(0);
@@ -6016,10 +6025,10 @@
 	// implementation-defined whether negative results round away or to zero (standard prefers to zero, so default to that)
 	if (lhs_converted && rhs_converted)
 		{
-		const promote_aux old(old_type.base_type_index);
-		const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=lhs.bitcount);
-		const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=rhs.bitcount);
 
 		// handle sign-extension of lhs, rhs
@@ -6040,7 +6049,7 @@
 				tmp.type_code = old_type;
 				src.DeleteIdx<1>(0);
 				if (want_zero)
-					force_unary_positive_literal(src,tmp); // +0
+					force_unary_positive_literal(src,tmp ARG_TYPES); // +0
 				else	
 					force_unary_negative_literal(src,tmp); // -1
 				return true;
@@ -6086,7 +6095,7 @@
 		tmp.type_code = old_type;
 
 		src.DeleteIdx<1>(0);
-		force_unary_positive_literal(src,tmp);
+		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
 		}
 	return false;
@@ -6098,10 +6107,9 @@
 
 	const type_spec old_type = src.type_code;
 	bool is_true = false;
-	if (converts_to_integerlike(src.type_code))
+	if (converts_to_integerlike(src.type_code ARG_TYPES))
 		{
-		if 		(literal_converts_to_bool(*src.data<2>(),is_true
-				) && !is_true)
+		if 		(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 			{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
 			if (hard_error)
 				//! \test default/Error_if_control31.hpp, Error_if_control31.h
@@ -6109,8 +6117,7 @@
 			return false;
 			}
 		/*! \todo would like a simple comparison of absolute values to auto-detect zero, possibly after mainline code */
-		else if (literal_converts_to_bool(*src.data<1>(),is_true
-				) && !is_true)
+		else if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 			{
 			// construct +0 to defuse 1-0%6
 			parse_tree tmp = decimal_literal("0",src,types);
@@ -6124,7 +6131,7 @@
 				}
 			else tmp.type_code = old_type;
 			src.DeleteIdx<1>(0);
-			force_unary_positive_literal(src,tmp);
+			force_unary_positive_literal(src,tmp ARG_TYPES);
 			return true;
 			}
 		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
@@ -6132,10 +6139,8 @@
 
 	umaxint res_int;
 	umaxint rhs_int;
-	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
-		);
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
-		);
+	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 	if (rhs_converted && rhs_int==1)
 		{	// __%1 |-> +0
 		parse_tree tmp = decimal_literal("0",src,types);
@@ -6144,15 +6149,15 @@
 		else
 			tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
 		src.DeleteIdx<1>(0);
-		force_unary_positive_literal(src,tmp);
+		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
 		};
 	if (lhs_converted && rhs_converted)
 		{
-		const promote_aux old(old_type.base_type_index);
-		const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=lhs.bitcount);
-		const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=rhs.bitcount);
 
 		// handle sign-extension of lhs, rhs
@@ -6198,7 +6203,7 @@
 		tmp.type_code = old_type;
 
 		src.DeleteIdx<1>(0);
-		force_unary_positive_literal(src,tmp);
+		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
 		}
 	return false;
@@ -6207,31 +6212,32 @@
 BOOST_STATIC_ASSERT(1==C99_MULT_SUBTYPE_MOD-C99_MULT_SUBTYPE_DIV);
 BOOST_STATIC_ASSERT(1==C99_MULT_SUBTYPE_MULT-C99_MULT_SUBTYPE_MOD);
 
-static bool _mod_expression_typecheck(parse_tree& src)
+static bool _mod_expression_typecheck(parse_tree& src SIG_CONST_TYPES)
 {
 	assert(C99_MULT_SUBTYPE_MOD==src.subtype && is_C99_mult_operator_expression<'%'>(src));
-	const bool rhs_integerlike = converts_to_integerlike(src.data<2>()->type_code);
-	if (!converts_to_integerlike(src.data<1>()->type_code))
+	const POD_pair<size_t,bool> lhs = default_promotion_is_integerlike(src.data<1>()->type_code ARG_TYPES);
+	const POD_pair<size_t,bool> rhs = default_promotion_is_integerlike(src.data<2>()->type_code ARG_TYPES);
+	if (!lhs.second)
 		{	//! \test default/Error_if_control33.hpp, default/Error_if_control33.h
 			//! \test default/Error_if_control34.hpp, default/Error_if_control34.h
-		simple_error(src,rhs_integerlike ? " has nonintegral LHS (C99 6.5.5p2, C++98 5.6p2)" : " has nonintegral LHS and RHS (C99 6.5.5p2, C++98 5.6p2)");
+		simple_error(src,rhs.second ? " has nonintegral LHS (C99 6.5.5p2, C++98 5.6p2)" : " has nonintegral LHS and RHS (C99 6.5.5p2, C++98 5.6p2)");
 		return false;
 		}
-	else if (!rhs_integerlike)
+	else if (!rhs.second)
 		{	//! \test default/Error_if_control32.hpp, default/Error_if_control32.h
 		simple_error(src," has nonintegral RHS (C99 6.5.5p2, C++98 5.6p2)");
 		return false;
 		};
-	src.type_code.set_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
+	src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 	return true;
 }
 
-static bool _mult_div_expression_typecheck(parse_tree& src)
+static bool _mult_div_expression_typecheck(parse_tree& src SIG_CONST_TYPES)
 {
 	assert(C99_MULT_SUBTYPE_DIV==src.subtype || C99_MULT_SUBTYPE_MULT==src.subtype);
 	assert((C99_MULT_SUBTYPE_DIV==src.subtype) ? is_C99_mult_operator_expression<'/'>(src) : is_C99_mult_operator_expression<'*'>(src));
-	const bool rhs_is_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code);
-	if (!converts_to_arithmeticlike(src.data<1>()->type_code))
+	const bool rhs_is_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code ARG_TYPES);
+	if (!converts_to_arithmeticlike(src.data<1>()->type_code ARG_TYPES))
 		{	//! \test default/Error_if_control36.hpp, default/Error_if_control36.h
 			//! \test default/Error_if_control37.hpp, default/Error_if_control37.h
 			//! \test default/Error_if_control39.hpp, default/Error_if_control39.h
@@ -6245,7 +6251,7 @@
 		simple_error(src," has nonarithmetic RHS (C99 6.5.5p2, C++98 5.6p2)");
 		return false;
 		};
-	src.type_code.set_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
+	src.type_code.set_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES));
 	return true;
 }
 
@@ -6256,11 +6262,11 @@
 	// note that 0*integerlike and so on are invalid, but do optimize to valid (but this is probably worth a separate execution path)
 	if (C99_MULT_SUBTYPE_MOD==src.subtype)
 		{	// require integral type
-		if (!_mod_expression_typecheck(src)) return;
+		if (!_mod_expression_typecheck(src ARG_TYPES)) return;
 		eval_mod_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 		}
 	else{	// require arithmetic type
-		if (!_mult_div_expression_typecheck(src)) return;
+		if (!_mult_div_expression_typecheck(src ARG_TYPES)) return;
 		if (C99_MULT_SUBTYPE_MULT==src.subtype)
 			eval_mult_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 		else
@@ -6275,11 +6281,11 @@
 
 	if (C99_MULT_SUBTYPE_MOD==src.subtype)
 		{	// require integral type
-		if (!_mod_expression_typecheck(src)) return;
+		if (!_mod_expression_typecheck(src ARG_TYPES)) return;
 		eval_mod_expression(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
 		}
 	else{	// require arithmetic type
-		if (!_mult_div_expression_typecheck(src)) return;
+		if (!_mult_div_expression_typecheck(src ARG_TYPES)) return;
 		if (C99_MULT_SUBTYPE_MULT==src.subtype)
 			eval_mult_expression(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
 		else
@@ -6470,18 +6476,16 @@
 	default: FATAL_CODE("hardware/compiler error: invalid linear combination in eval_add_expression",3);
 #endif
 	case 0:	{
-			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index));
-			assert(converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index));
+			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES));
+			assert(converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES));
 			bool is_true = false;
-			if 		(literal_converts_to_bool(*src.data<1>(),is_true
-					) && !is_true)
+			if 		(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 				{	// 0 + __ |-> __
 				src.eval_to_arg<2>(0);
 				src.type_code = old_type;
 				return true;
 				}
-			else if (literal_converts_to_bool(*src.data<2>(),is_true
-					) && !is_true)
+			else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ + 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -6489,15 +6493,13 @@
 				};
 			umaxint res_int;
 			umaxint rhs_int;
-			const promote_aux old(old_type.base_type_index);
-			const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+			const promote_aux old(old_type.base_type_index ARG_TYPES);
+			const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 			assert(old.bitcount>=lhs.bitcount);
-			const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+			const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 			assert(old.bitcount>=rhs.bitcount);
-			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
-				);
-			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
-				);
+			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 			const bool lhs_negative = lhs_converted && target_machine->C_promote_integer(res_int,lhs,old);
 			const bool rhs_negative = rhs_converted && target_machine->C_promote_integer(rhs_int,rhs,old);
 			if (lhs_converted && rhs_converted)
@@ -6569,16 +6571,15 @@
 				tmp.type_code = old_type;
 
 				src.DeleteIdx<1>(0);
-				force_unary_positive_literal(src,tmp);
+				force_unary_positive_literal(src,tmp ARG_TYPES);
 				return true;
 				}
 			break;
 			}
 	case 1:	{
-			assert(converts_to_integerlike(src.data<2>()->type_code.base_type_index));
+			assert(converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES));
 			bool is_true = false;
-			if (literal_converts_to_bool(*src.data<2>(),is_true
-				) && !is_true)
+			if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ + 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -6587,10 +6588,9 @@
 			break;
 			}
 	case 2:	{
-			assert(converts_to_integerlike(src.data<1>()->type_code.base_type_index));
+			assert(converts_to_integerlike(src.data<1>()->type_code.base_type_index ARG_TYPES));
 			bool is_true = false;
-			if (literal_converts_to_bool(*src.data<1>(),is_true
-				) && !is_true)
+			if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 				{	// 0 + __ |-> __
 				src.eval_to_arg<2>(0);
 				src.type_code = old_type;
@@ -6622,11 +6622,10 @@
 	default: FATAL_CODE("hardware/compiler error: invalid linear combination in eval_add_expression",3);
 #endif
 	case 0:	{
-			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index));
-			assert(converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index));
+			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES));
+			assert(converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES));
 			bool is_true = false;
-			if 		(literal_converts_to_bool(*src.data<1>(),is_true
-					) && !is_true)
+			if 		(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 				{	// 0 - __ |-> - __
 				src.DeleteIdx<1>(0);
 				src.core_flag_update();
@@ -6636,8 +6635,7 @@
 				src.type_code = old_type;				
 				return true;
 				}
-			else if (literal_converts_to_bool(*src.data<2>(),is_true
-					) && !is_true)
+			else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ - 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -6645,16 +6643,14 @@
 				}
 			umaxint res_int;
 			umaxint rhs_int;
-			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>()
-				);
-			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
-				);
+			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 			if (lhs_converted && rhs_converted)
 				{	//! \todo deal with signed integer arithmetic
-				const promote_aux old(old_type.base_type_index);
-				const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+				const promote_aux old(old_type.base_type_index ARG_TYPES);
+				const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 				assert(old.bitcount>=lhs.bitcount);
-				const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+				const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 				assert(old.bitcount>=rhs.bitcount);
 
 				// handle sign-extension of lhs, rhs
@@ -6727,16 +6723,15 @@
 				tmp.type_code = old_type;
 
 				src.DeleteIdx<1>(0);
-				force_unary_positive_literal(src,tmp);
+				force_unary_positive_literal(src,tmp ARG_TYPES);
 				return true;
 				}
 			break;
 			}
 	case 1:	{
-			assert(converts_to_integerlike(src.data<2>()->type_code.base_type_index));
+			assert(converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES));
 			bool is_true = false;
-			if (literal_converts_to_bool(*src.data<2>(),is_true
-				) && !is_true)
+			if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ - 0 |-> __
 				src.eval_to_arg<1>(0);
 				src.type_code = old_type;
@@ -6790,8 +6785,8 @@
 	default: FATAL_CODE("hardware/compiler error: invalid linear combination in C_add_expression_easy_syntax_check",3);
 #endif
 	case 0:	{	// cannot test errors from preprocessor
-			const bool rhs_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index);
-			if (!converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index))
+			const bool rhs_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES);
+			if (!converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src,rhs_arithmeticlike ? " has non-arithmetic non-pointer right argument (C99 6.5.6p2; C++98 5.7p1)" : " has non-arithmetic non-pointer arguments (C99 6.5.6p2; C++98 5.7p1)");
 				return;
@@ -6801,14 +6796,14 @@
 				simple_error(src," has non-arithmetic non-pointer left argument (C99 6.5.6p2; C++98 5.7p1)");
 				return;
 				}
-			src.type_code.set_type(arithmetic_reconcile(default_promote_type(src.data<1>()->type_code.base_type_index),default_promote_type(src.data<2>()->type_code.base_type_index)));
+			src.type_code.set_type(arithmetic_reconcile(default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES),default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES));
 			eval_add_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	case 1:	{	// ptr + integer, hopefully
 				// requires floating-point literals to test errors from preprocessor
 			src.type_code = src.data<1>()->type_code;
-			if (!converts_to_integerlike(src.data<2>()->type_code.base_type_index))
+			if (!converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src," adds pointer to non-integer (C99 6.5.6p2; C++98 5.7p1)");
 				return;
@@ -6819,7 +6814,7 @@
 	case 2:	{	// integer + ptr, hopefully
 				// requires floating-point literals to test errors from preprocessor
 			src.type_code = src.data<2>()->type_code;
-			if (!converts_to_integerlike(src.data<1>()->type_code.base_type_index))
+			if (!converts_to_integerlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src," adds pointer to non-integer (C99 6.5.6p2; C++98 5.7p1)");
 				return;
@@ -6833,8 +6828,8 @@
 			return;
 			}
 	case 4:	{	// cannot test errors from preprocessor
-			const bool rhs_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index);
-			if (!converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index))
+			const bool rhs_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES);
+			if (!converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src,rhs_arithmeticlike ? " has non-arithmetic non-pointer right argument (C99 6.5.6p3; C++98 5.7p2)" : " has non-arithmetic non-pointer arguments (C99 6.5.6p3; C++98 5.7p2)");
 				return;
@@ -6844,13 +6839,13 @@
 				simple_error(src," has non-arithmetic non-pointer left argument (C99 6.5.6p3; C++98 5.7p2)");
 				return;
 				}
-			src.type_code.set_type(arithmetic_reconcile(default_promote_type(src.data<1>()->type_code.base_type_index),default_promote_type(src.data<2>()->type_code.base_type_index)));
+			src.type_code.set_type(arithmetic_reconcile(default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES),default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES));
 			eval_sub_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	case 5:	{	// ptr - integer, hopefully; requires floating-point literal to test from preprocessor
 			src.type_code = src.data<1>()->type_code;
-			if (!converts_to_integerlike(src.data<2>()->type_code.base_type_index))
+			if (!converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src," subtracts non-integer from pointer (C99 6.5.6p3; C++98 5.7p2)");
 				return;
@@ -6930,16 +6925,16 @@
 		C_CPP_add_expression_easy_syntax_check(src.c_array<0>()[i],types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
 }
 
-static bool binary_infix_failed_integer_arguments(parse_tree& src, const char* standard)
+static bool binary_infix_failed_integer_arguments(parse_tree& src, const char* standard SIG_CONST_TYPES)
 {
 	assert(NULL!=standard);
 	if (parse_tree::INVALID & src.flags)	// already invalid, don't make noise
-		return !converts_to_integerlike(src.data<1>()->type_code) || !converts_to_integerlike(src.data<2>()->type_code);
+		return !converts_to_integerlike(src.data<1>()->type_code ARG_TYPES) || !converts_to_integerlike(src.data<2>()->type_code ARG_TYPES);
 
 	// hmm... 45-47, 48-50, 51-53, 54-56, 57-59
 	//! \todo need tests for float literal in place of int literal: << >> & ^ |
-	const bool rhs_integerlike = converts_to_integerlike(src.data<2>()->type_code);
-	if (!converts_to_integerlike(src.data<1>()->type_code))
+	const bool rhs_integerlike = converts_to_integerlike(src.data<2>()->type_code ARG_TYPES);
+	if (!converts_to_integerlike(src.data<1>()->type_code ARG_TYPES))
 		{	// tests for string literal in place of integer literal
 			//! \test default/Error_if_control46.hpp, default/Error_if_control46.h
 			//! \test default/Error_if_control47.hpp, default/Error_if_control47.h
@@ -7011,8 +7006,8 @@
 
 static bool eval_shift(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
-	assert(converts_to_integerlike(src.data<1>()->type_code));
-	assert(converts_to_integerlike(src.data<2>()->type_code));
+	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
+	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
 	assert(C99_SHIFT_SUBTYPE_LEFT<=src.subtype && C99_SHIFT_SUBTYPE_RIGHT>=src.subtype);
 	BOOST_STATIC_ASSERT(1==C99_SHIFT_SUBTYPE_RIGHT-C99_SHIFT_SUBTYPE_LEFT);
 	// handle:
@@ -7024,8 +7019,7 @@
 	// error if RHS is literal "out of bounds"
 	const type_spec old_type = src.type_code;
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<2>(),is_true
-		) && !is_true)
+	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 		{
 		if (!is_true)
 			{	// __ << 0 or __ >> 0: lift
@@ -7036,8 +7030,7 @@
 		};
 
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(rhs_int,*src.data<2>()
-		))
+	if (intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(old_type.base_type_index);
 		const bool undefined_behavior = target_machine->C_bit(machine_type)<=rhs_int;
@@ -7046,8 +7039,7 @@
 		if (undefined_behavior)
 			simple_error(src," : RHS is at least as large as bits of LHS; undefined behavior (C99 6.5.7p3/C++98 5.8p1)");
 
-		if (literal_converts_to_bool(*src.data<1>(),is_true
-			))
+		if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES))
 			{
 			if (!is_true)
 				{	// 0 << __ or 0 >> __: zero out (note that we can do this even if we invoked undefined behavior)
@@ -7059,8 +7051,7 @@
 		if (undefined_behavior) return false;
 
 		umaxint res_int;
-		if (intlike_literal_to_VM(res_int,*src.data<1>()
-			))
+		if (intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES))
 			{
 			// note that incoming negative signed integers are not handled by this code path
 			if (C99_SHIFT_SUBTYPE_LEFT==src.subtype)
@@ -7100,9 +7091,9 @@
 {
 	assert(is_C99_shift_expression(src));
 	// C99 6.5.7p2: requires being an integer type
-	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.7p2)")) return;
-	src.type_code.base_type_index = default_promote_type(src.data<1>()->type_code.base_type_index);
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.7p2)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_shift(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
@@ -7110,9 +7101,9 @@
 {
 	assert(is_C99_shift_expression(src));
 	// C++98 5.8p1: requires being an integer or enumeration type
-	if (binary_infix_failed_integer_arguments(src,"(C++98 5.8p1)")) return;
-	src.type_code.base_type_index = default_promote_type(src.data<1>()->type_code.base_type_index);
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C++98 5.8p1)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_shift(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
@@ -7193,10 +7184,8 @@
 	umaxint lhs_int;
 	umaxint rhs_int;
 
-	const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>()
-		);
-	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
-		);
+	const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 	if (lhs_converted && rhs_converted)
 		{
 		const char* result 	= NULL;
@@ -7233,7 +7222,7 @@
 	switch(ptr_case)
 	{
 	case 0:	{	// can't test from preprocessor
-			if (!converts_to_reallike(src.data<1>()->type_code.base_type_index) || !converts_to_reallike(src.data<2>()->type_code.base_type_index))
+			if (!converts_to_reallike(src.data<1>()->type_code.base_type_index ARG_TYPES) || !converts_to_reallike(src.data<2>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src," compares non-real type(s) (C99 6.5.8p2/C++98 5.9p2)");
 				return false;
@@ -7242,7 +7231,7 @@
 			}
 	case 1:	{	//! \todo need floating-point literal to test first half
 				//! \todo figure out how to test second half
-			if (!converts_to_integer(src.data<2>()->type_code) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+			if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
 				{	// oops
 				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
 				return false;
@@ -7251,7 +7240,7 @@
 			}
 	case 2:	{	//! \todo need floating-point literal to test first half
 				//! \todo figure out how to test second half
-			if (!converts_to_integer(src.data<1>()->type_code) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
+			if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
 				{	// oops
 				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
 				return false;
@@ -7381,8 +7370,8 @@
 	assert(C99_EQUALITY_SUBTYPE_EQ<=src.subtype && C99_EQUALITY_SUBTYPE_NEQ>=src.subtype);
 	umaxint lhs_int;
 	umaxint rhs_int;
-	const unsigned int integer_literal_case = 	  converts_to_integer(src.data<1>()->type_code)
-											+	2*converts_to_integer(src.data<2>()->type_code);
+	const unsigned int integer_literal_case = 	  converts_to_integer(src.data<1>()->type_code ARG_TYPES)
+											+	2*converts_to_integer(src.data<2>()->type_code ARG_TYPES);
 	const bool is_equal_op = src.subtype==C99_EQUALITY_SUBTYPE_EQ;
 	bool is_true = false;
 	switch(integer_literal_case)
@@ -7399,8 +7388,7 @@
 			break;
 			}
 	case 1:	{
-			if (0<src.data<2>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<1>(),is_true
-				)) 
+			if (0<src.data<2>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES)) 
 				{
 				if (!is_true)
 					{	
@@ -7421,8 +7409,7 @@
 			break;
 			}
 	case 2:	{
-			if (0<src.data<1>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<2>(),is_true
-				)) 
+			if (0<src.data<1>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES)) 
 				{
 				if (!is_true)
 					{
@@ -7443,15 +7430,13 @@
 			break;
 			}
 	case 3:	{	// integer literal == integer literal
-			const promote_aux lhs(src.data<1>()->type_code.base_type_index);
-			const promote_aux rhs(src.data<2>()->type_code.base_type_index);
-			const promote_aux old(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
+			const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
+			const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
+			const promote_aux old(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
 			assert(old.bitcount>=lhs.bitcount);
 			assert(old.bitcount>=rhs.bitcount);
-			const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>()
-				);
-			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>()
-				);
+			const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES);
+			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 			// general case here in case we try to do with converted/not converted mixed cases
 //			if (lhs_converted) target_machine->C_promote_integer(lhs_int,lhs,old);
 //			if (rhs_converted) target_machine->C_promote_integer(rhs_int,rhs,old);
@@ -7488,7 +7473,7 @@
 			break;
 			}
 	case 1:	{	// need floating-point literal to test from preprocessor
-			if (!converts_to_integer(src.data<2>()->type_code) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+			if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
 				{	// oops
 				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
 				return false;
@@ -7496,7 +7481,7 @@
 			break;
 			}
 	case 2:	{	// need floating-point literal to test from preprocessor
-			if (!converts_to_integer(src.data<1>()->type_code) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
+			if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
 				{	// oops
 				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
 				return false;
@@ -7609,8 +7594,8 @@
 
 static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
-	assert(converts_to_integerlike(src.data<1>()->type_code));
-	assert(converts_to_integerlike(src.data<2>()->type_code));
+	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
+	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
 	// handle following:
 	// __ & 0 |-> 0
 	// 0 & __ |-> 0
@@ -7618,10 +7603,8 @@
 	// unary - gives us problems (result is target-specific, could generate a trap representation)
 	const type_spec old_type = src.type_code;
 	bool is_true = false;
-	if (	(literal_converts_to_bool(*src.data<1>(),is_true
-			) && !is_true)	// 0 & __
-		||	(literal_converts_to_bool(*src.data<2>(),is_true
-			) && !is_true))	// __ & 0
+	if (	(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)	// 0 & __
+		||	(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true))	// __ & 0
 		{
 		if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
 			{
@@ -7640,11 +7623,9 @@
 
 	umaxint lhs_int;
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(lhs_int,*src.data<1>()
-		) && intlike_literal_to_VM(rhs_int,*src.data<2>()
-			))
+	if (intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES) && intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
-		const promote_aux old(old_type.base_type_index);
+		const promote_aux old(old_type.base_type_index ARG_TYPES);
 		umaxint res_int(lhs_int);
 		res_int &= rhs_int;
 
@@ -7685,9 +7666,9 @@
 {
 	assert(is_C99_bitwise_AND_expression(src));
 	// C99 6.5.10p2: requires being an integer type
-	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.10p2)")) return;
-	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.10p2)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_bitwise_AND(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
@@ -7695,9 +7676,9 @@
 {
 	assert(is_CPP_bitwise_AND_expression(src));
 	// C++98 5.11p1: requires being an integer or enumeration type
-	if (binary_infix_failed_integer_arguments(src,"(C++98 5.11p1)")) return;
-	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C++98 5.11p1)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_bitwise_AND(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
@@ -7788,16 +7769,15 @@
 
 static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
-	assert(converts_to_integerlike(src.data<1>()->type_code));
-	assert(converts_to_integerlike(src.data<2>()->type_code));
+	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
+	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
 	// handle following
 	// x ^ x |-> 0 [later, need sensible detection of "equal" expressions first]
 	// 0 ^ __ |-> __
 	// __ ^ 0 |-> __
 	// also handle double-literal case
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true
-		))
+	if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES))
 		{
 		if (!is_true)
 			{	// 0 ^ __
@@ -7806,8 +7786,7 @@
 			return true;
 			}
 		};
-	if (literal_converts_to_bool(*src.data<2>(),is_true
-		))
+	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES))
 		{
 		if (!is_true)
 			{	// __ ^ 0
@@ -7819,12 +7798,10 @@
 
 	umaxint lhs_int;
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(lhs_int,*src.data<1>()
-		) && intlike_literal_to_VM(rhs_int,*src.data<2>()
-		))
+	if (intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES) && intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
 		const type_spec old_type = src.type_code;
-		const promote_aux old(old_type.base_type_index);
+		const promote_aux old(old_type.base_type_index ARG_TYPES);
 		umaxint res_int(lhs_int);
 		res_int ^= rhs_int;
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
@@ -7857,9 +7834,9 @@
 {
 	assert(is_C99_bitwise_XOR_expression(src));
 	// C99 6.5.11p2: requires being an integer type
-	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.11p2)")) return;
-	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.11p2)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_bitwise_XOR(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
@@ -7867,9 +7844,9 @@
 {
 	assert(is_CPP_bitwise_XOR_expression(src));
 	// C++98 5.12p1: requires being an integer or enumeration type
-	if (binary_infix_failed_integer_arguments(src,"(C++98 5.12p1)")) return;
-	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C++98 5.12p1)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_bitwise_XOR(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
@@ -7960,16 +7937,15 @@
 
 static bool eval_bitwise_OR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
-	assert(converts_to_integerlike(src.data<1>()->type_code));
-	assert(converts_to_integerlike(src.data<2>()->type_code));
+	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
+	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
 	// handle following:
 	// __ | 0 |-> __
 	// 0 | __ |-> __
 	// int-literal | int-literal |-> int-literal *if* both fit
 	// unary - gives us problems (result is target-specific, could generate a trap representation)
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true
-		))
+	if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES))
 		{
 		if (!is_true)
 			{	// 0 | __
@@ -7978,8 +7954,7 @@
 			return true;
 			}
 		};
-	if (literal_converts_to_bool(*src.data<2>(),is_true
-		))
+	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES))
 		{
 		if (!is_true)
 			{	// __ | 0
@@ -7991,9 +7966,7 @@
 
 	umaxint lhs_int;
 	umaxint rhs_int;
-	if (intlike_literal_to_VM(lhs_int,*src.data<1>()
-		) && intlike_literal_to_VM(rhs_int,*src.data<2>()
-		))
+	if (intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES) && intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
 		const type_spec old_type = src.type_code;
 		umaxint res_int(lhs_int);
@@ -8033,9 +8006,9 @@
 {
 	assert(is_C99_bitwise_OR_expression(src));
 	// C99 6.5.12p2: requires being an integer type
-	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.12p2)")) return;
-	src.type_code.base_type_index = arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index);
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.12p2)" ARG_TYPES)) return;
+	src.type_code.base_type_index = arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_bitwise_OR(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
@@ -8043,9 +8016,9 @@
 {
 	assert(is_CPP_bitwise_OR_expression(src));
 	// C++98 5.13p1: requires being an integer or enumeration type
-	if (binary_infix_failed_integer_arguments(src,"(C++98 5.13p1)")) return;
-	src.type_code.base_type_index = arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index);
-	assert(converts_to_integerlike(src.type_code.base_type_index));
+	if (binary_infix_failed_integer_arguments(src,"(C++98 5.13p1)" ARG_TYPES)) return;
+	src.type_code.base_type_index = arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
 	if (eval_bitwise_OR(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
@@ -8084,13 +8057,13 @@
 		CPP_bitwise_OR_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
-static bool binary_infix_failed_boolean_arguments(parse_tree& src, const char* standard)
+static bool binary_infix_failed_boolean_arguments(parse_tree& src, const char* standard SIG_CONST_TYPES)
 {	//! \todo so the error message isn't technically right...convertible to bool in C++ is morally equivalent to scalar in C
 	// cannot test this within preprocessor
 	assert(NULL!=standard);
 
-	const bool rhs_converts_to_bool =  converts_to_bool(src.data<2>()->type_code);
-	if (!converts_to_bool(src.data<1>()->type_code))
+	const bool rhs_converts_to_bool =  converts_to_bool(src.data<2>()->type_code ARG_TYPES);
+	if (!converts_to_bool(src.data<1>()->type_code ARG_TYPES))
 		{
 		simple_error(src,rhs_converts_to_bool ? " has nonscalar LHS " : " has nonscalar LHS and RHS ");
 		return true;
@@ -8165,8 +8138,7 @@
 	// (__ && 1) && __ |-> __ && 1
 
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true
-		))
+	if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES))
 		{	// one of 0 && __ or 1 && __
 		if (!is_true)
 			{	// 0 && __
@@ -8180,8 +8152,7 @@
 			force_decimal_literal(src,"0",types);
 			return true;
 			}
-		else if (literal_converts_to_bool(*src.data<2>(),is_true
-			))
+		else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES))
 			{	// 1 && 1 or 1 && 0
 			force_decimal_literal(src,is_true ? "1" : "0",types);
 			return true;
@@ -8201,7 +8172,7 @@
 static void C_logical_AND_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_logical_AND_expression(src));
-	if (binary_infix_failed_boolean_arguments(src,"(C99 6.5.13p2)")) return;
+	if (binary_infix_failed_boolean_arguments(src,"(C99 6.5.13p2)" ARG_TYPES)) return;
 
 	if (eval_logical_AND(src,types,C99_literal_converts_to_bool)) return;
 }
@@ -8209,7 +8180,7 @@
 static void CPP_logical_AND_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_CPP_logical_AND_expression(src));
-	if (binary_infix_failed_boolean_arguments(src,"(C++98 5.14p1)")) return;
+	if (binary_infix_failed_boolean_arguments(src,"(C++98 5.14p1)" ARG_TYPES)) return;
 
 	if (eval_logical_AND(src,types,CPP_literal_converts_to_bool)) return;
 }
@@ -8310,8 +8281,7 @@
 	// (__ || 1) || __ |-> __ || 1
 
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.data<1>(),is_true
-		))
+	if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES))
 		{	// one of 0 || __ or 1 || __
 		if (is_true)
 			{	// 1 || __
@@ -8325,8 +8295,7 @@
 			force_decimal_literal(src,"1",types);
 			return true;
 			}
-		else if (literal_converts_to_bool(*src.data<2>(),is_true
-			))
+		else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES))
 			{	// 0 || 1 or 0 || 0
 			force_decimal_literal(src,is_true ? "1" : "0",types);
 			return true;
@@ -8346,7 +8315,7 @@
 static void C_logical_OR_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_logical_OR_expression(src));
-	if (binary_infix_failed_boolean_arguments(src,"(C99 6.5.14p2)")) return;
+	if (binary_infix_failed_boolean_arguments(src,"(C99 6.5.14p2)" ARG_TYPES)) return;
 
 	if (eval_logical_OR(src,types,C99_literal_converts_to_bool)) return;
 }
@@ -8354,7 +8323,7 @@
 static void CPP_logical_OR_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_CPP_logical_OR_expression(src));
-	if (binary_infix_failed_boolean_arguments(src,"(C++98 5.15p1)")) return;
+	if (binary_infix_failed_boolean_arguments(src,"(C++98 5.15p1)" ARG_TYPES)) return;
 
 	if (eval_logical_OR(src,types,CPP_literal_converts_to_bool)) return;
 }
@@ -8447,12 +8416,10 @@
 	return false;
 }
 
-static bool eval_conditional_op(parse_tree& src, literal_converts_to_bool_func& literal_converts_to_bool
-	)
+static bool eval_conditional_op(parse_tree& src, literal_converts_to_bool_func& literal_converts_to_bool SIG_CONST_TYPES)
 {
 	bool is_true = false;
-	if (literal_converts_to_bool(*src.c_array<1>(),is_true
-		))
+	if (literal_converts_to_bool(*src.c_array<1>(),is_true ARG_TYPES))
 		{
 		const bool was_invalid = src.flags & parse_tree::INVALID;
 		const type_spec old_type = src.type_code;
@@ -8489,8 +8456,7 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<2>(),C99_intlike_literal_to_VM
-				))
+			else if (is_null_pointer_constant(*src.data<2>(),C99_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -8509,8 +8475,7 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<0>(),C99_intlike_literal_to_VM
-				))
+			else if (is_null_pointer_constant(*src.data<0>(),C99_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -8537,7 +8502,7 @@
 			//! \todo test cases at preprocessor level
 			else if (0==src.data<0>()->type_code.pointer_power_after_array_decay() && is_innate_definite_type(src.data<0>()->type_code.base_type_index) && is_innate_definite_type(src.data<2>()->type_code.base_type_index))
 				// standard arithmetic conversions
-				src.type_code.set_type(arithmetic_reconcile(src.data<0>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
+				src.type_code.set_type(arithmetic_reconcile(src.data<0>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES));
 			//! \todo --do-what-i-mean can handle elementary integer types with same indirection as well
 			else if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index || C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
 				{
@@ -8553,15 +8518,14 @@
 	}
 
 	// 2) prefix arg type convertible to _Bool (control whether expression is evaluatable at all)
-	if (!converts_to_bool(src.data<1>()->type_code))
+	if (!converts_to_bool(src.data<1>()->type_code ARG_TYPES))
 		{	// can't test this from preprocessor
 		simple_error(src," has nonscalar control expression");
 		return;
 		}
 	// 3) RAM conservation: if we have a suitable literal Do It Now
 	// \todo disable this at O0?
-	if (eval_conditional_op(src,C99_literal_converts_to_bool
-		)) return;
+	if (eval_conditional_op(src,C99_literal_converts_to_bool ARG_TYPES)) return;
 }
 
 static void CPP_conditional_op_easy_syntax_check(parse_tree& src,const type_system& types)
@@ -8582,8 +8546,7 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<2>(),CPP_intlike_literal_to_VM
-				))
+			else if (is_null_pointer_constant(*src.data<2>(),CPP_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -8602,8 +8565,7 @@
 				src.type_code.set_type(C_TYPE::NOT_VOID);
 				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power_after_array_decay());
 				}
-			else if (is_null_pointer_constant(*src.data<0>(),CPP_intlike_literal_to_VM
-				))
+			else if (is_null_pointer_constant(*src.data<0>(),CPP_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
@@ -8629,7 +8591,7 @@
 				}
 			else if (0==src.data<0>()->type_code.pointer_power_after_array_decay() && is_innate_definite_type(src.data<0>()->type_code.base_type_index) && is_innate_definite_type(src.data<2>()->type_code.base_type_index))
 				// standard arithmetic conversions
-				src.type_code.set_type(arithmetic_reconcile(src.data<0>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index));
+				src.type_code.set_type(arithmetic_reconcile(src.data<0>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES));
 			//! \todo --do-what-i-mean can handle elementary integer types with same indirection as well
 			else if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index || C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
 				{
@@ -8645,15 +8607,14 @@
 	}
 
 	// 2) prefix arg type convertible to bool (control whether expression is evaluatable at all)
-	if (!converts_to_bool(src.data<1>()->type_code))
+	if (!converts_to_bool(src.data<1>()->type_code ARG_TYPES))
 		{	// can't test this from preprocessor
 		simple_error(src," has control expression unconvertible to bool");
 		return;
 		}
 	// 3) RAM conservation: if we have a suitable literal Do It Now
 	// \todo disable this at O0?
-	if (eval_conditional_op(src,CPP_literal_converts_to_bool
-		)) return;
+	if (eval_conditional_op(src,CPP_literal_converts_to_bool ARG_TYPES)) return;
 }
 
 static void locate_C99_conditional_op(parse_tree& src, size_t& i, const type_system& types)
@@ -9015,9 +8976,8 @@
 		if (UINT_MAX>str_index)
 			{
 			umaxint tmp; 
-			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index)
-				)) return false;
-			const size_t promoted_type = default_promote_type(src.type_code.base_type_index);
+			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index) ARG_TYPES)) return false;
+			const size_t promoted_type = default_promote_type(src.type_code.base_type_index ARG_TYPES);
 			const virtual_machine::std_int_enum machine_type = (virtual_machine::std_int_enum)((promoted_type-C_TYPE::INT)/2+virtual_machine::std_int_int);
 			eval_string_literal_deref(src,types,src.data(str_index)->index_tokens[0].token,tmp,tmp.test(target_machine->C_bit(machine_type)-1),C_TESTFLAG_CHAR_LITERAL==src.data(1-str_index)->index_tokens[0].flags);
 			return true;
@@ -9290,8 +9250,7 @@
 	if (is_C99_conditional_operator_expression(src))
 		{	// prefix operator is boolean
 		EvalParseTree(*src.c_array<1>(),types);
-		if (eval_conditional_op(src,literal_converts_to_bool
-			)) return true;
+		if (eval_conditional_op(src,literal_converts_to_bool ARG_TYPES)) return true;
 		}
 	return false;
 }
@@ -9407,17 +9366,15 @@
 			{
 			umaxint res_int;
 			umaxint rhs_int;
-			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data<1>()
-				);
-			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data<2>()
-				);
+			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 			if (lhs_converted && rhs_converted)
 				{	//! \todo deal with signed integer arithmetic
-				const promote_aux old(old_type.base_type_index);
+				const promote_aux old(old_type.base_type_index ARG_TYPES);
 				assert(old.is_signed);
-				const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+				const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 				assert(old.bitcount>=lhs.bitcount);
-				const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+				const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 				assert(old.bitcount>=rhs.bitcount);
 
 				// handle sign-extension of lhs, rhs
@@ -9477,17 +9434,15 @@
 			{
 			umaxint res_int;
 			umaxint rhs_int;
-			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data<1>()
-				);
-			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data<2>()
-				);
+			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 			if (lhs_converted && rhs_converted)
 				{	//! \todo deal with signed integer arithmetic
-				const promote_aux old(old_type.base_type_index);
+				const promote_aux old(old_type.base_type_index ARG_TYPES);
 				assert(old.is_signed);
-				const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+				const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 				assert(old.bitcount>=lhs.bitcount);
-				const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+				const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
 				assert(old.bitcount>=rhs.bitcount);
 
 				// handle sign-extension of lhs, rhs



From zaimoni at mail.berlios.de  Thu Mar 25 04:35:06 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 25 Mar 2010 04:35:06 +0100
Subject: [Zcplusplus-commits] r356 - in trunk/tests: zcc/staticassert.C1X
	zcc.in/staticassert.C1X
Message-ID: <201003250335.o2P3Z6Wt015405@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-25 04:35:02 +0100 (Thu, 25 Mar 2010)
New Revision: 356

Modified:
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
Log:
static assertion tests for operator ~

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-03-24 19:16:13 UTC (rev 355)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-03-25 03:35:02 UTC (rev 356)
@@ -1,6 +1,8 @@
 // staticassert.C1X\Pass_autosuccess.h
 // (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
+#include <limits.h>
+
 _Static_Assert(1,"automatic success has failed");
 
 // check unary +
@@ -14,3 +16,15 @@
 // check unary !
 _Static_Assert(!0,"automatic success has failed");
 
+// check unary ~ (unsigned only, signed is target-specific testing)
+_Static_Assert(~0U,"automatic success has failed");
+_Static_Assert(~0UL,"automatic success has failed");
+_Static_Assert(~0ULL,"automatic success has failed");
+_Static_Assert(~1U,"automatic success has failed");
+_Static_Assert(~1UL,"automatic success has failed");
+_Static_Assert(~1ULL,"automatic success has failed");
+_Static_Assert(!~UINT_MAX,"automatic success has failed");
+_Static_Assert(!~ULONG_MAX,"automatic success has failed");
+_Static_Assert(!~ULLONG_MAX,"automatic success has failed");
+
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-03-24 19:16:13 UTC (rev 355)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-03-25 03:35:02 UTC (rev 356)
@@ -1,6 +1,8 @@
 // staticassert.C1X\Pass_autosuccess.hpp
 // (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
+#include <limits.h>
+
 static_assert(1,"automatic success has failed");
 
 // check unary +
@@ -14,3 +16,15 @@
 // check unary !
 static_assert(!0,"automatic success has failed");
 
+// check unary ~ (unsigned only, signed is target-specific testing)
+static_assert(~0U,"automatic success has failed");
+static_assert(~0UL,"automatic success has failed");
+static_assert(~0ULL,"automatic success has failed");
+static_assert(~1U,"automatic success has failed");
+static_assert(~1UL,"automatic success has failed");
+static_assert(~1ULL,"automatic success has failed");
+static_assert(!~UINT_MAX,"automatic success has failed");
+static_assert(!~ULONG_MAX,"automatic success has failed");
+static_assert(!~ULLONG_MAX,"automatic success has failed");
+
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-03-24 19:16:13 UTC (rev 355)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-03-25 03:35:02 UTC (rev 356)
@@ -2,6 +2,8 @@
 OBJECTLIKE_MACRO STATIC_ASSERT _Static_Assert static_assert
 // (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
+#include <limits.h>
+
 STATIC_ASSERT(1,"automatic success has failed");
 
 // check unary +
@@ -15,3 +17,15 @@
 // check unary !
 STATIC_ASSERT(!0,"automatic success has failed");
 
+// check unary ~ (unsigned only, signed is target-specific testing)
+STATIC_ASSERT(~0U,"automatic success has failed");
+STATIC_ASSERT(~0UL,"automatic success has failed");
+STATIC_ASSERT(~0ULL,"automatic success has failed");
+STATIC_ASSERT(~1U,"automatic success has failed");
+STATIC_ASSERT(~1UL,"automatic success has failed");
+STATIC_ASSERT(~1ULL,"automatic success has failed");
+STATIC_ASSERT(!~UINT_MAX,"automatic success has failed");
+STATIC_ASSERT(!~ULONG_MAX,"automatic success has failed");
+STATIC_ASSERT(!~ULLONG_MAX,"automatic success has failed");
+
+



From zaimoni at mail.berlios.de  Fri Mar 26 04:04:55 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 26 Mar 2010 04:04:55 +0100
Subject: [Zcplusplus-commits] r357 - trunk
Message-ID: <201003260304.o2Q34tup004219@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-26 04:04:50 +0100 (Fri, 26 Mar 2010)
New Revision: 357

Modified:
   trunk/type_system.cpp
   trunk/type_system.hpp
Log:
be able to set underlying type for an enumeration

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2010-03-25 03:35:02 UTC (rev 356)
+++ trunk/type_system.cpp	2010-03-26 03:04:50 UTC (rev 357)
@@ -838,7 +838,7 @@
 	return tmp.third.first.third;
 }
 
-const enum_def* type_system::get_enum_def(type_index i)  const
+enum_def* type_system::_get_enum_def(type_index i) const
 {
 	if (core_types_size>=i) return NULL;
 	i -= core_types_size;
@@ -849,6 +849,14 @@
 	return tmp.third.first.fourth;
 }
 
+void type_system::set_enum_underlying_type(type_index i,size_t new_type)
+{
+	assert(UCHAR_MAX>=new_type);
+	enum_def* const tmp = _get_enum_def(i);
+	assert(tmp);
+	tmp->represent_as = new_type;
+}
+
 void type_system::upgrade_decl_to_def(type_index i,C_union_struct_def*& src)
 {	// cf. get_structdecl
 	assert(src);

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2010-03-25 03:35:02 UTC (rev 356)
+++ trunk/type_system.hpp	2010-03-26 03:04:50 UTC (rev 357)
@@ -120,7 +120,8 @@
 	const function_type* get_functype(type_index i) const;
 	const union_struct_decl* get_structdecl(type_index i) const;
 	const C_union_struct_def* get_C_structdef(type_index i) const;
-	const enum_def* get_enum_def(type_index i) const;
+	const enum_def* get_enum_def(type_index i) const {return _get_enum_def(i);};
+	void set_enum_underlying_type(type_index i,size_t new_type);
 	void upgrade_decl_to_def(type_index i,C_union_struct_def*& src);
 #/*cut-cpp*/
 private:
@@ -131,7 +132,8 @@
 	type_index _get_id_enum_CPP(const char* x) const;
 	type_index _get_id_struct_class(const char* x) const;
 	type_index _get_id_struct_class_CPP(const char* x) const;
-
+	enum_def* _get_enum_def(type_index i) const;
+	
 #/*cut-cpp*/
 	const char* _name(type_index id) const;
 #/*cut-cpp*/



From zaimoni at mail.berlios.de  Fri Mar 26 04:05:45 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 26 Mar 2010 04:05:45 +0100
Subject: [Zcplusplus-commits] r358 - in trunk: . tests/zcc/staticassert.C1X
	tests/zcc.in/staticassert.C1X
Message-ID: <201003260305.o2Q35jWU004344@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-26 04:05:36 +0100 (Fri, 26 Mar 2010)
New Revision: 358

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
Log:
make % handle enumerators

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-26 03:04:50 UTC (rev 357)
+++ trunk/CSupport.cpp	2010-03-26 03:05:36 UTC (rev 358)
@@ -860,7 +860,7 @@
 	if (0==type_code.pointer_power_after_array_decay())	// pointers do not have a standard conversion to integers
 		{
 		tmp.first = default_promote_type(type_code.base_type_index ARG_TYPES);
-		tmp.second = (C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>=type_code.base_type_index);
+		tmp.second = (C_TYPE::BOOL<=tmp.first && C_TYPE::INTEGERLIKE>=tmp.first);
 		}
 	return tmp;
 }
@@ -4383,7 +4383,7 @@
  *         pointer constant
  */
 static int is_null_pointer_constant(const parse_tree& src,intlike_literal_to_VM_func& intlike_literal_to_VM SIG_CONST_TYPES)
-{	//! \bug doesn't recognize enumerators with value zero
+{
 	if (!converts_to_integerlike(src.type_code ARG_TYPES)) return 0;
 	umaxint tmp;
 	if (intlike_literal_to_VM(tmp,src ARG_TYPES)) return tmp==0;
@@ -6367,7 +6367,7 @@
 		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
 		inspect_potential_paren_primary_expression(tmp_c_array[0]);
 		inspect_potential_paren_primary_expression(tmp_c_array[2]);
-		if (	(PARSE_MULT_EXPRESSION & tmp_c_array[0].flags)
+		if ((PARSE_MULT_EXPRESSION & tmp_c_array[0].flags)
 			&&	(PARSE_PM_EXPRESSION & tmp_c_array[2].flags))
 			{
 			assemble_binary_infix_arguments(src,i,PARSE_STRICT_MULT_EXPRESSION);	// tmp_c_array goes invalid here
@@ -6735,8 +6735,8 @@
 static bool _mod_expression_typecheck(parse_tree& src SIG_CONST_TYPES)
 {
 	assert(C99_MULT_SUBTYPE_MOD==src.subtype && is_C99_mult_operator_expression<'%'>(src));
-	const POD_pair<size_t,bool> lhs = default_promotion_is_integerlike(src.data<1>()->type_code ARG_TYPES);
-	const POD_pair<size_t,bool> rhs = default_promotion_is_integerlike(src.data<2>()->type_code ARG_TYPES);
+	POD_pair<size_t,bool> lhs = default_promotion_is_integerlike(src.data<1>()->type_code ARG_TYPES);
+	POD_pair<size_t,bool> rhs = default_promotion_is_integerlike(src.data<2>()->type_code ARG_TYPES);
 	if (!lhs.second)
 		{	//! \test default/Error_if_control33.hpp, default/Error_if_control33.h
 			//! \test default/Error_if_control34.hpp, default/Error_if_control34.h
@@ -6748,6 +6748,20 @@
 		simple_error(src," has nonintegral RHS (C99 6.5.5p2, C++98 5.6p2)");
 		return false;
 		};
+#/*cut-cpp*/
+	if (is_noticed_enumerator(*src.data<1>(),types))
+		{
+		if (!enumerator_to_integer_representation(*src.c_array<1>(),types)) return false;
+		lhs = default_promotion_is_integerlike(src.data<1>()->type_code,types);
+		assert(lhs.second);
+		}
+	if (is_noticed_enumerator(*src.data<2>(),types)) 
+		{
+		if (!enumerator_to_integer_representation(*src.c_array<2>(),types)) return false;
+		rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
+		assert(rhs.second);
+		}
+#/*cut-cpp*/
 	src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 	return true;
 }
@@ -10602,6 +10616,10 @@
 			// XXX would be handy to keep the tmp around, consider as time optimization XXX
 			}
 		}
+	size_t i = x.size<0>();
+	while(0<i) notice_enumerator_CPP(x.c_array<0>()[--i],types,active_namespace);
+	assert(x.empty<1>());	// expand these into loops if needed
+	assert(x.empty<2>());
 }
 
 static void C99_CPP_handle_static_assertion(parse_tree& src,type_system& types,PP_auxfunc& langinfo,const size_t i,const char* const err,const char* const active_namespace)
@@ -10904,8 +10922,8 @@
 	unsigned_var_int latest_value(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 	unsigned_var_int prior_value(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 	unsigned char current_enumerator_type = C_TYPE::INT;
-//	bool cpp_using_negative = false;
-//	bool cpp_using_above_LLONG_MAX = false;
+	unsigned char base_enum_type = C_TYPE::INT;
+	bool cpp_using_negative = false;
 	i = 0;
 	while(src.size<0>()>i)
 		{	// require identifier that is neither keyword nor a primitive type
@@ -10952,6 +10970,7 @@
 					if (bool_options[boolopt::warnings_are_errors])
 						zcc_errors.inc_error();
 					}
+				}
 			else{	// C
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
@@ -11135,9 +11154,43 @@
 			types.set_enumerator_def_CPP(src.data<0>()[origin-2].index_tokens[0].token.first, active_namespace,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 		else
 			types.set_enumerator_def(src.data<0>()[origin-2].index_tokens[0].token.first,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+		if (allow_empty && !cpp_using_negative)
+			{
+			const promote_aux test(current_enumerator_type,types);
+			if (test.is_signed && latest_value.test(test.bitcount-1))
+				{
+				cpp_using_negative = true;
+				switch(base_enum_type)
+				{
+				case C_TYPE::INT:
+				case C_TYPE::LONG:
+				case C_TYPE::LLONG:
+					break;	// these three are already signed, no representation change incurred
+				case C_TYPE::UINT:
+					if (target_machine->C_sizeof_int()<target_machine->C_sizeof_long())
+						{
+						base_enum_type = C_TYPE::LONG;
+						break;
+						}
+				case C_TYPE::ULONG:
+					if (target_machine->C_sizeof_long()<target_machine->C_sizeof_long_long())
+						{
+						base_enum_type = C_TYPE::LLONG;
+						break;
+						}
+				default:	//! \bug needs test case
+					message_header(src.data<0>()[origin-2].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("enumeration requires both negative values and values above INTMAX_MAX, underlying type doesn't exist (C++0X 7.2p6)");
+					zcc_errors.inc_error();
+					return false;
+				}
+				}
+			}
 		}
 		}
 	// now ok to crunch underlying type/machine representation
+	types.set_enum_underlying_type(enum_type_index,allow_empty ? base_enum_type : C_TYPE::INT);
 	return true;
 }
 

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-26 03:04:50 UTC (rev 357)
+++ trunk/CSupport_pp.cpp	2010-03-26 03:05:36 UTC (rev 358)
@@ -790,7 +790,7 @@
 	if (0==type_code.pointer_power_after_array_decay())	// pointers do not have a standard conversion to integers
 		{
 		tmp.first = default_promote_type(type_code.base_type_index ARG_TYPES);
-		tmp.second = (C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>=type_code.base_type_index);
+		tmp.second = (C_TYPE::BOOL<=tmp.first && C_TYPE::INTEGERLIKE>=tmp.first);
 		}
 	return tmp;
 }
@@ -3992,7 +3992,7 @@
  *         pointer constant
  */
 static int is_null_pointer_constant(const parse_tree& src,intlike_literal_to_VM_func& intlike_literal_to_VM SIG_CONST_TYPES)
-{	//! \bug doesn't recognize enumerators with value zero
+{
 	if (!converts_to_integerlike(src.type_code ARG_TYPES)) return 0;
 	umaxint tmp;
 	if (intlike_literal_to_VM(tmp,src ARG_TYPES)) return tmp==0;
@@ -5847,7 +5847,7 @@
 		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
 		inspect_potential_paren_primary_expression(tmp_c_array[0]);
 		inspect_potential_paren_primary_expression(tmp_c_array[2]);
-		if (	(PARSE_MULT_EXPRESSION & tmp_c_array[0].flags)
+		if ((PARSE_MULT_EXPRESSION & tmp_c_array[0].flags)
 			&&	(PARSE_PM_EXPRESSION & tmp_c_array[2].flags))
 			{
 			assemble_binary_infix_arguments(src,i,PARSE_STRICT_MULT_EXPRESSION);	// tmp_c_array goes invalid here
@@ -6215,8 +6215,8 @@
 static bool _mod_expression_typecheck(parse_tree& src SIG_CONST_TYPES)
 {
 	assert(C99_MULT_SUBTYPE_MOD==src.subtype && is_C99_mult_operator_expression<'%'>(src));
-	const POD_pair<size_t,bool> lhs = default_promotion_is_integerlike(src.data<1>()->type_code ARG_TYPES);
-	const POD_pair<size_t,bool> rhs = default_promotion_is_integerlike(src.data<2>()->type_code ARG_TYPES);
+	POD_pair<size_t,bool> lhs = default_promotion_is_integerlike(src.data<1>()->type_code ARG_TYPES);
+	POD_pair<size_t,bool> rhs = default_promotion_is_integerlike(src.data<2>()->type_code ARG_TYPES);
 	if (!lhs.second)
 		{	//! \test default/Error_if_control33.hpp, default/Error_if_control33.h
 			//! \test default/Error_if_control34.hpp, default/Error_if_control34.h

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-03-26 03:04:50 UTC (rev 357)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-03-26 03:05:36 UTC (rev 358)
@@ -27,4 +27,9 @@
 _Static_Assert(!~ULONG_MAX,"automatic success has failed");
 _Static_Assert(!~ULLONG_MAX,"automatic success has failed");
 
+// check %
+_Static_Assert(1%2,"automatic success has failed");
+_Static_Assert(!(0%2),"automatic success has failed");
+_Static_Assert(!(1%1),"automatic success has failed");
+_Static_Assert(!(0%1),"automatic success has failed");
 

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-03-26 03:04:50 UTC (rev 357)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-03-26 03:05:36 UTC (rev 358)
@@ -27,4 +27,9 @@
 static_assert(!~ULONG_MAX,"automatic success has failed");
 static_assert(!~ULLONG_MAX,"automatic success has failed");
 
+// check %
+static_assert(1%2,"automatic success has failed");
+static_assert(!(0%2),"automatic success has failed");
+static_assert(!(1%1),"automatic success has failed");
+static_assert(!(0%1),"automatic success has failed");
 

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-03-26 03:04:50 UTC (rev 357)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-03-26 03:05:36 UTC (rev 358)
@@ -4,7 +4,8 @@
 enum test {
 	neg_one = -1,
 	zero,
-	one
+	one,
+	two
 }
 
 _Static_Assert(neg_one,"automatic success has failed");
@@ -20,3 +21,10 @@
 
 // check unary !
 _Static_Assert(!zero,"automatic success has failed");
+
+// check %
+_Static_Assert(one%two,"automatic success has failed");
+_Static_Assert(!(zero%two),"automatic success has failed");
+_Static_Assert(!(one%one),"automatic success has failed");
+_Static_Assert(!(zero%one),"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-03-26 03:04:50 UTC (rev 357)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-03-26 03:05:36 UTC (rev 358)
@@ -4,7 +4,8 @@
 enum test {
 	neg_one = -1,
 	zero,
-	one
+	one,
+	two
 }
 
 static_assert(neg_one,"automatic success has failed");
@@ -20,3 +21,10 @@
 
 // check unary !
 static_assert(!zero,"automatic success has failed");
+
+// check %
+static_assert(one%two,"automatic success has failed");
+static_assert(!(zero%two),"automatic success has failed");
+static_assert(!(one%one),"automatic success has failed");
+static_assert(!(zero%one),"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-03-26 03:04:50 UTC (rev 357)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-03-26 03:05:36 UTC (rev 358)
@@ -28,4 +28,9 @@
 STATIC_ASSERT(!~ULONG_MAX,"automatic success has failed");
 STATIC_ASSERT(!~ULLONG_MAX,"automatic success has failed");
 
+// check %
+STATIC_ASSERT(1%2,"automatic success has failed");
+STATIC_ASSERT(!(0%2),"automatic success has failed");
+STATIC_ASSERT(!(1%1),"automatic success has failed");
+STATIC_ASSERT(!(0%1),"automatic success has failed");
 

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-03-26 03:04:50 UTC (rev 357)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-03-26 03:05:36 UTC (rev 358)
@@ -5,7 +5,8 @@
 enum test {
 	neg_one = -1,
 	zero,
-	one
+	one,
+	two
 }
 
 STATIC_ASSERT(neg_one,"automatic success has failed");
@@ -21,3 +22,10 @@
 
 // check unary !
 STATIC_ASSERT(!zero,"automatic success has failed");
+
+// check %
+STATIC_ASSERT(one%two,"automatic success has failed");
+STATIC_ASSERT(!(zero%two),"automatic success has failed");
+STATIC_ASSERT(!(one%one),"automatic success has failed");
+STATIC_ASSERT(!(zero%one),"automatic success has failed");
+



From zaimoni at mail.berlios.de  Fri Mar 26 08:04:35 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 26 Mar 2010 08:04:35 +0100
Subject: [Zcplusplus-commits] r359 - trunk
Message-ID: <201003260704.o2Q74ZqM012235@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-26 08:04:31 +0100 (Fri, 26 Mar 2010)
New Revision: 359

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
minor optimization

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-26 03:05:36 UTC (rev 358)
+++ trunk/CSupport.cpp	2010-03-26 07:04:31 UTC (rev 359)
@@ -865,6 +865,17 @@
 	return tmp;
 }
 
+static POD_pair<size_t,bool> default_promotion_is_arithmeticlike(const type_spec& type_code SIG_CONST_TYPES)
+{	// uses NRVO
+	POD_pair<size_t,bool> tmp = {0,false};
+	if (0==type_code.pointer_power_after_array_decay())	// pointers do not have a standard conversion to integers
+		{
+		tmp.first = default_promote_type(type_code.base_type_index ARG_TYPES);
+		tmp.second = (C_TYPE::BOOL<=tmp.first && C_TYPE::LDOUBLE__COMPLEX>=tmp.first);
+		}
+	return tmp;
+}
+
 // auxilliary structure to aggregate useful information for type promotions
 // this will malfunction badly for anything other than an integer type
 class promote_aux : public virtual_machine::promotion_info
@@ -6770,22 +6781,39 @@
 {
 	assert(C99_MULT_SUBTYPE_DIV==src.subtype || C99_MULT_SUBTYPE_MULT==src.subtype);
 	assert((C99_MULT_SUBTYPE_DIV==src.subtype) ? is_C99_mult_operator_expression<'/'>(src) : is_C99_mult_operator_expression<'*'>(src));
-	const bool rhs_is_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code ARG_TYPES);
-	if (!converts_to_arithmeticlike(src.data<1>()->type_code ARG_TYPES))
+	POD_pair<size_t,bool> lhs = default_promotion_is_arithmeticlike(src.data<1>()->type_code ARG_TYPES);
+	POD_pair<size_t,bool> rhs = default_promotion_is_arithmeticlike(src.data<2>()->type_code ARG_TYPES);
+	if (!lhs.second)
 		{	//! \test default/Error_if_control36.hpp, default/Error_if_control36.h
 			//! \test default/Error_if_control37.hpp, default/Error_if_control37.h
 			//! \test default/Error_if_control39.hpp, default/Error_if_control39.h
 			//! \test default/Error_if_control40.hpp, default/Error_if_control40.h
-		simple_error(src,rhs_is_arithmeticlike ? " has nonarithmetic LHS (C99 6.5.5p2, C++98 5.6p2)" : " has nonarithmetic LHS and RHS (C99 6.5.5p2, C++98 5.6p2)");
+		simple_error(src,rhs.second ? " has nonarithmetic LHS (C99 6.5.5p2, C++98 5.6p2)" : " has nonarithmetic LHS and RHS (C99 6.5.5p2, C++98 5.6p2)");
 		return false;
 		}
-	else if (!rhs_is_arithmeticlike)
+	else if (!rhs.second)
 		{	//! \test default/Error_if_control35.hpp, default/Error_if_control35.h
 			//! \test default/Error_if_control38.hpp, default/Error_if_control38.h
 		simple_error(src," has nonarithmetic RHS (C99 6.5.5p2, C++98 5.6p2)");
 		return false;
 		};
-	src.type_code.set_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES));
+
+#/*cut-cpp*/
+	// arithmeticlike subsumes integerlike so this is fine
+	if (is_noticed_enumerator(*src.data<1>(),types))
+		{
+		if (!enumerator_to_integer_representation(*src.c_array<1>(),types)) return false;
+		lhs = default_promotion_is_integerlike(src.data<1>()->type_code,types);
+		assert(lhs.second);
+		}
+	if (is_noticed_enumerator(*src.data<2>(),types)) 
+		{
+		if (!enumerator_to_integer_representation(*src.c_array<2>(),types)) return false;
+		rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
+		assert(rhs.second);
+		}
+#/*cut-cpp*/
+	src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 	return true;
 }
 
@@ -7319,18 +7347,35 @@
 	default: FATAL_CODE("hardware/compiler error: invalid linear combination in C_add_expression_easy_syntax_check",3);
 #endif
 	case 0:	{	// cannot test errors from preprocessor
-			const bool rhs_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES);
-			if (!converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
+			POD_pair<size_t,bool> lhs = default_promotion_is_arithmeticlike(src.data<1>()->type_code ARG_TYPES);
+			POD_pair<size_t,bool> rhs = default_promotion_is_arithmeticlike(src.data<2>()->type_code ARG_TYPES);
+			if (!lhs.second)
 				{
-				simple_error(src,rhs_arithmeticlike ? " has non-arithmetic non-pointer right argument (C99 6.5.6p2; C++98 5.7p1)" : " has non-arithmetic non-pointer arguments (C99 6.5.6p2; C++98 5.7p1)");
+				simple_error(src,rhs.second ? " has non-arithmetic non-pointer right argument (C99 6.5.6p2; C++98 5.7p1)" : " has non-arithmetic non-pointer arguments (C99 6.5.6p2; C++98 5.7p1)");
 				return;
 				}
-			else if (!rhs_arithmeticlike)
+			else if (!rhs.second)
 				{
 				simple_error(src," has non-arithmetic non-pointer left argument (C99 6.5.6p2; C++98 5.7p1)");
 				return;
 				}
-			src.type_code.set_type(arithmetic_reconcile(default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES),default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES));
+
+#/*cut-cpp*/
+			// arithmeticlike subsumes integerlike so this is fine
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				{
+				if (!enumerator_to_integer_representation(*src.c_array<1>(),types)) return;
+				lhs = default_promotion_is_integerlike(src.data<1>()->type_code,types);
+				assert(lhs.second);
+				}
+			if (is_noticed_enumerator(*src.data<2>(),types)) 
+				{
+				if (!enumerator_to_integer_representation(*src.c_array<2>(),types)) return;
+				rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
+				assert(rhs.second);
+				}
+#/*cut-cpp*/
+			src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 			eval_add_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
@@ -7362,18 +7407,35 @@
 			return;
 			}
 	case 4:	{	// cannot test errors from preprocessor
-			const bool rhs_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES);
-			if (!converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
+			POD_pair<size_t,bool> lhs = default_promotion_is_arithmeticlike(src.data<1>()->type_code ARG_TYPES);
+			POD_pair<size_t,bool> rhs = default_promotion_is_arithmeticlike(src.data<2>()->type_code ARG_TYPES);
+			if (!lhs.second)
 				{
-				simple_error(src,rhs_arithmeticlike ? " has non-arithmetic non-pointer right argument (C99 6.5.6p3; C++98 5.7p2)" : " has non-arithmetic non-pointer arguments (C99 6.5.6p3; C++98 5.7p2)");
+				simple_error(src,rhs.second ? " has non-arithmetic non-pointer right argument (C99 6.5.6p3; C++98 5.7p2)" : " has non-arithmetic non-pointer arguments (C99 6.5.6p3; C++98 5.7p2)");
 				return;
 				}
-			else if (!rhs_arithmeticlike)
+			else if (!rhs.second)
 				{
 				simple_error(src," has non-arithmetic non-pointer left argument (C99 6.5.6p3; C++98 5.7p2)");
 				return;
 				}
-			src.type_code.set_type(arithmetic_reconcile(default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES),default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES));
+
+#/*cut-cpp*/
+			// arithmeticlike subsumes integerlike so this is fine
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				{
+				if (!enumerator_to_integer_representation(*src.c_array<1>(),types)) return;
+				lhs = default_promotion_is_integerlike(src.data<1>()->type_code,types);
+				assert(lhs.second);
+				}
+			if (is_noticed_enumerator(*src.data<2>(),types)) 
+				{
+				if (!enumerator_to_integer_representation(*src.c_array<2>(),types)) return;
+				rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
+				assert(rhs.second);
+				}
+#/*cut-cpp*/
+			src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 			eval_sub_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-26 03:05:36 UTC (rev 358)
+++ trunk/CSupport_pp.cpp	2010-03-26 07:04:31 UTC (rev 359)
@@ -795,6 +795,17 @@
 	return tmp;
 }
 
+static POD_pair<size_t,bool> default_promotion_is_arithmeticlike(const type_spec& type_code SIG_CONST_TYPES)
+{	// uses NRVO
+	POD_pair<size_t,bool> tmp = {0,false};
+	if (0==type_code.pointer_power_after_array_decay())	// pointers do not have a standard conversion to integers
+		{
+		tmp.first = default_promote_type(type_code.base_type_index ARG_TYPES);
+		tmp.second = (C_TYPE::BOOL<=tmp.first && C_TYPE::LDOUBLE__COMPLEX>=tmp.first);
+		}
+	return tmp;
+}
+
 // auxilliary structure to aggregate useful information for type promotions
 // this will malfunction badly for anything other than an integer type
 class promote_aux : public virtual_machine::promotion_info
@@ -6236,22 +6247,24 @@
 {
 	assert(C99_MULT_SUBTYPE_DIV==src.subtype || C99_MULT_SUBTYPE_MULT==src.subtype);
 	assert((C99_MULT_SUBTYPE_DIV==src.subtype) ? is_C99_mult_operator_expression<'/'>(src) : is_C99_mult_operator_expression<'*'>(src));
-	const bool rhs_is_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code ARG_TYPES);
-	if (!converts_to_arithmeticlike(src.data<1>()->type_code ARG_TYPES))
+	POD_pair<size_t,bool> lhs = default_promotion_is_arithmeticlike(src.data<1>()->type_code ARG_TYPES);
+	POD_pair<size_t,bool> rhs = default_promotion_is_arithmeticlike(src.data<2>()->type_code ARG_TYPES);
+	if (!lhs.second)
 		{	//! \test default/Error_if_control36.hpp, default/Error_if_control36.h
 			//! \test default/Error_if_control37.hpp, default/Error_if_control37.h
 			//! \test default/Error_if_control39.hpp, default/Error_if_control39.h
 			//! \test default/Error_if_control40.hpp, default/Error_if_control40.h
-		simple_error(src,rhs_is_arithmeticlike ? " has nonarithmetic LHS (C99 6.5.5p2, C++98 5.6p2)" : " has nonarithmetic LHS and RHS (C99 6.5.5p2, C++98 5.6p2)");
+		simple_error(src,rhs.second ? " has nonarithmetic LHS (C99 6.5.5p2, C++98 5.6p2)" : " has nonarithmetic LHS and RHS (C99 6.5.5p2, C++98 5.6p2)");
 		return false;
 		}
-	else if (!rhs_is_arithmeticlike)
+	else if (!rhs.second)
 		{	//! \test default/Error_if_control35.hpp, default/Error_if_control35.h
 			//! \test default/Error_if_control38.hpp, default/Error_if_control38.h
 		simple_error(src," has nonarithmetic RHS (C99 6.5.5p2, C++98 5.6p2)");
 		return false;
 		};
-	src.type_code.set_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES));
+
+	src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 	return true;
 }
 
@@ -6785,18 +6798,20 @@
 	default: FATAL_CODE("hardware/compiler error: invalid linear combination in C_add_expression_easy_syntax_check",3);
 #endif
 	case 0:	{	// cannot test errors from preprocessor
-			const bool rhs_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES);
-			if (!converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
+			POD_pair<size_t,bool> lhs = default_promotion_is_arithmeticlike(src.data<1>()->type_code ARG_TYPES);
+			POD_pair<size_t,bool> rhs = default_promotion_is_arithmeticlike(src.data<2>()->type_code ARG_TYPES);
+			if (!lhs.second)
 				{
-				simple_error(src,rhs_arithmeticlike ? " has non-arithmetic non-pointer right argument (C99 6.5.6p2; C++98 5.7p1)" : " has non-arithmetic non-pointer arguments (C99 6.5.6p2; C++98 5.7p1)");
+				simple_error(src,rhs.second ? " has non-arithmetic non-pointer right argument (C99 6.5.6p2; C++98 5.7p1)" : " has non-arithmetic non-pointer arguments (C99 6.5.6p2; C++98 5.7p1)");
 				return;
 				}
-			else if (!rhs_arithmeticlike)
+			else if (!rhs.second)
 				{
 				simple_error(src," has non-arithmetic non-pointer left argument (C99 6.5.6p2; C++98 5.7p1)");
 				return;
 				}
-			src.type_code.set_type(arithmetic_reconcile(default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES),default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES));
+
+			src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 			eval_add_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
@@ -6828,18 +6843,20 @@
 			return;
 			}
 	case 4:	{	// cannot test errors from preprocessor
-			const bool rhs_arithmeticlike = converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES);
-			if (!converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
+			POD_pair<size_t,bool> lhs = default_promotion_is_arithmeticlike(src.data<1>()->type_code ARG_TYPES);
+			POD_pair<size_t,bool> rhs = default_promotion_is_arithmeticlike(src.data<2>()->type_code ARG_TYPES);
+			if (!lhs.second)
 				{
-				simple_error(src,rhs_arithmeticlike ? " has non-arithmetic non-pointer right argument (C99 6.5.6p3; C++98 5.7p2)" : " has non-arithmetic non-pointer arguments (C99 6.5.6p3; C++98 5.7p2)");
+				simple_error(src,rhs.second ? " has non-arithmetic non-pointer right argument (C99 6.5.6p3; C++98 5.7p2)" : " has non-arithmetic non-pointer arguments (C99 6.5.6p3; C++98 5.7p2)");
 				return;
 				}
-			else if (!rhs_arithmeticlike)
+			else if (!rhs.second)
 				{
 				simple_error(src," has non-arithmetic non-pointer left argument (C99 6.5.6p3; C++98 5.7p2)");
 				return;
 				}
-			src.type_code.set_type(arithmetic_reconcile(default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES),default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES));
+
+			src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 			eval_sub_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}



From zaimoni at mail.berlios.de  Fri Mar 26 09:42:09 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 26 Mar 2010 09:42:09 +0100
Subject: [Zcplusplus-commits] r360 - in trunk/tests: zcc/staticassert.C1X
	zcc.in/staticassert.C1X
Message-ID: <201003260842.o2Q8g9pW017067@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-26 09:42:03 +0100 (Fri, 26 Mar 2010)
New Revision: 360

Modified:
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
Log:
enumerators already working for /

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-03-26 07:04:31 UTC (rev 359)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-03-26 08:42:03 UTC (rev 360)
@@ -33,3 +33,8 @@
 _Static_Assert(!(1%1),"automatic success has failed");
 _Static_Assert(!(0%1),"automatic success has failed");
 
+// check /
+_Static_Assert(2/1,"automatic success has failed");
+_Static_Assert(1/1,"automatic success has failed");
+_Static_Assert(!(1/2),"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-03-26 07:04:31 UTC (rev 359)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-03-26 08:42:03 UTC (rev 360)
@@ -33,3 +33,8 @@
 static_assert(!(1%1),"automatic success has failed");
 static_assert(!(0%1),"automatic success has failed");
 
+// check /
+static_assert(2/1,"automatic success has failed");
+static_assert(1/1,"automatic success has failed");
+static_assert(!(1/2),"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-03-26 07:04:31 UTC (rev 359)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-03-26 08:42:03 UTC (rev 360)
@@ -28,3 +28,8 @@
 _Static_Assert(!(one%one),"automatic success has failed");
 _Static_Assert(!(zero%one),"automatic success has failed");
 
+// check /
+_Static_Assert(two/one,"automatic success has failed");
+_Static_Assert(one/one,"automatic success has failed");
+_Static_Assert(!(one/two),"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-03-26 07:04:31 UTC (rev 359)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-03-26 08:42:03 UTC (rev 360)
@@ -28,3 +28,8 @@
 static_assert(!(one%one),"automatic success has failed");
 static_assert(!(zero%one),"automatic success has failed");
 
+// check /
+static_assert(two/one,"automatic success has failed");
+static_assert(one/one,"automatic success has failed");
+static_assert(!(one/two),"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-03-26 07:04:31 UTC (rev 359)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-03-26 08:42:03 UTC (rev 360)
@@ -34,3 +34,8 @@
 STATIC_ASSERT(!(1%1),"automatic success has failed");
 STATIC_ASSERT(!(0%1),"automatic success has failed");
 
+// check /
+STATIC_ASSERT(2/1,"automatic success has failed");
+STATIC_ASSERT(1/1,"automatic success has failed");
+STATIC_ASSERT(!(1/2),"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-03-26 07:04:31 UTC (rev 359)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-03-26 08:42:03 UTC (rev 360)
@@ -29,3 +29,8 @@
 STATIC_ASSERT(!(one%one),"automatic success has failed");
 STATIC_ASSERT(!(zero%one),"automatic success has failed");
 
+// check /
+STATIC_ASSERT(two/one,"automatic success has failed");
+STATIC_ASSERT(one/one,"automatic success has failed");
+STATIC_ASSERT(!(one/two),"automatic success has failed");
+



From zaimoni at mail.berlios.de  Fri Mar 26 22:31:15 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 26 Mar 2010 22:31:15 +0100
Subject: [Zcplusplus-commits] r361 - in trunk: . tests/zcc/staticassert.C1X
	tests/zcc.in/staticassert.C1X
Message-ID: <201003262131.o2QLVFs5000281@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-26 22:31:06 +0100 (Fri, 26 Mar 2010)
New Revision: 361

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
Log:
bring up enumerators for *

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-26 08:42:03 UTC (rev 360)
+++ trunk/CSupport.cpp	2010-03-26 21:31:06 UTC (rev 361)
@@ -5551,7 +5551,7 @@
 	// can type if result is a primitive arithmetic type
 	if (converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
 		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES));
-	
+
 	const size_t arg_unary_subtype 	= (is_C99_unary_operator_expression<'-'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_NEG
 									: (is_C99_unary_operator_expression<'+'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_PLUS : 0;
 	if (!arg_unary_subtype) return;
@@ -6090,6 +6090,8 @@
 			{
 			assemble_unary_postfix_arguments(src,i,unary_subtype);
 			src.c_array<0>()[i].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
+			if (0==i)	// unless no predecessor possible
+				C_unary_plusminus_easy_syntax_check(src.c_array<0>()[0],types);
 			assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i]));
 			return true;
 			};
@@ -6116,6 +6118,8 @@
 			{
 			assemble_unary_postfix_arguments(src,i,unary_subtype);
 			src.c_array<0>()[i].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
+			if (0==i)	// unless no predecessor possible
+				CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[0],types);
 			assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i]));
 			return true;
 			};

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-03-26 08:42:03 UTC (rev 360)
+++ trunk/CSupport_pp.cpp	2010-03-26 21:31:06 UTC (rev 361)
@@ -5048,7 +5048,7 @@
 	// can type if result is a primitive arithmetic type
 	if (converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
 		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES));
-	
+
 	const size_t arg_unary_subtype 	= (is_C99_unary_operator_expression<'-'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_NEG
 									: (is_C99_unary_operator_expression<'+'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_PLUS : 0;
 	if (!arg_unary_subtype) return;
@@ -5570,6 +5570,8 @@
 			{
 			assemble_unary_postfix_arguments(src,i,unary_subtype);
 			src.c_array<0>()[i].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
+			if (0==i)	// unless no predecessor possible
+				C_unary_plusminus_easy_syntax_check(src.c_array<0>()[0],types);
 			assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i]));
 			return true;
 			};
@@ -5596,6 +5598,8 @@
 			{
 			assemble_unary_postfix_arguments(src,i,unary_subtype);
 			src.c_array<0>()[i].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
+			if (0==i)	// unless no predecessor possible
+				CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[0],types);
 			assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i]));
 			return true;
 			};

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-03-26 08:42:03 UTC (rev 360)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-03-26 21:31:06 UTC (rev 361)
@@ -38,3 +38,20 @@
 _Static_Assert(1/1,"automatic success has failed");
 _Static_Assert(!(1/2),"automatic success has failed");
 
+// check *
+_Static_Assert(!(0*-1),"automatic success has failed");
+_Static_Assert(!(0*1),"automatic success has failed");
+_Static_Assert(!(0*2),"automatic success has failed");
+_Static_Assert(!(-1*0),"automatic success has failed");
+_Static_Assert(!(1*0),"automatic success has failed");
+_Static_Assert(!(2*0),"automatic success has failed");
+_Static_Assert(-1*-1,"automatic success has failed");
+_Static_Assert(-1*1,"automatic success has failed");
+_Static_Assert(-1*2,"automatic success has failed");
+_Static_Assert(1*-1,"automatic success has failed");
+_Static_Assert(1*1,"automatic success has failed");
+_Static_Assert(1*2,"automatic success has failed");
+_Static_Assert(2*-1,"automatic success has failed");
+_Static_Assert(2*1,"automatic success has failed");
+_Static_Assert(2*2,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-03-26 08:42:03 UTC (rev 360)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-03-26 21:31:06 UTC (rev 361)
@@ -38,3 +38,20 @@
 static_assert(1/1,"automatic success has failed");
 static_assert(!(1/2),"automatic success has failed");
 
+// check *
+static_assert(!(0*-1),"automatic success has failed");
+static_assert(!(0*1),"automatic success has failed");
+static_assert(!(0*2),"automatic success has failed");
+static_assert(!(-1*0),"automatic success has failed");
+static_assert(!(1*0),"automatic success has failed");
+static_assert(!(2*0),"automatic success has failed");
+static_assert(-1*-1,"automatic success has failed");
+static_assert(-1*1,"automatic success has failed");
+static_assert(-1*2,"automatic success has failed");
+static_assert(1*-1,"automatic success has failed");
+static_assert(1*1,"automatic success has failed");
+static_assert(1*2,"automatic success has failed");
+static_assert(2*-1,"automatic success has failed");
+static_assert(2*1,"automatic success has failed");
+static_assert(2*2,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-03-26 08:42:03 UTC (rev 360)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-03-26 21:31:06 UTC (rev 361)
@@ -33,3 +33,20 @@
 _Static_Assert(one/one,"automatic success has failed");
 _Static_Assert(!(one/two),"automatic success has failed");
 
+// check *
+_Static_Assert(!(zero*neg_one),"automatic success has failed");
+_Static_Assert(!(zero*one),"automatic success has failed");
+_Static_Assert(!(zero*two),"automatic success has failed");
+_Static_Assert(!(neg_one*zero),"automatic success has failed");
+_Static_Assert(!(one*zero),"automatic success has failed");
+_Static_Assert(!(two*zero),"automatic success has failed");
+_Static_Assert(neg_one*neg_one,"automatic success has failed");
+_Static_Assert(neg_one*one,"automatic success has failed");
+_Static_Assert(neg_one*two,"automatic success has failed");
+_Static_Assert(one*neg_one,"automatic success has failed");
+_Static_Assert(one*one,"automatic success has failed");
+_Static_Assert(one*two,"automatic success has failed");
+_Static_Assert(two*neg_one,"automatic success has failed");
+_Static_Assert(two*one,"automatic success has failed");
+_Static_Assert(two*two,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-03-26 08:42:03 UTC (rev 360)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-03-26 21:31:06 UTC (rev 361)
@@ -33,3 +33,20 @@
 static_assert(one/one,"automatic success has failed");
 static_assert(!(one/two),"automatic success has failed");
 
+// check *
+static_assert(!(zero*neg_one),"automatic success has failed");
+static_assert(!(zero*one),"automatic success has failed");
+static_assert(!(zero*two),"automatic success has failed");
+static_assert(!(neg_one*zero),"automatic success has failed");
+static_assert(!(one*zero),"automatic success has failed");
+static_assert(!(two*zero),"automatic success has failed");
+static_assert(neg_one*neg_one,"automatic success has failed");
+static_assert(neg_one*one,"automatic success has failed");
+static_assert(neg_one*two,"automatic success has failed");
+static_assert(one*neg_one,"automatic success has failed");
+static_assert(one*one,"automatic success has failed");
+static_assert(one*two,"automatic success has failed");
+static_assert(two*neg_one,"automatic success has failed");
+static_assert(two*one,"automatic success has failed");
+static_assert(two*two,"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-03-26 08:42:03 UTC (rev 360)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-03-26 21:31:06 UTC (rev 361)
@@ -39,3 +39,20 @@
 STATIC_ASSERT(1/1,"automatic success has failed");
 STATIC_ASSERT(!(1/2),"automatic success has failed");
 
+// check *
+STATIC_ASSERT(!(0*-1),"automatic success has failed");
+STATIC_ASSERT(!(0*1),"automatic success has failed");
+STATIC_ASSERT(!(0*2),"automatic success has failed");
+STATIC_ASSERT(!(-1*0),"automatic success has failed");
+STATIC_ASSERT(!(1*0),"automatic success has failed");
+STATIC_ASSERT(!(2*0),"automatic success has failed");
+STATIC_ASSERT(-1*-1,"automatic success has failed");
+STATIC_ASSERT(-1*1,"automatic success has failed");
+STATIC_ASSERT(-1*2,"automatic success has failed");
+STATIC_ASSERT(1*-1,"automatic success has failed");
+STATIC_ASSERT(1*1,"automatic success has failed");
+STATIC_ASSERT(1*2,"automatic success has failed");
+STATIC_ASSERT(2*-1,"automatic success has failed");
+STATIC_ASSERT(2*1,"automatic success has failed");
+STATIC_ASSERT(2*2,"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-03-26 08:42:03 UTC (rev 360)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-03-26 21:31:06 UTC (rev 361)
@@ -34,3 +34,20 @@
 STATIC_ASSERT(one/one,"automatic success has failed");
 STATIC_ASSERT(!(one/two),"automatic success has failed");
 
+// check *
+STATIC_ASSERT(!(zero*neg_one),"automatic success has failed");
+STATIC_ASSERT(!(zero*one),"automatic success has failed");
+STATIC_ASSERT(!(zero*two),"automatic success has failed");
+STATIC_ASSERT(!(neg_one*zero),"automatic success has failed");
+STATIC_ASSERT(!(one*zero),"automatic success has failed");
+STATIC_ASSERT(!(two*zero),"automatic success has failed");
+STATIC_ASSERT(neg_one*neg_one,"automatic success has failed");
+STATIC_ASSERT(neg_one*one,"automatic success has failed");
+STATIC_ASSERT(neg_one*two,"automatic success has failed");
+STATIC_ASSERT(one*neg_one,"automatic success has failed");
+STATIC_ASSERT(one*one,"automatic success has failed");
+STATIC_ASSERT(one*two,"automatic success has failed");
+STATIC_ASSERT(two*neg_one,"automatic success has failed");
+STATIC_ASSERT(two*one,"automatic success has failed");
+STATIC_ASSERT(two*two,"automatic success has failed");
+



From zaimoni at mail.berlios.de  Sat Mar 27 02:52:18 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 27 Mar 2010 02:52:18 +0100
Subject: [Zcplusplus-commits] r362 - in trunk: .
	tests/zcc/default/staticassert tests/zcc/staticassert.C1X
	tests/zcc.in/default/staticassert tests/zcc.in/staticassert.C1X
Message-ID: <201003270152.o2R1qINf010660@sheep.berlios.de>

Author: zaimoni
Date: 2010-03-27 02:52:05 +0100 (Sat, 27 Mar 2010)
New Revision: 362

Modified:
   trunk/CSupport.cpp
   trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
   trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
   trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
Log:
document that enumerators work with +; augment static assertions to handle some non-null pointers from +

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-03-26 21:31:06 UTC (rev 361)
+++ trunk/CSupport.cpp	2010-03-27 01:52:05 UTC (rev 362)
@@ -10160,6 +10160,14 @@
 				}
 			}
 		}
+#/*cut-cpp*/
+	if (src.type_code.decays_to_nonnull_pointer())
+		{
+		force_decimal_literal(src,"1",types);
+		src.type_code.set_type(C_TYPE::INT);
+		return;
+		}
+#/*cut-cpp*/
 }
 
 void CPP_PPHackTree(parse_tree& src,const type_system& types)
@@ -10228,6 +10236,14 @@
 				}
 			}
 		}
+#/*cut-cpp*/
+	if (src.type_code.decays_to_nonnull_pointer())
+		{
+		force_decimal_literal(src,"1",types);
+		src.type_code.set_type(C_TYPE::INT);
+		return;
+		}
+#/*cut-cpp*/
 }
 
 #/*cut-cpp*/

Modified: trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2010-03-26 21:31:06 UTC (rev 361)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2010-03-27 01:52:05 UTC (rev 362)
@@ -10,3 +10,8 @@
 _Static_Assert(-"A"[0],"automatic success has failed");
 _Static_Assert(!"A"[1],"automatic success has failed");
 
+_Static_Assert("A"+0,"automatic success has failed");
+_Static_Assert(0+"A","automatic success has failed");
+_Static_Assert("A"+1,"automatic success has failed");
+_Static_Assert(1+"A","automatic success has failed");
+

Modified: trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp	2010-03-26 21:31:06 UTC (rev 361)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp	2010-03-27 01:52:05 UTC (rev 362)
@@ -10,3 +10,8 @@
 static_assert(-"A"[0],"automatic success has failed");
 static_assert(!"A"[1],"automatic success has failed");
 
+static_assert("A"+0,"automatic success has failed");
+static_assert(0+"A","automatic success has failed");
+static_assert("A"+1,"automatic success has failed");
+static_assert(1+"A","automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-03-26 21:31:06 UTC (rev 361)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-03-27 01:52:05 UTC (rev 362)
@@ -55,3 +55,14 @@
 _Static_Assert(2*1,"automatic success has failed");
 _Static_Assert(2*2,"automatic success has failed");
 
+// check +
+_Static_Assert(-1+-1,"automatic success has failed");
+_Static_Assert(-1+0,"automatic success has failed");
+_Static_Assert(!(-1+1),"automatic success has failed");
+_Static_Assert(0+-1,"automatic success has failed");
+_Static_Assert(!(0+0),"automatic success has failed");
+_Static_Assert(0+1,"automatic success has failed");
+_Static_Assert(!(1+-1),"automatic success has failed");
+_Static_Assert(1+0,"automatic success has failed");
+_Static_Assert(1+1,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-03-26 21:31:06 UTC (rev 361)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-03-27 01:52:05 UTC (rev 362)
@@ -55,3 +55,14 @@
 static_assert(2*1,"automatic success has failed");
 static_assert(2*2,"automatic success has failed");
 
+// check +
+static_assert(-1+-1,"automatic success has failed");
+static_assert(-1+0,"automatic success has failed");
+static_assert(!(-1+1),"automatic success has failed");
+static_assert(0+-1,"automatic success has failed");
+static_assert(!(0+0),"automatic success has failed");
+static_assert(0+1,"automatic success has failed");
+static_assert(!(1+-1),"automatic success has failed");
+static_assert(1+0,"automatic success has failed");
+static_assert(1+1,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-03-26 21:31:06 UTC (rev 361)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-03-27 01:52:05 UTC (rev 362)
@@ -50,3 +50,14 @@
 _Static_Assert(two*one,"automatic success has failed");
 _Static_Assert(two*two,"automatic success has failed");
 
+// check +
+_Static_Assert(neg_one+neg_one,"automatic success has failed");
+_Static_Assert(neg_one+zero,"automatic success has failed");
+_Static_Assert(!(neg_one+one),"automatic success has failed");
+_Static_Assert(zero+neg_one,"automatic success has failed");
+_Static_Assert(!(zero+zero),"automatic success has failed");
+_Static_Assert(zero+one,"automatic success has failed");
+_Static_Assert(!(one+neg_one),"automatic success has failed");
+_Static_Assert(one+zero,"automatic success has failed");
+_Static_Assert(one+one,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-03-26 21:31:06 UTC (rev 361)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-03-27 01:52:05 UTC (rev 362)
@@ -50,3 +50,14 @@
 static_assert(two*one,"automatic success has failed");
 static_assert(two*two,"automatic success has failed");
 
+// check +
+static_assert(neg_one+neg_one,"automatic success has failed");
+static_assert(neg_one+zero,"automatic success has failed");
+static_assert(!(neg_one+one),"automatic success has failed");
+static_assert(zero+neg_one,"automatic success has failed");
+static_assert(!(zero+zero),"automatic success has failed");
+static_assert(zero+one,"automatic success has failed");
+static_assert(!(one+neg_one),"automatic success has failed");
+static_assert(one+zero,"automatic success has failed");
+static_assert(one+one,"automatic success has failed");
+

Modified: trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2010-03-26 21:31:06 UTC (rev 361)
+++ trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2010-03-27 01:52:05 UTC (rev 362)
@@ -11,3 +11,8 @@
 STATIC_ASSERT(-"A"[0],"automatic success has failed");
 STATIC_ASSERT(!"A"[1],"automatic success has failed");
 
+STATIC_ASSERT("A"+0,"automatic success has failed");
+STATIC_ASSERT(0+"A","automatic success has failed");
+STATIC_ASSERT("A"+1,"automatic success has failed");
+STATIC_ASSERT(1+"A","automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-03-26 21:31:06 UTC (rev 361)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-03-27 01:52:05 UTC (rev 362)
@@ -56,3 +56,14 @@
 STATIC_ASSERT(2*1,"automatic success has failed");
 STATIC_ASSERT(2*2,"automatic success has failed");
 
+// check +
+STATIC_ASSERT(-1+-1,"automatic success has failed");
+STATIC_ASSERT(-1+0,"automatic success has failed");
+STATIC_ASSERT(!(-1+1),"automatic success has failed");
+STATIC_ASSERT(0+-1,"automatic success has failed");
+STATIC_ASSERT(!(0+0),"automatic success has failed");
+STATIC_ASSERT(0+1,"automatic success has failed");
+STATIC_ASSERT(!(1+-1),"automatic success has failed");
+STATIC_ASSERT(1+0,"automatic success has failed");
+STATIC_ASSERT(1+1,"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-03-26 21:31:06 UTC (rev 361)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-03-27 01:52:05 UTC (rev 362)
@@ -51,3 +51,14 @@
 STATIC_ASSERT(two*one,"automatic success has failed");
 STATIC_ASSERT(two*two,"automatic success has failed");
 
+// check +
+STATIC_ASSERT(neg_one+neg_one,"automatic success has failed");
+STATIC_ASSERT(neg_one+zero,"automatic success has failed");
+STATIC_ASSERT(!(neg_one+one),"automatic success has failed");
+STATIC_ASSERT(zero+neg_one,"automatic success has failed");
+STATIC_ASSERT(!(zero+zero),"automatic success has failed");
+STATIC_ASSERT(zero+one,"automatic success has failed");
+STATIC_ASSERT(!(one+neg_one),"automatic success has failed");
+STATIC_ASSERT(one+zero,"automatic success has failed");
+STATIC_ASSERT(one+one,"automatic success has failed");
+



