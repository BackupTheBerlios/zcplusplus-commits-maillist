<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Zcplusplus-commits] r529 - trunk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/zcplusplus-commits/2010-November/index.html" >
   <LINK REL="made" HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r529%20-%20trunk&In-Reply-To=%3C20101102085426.40DDD480C33%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000295.html">
   <LINK REL="Next"  HREF="000297.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Zcplusplus-commits] r529 - trunk</H1>
    <B>zaimoni at mail.berlios.de</B> 
    <A HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r529%20-%20trunk&In-Reply-To=%3C20101102085426.40DDD480C33%40sheep.berlios.de%3E"
       TITLE="[Zcplusplus-commits] r529 - trunk">zaimoni at mail.berlios.de
       </A><BR>
    <I>Tue Nov  2 09:54:25 CET 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="000295.html">[Zcplusplus-commits] r528 - in trunk: . tools
</A></li>
        <LI>Next message: <A HREF="000297.html">[Zcplusplus-commits] r530 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#296">[ date ]</a>
              <a href="thread.html#296">[ thread ]</a>
              <a href="subject.html#296">[ subject ]</a>
              <a href="author.html#296">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zaimoni
Date: 2010-11-02 09:54:25 +0100 (Tue, 02 Nov 2010)
New Revision: 529

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/CSupport.hpp
   trunk/ZParser.cpp
Log:
adjust context parsing to explicitly use global parse_tree::types rather than effectively pass it in as a parameter

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-02 03:01:19 UTC (rev 528)
+++ trunk/CSupport.cpp	2010-11-02 08:54:25 UTC (rev 529)
@@ -12135,7 +12135,7 @@
 }
 
 //! \throw std::bad_alloc()
-static void C99_CPP_handle_static_assertion(parse_tree&amp; src,type_system&amp; types,PP_auxfunc&amp; langinfo,const size_t i,const char* const err,const char* const active_namespace)
+static void C99_CPP_handle_static_assertion(parse_tree&amp; src,PP_auxfunc&amp; langinfo,const size_t i,const char* const err,const char* const active_namespace)
 {
 	assert(err &amp;&amp; *err);
 	// find the next ';'
@@ -12190,20 +12190,20 @@
 	zaimoni::autotransform_n&lt;void (*)(parse_tree&amp;,const parse_tree&amp;)&gt;(parsetree.c_array&lt;0&gt;(),src.data&lt;0&gt;()[i+1].data&lt;0&gt;(),k,value_copy);
 	// type all enumerators now to make life reasonable later on for the expression-parser
 	size_t enum_scan = k;
-	do	notice_enumerator_CPP(parsetree.c_array&lt;0&gt;()[--enum_scan],types,active_namespace);
+	do	notice_enumerator_CPP(parsetree.c_array&lt;0&gt;()[--enum_scan],*parse_tree::types,active_namespace);
 	while(0&lt;enum_scan);
 	}
 	// init above correctly
 	// snip from Condense
 	const size_t starting_errors = zcc_errors.err_count();
-	(langinfo.LocateExpression)(parsetree,SIZE_MAX,types);
+	(langinfo.LocateExpression)(parsetree,SIZE_MAX,*parse_tree::types);
 	if (starting_errors==zcc_errors.err_count())
 		{
 		while(parsetree.is_raw_list() &amp;&amp; 1==parsetree.size&lt;0&gt;())
 			parsetree.eval_to_arg&lt;0&gt;(0);
 		// end snip from Condense
 		// snip from CPreproc
-		if (!parsetree.is_atomic() &amp;&amp; !(langinfo.EvalParseTree)(parsetree,types))
+		if (!parsetree.is_atomic() &amp;&amp; !(langinfo.EvalParseTree)(parsetree,*parse_tree::types))
 			{
 			parsetree.destroy();	// efficiency
 			message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -12213,7 +12213,7 @@
 			src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
 			return;
 			}
-		(langinfo.PPHackTree)(parsetree,types);
+		(langinfo.PPHackTree)(parsetree,*parse_tree::types);
 		// final, when above is working properly
 		if (!parsetree.is_atomic())
 			{	//! \bug need test cases
@@ -12228,11 +12228,11 @@
 		// end snip from CPreproc
 
 		// handle top-level enumerators
-		if (is_noticed_enumerator(parsetree,types))
-			enumerator_to_integer_representation(parsetree,types);
+		if (is_noticed_enumerator(parsetree,*parse_tree::types))
+			enumerator_to_integer_representation(parsetree,*parse_tree::types);
 
 		bool is_true = false;
-		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true,types))
+		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true,*parse_tree::types))
 			{	//! \bug need test cases
 			parsetree.destroy();	// efficiency
 			message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -12331,7 +12331,7 @@
 }
 
 //! \throw std::bad_alloc
-static bool record_enum_values(parse_tree&amp; src, type_system&amp; types, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits&lt;const char* (*)(const char*, size_t)&gt;::function_ref_type echo_reserved_keyword, intlike_literal_to_VM_func&amp; intlike_literal_to_VM, func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type CondenseParseTree, func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree)
+static bool record_enum_values(parse_tree&amp; src, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits&lt;const char* (*)(const char*, size_t)&gt;::function_ref_type echo_reserved_keyword, intlike_literal_to_VM_func&amp; intlike_literal_to_VM, func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type CondenseParseTree, func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree)
 {
 	assert(enum_type_index);
 	assert(!active_namespace || *active_namespace);
@@ -12461,7 +12461,7 @@
 		char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[0].token.first,active_namespace,&quot;::&quot;) : NULL;
 		const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[0].token.first;
 		{
-		const type_system::enumerator_info* tmp = types.get_enumerator(fullname);
+		const type_system::enumerator_info* tmp = parse_tree::types-&gt;get_enumerator(fullname);
 		if (tmp)
 			{	// --do-what-i-mean could recover if the prior definition were identical
 				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined
@@ -12480,7 +12480,7 @@
 #if 0
 		// next proposed function call is a bit handwavish right now...
 		// C++0X 3.3.1p4: enumerator gets to hide class names and enum names, nothing else [in particular dies against typedefs and functions]
-		if (types.enum_already_defined(active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].token.first))
+		if (parse_tree::types-&gt;enum_already_defined(active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].token.first))
 			{	// -Wbackport warn in C++, fail in C
 			if (allow_empty)
 				{	// C++0X
@@ -12501,7 +12501,7 @@
 				return false;
 				}	
 			};
-		if (types.union_class_struct_already_declared(active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].token.first))
+		if (parse_tree::types-&gt;union_class_struct_already_declared(active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].token.first))
 			{	// -Wbackport warn in C++, fail in C
 			if (allow_empty)
 				{	// C++0X
@@ -12522,12 +12522,12 @@
 				return false;
 				}	
 			};
-		if (types.function_already_declared(active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].token.first))
+		if (parse_tree::types-&gt;function_already_declared(active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].token.first))
 			{	// C++: One Definition Rule
 			};
 #endif
 		{
-		const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* const tmp = types.get_typedef_CPP(src.data&lt;0&gt;()[i].index_tokens[0].token.first,active_namespace); 
+		const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* const tmp = parse_tree::types-&gt;get_typedef_CPP(src.data&lt;0&gt;()[i].index_tokens[0].token.first,active_namespace); 
 		if (tmp)
 			{	// C++: One Definition Rule
 				//! \test decl.C99/Error_enum_typedef.h, decl.C99/Error_enum_typedef.hpp 
@@ -12557,7 +12557,7 @@
 		value_copy(prior_value,latest_value);
 		{
 		bool value_is_nonnegative = true;
-		const promote_aux test(current_enumerator_type,types);
+		const promote_aux test(current_enumerator_type,*parse_tree::types);
 		if (test.is_signed &amp;&amp; latest_value.test(test.bitcount-1))
 			{
 			target_machine-&gt;signed_additive_inverse(latest_value,test.machine_type);
@@ -12574,15 +12574,15 @@
 		if (1&gt;=src.size&lt;0&gt;()-i)
 			{	// default-update
 			// handle type errors
-			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data&lt;0&gt;()[i].index_tokens[0],types))
+			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data&lt;0&gt;()[i].index_tokens[0],*parse_tree::types))
 				return false;
 			uchar_blob latest_value_copy;
 			latest_value_copy.init(0);
 			value_copy(latest_value_copy,latest_value);
 			if (active_namespace)
-				types.set_enumerator_def_CPP(src.data&lt;0&gt;()[i].index_tokens[0].token.first, active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types-&gt;set_enumerator_def_CPP(src.data&lt;0&gt;()[i].index_tokens[0].token.first, active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			else
-				types.set_enumerator_def(src.data&lt;0&gt;()[i].index_tokens[0].token.first,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types-&gt;set_enumerator_def(src.data&lt;0&gt;()[i].index_tokens[0].token.first,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			break;
 			}
 		// complete conversion
@@ -12591,15 +12591,15 @@
 		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
 		if (robust_token_is_char&lt;','&gt;(src.data&lt;0&gt;()[i+1]))
 			{	// would default-update
-			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data&lt;0&gt;()[i].index_tokens[0],types))
+			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data&lt;0&gt;()[i].index_tokens[0],*parse_tree::types))
 				return false;
 			uchar_blob latest_value_copy;
 			latest_value_copy.init(0);
 			value_copy(latest_value_copy,latest_value);
 			if (active_namespace)
-				types.set_enumerator_def_CPP(src.data&lt;0&gt;()[i].index_tokens[0].token.first, active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types-&gt;set_enumerator_def_CPP(src.data&lt;0&gt;()[i].index_tokens[0].token.first, active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			else
-				types.set_enumerator_def(src.data&lt;0&gt;()[i].index_tokens[0].token.first,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types-&gt;set_enumerator_def(src.data&lt;0&gt;()[i].index_tokens[0].token.first,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			i += 2;
 			continue;
 			};
@@ -12619,9 +12619,9 @@
 			};
 		{	// see if it's a compile-time constant
 		parse_tree_class tmp(src,origin,i-comma_overextended,0);
-		if (tmp.is_raw_list() &amp;&amp; !CondenseParseTree(tmp,types)) return false;
-		if (!EvalParseTree(tmp,types)) return false;
-		if (!intlike_literal_to_VM(latest_value,tmp,types))
+		if (tmp.is_raw_list() &amp;&amp; !CondenseParseTree(tmp,*parse_tree::types)) return false;
+		if (!EvalParseTree(tmp,*parse_tree::types)) return false;
+		if (!intlike_literal_to_VM(latest_value,tmp,*parse_tree::types))
 			{	//! \bug need test case
 			message_header(src.data&lt;0&gt;()[origin-2].index_tokens[0]);
 			INC_INFORM(ERR_STR);
@@ -12633,7 +12633,7 @@
 		if (allow_empty)
 			{	// C++
 			current_enumerator_type = tmp.type_code.base_type_index;
-			const promote_aux test(current_enumerator_type,types);
+			const promote_aux test(current_enumerator_type,*parse_tree::types);
 			if (test.is_signed &amp;&amp; latest_value.test(test.bitcount-1))
 				{	// negative
 				unsigned_var_int abs_latest_value(latest_value);
@@ -12738,8 +12738,8 @@
 				}
 			}
 		else{	// C
-			const promote_aux test(tmp.type_code.base_type_index,types);
-			const promote_aux dest_type(C_TYPE::INT,types);
+			const promote_aux test(tmp.type_code.base_type_index,*parse_tree::types);
+			const promote_aux dest_type(C_TYPE::INT,*parse_tree::types);
 			const bool is_negative = test.is_signed &amp;&amp; latest_value.test(test.bitcount-1);
 			if (is_negative)
 				target_machine-&gt;signed_additive_inverse(latest_value,test.machine_type);
@@ -12777,13 +12777,13 @@
 		latest_value_copy.init(0);
 		value_copy(latest_value_copy,latest_value);
 		if (active_namespace)
-			types.set_enumerator_def_CPP(src.data&lt;0&gt;()[origin-2].index_tokens[0].token.first, active_namespace,src.data&lt;0&gt;()[origin-2].index_tokens[0].logical_line,src.data&lt;0&gt;()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+			parse_tree::types-&gt;set_enumerator_def_CPP(src.data&lt;0&gt;()[origin-2].index_tokens[0].token.first, active_namespace,src.data&lt;0&gt;()[origin-2].index_tokens[0].logical_line,src.data&lt;0&gt;()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 		else
-			types.set_enumerator_def(src.data&lt;0&gt;()[origin-2].index_tokens[0].token.first,src.data&lt;0&gt;()[origin-2].index_tokens[0].logical_line,src.data&lt;0&gt;()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+			parse_tree::types-&gt;set_enumerator_def(src.data&lt;0&gt;()[origin-2].index_tokens[0].token.first,src.data&lt;0&gt;()[origin-2].index_tokens[0].logical_line,src.data&lt;0&gt;()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 		}
 		}
 	// now ok to crunch underlying type/machine representation
-	types.set_enum_underlying_type(enum_type_index,allow_empty ? base_enum_type : C_TYPE::INT);
+	parse_tree::types-&gt;set_enum_underlying_type(enum_type_index,allow_empty ? base_enum_type : C_TYPE::INT);
 	return true;
 }
 
@@ -12809,7 +12809,7 @@
 // will need: typedef map: identifier |-&gt; typespec record
 //! \todo check that the fact all literals are already legal-form is used
 //! \throw std::bad_alloc
-static void C99_ContextParse(parse_tree&amp; src,type_system&amp; types)
+static void C99_ContextParse(parse_tree&amp; src)
 {
 	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle in type_spec, which is required to be POD to allow C memory management:
 	// * indirection depth n (already have this in practice)
@@ -12834,7 +12834,7 @@
 		// C static assertion scanner
 		if (robust_token_is_string&lt;14&gt;(src.data&lt;0&gt;()[i],&quot;_Static_Assert&quot;))
 			{	// _Static_Assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CLexer-&gt;pp_support,i,&quot;control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)&quot;,NULL);
+			C99_CPP_handle_static_assertion(src,*CLexer-&gt;pp_support,i,&quot;control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)&quot;,NULL);
 			continue;
 			};
 		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
@@ -12842,21 +12842,22 @@
 		if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
 			{
 C99_union_specifier:
-			const type_system::type_index tmp = types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
+				assert(0&lt;parse_tree::types-&gt;use_count(tmp));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.h
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
@@ -12892,6 +12893,7 @@
 					//! \test zcc/decl.C99/Pass_union_forward_def.h
 					// remove from parse
 					src.DeleteNSlotsAt&lt;0&gt;(2,i);
+					assert(0&lt;parse_tree::types-&gt;use_count(tmp));
 					continue;					
 					}
 				// forward-declare
@@ -12912,21 +12914,22 @@
 		else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
 			{
 C99_struct_specifier:
-			const type_system::type_index tmp = types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
+				assert(0&lt;parse_tree::types-&gt;use_count(tmp));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
@@ -12981,10 +12984,11 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;union&quot;))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				assert(0&lt;parse_tree::types-&gt;use_count(tmp));
+				const C_union_struct_def* const fatal_def = parse_tree::types-&gt;get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_union_multidef.h
 					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -13006,12 +13010,12 @@
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.h
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
@@ -13019,13 +13023,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types-&gt;upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types-&gt;get_C_structdef(vr_tmp));
 			if (   1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
 				{	// no objects declared, trigger the const/volatile warnings
@@ -13048,10 +13052,11 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;struct&quot;))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				assert(0&lt;parse_tree::types-&gt;use_count(tmp));
+				const C_union_struct_def* const fatal_def = parse_tree::types-&gt;get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_struct_multidef.h
 					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -13073,12 +13078,12 @@
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or union must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
@@ -13086,13 +13091,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types-&gt;upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types-&gt;get_C_structdef(vr_tmp));
 			if (   1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
 				{	// no objects declared, trigger the const/volatile warnings
@@ -13116,21 +13121,21 @@
 		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl(&quot;&lt;unknown&gt;&quot;,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = parse_tree::types-&gt;register_structdecl(&quot;&lt;unknown&gt;&quot;,union_struct_decl::decl_union);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types-&gt;get_structdecl(tmp2));
 
 			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 			src.c_array&lt;0&gt;()[i].flags |= PARSE_UNION_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types-&gt;upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types-&gt;get_C_structdef(tmp2));
 
 			if (   1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
@@ -13161,21 +13166,21 @@
 		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl(&quot;&lt;unknown&gt;&quot;,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = parse_tree::types-&gt;register_structdecl(&quot;&lt;unknown&gt;&quot;,union_struct_decl::decl_struct);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types-&gt;get_structdecl(tmp2));
 
 			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 			src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types-&gt;upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types-&gt;get_C_structdef(tmp2));
 
 			if (   1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
@@ -13208,7 +13213,7 @@
 			{	// C99 6.7.2.3: allowed only after name is defined
 			if (!(src.c_array&lt;0&gt;()[i].flags &amp; parse_tree::INVALID))
 				{
-				type_system::type_index tmp = types.get_id_enum(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
+				type_system::type_index tmp = parse_tree::types-&gt;get_id_enum(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
 				src.c_array&lt;0&gt;()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 				if (!tmp)
 					{	//! \test zcc/decl.C99/Error_enum_undef.h
@@ -13224,15 +13229,16 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;enum&quot;))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_enum(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_enum(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
 			if (tmp)
 				{	//! \test zcc/decl.C99/Error_enum_multidef.h
+				assert(0&lt;parse_tree::types-&gt;use_count(tmp));
 				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM(&quot;'enum &quot;);
 				INC_INFORM(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].token.second);
 				INFORM(&quot;' already defined (C99 6.7.2.3p1)&quot;);
-				const enum_def* const tmp2 = types.get_enum_def(tmp);
+				const enum_def* const tmp2 = parse_tree::types-&gt;get_enum_def(tmp);
 				assert(tmp2);
 				message_header(*tmp2);
 				INFORM(&quot;prior definition here&quot;);
@@ -13243,9 +13249,9 @@
 				};
 			// enum-specifier doesn't have a specific declaration mode
 			//! \test zcc/decl.C99/Pass_enum_def.h
-			const type_system::type_index tmp2 = types.register_enum_def(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
-			assert(types.get_id_enum(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+			const type_system::type_index tmp2 = parse_tree::types-&gt;register_enum_def(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
+			assert(parse_tree::types-&gt;get_id_enum(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
 				return;
@@ -13254,8 +13260,8 @@
 		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;))
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = types.register_enum_def(&quot;&lt;unknown&gt;&quot;,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+			const type_system::type_index tmp = parse_tree::types-&gt;register_enum_def(&quot;&lt;unknown&gt;&quot;,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
+			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
 				return;
@@ -13275,7 +13281,7 @@
 		// ** C: const volatile restrict (but pointer type required for restrict)
 		// * atomic types have already been parsed, we need to catch the others
 		{
-		C99_decl_specifier_scanner declFind(types);
+		C99_decl_specifier_scanner declFind(*parse_tree::types);
 		size_t decl_count = src.get_span&lt;0&gt;(i,declFind);
 		if (decl_count)
 			{
@@ -13367,7 +13373,7 @@
 						{	// typedef
 						register_token&lt;0&gt;(*initdecl_identifier);
 						// verify that there is no prior definition
-						const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp = types.get_typedef(initdecl_identifier-&gt;index_tokens[0].token.first);
+						const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp = parse_tree::types-&gt;get_typedef(initdecl_identifier-&gt;index_tokens[0].token.first);
 						if (tmp)
 							{
 							if (bootstrap==tmp-&gt;first)
@@ -13400,7 +13406,7 @@
 							// do not re-register if there is a prior definition
 							}
 						else{	// prepare to register this with types object
-							const type_system::enumerator_info* tmp2 = types.get_enumerator(initdecl_identifier-&gt;index_tokens[0].token.first);
+							const type_system::enumerator_info* tmp2 = parse_tree::types-&gt;get_enumerator(initdecl_identifier-&gt;index_tokens[0].token.first);
 							if (tmp2)
 								{	//! \test zcc/decl.C99/Error_typedef_enum.h
 								message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -13413,7 +13419,7 @@
 								zcc_errors.inc_error();
 								return;
 								}
-							types.set_typedef(initdecl_identifier-&gt;index_tokens[0].token.first,initdecl_identifier-&gt;index_tokens[0].src_filename,initdecl_identifier-&gt;index_tokens[0].logical_line.first,bootstrap);
+							parse_tree::types-&gt;set_typedef(initdecl_identifier-&gt;index_tokens[0].token.first,initdecl_identifier-&gt;index_tokens[0].src_filename,initdecl_identifier-&gt;index_tokens[0].logical_line.first,bootstrap);
 							}
 						}
 #if 0
@@ -13610,7 +13616,7 @@
 // handle namespaces or else
 //! \todo check that the fact all literals are already legal-form is used
 //! \throw std::bad_alloc
-static void CPP_ParseNamespace(parse_tree&amp; src,type_system&amp; types,const char* const active_namespace)
+static void CPP_ParseNamespace(parse_tree&amp; src,const char* const active_namespace)
 {
 	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle
 	// * indirection depth n (already have this in practice)
@@ -13645,7 +13651,7 @@
 		// C++ static assertion scanner
 		if (robust_token_is_string&lt;13&gt;(src.data&lt;0&gt;()[i],&quot;static_assert&quot;))
 			{	// static_assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CPlusPlusLexer-&gt;pp_support,i,&quot;control expression for static assertion must be a constant convertible to bool (C++0X 7p4)&quot;,active_namespace);
+			C99_CPP_handle_static_assertion(src,*CPlusPlusLexer-&gt;pp_support,i,&quot;control expression for static assertion must be a constant convertible to bool (C++0X 7p4)&quot;,active_namespace);
 			continue;
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
@@ -13653,7 +13659,7 @@
 		if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
 			{
 CPP_union_specifier:
-			const type_system::type_index tmp = types.get_id_union_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_union_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
@@ -13662,12 +13668,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
@@ -13722,7 +13728,7 @@
 		else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
 			{
 CPP_struct_specifier:				
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
@@ -13731,12 +13737,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
@@ -13792,7 +13798,7 @@
 		else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;class&quot;))
 			{
 CPP_class_specifier:
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
@@ -13801,12 +13807,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
@@ -13861,10 +13867,10 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;union&quot;))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_union_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_union_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				const C_union_struct_def* const fatal_def = parse_tree::types-&gt;get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_union_multidef.hpp
 					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -13886,12 +13892,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
@@ -13899,13 +13905,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types-&gt;upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types-&gt;get_C_structdef(vr_tmp));
 			if (   1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
 				{	// check for forward-declaration here
@@ -13928,10 +13934,10 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;struct&quot;))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				const C_union_struct_def* const fatal_def = parse_tree::types-&gt;get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
 					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -13953,12 +13959,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
@@ -13966,13 +13972,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types-&gt;upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types-&gt;get_C_structdef(vr_tmp));
 			if (   1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
 				{	// check for forward-declaration here
@@ -13995,10 +14001,10 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;class&quot;))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				const C_union_struct_def* const fatal_def = parse_tree::types-&gt;get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_class_multidef.hpp
 					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -14020,12 +14026,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
@@ -14033,13 +14039,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types-&gt;upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types-&gt;get_C_structdef(vr_tmp));
 			if (   1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
 				{	// check for forward-declaration here
@@ -14063,22 +14069,22 @@
 		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = parse_tree::types-&gt;register_structdecl_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,union_struct_decl::decl_union);
 			assert(tmp2);
 
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types-&gt;get_structdecl(tmp2));
 			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 			src.c_array&lt;0&gt;()[i].flags |= PARSE_UNION_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types-&gt;upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types-&gt;get_C_structdef(tmp2));
 
 			if (	1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; 	robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
@@ -14109,20 +14115,20 @@
 		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = parse_tree::types-&gt;register_structdecl_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,union_struct_decl::decl_struct);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types-&gt;get_structdecl(tmp2));
 			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 			src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types-&gt;upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types-&gt;get_C_structdef(tmp2));
 
 			if (	1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; 	robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
@@ -14153,20 +14159,20 @@
 		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;class&quot;))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,union_struct_decl::decl_class);
+			const type_system::type_index tmp2 = parse_tree::types-&gt;register_structdecl_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,union_struct_decl::decl_class);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types-&gt;get_structdecl(tmp2));
 			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 			src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types-&gt;upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types-&gt;get_C_structdef(tmp2));
 
 			if (	1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; 	robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
@@ -14200,7 +14206,7 @@
 			{
 			if (!(src.c_array&lt;0&gt;()[i].flags &amp; parse_tree::INVALID))
 				{
-				type_system::type_index tmp = types.get_id_enum_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+				type_system::type_index tmp = parse_tree::types-&gt;get_id_enum_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);	// C++: enums are own type
 				if (!tmp)
 					{	// this belongs elsewhere
@@ -14220,7 +14226,7 @@
 			{	// can only define once
 			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
 			const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-			type_system::type_index tmp = types.get_id_enum(fullname);
+			type_system::type_index tmp = parse_tree::types-&gt;get_id_enum(fullname);
 			if (tmp)
 				{	//! \test zcc/decl.C99/Error_enum_multidef.hpp
 				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -14229,7 +14235,7 @@
 				INC_INFORM(fullname);
 				free(namespace_name);
 				INFORM(&quot;' already defined (C++98 3.2p1)&quot;);
-				const enum_def* const tmp2 = types.get_enum_def(tmp);
+				const enum_def* const tmp2 = parse_tree::types-&gt;get_enum_def(tmp);
 				assert(tmp2);
 				message_header(*tmp2);
 				INFORM(&quot;prior definition here&quot;);
@@ -14241,9 +14247,9 @@
 			free(namespace_name);
 			//! \test zcc/decl.C99/Pass_enum_def.hpp
 			// enum-specifier doesn't have a specific declaration mode
-			const type_system::type_index tmp2 = types.register_enum_def_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
-			assert(types.get_id_enum_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,tmp2,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+			const type_system::type_index tmp2 = parse_tree::types-&gt;register_enum_def_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
+			assert(parse_tree::types-&gt;get_id_enum_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),tmp2,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 				{
 				INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
 				return;
@@ -14252,8 +14258,8 @@
 		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;))
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = types.register_enum_def_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+			const type_system::type_index tmp = parse_tree::types-&gt;register_enum_def_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
+			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 				{
 				INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
 				return;
@@ -14303,11 +14309,11 @@
 					strcpy(new_active_namespace,active_namespace);
 					strcat(new_active_namespace,&quot;::&lt;unknown&gt;&quot;);
 					strcat(new_active_namespace,&quot;&quot;);
-					CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],types,new_active_namespace);
+					CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],new_active_namespace);
 					free(new_active_namespace);
 					}
 				else{
-					CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],types,&quot;&lt;unknown&gt;&quot;);
+					CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],&quot;&lt;unknown&gt;&quot;);
 					}
 				++i;
 				continue;
@@ -14359,12 +14365,12 @@
 			if (NULL==active_namespace)
 				{	// global
 					//! \todo expand namespace aliases
-				CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],types,src.c_array&lt;0&gt;()[i].index_tokens[1].token.first);
+				CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],src.c_array&lt;0&gt;()[i].index_tokens[1].token.first);
 				}
 			else{	// nested
 					//! \todo expand namespace aliases
 				char* const new_active_namespace = type_system::namespace_concatenate(src.c_array&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;);
-				CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],types,new_active_namespace);
+				CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],new_active_namespace);
 				free(new_active_namespace);
 				}
 			++i;
@@ -14389,7 +14395,7 @@
 		// * atomic types have already been parsed, we need to catch the others
 		// * C++0x: auto is a possible type!
 		{
-		CPP0X_decl_specifier_scanner declFind(types,active_namespace);
+		CPP0X_decl_specifier_scanner declFind(*parse_tree::types,active_namespace);
 		size_t decl_count = src.destructive_get_span&lt;0&gt;(i,declFind);
 		if (decl_count)
 			{
@@ -14493,7 +14499,7 @@
 
 						// verify that there is no prior definition
 						// we're fine redeclaring at a different level, so do not use full C++ typedef lookup
-						const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp = types.get_typedef(fullname);					
+						const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp = parse_tree::types-&gt;get_typedef(fullname);					
 						if (tmp)
 							{
 							if (bootstrap==tmp-&gt;first)
@@ -14528,7 +14534,7 @@
 							}
 						else{	// register this with types object
 							free(namespace_name);
-							const type_system::enumerator_info* tmp2 = types.get_enumerator_CPP(initdecl_identifier-&gt;index_tokens[0].token.first,active_namespace);
+							const type_system::enumerator_info* tmp2 = parse_tree::types-&gt;get_enumerator_CPP(initdecl_identifier-&gt;index_tokens[0].token.first,active_namespace);
 							if (tmp2)
 								{	//! \test zcc/decl.C99/Error_typedef_enum.hpp
 									//! \test zcc/decl.C99/Error_typedef_enum2.hpp
@@ -14542,7 +14548,7 @@
 								zcc_errors.inc_error();
 								return;
 								}							
-							types.set_typedef_CPP(initdecl_identifier-&gt;index_tokens[0].token.first,active_namespace,initdecl_identifier-&gt;index_tokens[0].src_filename,initdecl_identifier-&gt;index_tokens[0].logical_line.first,bootstrap);
+							parse_tree::types-&gt;set_typedef_CPP(initdecl_identifier-&gt;index_tokens[0].token.first,active_namespace,initdecl_identifier-&gt;index_tokens[0].src_filename,initdecl_identifier-&gt;index_tokens[0].logical_line.first,bootstrap);
 							}
 						}
 #if 0
@@ -14592,9 +14598,9 @@
 }
 
 //! \throw std::bad_alloc
-static void CPP_ContextParse(parse_tree&amp; src,type_system&amp; types)
+static void CPP_ContextParse(parse_tree&amp; src)
 {
-	CPP_ParseNamespace(src,types,NULL);
+	CPP_ParseNamespace(src,NULL);
 }
 
 PP_auxfunc C99_aux

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-02 03:01:19 UTC (rev 528)
+++ trunk/CSupport.cpp.in	2010-11-02 08:54:25 UTC (rev 529)
@@ -12279,7 +12279,7 @@
 }
 
 //! \throw std::bad_alloc()
-static void C99_CPP_handle_static_assertion(parse_tree&amp; src,type_system&amp; types,PP_auxfunc&amp; langinfo,const size_t i,const char* const err,const char* const active_namespace)
+static void C99_CPP_handle_static_assertion(parse_tree&amp; src,PP_auxfunc&amp; langinfo,const size_t i,const char* const err,const char* const active_namespace)
 {
 	assert(err &amp;&amp; *err);
 	// find the next ';'
@@ -12334,20 +12334,20 @@
 	zaimoni::autotransform_n&lt;void (*)(parse_tree&amp;,const parse_tree&amp;)&gt;(parsetree.c_array&lt;0&gt;(),src.data&lt;0&gt;()[i+1].data&lt;0&gt;(),k,value_copy);
 	// type all enumerators now to make life reasonable later on for the expression-parser
 	size_t enum_scan = k;
-	do	notice_enumerator_CPP(parsetree.c_array&lt;0&gt;()[--enum_scan],types,active_namespace);
+	do	notice_enumerator_CPP(parsetree.c_array&lt;0&gt;()[--enum_scan],*parse_tree::types,active_namespace);
 	while(0&lt;enum_scan);
 	}
 	// init above correctly
 	// snip from Condense
 	const size_t starting_errors = zcc_errors.err_count();
-	(langinfo.LocateExpression)(parsetree,SIZE_MAX,types);
+	(langinfo.LocateExpression)(parsetree,SIZE_MAX,*parse_tree::types);
 	if (starting_errors==zcc_errors.err_count())
 		{
 		while(parsetree.is_raw_list() &amp;&amp; 1==parsetree.size&lt;0&gt;())
 			parsetree.eval_to_arg&lt;0&gt;(0);
 		// end snip from Condense
 		// snip from CPreproc
-		if (!parsetree.is_atomic() &amp;&amp; !(langinfo.EvalParseTree)(parsetree,types))
+		if (!parsetree.is_atomic() &amp;&amp; !(langinfo.EvalParseTree)(parsetree,*parse_tree::types))
 			{
 			parsetree.destroy();	// efficiency
 			message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -12357,7 +12357,7 @@
 			src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
 			return;
 			}
-		(langinfo.PPHackTree)(parsetree,types);
+		(langinfo.PPHackTree)(parsetree,*parse_tree::types);
 		// final, when above is working properly
 		if (!parsetree.is_atomic())
 			{	//! \bug need test cases
@@ -12372,11 +12372,11 @@
 		// end snip from CPreproc
 
 		// handle top-level enumerators
-		if (is_noticed_enumerator(parsetree,types))
-			enumerator_to_integer_representation(parsetree,types);
+		if (is_noticed_enumerator(parsetree,*parse_tree::types))
+			enumerator_to_integer_representation(parsetree,*parse_tree::types);
 
 		bool is_true = false;
-		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true,types))
+		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true,*parse_tree::types))
 			{	//! \bug need test cases
 			parsetree.destroy();	// efficiency
 			message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -12475,7 +12475,7 @@
 }
 
 //! \throw std::bad_alloc
-static bool record_enum_values(parse_tree&amp; src, type_system&amp; types, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits&lt;const char* (*)(const char*, size_t)&gt;::function_ref_type echo_reserved_keyword, intlike_literal_to_VM_func&amp; intlike_literal_to_VM, func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type CondenseParseTree, func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree)
+static bool record_enum_values(parse_tree&amp; src, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits&lt;const char* (*)(const char*, size_t)&gt;::function_ref_type echo_reserved_keyword, intlike_literal_to_VM_func&amp; intlike_literal_to_VM, func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type CondenseParseTree, func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree)
 {
 	assert(enum_type_index);
 	assert(!active_namespace || *active_namespace);
@@ -12605,7 +12605,7 @@
 		char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[0].token.first,active_namespace,&quot;::&quot;) : NULL;
 		const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[0].token.first;
 		{
-		const type_system::enumerator_info* tmp = types.get_enumerator(fullname);
+		const type_system::enumerator_info* tmp = parse_tree::types-&gt;get_enumerator(fullname);
 		if (tmp)
 			{	// --do-what-i-mean could recover if the prior definition were identical
 				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined
@@ -12624,7 +12624,7 @@
 #if 0
 		// next proposed function call is a bit handwavish right now...
 		// C++0X 3.3.1p4: enumerator gets to hide class names and enum names, nothing else [in particular dies against typedefs and functions]
-		if (types.enum_already_defined(active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].token.first))
+		if (parse_tree::types-&gt;enum_already_defined(active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].token.first))
 			{	// -Wbackport warn in C++, fail in C
 			if (allow_empty)
 				{	// C++0X
@@ -12645,7 +12645,7 @@
 				return false;
 				}	
 			};
-		if (types.union_class_struct_already_declared(active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].token.first))
+		if (parse_tree::types-&gt;union_class_struct_already_declared(active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].token.first))
 			{	// -Wbackport warn in C++, fail in C
 			if (allow_empty)
 				{	// C++0X
@@ -12666,12 +12666,12 @@
 				return false;
 				}	
 			};
-		if (types.function_already_declared(active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].token.first))
+		if (parse_tree::types-&gt;function_already_declared(active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].token.first))
 			{	// C++: One Definition Rule
 			};
 #endif
 		{
-		const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* const tmp = types.get_typedef_CPP(src.data&lt;0&gt;()[i].index_tokens[0].token.first,active_namespace); 
+		const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* const tmp = parse_tree::types-&gt;get_typedef_CPP(src.data&lt;0&gt;()[i].index_tokens[0].token.first,active_namespace); 
 		if (tmp)
 			{	// C++: One Definition Rule
 				//! \test decl.C99/Error_enum_typedef.h, decl.C99/Error_enum_typedef.hpp 
@@ -12701,7 +12701,7 @@
 		value_copy(prior_value,latest_value);
 		{
 		bool value_is_nonnegative = true;
-		const promote_aux test(current_enumerator_type,types);
+		const promote_aux test(current_enumerator_type,*parse_tree::types);
 		if (test.is_signed &amp;&amp; latest_value.test(test.bitcount-1))
 			{
 			target_machine-&gt;signed_additive_inverse(latest_value,test.machine_type);
@@ -12718,15 +12718,15 @@
 		if (1&gt;=src.size&lt;0&gt;()-i)
 			{	// default-update
 			// handle type errors
-			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data&lt;0&gt;()[i].index_tokens[0],types))
+			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data&lt;0&gt;()[i].index_tokens[0],*parse_tree::types))
 				return false;
 			uchar_blob latest_value_copy;
 			latest_value_copy.init(0);
 			value_copy(latest_value_copy,latest_value);
 			if (active_namespace)
-				types.set_enumerator_def_CPP(src.data&lt;0&gt;()[i].index_tokens[0].token.first, active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types-&gt;set_enumerator_def_CPP(src.data&lt;0&gt;()[i].index_tokens[0].token.first, active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			else
-				types.set_enumerator_def(src.data&lt;0&gt;()[i].index_tokens[0].token.first,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types-&gt;set_enumerator_def(src.data&lt;0&gt;()[i].index_tokens[0].token.first,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			break;
 			}
 		// complete conversion
@@ -12735,15 +12735,15 @@
 		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
 		if (robust_token_is_char&lt;','&gt;(src.data&lt;0&gt;()[i+1]))
 			{	// would default-update
-			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data&lt;0&gt;()[i].index_tokens[0],types))
+			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data&lt;0&gt;()[i].index_tokens[0],*parse_tree::types))
 				return false;
 			uchar_blob latest_value_copy;
 			latest_value_copy.init(0);
 			value_copy(latest_value_copy,latest_value);
 			if (active_namespace)
-				types.set_enumerator_def_CPP(src.data&lt;0&gt;()[i].index_tokens[0].token.first, active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types-&gt;set_enumerator_def_CPP(src.data&lt;0&gt;()[i].index_tokens[0].token.first, active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			else
-				types.set_enumerator_def(src.data&lt;0&gt;()[i].index_tokens[0].token.first,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types-&gt;set_enumerator_def(src.data&lt;0&gt;()[i].index_tokens[0].token.first,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			i += 2;
 			continue;
 			};
@@ -12763,9 +12763,9 @@
 			};
 		{	// see if it's a compile-time constant
 		parse_tree_class tmp(src,origin,i-comma_overextended,0);
-		if (tmp.is_raw_list() &amp;&amp; !CondenseParseTree(tmp,types)) return false;
-		if (!EvalParseTree(tmp,types)) return false;
-		if (!intlike_literal_to_VM(latest_value,tmp,types))
+		if (tmp.is_raw_list() &amp;&amp; !CondenseParseTree(tmp,*parse_tree::types)) return false;
+		if (!EvalParseTree(tmp,*parse_tree::types)) return false;
+		if (!intlike_literal_to_VM(latest_value,tmp,*parse_tree::types))
 			{	//! \bug need test case
 			message_header(src.data&lt;0&gt;()[origin-2].index_tokens[0]);
 			INC_INFORM(ERR_STR);
@@ -12777,7 +12777,7 @@
 		if (allow_empty)
 			{	// C++
 			current_enumerator_type = tmp.type_code.base_type_index;
-			const promote_aux test(current_enumerator_type,types);
+			const promote_aux test(current_enumerator_type,*parse_tree::types);
 			if (test.is_signed &amp;&amp; latest_value.test(test.bitcount-1))
 				{	// negative
 				unsigned_var_int abs_latest_value(latest_value);
@@ -12882,8 +12882,8 @@
 				}
 			}
 		else{	// C
-			const promote_aux test(tmp.type_code.base_type_index,types);
-			const promote_aux dest_type(C_TYPE::INT,types);
+			const promote_aux test(tmp.type_code.base_type_index,*parse_tree::types);
+			const promote_aux dest_type(C_TYPE::INT,*parse_tree::types);
 			const bool is_negative = test.is_signed &amp;&amp; latest_value.test(test.bitcount-1);
 			if (is_negative)
 				target_machine-&gt;signed_additive_inverse(latest_value,test.machine_type);
@@ -12921,13 +12921,13 @@
 		latest_value_copy.init(0);
 		value_copy(latest_value_copy,latest_value);
 		if (active_namespace)
-			types.set_enumerator_def_CPP(src.data&lt;0&gt;()[origin-2].index_tokens[0].token.first, active_namespace,src.data&lt;0&gt;()[origin-2].index_tokens[0].logical_line,src.data&lt;0&gt;()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+			parse_tree::types-&gt;set_enumerator_def_CPP(src.data&lt;0&gt;()[origin-2].index_tokens[0].token.first, active_namespace,src.data&lt;0&gt;()[origin-2].index_tokens[0].logical_line,src.data&lt;0&gt;()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 		else
-			types.set_enumerator_def(src.data&lt;0&gt;()[origin-2].index_tokens[0].token.first,src.data&lt;0&gt;()[origin-2].index_tokens[0].logical_line,src.data&lt;0&gt;()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+			parse_tree::types-&gt;set_enumerator_def(src.data&lt;0&gt;()[origin-2].index_tokens[0].token.first,src.data&lt;0&gt;()[origin-2].index_tokens[0].logical_line,src.data&lt;0&gt;()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 		}
 		}
 	// now ok to crunch underlying type/machine representation
-	types.set_enum_underlying_type(enum_type_index,allow_empty ? base_enum_type : C_TYPE::INT);
+	parse_tree::types-&gt;set_enum_underlying_type(enum_type_index,allow_empty ? base_enum_type : C_TYPE::INT);
 	return true;
 }
 
@@ -12953,7 +12953,7 @@
 // will need: typedef map: identifier |-&gt; typespec record
 //! \todo check that the fact all literals are already legal-form is used
 //! \throw std::bad_alloc
-static void C99_ContextParse(parse_tree&amp; src,type_system&amp; types)
+static void C99_ContextParse(parse_tree&amp; src)
 {
 	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle in type_spec, which is required to be POD to allow C memory management:
 	// * indirection depth n (already have this in practice)
@@ -12978,7 +12978,7 @@
 		// C static assertion scanner
 		if (robust_token_is_string&lt;14&gt;(src.data&lt;0&gt;()[i],&quot;_Static_Assert&quot;))
 			{	// _Static_Assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CLexer-&gt;pp_support,i,&quot;control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)&quot;,NULL);
+			C99_CPP_handle_static_assertion(src,*CLexer-&gt;pp_support,i,&quot;control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)&quot;,NULL);
 			continue;
 			};
 		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
@@ -12986,21 +12986,22 @@
 		if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
 			{
 C99_union_specifier:
-			const type_system::type_index tmp = types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
+				assert(0&lt;parse_tree::types-&gt;use_count(tmp));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.h
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
@@ -13036,6 +13037,7 @@
 					//! \test zcc/decl.C99/Pass_union_forward_def.h
 					// remove from parse
 					src.DeleteNSlotsAt&lt;0&gt;(2,i);
+					assert(0&lt;parse_tree::types-&gt;use_count(tmp));
 					continue;					
 					}
 				// forward-declare
@@ -13056,21 +13058,22 @@
 		else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
 			{
 C99_struct_specifier:
-			const type_system::type_index tmp = types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
+				assert(0&lt;parse_tree::types-&gt;use_count(tmp));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
@@ -13125,10 +13128,11 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;union&quot;))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				assert(0&lt;parse_tree::types-&gt;use_count(tmp));
+				const C_union_struct_def* const fatal_def = parse_tree::types-&gt;get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_union_multidef.h
 					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -13150,12 +13154,12 @@
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.h
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
@@ -13163,13 +13167,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types-&gt;upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types-&gt;get_C_structdef(vr_tmp));
 			if (   1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
 				{	// no objects declared, trigger the const/volatile warnings
@@ -13192,10 +13196,11 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;struct&quot;))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				assert(0&lt;parse_tree::types-&gt;use_count(tmp));
+				const C_union_struct_def* const fatal_def = parse_tree::types-&gt;get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_struct_multidef.h
 					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -13217,12 +13222,12 @@
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or union must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl(src.data&lt;0&gt;()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
@@ -13230,13 +13235,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types-&gt;upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types-&gt;get_C_structdef(vr_tmp));
 			if (   1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
 				{	// no objects declared, trigger the const/volatile warnings
@@ -13260,21 +13265,21 @@
 		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl(&quot;&lt;unknown&gt;&quot;,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = parse_tree::types-&gt;register_structdecl(&quot;&lt;unknown&gt;&quot;,union_struct_decl::decl_union);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types-&gt;get_structdecl(tmp2));
 
 			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 			src.c_array&lt;0&gt;()[i].flags |= PARSE_UNION_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types-&gt;upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types-&gt;get_C_structdef(tmp2));
 
 			if (   1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
@@ -13305,21 +13310,21 @@
 		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl(&quot;&lt;unknown&gt;&quot;,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = parse_tree::types-&gt;register_structdecl(&quot;&lt;unknown&gt;&quot;,union_struct_decl::decl_struct);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types-&gt;get_structdecl(tmp2));
 
 			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 			src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const type qualifier (C99 6.7.3p4)&quot;,&quot;removing redundant volatile type qualifier (C99 6.7.3p4)&quot;);
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types-&gt;upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types-&gt;get_C_structdef(tmp2));
 
 			if (   1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
@@ -13352,7 +13357,7 @@
 			{	// C99 6.7.2.3: allowed only after name is defined
 			if (!(src.c_array&lt;0&gt;()[i].flags &amp; parse_tree::INVALID))
 				{
-				type_system::type_index tmp = types.get_id_enum(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
+				type_system::type_index tmp = parse_tree::types-&gt;get_id_enum(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
 				src.c_array&lt;0&gt;()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 				if (!tmp)
 					{	//! \test zcc/decl.C99/Error_enum_undef.h
@@ -13368,15 +13373,16 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;enum&quot;))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_enum(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_enum(src.data&lt;0&gt;()[i].index_tokens[1].token.first);
 			if (tmp)
 				{	//! \test zcc/decl.C99/Error_enum_multidef.h
+				assert(0&lt;parse_tree::types-&gt;use_count(tmp));
 				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM(&quot;'enum &quot;);
 				INC_INFORM(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].token.second);
 				INFORM(&quot;' already defined (C99 6.7.2.3p1)&quot;);
-				const enum_def* const tmp2 = types.get_enum_def(tmp);
+				const enum_def* const tmp2 = parse_tree::types-&gt;get_enum_def(tmp);
 				assert(tmp2);
 				message_header(*tmp2);
 				INFORM(&quot;prior definition here&quot;);
@@ -13387,9 +13393,9 @@
 				};
 			// enum-specifier doesn't have a specific declaration mode
 			//! \test zcc/decl.C99/Pass_enum_def.h
-			const type_system::type_index tmp2 = types.register_enum_def(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
-			assert(types.get_id_enum(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+			const type_system::type_index tmp2 = parse_tree::types-&gt;register_enum_def(src.data&lt;0&gt;()[i].index_tokens[1].token.first,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
+			assert(parse_tree::types-&gt;get_id_enum(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
 				return;
@@ -13398,8 +13404,8 @@
 		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;))
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = types.register_enum_def(&quot;&lt;unknown&gt;&quot;,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+			const type_system::type_index tmp = parse_tree::types-&gt;register_enum_def(&quot;&lt;unknown&gt;&quot;,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
+			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
 				return;
@@ -13419,7 +13425,7 @@
 		// ** C: const volatile restrict (but pointer type required for restrict)
 		// * atomic types have already been parsed, we need to catch the others
 		{
-		C99_decl_specifier_scanner declFind(types);
+		C99_decl_specifier_scanner declFind(*parse_tree::types);
 		size_t decl_count = src.get_span&lt;0&gt;(i,declFind);
 		if (decl_count)
 			{
@@ -13511,7 +13517,7 @@
 						{	// typedef
 						register_token&lt;0&gt;(*initdecl_identifier);
 						// verify that there is no prior definition
-						const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp = types.get_typedef(initdecl_identifier-&gt;index_tokens[0].token.first);
+						const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp = parse_tree::types-&gt;get_typedef(initdecl_identifier-&gt;index_tokens[0].token.first);
 						if (tmp)
 							{
 							if (bootstrap==tmp-&gt;first)
@@ -13544,7 +13550,7 @@
 							// do not re-register if there is a prior definition
 							}
 						else{	// prepare to register this with types object
-							const type_system::enumerator_info* tmp2 = types.get_enumerator(initdecl_identifier-&gt;index_tokens[0].token.first);
+							const type_system::enumerator_info* tmp2 = parse_tree::types-&gt;get_enumerator(initdecl_identifier-&gt;index_tokens[0].token.first);
 							if (tmp2)
 								{	//! \test zcc/decl.C99/Error_typedef_enum.h
 								message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -13557,7 +13563,7 @@
 								zcc_errors.inc_error();
 								return;
 								}
-							types.set_typedef(initdecl_identifier-&gt;index_tokens[0].token.first,initdecl_identifier-&gt;index_tokens[0].src_filename,initdecl_identifier-&gt;index_tokens[0].logical_line.first,bootstrap);
+							parse_tree::types-&gt;set_typedef(initdecl_identifier-&gt;index_tokens[0].token.first,initdecl_identifier-&gt;index_tokens[0].src_filename,initdecl_identifier-&gt;index_tokens[0].logical_line.first,bootstrap);
 							}
 						}
 #if 0
@@ -13754,7 +13760,7 @@
 // handle namespaces or else
 //! \todo check that the fact all literals are already legal-form is used
 //! \throw std::bad_alloc
-static void CPP_ParseNamespace(parse_tree&amp; src,type_system&amp; types,const char* const active_namespace)
+static void CPP_ParseNamespace(parse_tree&amp; src,const char* const active_namespace)
 {
 	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle
 	// * indirection depth n (already have this in practice)
@@ -13789,7 +13795,7 @@
 		// C++ static assertion scanner
 		if (robust_token_is_string&lt;13&gt;(src.data&lt;0&gt;()[i],&quot;static_assert&quot;))
 			{	// static_assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CPlusPlusLexer-&gt;pp_support,i,&quot;control expression for static assertion must be a constant convertible to bool (C++0X 7p4)&quot;,active_namespace);
+			C99_CPP_handle_static_assertion(src,*CPlusPlusLexer-&gt;pp_support,i,&quot;control expression for static assertion must be a constant convertible to bool (C++0X 7p4)&quot;,active_namespace);
 			continue;
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
@@ -13797,7 +13803,7 @@
 		if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
 			{
 CPP_union_specifier:
-			const type_system::type_index tmp = types.get_id_union_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_union_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
@@ -13806,12 +13812,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
@@ -13866,7 +13872,7 @@
 		else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
 			{
 CPP_struct_specifier:				
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
@@ -13875,12 +13881,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
@@ -13936,7 +13942,7 @@
 		else if (is_C99_named_specifier(src.data&lt;0&gt;()[i],&quot;class&quot;))
 			{
 CPP_class_specifier:
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);
@@ -13945,12 +13951,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
@@ -14005,10 +14011,10 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;union&quot;))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_union_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_union_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				const C_union_struct_def* const fatal_def = parse_tree::types-&gt;get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_union_multidef.hpp
 					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -14030,12 +14036,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
@@ -14043,13 +14049,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types-&gt;upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types-&gt;get_id_union(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types-&gt;get_C_structdef(vr_tmp));
 			if (   1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
 				{	// check for forward-declaration here
@@ -14072,10 +14078,10 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;struct&quot;))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				const C_union_struct_def* const fatal_def = parse_tree::types-&gt;get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
 					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -14097,12 +14103,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
@@ -14110,13 +14116,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types-&gt;upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types-&gt;get_C_structdef(vr_tmp));
 			if (   1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
 				{	// check for forward-declaration here
@@ -14139,10 +14145,10 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data&lt;0&gt;()[i],&quot;class&quot;))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types-&gt;get_id_struct_class_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				const C_union_struct_def* const fatal_def = parse_tree::types-&gt;get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_class_multidef.hpp
 					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -14164,12 +14170,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types-&gt;register_structdecl_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first));
+				assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types-&gt;get_structdecl(tmp2));
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 				src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
@@ -14177,13 +14183,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types-&gt;upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types-&gt;get_id_struct_class(src.data&lt;0&gt;()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types-&gt;get_C_structdef(vr_tmp));
 			if (   1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
 				{	// check for forward-declaration here
@@ -14207,22 +14213,22 @@
 		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;union&quot;))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = parse_tree::types-&gt;register_structdecl_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,union_struct_decl::decl_union);
 			assert(tmp2);
 
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types-&gt;get_structdecl(tmp2));
 			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 			src.c_array&lt;0&gt;()[i].flags |= PARSE_UNION_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types-&gt;upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types-&gt;get_C_structdef(tmp2));
 
 			if (	1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; 	robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
@@ -14253,20 +14259,20 @@
 		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;struct&quot;))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = parse_tree::types-&gt;register_structdecl_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,union_struct_decl::decl_struct);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types-&gt;get_structdecl(tmp2));
 			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 			src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types-&gt;upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types-&gt;get_C_structdef(tmp2));
 
 			if (	1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; 	robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
@@ -14297,20 +14303,20 @@
 		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;class&quot;))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,union_struct_decl::decl_class);
+			const type_system::type_index tmp2 = parse_tree::types-&gt;register_structdecl_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,union_struct_decl::decl_class);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types-&gt;get_structdecl(tmp2));
 			src.c_array&lt;0&gt;()[i].type_code.set_type(tmp2);
 			src.c_array&lt;0&gt;()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,&quot;removing redundant const cv-qualifier (C++0X 7.1.6.1p1)&quot;,&quot;removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)&quot;);
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types-&gt;get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types-&gt;upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types-&gt;get_C_structdef(tmp2));
 
 			if (	1&lt;src.size&lt;0&gt;()-i
 				&amp;&amp; 	robust_token_is_char&lt;';'&gt;(src.data&lt;0&gt;()[i+1]))
@@ -14344,7 +14350,7 @@
 			{
 			if (!(src.c_array&lt;0&gt;()[i].flags &amp; parse_tree::INVALID))
 				{
-				type_system::type_index tmp = types.get_id_enum_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
+				type_system::type_index tmp = parse_tree::types-&gt;get_id_enum_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace);
 				src.c_array&lt;0&gt;()[i].type_code.set_type(tmp);	// C++: enums are own type
 				if (!tmp)
 					{	// this belongs elsewhere
@@ -14364,7 +14370,7 @@
 			{	// can only define once
 			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;) : NULL;
 			const char* fullname = namespace_name ? namespace_name : src.data&lt;0&gt;()[i].index_tokens[1].token.first;
-			type_system::type_index tmp = types.get_id_enum(fullname);
+			type_system::type_index tmp = parse_tree::types-&gt;get_id_enum(fullname);
 			if (tmp)
 				{	//! \test zcc/decl.C99/Error_enum_multidef.hpp
 				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
@@ -14373,7 +14379,7 @@
 				INC_INFORM(fullname);
 				free(namespace_name);
 				INFORM(&quot;' already defined (C++98 3.2p1)&quot;);
-				const enum_def* const tmp2 = types.get_enum_def(tmp);
+				const enum_def* const tmp2 = parse_tree::types-&gt;get_enum_def(tmp);
 				assert(tmp2);
 				message_header(*tmp2);
 				INFORM(&quot;prior definition here&quot;);
@@ -14385,9 +14391,9 @@
 			free(namespace_name);
 			//! \test zcc/decl.C99/Pass_enum_def.hpp
 			// enum-specifier doesn't have a specific declaration mode
-			const type_system::type_index tmp2 = types.register_enum_def_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
-			assert(types.get_id_enum_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,tmp2,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+			const type_system::type_index tmp2 = parse_tree::types-&gt;register_enum_def_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,src.data&lt;0&gt;()[i].index_tokens[1].logical_line,src.data&lt;0&gt;()[i].index_tokens[1].src_filename);
+			assert(parse_tree::types-&gt;get_id_enum_CPP(src.data&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),tmp2,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 				{
 				INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
 				return;
@@ -14396,8 +14402,8 @@
 		else if (is_C99_anonymous_specifier(src.data&lt;0&gt;()[i],&quot;enum&quot;))
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = types.register_enum_def_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),types,tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+			const type_system::type_index tmp = parse_tree::types-&gt;register_enum_def_CPP(&quot;&lt;unknown&gt;&quot;,active_namespace,src.data&lt;0&gt;()[i].index_tokens[0].logical_line,src.data&lt;0&gt;()[i].index_tokens[0].src_filename);
+			if (!record_enum_values(*src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;(),tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 				{
 				INFORM(&quot;enumeration not fully parsed: stopping to prevent spurious errors&quot;);
 				return;
@@ -14447,11 +14453,11 @@
 					strcpy(new_active_namespace,active_namespace);
 					strcat(new_active_namespace,&quot;::&lt;unknown&gt;&quot;);
 					strcat(new_active_namespace,&quot;&quot;);
-					CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],types,new_active_namespace);
+					CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],new_active_namespace);
 					free(new_active_namespace);
 					}
 				else{
-					CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],types,&quot;&lt;unknown&gt;&quot;);
+					CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],&quot;&lt;unknown&gt;&quot;);
 					}
 				++i;
 				continue;
@@ -14503,12 +14509,12 @@
 			if (NULL==active_namespace)
 				{	// global
 					//! \todo expand namespace aliases
-				CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],types,src.c_array&lt;0&gt;()[i].index_tokens[1].token.first);
+				CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],src.c_array&lt;0&gt;()[i].index_tokens[1].token.first);
 				}
 			else{	// nested
 					//! \todo expand namespace aliases
 				char* const new_active_namespace = type_system::namespace_concatenate(src.c_array&lt;0&gt;()[i].index_tokens[1].token.first,active_namespace,&quot;::&quot;);
-				CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],types,new_active_namespace);
+				CPP_ParseNamespace(src.c_array&lt;0&gt;()[i].c_array&lt;2&gt;()[0],new_active_namespace);
 				free(new_active_namespace);
 				}
 			++i;
@@ -14533,7 +14539,7 @@
 		// * atomic types have already been parsed, we need to catch the others
 		// * C++0x: auto is a possible type!
 		{
-		CPP0X_decl_specifier_scanner declFind(types,active_namespace);
+		CPP0X_decl_specifier_scanner declFind(*parse_tree::types,active_namespace);
 		size_t decl_count = src.destructive_get_span&lt;0&gt;(i,declFind);
 		if (decl_count)
 			{
@@ -14637,7 +14643,7 @@
 
 						// verify that there is no prior definition
 						// we're fine redeclaring at a different level, so do not use full C++ typedef lookup
-						const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp = types.get_typedef(fullname);					
+						const zaimoni::POD_triple&lt;type_spec,const char*,size_t&gt;* tmp = parse_tree::types-&gt;get_typedef(fullname);					
 						if (tmp)
 							{
 							if (bootstrap==tmp-&gt;first)
@@ -14672,7 +14678,7 @@
 							}
 						else{	// register this with types object
 							free(namespace_name);
-							const type_system::enumerator_info* tmp2 = types.get_enumerator_CPP(initdecl_identifier-&gt;index_tokens[0].token.first,active_namespace);
+							const type_system::enumerator_info* tmp2 = parse_tree::types-&gt;get_enumerator_CPP(initdecl_identifier-&gt;index_tokens[0].token.first,active_namespace);
 							if (tmp2)
 								{	//! \test zcc/decl.C99/Error_typedef_enum.hpp
 									//! \test zcc/decl.C99/Error_typedef_enum2.hpp
@@ -14686,7 +14692,7 @@
 								zcc_errors.inc_error();
 								return;
 								}							
-							types.set_typedef_CPP(initdecl_identifier-&gt;index_tokens[0].token.first,active_namespace,initdecl_identifier-&gt;index_tokens[0].src_filename,initdecl_identifier-&gt;index_tokens[0].logical_line.first,bootstrap);
+							parse_tree::types-&gt;set_typedef_CPP(initdecl_identifier-&gt;index_tokens[0].token.first,active_namespace,initdecl_identifier-&gt;index_tokens[0].src_filename,initdecl_identifier-&gt;index_tokens[0].logical_line.first,bootstrap);
 							}
 						}
 #if 0
@@ -14736,9 +14742,9 @@
 }
 
 //! \throw std::bad_alloc
-static void CPP_ContextParse(parse_tree&amp; src,type_system&amp; types)
+static void CPP_ContextParse(parse_tree&amp; src)
 {
-	CPP_ParseNamespace(src,types,NULL);
+	CPP_ParseNamespace(src,NULL);
 }
 #/*cut-cpp*/
 

Modified: trunk/CSupport.hpp
===================================================================
--- trunk/CSupport.hpp	2010-11-02 03:01:19 UTC (rev 528)
+++ trunk/CSupport.hpp	2010-11-02 08:54:25 UTC (rev 529)
@@ -119,7 +119,7 @@
 	func_traits&lt;const char* (*)(const char* x,size_t x_len)&gt;::function_ref_type EchoReservedKeyword;
 	func_traits&lt;const char* (*)(const char* x,size_t x_len)&gt;::function_ref_type EchoReservedSymbol;
 	func_traits&lt;void (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type ContextFreeParse;		// return true iff no errors
-	func_traits&lt;void (*)(parse_tree&amp;,type_system&amp;)&gt;::function_ref_type ContextParse;		// return true iff no errors
+	func_traits&lt;void (*)(parse_tree&amp;)&gt;::function_ref_type ContextParse;		// return true iff no errors
 	// zcc 0.0.3
 	func_traits&lt;void (*)(parse_tree&amp;,const size_t,const type_system&amp;)&gt;::function_ref_type LocateExpression;
 	func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;,const type_system&amp;)&gt;::function_ref_type LiteralConvertsToBool;

Modified: trunk/ZParser.cpp
===================================================================
--- trunk/ZParser.cpp	2010-11-02 03:01:19 UTC (rev 528)
+++ trunk/ZParser.cpp	2010-11-02 08:54:25 UTC (rev 529)
@@ -174,7 +174,7 @@
 	assert(ParsedList[0]-&gt;syntax_ok());
 #endif
 	die_on_parse_errors();
-	lang.pp_support-&gt;ContextParse(*ParsedList[0],types);
+	lang.pp_support-&gt;ContextParse(*ParsedList[0]);
 #ifndef ZAIMONI_FORCE_ISO
 	assert(ParsedList[0]-&gt;syntax_ok());
 #endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000295.html">[Zcplusplus-commits] r528 - in trunk: . tools
</A></li>
	<LI>Next message: <A HREF="000297.html">[Zcplusplus-commits] r530 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#296">[ date ]</a>
              <a href="thread.html#296">[ thread ]</a>
              <a href="subject.html#296">[ subject ]</a>
              <a href="author.html#296">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/zcplusplus-commits">More information about the Zcplusplus-commits
mailing list</a><br>
</body></html>
