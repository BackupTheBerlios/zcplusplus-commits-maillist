From zaimoni at mail.berlios.de  Tue Nov  2 04:01:19 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue,  2 Nov 2010 04:01:19 +0100
Subject: [Zcplusplus-commits] r528 - in trunk: . tools
Message-ID: <20101102030120.31AA5481115@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-02 04:01:19 +0100 (Tue, 02 Nov 2010)
New Revision: 528

Added:
   trunk/type_spec_pp.cpp
Modified:
   trunk/MakeMake.cfg
   trunk/POSIX.dep
   trunk/tools/POSIX.inc
   trunk/type_spec.cpp
Log:
allow compiler to auto-update use counts for types

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2010-10-31 20:55:28 UTC (rev 527)
+++ trunk/MakeMake.cfg	2010-11-02 03:01:19 UTC (rev 528)
@@ -1,5 +1,5 @@
 ########
-ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system_pp','ParseTree','type_spec','CSupport_pp','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','end_nl','load_src','CPreproc_pp','CPreproc_autogen_pp'),
+ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system_pp','ParseTree','type_spec_pp','CSupport_pp','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','end_nl','load_src','CPreproc_pp','CPreproc_autogen_pp'),
 				'zcc':('zcc','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','end_nl','load_src','CPreproc','CPreproc_autogen','ZParser')}
 MainPrograms = ['z_cpp','zcc']
 

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-10-31 20:55:28 UTC (rev 527)
+++ trunk/POSIX.dep	2010-11-02 03:01:19 UTC (rev 528)
@@ -1,5 +1,5 @@
-OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system_pp.o ParseTree.o type_spec.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
-OBJECTS_Z_CPP_LINK_PRIORITY = type_system_pp.o CSupport_pp.o CPreproc_pp.o CPreproc_autogen_pp.o ParseTree.o type_spec.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o uchar_blob.o CPUInfo.o unsigned_var_int.o z_cpp.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
+OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system_pp.o ParseTree.o type_spec_pp.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
+OBJECTS_Z_CPP_LINK_PRIORITY = type_spec_pp.o CPreproc_pp.o type_system_pp.o CSupport_pp.o CPreproc_autogen_pp.o ParseTree.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o uchar_blob.o CPUInfo.o unsigned_var_int.o z_cpp.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
 
 OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
 OBJECTS_ZCC_LINK_PRIORITY = type_system.o CSupport.o CPreproc.o CPreproc_autogen.o ZParser.o ParseTree.o type_spec.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o uchar_blob.o CPUInfo.o unsigned_var_int.o zcc.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
@@ -18,7 +18,7 @@
 struct_type.o: struct_type.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp
 type_system_pp.o: type_system_pp.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
+type_spec_pp.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system_pp.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uc
 har_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -36,6 +36,7 @@
 CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h type_system.hpp Zaimoni.STL/Perl_localize.hpp
 type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
+type_spec.o: type_spec.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 CSupport.o: CSupport.hpp _CSupport3.hpp _CSupport4.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp kleene_star.hpp cond_act.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_l
 t.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp _CSupport3.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/Perl_localize.hpp DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logi
 c_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp

Modified: trunk/tools/POSIX.inc
===================================================================
--- trunk/tools/POSIX.inc	2010-10-31 20:55:28 UTC (rev 527)
+++ trunk/tools/POSIX.inc	2010-11-02 03:01:19 UTC (rev 528)
@@ -22,7 +22,8 @@
 C_MACROS = 
 CXX_MACROS = -D__STDC_LIMIT_MACROS
 
-# build rules
+# maintainer-mode build rules for derived files
+# PYTHON variable does require configuration when moved to another machine
 PYTHON = c:\Python26\python
 SELECTIVE_CUT = tools\selective_cut.py
 SUPPRESS_CUT = tools\suppress_cut.py
@@ -62,6 +63,10 @@
 	$(PYTHON) $(SELECTIVE_CUT) nocpp CSupport.cpp.alt2 CSupport.cpp.alt 
 	if cmp -s CSupport.cpp CSupport.cpp.alt; then rm CSupport.cpp.alt ; else mv CSupport.cpp.alt CSupport.cpp; fi
 	rm CSupport.cpp.alt2
+
+type_spec_pp.cpp: type_spec.cpp
+	$(PYTHON) $(SELECTIVE_CUT) cpp type_spec.cpp type_spec_pp.cpp.alt 
+	if cmp -s type_spec_pp.cpp type_spec_pp.cpp.alt; then rm type_spec_pp.cpp.alt ; else mv type_spec_pp.cpp.alt type_spec_pp.cpp; fi
 	
 type_system_pp.hpp: type_system.hpp.in
 	$(PYTHON) $(SELECTIVE_CUT) cpp type_system.hpp.in type_system_pp.hpp.alt2 

Modified: trunk/type_spec.cpp
===================================================================
--- trunk/type_spec.cpp	2010-10-31 20:55:28 UTC (rev 527)
+++ trunk/type_spec.cpp	2010-11-02 03:01:19 UTC (rev 528)
@@ -2,6 +2,10 @@
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
 #include "type_spec.hpp"
+#/*cut-cpp*/
+#include "ParseTree.hpp"
+#include "type_system.hpp"
+#/*cut-cpp*/
 
 #include "Zaimoni.STL/MetaRAM2.hpp"
 using namespace zaimoni;
@@ -81,6 +85,13 @@
 		dest = tmp;
 		}
 	else{	// non-enlarging doesn't throw
+#/*cut-cpp*/
+		if (parse_tree::types)
+			{
+			parse_tree::types->unuse_type(dest.base_type_index);
+			parse_tree::types->use_type(src.base_type_index);
+			}
+#/*cut-cpp*/
 		dest.base_type_index = src.base_type_index;
 		dest.set_pointer_power(src.pointer_power);
 		if (dest.q_vector.size()==src.q_vector.size())
@@ -123,6 +134,13 @@
 #endif
 	if (0==pointer_power) return false;
 	assert(lvalue & q_vector.data()[pointer_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
+#/*cut-cpp*/
+	if (parse_tree::types)
+		{
+		parse_tree::types->unuse_type(dest.base_type_index);
+		parse_tree::types->use_type(base_type_index);
+		}
+#/*cut-cpp*/
 	dest.base_type_index = base_type_index; 
 	dest.set_pointer_power(pointer_power-1); // lost a level of indirection
 	memmove(dest.q_vector.c_array(),q_vector.data(),dest.q_vector.size());
@@ -149,6 +167,9 @@
 	FREE_AND_NULL(extent_vector);
 	q_vector.resize(1);
 	q_vector.front() = '\0';
+#/*cut-cpp*/
+	if (parse_tree::types) parse_tree::types->unuse_type(base_type_index);
+#/*cut-cpp*/
 	base_type_index = 0;
 	pointer_power = 0;
 }
@@ -161,6 +182,13 @@
 	FREE_AND_NULL(extent_vector);
 	q_vector.resize(1);
 	q_vector.front() = '\0';
+#/*cut-cpp*/
+	if (parse_tree::types)
+		{
+		parse_tree::types->unuse_type(base_type_index);
+		parse_tree::types->use_type(_base_type_index);
+		};
+#/*cut-cpp*/
 	base_type_index = _base_type_index;
 	pointer_power = 0;
 }

Added: trunk/type_spec_pp.cpp
===================================================================
--- trunk/type_spec_pp.cpp	                        (rev 0)
+++ trunk/type_spec_pp.cpp	2010-11-02 03:01:19 UTC (rev 528)
@@ -0,0 +1,226 @@
+// type_spec.cpp
+// (C)2009, 2010 Kenneth Boyd, license: MIT.txt
+
+#include "type_spec.hpp"
+
+#include "Zaimoni.STL/MetaRAM2.hpp"
+using namespace zaimoni;
+
+//! \throw std::bad_alloc only if _size>pointer_power
+void type_spec::set_pointer_power(size_t _size)
+{
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
+	if (_size==pointer_power) return;
+	assert(0<_size);
+	const bool shrinking = _size<pointer_power;
+	const size_t old_ptr_power = pointer_power;
+	// zaimoni::_resize always succeeds when shrinking; if it fails, then reverting q_vector's resize 
+	// is a shrinking operation which always succeeds.
+	q_vector.resize(_size+1);
+#ifndef ZAIMONI_FORCE_ISO
+	if (!zaimoni::_resize(extent_vector,_size))
+#else
+	if (!zaimoni::_resize(extent_vector,pointer_power,_size))
+#endif
+		{
+		q_vector.resize(old_ptr_power+1);
+		throw std::bad_alloc();
+		};
+#ifndef ZAIMONI_FORCE_ISO
+	pointer_power = _size;
+#endif
+	if (!shrinking)
+		{
+		memset(extent_vector+old_ptr_power,0,sizeof(uintmax_t)*(_size-old_ptr_power));
+		size_t i = old_ptr_power;
+		while(i<_size) q_vector.c_array()[i++] = lvalue;
+		// q_vector.second[new_ptr_power] = '\0';	// handled by uchar_blob
+		};
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
+}
+
+//! \throw std::bad_alloc
+void type_spec::make_C_array(uintmax_t _size)
+{	// can't count on type_spec being initialized correctly beforehand
+	// (could be 0 coming in, but then pointer_power=0 as well coming in)
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
+	set_pointer_power(pointer_power+1);
+	q_vector.back() |= _array;
+	q_vector.c_array()[q_vector.size()-2] |= lvalue;
+	extent_vector[pointer_power-1] = _size;
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
+}
+
+
+// XXX properly operator= in C++, but type_spec has to be POD
+// ACID
+//! \throw std::bad_alloc only if dest.pointer_power<src.pointer_power 
+void value_copy(type_spec& dest,const type_spec& src)
+{	// again, can't count on src.syntax_ok()
+#ifndef ZAIMONI_FORCE_ISO
+	assert(src.syntax_ok());
+#endif
+	if (dest.pointer_power<src.pointer_power)
+		{	// set_pointer_power can throw anyway, so be ACID
+		type_spec tmp;
+		tmp.clear();
+		tmp.set_type(src.base_type_index);
+		tmp.set_pointer_power(src.pointer_power);
+		if (tmp.q_vector.size()==src.q_vector.size())
+			value_copy(tmp.q_vector,src.q_vector);
+		if (0<src.pointer_power) memmove(tmp.extent_vector,src.extent_vector,src.pointer_power*sizeof(uintmax_t));
+		dest.destroy();
+		dest = tmp;
+		}
+	else{	// non-enlarging doesn't throw
+		dest.base_type_index = src.base_type_index;
+		dest.set_pointer_power(src.pointer_power);
+		if (dest.q_vector.size()==src.q_vector.size())
+			value_copy(dest.q_vector,src.q_vector);
+		if (0<src.pointer_power) memmove(dest.extent_vector,src.extent_vector,src.pointer_power*sizeof(uintmax_t));
+		}
+#ifndef ZAIMONI_FORCE_ISO
+	assert(dest.syntax_ok());
+#endif
+}
+
+bool type_spec::dereference()
+{
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
+	if (0==pointer_power) return false;
+//	q_vector.c_array()[old_ptr_power] = '\0';	// redundant, wiped by q_vector.resize()
+	assert(lvalue & q_vector.data()[pointer_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
+	q_vector.resize(pointer_power);	// lost a level of indirection
+#if ZAIMONI_REALLOC_TO_ZERO_IS_NULL
+	extent_vector = REALLOC(extent_vector,--pointer_power*sizeof(*extent_vector));
+#else
+	if (0== --pointer_power)
+		FREE_AND_NULL(extent_vector);
+	else
+		extent_vector = REALLOC(extent_vector,pointer_power*sizeof(*extent_vector));
+#endif
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
+	return true;
+}
+
+//! \throw std::bad_alloc only if pointer_power-1>dest.pointer_power
+bool type_spec::dereference(type_spec& dest) const
+{
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
+	if (0==pointer_power) return false;
+	assert(lvalue & q_vector.data()[pointer_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
+	dest.base_type_index = base_type_index; 
+	dest.set_pointer_power(pointer_power-1); // lost a level of indirection
+	memmove(dest.q_vector.c_array(),q_vector.data(),dest.q_vector.size());
+	if (0<dest.pointer_power) memmove(dest.extent_vector,extent_vector,dest.pointer_power*sizeof(*extent_vector));
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
+	return true;
+}
+
+void type_spec::clear()
+{
+	base_type_index = 0;
+	pointer_power = 0;
+	q_vector.init(1);
+	extent_vector = NULL;
+}
+
+void type_spec::destroy()
+{
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
+	FREE_AND_NULL(extent_vector);
+	q_vector.resize(1);
+	q_vector.front() = '\0';
+	base_type_index = 0;
+	pointer_power = 0;
+}
+
+void type_spec::set_type(size_t _base_type_index)
+{
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
+	FREE_AND_NULL(extent_vector);
+	q_vector.resize(1);
+	q_vector.front() = '\0';
+	base_type_index = _base_type_index;
+	pointer_power = 0;
+}
+
+bool type_spec::operator==(const type_spec& rhs) const
+{
+	return 	base_type_index==rhs.base_type_index
+		&&	pointer_power==rhs.pointer_power
+		&&  q_vector==rhs.q_vector
+		&& (0==pointer_power || !memcmp(extent_vector,rhs.extent_vector,sizeof(uintmax_t)*pointer_power));
+}
+
+bool type_spec::typeid_equal(const type_spec& rhs) const
+{
+	if (   base_type_index==rhs.base_type_index
+		&& pointer_power==rhs.pointer_power)
+		{	// C++0X 5.2.8p5: lose the topmost level of 
+			// C++ cv-qualification (extending to C would be 
+			// C type-qualifiers)
+		if (0==pointer_power) return true;
+		if (	!memcmp(extent_vector,rhs.extent_vector,sizeof(uintmax_t)*pointer_power)
+			&&	!memcmp(q_vector.data(),rhs.q_vector.data(),pointer_power))
+			return true;
+		}
+	return false;
+}
+
+void type_spec::MoveInto(type_spec& dest)
+{
+	dest.destroy();
+	dest = *this;
+	clear();
+}
+
+void type_spec::OverwriteInto(type_spec& dest)
+{
+	dest = *this;
+	clear();
+}
+
+#ifndef ZAIMONI_FORCE_ISO
+bool type_spec::syntax_ok() const
+{
+	if (0==q_vector.size() && 0==pointer_power && !extent_vector) return true;
+	if (pointer_power>=q_vector.size() || pointer_power+1!=q_vector.size()) return false;
+	if (0==pointer_power)
+		{
+		if (extent_vector) return false;
+		}
+	else if (!_memory_block_start_valid(extent_vector))
+		return false;
+	return true;
+}
+
+bool type_spec::entangled_with(const type_spec& x) const
+{
+	if (extent_vector && x.extent_vector && extent_vector==x.extent_vector)
+		return true;
+	//! \todo Law of Demeter would delegate the entangled check for q_vector
+	return false;
+}
+#endif
+



From zaimoni at mail.berlios.de  Tue Nov  2 09:54:25 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue,  2 Nov 2010 09:54:25 +0100
Subject: [Zcplusplus-commits] r529 - trunk
Message-ID: <20101102085426.40DDD480C33@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-02 09:54:25 +0100 (Tue, 02 Nov 2010)
New Revision: 529

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/CSupport.hpp
   trunk/ZParser.cpp
Log:
adjust context parsing to explicitly use global parse_tree::types rather than effectively pass it in as a parameter

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-02 03:01:19 UTC (rev 528)
+++ trunk/CSupport.cpp	2010-11-02 08:54:25 UTC (rev 529)
@@ -12135,7 +12135,7 @@
 }
 
 //! \throw std::bad_alloc()
-static void C99_CPP_handle_static_assertion(parse_tree& src,type_system& types,PP_auxfunc& langinfo,const size_t i,const char* const err,const char* const active_namespace)
+static void C99_CPP_handle_static_assertion(parse_tree& src,PP_auxfunc& langinfo,const size_t i,const char* const err,const char* const active_namespace)
 {
 	assert(err && *err);
 	// find the next ';'
@@ -12190,20 +12190,20 @@
 	zaimoni::autotransform_n<void (*)(parse_tree&,const parse_tree&)>(parsetree.c_array<0>(),src.data<0>()[i+1].data<0>(),k,value_copy);
 	// type all enumerators now to make life reasonable later on for the expression-parser
 	size_t enum_scan = k;
-	do	notice_enumerator_CPP(parsetree.c_array<0>()[--enum_scan],types,active_namespace);
+	do	notice_enumerator_CPP(parsetree.c_array<0>()[--enum_scan],*parse_tree::types,active_namespace);
 	while(0<enum_scan);
 	}
 	// init above correctly
 	// snip from Condense
 	const size_t starting_errors = zcc_errors.err_count();
-	(langinfo.LocateExpression)(parsetree,SIZE_MAX,types);
+	(langinfo.LocateExpression)(parsetree,SIZE_MAX,*parse_tree::types);
 	if (starting_errors==zcc_errors.err_count())
 		{
 		while(parsetree.is_raw_list() && 1==parsetree.size<0>())
 			parsetree.eval_to_arg<0>(0);
 		// end snip from Condense
 		// snip from CPreproc
-		if (!parsetree.is_atomic() && !(langinfo.EvalParseTree)(parsetree,types))
+		if (!parsetree.is_atomic() && !(langinfo.EvalParseTree)(parsetree,*parse_tree::types))
 			{
 			parsetree.destroy();	// efficiency
 			message_header(src.data<0>()[i].index_tokens[0]);
@@ -12213,7 +12213,7 @@
 			src.DeleteNSlotsAt<0>(j-i+1,i);
 			return;
 			}
-		(langinfo.PPHackTree)(parsetree,types);
+		(langinfo.PPHackTree)(parsetree,*parse_tree::types);
 		// final, when above is working properly
 		if (!parsetree.is_atomic())
 			{	//! \bug need test cases
@@ -12228,11 +12228,11 @@
 		// end snip from CPreproc
 
 		// handle top-level enumerators
-		if (is_noticed_enumerator(parsetree,types))
-			enumerator_to_integer_representation(parsetree,types);
+		if (is_noticed_enumerator(parsetree,*parse_tree::types))
+			enumerator_to_integer_representation(parsetree,*parse_tree::types);
 
 		bool is_true = false;
-		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true,types))
+		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true,*parse_tree::types))
 			{	//! \bug need test cases
 			parsetree.destroy();	// efficiency
 			message_header(src.data<0>()[i].index_tokens[0]);
@@ -12331,7 +12331,7 @@
 }
 
 //! \throw std::bad_alloc
-static bool record_enum_values(parse_tree& src, type_system& types, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits<const char* (*)(const char*, size_t)>::function_ref_type echo_reserved_keyword, intlike_literal_to_VM_func& intlike_literal_to_VM, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type CondenseParseTree, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
+static bool record_enum_values(parse_tree& src, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits<const char* (*)(const char*, size_t)>::function_ref_type echo_reserved_keyword, intlike_literal_to_VM_func& intlike_literal_to_VM, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type CondenseParseTree, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
 {
 	assert(enum_type_index);
 	assert(!active_namespace || *active_namespace);
@@ -12461,7 +12461,7 @@
 		char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[0].token.first,active_namespace,"::") : NULL;
 		const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[0].token.first;
 		{
-		const type_system::enumerator_info* tmp = types.get_enumerator(fullname);
+		const type_system::enumerator_info* tmp = parse_tree::types->get_enumerator(fullname);
 		if (tmp)
 			{	// --do-what-i-mean could recover if the prior definition were identical
 				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined
@@ -12480,7 +12480,7 @@
 #if 0
 		// next proposed function call is a bit handwavish right now...
 		// C++0X 3.3.1p4: enumerator gets to hide class names and enum names, nothing else [in particular dies against typedefs and functions]
-		if (types.enum_already_defined(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
+		if (parse_tree::types->enum_already_defined(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
 			{	// -Wbackport warn in C++, fail in C
 			if (allow_empty)
 				{	// C++0X
@@ -12501,7 +12501,7 @@
 				return false;
 				}	
 			};
-		if (types.union_class_struct_already_declared(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
+		if (parse_tree::types->union_class_struct_already_declared(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
 			{	// -Wbackport warn in C++, fail in C
 			if (allow_empty)
 				{	// C++0X
@@ -12522,12 +12522,12 @@
 				return false;
 				}	
 			};
-		if (types.function_already_declared(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
+		if (parse_tree::types->function_already_declared(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
 			{	// C++: One Definition Rule
 			};
 #endif
 		{
-		const zaimoni::POD_triple<type_spec,const char*,size_t>* const tmp = types.get_typedef_CPP(src.data<0>()[i].index_tokens[0].token.first,active_namespace); 
+		const zaimoni::POD_triple<type_spec,const char*,size_t>* const tmp = parse_tree::types->get_typedef_CPP(src.data<0>()[i].index_tokens[0].token.first,active_namespace); 
 		if (tmp)
 			{	// C++: One Definition Rule
 				//! \test decl.C99/Error_enum_typedef.h, decl.C99/Error_enum_typedef.hpp 
@@ -12557,7 +12557,7 @@
 		value_copy(prior_value,latest_value);
 		{
 		bool value_is_nonnegative = true;
-		const promote_aux test(current_enumerator_type,types);
+		const promote_aux test(current_enumerator_type,*parse_tree::types);
 		if (test.is_signed && latest_value.test(test.bitcount-1))
 			{
 			target_machine->signed_additive_inverse(latest_value,test.machine_type);
@@ -12574,15 +12574,15 @@
 		if (1>=src.size<0>()-i)
 			{	// default-update
 			// handle type errors
-			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0],types))
+			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0],*parse_tree::types))
 				return false;
 			uchar_blob latest_value_copy;
 			latest_value_copy.init(0);
 			value_copy(latest_value_copy,latest_value);
 			if (active_namespace)
-				types.set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types->set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			else
-				types.set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types->set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			break;
 			}
 		// complete conversion
@@ -12591,15 +12591,15 @@
 		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
 		if (robust_token_is_char<','>(src.data<0>()[i+1]))
 			{	// would default-update
-			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0],types))
+			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0],*parse_tree::types))
 				return false;
 			uchar_blob latest_value_copy;
 			latest_value_copy.init(0);
 			value_copy(latest_value_copy,latest_value);
 			if (active_namespace)
-				types.set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types->set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			else
-				types.set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types->set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			i += 2;
 			continue;
 			};
@@ -12619,9 +12619,9 @@
 			};
 		{	// see if it's a compile-time constant
 		parse_tree_class tmp(src,origin,i-comma_overextended,0);
-		if (tmp.is_raw_list() && !CondenseParseTree(tmp,types)) return false;
-		if (!EvalParseTree(tmp,types)) return false;
-		if (!intlike_literal_to_VM(latest_value,tmp,types))
+		if (tmp.is_raw_list() && !CondenseParseTree(tmp,*parse_tree::types)) return false;
+		if (!EvalParseTree(tmp,*parse_tree::types)) return false;
+		if (!intlike_literal_to_VM(latest_value,tmp,*parse_tree::types))
 			{	//! \bug need test case
 			message_header(src.data<0>()[origin-2].index_tokens[0]);
 			INC_INFORM(ERR_STR);
@@ -12633,7 +12633,7 @@
 		if (allow_empty)
 			{	// C++
 			current_enumerator_type = tmp.type_code.base_type_index;
-			const promote_aux test(current_enumerator_type,types);
+			const promote_aux test(current_enumerator_type,*parse_tree::types);
 			if (test.is_signed && latest_value.test(test.bitcount-1))
 				{	// negative
 				unsigned_var_int abs_latest_value(latest_value);
@@ -12738,8 +12738,8 @@
 				}
 			}
 		else{	// C
-			const promote_aux test(tmp.type_code.base_type_index,types);
-			const promote_aux dest_type(C_TYPE::INT,types);
+			const promote_aux test(tmp.type_code.base_type_index,*parse_tree::types);
+			const promote_aux dest_type(C_TYPE::INT,*parse_tree::types);
 			const bool is_negative = test.is_signed && latest_value.test(test.bitcount-1);
 			if (is_negative)
 				target_machine->signed_additive_inverse(latest_value,test.machine_type);
@@ -12777,13 +12777,13 @@
 		latest_value_copy.init(0);
 		value_copy(latest_value_copy,latest_value);
 		if (active_namespace)
-			types.set_enumerator_def_CPP(src.data<0>()[origin-2].index_tokens[0].token.first, active_namespace,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+			parse_tree::types->set_enumerator_def_CPP(src.data<0>()[origin-2].index_tokens[0].token.first, active_namespace,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 		else
-			types.set_enumerator_def(src.data<0>()[origin-2].index_tokens[0].token.first,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+			parse_tree::types->set_enumerator_def(src.data<0>()[origin-2].index_tokens[0].token.first,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 		}
 		}
 	// now ok to crunch underlying type/machine representation
-	types.set_enum_underlying_type(enum_type_index,allow_empty ? base_enum_type : C_TYPE::INT);
+	parse_tree::types->set_enum_underlying_type(enum_type_index,allow_empty ? base_enum_type : C_TYPE::INT);
 	return true;
 }
 
@@ -12809,7 +12809,7 @@
 // will need: typedef map: identifier |-> typespec record
 //! \todo check that the fact all literals are already legal-form is used
 //! \throw std::bad_alloc
-static void C99_ContextParse(parse_tree& src,type_system& types)
+static void C99_ContextParse(parse_tree& src)
 {
 	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle in type_spec, which is required to be POD to allow C memory management:
 	// * indirection depth n (already have this in practice)
@@ -12834,7 +12834,7 @@
 		// C static assertion scanner
 		if (robust_token_is_string<14>(src.data<0>()[i],"_Static_Assert"))
 			{	// _Static_Assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CLexer->pp_support,i,"control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)",NULL);
+			C99_CPP_handle_static_assertion(src,*CLexer->pp_support,i,"control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)",NULL);
 			continue;
 			};
 		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
@@ -12842,21 +12842,22 @@
 		if (is_C99_named_specifier(src.data<0>()[i],"union"))
 			{
 C99_union_specifier:
-			const type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
+				assert(0<parse_tree::types->use_count(tmp));
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.h
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
@@ -12892,6 +12893,7 @@
 					//! \test zcc/decl.C99/Pass_union_forward_def.h
 					// remove from parse
 					src.DeleteNSlotsAt<0>(2,i);
+					assert(0<parse_tree::types->use_count(tmp));
 					continue;					
 					}
 				// forward-declare
@@ -12912,21 +12914,22 @@
 		else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
 			{
 C99_struct_specifier:
-			const type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
+				assert(0<parse_tree::types->use_count(tmp));
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
@@ -12981,10 +12984,11 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				assert(0<parse_tree::types->use_count(tmp));
+				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_union_multidef.h
 					message_header(src.data<0>()[i].index_tokens[0]);
@@ -13006,12 +13010,12 @@
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.h
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
@@ -13019,13 +13023,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// no objects declared, trigger the const/volatile warnings
@@ -13048,10 +13052,11 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				assert(0<parse_tree::types->use_count(tmp));
+				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_struct_multidef.h
 					message_header(src.data<0>()[i].index_tokens[0]);
@@ -13073,12 +13078,12 @@
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or union must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
@@ -13086,13 +13091,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// no objects declared, trigger the const/volatile warnings
@@ -13116,21 +13121,21 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl("<unknown>",union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_union);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types->get_structdecl(tmp2));
 
 			src.c_array<0>()[i].type_code.set_type(tmp2);
 			src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types->get_C_structdef(tmp2));
 
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -13161,21 +13166,21 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl("<unknown>",union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_struct);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types->get_structdecl(tmp2));
 
 			src.c_array<0>()[i].type_code.set_type(tmp2);
 			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types->get_C_structdef(tmp2));
 
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -13208,7 +13213,7 @@
 			{	// C99 6.7.2.3: allowed only after name is defined
 			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
 				{
-				type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+				type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
 				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 				if (!tmp)
 					{	//! \test zcc/decl.C99/Error_enum_undef.h
@@ -13224,15 +13229,16 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{	//! \test zcc/decl.C99/Error_enum_multidef.h
+				assert(0<parse_tree::types->use_count(tmp));
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("'enum ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 				INFORM("' already defined (C99 6.7.2.3p1)");
-				const enum_def* const tmp2 = types.get_enum_def(tmp);
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(tmp);
 				assert(tmp2);
 				message_header(*tmp2);
 				INFORM("prior definition here");
@@ -13243,9 +13249,9 @@
 				};
 			// enum-specifier doesn't have a specific declaration mode
 			//! \test zcc/decl.C99/Pass_enum_def.h
-			const type_system::type_index tmp2 = types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			assert(types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+			const type_system::type_index tmp2 = parse_tree::types->register_enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			assert(parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;
@@ -13254,8 +13260,8 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = types.register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+			const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;
@@ -13275,7 +13281,7 @@
 		// ** C: const volatile restrict (but pointer type required for restrict)
 		// * atomic types have already been parsed, we need to catch the others
 		{
-		C99_decl_specifier_scanner declFind(types);
+		C99_decl_specifier_scanner declFind(*parse_tree::types);
 		size_t decl_count = src.get_span<0>(i,declFind);
 		if (decl_count)
 			{
@@ -13367,7 +13373,7 @@
 						{	// typedef
 						register_token<0>(*initdecl_identifier);
 						// verify that there is no prior definition
-						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(initdecl_identifier->index_tokens[0].token.first);
+						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = parse_tree::types->get_typedef(initdecl_identifier->index_tokens[0].token.first);
 						if (tmp)
 							{
 							if (bootstrap==tmp->first)
@@ -13400,7 +13406,7 @@
 							// do not re-register if there is a prior definition
 							}
 						else{	// prepare to register this with types object
-							const type_system::enumerator_info* tmp2 = types.get_enumerator(initdecl_identifier->index_tokens[0].token.first);
+							const type_system::enumerator_info* tmp2 = parse_tree::types->get_enumerator(initdecl_identifier->index_tokens[0].token.first);
 							if (tmp2)
 								{	//! \test zcc/decl.C99/Error_typedef_enum.h
 								message_header(src.data<0>()[i].index_tokens[0]);
@@ -13413,7 +13419,7 @@
 								zcc_errors.inc_error();
 								return;
 								}
-							types.set_typedef(initdecl_identifier->index_tokens[0].token.first,initdecl_identifier->index_tokens[0].src_filename,initdecl_identifier->index_tokens[0].logical_line.first,bootstrap);
+							parse_tree::types->set_typedef(initdecl_identifier->index_tokens[0].token.first,initdecl_identifier->index_tokens[0].src_filename,initdecl_identifier->index_tokens[0].logical_line.first,bootstrap);
 							}
 						}
 #if 0
@@ -13610,7 +13616,7 @@
 // handle namespaces or else
 //! \todo check that the fact all literals are already legal-form is used
 //! \throw std::bad_alloc
-static void CPP_ParseNamespace(parse_tree& src,type_system& types,const char* const active_namespace)
+static void CPP_ParseNamespace(parse_tree& src,const char* const active_namespace)
 {
 	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle
 	// * indirection depth n (already have this in practice)
@@ -13645,7 +13651,7 @@
 		// C++ static assertion scanner
 		if (robust_token_is_string<13>(src.data<0>()[i],"static_assert"))
 			{	// static_assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CPlusPlusLexer->pp_support,i,"control expression for static assertion must be a constant convertible to bool (C++0X 7p4)",active_namespace);
+			C99_CPP_handle_static_assertion(src,*CPlusPlusLexer->pp_support,i,"control expression for static assertion must be a constant convertible to bool (C++0X 7p4)",active_namespace);
 			continue;
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
@@ -13653,7 +13659,7 @@
 		if (is_C99_named_specifier(src.data<0>()[i],"union"))
 			{
 CPP_union_specifier:
-			const type_system::type_index tmp = types.get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
 				src.c_array<0>()[i].type_code.set_type(tmp);
@@ -13662,12 +13668,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
@@ -13722,7 +13728,7 @@
 		else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
 			{
 CPP_struct_specifier:				
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
 				src.c_array<0>()[i].type_code.set_type(tmp);
@@ -13731,12 +13737,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
@@ -13792,7 +13798,7 @@
 		else if (is_C99_named_specifier(src.data<0>()[i],"class"))
 			{
 CPP_class_specifier:
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
 				src.c_array<0>()[i].type_code.set_type(tmp);
@@ -13801,12 +13807,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
@@ -13861,10 +13867,10 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_union_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
@@ -13886,12 +13892,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
@@ -13899,13 +13905,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
@@ -13928,10 +13934,10 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
@@ -13953,12 +13959,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
@@ -13966,13 +13972,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
@@ -13995,10 +14001,10 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_class_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
@@ -14020,12 +14026,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
@@ -14033,13 +14039,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
@@ -14063,22 +14069,22 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union);
 			assert(tmp2);
 
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types->get_structdecl(tmp2));
 			src.c_array<0>()[i].type_code.set_type(tmp2);
 			src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types->get_C_structdef(tmp2));
 
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -14109,20 +14115,20 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types->get_structdecl(tmp2));
 			src.c_array<0>()[i].type_code.set_type(tmp2);
 			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types->get_C_structdef(tmp2));
 
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -14153,20 +14159,20 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"class"))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types->get_structdecl(tmp2));
 			src.c_array<0>()[i].type_code.set_type(tmp2);
 			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types->get_C_structdef(tmp2));
 
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -14200,7 +14206,7 @@
 			{
 			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
 				{
-				type_system::type_index tmp = types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+				type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 				src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
 				if (!tmp)
 					{	// this belongs elsewhere
@@ -14220,7 +14226,7 @@
 			{	// can only define once
 			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
 			const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-			type_system::type_index tmp = types.get_id_enum(fullname);
+			type_system::type_index tmp = parse_tree::types->get_id_enum(fullname);
 			if (tmp)
 				{	//! \test zcc/decl.C99/Error_enum_multidef.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -14229,7 +14235,7 @@
 				INC_INFORM(fullname);
 				free(namespace_name);
 				INFORM("' already defined (C++98 3.2p1)");
-				const enum_def* const tmp2 = types.get_enum_def(tmp);
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(tmp);
 				assert(tmp2);
 				message_header(*tmp2);
 				INFORM("prior definition here");
@@ -14241,9 +14247,9 @@
 			free(namespace_name);
 			//! \test zcc/decl.C99/Pass_enum_def.hpp
 			// enum-specifier doesn't have a specific declaration mode
-			const type_system::type_index tmp2 = types.register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			assert(types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp2,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+			const type_system::type_index tmp2 = parse_tree::types->register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			assert(parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp2,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;
@@ -14252,8 +14258,8 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = types.register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+			const type_system::type_index tmp = parse_tree::types->register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;
@@ -14303,11 +14309,11 @@
 					strcpy(new_active_namespace,active_namespace);
 					strcat(new_active_namespace,"::<unknown>");
 					strcat(new_active_namespace,"");
-					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],types,new_active_namespace);
+					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],new_active_namespace);
 					free(new_active_namespace);
 					}
 				else{
-					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],types,"<unknown>");
+					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],"<unknown>");
 					}
 				++i;
 				continue;
@@ -14359,12 +14365,12 @@
 			if (NULL==active_namespace)
 				{	// global
 					//! \todo expand namespace aliases
-				CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],types,src.c_array<0>()[i].index_tokens[1].token.first);
+				CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],src.c_array<0>()[i].index_tokens[1].token.first);
 				}
 			else{	// nested
 					//! \todo expand namespace aliases
 				char* const new_active_namespace = type_system::namespace_concatenate(src.c_array<0>()[i].index_tokens[1].token.first,active_namespace,"::");
-				CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],types,new_active_namespace);
+				CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],new_active_namespace);
 				free(new_active_namespace);
 				}
 			++i;
@@ -14389,7 +14395,7 @@
 		// * atomic types have already been parsed, we need to catch the others
 		// * C++0x: auto is a possible type!
 		{
-		CPP0X_decl_specifier_scanner declFind(types,active_namespace);
+		CPP0X_decl_specifier_scanner declFind(*parse_tree::types,active_namespace);
 		size_t decl_count = src.destructive_get_span<0>(i,declFind);
 		if (decl_count)
 			{
@@ -14493,7 +14499,7 @@
 
 						// verify that there is no prior definition
 						// we're fine redeclaring at a different level, so do not use full C++ typedef lookup
-						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(fullname);					
+						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = parse_tree::types->get_typedef(fullname);					
 						if (tmp)
 							{
 							if (bootstrap==tmp->first)
@@ -14528,7 +14534,7 @@
 							}
 						else{	// register this with types object
 							free(namespace_name);
-							const type_system::enumerator_info* tmp2 = types.get_enumerator_CPP(initdecl_identifier->index_tokens[0].token.first,active_namespace);
+							const type_system::enumerator_info* tmp2 = parse_tree::types->get_enumerator_CPP(initdecl_identifier->index_tokens[0].token.first,active_namespace);
 							if (tmp2)
 								{	//! \test zcc/decl.C99/Error_typedef_enum.hpp
 									//! \test zcc/decl.C99/Error_typedef_enum2.hpp
@@ -14542,7 +14548,7 @@
 								zcc_errors.inc_error();
 								return;
 								}							
-							types.set_typedef_CPP(initdecl_identifier->index_tokens[0].token.first,active_namespace,initdecl_identifier->index_tokens[0].src_filename,initdecl_identifier->index_tokens[0].logical_line.first,bootstrap);
+							parse_tree::types->set_typedef_CPP(initdecl_identifier->index_tokens[0].token.first,active_namespace,initdecl_identifier->index_tokens[0].src_filename,initdecl_identifier->index_tokens[0].logical_line.first,bootstrap);
 							}
 						}
 #if 0
@@ -14592,9 +14598,9 @@
 }
 
 //! \throw std::bad_alloc
-static void CPP_ContextParse(parse_tree& src,type_system& types)
+static void CPP_ContextParse(parse_tree& src)
 {
-	CPP_ParseNamespace(src,types,NULL);
+	CPP_ParseNamespace(src,NULL);
 }
 
 PP_auxfunc C99_aux

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-02 03:01:19 UTC (rev 528)
+++ trunk/CSupport.cpp.in	2010-11-02 08:54:25 UTC (rev 529)
@@ -12279,7 +12279,7 @@
 }
 
 //! \throw std::bad_alloc()
-static void C99_CPP_handle_static_assertion(parse_tree& src,type_system& types,PP_auxfunc& langinfo,const size_t i,const char* const err,const char* const active_namespace)
+static void C99_CPP_handle_static_assertion(parse_tree& src,PP_auxfunc& langinfo,const size_t i,const char* const err,const char* const active_namespace)
 {
 	assert(err && *err);
 	// find the next ';'
@@ -12334,20 +12334,20 @@
 	zaimoni::autotransform_n<void (*)(parse_tree&,const parse_tree&)>(parsetree.c_array<0>(),src.data<0>()[i+1].data<0>(),k,value_copy);
 	// type all enumerators now to make life reasonable later on for the expression-parser
 	size_t enum_scan = k;
-	do	notice_enumerator_CPP(parsetree.c_array<0>()[--enum_scan],types,active_namespace);
+	do	notice_enumerator_CPP(parsetree.c_array<0>()[--enum_scan],*parse_tree::types,active_namespace);
 	while(0<enum_scan);
 	}
 	// init above correctly
 	// snip from Condense
 	const size_t starting_errors = zcc_errors.err_count();
-	(langinfo.LocateExpression)(parsetree,SIZE_MAX,types);
+	(langinfo.LocateExpression)(parsetree,SIZE_MAX,*parse_tree::types);
 	if (starting_errors==zcc_errors.err_count())
 		{
 		while(parsetree.is_raw_list() && 1==parsetree.size<0>())
 			parsetree.eval_to_arg<0>(0);
 		// end snip from Condense
 		// snip from CPreproc
-		if (!parsetree.is_atomic() && !(langinfo.EvalParseTree)(parsetree,types))
+		if (!parsetree.is_atomic() && !(langinfo.EvalParseTree)(parsetree,*parse_tree::types))
 			{
 			parsetree.destroy();	// efficiency
 			message_header(src.data<0>()[i].index_tokens[0]);
@@ -12357,7 +12357,7 @@
 			src.DeleteNSlotsAt<0>(j-i+1,i);
 			return;
 			}
-		(langinfo.PPHackTree)(parsetree,types);
+		(langinfo.PPHackTree)(parsetree,*parse_tree::types);
 		// final, when above is working properly
 		if (!parsetree.is_atomic())
 			{	//! \bug need test cases
@@ -12372,11 +12372,11 @@
 		// end snip from CPreproc
 
 		// handle top-level enumerators
-		if (is_noticed_enumerator(parsetree,types))
-			enumerator_to_integer_representation(parsetree,types);
+		if (is_noticed_enumerator(parsetree,*parse_tree::types))
+			enumerator_to_integer_representation(parsetree,*parse_tree::types);
 
 		bool is_true = false;
-		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true,types))
+		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true,*parse_tree::types))
 			{	//! \bug need test cases
 			parsetree.destroy();	// efficiency
 			message_header(src.data<0>()[i].index_tokens[0]);
@@ -12475,7 +12475,7 @@
 }
 
 //! \throw std::bad_alloc
-static bool record_enum_values(parse_tree& src, type_system& types, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits<const char* (*)(const char*, size_t)>::function_ref_type echo_reserved_keyword, intlike_literal_to_VM_func& intlike_literal_to_VM, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type CondenseParseTree, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
+static bool record_enum_values(parse_tree& src, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits<const char* (*)(const char*, size_t)>::function_ref_type echo_reserved_keyword, intlike_literal_to_VM_func& intlike_literal_to_VM, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type CondenseParseTree, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
 {
 	assert(enum_type_index);
 	assert(!active_namespace || *active_namespace);
@@ -12605,7 +12605,7 @@
 		char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[0].token.first,active_namespace,"::") : NULL;
 		const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[0].token.first;
 		{
-		const type_system::enumerator_info* tmp = types.get_enumerator(fullname);
+		const type_system::enumerator_info* tmp = parse_tree::types->get_enumerator(fullname);
 		if (tmp)
 			{	// --do-what-i-mean could recover if the prior definition were identical
 				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined
@@ -12624,7 +12624,7 @@
 #if 0
 		// next proposed function call is a bit handwavish right now...
 		// C++0X 3.3.1p4: enumerator gets to hide class names and enum names, nothing else [in particular dies against typedefs and functions]
-		if (types.enum_already_defined(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
+		if (parse_tree::types->enum_already_defined(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
 			{	// -Wbackport warn in C++, fail in C
 			if (allow_empty)
 				{	// C++0X
@@ -12645,7 +12645,7 @@
 				return false;
 				}	
 			};
-		if (types.union_class_struct_already_declared(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
+		if (parse_tree::types->union_class_struct_already_declared(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
 			{	// -Wbackport warn in C++, fail in C
 			if (allow_empty)
 				{	// C++0X
@@ -12666,12 +12666,12 @@
 				return false;
 				}	
 			};
-		if (types.function_already_declared(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
+		if (parse_tree::types->function_already_declared(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
 			{	// C++: One Definition Rule
 			};
 #endif
 		{
-		const zaimoni::POD_triple<type_spec,const char*,size_t>* const tmp = types.get_typedef_CPP(src.data<0>()[i].index_tokens[0].token.first,active_namespace); 
+		const zaimoni::POD_triple<type_spec,const char*,size_t>* const tmp = parse_tree::types->get_typedef_CPP(src.data<0>()[i].index_tokens[0].token.first,active_namespace); 
 		if (tmp)
 			{	// C++: One Definition Rule
 				//! \test decl.C99/Error_enum_typedef.h, decl.C99/Error_enum_typedef.hpp 
@@ -12701,7 +12701,7 @@
 		value_copy(prior_value,latest_value);
 		{
 		bool value_is_nonnegative = true;
-		const promote_aux test(current_enumerator_type,types);
+		const promote_aux test(current_enumerator_type,*parse_tree::types);
 		if (test.is_signed && latest_value.test(test.bitcount-1))
 			{
 			target_machine->signed_additive_inverse(latest_value,test.machine_type);
@@ -12718,15 +12718,15 @@
 		if (1>=src.size<0>()-i)
 			{	// default-update
 			// handle type errors
-			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0],types))
+			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0],*parse_tree::types))
 				return false;
 			uchar_blob latest_value_copy;
 			latest_value_copy.init(0);
 			value_copy(latest_value_copy,latest_value);
 			if (active_namespace)
-				types.set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types->set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			else
-				types.set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types->set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			break;
 			}
 		// complete conversion
@@ -12735,15 +12735,15 @@
 		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
 		if (robust_token_is_char<','>(src.data<0>()[i+1]))
 			{	// would default-update
-			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0],types))
+			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0],*parse_tree::types))
 				return false;
 			uchar_blob latest_value_copy;
 			latest_value_copy.init(0);
 			value_copy(latest_value_copy,latest_value);
 			if (active_namespace)
-				types.set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types->set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			else
-				types.set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+				parse_tree::types->set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 			i += 2;
 			continue;
 			};
@@ -12763,9 +12763,9 @@
 			};
 		{	// see if it's a compile-time constant
 		parse_tree_class tmp(src,origin,i-comma_overextended,0);
-		if (tmp.is_raw_list() && !CondenseParseTree(tmp,types)) return false;
-		if (!EvalParseTree(tmp,types)) return false;
-		if (!intlike_literal_to_VM(latest_value,tmp,types))
+		if (tmp.is_raw_list() && !CondenseParseTree(tmp,*parse_tree::types)) return false;
+		if (!EvalParseTree(tmp,*parse_tree::types)) return false;
+		if (!intlike_literal_to_VM(latest_value,tmp,*parse_tree::types))
 			{	//! \bug need test case
 			message_header(src.data<0>()[origin-2].index_tokens[0]);
 			INC_INFORM(ERR_STR);
@@ -12777,7 +12777,7 @@
 		if (allow_empty)
 			{	// C++
 			current_enumerator_type = tmp.type_code.base_type_index;
-			const promote_aux test(current_enumerator_type,types);
+			const promote_aux test(current_enumerator_type,*parse_tree::types);
 			if (test.is_signed && latest_value.test(test.bitcount-1))
 				{	// negative
 				unsigned_var_int abs_latest_value(latest_value);
@@ -12882,8 +12882,8 @@
 				}
 			}
 		else{	// C
-			const promote_aux test(tmp.type_code.base_type_index,types);
-			const promote_aux dest_type(C_TYPE::INT,types);
+			const promote_aux test(tmp.type_code.base_type_index,*parse_tree::types);
+			const promote_aux dest_type(C_TYPE::INT,*parse_tree::types);
 			const bool is_negative = test.is_signed && latest_value.test(test.bitcount-1);
 			if (is_negative)
 				target_machine->signed_additive_inverse(latest_value,test.machine_type);
@@ -12921,13 +12921,13 @@
 		latest_value_copy.init(0);
 		value_copy(latest_value_copy,latest_value);
 		if (active_namespace)
-			types.set_enumerator_def_CPP(src.data<0>()[origin-2].index_tokens[0].token.first, active_namespace,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+			parse_tree::types->set_enumerator_def_CPP(src.data<0>()[origin-2].index_tokens[0].token.first, active_namespace,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 		else
-			types.set_enumerator_def(src.data<0>()[origin-2].index_tokens[0].token.first,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+			parse_tree::types->set_enumerator_def(src.data<0>()[origin-2].index_tokens[0].token.first,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 		}
 		}
 	// now ok to crunch underlying type/machine representation
-	types.set_enum_underlying_type(enum_type_index,allow_empty ? base_enum_type : C_TYPE::INT);
+	parse_tree::types->set_enum_underlying_type(enum_type_index,allow_empty ? base_enum_type : C_TYPE::INT);
 	return true;
 }
 
@@ -12953,7 +12953,7 @@
 // will need: typedef map: identifier |-> typespec record
 //! \todo check that the fact all literals are already legal-form is used
 //! \throw std::bad_alloc
-static void C99_ContextParse(parse_tree& src,type_system& types)
+static void C99_ContextParse(parse_tree& src)
 {
 	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle in type_spec, which is required to be POD to allow C memory management:
 	// * indirection depth n (already have this in practice)
@@ -12978,7 +12978,7 @@
 		// C static assertion scanner
 		if (robust_token_is_string<14>(src.data<0>()[i],"_Static_Assert"))
 			{	// _Static_Assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CLexer->pp_support,i,"control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)",NULL);
+			C99_CPP_handle_static_assertion(src,*CLexer->pp_support,i,"control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)",NULL);
 			continue;
 			};
 		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
@@ -12986,21 +12986,22 @@
 		if (is_C99_named_specifier(src.data<0>()[i],"union"))
 			{
 C99_union_specifier:
-			const type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
+				assert(0<parse_tree::types->use_count(tmp));
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.h
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
@@ -13036,6 +13037,7 @@
 					//! \test zcc/decl.C99/Pass_union_forward_def.h
 					// remove from parse
 					src.DeleteNSlotsAt<0>(2,i);
+					assert(0<parse_tree::types->use_count(tmp));
 					continue;					
 					}
 				// forward-declare
@@ -13056,21 +13058,22 @@
 		else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
 			{
 C99_struct_specifier:
-			const type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
+				assert(0<parse_tree::types->use_count(tmp));
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
@@ -13125,10 +13128,11 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				assert(0<parse_tree::types->use_count(tmp));
+				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_union_multidef.h
 					message_header(src.data<0>()[i].index_tokens[0]);
@@ -13150,12 +13154,12 @@
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.h
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
@@ -13163,13 +13167,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// no objects declared, trigger the const/volatile warnings
@@ -13192,10 +13196,11 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				assert(0<parse_tree::types->use_count(tmp));
+				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_struct_multidef.h
 					message_header(src.data<0>()[i].index_tokens[0]);
@@ -13217,12 +13222,12 @@
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or union must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
@@ -13230,13 +13235,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// no objects declared, trigger the const/volatile warnings
@@ -13260,21 +13265,21 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl("<unknown>",union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_union);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types->get_structdecl(tmp2));
 
 			src.c_array<0>()[i].type_code.set_type(tmp2);
 			src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types->get_C_structdef(tmp2));
 
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -13305,21 +13310,21 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl("<unknown>",union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_struct);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types->get_structdecl(tmp2));
 
 			src.c_array<0>()[i].type_code.set_type(tmp2);
 			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types->get_C_structdef(tmp2));
 
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -13352,7 +13357,7 @@
 			{	// C99 6.7.2.3: allowed only after name is defined
 			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
 				{
-				type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+				type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
 				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 				if (!tmp)
 					{	//! \test zcc/decl.C99/Error_enum_undef.h
@@ -13368,15 +13373,16 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+			const type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{	//! \test zcc/decl.C99/Error_enum_multidef.h
+				assert(0<parse_tree::types->use_count(tmp));
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("'enum ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 				INFORM("' already defined (C99 6.7.2.3p1)");
-				const enum_def* const tmp2 = types.get_enum_def(tmp);
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(tmp);
 				assert(tmp2);
 				message_header(*tmp2);
 				INFORM("prior definition here");
@@ -13387,9 +13393,9 @@
 				};
 			// enum-specifier doesn't have a specific declaration mode
 			//! \test zcc/decl.C99/Pass_enum_def.h
-			const type_system::type_index tmp2 = types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			assert(types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+			const type_system::type_index tmp2 = parse_tree::types->register_enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			assert(parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;
@@ -13398,8 +13404,8 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = types.register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+			const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;
@@ -13419,7 +13425,7 @@
 		// ** C: const volatile restrict (but pointer type required for restrict)
 		// * atomic types have already been parsed, we need to catch the others
 		{
-		C99_decl_specifier_scanner declFind(types);
+		C99_decl_specifier_scanner declFind(*parse_tree::types);
 		size_t decl_count = src.get_span<0>(i,declFind);
 		if (decl_count)
 			{
@@ -13511,7 +13517,7 @@
 						{	// typedef
 						register_token<0>(*initdecl_identifier);
 						// verify that there is no prior definition
-						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(initdecl_identifier->index_tokens[0].token.first);
+						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = parse_tree::types->get_typedef(initdecl_identifier->index_tokens[0].token.first);
 						if (tmp)
 							{
 							if (bootstrap==tmp->first)
@@ -13544,7 +13550,7 @@
 							// do not re-register if there is a prior definition
 							}
 						else{	// prepare to register this with types object
-							const type_system::enumerator_info* tmp2 = types.get_enumerator(initdecl_identifier->index_tokens[0].token.first);
+							const type_system::enumerator_info* tmp2 = parse_tree::types->get_enumerator(initdecl_identifier->index_tokens[0].token.first);
 							if (tmp2)
 								{	//! \test zcc/decl.C99/Error_typedef_enum.h
 								message_header(src.data<0>()[i].index_tokens[0]);
@@ -13557,7 +13563,7 @@
 								zcc_errors.inc_error();
 								return;
 								}
-							types.set_typedef(initdecl_identifier->index_tokens[0].token.first,initdecl_identifier->index_tokens[0].src_filename,initdecl_identifier->index_tokens[0].logical_line.first,bootstrap);
+							parse_tree::types->set_typedef(initdecl_identifier->index_tokens[0].token.first,initdecl_identifier->index_tokens[0].src_filename,initdecl_identifier->index_tokens[0].logical_line.first,bootstrap);
 							}
 						}
 #if 0
@@ -13754,7 +13760,7 @@
 // handle namespaces or else
 //! \todo check that the fact all literals are already legal-form is used
 //! \throw std::bad_alloc
-static void CPP_ParseNamespace(parse_tree& src,type_system& types,const char* const active_namespace)
+static void CPP_ParseNamespace(parse_tree& src,const char* const active_namespace)
 {
 	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle
 	// * indirection depth n (already have this in practice)
@@ -13789,7 +13795,7 @@
 		// C++ static assertion scanner
 		if (robust_token_is_string<13>(src.data<0>()[i],"static_assert"))
 			{	// static_assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CPlusPlusLexer->pp_support,i,"control expression for static assertion must be a constant convertible to bool (C++0X 7p4)",active_namespace);
+			C99_CPP_handle_static_assertion(src,*CPlusPlusLexer->pp_support,i,"control expression for static assertion must be a constant convertible to bool (C++0X 7p4)",active_namespace);
 			continue;
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
@@ -13797,7 +13803,7 @@
 		if (is_C99_named_specifier(src.data<0>()[i],"union"))
 			{
 CPP_union_specifier:
-			const type_system::type_index tmp = types.get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
 				src.c_array<0>()[i].type_code.set_type(tmp);
@@ -13806,12 +13812,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
@@ -13866,7 +13872,7 @@
 		else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
 			{
 CPP_struct_specifier:				
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
 				src.c_array<0>()[i].type_code.set_type(tmp);
@@ -13875,12 +13881,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
@@ -13936,7 +13942,7 @@
 		else if (is_C99_named_specifier(src.data<0>()[i],"class"))
 			{
 CPP_class_specifier:
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
 				src.c_array<0>()[i].type_code.set_type(tmp);
@@ -13945,12 +13951,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
@@ -14005,10 +14011,10 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_union_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
@@ -14030,12 +14036,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
@@ -14043,13 +14049,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
@@ -14072,10 +14078,10 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
@@ -14097,12 +14103,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
@@ -14110,13 +14116,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
@@ -14139,10 +14145,10 @@
 			}
 		else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
 			{	// can only define once
-			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
 				if (fatal_def)
 					{	//! \test zcc/decl.C99/Error_class_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
@@ -14164,12 +14170,12 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(types.get_structdecl(tmp2));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
@@ -14177,13 +14183,13 @@
 			assert(tmp || tmp2);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
-			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
-			assert(types.get_C_structdef(vr_tmp));
+			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
@@ -14207,22 +14213,22 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union);
 			assert(tmp2);
 
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types->get_structdecl(tmp2));
 			src.c_array<0>()[i].type_code.set_type(tmp2);
 			src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types->get_C_structdef(tmp2));
 
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -14253,20 +14259,20 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types->get_structdecl(tmp2));
 			src.c_array<0>()[i].type_code.set_type(tmp2);
 			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types->get_C_structdef(tmp2));
 
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -14297,20 +14303,20 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"class"))
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class);
 			assert(tmp2);
-			assert(types.get_structdecl(tmp2));
+			assert(parse_tree::types->get_structdecl(tmp2));
 			src.c_array<0>()[i].type_code.set_type(tmp2);
 			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 
 			// parse the union and upgrade it to a full definition
-			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(tmp2);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
-			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_C_structdef(tmp2));
+			parse_tree::types->upgrade_decl_to_def(tmp2,tmp4);
+			assert(parse_tree::types->get_C_structdef(tmp2));
 
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -14344,7 +14350,7 @@
 			{
 			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
 				{
-				type_system::type_index tmp = types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+				type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 				src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
 				if (!tmp)
 					{	// this belongs elsewhere
@@ -14364,7 +14370,7 @@
 			{	// can only define once
 			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
 			const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-			type_system::type_index tmp = types.get_id_enum(fullname);
+			type_system::type_index tmp = parse_tree::types->get_id_enum(fullname);
 			if (tmp)
 				{	//! \test zcc/decl.C99/Error_enum_multidef.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -14373,7 +14379,7 @@
 				INC_INFORM(fullname);
 				free(namespace_name);
 				INFORM("' already defined (C++98 3.2p1)");
-				const enum_def* const tmp2 = types.get_enum_def(tmp);
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(tmp);
 				assert(tmp2);
 				message_header(*tmp2);
 				INFORM("prior definition here");
@@ -14385,9 +14391,9 @@
 			free(namespace_name);
 			//! \test zcc/decl.C99/Pass_enum_def.hpp
 			// enum-specifier doesn't have a specific declaration mode
-			const type_system::type_index tmp2 = types.register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
-			assert(types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp2,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+			const type_system::type_index tmp2 = parse_tree::types->register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			assert(parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp2,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;
@@ -14396,8 +14402,8 @@
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
-			const type_system::type_index tmp = types.register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+			const type_system::type_index tmp = parse_tree::types->register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
 				return;
@@ -14447,11 +14453,11 @@
 					strcpy(new_active_namespace,active_namespace);
 					strcat(new_active_namespace,"::<unknown>");
 					strcat(new_active_namespace,"");
-					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],types,new_active_namespace);
+					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],new_active_namespace);
 					free(new_active_namespace);
 					}
 				else{
-					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],types,"<unknown>");
+					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],"<unknown>");
 					}
 				++i;
 				continue;
@@ -14503,12 +14509,12 @@
 			if (NULL==active_namespace)
 				{	// global
 					//! \todo expand namespace aliases
-				CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],types,src.c_array<0>()[i].index_tokens[1].token.first);
+				CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],src.c_array<0>()[i].index_tokens[1].token.first);
 				}
 			else{	// nested
 					//! \todo expand namespace aliases
 				char* const new_active_namespace = type_system::namespace_concatenate(src.c_array<0>()[i].index_tokens[1].token.first,active_namespace,"::");
-				CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],types,new_active_namespace);
+				CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],new_active_namespace);
 				free(new_active_namespace);
 				}
 			++i;
@@ -14533,7 +14539,7 @@
 		// * atomic types have already been parsed, we need to catch the others
 		// * C++0x: auto is a possible type!
 		{
-		CPP0X_decl_specifier_scanner declFind(types,active_namespace);
+		CPP0X_decl_specifier_scanner declFind(*parse_tree::types,active_namespace);
 		size_t decl_count = src.destructive_get_span<0>(i,declFind);
 		if (decl_count)
 			{
@@ -14637,7 +14643,7 @@
 
 						// verify that there is no prior definition
 						// we're fine redeclaring at a different level, so do not use full C++ typedef lookup
-						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(fullname);					
+						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = parse_tree::types->get_typedef(fullname);					
 						if (tmp)
 							{
 							if (bootstrap==tmp->first)
@@ -14672,7 +14678,7 @@
 							}
 						else{	// register this with types object
 							free(namespace_name);
-							const type_system::enumerator_info* tmp2 = types.get_enumerator_CPP(initdecl_identifier->index_tokens[0].token.first,active_namespace);
+							const type_system::enumerator_info* tmp2 = parse_tree::types->get_enumerator_CPP(initdecl_identifier->index_tokens[0].token.first,active_namespace);
 							if (tmp2)
 								{	//! \test zcc/decl.C99/Error_typedef_enum.hpp
 									//! \test zcc/decl.C99/Error_typedef_enum2.hpp
@@ -14686,7 +14692,7 @@
 								zcc_errors.inc_error();
 								return;
 								}							
-							types.set_typedef_CPP(initdecl_identifier->index_tokens[0].token.first,active_namespace,initdecl_identifier->index_tokens[0].src_filename,initdecl_identifier->index_tokens[0].logical_line.first,bootstrap);
+							parse_tree::types->set_typedef_CPP(initdecl_identifier->index_tokens[0].token.first,active_namespace,initdecl_identifier->index_tokens[0].src_filename,initdecl_identifier->index_tokens[0].logical_line.first,bootstrap);
 							}
 						}
 #if 0
@@ -14736,9 +14742,9 @@
 }
 
 //! \throw std::bad_alloc
-static void CPP_ContextParse(parse_tree& src,type_system& types)
+static void CPP_ContextParse(parse_tree& src)
 {
-	CPP_ParseNamespace(src,types,NULL);
+	CPP_ParseNamespace(src,NULL);
 }
 #/*cut-cpp*/
 

Modified: trunk/CSupport.hpp
===================================================================
--- trunk/CSupport.hpp	2010-11-02 03:01:19 UTC (rev 528)
+++ trunk/CSupport.hpp	2010-11-02 08:54:25 UTC (rev 529)
@@ -119,7 +119,7 @@
 	func_traits<const char* (*)(const char* x,size_t x_len)>::function_ref_type EchoReservedKeyword;
 	func_traits<const char* (*)(const char* x,size_t x_len)>::function_ref_type EchoReservedSymbol;
 	func_traits<void (*)(parse_tree&,const type_system&)>::function_ref_type ContextFreeParse;		// return true iff no errors
-	func_traits<void (*)(parse_tree&,type_system&)>::function_ref_type ContextParse;		// return true iff no errors
+	func_traits<void (*)(parse_tree&)>::function_ref_type ContextParse;		// return true iff no errors
 	// zcc 0.0.3
 	func_traits<void (*)(parse_tree&,const size_t,const type_system&)>::function_ref_type LocateExpression;
 	func_traits<bool (*)(const parse_tree&, bool&,const type_system&)>::function_ref_type LiteralConvertsToBool;

Modified: trunk/ZParser.cpp
===================================================================
--- trunk/ZParser.cpp	2010-11-02 03:01:19 UTC (rev 528)
+++ trunk/ZParser.cpp	2010-11-02 08:54:25 UTC (rev 529)
@@ -174,7 +174,7 @@
 	assert(ParsedList[0]->syntax_ok());
 #endif
 	die_on_parse_errors();
-	lang.pp_support->ContextParse(*ParsedList[0],types);
+	lang.pp_support->ContextParse(*ParsedList[0]);
 #ifndef ZAIMONI_FORCE_ISO
 	assert(ParsedList[0]->syntax_ok());
 #endif



From zaimoni at mail.berlios.de  Tue Nov  2 23:14:30 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue,  2 Nov 2010 23:14:30 +0100
Subject: [Zcplusplus-commits] r530 - trunk
Message-ID: <20101102221430.7A928480FE7@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-02 23:14:29 +0100 (Tue, 02 Nov 2010)
New Revision: 530

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
lines of code reduction; augment error message for already-defined enumeration

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-02 08:54:25 UTC (rev 529)
+++ trunk/CSupport.cpp	2010-11-02 22:14:29 UTC (rev 530)
@@ -1168,6 +1168,12 @@
 	message_header(src.filename(),src.loc().first);
 }
 
+static void message_header(const zaimoni::POD_pair<const char*,zaimoni::POD_pair<size_t,size_t> >& src)
+{
+	assert(src.first && *src.first);
+	message_header(src.first,src.second.first);
+}
+
 // balanced character count
 static POD_pair<size_t,size_t>
 _balanced_character_count(const weak_token* tokenlist,size_t tokenlist_len,const char l_match,const char r_match)
@@ -12460,21 +12466,20 @@
 		{
 		char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[0].token.first,active_namespace,"::") : NULL;
 		const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[0].token.first;
-		{
-		const type_system::enumerator_info* tmp = parse_tree::types->get_enumerator(fullname);
-		if (tmp)
+		if (const type_system::enumerator_info* fatal_def = parse_tree::types->get_enumerator(fullname))
 			{	// --do-what-i-mean could recover if the prior definition were identical
-				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined
+				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined (but scope matters)
 				// C++: One Definition Rule wipes out
 				//! \test decl.C99/Error_enum_multidef.h, decl.C99/Error_enum_multidef.hpp 
 			message_header(src.data<0>()[i].index_tokens[0]);
 			INC_INFORM(ERR_STR);
 			INFORM("enumerator is already defined (C99 6.7.2.2p3/C++98 3.2)");
+			message_header(fatal_def->second.second);
+			INFORM("prior definition here");
 			zcc_errors.inc_error();
 			free(namespace_name);
 			return false;
 			};
-		}
 		free(namespace_name);
 		}
 #if 0
@@ -12526,9 +12531,7 @@
 			{	// C++: One Definition Rule
 			};
 #endif
-		{
-		const zaimoni::POD_triple<type_spec,const char*,size_t>* const tmp = parse_tree::types->get_typedef_CPP(src.data<0>()[i].index_tokens[0].token.first,active_namespace); 
-		if (tmp)
+		if (const zaimoni::POD_triple<type_spec,const char*,size_t>* const tmp = parse_tree::types->get_typedef_CPP(src.data<0>()[i].index_tokens[0].token.first,active_namespace))
 			{	// C++: One Definition Rule
 				//! \test decl.C99/Error_enum_typedef.h, decl.C99/Error_enum_typedef.hpp 
 			message_header(src.data<0>()[i].index_tokens[0]);
@@ -12541,7 +12544,6 @@
 			zcc_errors.inc_error();
 			return false;
 			};
-		}
 
 		// The type and representation of an enumeration varies by language
 		// C: values are type int; actual representation can be decided after seeing all enumeration values.
@@ -12988,8 +12990,7 @@
 			if (tmp)
 				{
 				assert(0<parse_tree::types->use_count(tmp));
-				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
-				if (fatal_def)
+				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
 					{	//! \test zcc/decl.C99/Error_union_multidef.h
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -13056,8 +13057,7 @@
 			if (tmp)
 				{
 				assert(0<parse_tree::types->use_count(tmp));
-				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
-				if (fatal_def)
+				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
 					{	//! \test zcc/decl.C99/Error_struct_multidef.h
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -13870,8 +13870,7 @@
 			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
-				if (fatal_def)
+				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
 					{	//! \test zcc/decl.C99/Error_union_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -13937,8 +13936,7 @@
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
-				if (fatal_def)
+				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
 					{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -14004,8 +14002,7 @@
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
-				if (fatal_def)
+				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
 					{	//! \test zcc/decl.C99/Error_class_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-02 08:54:25 UTC (rev 529)
+++ trunk/CSupport.cpp.in	2010-11-02 22:14:29 UTC (rev 530)
@@ -1221,6 +1221,12 @@
 	assert(src.filename() && *src.filename());
 	message_header(src.filename(),src.loc().first);
 }
+
+static void message_header(const zaimoni::POD_pair<const char*,zaimoni::POD_pair<size_t,size_t> >& src)
+{
+	assert(src.first && *src.first);
+	message_header(src.first,src.second.first);
+}
 #/*cut-cpp*/
 
 // balanced character count
@@ -12604,21 +12610,20 @@
 		{
 		char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[0].token.first,active_namespace,"::") : NULL;
 		const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[0].token.first;
-		{
-		const type_system::enumerator_info* tmp = parse_tree::types->get_enumerator(fullname);
-		if (tmp)
+		if (const type_system::enumerator_info* fatal_def = parse_tree::types->get_enumerator(fullname))
 			{	// --do-what-i-mean could recover if the prior definition were identical
-				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined
+				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined (but scope matters)
 				// C++: One Definition Rule wipes out
 				//! \test decl.C99/Error_enum_multidef.h, decl.C99/Error_enum_multidef.hpp 
 			message_header(src.data<0>()[i].index_tokens[0]);
 			INC_INFORM(ERR_STR);
 			INFORM("enumerator is already defined (C99 6.7.2.2p3/C++98 3.2)");
+			message_header(fatal_def->second.second);
+			INFORM("prior definition here");
 			zcc_errors.inc_error();
 			free(namespace_name);
 			return false;
 			};
-		}
 		free(namespace_name);
 		}
 #if 0
@@ -12670,9 +12675,7 @@
 			{	// C++: One Definition Rule
 			};
 #endif
-		{
-		const zaimoni::POD_triple<type_spec,const char*,size_t>* const tmp = parse_tree::types->get_typedef_CPP(src.data<0>()[i].index_tokens[0].token.first,active_namespace); 
-		if (tmp)
+		if (const zaimoni::POD_triple<type_spec,const char*,size_t>* const tmp = parse_tree::types->get_typedef_CPP(src.data<0>()[i].index_tokens[0].token.first,active_namespace))
 			{	// C++: One Definition Rule
 				//! \test decl.C99/Error_enum_typedef.h, decl.C99/Error_enum_typedef.hpp 
 			message_header(src.data<0>()[i].index_tokens[0]);
@@ -12685,7 +12688,6 @@
 			zcc_errors.inc_error();
 			return false;
 			};
-		}
 
 		// The type and representation of an enumeration varies by language
 		// C: values are type int; actual representation can be decided after seeing all enumeration values.
@@ -13132,8 +13134,7 @@
 			if (tmp)
 				{
 				assert(0<parse_tree::types->use_count(tmp));
-				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
-				if (fatal_def)
+				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
 					{	//! \test zcc/decl.C99/Error_union_multidef.h
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -13200,8 +13201,7 @@
 			if (tmp)
 				{
 				assert(0<parse_tree::types->use_count(tmp));
-				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
-				if (fatal_def)
+				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
 					{	//! \test zcc/decl.C99/Error_struct_multidef.h
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -14014,8 +14014,7 @@
 			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
-				if (fatal_def)
+				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
 					{	//! \test zcc/decl.C99/Error_union_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -14081,8 +14080,7 @@
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
-				if (fatal_def)
+				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
 					{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -14148,8 +14146,7 @@
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
-				const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp);
-				if (fatal_def)
+				if (const C_union_struct_def* const fatal_def = parse_tree::types->get_C_structdef(tmp))
 					{	//! \test zcc/decl.C99/Error_class_multidef.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);



From zaimoni at mail.berlios.de  Tue Nov  2 23:59:58 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue,  2 Nov 2010 23:59:58 +0100
Subject: [Zcplusplus-commits] r531 - trunk
Message-ID: <20101102225958.78BDD480FE7@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-02 23:59:58 +0100 (Tue, 02 Nov 2010)
New Revision: 531

Modified:
   trunk/type_system.cpp
   trunk/type_system.cpp.in
Log:
start automatic cleanup of dead type specifications

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2010-11-02 22:14:29 UTC (rev 530)
+++ trunk/type_system.cpp	2010-11-02 22:59:58 UTC (rev 531)
@@ -273,7 +273,31 @@
 	if (core_types_size>=id) return;
 	if (SIZE_MAX==dynamic_types[id-=(core_types_size+1)].fourth) return;
 	assert(0<dynamic_types[id].fourth);
-	--dynamic_types[id].fourth;
+	if (0== --dynamic_types[id].fourth && dynamic_types.size()-1==id)
+		{	// type use count down to zero
+		switch(dynamic_types[id].third.second)
+		{
+#if 0
+		case DYNAMIC_FUNCTYPE:
+			delete dynamic_types[id].third.first.first;
+			dynamic_types[id].third.first.first = NULL;
+			break;
+#endif
+		case DYNAMIC_STRUCTDECL:
+			delete dynamic_types[id].third.first.second;
+			dynamic_types[id].third.first.second = NULL;
+			break;
+		case DYNAMIC_C_STRUCTDEF:
+			delete dynamic_types[id].third.first.third;
+			dynamic_types[id].third.first.third = NULL;
+			break;
+		case DYNAMIC_ENUMDEF:
+			delete dynamic_types[id].third.first.fourth;
+			dynamic_types[id].third.first.fourth = NULL;
+			break;
+		}
+		dynamic_types.DeleteIdx(id);		
+		}
 }
 
 const char* type_system::_name(size_t id) const

Modified: trunk/type_system.cpp.in
===================================================================
--- trunk/type_system.cpp.in	2010-11-02 22:14:29 UTC (rev 530)
+++ trunk/type_system.cpp.in	2010-11-02 22:59:58 UTC (rev 531)
@@ -284,7 +284,31 @@
 	if (core_types_size>=id) return;
 	if (SIZE_MAX==dynamic_types[id-=(core_types_size+1)].fourth) return;
 	assert(0<dynamic_types[id].fourth);
-	--dynamic_types[id].fourth;
+	if (0== --dynamic_types[id].fourth && dynamic_types.size()-1==id)
+		{	// type use count down to zero
+		switch(dynamic_types[id].third.second)
+		{
+#if 0
+		case DYNAMIC_FUNCTYPE:
+			delete dynamic_types[id].third.first.first;
+			dynamic_types[id].third.first.first = NULL;
+			break;
+#endif
+		case DYNAMIC_STRUCTDECL:
+			delete dynamic_types[id].third.first.second;
+			dynamic_types[id].third.first.second = NULL;
+			break;
+		case DYNAMIC_C_STRUCTDEF:
+			delete dynamic_types[id].third.first.third;
+			dynamic_types[id].third.first.third = NULL;
+			break;
+		case DYNAMIC_ENUMDEF:
+			delete dynamic_types[id].third.first.fourth;
+			dynamic_types[id].third.first.fourth = NULL;
+			break;
+		}
+		dynamic_types.DeleteIdx(id);		
+		}
 }
 #/*cut-cpp*/
 



From zaimoni at mail.berlios.de  Thu Nov  4 23:19:17 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu,  4 Nov 2010 23:19:17 +0100
Subject: [Zcplusplus-commits] r532 - trunk
Message-ID: <20101104221917.89819480F6E@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-04 23:19:16 +0100 (Thu, 04 Nov 2010)
New Revision: 532

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
tweak diagnosis of enum/union/struct/class to facilitate later parsing

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-02 22:59:58 UTC (rev 531)
+++ trunk/CSupport.cpp	2010-11-04 22:19:16 UTC (rev 532)
@@ -12805,6 +12805,102 @@
 		};
 }
 
+// ahem...morally should be macros; defensive coding
+#ifdef UNION_NAME
+#error internal enumerator UNION_NAME defined
+#undef UNION_NAME
+#endif
+#ifdef UNION_NAMED_DEF
+#error internal enumerator UNION_NAMED_DEF defined
+#undef UNION_NAMED_DEF
+#endif
+#ifdef UNION_ANON_DEF
+#error internal enumerator UNION_ANON_DEF defined
+#undef UNION_ANON_DEF
+#endif
+#ifdef STRUCT_NAME
+#error internal enumerator STRUCT_NAME defined
+#undef STRUCT_NAME
+#endif
+#ifdef STRUCT_NAMED_DEF
+#error internal enumerator STRUCT_NAMED_DEF defined
+#undef STRUCT_NAMED_DEF
+#endif
+#ifdef STRUCT_ANON_DEF
+#error internal enumerator STRUCT_ANON_DEF defined
+#undef STRUCT_ANON_DEF
+#endif
+#ifdef ENUM_NAME
+#error internal enumerator ENUM_NAME defined
+#undef ENUM_NAME
+#endif
+#ifdef ENUM_NAMED_DEF
+#error internal enumerator ENUM_NAMED_DEF defined
+#undef ENUM_NAMED_DEF
+#endif
+#ifdef ENUM_ANON_DEF
+#error internal enumerator ENUM_ANON_DEF defined
+#undef ENUM_ANON_DEF
+#endif
+#ifdef CLASS_NAME
+#error internal enumerator CLASS_NAME defined
+#undef CLASS_NAME
+#endif
+#ifdef CLASS_NAMED_DEF
+#error internal enumerator CLASS_NAMED_DEF defined
+#undef CLASS_NAMED_DEF
+#endif
+#ifdef CLASS_ANON_DEF
+#error internal enumerator CLASS_ANON_DEF defined
+#undef CLASS_ANON_DEF
+#endif
+enum C99_CPP_tag {
+	UNION_NAME = 1,
+	UNION_NAMED_DEF,
+	UNION_ANON_DEF,
+	STRUCT_NAME,
+	STRUCT_NAMED_DEF,
+	STRUCT_ANON_DEF,
+	ENUM_NAME,
+	ENUM_NAMED_DEF,
+	ENUM_ANON_DEF,
+	CLASS_NAME,
+	CLASS_NAMED_DEF,
+	CLASS_ANON_DEF
+};
+
+#ifdef ZCC_CORE_NOTICE_TAG
+#error internal macro ZCC_CORE_NOTICE_TAG defined
+#undef ZCC_CORE_NOTICE_TAG
+#endif
+#define ZCC_CORE_NOTICE_TAG(src)	\
+	if (is_C99_named_specifier(src,"union")) return UNION_NAME;	\
+	else if (is_C99_named_specifier_definition(src,"union")) return UNION_NAMED_DEF;	\
+	else if (is_C99_anonymous_specifier(src,"union")) return UNION_ANON_DEF;	\
+	else if (is_C99_named_specifier(src,"struct")) return STRUCT_NAME;	\
+	else if (is_C99_named_specifier_definition(src,"struct")) return STRUCT_NAMED_DEF;	\
+	else if (is_C99_anonymous_specifier(src,"struct")) return STRUCT_ANON_DEF;	\
+	else if (is_C99_named_specifier(src,"enum")) return ENUM_NAME;	\
+	else if (is_C99_named_specifier_definition(src,"enum")) return ENUM_NAMED_DEF;	\
+	else if (is_C99_anonymous_specifier(src,"enum")) return ENUM_ANON_DEF
+
+static int notice_C99_tag(const parse_tree& src)
+{
+	ZCC_CORE_NOTICE_TAG(src);
+	return 0;
+}
+
+static int notice_CPP_tag(const parse_tree& src)
+{
+	ZCC_CORE_NOTICE_TAG(src);
+	else if (is_C99_named_specifier(src,"class")) return CLASS_NAME;
+	else if (is_C99_named_specifier_definition(src,"class")) return CLASS_NAMED_DEF;
+	else if (is_C99_anonymous_specifier(src,"class")) return CLASS_ANON_DEF;
+	return 0;
+}
+
+#undef ZCC_CORE_NOTICE_TAG
+
 // will need: "function-type vector"
 // return: 1 typespec record (for now, other languages may have more demanding requirements)
 // incoming: n typespec records, flag for trailing ...
@@ -12841,8 +12937,16 @@
 			};
 		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// check naked declarations first
-		if (is_C99_named_specifier(src.data<0>()[i],"union"))
+		const int tag_type = notice_C99_tag(src.data<0>()[i]);
+		if (tag_type)
 			{
+			switch(tag_type)
+			{	//! \todo deal with indentation violations later
+#ifndef NDEBUG
+			default: _fatal_code("return value of notice_C99_tag out of range",3);
+#endif
+			case UNION_NAME:
+			{
 C99_union_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
@@ -12904,16 +13008,9 @@
 				i += 2;
 				continue;
 				}
-			else if (!tmp)
-				{	// used without at least forward-declaring
-					//! \bug needs test cases
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("used without at least forward-declaring");
-				zcc_errors.inc_error();
-				}
 			}
-		else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
+			break;
+			case STRUCT_NAME:
 			{
 C99_struct_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
@@ -12984,7 +13081,8 @@
 				zcc_errors.inc_error();
 				}
 			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
+			break;
+			case UNION_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
@@ -13051,7 +13149,8 @@
 				continue;
 				};
 			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
+			break;
+			case STRUCT_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
@@ -13118,7 +13217,8 @@
 				continue;
 				};
 			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
+			break;
+			case UNION_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_union);
@@ -13163,7 +13263,8 @@
 				continue;
 				}
 			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
+			break;
+			case STRUCT_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_struct);
@@ -13208,8 +13309,8 @@
 				continue;
 				}
 			}
-		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
-		else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
+			break;
+			case ENUM_NAME:
 			{	// C99 6.7.2.3: allowed only after name is defined
 			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
 				{
@@ -13227,7 +13328,8 @@
 					}
 				}
 			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
+			break;
+			case ENUM_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
@@ -13257,7 +13359,8 @@
 				return;
 				}
 			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
+			break;
+			case ENUM_ANON_DEF:
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 			const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
@@ -13267,7 +13370,10 @@
 				return;
 				}
 			}
-
+			break;
+			}
+			}
+			
 		// general declaration scanner 
 		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
 		// intercept declarations as follows
@@ -13656,8 +13762,16 @@
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// check naked declarations first; handle namespaces later
-		if (is_C99_named_specifier(src.data<0>()[i],"union"))
+		const int tag_type = notice_CPP_tag(src.data<0>()[i]);
+		if (tag_type)
 			{
+			switch(tag_type)
+			{	//! \todo deal with indentation violations later
+#ifndef NDEBUG
+			default: _fatal_code("return value of notice_C99_tag out of range",3);
+#endif
+			case UNION_NAME:
+			{
 CPP_union_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
@@ -13725,7 +13839,8 @@
 				zcc_errors.inc_error();
 				}
 			}
-		else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
+			break;
+			case STRUCT_NAME:
 			{
 CPP_struct_specifier:				
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
@@ -13795,7 +13910,8 @@
 				zcc_errors.inc_error();
 				}
 			}
-		else if (is_C99_named_specifier(src.data<0>()[i],"class"))
+			break;
+			case CLASS_NAME:
 			{
 CPP_class_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
@@ -13865,7 +13981,8 @@
 				zcc_errors.inc_error();
 				}
 			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
+			break;
+			case UNION_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
@@ -13931,7 +14048,8 @@
 				continue;
 				}
 			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
+			break;
+			case STRUCT_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
@@ -13997,7 +14115,8 @@
 				continue;
 				}
 			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
+			break;
+			case CLASS_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
@@ -14063,7 +14182,8 @@
 				continue;
 				}
 			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
+			break;
+			case UNION_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union);
@@ -14109,7 +14229,8 @@
 				continue;
 				}
 			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
+			break;
+			case STRUCT_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct);
@@ -14153,7 +14274,8 @@
 				continue;
 				}
 			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"class"))
+			break;
+			case CLASS_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class);
@@ -14197,9 +14319,8 @@
 				continue;
 				}
 			}
-		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
-		//! \todo actually, we can try forward-declare both scoped enums and enum-based enums (C++0X 7.2p3, these have enough size information); but other parts of the standard get in the way
-		else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
+			break;
+			case ENUM_NAME:
 			{
 			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
 				{
@@ -14219,7 +14340,8 @@
 				}
 			//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
 			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
+			break;
+			case ENUM_NAMED_DEF:
 			{	// can only define once
 			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
 			const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
@@ -14252,7 +14374,8 @@
 				return;
 				}
 			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
+			break;
+			case ENUM_ANON_DEF:
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 			const type_system::type_index tmp = parse_tree::types->register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
@@ -14262,6 +14385,9 @@
 				return;
 				}
 			}
+			break;
+			}
+			};
 
 		// namespace scanner
 		// need some scheme to handle unnamed namespaces (probably alphabetical counter after something illegal so unmatchable)

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-02 22:59:58 UTC (rev 531)
+++ trunk/CSupport.cpp.in	2010-11-04 22:19:16 UTC (rev 532)
@@ -12949,6 +12949,102 @@
 		};
 }
 
+// ahem...morally should be macros; defensive coding
+#ifdef UNION_NAME
+#error internal enumerator UNION_NAME defined
+#undef UNION_NAME
+#endif
+#ifdef UNION_NAMED_DEF
+#error internal enumerator UNION_NAMED_DEF defined
+#undef UNION_NAMED_DEF
+#endif
+#ifdef UNION_ANON_DEF
+#error internal enumerator UNION_ANON_DEF defined
+#undef UNION_ANON_DEF
+#endif
+#ifdef STRUCT_NAME
+#error internal enumerator STRUCT_NAME defined
+#undef STRUCT_NAME
+#endif
+#ifdef STRUCT_NAMED_DEF
+#error internal enumerator STRUCT_NAMED_DEF defined
+#undef STRUCT_NAMED_DEF
+#endif
+#ifdef STRUCT_ANON_DEF
+#error internal enumerator STRUCT_ANON_DEF defined
+#undef STRUCT_ANON_DEF
+#endif
+#ifdef ENUM_NAME
+#error internal enumerator ENUM_NAME defined
+#undef ENUM_NAME
+#endif
+#ifdef ENUM_NAMED_DEF
+#error internal enumerator ENUM_NAMED_DEF defined
+#undef ENUM_NAMED_DEF
+#endif
+#ifdef ENUM_ANON_DEF
+#error internal enumerator ENUM_ANON_DEF defined
+#undef ENUM_ANON_DEF
+#endif
+#ifdef CLASS_NAME
+#error internal enumerator CLASS_NAME defined
+#undef CLASS_NAME
+#endif
+#ifdef CLASS_NAMED_DEF
+#error internal enumerator CLASS_NAMED_DEF defined
+#undef CLASS_NAMED_DEF
+#endif
+#ifdef CLASS_ANON_DEF
+#error internal enumerator CLASS_ANON_DEF defined
+#undef CLASS_ANON_DEF
+#endif
+enum C99_CPP_tag {
+	UNION_NAME = 1,
+	UNION_NAMED_DEF,
+	UNION_ANON_DEF,
+	STRUCT_NAME,
+	STRUCT_NAMED_DEF,
+	STRUCT_ANON_DEF,
+	ENUM_NAME,
+	ENUM_NAMED_DEF,
+	ENUM_ANON_DEF,
+	CLASS_NAME,
+	CLASS_NAMED_DEF,
+	CLASS_ANON_DEF
+};
+
+#ifdef ZCC_CORE_NOTICE_TAG
+#error internal macro ZCC_CORE_NOTICE_TAG defined
+#undef ZCC_CORE_NOTICE_TAG
+#endif
+#define ZCC_CORE_NOTICE_TAG(src)	\
+	if (is_C99_named_specifier(src,"union")) return UNION_NAME;	\
+	else if (is_C99_named_specifier_definition(src,"union")) return UNION_NAMED_DEF;	\
+	else if (is_C99_anonymous_specifier(src,"union")) return UNION_ANON_DEF;	\
+	else if (is_C99_named_specifier(src,"struct")) return STRUCT_NAME;	\
+	else if (is_C99_named_specifier_definition(src,"struct")) return STRUCT_NAMED_DEF;	\
+	else if (is_C99_anonymous_specifier(src,"struct")) return STRUCT_ANON_DEF;	\
+	else if (is_C99_named_specifier(src,"enum")) return ENUM_NAME;	\
+	else if (is_C99_named_specifier_definition(src,"enum")) return ENUM_NAMED_DEF;	\
+	else if (is_C99_anonymous_specifier(src,"enum")) return ENUM_ANON_DEF
+
+static int notice_C99_tag(const parse_tree& src)
+{
+	ZCC_CORE_NOTICE_TAG(src);
+	return 0;
+}
+
+static int notice_CPP_tag(const parse_tree& src)
+{
+	ZCC_CORE_NOTICE_TAG(src);
+	else if (is_C99_named_specifier(src,"class")) return CLASS_NAME;
+	else if (is_C99_named_specifier_definition(src,"class")) return CLASS_NAMED_DEF;
+	else if (is_C99_anonymous_specifier(src,"class")) return CLASS_ANON_DEF;
+	return 0;
+}
+
+#undef ZCC_CORE_NOTICE_TAG
+
 // will need: "function-type vector"
 // return: 1 typespec record (for now, other languages may have more demanding requirements)
 // incoming: n typespec records, flag for trailing ...
@@ -12985,8 +13081,16 @@
 			};
 		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// check naked declarations first
-		if (is_C99_named_specifier(src.data<0>()[i],"union"))
+		const int tag_type = notice_C99_tag(src.data<0>()[i]);
+		if (tag_type)
 			{
+			switch(tag_type)
+			{	//! \todo deal with indentation violations later
+#ifndef NDEBUG
+			default: _fatal_code("return value of notice_C99_tag out of range",3);
+#endif
+			case UNION_NAME:
+			{
 C99_union_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
@@ -13048,16 +13152,9 @@
 				i += 2;
 				continue;
 				}
-			else if (!tmp)
-				{	// used without at least forward-declaring
-					//! \bug needs test cases
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(ERR_STR);
-				INFORM("used without at least forward-declaring");
-				zcc_errors.inc_error();
-				}
 			}
-		else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
+			break;
+			case STRUCT_NAME:
 			{
 C99_struct_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
@@ -13128,7 +13225,8 @@
 				zcc_errors.inc_error();
 				}
 			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
+			break;
+			case UNION_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
@@ -13195,7 +13293,8 @@
 				continue;
 				};
 			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
+			break;
+			case STRUCT_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
@@ -13262,7 +13361,8 @@
 				continue;
 				};
 			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
+			break;
+			case UNION_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_union);
@@ -13307,7 +13407,8 @@
 				continue;
 				}
 			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
+			break;
+			case STRUCT_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_struct);
@@ -13352,8 +13453,8 @@
 				continue;
 				}
 			}
-		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
-		else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
+			break;
+			case ENUM_NAME:
 			{	// C99 6.7.2.3: allowed only after name is defined
 			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
 				{
@@ -13371,7 +13472,8 @@
 					}
 				}
 			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
+			break;
+			case ENUM_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
@@ -13401,7 +13503,8 @@
 				return;
 				}
 			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
+			break;
+			case ENUM_ANON_DEF:
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 			const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
@@ -13411,7 +13514,10 @@
 				return;
 				}
 			}
-
+			break;
+			}
+			}
+			
 		// general declaration scanner 
 		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
 		// intercept declarations as follows
@@ -13800,8 +13906,16 @@
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// check naked declarations first; handle namespaces later
-		if (is_C99_named_specifier(src.data<0>()[i],"union"))
+		const int tag_type = notice_CPP_tag(src.data<0>()[i]);
+		if (tag_type)
 			{
+			switch(tag_type)
+			{	//! \todo deal with indentation violations later
+#ifndef NDEBUG
+			default: _fatal_code("return value of notice_C99_tag out of range",3);
+#endif
+			case UNION_NAME:
+			{
 CPP_union_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
@@ -13869,7 +13983,8 @@
 				zcc_errors.inc_error();
 				}
 			}
-		else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
+			break;
+			case STRUCT_NAME:
 			{
 CPP_struct_specifier:				
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
@@ -13939,7 +14054,8 @@
 				zcc_errors.inc_error();
 				}
 			}
-		else if (is_C99_named_specifier(src.data<0>()[i],"class"))
+			break;
+			case CLASS_NAME:
 			{
 CPP_class_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
@@ -14009,7 +14125,8 @@
 				zcc_errors.inc_error();
 				}
 			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
+			break;
+			case UNION_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
@@ -14075,7 +14192,8 @@
 				continue;
 				}
 			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
+			break;
+			case STRUCT_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
@@ -14141,7 +14259,8 @@
 				continue;
 				}
 			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
+			break;
+			case CLASS_NAMED_DEF:
 			{	// can only define once
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
@@ -14207,7 +14326,8 @@
 				continue;
 				}
 			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
+			break;
+			case UNION_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union);
@@ -14253,7 +14373,8 @@
 				continue;
 				}
 			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
+			break;
+			case STRUCT_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct);
@@ -14297,7 +14418,8 @@
 				continue;
 				}
 			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"class"))
+			break;
+			case CLASS_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class);
@@ -14341,9 +14463,8 @@
 				continue;
 				}
 			}
-		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
-		//! \todo actually, we can try forward-declare both scoped enums and enum-based enums (C++0X 7.2p3, these have enough size information); but other parts of the standard get in the way
-		else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
+			break;
+			case ENUM_NAME:
 			{
 			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
 				{
@@ -14363,7 +14484,8 @@
 				}
 			//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
 			}
-		else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
+			break;
+			case ENUM_NAMED_DEF:
 			{	// can only define once
 			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
 			const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
@@ -14396,7 +14518,8 @@
 				return;
 				}
 			}
-		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
+			break;
+			case ENUM_ANON_DEF:
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 			const type_system::type_index tmp = parse_tree::types->register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
@@ -14406,6 +14529,9 @@
 				return;
 				}
 			}
+			break;
+			}
+			};
 
 		// namespace scanner
 		// need some scheme to handle unnamed namespaces (probably alphabetical counter after something illegal so unmatchable)



From zaimoni at mail.berlios.de  Fri Nov  5 19:01:37 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri,  5 Nov 2010 19:01:37 +0100
Subject: [Zcplusplus-commits] r533 - trunk
Message-ID: <20101105180137.D8F27480A0D@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-05 19:01:37 +0100 (Fri, 05 Nov 2010)
New Revision: 533

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
object file size, line count reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-04 22:19:16 UTC (rev 532)
+++ trunk/CSupport.cpp	2010-11-05 18:01:37 UTC (rev 533)
@@ -12901,6 +12901,32 @@
 
 #undef ZCC_CORE_NOTICE_TAG
 
+static type_system::type_index _forward_declare_C_union(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	src.c_array<0>()[i].type_code.set_type(tmp2);
+	src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+	return tmp2;
+}
+
+static type_system::type_index _forward_declare_C_struct(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	src.c_array<0>()[i].type_code.set_type(tmp2);
+	src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+	return tmp2;
+}
+
 // will need: "function-type vector"
 // return: 1 typespec record (for now, other languages may have more demanding requirements)
 // incoming: n typespec records, flag for trailing ...
@@ -12955,20 +12981,11 @@
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
+				}
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_union_forward_def.h
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_union_forward_def.h
+			else _forward_declare_C_union(src,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here (C99 6.7.2.3)
@@ -13004,7 +13021,6 @@
 					}
 				// forward-declare
 				//! \test zcc/decl.C99/Pass_union_forward_def.h
-				assert(tmp2);
 				i += 2;
 				continue;
 				}
@@ -13020,20 +13036,11 @@
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
+				}
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_struct_forward_def.h
+			else _forward_declare_C_struct(src,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here (C99 6.7.2.3)
@@ -13068,7 +13075,6 @@
 					}
 				// forward-declare
 				//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				assert(tmp2);
 				i += 2;
 				continue;
 				}
@@ -13109,17 +13115,8 @@
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_union_forward_def.h
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_union_forward_def.h
+			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_C_union(src,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
@@ -13177,17 +13174,8 @@
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or union must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_struct_forward_def.h
+			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_C_struct(src,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
@@ -13785,8 +13773,8 @@
 			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
@@ -13855,8 +13843,8 @@
 			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
@@ -13926,8 +13914,8 @@
 			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
@@ -14011,8 +13999,8 @@
 			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
@@ -14078,8 +14066,8 @@
 			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
@@ -14145,8 +14133,8 @@
 			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-04 22:19:16 UTC (rev 532)
+++ trunk/CSupport.cpp.in	2010-11-05 18:01:37 UTC (rev 533)
@@ -13045,6 +13045,32 @@
 
 #undef ZCC_CORE_NOTICE_TAG
 
+static type_system::type_index _forward_declare_C_union(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	src.c_array<0>()[i].type_code.set_type(tmp2);
+	src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+	return tmp2;
+}
+
+static type_system::type_index _forward_declare_C_struct(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	src.c_array<0>()[i].type_code.set_type(tmp2);
+	src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+	return tmp2;
+}
+
 // will need: "function-type vector"
 // return: 1 typespec record (for now, other languages may have more demanding requirements)
 // incoming: n typespec records, flag for trailing ...
@@ -13099,20 +13125,11 @@
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
+				}
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_union_forward_def.h
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_union_forward_def.h
+			else _forward_declare_C_union(src,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here (C99 6.7.2.3)
@@ -13148,7 +13165,6 @@
 					}
 				// forward-declare
 				//! \test zcc/decl.C99/Pass_union_forward_def.h
-				assert(tmp2);
 				i += 2;
 				continue;
 				}
@@ -13164,20 +13180,11 @@
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
+				}
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_struct_forward_def.h
+			else _forward_declare_C_struct(src,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here (C99 6.7.2.3)
@@ -13212,7 +13219,6 @@
 					}
 				// forward-declare
 				//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				assert(tmp2);
 				i += 2;
 				continue;
 				}
@@ -13253,17 +13259,8 @@
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_union_forward_def.h
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_union_forward_def.h
+			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_C_union(src,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
@@ -13321,17 +13318,8 @@
 				};
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or union must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_struct_forward_def.h
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_struct_forward_def.h
+			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_C_struct(src,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
@@ -13929,8 +13917,8 @@
 			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
@@ -13999,8 +13987,8 @@
 			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
@@ -14070,8 +14058,8 @@
 			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
@@ -14155,8 +14143,8 @@
 			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
@@ -14222,8 +14210,8 @@
 			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
@@ -14289,8 +14277,8 @@
 			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
 			if (tmp2)
 				{	//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-				assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 				assert(parse_tree::types->get_structdecl(tmp2));
 				src.c_array<0>()[i].type_code.set_type(tmp2);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;



From zaimoni at mail.berlios.de  Sat Nov  6 06:14:27 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat,  6 Nov 2010 06:14:27 +0100
Subject: [Zcplusplus-commits] r534 - trunk
Message-ID: <20101106051427.924D2480A41@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-06 06:14:27 +0100 (Sat, 06 Nov 2010)
New Revision: 534

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
line count reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-05 18:01:37 UTC (rev 533)
+++ trunk/CSupport.cpp	2010-11-06 05:14:27 UTC (rev 534)
@@ -13707,6 +13707,45 @@
 		}
 }
 
+static type_system::type_index _forward_declare_CPP_union(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	src.c_array<0>()[i].type_code.set_type(tmp2);
+	src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+	return tmp2;
+}
+
+static type_system::type_index _forward_declare_CPP_struct(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	src.c_array<0>()[i].type_code.set_type(tmp2);
+	src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+	return tmp2;
+}
+
+static type_system::type_index _forward_declare_CPP_class(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	src.c_array<0>()[i].type_code.set_type(tmp2);
+	src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+	return tmp2;
+}
+
 // handle namespaces or else
 //! \todo check that the fact all literals are already legal-form is used
 //! \throw std::bad_alloc
@@ -13767,20 +13806,10 @@
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
+				}
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			assert(tmp || tmp2);
+			else _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
@@ -13814,7 +13843,6 @@
 					continue;					
 					};
 				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(tmp2);
 				i += 2;
 				continue;
 				}
@@ -13837,20 +13865,11 @@
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
+				}
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
@@ -13885,7 +13904,6 @@
 					}
 				// forward-declare
 				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				assert(tmp2);
 				i += 2;
 				continue;
 				}
@@ -13908,20 +13926,11 @@
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
+				}
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
@@ -13956,7 +13965,6 @@
 					}
 				// forward-declare
 				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				assert(tmp2);
 				i += 2;
 				continue;
 				}
@@ -13996,17 +14004,8 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
@@ -14063,17 +14062,8 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
@@ -14130,17 +14120,8 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-05 18:01:37 UTC (rev 533)
+++ trunk/CSupport.cpp.in	2010-11-06 05:14:27 UTC (rev 534)
@@ -13851,6 +13851,45 @@
 		}
 }
 
+static type_system::type_index _forward_declare_CPP_union(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	src.c_array<0>()[i].type_code.set_type(tmp2);
+	src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+	return tmp2;
+}
+
+static type_system::type_index _forward_declare_CPP_struct(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	src.c_array<0>()[i].type_code.set_type(tmp2);
+	src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+	return tmp2;
+}
+
+static type_system::type_index _forward_declare_CPP_class(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+{
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+	assert(tmp2);
+	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
+	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+	assert(parse_tree::types->get_structdecl(tmp2));
+	src.c_array<0>()[i].type_code.set_type(tmp2);
+	src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+	return tmp2;
+}
+
 // handle namespaces or else
 //! \todo check that the fact all literals are already legal-form is used
 //! \throw std::bad_alloc
@@ -13911,20 +13950,10 @@
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
+				}
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			assert(tmp || tmp2);
+			else _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
@@ -13958,7 +13987,6 @@
 					continue;					
 					};
 				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(tmp2);
 				i += 2;
 				continue;
 				}
@@ -13981,20 +14009,11 @@
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
+				}
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
@@ -14029,7 +14048,6 @@
 					}
 				// forward-declare
 				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				assert(tmp2);
 				i += 2;
 				continue;
 				}
@@ -14052,20 +14070,11 @@
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
+				}
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
@@ -14100,7 +14109,6 @@
 					}
 				// forward-declare
 				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				assert(tmp2);
 				i += 2;
 				continue;
 				}
@@ -14140,17 +14148,8 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-				assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
@@ -14207,17 +14206,8 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
@@ -14274,17 +14264,8 @@
 				};
 			//! \bug [find citation] states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = tmp ? 0 : parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
-			if (tmp2)
-				{	//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
-				assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
-				assert(parse_tree::types->get_structdecl(tmp2));
-				src.c_array<0>()[i].type_code.set_type(tmp2);
-				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
-				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			assert(tmp || tmp2);
+			//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);



From zaimoni at mail.berlios.de  Mon Nov  8 20:56:55 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon,  8 Nov 2010 20:56:55 +0100
Subject: [Zcplusplus-commits] r535 - trunk
Message-ID: <20101108195656.0132A4810DA@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-08 20:56:55 +0100 (Mon, 08 Nov 2010)
New Revision: 535

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
object file size reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-06 05:14:27 UTC (rev 534)
+++ trunk/CSupport.cpp	2010-11-08 19:56:55 UTC (rev 535)
@@ -12901,30 +12901,38 @@
 
 #undef ZCC_CORE_NOTICE_TAG
 
-static type_system::type_index _forward_declare_C_union(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+static void _forward_declare_C_union(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
+	parse_tree& tmp = src.c_array<0>()[i];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union));
+#else
 	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
 	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
 	assert(parse_tree::types->get_structdecl(tmp2));
-	src.c_array<0>()[i].type_code.set_type(tmp2);
-	src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_UNION_TYPE;
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-	return tmp2;
 }
 
-static type_system::type_index _forward_declare_C_struct(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+static void _forward_declare_C_struct(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
+	parse_tree& tmp = src.c_array<0>()[i];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct));
+#else
 	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
 	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
 	assert(parse_tree::types->get_structdecl(tmp2));
-	src.c_array<0>()[i].type_code.set_type(tmp2);
-	src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-	return tmp2;
 }
 
 // will need: "function-type vector"
@@ -12963,6 +12971,7 @@
 			};
 		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// check naked declarations first
+reparse:
 		const int tag_type = notice_C99_tag(src.data<0>()[i]);
 		if (tag_type)
 			{
@@ -12973,7 +12982,6 @@
 #endif
 			case UNION_NAME:
 			{
-C99_union_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
@@ -13028,7 +13036,6 @@
 			break;
 			case STRUCT_NAME:
 			{
-C99_struct_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
@@ -13107,18 +13114,18 @@
 					// reduce to named-specifier
 					src.c_array<0>()[i].DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-					goto C99_union_specifier;
+					goto reparse;
 					}
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
+				}
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.h
-			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_C_union(src,i,invariant_decl_scanner);
+			else _forward_declare_C_union(src,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
+			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
@@ -13166,18 +13173,18 @@
 					// reduce to named-specifier
 					src.c_array<0>()[i].DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-					goto C99_struct_specifier;
+					goto reparse;
 					}
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
+				}
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or union must error
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_struct_forward_def.h
-			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_C_struct(src,i,invariant_decl_scanner);
+			else _forward_declare_C_struct(src,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
+			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
@@ -13707,43 +13714,55 @@
 		}
 }
 
-static type_system::type_index _forward_declare_CPP_union(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+static void _forward_declare_CPP_union(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
+	parse_tree& tmp = src.c_array<0>()[i];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union));
+#else
 	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
 	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 	assert(parse_tree::types->get_structdecl(tmp2));
-	src.c_array<0>()[i].type_code.set_type(tmp2);
-	src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_UNION_TYPE;
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-	return tmp2;
 }
 
-static type_system::type_index _forward_declare_CPP_struct(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+static void _forward_declare_CPP_struct(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
+	parse_tree& tmp = src.c_array<0>()[i];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct));
+#else
 	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 	assert(parse_tree::types->get_structdecl(tmp2));
-	src.c_array<0>()[i].type_code.set_type(tmp2);
-	src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-	return tmp2;
 }
 
-static type_system::type_index _forward_declare_CPP_class(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+static void _forward_declare_CPP_class(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
+	parse_tree& tmp = src.c_array<0>()[i];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class));
+#else
 	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 	assert(parse_tree::types->get_structdecl(tmp2));
-	src.c_array<0>()[i].type_code.set_type(tmp2);
-	src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-	return tmp2;
 }
 
 // handle namespaces or else
@@ -13789,6 +13808,7 @@
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// check naked declarations first; handle namespaces later
+reparse:
 		const int tag_type = notice_CPP_tag(src.data<0>()[i]);
 		if (tag_type)
 			{
@@ -13799,16 +13819,17 @@
 #endif
 			case UNION_NAME:
 			{
-CPP_union_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
+				assert(0<parse_tree::types->use_count(tmp));
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug [find citation] states that conflicting enum, struct, or class must error
+			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
+			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 			else _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -13858,15 +13879,15 @@
 			break;
 			case STRUCT_NAME:
 			{
-CPP_struct_specifier:				
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
+				assert(0<parse_tree::types->use_count(tmp));
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug [find citation] states that conflicting enum, struct, or class must error
+			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
@@ -13919,15 +13940,15 @@
 			break;
 			case CLASS_NAME:
 			{
-CPP_class_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
+				assert(0<parse_tree::types->use_count(tmp));
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug [find citation] states that conflicting enum, struct, or class must error
+			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
@@ -13996,18 +14017,18 @@
 					// reduce to named-specifier
 					src.c_array<0>()[i].DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-					goto CPP_union_specifier;
+					goto reparse;
 					}					
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			//! \bug [find citation] states that conflicting enum, struct, or class must error
+				}
+			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
+			else _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
+			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
@@ -14054,18 +14075,18 @@
 					// reduce to named-specifier
 					src.c_array<0>()[i].DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-					goto CPP_struct_specifier;
+					goto reparse;
 					}					
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			//! \bug [find citation] states that conflicting enum, struct, or class must error
+				}
+			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
+			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
+			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
@@ -14112,18 +14133,18 @@
 					// reduce to named-specifier
 					src.c_array<0>()[i].DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(src.data<0>()[i],"class"));
-					goto CPP_class_specifier;
+					goto reparse;
 					}					
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			//! \bug [find citation] states that conflicting enum, struct, or class must error
+				}
+			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
+			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
+			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-06 05:14:27 UTC (rev 534)
+++ trunk/CSupport.cpp.in	2010-11-08 19:56:55 UTC (rev 535)
@@ -13045,30 +13045,38 @@
 
 #undef ZCC_CORE_NOTICE_TAG
 
-static type_system::type_index _forward_declare_C_union(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+static void _forward_declare_C_union(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
+	parse_tree& tmp = src.c_array<0>()[i];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union));
+#else
 	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
 	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
 	assert(parse_tree::types->get_structdecl(tmp2));
-	src.c_array<0>()[i].type_code.set_type(tmp2);
-	src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_UNION_TYPE;
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-	return tmp2;
 }
 
-static type_system::type_index _forward_declare_C_struct(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+static void _forward_declare_C_struct(parse_tree& src, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
+	parse_tree& tmp = src.c_array<0>()[i];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct));
+#else
 	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
 	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
 	assert(parse_tree::types->get_structdecl(tmp2));
-	src.c_array<0>()[i].type_code.set_type(tmp2);
-	src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-	return tmp2;
 }
 
 // will need: "function-type vector"
@@ -13107,6 +13115,7 @@
 			};
 		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// check naked declarations first
+reparse:
 		const int tag_type = notice_C99_tag(src.data<0>()[i]);
 		if (tag_type)
 			{
@@ -13117,7 +13126,6 @@
 #endif
 			case UNION_NAME:
 			{
-C99_union_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
@@ -13172,7 +13180,6 @@
 			break;
 			case STRUCT_NAME:
 			{
-C99_struct_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{
@@ -13251,18 +13258,18 @@
 					// reduce to named-specifier
 					src.c_array<0>()[i].DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-					goto C99_union_specifier;
+					goto reparse;
 					}
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
+				}
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.h
-			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_C_union(src,i,invariant_decl_scanner);
+			else _forward_declare_C_union(src,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
+			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
@@ -13310,18 +13317,18 @@
 					// reduce to named-specifier
 					src.c_array<0>()[i].DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-					goto C99_struct_specifier;
+					goto reparse;
 					}
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
-				};
+				}
 			//! \bug C1X 6.7.2.3p2 states that conflicting enum or union must error
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_struct_forward_def.h
-			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_C_struct(src,i,invariant_decl_scanner);
+			else _forward_declare_C_struct(src,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
+			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
@@ -13851,43 +13858,55 @@
 		}
 }
 
-static type_system::type_index _forward_declare_CPP_union(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+static void _forward_declare_CPP_union(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
+	parse_tree& tmp = src.c_array<0>()[i];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union));
+#else
 	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
 	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 	assert(parse_tree::types->get_structdecl(tmp2));
-	src.c_array<0>()[i].type_code.set_type(tmp2);
-	src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_UNION_TYPE;
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-	return tmp2;
 }
 
-static type_system::type_index _forward_declare_CPP_struct(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+static void _forward_declare_CPP_struct(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
+	parse_tree& tmp = src.c_array<0>()[i];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct));
+#else
 	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 	assert(parse_tree::types->get_structdecl(tmp2));
-	src.c_array<0>()[i].type_code.set_type(tmp2);
-	src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-	return tmp2;
 }
 
-static type_system::type_index _forward_declare_CPP_class(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
+static void _forward_declare_CPP_class(parse_tree& src, const char* const active_namespace, size_t& i, kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner)
 {
+	parse_tree& tmp = src.c_array<0>()[i];
+#ifdef NDEBUG
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class));
+#else
 	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
 	assert(parse_tree::types->get_structdecl(tmp2));
-	src.c_array<0>()[i].type_code.set_type(tmp2);
-	src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+	tmp.type_code.set_type(tmp2);
+#endif
+	tmp.flags |= PARSE_CLASS_STRUCT_TYPE;
 	_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-	return tmp2;
 }
 
 // handle namespaces or else
@@ -13933,6 +13952,7 @@
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
 		// check naked declarations first; handle namespaces later
+reparse:
 		const int tag_type = notice_CPP_tag(src.data<0>()[i]);
 		if (tag_type)
 			{
@@ -13943,16 +13963,17 @@
 #endif
 			case UNION_NAME:
 			{
-CPP_union_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
+				assert(0<parse_tree::types->use_count(tmp));
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug [find citation] states that conflicting enum, struct, or class must error
+			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
+			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 			else _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -14002,15 +14023,15 @@
 			break;
 			case STRUCT_NAME:
 			{
-CPP_struct_specifier:				
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
+				assert(0<parse_tree::types->use_count(tmp));
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug [find citation] states that conflicting enum, struct, or class must error
+			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
@@ -14063,15 +14084,15 @@
 			break;
 			case CLASS_NAME:
 			{
-CPP_class_specifier:
 			const type_system::type_index tmp = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
 			if (tmp)
 				{
+				assert(0<parse_tree::types->use_count(tmp));
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug [find citation] states that conflicting enum, struct, or class must error
+			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
@@ -14140,18 +14161,18 @@
 					// reduce to named-specifier
 					src.c_array<0>()[i].DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(src.data<0>()[i],"union"));
-					goto CPP_union_specifier;
+					goto reparse;
 					}					
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			//! \bug [find citation] states that conflicting enum, struct, or class must error
+				}
+			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
-			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
+			else _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
+			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
@@ -14198,18 +14219,18 @@
 					// reduce to named-specifier
 					src.c_array<0>()[i].DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
-					goto CPP_struct_specifier;
+					goto reparse;
 					}					
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			//! \bug [find citation] states that conflicting enum, struct, or class must error
+				}
+			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
-			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
+			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
+			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
@@ -14256,18 +14277,18 @@
 					// reduce to named-specifier
 					src.c_array<0>()[i].DeleteIdx<2>(0);
 					assert(is_C99_named_specifier(src.data<0>()[i],"class"));
-					goto CPP_class_specifier;
+					goto reparse;
 					}					
 				src.c_array<0>()[i].type_code.set_type(tmp);
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
-				};
-			//! \bug [find citation] states that conflicting enum, struct, or class must error
+				}
+			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_class_forward_def.hpp
-			const type_system::type_index tmp2 = tmp ? 0 : _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
+			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
-			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
+			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);



From zaimoni at mail.berlios.de  Tue Nov  9 00:00:30 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue,  9 Nov 2010 00:00:30 +0100
Subject: [Zcplusplus-commits] r536 - in trunk: . tests/zcc/decl.C99
	tests/zcc.in/decl.C99
Message-ID: <20101108230031.707424810DA@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-09 00:00:30 +0100 (Tue, 09 Nov 2010)
New Revision: 536

Added:
   trunk/tests/zcc.in/decl.C99/Error_enum_as_union.in
   trunk/tests/zcc.in/decl.C99/Error_struct_as_union.in
   trunk/tests/zcc/decl.C99/Error_enum_as_union.h
   trunk/tests/zcc/decl.C99/Error_enum_as_union.hpp
   trunk/tests/zcc/decl.C99/Error_struct_as_union.h
   trunk/tests/zcc/decl.C99/Error_struct_as_union.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/type_spec.cpp
   trunk/type_system.hpp
   trunk/type_system.hpp.in
Log:
make using enum/struct tag as union an error

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-08 19:56:55 UTC (rev 535)
+++ trunk/CSupport.cpp	2010-11-08 23:00:30 UTC (rev 536)
@@ -12990,7 +12990,35 @@
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 				}
-			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_struct_as_union.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as struct (C99 6.7.2.3p2)");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
+				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_enum_as_union.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.h
 			else _forward_declare_C_union(src,i,invariant_decl_scanner);
@@ -13329,7 +13357,6 @@
 			const type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{	//! \test zcc/decl.C99/Error_enum_multidef.h
-				assert(0<parse_tree::types->use_count(tmp));
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("'enum ");
@@ -13348,6 +13375,7 @@
 			//! \test zcc/decl.C99/Pass_enum_def.h
 			const type_system::type_index tmp2 = parse_tree::types->register_enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			assert(parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+			src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
@@ -13359,6 +13387,7 @@
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 			const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
+			src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
@@ -13827,7 +13856,35 @@
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
+			// One Definition Rule states that conflicting enum, struct, or class must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_struct_as_union.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as struct or class (C++98 One Definition Rule)");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
+				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C++98 One Definition Rule)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 			else _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
@@ -14087,11 +14144,13 @@
 			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
+			assert(1 && 0<parse_tree::types->use_count(vr_tmp));
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
 			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(2 && 0<parse_tree::types->use_count(vr_tmp));
 			assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
 			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
@@ -14358,6 +14417,7 @@
 			// enum-specifier doesn't have a specific declaration mode
 			const type_system::type_index tmp2 = parse_tree::types->register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			assert(parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+			src.c_array<0>()[i].type_code.set_type(tmp2);	// C++: enums are own type
 			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp2,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
@@ -14369,6 +14429,7 @@
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 			const type_system::type_index tmp = parse_tree::types->register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
+			src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
 			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-08 19:56:55 UTC (rev 535)
+++ trunk/CSupport.cpp.in	2010-11-08 23:00:30 UTC (rev 536)
@@ -13134,7 +13134,35 @@
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 				}
-			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_struct_as_union.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as struct (C99 6.7.2.3p2)");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
+				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_enum_as_union.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.h
 			else _forward_declare_C_union(src,i,invariant_decl_scanner);
@@ -13473,7 +13501,6 @@
 			const type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
 			if (tmp)
 				{	//! \test zcc/decl.C99/Error_enum_multidef.h
-				assert(0<parse_tree::types->use_count(tmp));
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("'enum ");
@@ -13492,6 +13519,7 @@
 			//! \test zcc/decl.C99/Pass_enum_def.h
 			const type_system::type_index tmp2 = parse_tree::types->register_enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			assert(parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+			src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
@@ -13503,6 +13531,7 @@
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 			const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
+			src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
@@ -13971,7 +14000,35 @@
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
+			// One Definition Rule states that conflicting enum, struct, or class must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_struct_as_union.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as struct or class (C++98 One Definition Rule)");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
+				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C++98 One Definition Rule)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 			else _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);
@@ -14231,11 +14288,13 @@
 			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
+			assert(1 && 0<parse_tree::types->use_count(vr_tmp));
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
 			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(2 && 0<parse_tree::types->use_count(vr_tmp));
 			assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
 			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
@@ -14502,6 +14561,7 @@
 			// enum-specifier doesn't have a specific declaration mode
 			const type_system::type_index tmp2 = parse_tree::types->register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			assert(parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+			src.c_array<0>()[i].type_code.set_type(tmp2);	// C++: enums are own type
 			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp2,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
@@ -14513,6 +14573,7 @@
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 			const type_system::type_index tmp = parse_tree::types->register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
+			src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
 			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");

Added: trunk/tests/zcc/decl.C99/Error_enum_as_union.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_as_union.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_enum_as_union.h	2010-11-08 23:00:30 UTC (rev 536)
@@ -0,0 +1,10 @@
+// decl.C99\Error_enum_as_union.h
+// using enum as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+union bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_enum_as_union.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_as_union.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_enum_as_union.hpp	2010-11-08 23:00:30 UTC (rev 536)
@@ -0,0 +1,10 @@
+// decl.C99\Error_enum_as_union.hpp
+// using enum as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+union bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_struct_as_union.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_as_union.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_as_union.h	2010-11-08 23:00:30 UTC (rev 536)
@@ -0,0 +1,10 @@
+// decl.C99\Error_struct_as_union.h
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct bad_test {
+	int x_factor;
+};
+
+union bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_struct_as_union.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_as_union.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_as_union.hpp	2010-11-08 23:00:30 UTC (rev 536)
@@ -0,0 +1,10 @@
+// decl.C99\Error_struct_as_union.hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct bad_test {
+	int x_factor;
+};
+
+union bad_test;
+

Added: trunk/tests/zcc.in/decl.C99/Error_enum_as_union.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_as_union.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_as_union.in	2010-11-08 23:00:30 UTC (rev 536)
@@ -0,0 +1,10 @@
+SUFFIXES h hpp
+// using enum as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+union bad_test;
+

Added: trunk/tests/zcc.in/decl.C99/Error_struct_as_union.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_struct_as_union.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_struct_as_union.in	2010-11-08 23:00:30 UTC (rev 536)
@@ -0,0 +1,10 @@
+SUFFIXES h hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct bad_test {
+	int x_factor;
+};
+
+union bad_test;
+

Modified: trunk/type_spec.cpp
===================================================================
--- trunk/type_spec.cpp	2010-11-08 19:56:55 UTC (rev 535)
+++ trunk/type_spec.cpp	2010-11-08 23:00:30 UTC (rev 536)
@@ -86,7 +86,7 @@
 		}
 	else{	// non-enlarging doesn't throw
 #/*cut-cpp*/
-		if (parse_tree::types)
+		if (parse_tree::types && src.base_type_index!=dest.base_type_index)
 			{
 			parse_tree::types->unuse_type(dest.base_type_index);
 			parse_tree::types->use_type(src.base_type_index);
@@ -135,7 +135,7 @@
 	if (0==pointer_power) return false;
 	assert(lvalue & q_vector.data()[pointer_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
 #/*cut-cpp*/
-	if (parse_tree::types)
+	if (parse_tree::types && base_type_index!=dest.base_type_index)
 		{
 		parse_tree::types->unuse_type(dest.base_type_index);
 		parse_tree::types->use_type(base_type_index);
@@ -183,7 +183,7 @@
 	q_vector.resize(1);
 	q_vector.front() = '\0';
 #/*cut-cpp*/
-	if (parse_tree::types)
+	if (parse_tree::types && base_type_index!=_base_type_index)
 		{
 		parse_tree::types->unuse_type(base_type_index);
 		parse_tree::types->use_type(_base_type_index);

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2010-11-08 19:56:55 UTC (rev 535)
+++ trunk/type_system.hpp	2010-11-08 23:00:30 UTC (rev 536)
@@ -66,7 +66,7 @@
 		{
 		assert(core_types_size+dynamic_types.size()>=id);
 		if (core_types_size>=id) return SIZE_MAX;
-		return dynamic_types[id-core_types_size].fourth;
+		return dynamic_types[id-(core_types_size+1)].fourth;
 		}
 	const char* name(type_index id) const
 		{

Modified: trunk/type_system.hpp.in
===================================================================
--- trunk/type_system.hpp.in	2010-11-08 19:56:55 UTC (rev 535)
+++ trunk/type_system.hpp.in	2010-11-08 23:00:30 UTC (rev 536)
@@ -81,7 +81,7 @@
 		{
 		assert(core_types_size+dynamic_types.size()>=id);
 		if (core_types_size>=id) return SIZE_MAX;
-		return dynamic_types[id-core_types_size].fourth;
+		return dynamic_types[id-(core_types_size+1)].fourth;
 		}
 #/*cut-cpp*/
 	const char* name(type_index id) const



From zaimoni at mail.berlios.de  Tue Nov  9 03:55:42 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue,  9 Nov 2010 03:55:42 +0100
Subject: [Zcplusplus-commits] r537 - in trunk: . tests/zcc/decl.C99
	tests/zcc.in/decl.C99
Message-ID: <20101109025542.D61CD4810DA@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-09 03:55:42 +0100 (Tue, 09 Nov 2010)
New Revision: 537

Added:
   trunk/tests/zcc.in/decl.C99/Error_enum_as_union2.in
   trunk/tests/zcc.in/decl.C99/Error_struct_as_union2.in
   trunk/tests/zcc.in/decl.C99/Error_struct_as_union3.in
   trunk/tests/zcc.in/decl.C99/Error_struct_as_union4.in
   trunk/tests/zcc/decl.C99/Error_enum_as_union2.h
   trunk/tests/zcc/decl.C99/Error_enum_as_union2.hpp
   trunk/tests/zcc/decl.C99/Error_struct_as_union2.h
   trunk/tests/zcc/decl.C99/Error_struct_as_union2.hpp
   trunk/tests/zcc/decl.C99/Error_struct_as_union3.h
   trunk/tests/zcc/decl.C99/Error_struct_as_union3.hpp
   trunk/tests/zcc/decl.C99/Error_struct_as_union4.h
   trunk/tests/zcc/decl.C99/Error_struct_as_union4.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
make using enum/struct tag as union an error, part 2

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-08 23:00:30 UTC (rev 536)
+++ trunk/CSupport.cpp	2010-11-09 02:55:42 UTC (rev 537)
@@ -13148,7 +13148,37 @@
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 				}
-			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_struct_as_union.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as struct (C99 6.7.2.3p2)");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_enum_as_union.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.h
 			else _forward_declare_C_union(src,i,invariant_decl_scanner);
@@ -14080,7 +14110,37 @@
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
+			// One Definition Rule states that conflicting enum, struct, or class must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_struct_as_union.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as struct or class (C++98 One Definition Rule)");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C++98 One Definition Rule)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 			else _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-08 23:00:30 UTC (rev 536)
+++ trunk/CSupport.cpp.in	2010-11-09 02:55:42 UTC (rev 537)
@@ -13292,7 +13292,37 @@
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 				}
-			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_struct_as_union.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as struct (C99 6.7.2.3p2)");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_enum_as_union.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.h
 			else _forward_declare_C_union(src,i,invariant_decl_scanner);
@@ -14224,7 +14254,37 @@
 				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
+			// One Definition Rule states that conflicting enum, struct, or class must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_struct_as_union.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as struct or class (C++98 One Definition Rule)");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_enum_as_union.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C++98 One Definition Rule)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 			else _forward_declare_CPP_union(src,active_namespace,i,invariant_decl_scanner);

Added: trunk/tests/zcc/decl.C99/Error_enum_as_union2.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_as_union2.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_enum_as_union2.h	2010-11-09 02:55:42 UTC (rev 537)
@@ -0,0 +1,12 @@
+// decl.C99\Error_enum_as_union2.h
+// using enum as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+union bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_enum_as_union2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_as_union2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_enum_as_union2.hpp	2010-11-09 02:55:42 UTC (rev 537)
@@ -0,0 +1,12 @@
+// decl.C99\Error_enum_as_union2.hpp
+// using enum as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+union bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_struct_as_union2.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_as_union2.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_as_union2.h	2010-11-09 02:55:42 UTC (rev 537)
@@ -0,0 +1,12 @@
+// decl.C99\Error_struct_as_union2.h
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct bad_test {
+	int x_factor;
+};
+
+union bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_struct_as_union2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_as_union2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_as_union2.hpp	2010-11-09 02:55:42 UTC (rev 537)
@@ -0,0 +1,12 @@
+// decl.C99\Error_struct_as_union2.hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct bad_test {
+	int x_factor;
+};
+
+union bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_struct_as_union3.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_as_union3.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_as_union3.h	2010-11-09 02:55:42 UTC (rev 537)
@@ -0,0 +1,8 @@
+// decl.C99\Error_struct_as_union3.h
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct bad_test;
+
+union bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_struct_as_union3.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_as_union3.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_as_union3.hpp	2010-11-09 02:55:42 UTC (rev 537)
@@ -0,0 +1,8 @@
+// decl.C99\Error_struct_as_union3.hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct bad_test;
+
+union bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_struct_as_union4.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_as_union4.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_as_union4.h	2010-11-09 02:55:42 UTC (rev 537)
@@ -0,0 +1,10 @@
+// decl.C99\Error_struct_as_union4.h
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct bad_test;
+
+union bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_struct_as_union4.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_as_union4.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_as_union4.hpp	2010-11-09 02:55:42 UTC (rev 537)
@@ -0,0 +1,10 @@
+// decl.C99\Error_struct_as_union4.hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct bad_test;
+
+union bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc.in/decl.C99/Error_enum_as_union2.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_as_union2.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_as_union2.in	2010-11-09 02:55:42 UTC (rev 537)
@@ -0,0 +1,12 @@
+SUFFIXES h hpp
+// using enum as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+union bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc.in/decl.C99/Error_struct_as_union2.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_struct_as_union2.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_struct_as_union2.in	2010-11-09 02:55:42 UTC (rev 537)
@@ -0,0 +1,12 @@
+SUFFIXES h hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct bad_test {
+	int x_factor;
+};
+
+union bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc.in/decl.C99/Error_struct_as_union3.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_struct_as_union3.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_struct_as_union3.in	2010-11-09 02:55:42 UTC (rev 537)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct bad_test;
+
+union bad_test;
+

Added: trunk/tests/zcc.in/decl.C99/Error_struct_as_union4.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_struct_as_union4.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_struct_as_union4.in	2010-11-09 02:55:42 UTC (rev 537)
@@ -0,0 +1,10 @@
+SUFFIXES h hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct bad_test;
+
+union bad_test {
+	int x_factor;
+};
+



From zaimoni at mail.berlios.de  Tue Nov  9 05:33:01 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue,  9 Nov 2010 05:33:01 +0100
Subject: [Zcplusplus-commits] r538 - trunk
Message-ID: <20101109043301.69B3B4810E9@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-09 05:33:00 +0100 (Tue, 09 Nov 2010)
New Revision: 538

Modified:
   trunk/MakeMake.cfg
   trunk/POSIX.dep
Log:
build system adjust

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2010-11-09 02:55:42 UTC (rev 537)
+++ trunk/MakeMake.cfg	2010-11-09 04:33:00 UTC (rev 538)
@@ -1,5 +1,5 @@
 ########
-ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system_pp','ParseTree','type_spec_pp','CSupport_pp','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','end_nl','load_src','CPreproc_pp','CPreproc_autogen_pp'),
+ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','type_system_pp','ParseTree','type_spec_pp','CSupport_pp','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','end_nl','load_src','CPreproc_pp','CPreproc_autogen_pp'),
 				'zcc':('zcc','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','end_nl','load_src','CPreproc','CPreproc_autogen','ZParser')}
 MainPrograms = ['z_cpp','zcc']
 

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-11-09 02:55:42 UTC (rev 537)
+++ trunk/POSIX.dep	2010-11-09 04:33:00 UTC (rev 538)
@@ -1,5 +1,5 @@
-OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system_pp.o ParseTree.o type_spec_pp.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
-OBJECTS_Z_CPP_LINK_PRIORITY = type_spec_pp.o CPreproc_pp.o type_system_pp.o CSupport_pp.o CPreproc_autogen_pp.o ParseTree.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o uchar_blob.o CPUInfo.o unsigned_var_int.o z_cpp.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
+OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o type_system_pp.o ParseTree.o type_spec_pp.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
+OBJECTS_Z_CPP_LINK_PRIORITY = type_spec_pp.o CPreproc_pp.o type_system_pp.o CSupport_pp.o CPreproc_autogen_pp.o ParseTree.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o uchar_blob.o CPUInfo.o unsigned_var_int.o z_cpp.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
 
 OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
 OBJECTS_ZCC_LINK_PRIORITY = type_system.o CSupport.o CPreproc.o CPreproc_autogen.o ZParser.o ParseTree.o type_spec.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o uchar_blob.o CPUInfo.o unsigned_var_int.o zcc.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
@@ -15,7 +15,6 @@
 uchar_blob.o: uchar_blob.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp
 unsigned_var_int.o: unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp
 CPUInfo.o: CPUInfo.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp
-struct_type.o: struct_type.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp
 type_system_pp.o: type_system_pp.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec_pp.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
@@ -35,6 +34,7 @@
 CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system_pp.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/Perl_localize.hpp DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimon
 i.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h type_system.hpp Zaimoni.STL/Perl_localize.hpp
+struct_type.o: struct_type.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp
 type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 type_spec.o: type_spec.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 CSupport.o: CSupport.hpp _CSupport3.hpp _CSupport4.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp kleene_star.hpp cond_act.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_l
 t.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp



From zaimoni at mail.berlios.de  Tue Nov  9 06:26:17 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue,  9 Nov 2010 06:26:17 +0100
Subject: [Zcplusplus-commits] r539 - trunk
Message-ID: <20101109052617.CF2F3480B08@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-09 06:26:17 +0100 (Tue, 09 Nov 2010)
New Revision: 539

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/struct_type.cpp
   trunk/struct_type.hpp
   trunk/type_system.cpp
   trunk/type_system.cpp.in
   trunk/type_system.hpp
   trunk/type_system.hpp.in
Log:
actually record location information for union/struct/class declarations and forward definitions

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-09 04:33:00 UTC (rev 538)
+++ trunk/CSupport.cpp	2010-11-09 05:26:17 UTC (rev 539)
@@ -1162,7 +1162,7 @@
 }
 
 /* XXX this may belong with C_union_struct_def XXX */
-static void message_header(const C_union_struct_def& src)
+static void message_header(const union_struct_decl& src)
 {
 	assert(src.filename() && *src.filename());
 	message_header(src.filename(),src.loc().first);
@@ -12905,9 +12905,9 @@
 {
 	parse_tree& tmp = src.c_array<0>()[i];
 #ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union));
+	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
 #else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
 	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
@@ -12922,9 +12922,9 @@
 {
 	parse_tree& tmp = src.c_array<0>()[i];
 #ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct));
+	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
 #else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
 	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
@@ -13136,7 +13136,7 @@
 					INC_INFORM("'union ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 					INFORM("' already defined (C99 6.7.2.3p1)");
-					message_header(*fatal_def);
+					message_header(fatal_def->_decl);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
 					// reduce to named-specifier
@@ -13225,7 +13225,7 @@
 					INC_INFORM("'struct ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 					INFORM("' already defined (C99 6.7.2.3p1)");
-					message_header(*fatal_def);
+					message_header(fatal_def->_decl);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
 					// reduce to named-specifier
@@ -13274,7 +13274,7 @@
 			case UNION_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_union,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			assert(tmp2);
 			assert(parse_tree::types->get_structdecl(tmp2));
 
@@ -13320,7 +13320,7 @@
 			case STRUCT_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			assert(tmp2);
 			assert(parse_tree::types->get_structdecl(tmp2));
 
@@ -13777,9 +13777,9 @@
 {
 	parse_tree& tmp = src.c_array<0>()[i];
 #ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union));
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
 #else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
 	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
@@ -13794,9 +13794,9 @@
 {
 	parse_tree& tmp = src.c_array<0>()[i];
 #ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct));
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
 #else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
@@ -13811,9 +13811,9 @@
 {
 	parse_tree& tmp = src.c_array<0>()[i];
 #ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class));
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
 #else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
@@ -14098,7 +14098,7 @@
 					INC_INFORM("'union ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 					INFORM("' already defined (C++98 3.2p1)");
-					message_header(*fatal_def);
+					message_header(fatal_def->_decl);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
 					// reduce to named-specifier
@@ -14186,7 +14186,7 @@
 					INC_INFORM("'struct ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 					INFORM("' already defined (C++98 3.2p1)");
-					message_header(*fatal_def);
+					message_header(fatal_def->_decl);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
 					// reduce to named-specifier
@@ -14246,7 +14246,7 @@
 					INC_INFORM("'class ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 					INFORM("' already defined (C++98 3.2p1)");
-					message_header(*fatal_def);
+					message_header(fatal_def->_decl);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
 					// reduce to named-specifier
@@ -14295,7 +14295,7 @@
 			case UNION_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			assert(tmp2);
 
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
@@ -14342,7 +14342,7 @@
 			case STRUCT_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			assert(tmp2);
 			assert(parse_tree::types->get_structdecl(tmp2));
 			src.c_array<0>()[i].type_code.set_type(tmp2);
@@ -14387,7 +14387,7 @@
 			case CLASS_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			assert(tmp2);
 			assert(parse_tree::types->get_structdecl(tmp2));
 			src.c_array<0>()[i].type_code.set_type(tmp2);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-09 04:33:00 UTC (rev 538)
+++ trunk/CSupport.cpp.in	2010-11-09 05:26:17 UTC (rev 539)
@@ -1216,7 +1216,7 @@
 }
 
 /* XXX this may belong with C_union_struct_def XXX */
-static void message_header(const C_union_struct_def& src)
+static void message_header(const union_struct_decl& src)
 {
 	assert(src.filename() && *src.filename());
 	message_header(src.filename(),src.loc().first);
@@ -13049,9 +13049,9 @@
 {
 	parse_tree& tmp = src.c_array<0>()[i];
 #ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union));
+	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
 #else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first));
 	assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
@@ -13066,9 +13066,9 @@
 {
 	parse_tree& tmp = src.c_array<0>()[i];
 #ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct));
+	tmp.type_code.set_type(parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
 #else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
 	assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
@@ -13280,7 +13280,7 @@
 					INC_INFORM("'union ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 					INFORM("' already defined (C99 6.7.2.3p1)");
-					message_header(*fatal_def);
+					message_header(fatal_def->_decl);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
 					// reduce to named-specifier
@@ -13369,7 +13369,7 @@
 					INC_INFORM("'struct ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 					INFORM("' already defined (C99 6.7.2.3p1)");
-					message_header(*fatal_def);
+					message_header(fatal_def->_decl);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
 					// reduce to named-specifier
@@ -13418,7 +13418,7 @@
 			case UNION_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_union,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			assert(tmp2);
 			assert(parse_tree::types->get_structdecl(tmp2));
 
@@ -13464,7 +13464,7 @@
 			case STRUCT_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl("<unknown>",union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			assert(tmp2);
 			assert(parse_tree::types->get_structdecl(tmp2));
 
@@ -13921,9 +13921,9 @@
 {
 	parse_tree& tmp = src.c_array<0>()[i];
 #ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union));
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
 #else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
 	assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
@@ -13938,9 +13938,9 @@
 {
 	parse_tree& tmp = src.c_array<0>()[i];
 #ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct));
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
 #else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
@@ -13955,9 +13955,9 @@
 {
 	parse_tree& tmp = src.c_array<0>()[i];
 #ifdef NDEBUG
-	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class));
+	tmp.type_code.set_type(parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename));
 #else
-	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+	const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 	assert(tmp2);
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace));
 	assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
@@ -14242,7 +14242,7 @@
 					INC_INFORM("'union ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 					INFORM("' already defined (C++98 3.2p1)");
-					message_header(*fatal_def);
+					message_header(fatal_def->_decl);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
 					// reduce to named-specifier
@@ -14330,7 +14330,7 @@
 					INC_INFORM("'struct ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 					INFORM("' already defined (C++98 3.2p1)");
-					message_header(*fatal_def);
+					message_header(fatal_def->_decl);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
 					// reduce to named-specifier
@@ -14390,7 +14390,7 @@
 					INC_INFORM("'class ");
 					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 					INFORM("' already defined (C++98 3.2p1)");
-					message_header(*fatal_def);
+					message_header(fatal_def->_decl);
 					INFORM("prior definition here");
 					zcc_errors.inc_error();
 					// reduce to named-specifier
@@ -14439,7 +14439,7 @@
 			case UNION_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			assert(tmp2);
 
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
@@ -14486,7 +14486,7 @@
 			case STRUCT_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			assert(tmp2);
 			assert(parse_tree::types->get_structdecl(tmp2));
 			src.c_array<0>()[i].type_code.set_type(tmp2);
@@ -14531,7 +14531,7 @@
 			case CLASS_ANON_DEF:
 			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class);
+			const type_system::type_index tmp2 = parse_tree::types->register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			assert(tmp2);
 			assert(parse_tree::types->get_structdecl(tmp2));
 			src.c_array<0>()[i].type_code.set_type(tmp2);

Modified: trunk/struct_type.cpp
===================================================================
--- trunk/struct_type.cpp	2010-11-09 04:33:00 UTC (rev 538)
+++ trunk/struct_type.cpp	2010-11-09 05:26:17 UTC (rev 539)
@@ -5,17 +5,13 @@
 #include "Zaimoni.STL/Pure.C/auto_int.h"
 
 C_union_struct_def::C_union_struct_def(const union_struct_decl& src,const zaimoni::POD_pair<size_t,size_t>& logical_line,const char* src_filename)
-:	_logical_line(logical_line),
-	_src_filename(((src_filename && *src_filename) ? src_filename : NULL)),
-	_decl(src)
+:	_decl(src,logical_line,src_filename)
 {
 	assert(syntax_ok());
 }
 
 C_union_struct_def::C_union_struct_def(union_struct_decl::keywords keyword, const char* tag,const zaimoni::POD_pair<size_t,size_t>& logical_line, const char* src_filename)
-:	_logical_line(logical_line),
-	_src_filename(((src_filename && *src_filename) ? src_filename : NULL)),
-	_decl(keyword,tag)
+:	_decl(keyword,tag,logical_line,src_filename)
 {
 	assert(syntax_ok());
 }
@@ -78,8 +74,6 @@
 		}
 
 	_decl = src._decl;
-	_logical_line = src._logical_line;
-	_src_filename = src._src_filename;
 	assert(syntax_ok());
 	return *this;
 }

Modified: trunk/struct_type.hpp
===================================================================
--- trunk/struct_type.hpp	2010-11-09 04:33:00 UTC (rev 538)
+++ trunk/struct_type.hpp	2010-11-09 05:26:17 UTC (rev 539)
@@ -11,6 +11,8 @@
 private:
 	const char* _tag;	// NULL or ends in :: for anonymous
 	unsigned char _keyword;
+	zaimoni::POD_pair<size_t,size_t> _logical_line;
+	const char* _src_filename;
 public:
 	enum keywords {
 		decl_none = 0,
@@ -19,7 +21,16 @@
 		decl_class = 3		// default private access in C++; entries are in sequence (calculating layout requires target information)
 	};
 
-	union_struct_decl(keywords keyword, const char* tag) : _tag((tag && *tag ? tag : NULL)),_keyword((assert(keyword),keyword)) {};
+	union_struct_decl(keywords keyword, const char* tag,const zaimoni::POD_pair<size_t,size_t>& logical_line,const char* src_filename)
+	: _tag((tag && *tag ? tag : NULL)),
+	  _keyword((assert(keyword),keyword)),
+	  _logical_line(logical_line),
+	  _src_filename(((src_filename && *src_filename) ? src_filename : NULL)) {};
+	union_struct_decl(const union_struct_decl& src,const zaimoni::POD_pair<size_t,size_t>& logical_line,const char* src_filename)
+	: _tag(src._tag),
+	  _keyword(src._keyword),
+	  _logical_line(logical_line),
+	  _src_filename(((src_filename && *src_filename) ? src_filename : NULL)) {};	  
 	// defaults ok for: copy constructor, destructor, assignment operator
 
 	const char* tag() const {return _tag;};
@@ -27,13 +38,13 @@
 	friend bool operator==(const union_struct_decl& lhs,const union_struct_decl& rhs) {
 		return lhs._tag==rhs._tag && lhs._keyword==rhs._keyword;
 	};
+
+	const char* filename() const {return _src_filename;};
+	zaimoni::POD_pair<size_t,size_t> loc() const {return _logical_line;};
 };
 
 class C_union_struct_def
 {
-private:
-	zaimoni::POD_pair<size_t,size_t> _logical_line;
-	const char* _src_filename;
 public:
 	union_struct_decl _decl;
 	zaimoni::autovalarray_ptr_throws<type_spec> data_field_spec;
@@ -44,10 +55,6 @@
 	C_union_struct_def(const C_union_struct_def& src);
 	~C_union_struct_def();
 	const C_union_struct_def& operator=(const C_union_struct_def& src);
-
-	const char* filename() const {return _src_filename;};
-	zaimoni::POD_pair<size_t,size_t> loc() const {return _logical_line;};
-
 #ifndef NDEBUG
 	bool syntax_ok() const;
 #endif

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2010-11-09 04:33:00 UTC (rev 538)
+++ trunk/type_system.cpp	2010-11-09 05:26:17 UTC (rev 539)
@@ -730,7 +730,7 @@
 	return register_functype(name,src);
 }
 
-type_system::type_index type_system::register_structdecl(const char* const alias, int keyword)
+type_system::type_index type_system::register_structdecl(const char* const alias, int keyword,const zaimoni::POD_pair<size_t,size_t>& logical_line,const char* src_filename)
 {
 	assert(alias && *alias);
 	const size_t dynamic_types_size = dynamic_types.size();
@@ -740,7 +740,7 @@
 		FATAL("Host implementation limit exceeded: cannot record union/struct type used in program");
 
 	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_STRUCTDECL}};
-	tmp.third.first.second = new union_struct_decl((union_struct_decl::keywords)keyword,alias);
+	tmp.third.first.second = new union_struct_decl((union_struct_decl::keywords)keyword,alias,logical_line,src_filename);
 
 	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp))
 		{
@@ -750,7 +750,7 @@
 	return dynamic_types_size+1+core_types_size;
 }
 
-type_system::type_index type_system::register_structdecl_CPP(const char* name, const char* const active_namespace, int keyword)
+type_system::type_index type_system::register_structdecl_CPP(const char* name, const char* const active_namespace, int keyword,const zaimoni::POD_pair<size_t,size_t>& logical_line,const char* src_filename)
 {
 	assert(name && *name);
 
@@ -758,7 +758,7 @@
 	if (active_namespace && *active_namespace)
 		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
 
-	return register_structdecl(name,keyword);
+	return register_structdecl(name,keyword,logical_line,src_filename);
 }
 
 type_system::type_index type_system::register_C_structdef(const char* const alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename, int keyword)

Modified: trunk/type_system.cpp.in
===================================================================
--- trunk/type_system.cpp.in	2010-11-09 04:33:00 UTC (rev 538)
+++ trunk/type_system.cpp.in	2010-11-09 05:26:17 UTC (rev 539)
@@ -745,7 +745,7 @@
 	return register_functype(name,src);
 }
 
-type_system::type_index type_system::register_structdecl(const char* const alias, int keyword)
+type_system::type_index type_system::register_structdecl(const char* const alias, int keyword,const zaimoni::POD_pair<size_t,size_t>& logical_line,const char* src_filename)
 {
 	assert(alias && *alias);
 	const size_t dynamic_types_size = dynamic_types.size();
@@ -755,7 +755,7 @@
 		FATAL("Host implementation limit exceeded: cannot record union/struct type used in program");
 
 	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_STRUCTDECL}};
-	tmp.third.first.second = new union_struct_decl((union_struct_decl::keywords)keyword,alias);
+	tmp.third.first.second = new union_struct_decl((union_struct_decl::keywords)keyword,alias,logical_line,src_filename);
 
 	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp))
 		{
@@ -765,7 +765,7 @@
 	return dynamic_types_size+1+core_types_size;
 }
 
-type_system::type_index type_system::register_structdecl_CPP(const char* name, const char* const active_namespace, int keyword)
+type_system::type_index type_system::register_structdecl_CPP(const char* name, const char* const active_namespace, int keyword,const zaimoni::POD_pair<size_t,size_t>& logical_line,const char* src_filename)
 {
 	assert(name && *name);
 
@@ -773,7 +773,7 @@
 	if (active_namespace && *active_namespace)
 		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
 
-	return register_structdecl(name,keyword);
+	return register_structdecl(name,keyword,logical_line,src_filename);
 }
 
 type_system::type_index type_system::register_C_structdef(const char* const alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename, int keyword)

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2010-11-09 04:33:00 UTC (rev 538)
+++ trunk/type_system.hpp	2010-11-09 05:26:17 UTC (rev 539)
@@ -114,8 +114,8 @@
 	type_index register_functype(const char* const alias, function_type*& src);
 	type_index register_functype_CPP(const char* name, const char* active_namespace, function_type*& src);
 //	keyword actually should be type union_struct_decl::keywords, but that increases coupling unacceptably
-	type_index register_structdecl(const char* alias, int keyword);
-	type_index register_structdecl_CPP(const char* name, const char* active_namespace, int keyword);
+	type_index register_structdecl(const char* alias, int keyword,const zaimoni::POD_pair<size_t,size_t>& logical_line,const char* src_filename);
+	type_index register_structdecl_CPP(const char* name, const char* active_namespace, int keyword,const zaimoni::POD_pair<size_t,size_t>& logical_line,const char* src_filename);
 	type_index register_C_structdef(const char* alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename, int keyword);
 	type_index register_C_structdef_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename, int keyword);
 	type_index register_enum_def(const char* alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename);

Modified: trunk/type_system.hpp.in
===================================================================
--- trunk/type_system.hpp.in	2010-11-09 04:33:00 UTC (rev 538)
+++ trunk/type_system.hpp.in	2010-11-09 05:26:17 UTC (rev 539)
@@ -136,8 +136,8 @@
 	type_index register_functype(const char* const alias, function_type*& src);
 	type_index register_functype_CPP(const char* name, const char* active_namespace, function_type*& src);
 //	keyword actually should be type union_struct_decl::keywords, but that increases coupling unacceptably
-	type_index register_structdecl(const char* alias, int keyword);
-	type_index register_structdecl_CPP(const char* name, const char* active_namespace, int keyword);
+	type_index register_structdecl(const char* alias, int keyword,const zaimoni::POD_pair<size_t,size_t>& logical_line,const char* src_filename);
+	type_index register_structdecl_CPP(const char* name, const char* active_namespace, int keyword,const zaimoni::POD_pair<size_t,size_t>& logical_line,const char* src_filename);
 	type_index register_C_structdef(const char* alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename, int keyword);
 	type_index register_C_structdef_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename, int keyword);
 	type_index register_enum_def(const char* alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename);



From zaimoni at mail.berlios.de  Wed Nov 10 05:48:37 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 10 Nov 2010 05:48:37 +0100
Subject: [Zcplusplus-commits] r540 - in trunk: . tests/zcc/decl.C99
Message-ID: <20101110044837.9FB3B48112E@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-10 05:48:36 +0100 (Wed, 10 Nov 2010)
New Revision: 540

Added:
   trunk/tests/zcc/decl.C99/Error_class_as_union.hpp
   trunk/tests/zcc/decl.C99/Error_class_as_union2.hpp
   trunk/tests/zcc/decl.C99/Error_class_as_union3.hpp
   trunk/tests/zcc/decl.C99/Error_class_as_union4.hpp
   trunk/tests/zcc/decl.C99/Error_class_as_union5.hpp
   trunk/tests/zcc/decl.C99/Error_class_as_union6.hpp
   trunk/tests/zcc/decl.C99/Error_class_as_union7.hpp
   trunk/tests/zcc/decl.C99/Error_class_as_union8.hpp
   trunk/tests/zcc/decl.C99/Error_struct_as_union5.hpp
   trunk/tests/zcc/decl.C99/Error_struct_as_union6.hpp
   trunk/tests/zcc/decl.C99/Error_struct_as_union7.hpp
   trunk/tests/zcc/decl.C99/Error_struct_as_union8.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/type_system.cpp
   trunk/type_system.cpp.in
Log:
increase test case coverage for erroring when referring to class/struct as union

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-09 05:26:17 UTC (rev 539)
+++ trunk/CSupport.cpp	2010-11-10 04:48:36 UTC (rev 540)
@@ -12993,11 +12993,16 @@
 			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
 				{	//! \test zcc/decl.C99/Error_struct_as_union.h
+					//! \test zcc/decl.C99/Error_struct_as_union3.h
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("union ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
 				INFORM(" declared as struct (C99 6.7.2.3p2)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
 				zcc_errors.inc_error();
 				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
 				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
@@ -13150,12 +13155,17 @@
 				}
 			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_struct_as_union.h
+				{	//! \test zcc/decl.C99/Error_struct_as_union2.h
+					//! \test zcc/decl.C99/Error_struct_as_union4.h
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("union ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
 				INFORM(" declared as struct (C99 6.7.2.3p2)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
 				zcc_errors.inc_error();
 				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
 				src.c_array<0>()[i].DeleteIdx<2>(0);
@@ -13675,16 +13685,8 @@
 
 	if (types.get_enum_def(src.base_type_index))
 		INC_INFORM("enum ");
-	else{
-		zaimoni::POD_pair<const union_struct_decl*,const C_union_struct_def*> tmp;
-		tmp.first = types.get_structdecl(src.base_type_index);
-		if (tmp.first) INC_INFORM(text_from_keyword(*tmp.first));
-		else{
-			tmp.second = types.get_C_structdef(src.base_type_index);
-			if (tmp.second)
-				INC_INFORM(text_from_keyword(tmp.second->_decl));
-			}
-		}
+	else if (const union_struct_decl* tmp = types.get_structdecl(src.base_type_index))
+		INC_INFORM(text_from_keyword(*tmp));
 	INC_INFORM(type_name ? type_name : "<unresolved type>");
 
 	while(0<start_ptr_scan--)
@@ -13889,11 +13891,20 @@
 			// One Definition Rule states that conflicting enum, struct, or class must error
 			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
 				{	//! \test zcc/decl.C99/Error_struct_as_union.hpp
+					//! \test zcc/decl.C99/Error_struct_as_union3.hpp
+					//! \test zcc/decl.C99/Error_class_as_union.hpp
+					//! \test zcc/decl.C99/Error_class_as_union3.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("union ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as struct or class (C++98 One Definition Rule)");
+				INFORM(" declared as ");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				INC_INFORM(text_from_keyword(*tmp2));
+				INFORM(" (C++98 One Definition Rule)");
+				message_header(*tmp2);
+				INFORM("prior definition here");
 				zcc_errors.inc_error();
 				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
 				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
@@ -14112,12 +14123,21 @@
 				}
 			// One Definition Rule states that conflicting enum, struct, or class must error
 			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_struct_as_union.hpp
+				{	//! \test zcc/decl.C99/Error_struct_as_union2.hpp
+					//! \test zcc/decl.C99/Error_struct_as_union4.hpp
+					//! \test zcc/decl.C99/Error_class_as_union2.hpp
+					//! \test zcc/decl.C99/Error_class_as_union4.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("union ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as struct or class (C++98 One Definition Rule)");
+				INFORM(" declared as ");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				INC_INFORM(text_from_keyword(*tmp2));
+				INFORM(" (C++98 One Definition Rule)");
+				message_header(*tmp2);
+				INFORM("prior definition here");
 				zcc_errors.inc_error();
 				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
 				src.c_array<0>()[i].DeleteIdx<2>(0);
@@ -14151,7 +14171,7 @@
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
 			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==vr_tmp);
 			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -14211,7 +14231,7 @@
 			//! \todo record field structure, etc.
 			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
 			assert(2 && 0<parse_tree::types->use_count(vr_tmp));
-			assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==vr_tmp);
 			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -14269,7 +14289,7 @@
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
 			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==vr_tmp);
 			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-09 05:26:17 UTC (rev 539)
+++ trunk/CSupport.cpp.in	2010-11-10 04:48:36 UTC (rev 540)
@@ -13137,11 +13137,16 @@
 			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
 				{	//! \test zcc/decl.C99/Error_struct_as_union.h
+					//! \test zcc/decl.C99/Error_struct_as_union3.h
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("union ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
 				INFORM(" declared as struct (C99 6.7.2.3p2)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
 				zcc_errors.inc_error();
 				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
 				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
@@ -13294,12 +13299,17 @@
 				}
 			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
 			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
-				{	//! \test zcc/decl.C99/Error_struct_as_union.h
+				{	//! \test zcc/decl.C99/Error_struct_as_union2.h
+					//! \test zcc/decl.C99/Error_struct_as_union4.h
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("union ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
 				INFORM(" declared as struct (C99 6.7.2.3p2)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
 				zcc_errors.inc_error();
 				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
 				src.c_array<0>()[i].DeleteIdx<2>(0);
@@ -13819,16 +13829,8 @@
 
 	if (types.get_enum_def(src.base_type_index))
 		INC_INFORM("enum ");
-	else{
-		zaimoni::POD_pair<const union_struct_decl*,const C_union_struct_def*> tmp;
-		tmp.first = types.get_structdecl(src.base_type_index);
-		if (tmp.first) INC_INFORM(text_from_keyword(*tmp.first));
-		else{
-			tmp.second = types.get_C_structdef(src.base_type_index);
-			if (tmp.second)
-				INC_INFORM(text_from_keyword(tmp.second->_decl));
-			}
-		}
+	else if (const union_struct_decl* tmp = types.get_structdecl(src.base_type_index))
+		INC_INFORM(text_from_keyword(*tmp));
 	INC_INFORM(type_name ? type_name : "<unresolved type>");
 
 	while(0<start_ptr_scan--)
@@ -14033,11 +14035,20 @@
 			// One Definition Rule states that conflicting enum, struct, or class must error
 			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
 				{	//! \test zcc/decl.C99/Error_struct_as_union.hpp
+					//! \test zcc/decl.C99/Error_struct_as_union3.hpp
+					//! \test zcc/decl.C99/Error_class_as_union.hpp
+					//! \test zcc/decl.C99/Error_class_as_union3.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("union ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as struct or class (C++98 One Definition Rule)");
+				INFORM(" declared as ");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				INC_INFORM(text_from_keyword(*tmp2));
+				INFORM(" (C++98 One Definition Rule)");
+				message_header(*tmp2);
+				INFORM("prior definition here");
 				zcc_errors.inc_error();
 				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
 				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
@@ -14256,12 +14267,21 @@
 				}
 			// One Definition Rule states that conflicting enum, struct, or class must error
 			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
-				{	//! \test zcc/decl.C99/Error_struct_as_union.hpp
+				{	//! \test zcc/decl.C99/Error_struct_as_union2.hpp
+					//! \test zcc/decl.C99/Error_struct_as_union4.hpp
+					//! \test zcc/decl.C99/Error_class_as_union2.hpp
+					//! \test zcc/decl.C99/Error_class_as_union4.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("union ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as struct or class (C++98 One Definition Rule)");
+				INFORM(" declared as ");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				INC_INFORM(text_from_keyword(*tmp2));
+				INFORM(" (C++98 One Definition Rule)");
+				message_header(*tmp2);
+				INFORM("prior definition here");
 				zcc_errors.inc_error();
 				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
 				src.c_array<0>()[i].DeleteIdx<2>(0);

Added: trunk/tests/zcc/decl.C99/Error_class_as_union.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_as_union.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_as_union.hpp	2010-11-10 04:48:36 UTC (rev 540)
@@ -0,0 +1,10 @@
+// decl.C99\Error_class_as_union.hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+class bad_test {
+	int x_factor;
+};
+
+union bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_class_as_union2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_as_union2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_as_union2.hpp	2010-11-10 04:48:36 UTC (rev 540)
@@ -0,0 +1,12 @@
+// decl.C99\Error_class_as_union2.hpp
+// using class as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+class bad_test {
+	int x_factor;
+};
+
+union bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_class_as_union3.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_as_union3.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_as_union3.hpp	2010-11-10 04:48:36 UTC (rev 540)
@@ -0,0 +1,8 @@
+// decl.C99\Error_class_as_union3.hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+class bad_test;
+
+union bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_class_as_union4.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_as_union4.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_as_union4.hpp	2010-11-10 04:48:36 UTC (rev 540)
@@ -0,0 +1,10 @@
+// decl.C99\Error_class_as_union4.hpp
+// using class as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+class bad_test;
+
+union bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_class_as_union5.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_as_union5.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_as_union5.hpp	2010-11-10 04:48:36 UTC (rev 540)
@@ -0,0 +1,13 @@
+// decl.C99\Error_class_as_union5.hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+namespace test {
+
+class bad_test {
+	int x_factor;
+};
+
+union bad_test;
+
+}

Added: trunk/tests/zcc/decl.C99/Error_class_as_union6.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_as_union6.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_as_union6.hpp	2010-11-10 04:48:36 UTC (rev 540)
@@ -0,0 +1,15 @@
+// decl.C99\Error_class_as_union6.hpp
+// using class as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+namespace test {
+
+class bad_test {
+	int x_factor;
+};
+
+union bad_test {
+	int x_factor;
+};
+
+}

Added: trunk/tests/zcc/decl.C99/Error_class_as_union7.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_as_union7.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_as_union7.hpp	2010-11-10 04:48:36 UTC (rev 540)
@@ -0,0 +1,11 @@
+// decl.C99\Error_class_as_union7.hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+namespace test {
+
+class bad_test;
+
+union bad_test;
+
+}

Added: trunk/tests/zcc/decl.C99/Error_class_as_union8.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_as_union8.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_as_union8.hpp	2010-11-10 04:48:36 UTC (rev 540)
@@ -0,0 +1,13 @@
+// decl.C99\Error_class_as_union8.hpp
+// using class as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+namespace test {
+
+class bad_test;
+
+union bad_test {
+	int x_factor;
+};
+
+}

Added: trunk/tests/zcc/decl.C99/Error_struct_as_union5.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_as_union5.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_as_union5.hpp	2010-11-10 04:48:36 UTC (rev 540)
@@ -0,0 +1,13 @@
+// decl.C99\Error_struct_as_union5.hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+namespace test {
+
+struct bad_test {
+	int x_factor;
+};
+
+union bad_test;
+
+}

Added: trunk/tests/zcc/decl.C99/Error_struct_as_union6.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_as_union6.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_as_union6.hpp	2010-11-10 04:48:36 UTC (rev 540)
@@ -0,0 +1,15 @@
+// decl.C99\Error_struct_as_union6.hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+namespace test {
+
+struct bad_test {
+	int x_factor;
+};
+
+union bad_test {
+	int x_factor;
+};
+
+}

Added: trunk/tests/zcc/decl.C99/Error_struct_as_union7.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_as_union7.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_as_union7.hpp	2010-11-10 04:48:36 UTC (rev 540)
@@ -0,0 +1,11 @@
+// decl.C99\Error_struct_as_union7.hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+namespace test {
+	
+struct bad_test;
+
+union bad_test;
+
+}

Added: trunk/tests/zcc/decl.C99/Error_struct_as_union8.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_as_union8.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_as_union8.hpp	2010-11-10 04:48:36 UTC (rev 540)
@@ -0,0 +1,13 @@
+// decl.C99\Error_struct_as_union8.hpp
+// using struct as union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+namespace test {
+
+struct bad_test;
+
+union bad_test {
+	int x_factor;
+};
+
+}

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2010-11-09 05:26:17 UTC (rev 539)
+++ trunk/type_system.cpp	2010-11-10 04:48:36 UTC (rev 540)
@@ -843,6 +843,9 @@
 	i -= core_types_size;
 	if (dynamic_types.size()<= --i) return NULL;
 	const dynamic_type_format& tmp = dynamic_types[i];
+	// struct_def also has a struct_decl member
+	if (DYNAMIC_C_STRUCTDEF==tmp.third.second)
+		return &tmp.third.first.third->_decl;
 	if (DYNAMIC_STRUCTDECL!=tmp.third.second) return NULL;
 	return tmp.third.first.second;
 }

Modified: trunk/type_system.cpp.in
===================================================================
--- trunk/type_system.cpp.in	2010-11-09 05:26:17 UTC (rev 539)
+++ trunk/type_system.cpp.in	2010-11-10 04:48:36 UTC (rev 540)
@@ -858,6 +858,9 @@
 	i -= core_types_size;
 	if (dynamic_types.size()<= --i) return NULL;
 	const dynamic_type_format& tmp = dynamic_types[i];
+	// struct_def also has a struct_decl member
+	if (DYNAMIC_C_STRUCTDEF==tmp.third.second)
+		return &tmp.third.first.third->_decl;
 	if (DYNAMIC_STRUCTDECL!=tmp.third.second) return NULL;
 	return tmp.third.first.second;
 }



From zaimoni at mail.berlios.de  Sat Nov 13 02:26:46 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 13 Nov 2010 02:26:46 +0100
Subject: [Zcplusplus-commits] r541 - trunk/tests/zcc.in/decl.C99
Message-ID: <20101113012646.86A5A480C72@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-13 02:26:46 +0100 (Sat, 13 Nov 2010)
New Revision: 541

Added:
   trunk/tests/zcc.in/decl.C99/Error_enum_as_struct.in
   trunk/tests/zcc.in/decl.C99/Error_enum_as_struct2.in
   trunk/tests/zcc.in/decl.C99/Error_union_as_struct.in
   trunk/tests/zcc.in/decl.C99/Error_union_as_struct2.in
   trunk/tests/zcc.in/decl.C99/Error_union_as_struct3.in
   trunk/tests/zcc.in/decl.C99/Error_union_as_struct4.in
Log:
test case infiles

Added: trunk/tests/zcc.in/decl.C99/Error_enum_as_struct.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_as_struct.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_as_struct.in	2010-11-13 01:26:46 UTC (rev 541)
@@ -0,0 +1,10 @@
+SUFFIXES h hpp
+// using enum as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+struct bad_test;
+

Added: trunk/tests/zcc.in/decl.C99/Error_enum_as_struct2.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_enum_as_struct2.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_enum_as_struct2.in	2010-11-13 01:26:46 UTC (rev 541)
@@ -0,0 +1,12 @@
+SUFFIXES h hpp
+// using enum as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+struct bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc.in/decl.C99/Error_union_as_struct.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_union_as_struct.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_union_as_struct.in	2010-11-13 01:26:46 UTC (rev 541)
@@ -0,0 +1,10 @@
+SUFFIXES h hpp
+// using union as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test {
+	int x_factor;
+};
+
+struct bad_test;
+

Added: trunk/tests/zcc.in/decl.C99/Error_union_as_struct2.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_union_as_struct2.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_union_as_struct2.in	2010-11-13 01:26:46 UTC (rev 541)
@@ -0,0 +1,12 @@
+SUFFIXES h hpp
+// using union as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test {
+	int x_factor;
+};
+
+struct bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc.in/decl.C99/Error_union_as_struct3.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_union_as_struct3.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_union_as_struct3.in	2010-11-13 01:26:46 UTC (rev 541)
@@ -0,0 +1,8 @@
+SUFFIXES h hpp
+// using union as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test;
+
+struct bad_test;
+

Added: trunk/tests/zcc.in/decl.C99/Error_union_as_struct4.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_union_as_struct4.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_union_as_struct4.in	2010-11-13 01:26:46 UTC (rev 541)
@@ -0,0 +1,10 @@
+SUFFIXES h hpp
+// using union as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test;
+
+struct bad_test {
+	int x_factor;
+};
+



From zaimoni at mail.berlios.de  Sat Nov 13 05:44:01 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 13 Nov 2010 05:44:01 +0100
Subject: [Zcplusplus-commits] r542 - in trunk: . tests/zcc/decl.C99
Message-ID: <20101113044402.5FD01480EF3@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-13 05:44:01 +0100 (Sat, 13 Nov 2010)
New Revision: 542

Added:
   trunk/tests/zcc/decl.C99/Error_enum_as_struct.h
   trunk/tests/zcc/decl.C99/Error_enum_as_struct.hpp
   trunk/tests/zcc/decl.C99/Error_enum_as_struct2.h
   trunk/tests/zcc/decl.C99/Error_enum_as_struct2.hpp
   trunk/tests/zcc/decl.C99/Error_union_as_struct.h
   trunk/tests/zcc/decl.C99/Error_union_as_struct.hpp
   trunk/tests/zcc/decl.C99/Error_union_as_struct2.h
   trunk/tests/zcc/decl.C99/Error_union_as_struct2.hpp
   trunk/tests/zcc/decl.C99/Error_union_as_struct3.h
   trunk/tests/zcc/decl.C99/Error_union_as_struct3.hpp
   trunk/tests/zcc/decl.C99/Error_union_as_struct4.h
   trunk/tests/zcc/decl.C99/Error_union_as_struct4.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
error on use of enumeration or union as struct

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-13 01:26:46 UTC (rev 541)
+++ trunk/CSupport.cpp	2010-11-13 04:44:01 UTC (rev 542)
@@ -13065,6 +13065,14 @@
 				i += 2;
 				continue;
 				}
+			else if (!tmp)
+				{	// used without at least forward-declaring
+					//! \bug needs test cases
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("used without at least forward-declaring");
+				zcc_errors.inc_error();
+				}
 			}
 			break;
 			case STRUCT_NAME:
@@ -13077,7 +13085,40 @@
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 				}
-			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_union_as_struct.h
+					//! \test zcc/decl.C99/Error_union_as_struct3.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C99 6.7.2.3p2)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_enum_as_struct.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_struct_forward_def.h
 			else _forward_declare_C_struct(src,i,invariant_decl_scanner);
@@ -13247,7 +13288,42 @@
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 				}
-			//! \bug C1X 6.7.2.3p2 states that conflicting enum or union must error
+			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_union_as_struct2.h
+					//! \test zcc/decl.C99/Error_union_as_struct4.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C99 6.7.2.3p2)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_enum_as_struct2.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_struct_forward_def.h
 			else _forward_declare_C_struct(src,i,invariant_decl_scanner);
@@ -13985,7 +14061,40 @@
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
+			// One Definition Rule states that conflicting enum, struct, or class must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_union_as_struct.hpp
+					//! \test zcc/decl.C99/Error_union_as_struct3.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C++98 One Definition Rule)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_enum_as_struct.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C++98 One Definition Rule)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
@@ -14046,7 +14155,41 @@
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
+			// One Definition Rule states that conflicting enum, struct, or class must error
+			//! \bug need cited test cases
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_union_as_class.hpp
+					//! \test zcc/decl.C99/Error_union_as_class3.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("class ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C++98 One Definition Rule)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_enum_as_class.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("class ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C++98 One Definition Rule)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
@@ -14218,19 +14361,52 @@
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
+			// One Definition Rule states that conflicting enum, struct, or class must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_union_as_struct2.hpp
+					//! \test zcc/decl.C99/Error_union_as_struct4.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C++98 One Definition Rule)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_enum_as_struct2.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C++98 One Definition Rule)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
-			assert(1 && 0<parse_tree::types->use_count(vr_tmp));
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
 			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(2 && 0<parse_tree::types->use_count(vr_tmp));
 			assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==vr_tmp);
 			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
@@ -14278,7 +14454,43 @@
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
+			// One Definition Rule states that conflicting enum, struct, or class must error
+			//! \bug need cited test cases
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_union_as_class2.hpp
+					//! \test zcc/decl.C99/Error_union_as_class4.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("class ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C++98 One Definition Rule)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_enum_as_class2.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("class ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C++98 One Definition Rule)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_class_forward_def.hpp
 			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-13 01:26:46 UTC (rev 541)
+++ trunk/CSupport.cpp.in	2010-11-13 04:44:01 UTC (rev 542)
@@ -13209,6 +13209,14 @@
 				i += 2;
 				continue;
 				}
+			else if (!tmp)
+				{	// used without at least forward-declaring
+					//! \bug needs test cases
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("used without at least forward-declaring");
+				zcc_errors.inc_error();
+				}
 			}
 			break;
 			case STRUCT_NAME:
@@ -13221,7 +13229,40 @@
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 				}
-			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_union_as_struct.h
+					//! \test zcc/decl.C99/Error_union_as_struct3.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C99 6.7.2.3p2)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_enum_as_struct.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_struct_forward_def.h
 			else _forward_declare_C_struct(src,i,invariant_decl_scanner);
@@ -13391,7 +13432,42 @@
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
 				}
-			//! \bug C1X 6.7.2.3p2 states that conflicting enum or union must error
+			// C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_union_as_struct2.h
+					//! \test zcc/decl.C99/Error_union_as_struct4.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C99 6.7.2.3p2)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_enum_as_struct2.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C99 6.7.2.3p2)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_struct_forward_def.h
 			else _forward_declare_C_struct(src,i,invariant_decl_scanner);
@@ -14129,7 +14205,40 @@
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
+			// One Definition Rule states that conflicting enum, struct, or class must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_union_as_struct.hpp
+					//! \test zcc/decl.C99/Error_union_as_struct3.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C++98 One Definition Rule)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_enum_as_struct.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C++98 One Definition Rule)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
@@ -14190,7 +14299,41 @@
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
+			// One Definition Rule states that conflicting enum, struct, or class must error
+			//! \bug need cited test cases
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_union_as_class.hpp
+					//! \test zcc/decl.C99/Error_union_as_class3.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("class ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C++98 One Definition Rule)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_enum_as_class.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("class ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C++98 One Definition Rule)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
@@ -14315,7 +14458,7 @@
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
 			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==vr_tmp);
 			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -14362,20 +14505,53 @@
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
+			// One Definition Rule states that conflicting enum, struct, or class must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_union_as_struct2.hpp
+					//! \test zcc/decl.C99/Error_union_as_struct4.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C++98 One Definition Rule)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_enum_as_struct2.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C++98 One Definition Rule)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
 			// parse the union and upgrade it to a full definition
 			const type_system::type_index vr_tmp = src.data<0>()[i].type_code.base_type_index;
-			assert(1 && 0<parse_tree::types->use_count(vr_tmp));
 			const union_struct_decl* tmp3 = parse_tree::types->get_structdecl(vr_tmp);
 			assert(tmp3);
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
 			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(2 && 0<parse_tree::types->use_count(vr_tmp));
-			assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==vr_tmp);
 			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -14422,7 +14598,43 @@
 				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
-			//! \bug One Definition Rule states that conflicting enum, struct, or class must error
+			// One Definition Rule states that conflicting enum, struct, or class must error
+			//! \bug need cited test cases
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_union_as_class2.hpp
+					//! \test zcc/decl.C99/Error_union_as_class4.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("class ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C++98 One Definition Rule)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_enum_as_class2.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("class ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as enumeration (C++98 One Definition Rule)");
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("enum");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
+				}
 			// tentatively forward-declare immediately
 			//! \test zcc/decl.C99/Pass_class_forward_def.hpp
 			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
@@ -14433,7 +14645,7 @@
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
 			parse_tree::types->upgrade_decl_to_def(vr_tmp,tmp4);
-			assert(parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==vr_tmp);
 			assert(parse_tree::types->get_C_structdef(vr_tmp));
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))

Added: trunk/tests/zcc/decl.C99/Error_enum_as_struct.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_as_struct.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_enum_as_struct.h	2010-11-13 04:44:01 UTC (rev 542)
@@ -0,0 +1,10 @@
+// decl.C99\Error_enum_as_struct.h
+// using enum as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+struct bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_enum_as_struct.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_as_struct.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_enum_as_struct.hpp	2010-11-13 04:44:01 UTC (rev 542)
@@ -0,0 +1,10 @@
+// decl.C99\Error_enum_as_struct.hpp
+// using enum as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+struct bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_enum_as_struct2.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_as_struct2.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_enum_as_struct2.h	2010-11-13 04:44:01 UTC (rev 542)
@@ -0,0 +1,12 @@
+// decl.C99\Error_enum_as_struct2.h
+// using enum as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+struct bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_enum_as_struct2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_as_struct2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_enum_as_struct2.hpp	2010-11-13 04:44:01 UTC (rev 542)
@@ -0,0 +1,12 @@
+// decl.C99\Error_enum_as_struct2.hpp
+// using enum as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+struct bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_union_as_struct.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_as_struct.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_as_struct.h	2010-11-13 04:44:01 UTC (rev 542)
@@ -0,0 +1,10 @@
+// decl.C99\Error_union_as_struct.h
+// using union as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test {
+	int x_factor;
+};
+
+struct bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_union_as_struct.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_as_struct.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_as_struct.hpp	2010-11-13 04:44:01 UTC (rev 542)
@@ -0,0 +1,10 @@
+// decl.C99\Error_union_as_struct.hpp
+// using union as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test {
+	int x_factor;
+};
+
+struct bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_union_as_struct2.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_as_struct2.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_as_struct2.h	2010-11-13 04:44:01 UTC (rev 542)
@@ -0,0 +1,12 @@
+// decl.C99\Error_union_as_struct2.h
+// using union as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test {
+	int x_factor;
+};
+
+struct bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_union_as_struct2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_as_struct2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_as_struct2.hpp	2010-11-13 04:44:01 UTC (rev 542)
@@ -0,0 +1,12 @@
+// decl.C99\Error_union_as_struct2.hpp
+// using union as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test {
+	int x_factor;
+};
+
+struct bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_union_as_struct3.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_as_struct3.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_as_struct3.h	2010-11-13 04:44:01 UTC (rev 542)
@@ -0,0 +1,8 @@
+// decl.C99\Error_union_as_struct3.h
+// using union as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test;
+
+struct bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_union_as_struct3.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_as_struct3.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_as_struct3.hpp	2010-11-13 04:44:01 UTC (rev 542)
@@ -0,0 +1,8 @@
+// decl.C99\Error_union_as_struct3.hpp
+// using union as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test;
+
+struct bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_union_as_struct4.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_as_struct4.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_as_struct4.h	2010-11-13 04:44:01 UTC (rev 542)
@@ -0,0 +1,10 @@
+// decl.C99\Error_union_as_struct4.h
+// using union as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test;
+
+struct bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_union_as_struct4.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_as_struct4.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_as_struct4.hpp	2010-11-13 04:44:01 UTC (rev 542)
@@ -0,0 +1,10 @@
+// decl.C99\Error_union_as_struct4.hpp
+// using union as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test;
+
+struct bad_test {
+	int x_factor;
+};
+



From zaimoni at mail.berlios.de  Sun Nov 14 06:53:35 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 14 Nov 2010 06:53:35 +0100
Subject: [Zcplusplus-commits] r543 - in trunk: . tests/zcc/decl.C99
Message-ID: <20101114055336.45C85481184@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-14 06:53:35 +0100 (Sun, 14 Nov 2010)
New Revision: 543

Added:
   trunk/tests/zcc/decl.C99/Error_enum_as_class.hpp
   trunk/tests/zcc/decl.C99/Error_enum_as_class2.hpp
   trunk/tests/zcc/decl.C99/Error_union_as_class.hpp
   trunk/tests/zcc/decl.C99/Error_union_as_class2.hpp
   trunk/tests/zcc/decl.C99/Error_union_as_class3.hpp
   trunk/tests/zcc/decl.C99/Error_union_as_class4.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
test cases for error when using enum or union as class

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-13 04:44:01 UTC (rev 542)
+++ trunk/CSupport.cpp	2010-11-14 05:53:35 UTC (rev 543)
@@ -14096,7 +14096,7 @@
 				goto reparse;
 				}
 			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+			//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -14156,7 +14156,6 @@
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
 			// One Definition Rule states that conflicting enum, struct, or class must error
-			//! \bug need cited test cases
 			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
 				{	//! \test zcc/decl.C99/Error_union_as_class.hpp
 					//! \test zcc/decl.C99/Error_union_as_class3.hpp
@@ -14191,7 +14190,7 @@
 				goto reparse;
 				}
 			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+			//! \test zcc/decl.C99/Pass_class_forward_def.hpp
 			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -14455,8 +14454,7 @@
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
 			// One Definition Rule states that conflicting enum, struct, or class must error
-			//! \bug need cited test cases
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
 				{	//! \test zcc/decl.C99/Error_union_as_class2.hpp
 					//! \test zcc/decl.C99/Error_union_as_class4.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-13 04:44:01 UTC (rev 542)
+++ trunk/CSupport.cpp.in	2010-11-14 05:53:35 UTC (rev 543)
@@ -14240,7 +14240,7 @@
 				goto reparse;
 				}
 			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+			//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 			else _forward_declare_CPP_struct(src,active_namespace,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -14300,7 +14300,6 @@
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
 			// One Definition Rule states that conflicting enum, struct, or class must error
-			//! \bug need cited test cases
 			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
 				{	//! \test zcc/decl.C99/Error_union_as_class.hpp
 					//! \test zcc/decl.C99/Error_union_as_class3.hpp
@@ -14335,7 +14334,7 @@
 				goto reparse;
 				}
 			// tentatively forward-declare immediately
-			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+			//! \test zcc/decl.C99/Pass_class_forward_def.hpp
 			else _forward_declare_CPP_class(src,active_namespace,i,invariant_decl_scanner);
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
@@ -14599,8 +14598,7 @@
 				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
 				}
 			// One Definition Rule states that conflicting enum, struct, or class must error
-			//! \bug need cited test cases
-			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
 				{	//! \test zcc/decl.C99/Error_union_as_class2.hpp
 					//! \test zcc/decl.C99/Error_union_as_class4.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);

Added: trunk/tests/zcc/decl.C99/Error_enum_as_class.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_as_class.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_enum_as_class.hpp	2010-11-14 05:53:35 UTC (rev 543)
@@ -0,0 +1,10 @@
+// decl.C99\Error_enum_as_class.hpp
+// using enum as class
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+class bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_enum_as_class2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_as_class2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_enum_as_class2.hpp	2010-11-14 05:53:35 UTC (rev 543)
@@ -0,0 +1,12 @@
+// decl.C99\Error_enum_as_class2.hpp
+// using enum as class
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+enum bad_test {
+	x_factor = 1
+};
+
+class bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_union_as_class.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_as_class.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_as_class.hpp	2010-11-14 05:53:35 UTC (rev 543)
@@ -0,0 +1,10 @@
+// decl.C99\Error_union_as_class.hpp
+// using union as class
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test {
+	int x_factor;
+};
+
+class bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_union_as_class2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_as_class2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_as_class2.hpp	2010-11-14 05:53:35 UTC (rev 543)
@@ -0,0 +1,12 @@
+// decl.C99\Error_union_as_class2.hpp
+// using union as class
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test {
+	int x_factor;
+};
+
+class bad_test {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_union_as_class3.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_as_class3.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_as_class3.hpp	2010-11-14 05:53:35 UTC (rev 543)
@@ -0,0 +1,8 @@
+// decl.C99\Error_union_as_class3.hpp
+// using union as struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test;
+
+class bad_test;
+

Added: trunk/tests/zcc/decl.C99/Error_union_as_class4.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_as_class4.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_as_class4.hpp	2010-11-14 05:53:35 UTC (rev 543)
@@ -0,0 +1,10 @@
+// decl.C99\Error_union_as_class4.hpp
+// using union as class
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union bad_test;
+
+class bad_test {
+	int x_factor;
+};
+



From zaimoni at mail.berlios.de  Fri Nov 19 22:07:44 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 19 Nov 2010 22:07:44 +0100
Subject: [Zcplusplus-commits] r544 - trunk
Message-ID: <20101119210744.78991480B79@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-19 22:07:44 +0100 (Fri, 19 Nov 2010)
New Revision: 544

Modified:
   trunk/z_cpp.cpp
   trunk/zcc.cpp
Log:
option -flimit-errors for CLang compatibility

Modified: trunk/z_cpp.cpp
===================================================================
--- trunk/z_cpp.cpp	2010-11-14 05:53:35 UTC (rev 543)
+++ trunk/z_cpp.cpp	2010-11-19 21:07:44 UTC (rev 544)
@@ -41,7 +41,8 @@
 		};
 
 static const POD_triple<const char*, size_t, const char*> option_map_int[]
-=	{	{ "-fmax-errors",		intopt::error_ub, 					"how many errors are too many (default 100)\n"},	// GFortran compatibility
+=	{	{ "-fmax-errors",		intopt::error_ub, 	"how many errors are too many (default 100)\n"},	// GFortran compatibility
+		{ "-ferror-limit",		intopt::error_ub, 	"how many errors are too many (default 100)\n"},	// CLang compatibility
 		{"--target-char-bit",	intopt::target_char_bit,	"target CHAR_BIT\n"},
 		{"--target-sizeof-short",	intopt::target_short_size,	"target sizeof(short), sizeof(unsigned short)\n"},
 		{"--target-sizeof-int",	intopt::target_int_size,	"target sizeof(int), sizeof(unsigned int)\n"},

Modified: trunk/zcc.cpp
===================================================================
--- trunk/zcc.cpp	2010-11-14 05:53:35 UTC (rev 543)
+++ trunk/zcc.cpp	2010-11-19 21:07:44 UTC (rev 544)
@@ -47,6 +47,7 @@
 
 static const POD_triple<const char*, size_t, const char*> option_map_int[]
 =	{	{ "-fmax-errors",		intopt::error_ub, 					"how many errors are too many (default 100)\n"},	// GFortran compatibility
+		{ "-ferror-limit",		intopt::error_ub, 					"how many errors are too many (default 100)\n"},	// CLang compatibility
 		{"--target-char-bit",	intopt::target_char_bit,	"target CHAR_BIT\n"},
 		{"--target-sizeof-short",	intopt::target_short_size,	"target sizeof(short), sizeof(unsigned short)\n"},
 		{"--target-sizeof-int",	intopt::target_int_size,	"target sizeof(int), sizeof(unsigned int)\n"},



From zaimoni at mail.berlios.de  Thu Nov 25 11:02:10 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 25 Nov 2010 11:02:10 +0100
Subject: [Zcplusplus-commits] r545 - trunk
Message-ID: <20101125100211.6DBF7480EF1@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-25 11:02:10 +0100 (Thu, 25 Nov 2010)
New Revision: 545

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
remove empirically true guard clause

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-19 21:07:44 UTC (rev 544)
+++ trunk/CSupport.cpp	2010-11-25 10:02:10 UTC (rev 545)
@@ -13451,20 +13451,17 @@
 			break;
 			case ENUM_NAME:
 			{	// C99 6.7.2.3: allowed only after name is defined
-			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
-				{
-				type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
-				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
-				if (!tmp)
-					{	//! \test zcc/decl.C99/Error_enum_undef.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'enum ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
-					zcc_errors.inc_error();
-					src.c_array<0>()[i].flags |= parse_tree::INVALID;
-					}
+			type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+			src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
+			if (!tmp)
+				{	//! \test zcc/decl.C99/Error_enum_undef.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("'enum ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+				INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].flags |= parse_tree::INVALID;
 				}
 			}
 			break;
@@ -14661,21 +14658,18 @@
 			break;
 			case ENUM_NAME:
 			{
-			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
-				{
-				type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-				src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
-				if (!tmp)
-					{	// this belongs elsewhere
-						//! \test zcc/decl.C99/Error_enum_undef.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'enum ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
-					zcc_errors.inc_error();
-					src.c_array<0>()[i].flags |= parse_tree::INVALID;
-					}
+			type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
+			if (!tmp)
+				{	// this belongs elsewhere
+					//! \test zcc/decl.C99/Error_enum_undef.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("'enum ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+				INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].flags |= parse_tree::INVALID;
 				}
 			//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
 			}

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-19 21:07:44 UTC (rev 544)
+++ trunk/CSupport.cpp.in	2010-11-25 10:02:10 UTC (rev 545)
@@ -13595,20 +13595,17 @@
 			break;
 			case ENUM_NAME:
 			{	// C99 6.7.2.3: allowed only after name is defined
-			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
-				{
-				type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
-				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
-				if (!tmp)
-					{	//! \test zcc/decl.C99/Error_enum_undef.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'enum ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
-					zcc_errors.inc_error();
-					src.c_array<0>()[i].flags |= parse_tree::INVALID;
-					}
+			type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+			src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
+			if (!tmp)
+				{	//! \test zcc/decl.C99/Error_enum_undef.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("'enum ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+				INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].flags |= parse_tree::INVALID;
 				}
 			}
 			break;
@@ -14805,21 +14802,18 @@
 			break;
 			case ENUM_NAME:
 			{
-			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
-				{
-				type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-				src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
-				if (!tmp)
-					{	// this belongs elsewhere
-						//! \test zcc/decl.C99/Error_enum_undef.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INC_INFORM("'enum ");
-					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
-					INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
-					zcc_errors.inc_error();
-					src.c_array<0>()[i].flags |= parse_tree::INVALID;
-					}
+			type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
+			if (!tmp)
+				{	// this belongs elsewhere
+					//! \test zcc/decl.C99/Error_enum_undef.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("'enum ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+				INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].flags |= parse_tree::INVALID;
 				}
 			//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
 			}



From zaimoni at mail.berlios.de  Thu Nov 25 23:10:24 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 25 Nov 2010 23:10:24 +0100
Subject: [Zcplusplus-commits] r546 - trunk
Message-ID: <20101125221025.1EA68480F85@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-25 23:10:24 +0100 (Thu, 25 Nov 2010)
New Revision: 546

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
make C and C++ internal implementation behave alike, in spite of standard differences (optimizers want to know)

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-25 10:02:10 UTC (rev 545)
+++ trunk/CSupport.cpp	2010-11-25 22:10:24 UTC (rev 546)
@@ -13451,8 +13451,8 @@
 			break;
 			case ENUM_NAME:
 			{	// C99 6.7.2.3: allowed only after name is defined
+			// XXX C: enums are int, but the optimizers will want to know
 			type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
-			src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 			if (!tmp)
 				{	//! \test zcc/decl.C99/Error_enum_undef.h
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -13461,8 +13461,10 @@
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 				INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
 				zcc_errors.inc_error();
+				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 				src.c_array<0>()[i].flags |= parse_tree::INVALID;
 				}
+			else src.c_array<0>()[i].type_code.set_type(tmp);
 			}
 			break;
 			case ENUM_NAMED_DEF:
@@ -14659,7 +14661,6 @@
 			case ENUM_NAME:
 			{
 			type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
 			if (!tmp)
 				{	// this belongs elsewhere
 					//! \test zcc/decl.C99/Error_enum_undef.hpp
@@ -14669,8 +14670,10 @@
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 				INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
 				zcc_errors.inc_error();
+				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// fail over to int, like C
 				src.c_array<0>()[i].flags |= parse_tree::INVALID;
 				}
+			else src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
 			//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
 			}
 			break;

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-25 10:02:10 UTC (rev 545)
+++ trunk/CSupport.cpp.in	2010-11-25 22:10:24 UTC (rev 546)
@@ -13595,8 +13595,8 @@
 			break;
 			case ENUM_NAME:
 			{	// C99 6.7.2.3: allowed only after name is defined
+			// XXX C: enums are int, but the optimizers will want to know
 			type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
-			src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 			if (!tmp)
 				{	//! \test zcc/decl.C99/Error_enum_undef.h
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -13605,8 +13605,10 @@
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 				INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
 				zcc_errors.inc_error();
+				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 				src.c_array<0>()[i].flags |= parse_tree::INVALID;
 				}
+			else src.c_array<0>()[i].type_code.set_type(tmp);
 			}
 			break;
 			case ENUM_NAMED_DEF:
@@ -14803,7 +14805,6 @@
 			case ENUM_NAME:
 			{
 			type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
 			if (!tmp)
 				{	// this belongs elsewhere
 					//! \test zcc/decl.C99/Error_enum_undef.hpp
@@ -14813,8 +14814,10 @@
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 				INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
 				zcc_errors.inc_error();
+				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// fail over to int, like C
 				src.c_array<0>()[i].flags |= parse_tree::INVALID;
 				}
+			else src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
 			//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
 			}
 			break;



From zaimoni at mail.berlios.de  Sun Nov 28 03:55:03 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 28 Nov 2010 03:55:03 +0100
Subject: [Zcplusplus-commits] r547 - trunk
Message-ID: <20101128025503.98D4A480EFB@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-28 03:55:02 +0100 (Sun, 28 Nov 2010)
New Revision: 547

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
make abusing union/struct/class as enum error

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-25 22:10:24 UTC (rev 546)
+++ trunk/CSupport.cpp	2010-11-28 02:55:02 UTC (rev 547)
@@ -13452,9 +13452,9 @@
 			case ENUM_NAME:
 			{	// C99 6.7.2.3: allowed only after name is defined
 			// XXX C: enums are int, but the optimizers will want to know
-			type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
-			if (!tmp)
-				{	//! \test zcc/decl.C99/Error_enum_undef.h
+			if (type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
+				 src.c_array<0>()[i].type_code.set_type(tmp);
+			else{	//! \test zcc/decl.C99/Error_enum_undef.h
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("'enum ");
@@ -13463,21 +13463,19 @@
 				zcc_errors.inc_error();
 				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 				src.c_array<0>()[i].flags |= parse_tree::INVALID;
-				}
-			else src.c_array<0>()[i].type_code.set_type(tmp);
+				};
 			}
 			break;
 			case ENUM_NAMED_DEF:
 			{	// can only define once
-			const type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
-			if (tmp)
+			if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
 				{	//! \test zcc/decl.C99/Error_enum_multidef.h
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("'enum ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 				INFORM("' already defined (C99 6.7.2.3p1)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(tmp);
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
 				assert(tmp2);
 				message_header(*tmp2);
 				INFORM("prior definition here");
@@ -13485,7 +13483,45 @@
 				// now it's gone
 				src.DeleteNSlotsAt<0>(1,i);
 				continue;
-				};
+				}
+			// C1X 6.7.2.3p2 states that conflicting union or struct must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_union_as_enum.h
+					//! \test zcc/decl.C99/Error_union_as_enum2.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C99 6.7.2.3p2)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_struct_as_enum.h
+					//! \test zcc/decl.C99/Error_struct_as_enum2.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as struct (C99 6.7.2.3p2)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
+				goto reparse;
+				}
+				
 			// enum-specifier doesn't have a specific declaration mode
 			//! \test zcc/decl.C99/Pass_enum_def.h
 			const type_system::type_index tmp2 = parse_tree::types->register_enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
@@ -13502,7 +13538,7 @@
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 			const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
+			src.c_array<0>()[i].type_code.set_type(tmp);	// C: enums are int (although we'd like to extend this a bit)
 			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
@@ -13973,7 +14009,7 @@
 				INC_INFORM(ERR_STR);
 				INC_INFORM("union ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as ");
+				INC_INFORM(" declared as ");
 				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
 				assert(tmp2);
 				INC_INFORM(text_from_keyword(*tmp2));
@@ -14272,7 +14308,7 @@
 				INC_INFORM(ERR_STR);
 				INC_INFORM("union ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as ");
+				INC_INFORM(" declared as ");
 				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
 				assert(tmp2);
 				INC_INFORM(text_from_keyword(*tmp2));
@@ -14660,9 +14696,9 @@
 			break;
 			case ENUM_NAME:
 			{
-			type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			if (!tmp)
-				{	// this belongs elsewhere
+			if (const type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				 src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
+			else{	// this belongs elsewhere
 					//! \test zcc/decl.C99/Error_enum_undef.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
@@ -14673,24 +14709,19 @@
 				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// fail over to int, like C
 				src.c_array<0>()[i].flags |= parse_tree::INVALID;
 				}
-			else src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
 			//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
 			}
 			break;
 			case ENUM_NAMED_DEF:
 			{	// can only define once
-			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-			const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-			type_system::type_index tmp = parse_tree::types->get_id_enum(fullname);
-			if (tmp)
+			if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
 				{	//! \test zcc/decl.C99/Error_enum_multidef.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("'enum ");
-				INC_INFORM(fullname);
-				free(namespace_name);
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
 				INFORM("' already defined (C++98 3.2p1)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(tmp);
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
 				assert(tmp2);
 				message_header(*tmp2);
 				INFORM("prior definition here");
@@ -14698,8 +14729,48 @@
 				// now it's gone
 				src.DeleteNSlotsAt<0>(1,i);
 				continue;
-				};
-			free(namespace_name);
+				}
+			// One Definition Rule states that conflicting enum, struct, or class must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_union_as_enum.hpp
+					//! \test zcc/decl.C99/Error_union_as_enum2.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C++98 One Definition Rule)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_struct_as_enum.hpp
+					//! \test zcc/decl.C99/Error_struct_as_enum2.hpp
+					//! \test zcc/decl.C99/Error_class_as_enum.hpp
+					//! \test zcc/decl.C99/Error_class_as_enum2.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INC_INFORM(" declared as ");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				INC_INFORM(text_from_keyword(*tmp2));
+				INFORM(" (C++98 One Definition Rule)");
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
+				goto reparse;
+				}
 			//! \test zcc/decl.C99/Pass_enum_def.hpp
 			// enum-specifier doesn't have a specific declaration mode
 			const type_system::type_index tmp2 = parse_tree::types->register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-25 22:10:24 UTC (rev 546)
+++ trunk/CSupport.cpp.in	2010-11-28 02:55:02 UTC (rev 547)
@@ -13596,9 +13596,9 @@
 			case ENUM_NAME:
 			{	// C99 6.7.2.3: allowed only after name is defined
 			// XXX C: enums are int, but the optimizers will want to know
-			type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
-			if (!tmp)
-				{	//! \test zcc/decl.C99/Error_enum_undef.h
+			if (type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
+				 src.c_array<0>()[i].type_code.set_type(tmp);
+			else{	//! \test zcc/decl.C99/Error_enum_undef.h
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("'enum ");
@@ -13607,21 +13607,19 @@
 				zcc_errors.inc_error();
 				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
 				src.c_array<0>()[i].flags |= parse_tree::INVALID;
-				}
-			else src.c_array<0>()[i].type_code.set_type(tmp);
+				};
 			}
 			break;
 			case ENUM_NAMED_DEF:
 			{	// can only define once
-			const type_system::type_index tmp = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
-			if (tmp)
+			if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum(src.data<0>()[i].index_tokens[1].token.first))
 				{	//! \test zcc/decl.C99/Error_enum_multidef.h
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("'enum ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
 				INFORM("' already defined (C99 6.7.2.3p1)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(tmp);
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
 				assert(tmp2);
 				message_header(*tmp2);
 				INFORM("prior definition here");
@@ -13629,7 +13627,45 @@
 				// now it's gone
 				src.DeleteNSlotsAt<0>(1,i);
 				continue;
-				};
+				}
+			// C1X 6.7.2.3p2 states that conflicting union or struct must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_union_as_enum.h
+					//! \test zcc/decl.C99/Error_union_as_enum2.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C99 6.7.2.3p2)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first))
+				{	//! \test zcc/decl.C99/Error_struct_as_enum.h
+					//! \test zcc/decl.C99/Error_struct_as_enum2.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as struct (C99 6.7.2.3p2)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
+				goto reparse;
+				}
+				
 			// enum-specifier doesn't have a specific declaration mode
 			//! \test zcc/decl.C99/Pass_enum_def.h
 			const type_system::type_index tmp2 = parse_tree::types->register_enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
@@ -13646,7 +13682,7 @@
 			{	// enum-specifier doesn't have a specific declaration mode
 				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
 			const type_system::type_index tmp = parse_tree::types->register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
-			src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
+			src.c_array<0>()[i].type_code.set_type(tmp);	// C: enums are int (although we'd like to extend this a bit)
 			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
 				{
 				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
@@ -14117,7 +14153,7 @@
 				INC_INFORM(ERR_STR);
 				INC_INFORM("union ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as ");
+				INC_INFORM(" declared as ");
 				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
 				assert(tmp2);
 				INC_INFORM(text_from_keyword(*tmp2));
@@ -14416,7 +14452,7 @@
 				INC_INFORM(ERR_STR);
 				INC_INFORM("union ");
 				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
-				INFORM(" declared as ");
+				INC_INFORM(" declared as ");
 				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
 				assert(tmp2);
 				INC_INFORM(text_from_keyword(*tmp2));
@@ -14804,9 +14840,9 @@
 			break;
 			case ENUM_NAME:
 			{
-			type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
-			if (!tmp)
-				{	// this belongs elsewhere
+			if (const type_system::type_index tmp = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				 src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
+			else{	// this belongs elsewhere
 					//! \test zcc/decl.C99/Error_enum_undef.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
@@ -14817,24 +14853,19 @@
 				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// fail over to int, like C
 				src.c_array<0>()[i].flags |= parse_tree::INVALID;
 				}
-			else src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
 			//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
 			}
 			break;
 			case ENUM_NAMED_DEF:
 			{	// can only define once
-			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
-			const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
-			type_system::type_index tmp = parse_tree::types->get_id_enum(fullname);
-			if (tmp)
+			if (const type_system::type_index fatal_def = parse_tree::types->get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
 				{	//! \test zcc/decl.C99/Error_enum_multidef.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INC_INFORM("'enum ");
-				INC_INFORM(fullname);
-				free(namespace_name);
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
 				INFORM("' already defined (C++98 3.2p1)");
-				const enum_def* const tmp2 = parse_tree::types->get_enum_def(tmp);
+				const enum_def* const tmp2 = parse_tree::types->get_enum_def(fatal_def);
 				assert(tmp2);
 				message_header(*tmp2);
 				INFORM("prior definition here");
@@ -14842,8 +14873,48 @@
 				// now it's gone
 				src.DeleteNSlotsAt<0>(1,i);
 				continue;
-				};
-			free(namespace_name);
+				}
+			// One Definition Rule states that conflicting enum, struct, or class must error
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_union_as_enum.hpp
+					//! \test zcc/decl.C99/Error_union_as_enum2.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("struct ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INFORM(" declared as union (C++98 One Definition Rule)");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("union");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+				goto reparse;
+				}
+			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))
+				{	//! \test zcc/decl.C99/Error_struct_as_enum.hpp
+					//! \test zcc/decl.C99/Error_struct_as_enum2.hpp
+					//! \test zcc/decl.C99/Error_class_as_enum.hpp
+					//! \test zcc/decl.C99/Error_class_as_enum2.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("union ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first);
+				INC_INFORM(" declared as ");
+				const union_struct_decl* const tmp2 = parse_tree::types->get_structdecl(fatal_def);
+				assert(tmp2);
+				INC_INFORM(text_from_keyword(*tmp2));
+				INFORM(" (C++98 One Definition Rule)");
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				src.c_array<0>()[i].set_index_token_from_str_literal<0>("struct");
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
+				goto reparse;
+				}
 			//! \test zcc/decl.C99/Pass_enum_def.hpp
 			// enum-specifier doesn't have a specific declaration mode
 			const type_system::type_index tmp2 = parse_tree::types->register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);



From zaimoni at mail.berlios.de  Sun Nov 28 04:36:45 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 28 Nov 2010 04:36:45 +0100
Subject: [Zcplusplus-commits] r548 - trunk
Message-ID: <20101128033646.48CD9480EFB@sheep.berlios.de>

Author: zaimoni
Date: 2010-11-28 04:36:45 +0100 (Sun, 28 Nov 2010)
New Revision: 548

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
no need to invalidate parse structure when handling a redefined enum

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-11-28 02:55:02 UTC (rev 547)
+++ trunk/CSupport.cpp	2010-11-28 03:36:45 UTC (rev 548)
@@ -13480,9 +13480,9 @@
 				message_header(*tmp2);
 				INFORM("prior definition here");
 				zcc_errors.inc_error();
-				// now it's gone
-				src.DeleteNSlotsAt<0>(1,i);
-				continue;
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
 				}
 			// C1X 6.7.2.3p2 states that conflicting union or struct must error
 			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first))
@@ -14726,9 +14726,9 @@
 				message_header(*tmp2);
 				INFORM("prior definition here");
 				zcc_errors.inc_error();
-				// now it's gone
-				src.DeleteNSlotsAt<0>(1,i);
-				continue;
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
 				}
 			// One Definition Rule states that conflicting enum, struct, or class must error
 			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-11-28 02:55:02 UTC (rev 547)
+++ trunk/CSupport.cpp.in	2010-11-28 03:36:45 UTC (rev 548)
@@ -13624,9 +13624,9 @@
 				message_header(*tmp2);
 				INFORM("prior definition here");
 				zcc_errors.inc_error();
-				// now it's gone
-				src.DeleteNSlotsAt<0>(1,i);
-				continue;
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
 				}
 			// C1X 6.7.2.3p2 states that conflicting union or struct must error
 			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union(src.data<0>()[i].index_tokens[1].token.first))
@@ -14870,9 +14870,9 @@
 				message_header(*tmp2);
 				INFORM("prior definition here");
 				zcc_errors.inc_error();
-				// now it's gone
-				src.DeleteNSlotsAt<0>(1,i);
-				continue;
+				src.c_array<0>()[i].DeleteIdx<2>(0);
+				assert(is_C99_named_specifier(src.data<0>()[i],"enum"));
+				goto reparse;
 				}
 			// One Definition Rule states that conflicting enum, struct, or class must error
 			else if (const type_system::type_index fatal_def = parse_tree::types->get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace))



