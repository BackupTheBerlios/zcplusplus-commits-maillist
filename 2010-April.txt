From zaimoni at mail.berlios.de  Wed Apr  7 08:07:56 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 7 Apr 2010 08:07:56 +0200
Subject: [Zcplusplus-commits] r363 - in trunk/tests:
	zcc/default/staticassert zcc/staticassert.C1X
	zcc.in/default/staticassert
Message-ID: <201004070607.o3767uJt018871@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-07 08:07:22 +0200 (Wed, 07 Apr 2010)
New Revision: 363

Modified:
   trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
   trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
   trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
Log:
operator - test cases

Modified: trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2010-03-27 01:52:05 UTC (rev 362)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2010-04-07 06:07:22 UTC (rev 363)
@@ -15,3 +15,5 @@
 _Static_Assert("A"+1,"automatic success has failed");
 _Static_Assert(1+"A","automatic success has failed");
 
+_Static_Assert("A"-0,"automatic success has failed");
+

Modified: trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp	2010-03-27 01:52:05 UTC (rev 362)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp	2010-04-07 06:07:22 UTC (rev 363)
@@ -15,3 +15,5 @@
 static_assert("A"+1,"automatic success has failed");
 static_assert(1+"A","automatic success has failed");
 
+static_assert("A"-0,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-03-27 01:52:05 UTC (rev 362)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-04-07 06:07:22 UTC (rev 363)
@@ -66,3 +66,14 @@
 _Static_Assert(1+0,"automatic success has failed");
 _Static_Assert(1+1,"automatic success has failed");
 
+// check -
+_Static_Assert(!(-1- -1),"automatic success has failed");
+_Static_Assert(-1-0,"automatic success has failed");
+_Static_Assert(-1-1,"automatic success has failed");
+_Static_Assert(0- -1,"automatic success has failed");
+_Static_Assert(!(0-0),"automatic success has failed");
+_Static_Assert(0-1,"automatic success has failed");
+_Static_Assert(1- -1,"automatic success has failed");
+_Static_Assert(1-0,"automatic success has failed");
+_Static_Assert(!(1-1),"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-03-27 01:52:05 UTC (rev 362)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-04-07 06:07:22 UTC (rev 363)
@@ -66,3 +66,14 @@
 static_assert(1+0,"automatic success has failed");
 static_assert(1+1,"automatic success has failed");
 
+// check -
+static_assert(!(-1- -1),"automatic success has failed");
+static_assert(-1-0,"automatic success has failed");
+static_assert(-1-1,"automatic success has failed");
+static_assert(0- -1,"automatic success has failed");
+static_assert(!(0-0),"automatic success has failed");
+static_assert(0-1,"automatic success has failed");
+static_assert(1- -1,"automatic success has failed");
+static_assert(1-0,"automatic success has failed");
+static_assert(!(1-1),"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-03-27 01:52:05 UTC (rev 362)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-04-07 06:07:22 UTC (rev 363)
@@ -61,3 +61,15 @@
 _Static_Assert(one+zero,"automatic success has failed");
 _Static_Assert(one+one,"automatic success has failed");
 
+// check -
+_Static_Assert(!(neg_one-neg_one),"automatic success has failed");
+_Static_Assert(neg_one-zero,"automatic success has failed");
+_Static_Assert(neg_one-one,"automatic success has failed");
+_Static_Assert(zero-neg_one,"automatic success has failed");
+_Static_Assert(!(zero-zero),"automatic success has failed");
+_Static_Assert(zero-one,"automatic success has failed");
+_Static_Assert(one-neg_one,"automatic success has failed");
+_Static_Assert(one-zero,"automatic success has failed");
+_Static_Assert(!(one-one),"automatic success has failed");
+
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-03-27 01:52:05 UTC (rev 362)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-04-07 06:07:22 UTC (rev 363)
@@ -61,3 +61,15 @@
 static_assert(one+zero,"automatic success has failed");
 static_assert(one+one,"automatic success has failed");
 
+// check -
+static_assert(!(neg_one-neg_one),"automatic success has failed");
+static_assert(neg_one-zero,"automatic success has failed");
+static_assert(neg_one-one,"automatic success has failed");
+static_assert(zero-neg_one,"automatic success has failed");
+static_assert(!(zero-zero),"automatic success has failed");
+static_assert(zero-one,"automatic success has failed");
+static_assert(one-neg_one,"automatic success has failed");
+static_assert(one-zero,"automatic success has failed");
+static_assert(!(one-one),"automatic success has failed");
+
+

Modified: trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2010-03-27 01:52:05 UTC (rev 362)
+++ trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2010-04-07 06:07:22 UTC (rev 363)
@@ -16,3 +16,5 @@
 STATIC_ASSERT("A"+1,"automatic success has failed");
 STATIC_ASSERT(1+"A","automatic success has failed");
 
+STATIC_ASSERT("A"-0,"automatic success has failed");
+



From zaimoni at mail.berlios.de  Wed Apr  7 08:15:39 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 7 Apr 2010 08:15:39 +0200
Subject: [Zcplusplus-commits] r364 - trunk/tests/zcc.in/staticassert.C1X
Message-ID: <201004070615.o376FdOB019279@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-07 08:15:36 +0200 (Wed, 07 Apr 2010)
New Revision: 364

Modified:
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
Log:
source for operator - test cases

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-07 06:07:22 UTC (rev 363)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-07 06:15:36 UTC (rev 364)
@@ -67,3 +67,14 @@
 STATIC_ASSERT(1+0,"automatic success has failed");
 STATIC_ASSERT(1+1,"automatic success has failed");
 
+// check -
+STATIC_ASSERT(!(-1- -1),"automatic success has failed");
+STATIC_ASSERT(-1-0,"automatic success has failed");
+STATIC_ASSERT(-1-1,"automatic success has failed");
+STATIC_ASSERT(0- -1,"automatic success has failed");
+STATIC_ASSERT(!(0-0),"automatic success has failed");
+STATIC_ASSERT(0-1,"automatic success has failed");
+STATIC_ASSERT(1- -1,"automatic success has failed");
+STATIC_ASSERT(1-0,"automatic success has failed");
+STATIC_ASSERT(!(1-1),"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-04-07 06:07:22 UTC (rev 363)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-04-07 06:15:36 UTC (rev 364)
@@ -62,3 +62,15 @@
 STATIC_ASSERT(one+zero,"automatic success has failed");
 STATIC_ASSERT(one+one,"automatic success has failed");
 
+// check -
+STATIC_ASSERT(!(neg_one-neg_one),"automatic success has failed");
+STATIC_ASSERT(neg_one-zero,"automatic success has failed");
+STATIC_ASSERT(neg_one-one,"automatic success has failed");
+STATIC_ASSERT(zero-neg_one,"automatic success has failed");
+STATIC_ASSERT(!(zero-zero),"automatic success has failed");
+STATIC_ASSERT(zero-one,"automatic success has failed");
+STATIC_ASSERT(one-neg_one,"automatic success has failed");
+STATIC_ASSERT(one-zero,"automatic success has failed");
+STATIC_ASSERT(!(one-one),"automatic success has failed");
+
+



From zaimoni at mail.berlios.de  Thu Apr  8 06:38:42 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 8 Apr 2010 06:38:42 +0200
Subject: [Zcplusplus-commits] r365 - in trunk: . tests/zcc/staticassert.C1X
	tests/zcc.in/staticassert.C1X
Message-ID: <201004080438.o384cgKo011490@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-08 06:38:29 +0200 (Thu, 08 Apr 2010)
New Revision: 365

Modified:
   trunk/CSupport.cpp
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
Log:
enumerator support for the shift operators << >>

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-07 06:15:36 UTC (rev 364)
+++ trunk/CSupport.cpp	2010-04-08 04:38:29 UTC (rev 365)
@@ -7623,6 +7623,12 @@
 		{
 		if (!is_true)
 			{	// __ << 0 or __ >> 0: lift
+#/*cut-cpp*/
+			// handle enumerators now
+			if (   is_noticed_enumerator(*src.data<1>(),types)
+				&& !enumerator_to_integer_representation(*src.c_array<1>(),types))
+				return false;
+#/*cut-cpp*/
 			src.eval_to_arg<1>(0);
 			src.type_code = old_type;
 			return true;

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-04-07 06:15:36 UTC (rev 364)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-04-08 04:38:29 UTC (rev 365)
@@ -77,3 +77,9 @@
 _Static_Assert(1-0,"automatic success has failed");
 _Static_Assert(!(1-1),"automatic success has failed");
 
+// check <<, >>
+_Static_Assert(!(0<<0),"automatic success has failed");
+_Static_Assert(!(0<<1),"automatic success has failed");
+_Static_Assert(1<<0,"automatic success has failed");
+_Static_Assert(1<<1,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-04-07 06:15:36 UTC (rev 364)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-04-08 04:38:29 UTC (rev 365)
@@ -77,3 +77,9 @@
 static_assert(1-0,"automatic success has failed");
 static_assert(!(1-1),"automatic success has failed");
 
+// check <<, >>
+static_assert(!(0<<0),"automatic success has failed");
+static_assert(!(0<<1),"automatic success has failed");
+static_assert(1<<0,"automatic success has failed");
+static_assert(1<<1,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-04-07 06:15:36 UTC (rev 364)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-04-08 04:38:29 UTC (rev 365)
@@ -72,4 +72,9 @@
 _Static_Assert(one-zero,"automatic success has failed");
 _Static_Assert(!(one-one),"automatic success has failed");
 
+// check <<, >>
+_Static_Assert(!(zero<<zero),"automatic success has failed");
+_Static_Assert(!(zero<<one),"automatic success has failed");
+_Static_Assert(one<<zero,"automatic success has failed");
+_Static_Assert(one<<one,"automatic success has failed");
 

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-04-07 06:15:36 UTC (rev 364)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-04-08 04:38:29 UTC (rev 365)
@@ -72,4 +72,9 @@
 static_assert(one-zero,"automatic success has failed");
 static_assert(!(one-one),"automatic success has failed");
 
+// check <<, >>
+static_assert(!(zero<<zero),"automatic success has failed");
+static_assert(!(zero<<one),"automatic success has failed");
+static_assert(one<<zero,"automatic success has failed");
+static_assert(one<<one,"automatic success has failed");
 

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-07 06:15:36 UTC (rev 364)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-08 04:38:29 UTC (rev 365)
@@ -78,3 +78,9 @@
 STATIC_ASSERT(1-0,"automatic success has failed");
 STATIC_ASSERT(!(1-1),"automatic success has failed");
 
+// check <<, >>
+STATIC_ASSERT(!(0<<0),"automatic success has failed");
+STATIC_ASSERT(!(0<<1),"automatic success has failed");
+STATIC_ASSERT(1<<0,"automatic success has failed");
+STATIC_ASSERT(1<<1,"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-04-07 06:15:36 UTC (rev 364)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-04-08 04:38:29 UTC (rev 365)
@@ -73,4 +73,9 @@
 STATIC_ASSERT(one-zero,"automatic success has failed");
 STATIC_ASSERT(!(one-one),"automatic success has failed");
 
+// check <<, >>
+STATIC_ASSERT(!(zero<<zero),"automatic success has failed");
+STATIC_ASSERT(!(zero<<one),"automatic success has failed");
+STATIC_ASSERT(one<<zero,"automatic success has failed");
+STATIC_ASSERT(one<<one,"automatic success has failed");
 



From zaimoni at mail.berlios.de  Fri Apr  9 02:02:32 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 9 Apr 2010 02:02:32 +0200
Subject: [Zcplusplus-commits] r366 - trunk
Message-ID: <201004090002.o3902Wv4013083@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-09 02:02:28 +0200 (Fri, 09 Apr 2010)
New Revision: 366

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
C99 compliance fix: use signed < <= >= > when required; fix sync error regarding C++ notion of logical negation

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-08 04:38:29 UTC (rev 365)
+++ trunk/CSupport.cpp	2010-04-09 00:02:28 UTC (rev 366)
@@ -3598,7 +3598,8 @@
 			&&	NULL==src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	src.empty<1>()
-			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
+//			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
 }
 
 static bool is_CPP_bitwise_complement_expression(const parse_tree& src)
@@ -7795,25 +7796,73 @@
 	if (lhs_converted && rhs_converted)
 		{
 		const char* result 	= NULL;
-		switch(src.subtype)
-		{
-		case C99_RELATION_SUBTYPE_LT:	{
-										result = (lhs_int<rhs_int) ? "1" : "0";
-										break;
-										}
-		case C99_RELATION_SUBTYPE_GT:	{
-										result = (lhs_int>rhs_int) ? "1" : "0";
-										break;
-										}
-		case C99_RELATION_SUBTYPE_LTE:	{
-										result = (lhs_int<=rhs_int) ? "1" : "0";
-										break;
-										}
-		case C99_RELATION_SUBTYPE_GTE:	{
-										result = (lhs_int>=rhs_int) ? "1" : "0";
-										break;
-										}
-		}
+		const promote_aux targ(arithmetic_reconcile(src.data<1>()->type_code.base_type_index, src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
+		assert(targ.bitcount>=lhs.bitcount);
+		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
+		assert(targ.bitcount>=rhs.bitcount);
+
+		// handle sign-extension of lhs, rhs
+		bool use_unsigned_compare = true;
+		const bool lhs_negative = target_machine->C_promote_integer(lhs_int,lhs,targ);
+		const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,targ);
+		if (rhs_negative) target_machine->signed_additive_inverse(rhs_int,targ.machine_type);
+		if (lhs_negative) target_machine->signed_additive_inverse(lhs_int,targ.machine_type);
+
+		//! \todo --do-what-i-mean redefines < > operators to handle cross-domain
+		if (targ.is_signed && (lhs_negative || rhs_negative))
+			{	// repair switch to handle signed numerals
+			if (lhs_negative && rhs_negative)
+				std::swap(lhs_int,rhs_int);
+			else{
+				const bool lhs_zero = target_machine->is_zero(lhs_int.data(),lhs_int.size(),targ);
+				const bool rhs_zero = target_machine->is_zero(rhs_int.data(),rhs_int.size(),targ);
+				const bool op_uses_less_than = (src.subtype%2);	// low-level, check with static assertions
+				// is above correct?
+				BOOST_STATIC_ASSERT(C99_RELATION_SUBTYPE_LT%2);
+				BOOST_STATIC_ASSERT(C99_RELATION_SUBTYPE_LTE%2);
+				BOOST_STATIC_ASSERT(!(C99_RELATION_SUBTYPE_GT%2));
+				BOOST_STATIC_ASSERT(!(C99_RELATION_SUBTYPE_GTE%2));
+				use_unsigned_compare = false;
+				if (!lhs_zero)
+					{
+					result = lhs_negative ? (op_uses_less_than ? "1" : "0") : (op_uses_less_than ? "0" : "1");
+					}
+				else if (rhs_zero)
+					{
+					result = (C99_RELATION_SUBTYPE_LTE<=src.subtype) ? "1" : "0"; 	// low-level, check with static assertions
+					// is above correct?
+					BOOST_STATIC_ASSERT(C99_RELATION_SUBTYPE_LTE<=C99_RELATION_SUBTYPE_GTE);
+					BOOST_STATIC_ASSERT(C99_RELATION_SUBTYPE_LT<C99_RELATION_SUBTYPE_LTE);
+					BOOST_STATIC_ASSERT(C99_RELATION_SUBTYPE_GT<C99_RELATION_SUBTYPE_LTE);
+					}
+				else{
+					result = rhs_negative ? (op_uses_less_than ? "0" : "1") : (op_uses_less_than ? "1" : "0");
+					}
+				}
+			};
+		if (use_unsigned_compare)
+			{
+			switch(src.subtype)
+			{
+			case C99_RELATION_SUBTYPE_LT:	{
+											result = (lhs_int<rhs_int) ? "1" : "0";
+											break;
+											}
+			case C99_RELATION_SUBTYPE_GT:	{
+											result = (lhs_int>rhs_int) ? "1" : "0";
+											break;
+											}
+			case C99_RELATION_SUBTYPE_LTE:	{
+											result = (lhs_int<=rhs_int) ? "1" : "0";
+											break;
+											}
+			case C99_RELATION_SUBTYPE_GTE:	{
+											result = (lhs_int>=rhs_int) ? "1" : "0";
+											break;
+											}
+			}
+			}
 		force_decimal_literal(src,result,types);
 		return true;
 		};

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-04-08 04:38:29 UTC (rev 365)
+++ trunk/CSupport_pp.cpp	2010-04-09 00:02:28 UTC (rev 366)
@@ -3491,7 +3491,8 @@
 			&&	NULL==src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	src.empty<1>()
-			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
+//			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
 }
 
 static bool is_CPP_bitwise_complement_expression(const parse_tree& src)
@@ -7210,25 +7211,73 @@
 	if (lhs_converted && rhs_converted)
 		{
 		const char* result 	= NULL;
-		switch(src.subtype)
-		{
-		case C99_RELATION_SUBTYPE_LT:	{
-										result = (lhs_int<rhs_int) ? "1" : "0";
-										break;
-										}
-		case C99_RELATION_SUBTYPE_GT:	{
-										result = (lhs_int>rhs_int) ? "1" : "0";
-										break;
-										}
-		case C99_RELATION_SUBTYPE_LTE:	{
-										result = (lhs_int<=rhs_int) ? "1" : "0";
-										break;
-										}
-		case C99_RELATION_SUBTYPE_GTE:	{
-										result = (lhs_int>=rhs_int) ? "1" : "0";
-										break;
-										}
-		}
+		const promote_aux targ(arithmetic_reconcile(src.data<1>()->type_code.base_type_index, src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
+		assert(targ.bitcount>=lhs.bitcount);
+		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
+		assert(targ.bitcount>=rhs.bitcount);
+
+		// handle sign-extension of lhs, rhs
+		bool use_unsigned_compare = true;
+		const bool lhs_negative = target_machine->C_promote_integer(lhs_int,lhs,targ);
+		const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,targ);
+		if (rhs_negative) target_machine->signed_additive_inverse(rhs_int,targ.machine_type);
+		if (lhs_negative) target_machine->signed_additive_inverse(lhs_int,targ.machine_type);
+
+		//! \todo --do-what-i-mean redefines < > operators to handle cross-domain
+		if (targ.is_signed && (lhs_negative || rhs_negative))
+			{	// repair switch to handle signed numerals
+			if (lhs_negative && rhs_negative)
+				std::swap(lhs_int,rhs_int);
+			else{
+				const bool lhs_zero = target_machine->is_zero(lhs_int.data(),lhs_int.size(),targ);
+				const bool rhs_zero = target_machine->is_zero(rhs_int.data(),rhs_int.size(),targ);
+				const bool op_uses_less_than = (src.subtype%2);	// low-level, check with static assertions
+				// is above correct?
+				BOOST_STATIC_ASSERT(C99_RELATION_SUBTYPE_LT%2);
+				BOOST_STATIC_ASSERT(C99_RELATION_SUBTYPE_LTE%2);
+				BOOST_STATIC_ASSERT(!(C99_RELATION_SUBTYPE_GT%2));
+				BOOST_STATIC_ASSERT(!(C99_RELATION_SUBTYPE_GTE%2));
+				use_unsigned_compare = false;
+				if (!lhs_zero)
+					{
+					result = lhs_negative ? (op_uses_less_than ? "1" : "0") : (op_uses_less_than ? "0" : "1");
+					}
+				else if (rhs_zero)
+					{
+					result = (C99_RELATION_SUBTYPE_LTE<=src.subtype) ? "1" : "0"; 	// low-level, check with static assertions
+					// is above correct?
+					BOOST_STATIC_ASSERT(C99_RELATION_SUBTYPE_LTE<=C99_RELATION_SUBTYPE_GTE);
+					BOOST_STATIC_ASSERT(C99_RELATION_SUBTYPE_LT<C99_RELATION_SUBTYPE_LTE);
+					BOOST_STATIC_ASSERT(C99_RELATION_SUBTYPE_GT<C99_RELATION_SUBTYPE_LTE);
+					}
+				else{
+					result = rhs_negative ? (op_uses_less_than ? "0" : "1") : (op_uses_less_than ? "1" : "0");
+					}
+				}
+			};
+		if (use_unsigned_compare)
+			{
+			switch(src.subtype)
+			{
+			case C99_RELATION_SUBTYPE_LT:	{
+											result = (lhs_int<rhs_int) ? "1" : "0";
+											break;
+											}
+			case C99_RELATION_SUBTYPE_GT:	{
+											result = (lhs_int>rhs_int) ? "1" : "0";
+											break;
+											}
+			case C99_RELATION_SUBTYPE_LTE:	{
+											result = (lhs_int<=rhs_int) ? "1" : "0";
+											break;
+											}
+			case C99_RELATION_SUBTYPE_GTE:	{
+											result = (lhs_int>=rhs_int) ? "1" : "0";
+											break;
+											}
+			}
+			}
 		force_decimal_literal(src,result,types);
 		return true;
 		};



From zaimoni at mail.berlios.de  Fri Apr  9 03:10:15 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 9 Apr 2010 03:10:15 +0200
Subject: [Zcplusplus-commits] r367 - in trunk: . tests/zcc/staticassert.C1X
	tests/zcc.in/staticassert.C1X
Message-ID: <201004090110.o391AFoM016727@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-09 03:10:07 +0200 (Fri, 09 Apr 2010)
New Revision: 367

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
Log:
make enumerators work with the relational operators < <= >= >

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-09 00:02:28 UTC (rev 366)
+++ trunk/CSupport.cpp	2010-04-09 01:10:07 UTC (rev 367)
@@ -678,7 +678,6 @@
 
 static bool converts_to_reallike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index;
 #ifdef ZCC_NOT_BUILDING_CPP
 	if (C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index) return true;
 	return types.get_enum_def(base_type_index);

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-04-09 00:02:28 UTC (rev 366)
+++ trunk/CSupport_pp.cpp	2010-04-09 01:10:07 UTC (rev 367)
@@ -622,7 +622,6 @@
 
 static bool converts_to_reallike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index;
 #ifdef ZCC_NOT_BUILDING_CPP
 	if (C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index) return true;
 	return types.get_enum_def(base_type_index);

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-04-09 00:02:28 UTC (rev 366)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-04-09 01:10:07 UTC (rev 367)
@@ -83,3 +83,44 @@
 _Static_Assert(1<<0,"automatic success has failed");
 _Static_Assert(1<<1,"automatic success has failed");
 
+// check <, <=, >=, >
+_Static_Assert(!(-1< -1),"automatic success has failed");
+_Static_Assert(-1<0,"automatic success has failed");
+_Static_Assert(-1<1,"automatic success has failed");
+_Static_Assert(!(0< -1),"automatic success has failed");
+_Static_Assert(!(0<0),"automatic success has failed");
+_Static_Assert(0<1,"automatic success has failed");
+_Static_Assert(!(1< -1),"automatic success has failed");
+_Static_Assert(!(1<0),"automatic success has failed");
+_Static_Assert(!(1<1),"automatic success has failed");
+
+_Static_Assert(-1<= -1,"automatic success has failed");
+_Static_Assert(-1<=0,"automatic success has failed");
+_Static_Assert(-1<=1,"automatic success has failed");
+_Static_Assert(!(0<= -1),"automatic success has failed");
+_Static_Assert(0<=0,"automatic success has failed");
+_Static_Assert(0<=1,"automatic success has failed");
+_Static_Assert(!(1<= -1),"automatic success has failed");
+_Static_Assert(!(1<=0),"automatic success has failed");
+_Static_Assert(1<=1,"automatic success has failed");
+
+_Static_Assert(-1>= -1,"automatic success has failed");
+_Static_Assert(!(-1>=0),"automatic success has failed");
+_Static_Assert(!(-1>=1),"automatic success has failed");
+_Static_Assert(0>= -1,"automatic success has failed");
+_Static_Assert(0>=0,"automatic success has failed");
+_Static_Assert(!(0>=1),"automatic success has failed");
+_Static_Assert(1>= -1,"automatic success has failed");
+_Static_Assert(1>=0,"automatic success has failed");
+_Static_Assert(1>=1,"automatic success has failed");
+
+_Static_Assert(!(-1> -1),"automatic success has failed");
+_Static_Assert(!(-1>0),"automatic success has failed");
+_Static_Assert(!(-1>1),"automatic success has failed");
+_Static_Assert(0> -1,"automatic success has failed");
+_Static_Assert(!(0>0),"automatic success has failed");
+_Static_Assert(!(0>1),"automatic success has failed");
+_Static_Assert(1> -1,"automatic success has failed");
+_Static_Assert(1>0,"automatic success has failed");
+_Static_Assert(!(1>1),"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-04-09 00:02:28 UTC (rev 366)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-04-09 01:10:07 UTC (rev 367)
@@ -83,3 +83,44 @@
 static_assert(1<<0,"automatic success has failed");
 static_assert(1<<1,"automatic success has failed");
 
+// check <, <=, >=, >
+static_assert(!(-1< -1),"automatic success has failed");
+static_assert(-1<0,"automatic success has failed");
+static_assert(-1<1,"automatic success has failed");
+static_assert(!(0< -1),"automatic success has failed");
+static_assert(!(0<0),"automatic success has failed");
+static_assert(0<1,"automatic success has failed");
+static_assert(!(1< -1),"automatic success has failed");
+static_assert(!(1<0),"automatic success has failed");
+static_assert(!(1<1),"automatic success has failed");
+
+static_assert(-1<= -1,"automatic success has failed");
+static_assert(-1<=0,"automatic success has failed");
+static_assert(-1<=1,"automatic success has failed");
+static_assert(!(0<= -1),"automatic success has failed");
+static_assert(0<=0,"automatic success has failed");
+static_assert(0<=1,"automatic success has failed");
+static_assert(!(1<= -1),"automatic success has failed");
+static_assert(!(1<=0),"automatic success has failed");
+static_assert(1<=1,"automatic success has failed");
+
+static_assert(-1>= -1,"automatic success has failed");
+static_assert(!(-1>=0),"automatic success has failed");
+static_assert(!(-1>=1),"automatic success has failed");
+static_assert(0>= -1,"automatic success has failed");
+static_assert(0>=0,"automatic success has failed");
+static_assert(!(0>=1),"automatic success has failed");
+static_assert(1>= -1,"automatic success has failed");
+static_assert(1>=0,"automatic success has failed");
+static_assert(1>=1,"automatic success has failed");
+
+static_assert(!(-1> -1),"automatic success has failed");
+static_assert(!(-1>0),"automatic success has failed");
+static_assert(!(-1>1),"automatic success has failed");
+static_assert(0> -1,"automatic success has failed");
+static_assert(!(0>0),"automatic success has failed");
+static_assert(!(0>1),"automatic success has failed");
+static_assert(1> -1,"automatic success has failed");
+static_assert(1>0,"automatic success has failed");
+static_assert(!(1>1),"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-04-09 00:02:28 UTC (rev 366)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-04-09 01:10:07 UTC (rev 367)
@@ -78,3 +78,44 @@
 _Static_Assert(one<<zero,"automatic success has failed");
 _Static_Assert(one<<one,"automatic success has failed");
 
+// check <, <=, >=, >
+_Static_Assert(!(neg_one<neg_one),"automatic success has failed");
+_Static_Assert(neg_one<zero,"automatic success has failed");
+_Static_Assert(neg_one<one,"automatic success has failed");
+_Static_Assert(!(zero<neg_one),"automatic success has failed");
+_Static_Assert(!(zero<zero),"automatic success has failed");
+_Static_Assert(zero<one,"automatic success has failed");
+_Static_Assert(!(one<neg_one),"automatic success has failed");
+_Static_Assert(!(one<zero),"automatic success has failed");
+_Static_Assert(!(one<one),"automatic success has failed");
+
+_Static_Assert(neg_one<=neg_one,"automatic success has failed");
+_Static_Assert(neg_one<=zero,"automatic success has failed");
+_Static_Assert(neg_one<=one,"automatic success has failed");
+_Static_Assert(!(zero<=neg_one),"automatic success has failed");
+_Static_Assert(zero<=zero,"automatic success has failed");
+_Static_Assert(zero<=one,"automatic success has failed");
+_Static_Assert(!(one<=neg_one),"automatic success has failed");
+_Static_Assert(!(one<=zero),"automatic success has failed");
+_Static_Assert(one<=one,"automatic success has failed");
+
+_Static_Assert(neg_one>=neg_one,"automatic success has failed");
+_Static_Assert(!(neg_one>=zero),"automatic success has failed");
+_Static_Assert(!(neg_one>=one),"automatic success has failed");
+_Static_Assert(zero>=neg_one,"automatic success has failed");
+_Static_Assert(zero>=zero,"automatic success has failed");
+_Static_Assert(!(zero>=one),"automatic success has failed");
+_Static_Assert(one>=neg_one,"automatic success has failed");
+_Static_Assert(one>=zero,"automatic success has failed");
+_Static_Assert(one>=one,"automatic success has failed");
+
+_Static_Assert(!(neg_one>neg_one),"automatic success has failed");
+_Static_Assert(!(neg_one>zero),"automatic success has failed");
+_Static_Assert(!(neg_one>one),"automatic success has failed");
+_Static_Assert(zero>neg_one,"automatic success has failed");
+_Static_Assert(!(zero>zero),"automatic success has failed");
+_Static_Assert(!(zero>one),"automatic success has failed");
+_Static_Assert(one>neg_one,"automatic success has failed");
+_Static_Assert(one>zero,"automatic success has failed");
+_Static_Assert(!(one>one),"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-04-09 00:02:28 UTC (rev 366)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-04-09 01:10:07 UTC (rev 367)
@@ -78,3 +78,44 @@
 static_assert(one<<zero,"automatic success has failed");
 static_assert(one<<one,"automatic success has failed");
 
+// check <, <=, >=, >
+static_assert(!(neg_one<neg_one),"automatic success has failed");
+static_assert(neg_one<zero,"automatic success has failed");
+static_assert(neg_one<one,"automatic success has failed");
+static_assert(!(zero<neg_one),"automatic success has failed");
+static_assert(!(zero<zero),"automatic success has failed");
+static_assert(zero<one,"automatic success has failed");
+static_assert(!(one<neg_one),"automatic success has failed");
+static_assert(!(one<zero),"automatic success has failed");
+static_assert(!(one<one),"automatic success has failed");
+
+static_assert(neg_one<=neg_one,"automatic success has failed");
+static_assert(neg_one<=zero,"automatic success has failed");
+static_assert(neg_one<=one,"automatic success has failed");
+static_assert(!(zero<=neg_one),"automatic success has failed");
+static_assert(zero<=zero,"automatic success has failed");
+static_assert(zero<=one,"automatic success has failed");
+static_assert(!(one<=neg_one),"automatic success has failed");
+static_assert(!(one<=zero),"automatic success has failed");
+static_assert(one<=one,"automatic success has failed");
+
+static_assert(neg_one>=neg_one,"automatic success has failed");
+static_assert(!(neg_one>=zero),"automatic success has failed");
+static_assert(!(neg_one>=one),"automatic success has failed");
+static_assert(zero>=neg_one,"automatic success has failed");
+static_assert(zero>=zero,"automatic success has failed");
+static_assert(!(zero>=one),"automatic success has failed");
+static_assert(one>=neg_one,"automatic success has failed");
+static_assert(one>=zero,"automatic success has failed");
+static_assert(one>=one,"automatic success has failed");
+
+static_assert(!(neg_one>neg_one),"automatic success has failed");
+static_assert(!(neg_one>zero),"automatic success has failed");
+static_assert(!(neg_one>one),"automatic success has failed");
+static_assert(zero>neg_one,"automatic success has failed");
+static_assert(!(zero>zero),"automatic success has failed");
+static_assert(!(zero>one),"automatic success has failed");
+static_assert(one>neg_one,"automatic success has failed");
+static_assert(one>zero,"automatic success has failed");
+static_assert(!(one>one),"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-09 00:02:28 UTC (rev 366)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-09 01:10:07 UTC (rev 367)
@@ -84,3 +84,44 @@
 STATIC_ASSERT(1<<0,"automatic success has failed");
 STATIC_ASSERT(1<<1,"automatic success has failed");
 
+// check <, <=, >=, >
+STATIC_ASSERT(!(-1< -1),"automatic success has failed");
+STATIC_ASSERT(-1<0,"automatic success has failed");
+STATIC_ASSERT(-1<1,"automatic success has failed");
+STATIC_ASSERT(!(0< -1),"automatic success has failed");
+STATIC_ASSERT(!(0<0),"automatic success has failed");
+STATIC_ASSERT(0<1,"automatic success has failed");
+STATIC_ASSERT(!(1< -1),"automatic success has failed");
+STATIC_ASSERT(!(1<0),"automatic success has failed");
+STATIC_ASSERT(!(1<1),"automatic success has failed");
+
+STATIC_ASSERT(-1<= -1,"automatic success has failed");
+STATIC_ASSERT(-1<=0,"automatic success has failed");
+STATIC_ASSERT(-1<=1,"automatic success has failed");
+STATIC_ASSERT(!(0<= -1),"automatic success has failed");
+STATIC_ASSERT(0<=0,"automatic success has failed");
+STATIC_ASSERT(0<=1,"automatic success has failed");
+STATIC_ASSERT(!(1<= -1),"automatic success has failed");
+STATIC_ASSERT(!(1<=0),"automatic success has failed");
+STATIC_ASSERT(1<=1,"automatic success has failed");
+
+STATIC_ASSERT(-1>= -1,"automatic success has failed");
+STATIC_ASSERT(!(-1>=0),"automatic success has failed");
+STATIC_ASSERT(!(-1>=1),"automatic success has failed");
+STATIC_ASSERT(0>= -1,"automatic success has failed");
+STATIC_ASSERT(0>=0,"automatic success has failed");
+STATIC_ASSERT(!(0>=1),"automatic success has failed");
+STATIC_ASSERT(1>= -1,"automatic success has failed");
+STATIC_ASSERT(1>=0,"automatic success has failed");
+STATIC_ASSERT(1>=1,"automatic success has failed");
+
+STATIC_ASSERT(!(-1> -1),"automatic success has failed");
+STATIC_ASSERT(!(-1>0),"automatic success has failed");
+STATIC_ASSERT(!(-1>1),"automatic success has failed");
+STATIC_ASSERT(0> -1,"automatic success has failed");
+STATIC_ASSERT(!(0>0),"automatic success has failed");
+STATIC_ASSERT(!(0>1),"automatic success has failed");
+STATIC_ASSERT(1> -1,"automatic success has failed");
+STATIC_ASSERT(1>0,"automatic success has failed");
+STATIC_ASSERT(!(1>1),"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-04-09 00:02:28 UTC (rev 366)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-04-09 01:10:07 UTC (rev 367)
@@ -79,3 +79,44 @@
 STATIC_ASSERT(one<<zero,"automatic success has failed");
 STATIC_ASSERT(one<<one,"automatic success has failed");
 
+// check <, <=, >=, >
+STATIC_ASSERT(!(neg_one<neg_one),"automatic success has failed");
+STATIC_ASSERT(neg_one<zero,"automatic success has failed");
+STATIC_ASSERT(neg_one<one,"automatic success has failed");
+STATIC_ASSERT(!(zero<neg_one),"automatic success has failed");
+STATIC_ASSERT(!(zero<zero),"automatic success has failed");
+STATIC_ASSERT(zero<one,"automatic success has failed");
+STATIC_ASSERT(!(one<neg_one),"automatic success has failed");
+STATIC_ASSERT(!(one<zero),"automatic success has failed");
+STATIC_ASSERT(!(one<one),"automatic success has failed");
+
+STATIC_ASSERT(neg_one<=neg_one,"automatic success has failed");
+STATIC_ASSERT(neg_one<=zero,"automatic success has failed");
+STATIC_ASSERT(neg_one<=one,"automatic success has failed");
+STATIC_ASSERT(!(zero<=neg_one),"automatic success has failed");
+STATIC_ASSERT(zero<=zero,"automatic success has failed");
+STATIC_ASSERT(zero<=one,"automatic success has failed");
+STATIC_ASSERT(!(one<=neg_one),"automatic success has failed");
+STATIC_ASSERT(!(one<=zero),"automatic success has failed");
+STATIC_ASSERT(one<=one,"automatic success has failed");
+
+STATIC_ASSERT(neg_one>=neg_one,"automatic success has failed");
+STATIC_ASSERT(!(neg_one>=zero),"automatic success has failed");
+STATIC_ASSERT(!(neg_one>=one),"automatic success has failed");
+STATIC_ASSERT(zero>=neg_one,"automatic success has failed");
+STATIC_ASSERT(zero>=zero,"automatic success has failed");
+STATIC_ASSERT(!(zero>=one),"automatic success has failed");
+STATIC_ASSERT(one>=neg_one,"automatic success has failed");
+STATIC_ASSERT(one>=zero,"automatic success has failed");
+STATIC_ASSERT(one>=one,"automatic success has failed");
+
+STATIC_ASSERT(!(neg_one>neg_one),"automatic success has failed");
+STATIC_ASSERT(!(neg_one>zero),"automatic success has failed");
+STATIC_ASSERT(!(neg_one>one),"automatic success has failed");
+STATIC_ASSERT(zero>neg_one,"automatic success has failed");
+STATIC_ASSERT(!(zero>zero),"automatic success has failed");
+STATIC_ASSERT(!(zero>one),"automatic success has failed");
+STATIC_ASSERT(one>neg_one,"automatic success has failed");
+STATIC_ASSERT(one>zero,"automatic success has failed");
+STATIC_ASSERT(!(one>one),"automatic success has failed");
+



From zaimoni at mail.berlios.de  Sat Apr 10 04:52:28 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 10 Apr 2010 04:52:28 +0200
Subject: [Zcplusplus-commits] r368 - in trunk/tests:
	zcc/default/staticassert zcc/staticassert.C1X
	zcc.in/default/staticassert zcc.in/staticassert.C1X
Message-ID: <201004100252.o3A2qSan023783@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-10 04:52:20 +0200 (Sat, 10 Apr 2010)
New Revision: 368

Modified:
   trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
   trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
   trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
Log:
test cases documenting enumerator support for operators == !=

Modified: trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2010-04-09 01:10:07 UTC (rev 367)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2010-04-10 02:52:20 UTC (rev 368)
@@ -17,3 +17,9 @@
 
 _Static_Assert("A"-0,"automatic success has failed");
 
+_Static_Assert("A"=="A","automatic success has failed");
+_Static_Assert("A"!="B","automatic success has failed");
+_Static_Assert("A"!=0,"automatic success has failed");
+_Static_Assert(0!="B","automatic success has failed");
+
+

Modified: trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp	2010-04-09 01:10:07 UTC (rev 367)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp	2010-04-10 02:52:20 UTC (rev 368)
@@ -17,3 +17,9 @@
 
 static_assert("A"-0,"automatic success has failed");
 
+static_assert("A"=="A","automatic success has failed");
+static_assert("A"!="B","automatic success has failed");
+static_assert("A"!=0,"automatic success has failed");
+static_assert(0!="B","automatic success has failed");
+
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-04-09 01:10:07 UTC (rev 367)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-04-10 02:52:20 UTC (rev 368)
@@ -124,3 +124,23 @@
 _Static_Assert(1>0,"automatic success has failed");
 _Static_Assert(!(1>1),"automatic success has failed");
 
+// check ==, !=
+_Static_Assert(-1== -1,"automatic success has failed");
+_Static_Assert(!(-1==0),"automatic success has failed");
+_Static_Assert(!(-1==1),"automatic success has failed");
+_Static_Assert(!(0== -1),"automatic success has failed");
+_Static_Assert(0==0,"automatic success has failed");
+_Static_Assert(!(0==1),"automatic success has failed");
+_Static_Assert(!(1== -1),"automatic success has failed");
+_Static_Assert(!(1==0),"automatic success has failed");
+_Static_Assert(1==1,"automatic success has failed");
+
+_Static_Assert(!(-1!= -1),"automatic success has failed");
+_Static_Assert(-1!=0,"automatic success has failed");
+_Static_Assert(-1!=1,"automatic success has failed");
+_Static_Assert(0!= -1,"automatic success has failed");
+_Static_Assert(!(0!=0),"automatic success has failed");
+_Static_Assert(0!=1,"automatic success has failed");
+_Static_Assert(1!= -1,"automatic success has failed");
+_Static_Assert(1!=0,"automatic success has failed");
+_Static_Assert(!(1!=1),"automatic success has failed");

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-04-09 01:10:07 UTC (rev 367)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-04-10 02:52:20 UTC (rev 368)
@@ -124,3 +124,23 @@
 static_assert(1>0,"automatic success has failed");
 static_assert(!(1>1),"automatic success has failed");
 
+// check ==, !=
+static_assert(-1== -1,"automatic success has failed");
+static_assert(!(-1==0),"automatic success has failed");
+static_assert(!(-1==1),"automatic success has failed");
+static_assert(!(0== -1),"automatic success has failed");
+static_assert(0==0,"automatic success has failed");
+static_assert(!(0==1),"automatic success has failed");
+static_assert(!(1== -1),"automatic success has failed");
+static_assert(!(1==0),"automatic success has failed");
+static_assert(1==1,"automatic success has failed");
+
+static_assert(!(-1!= -1),"automatic success has failed");
+static_assert(-1!=0,"automatic success has failed");
+static_assert(-1!=1,"automatic success has failed");
+static_assert(0!= -1,"automatic success has failed");
+static_assert(!(0!=0),"automatic success has failed");
+static_assert(0!=1,"automatic success has failed");
+static_assert(1!= -1,"automatic success has failed");
+static_assert(1!=0,"automatic success has failed");
+static_assert(!(1!=1),"automatic success has failed");

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-04-09 01:10:07 UTC (rev 367)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-04-10 02:52:20 UTC (rev 368)
@@ -119,3 +119,23 @@
 _Static_Assert(one>zero,"automatic success has failed");
 _Static_Assert(!(one>one),"automatic success has failed");
 
+// check ==, !=
+_Static_Assert(neg_one==neg_one,"automatic success has failed");
+_Static_Assert(!(neg_one==zero),"automatic success has failed");
+_Static_Assert(!(neg_one==one),"automatic success has failed");
+_Static_Assert(!(zero==neg_one),"automatic success has failed");
+_Static_Assert(zero==zero,"automatic success has failed");
+_Static_Assert(!(zero==one),"automatic success has failed");
+_Static_Assert(!(one==neg_one),"automatic success has failed");
+_Static_Assert(!(one==zero),"automatic success has failed");
+_Static_Assert(one==one,"automatic success has failed");
+
+_Static_Assert(!(neg_one!=neg_one),"automatic success has failed");
+_Static_Assert(neg_one!=zero,"automatic success has failed");
+_Static_Assert(neg_one!=one,"automatic success has failed");
+_Static_Assert(zero!=neg_one,"automatic success has failed");
+_Static_Assert(!(zero!=zero),"automatic success has failed");
+_Static_Assert(zero!=one,"automatic success has failed");
+_Static_Assert(one!=neg_one,"automatic success has failed");
+_Static_Assert(one!=zero,"automatic success has failed");
+_Static_Assert(!(one!=one),"automatic success has failed");

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-04-09 01:10:07 UTC (rev 367)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-04-10 02:52:20 UTC (rev 368)
@@ -119,3 +119,23 @@
 static_assert(one>zero,"automatic success has failed");
 static_assert(!(one>one),"automatic success has failed");
 
+// check ==, !=
+static_assert(neg_one==neg_one,"automatic success has failed");
+static_assert(!(neg_one==zero),"automatic success has failed");
+static_assert(!(neg_one==one),"automatic success has failed");
+static_assert(!(zero==neg_one),"automatic success has failed");
+static_assert(zero==zero,"automatic success has failed");
+static_assert(!(zero==one),"automatic success has failed");
+static_assert(!(one==neg_one),"automatic success has failed");
+static_assert(!(one==zero),"automatic success has failed");
+static_assert(one==one,"automatic success has failed");
+
+static_assert(!(neg_one!=neg_one),"automatic success has failed");
+static_assert(neg_one!=zero,"automatic success has failed");
+static_assert(neg_one!=one,"automatic success has failed");
+static_assert(zero!=neg_one,"automatic success has failed");
+static_assert(!(zero!=zero),"automatic success has failed");
+static_assert(zero!=one,"automatic success has failed");
+static_assert(one!=neg_one,"automatic success has failed");
+static_assert(one!=zero,"automatic success has failed");
+static_assert(!(one!=one),"automatic success has failed");

Modified: trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2010-04-09 01:10:07 UTC (rev 367)
+++ trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2010-04-10 02:52:20 UTC (rev 368)
@@ -18,3 +18,9 @@
 
 STATIC_ASSERT("A"-0,"automatic success has failed");
 
+STATIC_ASSERT("A"=="A","automatic success has failed");
+STATIC_ASSERT("A"!="B","automatic success has failed");
+STATIC_ASSERT("A"!=0,"automatic success has failed");
+STATIC_ASSERT(0!="B","automatic success has failed");
+
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-09 01:10:07 UTC (rev 367)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-10 02:52:20 UTC (rev 368)
@@ -125,3 +125,23 @@
 STATIC_ASSERT(1>0,"automatic success has failed");
 STATIC_ASSERT(!(1>1),"automatic success has failed");
 
+// check ==, !=
+STATIC_ASSERT(-1== -1,"automatic success has failed");
+STATIC_ASSERT(!(-1==0),"automatic success has failed");
+STATIC_ASSERT(!(-1==1),"automatic success has failed");
+STATIC_ASSERT(!(0== -1),"automatic success has failed");
+STATIC_ASSERT(0==0,"automatic success has failed");
+STATIC_ASSERT(!(0==1),"automatic success has failed");
+STATIC_ASSERT(!(1== -1),"automatic success has failed");
+STATIC_ASSERT(!(1==0),"automatic success has failed");
+STATIC_ASSERT(1==1,"automatic success has failed");
+
+STATIC_ASSERT(!(-1!= -1),"automatic success has failed");
+STATIC_ASSERT(-1!=0,"automatic success has failed");
+STATIC_ASSERT(-1!=1,"automatic success has failed");
+STATIC_ASSERT(0!= -1,"automatic success has failed");
+STATIC_ASSERT(!(0!=0),"automatic success has failed");
+STATIC_ASSERT(0!=1,"automatic success has failed");
+STATIC_ASSERT(1!= -1,"automatic success has failed");
+STATIC_ASSERT(1!=0,"automatic success has failed");
+STATIC_ASSERT(!(1!=1),"automatic success has failed");

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-04-09 01:10:07 UTC (rev 367)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-04-10 02:52:20 UTC (rev 368)
@@ -120,3 +120,23 @@
 STATIC_ASSERT(one>zero,"automatic success has failed");
 STATIC_ASSERT(!(one>one),"automatic success has failed");
 
+// check ==, !=
+STATIC_ASSERT(neg_one==neg_one,"automatic success has failed");
+STATIC_ASSERT(!(neg_one==zero),"automatic success has failed");
+STATIC_ASSERT(!(neg_one==one),"automatic success has failed");
+STATIC_ASSERT(!(zero==neg_one),"automatic success has failed");
+STATIC_ASSERT(zero==zero,"automatic success has failed");
+STATIC_ASSERT(!(zero==one),"automatic success has failed");
+STATIC_ASSERT(!(one==neg_one),"automatic success has failed");
+STATIC_ASSERT(!(one==zero),"automatic success has failed");
+STATIC_ASSERT(one==one,"automatic success has failed");
+
+STATIC_ASSERT(!(neg_one!=neg_one),"automatic success has failed");
+STATIC_ASSERT(neg_one!=zero,"automatic success has failed");
+STATIC_ASSERT(neg_one!=one,"automatic success has failed");
+STATIC_ASSERT(zero!=neg_one,"automatic success has failed");
+STATIC_ASSERT(!(zero!=zero),"automatic success has failed");
+STATIC_ASSERT(zero!=one,"automatic success has failed");
+STATIC_ASSERT(one!=neg_one,"automatic success has failed");
+STATIC_ASSERT(one!=zero,"automatic success has failed");
+STATIC_ASSERT(!(one!=one),"automatic success has failed");



From zaimoni at mail.berlios.de  Sat Apr 10 05:36:11 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 10 Apr 2010 05:36:11 +0200
Subject: [Zcplusplus-commits] r369 - in trunk: . tests/zcc/staticassert.C1X
	tests/zcc.in/staticassert.C1X
Message-ID: <201004100336.o3A3aBKj026429@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-10 05:36:05 +0200 (Sat, 10 Apr 2010)
New Revision: 369

Modified:
   trunk/CSupport.cpp
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
Log:
enumerator support for operators & ^ |

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-10 02:52:20 UTC (rev 368)
+++ trunk/CSupport.cpp	2010-04-10 03:36:05 UTC (rev 369)
@@ -8288,10 +8288,30 @@
 
 		if 		(res_int==lhs_int)
 			// lhs & rhs = lhs; conserve type
+#/*cut-cpp*/
+			{
+			// handle enumerators now
+			if (   is_noticed_enumerator(*src.data<1>(),types)
+				&& !enumerator_to_integer_representation(*src.c_array<1>(),types))
+				return false;
+#/*cut-cpp*/
 			src.eval_to_arg<1>(0);
+#/*cut-cpp*/
+			}
+#/*cut-cpp*/
 		else if (res_int==rhs_int)
 			// lhs & rhs = rhs; conserve type
+#/*cut-cpp*/
+			{
+			// handle enumerators now
+			if (   is_noticed_enumerator(*src.data<2>(),types)
+				&& !enumerator_to_integer_representation(*src.c_array<2>(),types))
+				return false;
+#/*cut-cpp*/
 			src.eval_to_arg<2>(0);
+#/*cut-cpp*/
+			}
+#/*cut-cpp*/
 		else{
 			const bool negative_signed_int = old.is_signed && res_int.test(old.bitcount-1);
 			if (negative_signed_int) target_machine->signed_additive_inverse(res_int,old.machine_type);
@@ -8435,6 +8455,12 @@
 		{
 		if (!is_true)
 			{	// 0 ^ __
+#/*cut-cpp*/
+			// handle enumerators now
+			if (   is_noticed_enumerator(*src.data<2>(),types)
+				&& !enumerator_to_integer_representation(*src.c_array<2>(),types))
+				return false;
+#/*cut-cpp*/
 			src.eval_to_arg<2>(0);
 			//! \todo convert char literal to appropriate integer
 			return true;
@@ -8444,6 +8470,12 @@
 		{
 		if (!is_true)
 			{	// __ ^ 0
+#/*cut-cpp*/
+			// handle enumerators now
+			if (   is_noticed_enumerator(*src.data<1>(),types)
+				&& !enumerator_to_integer_representation(*src.c_array<1>(),types))
+				return false;
+#/*cut-cpp*/
 			src.eval_to_arg<1>(0);
 			//! \todo convert char literal to appropriate integer
 			return true;
@@ -8603,6 +8635,12 @@
 		{
 		if (!is_true)
 			{	// 0 | __
+#/*cut-cpp*/
+			// handle enumerators now
+			if (   is_noticed_enumerator(*src.data<2>(),types)
+				&& !enumerator_to_integer_representation(*src.c_array<2>(),types))
+				return false;
+#/*cut-cpp*/
 			src.eval_to_arg<2>(0);
 			//! \todo convert char literal to appropriate integer
 			return true;
@@ -8612,6 +8650,12 @@
 		{
 		if (!is_true)
 			{	// __ | 0
+#/*cut-cpp*/
+			// handle enumerators now
+			if (   is_noticed_enumerator(*src.data<1>(),types)
+				&& !enumerator_to_integer_representation(*src.c_array<1>(),types))
+				return false;
+#/*cut-cpp*/
 			src.eval_to_arg<1>(0);
 			//! \todo convert char literal to appropriate integer
 			return true;
@@ -8629,10 +8673,30 @@
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
 		if 		(res_int==lhs_int)
 			// lhs | rhs = lhs; conserve type
+#/*cut-cpp*/
+			{
+			// handle enumerators now
+			if (   is_noticed_enumerator(*src.data<1>(),types)
+				&& !enumerator_to_integer_representation(*src.c_array<1>(),types))
+				return false;
+#/*cut-cpp*/
 			src.eval_to_arg<1>(0);
+#/*cut-cpp*/
+			}
+#/*cut-cpp*/
 		else if (res_int==rhs_int)
 			// lhs | rhs = rhs; conserve type
+#/*cut-cpp*/
+			{
+			// handle enumerators now
+			if (   is_noticed_enumerator(*src.data<1>(),types)
+				&& !enumerator_to_integer_representation(*src.c_array<1>(),types))
+				return false;
+#/*cut-cpp*/
 			src.eval_to_arg<2>(0);
+#/*cut-cpp*/
+			}
+#/*cut-cpp*/
 		else{
 			if (int_has_trapped(src,res_int,hard_error)) return false;
 

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-04-10 02:52:20 UTC (rev 368)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-04-10 03:36:05 UTC (rev 369)
@@ -144,3 +144,20 @@
 _Static_Assert(1!= -1,"automatic success has failed");
 _Static_Assert(1!=0,"automatic success has failed");
 _Static_Assert(!(1!=1),"automatic success has failed");
+
+// check & ^ | 
+_Static_Assert(!(0&0),"automatic success has failed");
+_Static_Assert(!(0&1),"automatic success has failed");
+_Static_Assert(!(1&0),"automatic success has failed");
+_Static_Assert(1&1,"automatic success has failed");
+
+_Static_Assert(!(0^0),"automatic success has failed");
+_Static_Assert(0^1,"automatic success has failed");
+_Static_Assert(1^0,"automatic success has failed");
+_Static_Assert(!(1^1),"automatic success has failed");
+
+_Static_Assert(!(0|0),"automatic success has failed");
+_Static_Assert(0|1,"automatic success has failed");
+_Static_Assert(1|0,"automatic success has failed");
+_Static_Assert(1|1,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-04-10 02:52:20 UTC (rev 368)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-04-10 03:36:05 UTC (rev 369)
@@ -144,3 +144,20 @@
 static_assert(1!= -1,"automatic success has failed");
 static_assert(1!=0,"automatic success has failed");
 static_assert(!(1!=1),"automatic success has failed");
+
+// check & ^ | 
+static_assert(!(0&0),"automatic success has failed");
+static_assert(!(0&1),"automatic success has failed");
+static_assert(!(1&0),"automatic success has failed");
+static_assert(1&1,"automatic success has failed");
+
+static_assert(!(0^0),"automatic success has failed");
+static_assert(0^1,"automatic success has failed");
+static_assert(1^0,"automatic success has failed");
+static_assert(!(1^1),"automatic success has failed");
+
+static_assert(!(0|0),"automatic success has failed");
+static_assert(0|1,"automatic success has failed");
+static_assert(1|0,"automatic success has failed");
+static_assert(1|1,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-04-10 02:52:20 UTC (rev 368)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-04-10 03:36:05 UTC (rev 369)
@@ -139,3 +139,20 @@
 _Static_Assert(one!=neg_one,"automatic success has failed");
 _Static_Assert(one!=zero,"automatic success has failed");
 _Static_Assert(!(one!=one),"automatic success has failed");
+
+// check & ^ | 
+_Static_Assert(!(zero&zero),"automatic success has failed");
+_Static_Assert(!(zero&one),"automatic success has failed");
+_Static_Assert(!(one&zero),"automatic success has failed");
+_Static_Assert(one&one,"automatic success has failed");
+
+_Static_Assert(!(zero^zero),"automatic success has failed");
+_Static_Assert(zero^one,"automatic success has failed");
+_Static_Assert(one^zero,"automatic success has failed");
+_Static_Assert(!(one^one),"automatic success has failed");
+
+_Static_Assert(!(zero|zero),"automatic success has failed");
+_Static_Assert(zero|one,"automatic success has failed");
+_Static_Assert(one|zero,"automatic success has failed");
+_Static_Assert(one|one,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-04-10 02:52:20 UTC (rev 368)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-04-10 03:36:05 UTC (rev 369)
@@ -139,3 +139,20 @@
 static_assert(one!=neg_one,"automatic success has failed");
 static_assert(one!=zero,"automatic success has failed");
 static_assert(!(one!=one),"automatic success has failed");
+
+// check & ^ | 
+static_assert(!(zero&zero),"automatic success has failed");
+static_assert(!(zero&one),"automatic success has failed");
+static_assert(!(one&zero),"automatic success has failed");
+static_assert(one&one,"automatic success has failed");
+
+static_assert(!(zero^zero),"automatic success has failed");
+static_assert(zero^one,"automatic success has failed");
+static_assert(one^zero,"automatic success has failed");
+static_assert(!(one^one),"automatic success has failed");
+
+static_assert(!(zero|zero),"automatic success has failed");
+static_assert(zero|one,"automatic success has failed");
+static_assert(one|zero,"automatic success has failed");
+static_assert(one|one,"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-10 02:52:20 UTC (rev 368)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-10 03:36:05 UTC (rev 369)
@@ -145,3 +145,20 @@
 STATIC_ASSERT(1!= -1,"automatic success has failed");
 STATIC_ASSERT(1!=0,"automatic success has failed");
 STATIC_ASSERT(!(1!=1),"automatic success has failed");
+
+// check & ^ | 
+STATIC_ASSERT(!(0&0),"automatic success has failed");
+STATIC_ASSERT(!(0&1),"automatic success has failed");
+STATIC_ASSERT(!(1&0),"automatic success has failed");
+STATIC_ASSERT(1&1,"automatic success has failed");
+
+STATIC_ASSERT(!(0^0),"automatic success has failed");
+STATIC_ASSERT(0^1,"automatic success has failed");
+STATIC_ASSERT(1^0,"automatic success has failed");
+STATIC_ASSERT(!(1^1),"automatic success has failed");
+
+STATIC_ASSERT(!(0|0),"automatic success has failed");
+STATIC_ASSERT(0|1,"automatic success has failed");
+STATIC_ASSERT(1|0,"automatic success has failed");
+STATIC_ASSERT(1|1,"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-04-10 02:52:20 UTC (rev 368)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-04-10 03:36:05 UTC (rev 369)
@@ -140,3 +140,20 @@
 STATIC_ASSERT(one!=neg_one,"automatic success has failed");
 STATIC_ASSERT(one!=zero,"automatic success has failed");
 STATIC_ASSERT(!(one!=one),"automatic success has failed");
+
+// check & ^ | 
+STATIC_ASSERT(!(zero&zero),"automatic success has failed");
+STATIC_ASSERT(!(zero&one),"automatic success has failed");
+STATIC_ASSERT(!(one&zero),"automatic success has failed");
+STATIC_ASSERT(one&one,"automatic success has failed");
+
+STATIC_ASSERT(!(zero^zero),"automatic success has failed");
+STATIC_ASSERT(zero^one,"automatic success has failed");
+STATIC_ASSERT(one^zero,"automatic success has failed");
+STATIC_ASSERT(!(one^one),"automatic success has failed");
+
+STATIC_ASSERT(!(zero|zero),"automatic success has failed");
+STATIC_ASSERT(zero|one,"automatic success has failed");
+STATIC_ASSERT(one|zero,"automatic success has failed");
+STATIC_ASSERT(one|one,"automatic success has failed");
+



From zaimoni at mail.berlios.de  Sat Apr 10 06:03:03 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 10 Apr 2010 06:03:03 +0200
Subject: [Zcplusplus-commits] r370 - in trunk: . tests/cpp/default/keywords
Message-ID: <201004100403.o3A4339W027801@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-10 06:02:57 +0200 (Sat, 10 Apr 2010)
New Revision: 370

Added:
   trunk/tests/cpp/default/keywords/Error_noexcept.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
C++0X n3090 keyword noexcept: preprocessor support

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-10 03:36:05 UTC (rev 369)
+++ trunk/CSupport.cpp	2010-04-10 04:02:57 UTC (rev 370)
@@ -526,6 +526,7 @@
 			DICT_STRUCT("xor"),
 			DICT_STRUCT("xor_eq"),		// end C++98 alternate-operators
 			DICT_STRUCT("constexpr"),	// C++0X keywords we pay attention to
+			DICT_STRUCT("noexcept"),	// C++0X n3090
 			DICT_STRUCT("static_assert"),
 			DICT_STRUCT("thread_local")
 		};

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-04-10 03:36:05 UTC (rev 369)
+++ trunk/CSupport_pp.cpp	2010-04-10 04:02:57 UTC (rev 370)
@@ -516,6 +516,7 @@
 			DICT_STRUCT("xor"),
 			DICT_STRUCT("xor_eq"),		// end C++98 alternate-operators
 			DICT_STRUCT("constexpr"),	// C++0X keywords we pay attention to
+			DICT_STRUCT("noexcept"),	// C++0X n3090
 			DICT_STRUCT("static_assert"),
 			DICT_STRUCT("thread_local")
 		};

Added: trunk/tests/cpp/default/keywords/Error_noexcept.hpp
===================================================================
--- trunk/tests/cpp/default/keywords/Error_noexcept.hpp	2010-04-10 03:36:05 UTC (rev 369)
+++ trunk/tests/cpp/default/keywords/Error_noexcept.hpp	2010-04-10 04:02:57 UTC (rev 370)
@@ -0,0 +1,4 @@
+// default\keywords\Error_noexcept.hpp
+// check that #define of noexcept errors
+// (C)2010 Kenneth Boyd, license: MIT.txt
+#define noexcept 1



From zaimoni at mail.berlios.de  Sat Apr 10 17:57:15 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 10 Apr 2010 17:57:15 +0200
Subject: [Zcplusplus-commits] r371 - in trunk/tests: zcc/staticassert.C1X
	zcc.in/staticassert.C1X
Message-ID: <201004101557.o3AFvFvn007986@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-10 17:57:08 +0200 (Sat, 10 Apr 2010)
New Revision: 371

Modified:
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
Log:
test cases documenting that enumerators work with operators && || ?:

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-04-10 04:02:57 UTC (rev 370)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-04-10 15:57:08 UTC (rev 371)
@@ -161,3 +161,53 @@
 _Static_Assert(1|0,"automatic success has failed");
 _Static_Assert(1|1,"automatic success has failed");
 
+// check && ||
+_Static_Assert(-1&& -1,"automatic success has failed");
+_Static_Assert(!(-1&&0),"automatic success has failed");
+_Static_Assert(-1&&1,"automatic success has failed");
+_Static_Assert(!(0&& -1),"automatic success has failed");
+_Static_Assert(!(0&&0),"automatic success has failed");
+_Static_Assert(!(0&&1),"automatic success has failed");
+_Static_Assert(1&& -1,"automatic success has failed");
+_Static_Assert(!(1&&0),"automatic success has failed");
+_Static_Assert(1&&1,"automatic success has failed");
+
+_Static_Assert(-1|| -1,"automatic success has failed");
+_Static_Assert(-1||0,"automatic success has failed");
+_Static_Assert(-1||1,"automatic success has failed");
+_Static_Assert(0|| -1,"automatic success has failed");
+_Static_Assert(!(0||0),"automatic success has failed");
+_Static_Assert(0||1,"automatic success has failed");
+_Static_Assert(1|| -1,"automatic success has failed");
+_Static_Assert(1||0,"automatic success has failed");
+_Static_Assert(1||1,"automatic success has failed");
+
+// check ? :
+_Static_Assert(-1 ? -1 : -1,"automatic success has failed");
+_Static_Assert(-1 ? -1 : 0,"automatic success has failed");
+_Static_Assert(-1 ? -1 : 1,"automatic success has failed");
+_Static_Assert(!(-1 ? 0 : -1),"automatic success has failed");
+_Static_Assert(!(-1 ? 0 : 0),"automatic success has failed");
+_Static_Assert(!(-1 ? 0 : 1),"automatic success has failed");
+_Static_Assert(-1 ? 1 : -1,"automatic success has failed");
+_Static_Assert(-1 ? 1 : 0,"automatic success has failed");
+_Static_Assert(-1 ? 1 : 1,"automatic success has failed");
+_Static_Assert(0 ? -1 : -1,"automatic success has failed");
+_Static_Assert(!(0 ? -1 : 0),"automatic success has failed");
+_Static_Assert(0 ? -1 : 1,"automatic success has failed");
+_Static_Assert(0 ? 0 : -1,"automatic success has failed");
+_Static_Assert(!(0 ? 0 : 0),"automatic success has failed");
+_Static_Assert(0 ? 0 : 1,"automatic success has failed");
+_Static_Assert(0 ? 1 : -1,"automatic success has failed");
+_Static_Assert(!(0 ? 1 : 0),"automatic success has failed");
+_Static_Assert(0 ? 1 : 1,"automatic success has failed");
+_Static_Assert(1 ? -1 : -1,"automatic success has failed");
+_Static_Assert(1 ? -1 : 0,"automatic success has failed");
+_Static_Assert(1 ? -1 : 1,"automatic success has failed");
+_Static_Assert(!(1 ? 0 : -1),"automatic success has failed");
+_Static_Assert(!(1 ? 0 : 0),"automatic success has failed");
+_Static_Assert(!(1 ? 0 : 1),"automatic success has failed");
+_Static_Assert(1 ? 1 : -1,"automatic success has failed");
+_Static_Assert(1 ? 1 : 0,"automatic success has failed");
+_Static_Assert(1 ? 1 : 1,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-04-10 04:02:57 UTC (rev 370)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-04-10 15:57:08 UTC (rev 371)
@@ -161,3 +161,53 @@
 static_assert(1|0,"automatic success has failed");
 static_assert(1|1,"automatic success has failed");
 
+// check && ||
+static_assert(-1&& -1,"automatic success has failed");
+static_assert(!(-1&&0),"automatic success has failed");
+static_assert(-1&&1,"automatic success has failed");
+static_assert(!(0&& -1),"automatic success has failed");
+static_assert(!(0&&0),"automatic success has failed");
+static_assert(!(0&&1),"automatic success has failed");
+static_assert(1&& -1,"automatic success has failed");
+static_assert(!(1&&0),"automatic success has failed");
+static_assert(1&&1,"automatic success has failed");
+
+static_assert(-1|| -1,"automatic success has failed");
+static_assert(-1||0,"automatic success has failed");
+static_assert(-1||1,"automatic success has failed");
+static_assert(0|| -1,"automatic success has failed");
+static_assert(!(0||0),"automatic success has failed");
+static_assert(0||1,"automatic success has failed");
+static_assert(1|| -1,"automatic success has failed");
+static_assert(1||0,"automatic success has failed");
+static_assert(1||1,"automatic success has failed");
+
+// check ? :
+static_assert(-1 ? -1 : -1,"automatic success has failed");
+static_assert(-1 ? -1 : 0,"automatic success has failed");
+static_assert(-1 ? -1 : 1,"automatic success has failed");
+static_assert(!(-1 ? 0 : -1),"automatic success has failed");
+static_assert(!(-1 ? 0 : 0),"automatic success has failed");
+static_assert(!(-1 ? 0 : 1),"automatic success has failed");
+static_assert(-1 ? 1 : -1,"automatic success has failed");
+static_assert(-1 ? 1 : 0,"automatic success has failed");
+static_assert(-1 ? 1 : 1,"automatic success has failed");
+static_assert(0 ? -1 : -1,"automatic success has failed");
+static_assert(!(0 ? -1 : 0),"automatic success has failed");
+static_assert(0 ? -1 : 1,"automatic success has failed");
+static_assert(0 ? 0 : -1,"automatic success has failed");
+static_assert(!(0 ? 0 : 0),"automatic success has failed");
+static_assert(0 ? 0 : 1,"automatic success has failed");
+static_assert(0 ? 1 : -1,"automatic success has failed");
+static_assert(!(0 ? 1 : 0),"automatic success has failed");
+static_assert(0 ? 1 : 1,"automatic success has failed");
+static_assert(1 ? -1 : -1,"automatic success has failed");
+static_assert(1 ? -1 : 0,"automatic success has failed");
+static_assert(1 ? -1 : 1,"automatic success has failed");
+static_assert(!(1 ? 0 : -1),"automatic success has failed");
+static_assert(!(1 ? 0 : 0),"automatic success has failed");
+static_assert(!(1 ? 0 : 1),"automatic success has failed");
+static_assert(1 ? 1 : -1,"automatic success has failed");
+static_assert(1 ? 1 : 0,"automatic success has failed");
+static_assert(1 ? 1 : 1,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-04-10 04:02:57 UTC (rev 370)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.h	2010-04-10 15:57:08 UTC (rev 371)
@@ -156,3 +156,53 @@
 _Static_Assert(one|zero,"automatic success has failed");
 _Static_Assert(one|one,"automatic success has failed");
 
+// check && ||
+_Static_Assert(neg_one&&neg_one,"automatic success has failed");
+_Static_Assert(!(neg_one&&zero),"automatic success has failed");
+_Static_Assert(neg_one&&one,"automatic success has failed");
+_Static_Assert(!(zero&&neg_one),"automatic success has failed");
+_Static_Assert(!(zero&&zero),"automatic success has failed");
+_Static_Assert(!(zero&&one),"automatic success has failed");
+_Static_Assert(one&&neg_one,"automatic success has failed");
+_Static_Assert(!(one&&zero),"automatic success has failed");
+_Static_Assert(one&&one,"automatic success has failed");
+
+_Static_Assert(neg_one||neg_one,"automatic success has failed");
+_Static_Assert(neg_one||zero,"automatic success has failed");
+_Static_Assert(neg_one||one,"automatic success has failed");
+_Static_Assert(zero||neg_one,"automatic success has failed");
+_Static_Assert(!(zero||zero),"automatic success has failed");
+_Static_Assert(zero||one,"automatic success has failed");
+_Static_Assert(one||neg_one,"automatic success has failed");
+_Static_Assert(one||zero,"automatic success has failed");
+_Static_Assert(one||one,"automatic success has failed");
+
+// check ? :
+_Static_Assert(neg_one ? neg_one : neg_one,"automatic success has failed");
+_Static_Assert(neg_one ? neg_one : zero,"automatic success has failed");
+_Static_Assert(neg_one ? neg_one : one,"automatic success has failed");
+_Static_Assert(!(neg_one ? zero : neg_one),"automatic success has failed");
+_Static_Assert(!(neg_one ? zero : zero),"automatic success has failed");
+_Static_Assert(!(neg_one ? zero : one),"automatic success has failed");
+_Static_Assert(neg_one ? one : neg_one,"automatic success has failed");
+_Static_Assert(neg_one ? one : zero,"automatic success has failed");
+_Static_Assert(neg_one ? one : one,"automatic success has failed");
+_Static_Assert(zero ? neg_one : neg_one,"automatic success has failed");
+_Static_Assert(!(zero ? neg_one : zero),"automatic success has failed");
+_Static_Assert(zero ? neg_one : one,"automatic success has failed");
+_Static_Assert(zero ? zero : neg_one,"automatic success has failed");
+_Static_Assert(!(zero ? zero : zero),"automatic success has failed");
+_Static_Assert(zero ? zero : one,"automatic success has failed");
+_Static_Assert(zero ? one : neg_one,"automatic success has failed");
+_Static_Assert(!(zero ? one : zero),"automatic success has failed");
+_Static_Assert(zero ? one : one,"automatic success has failed");
+_Static_Assert(one ? neg_one : neg_one,"automatic success has failed");
+_Static_Assert(one ? neg_one : zero,"automatic success has failed");
+_Static_Assert(one ? neg_one : one,"automatic success has failed");
+_Static_Assert(!(one ? zero : neg_one),"automatic success has failed");
+_Static_Assert(!(one ? zero : zero),"automatic success has failed");
+_Static_Assert(!(one ? zero : one),"automatic success has failed");
+_Static_Assert(one ? one : neg_one,"automatic success has failed");
+_Static_Assert(one ? one : zero,"automatic success has failed");
+_Static_Assert(one ? one : one,"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-04-10 04:02:57 UTC (rev 370)
+++ trunk/tests/zcc/staticassert.C1X/Pass_enum_autosuccess.hpp	2010-04-10 15:57:08 UTC (rev 371)
@@ -156,3 +156,53 @@
 static_assert(one|zero,"automatic success has failed");
 static_assert(one|one,"automatic success has failed");
 
+// check && ||
+static_assert(neg_one&&neg_one,"automatic success has failed");
+static_assert(!(neg_one&&zero),"automatic success has failed");
+static_assert(neg_one&&one,"automatic success has failed");
+static_assert(!(zero&&neg_one),"automatic success has failed");
+static_assert(!(zero&&zero),"automatic success has failed");
+static_assert(!(zero&&one),"automatic success has failed");
+static_assert(one&&neg_one,"automatic success has failed");
+static_assert(!(one&&zero),"automatic success has failed");
+static_assert(one&&one,"automatic success has failed");
+
+static_assert(neg_one||neg_one,"automatic success has failed");
+static_assert(neg_one||zero,"automatic success has failed");
+static_assert(neg_one||one,"automatic success has failed");
+static_assert(zero||neg_one,"automatic success has failed");
+static_assert(!(zero||zero),"automatic success has failed");
+static_assert(zero||one,"automatic success has failed");
+static_assert(one||neg_one,"automatic success has failed");
+static_assert(one||zero,"automatic success has failed");
+static_assert(one||one,"automatic success has failed");
+
+// check ? :
+static_assert(neg_one ? neg_one : neg_one,"automatic success has failed");
+static_assert(neg_one ? neg_one : zero,"automatic success has failed");
+static_assert(neg_one ? neg_one : one,"automatic success has failed");
+static_assert(!(neg_one ? zero : neg_one),"automatic success has failed");
+static_assert(!(neg_one ? zero : zero),"automatic success has failed");
+static_assert(!(neg_one ? zero : one),"automatic success has failed");
+static_assert(neg_one ? one : neg_one,"automatic success has failed");
+static_assert(neg_one ? one : zero,"automatic success has failed");
+static_assert(neg_one ? one : one,"automatic success has failed");
+static_assert(zero ? neg_one : neg_one,"automatic success has failed");
+static_assert(!(zero ? neg_one : zero),"automatic success has failed");
+static_assert(zero ? neg_one : one,"automatic success has failed");
+static_assert(zero ? zero : neg_one,"automatic success has failed");
+static_assert(!(zero ? zero : zero),"automatic success has failed");
+static_assert(zero ? zero : one,"automatic success has failed");
+static_assert(zero ? one : neg_one,"automatic success has failed");
+static_assert(!(zero ? one : zero),"automatic success has failed");
+static_assert(zero ? one : one,"automatic success has failed");
+static_assert(one ? neg_one : neg_one,"automatic success has failed");
+static_assert(one ? neg_one : zero,"automatic success has failed");
+static_assert(one ? neg_one : one,"automatic success has failed");
+static_assert(!(one ? zero : neg_one),"automatic success has failed");
+static_assert(!(one ? zero : zero),"automatic success has failed");
+static_assert(!(one ? zero : one),"automatic success has failed");
+static_assert(one ? one : neg_one,"automatic success has failed");
+static_assert(one ? one : zero,"automatic success has failed");
+static_assert(one ? one : one,"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-10 04:02:57 UTC (rev 370)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-10 15:57:08 UTC (rev 371)
@@ -162,3 +162,53 @@
 STATIC_ASSERT(1|0,"automatic success has failed");
 STATIC_ASSERT(1|1,"automatic success has failed");
 
+// check && ||
+STATIC_ASSERT(-1&& -1,"automatic success has failed");
+STATIC_ASSERT(!(-1&&0),"automatic success has failed");
+STATIC_ASSERT(-1&&1,"automatic success has failed");
+STATIC_ASSERT(!(0&& -1),"automatic success has failed");
+STATIC_ASSERT(!(0&&0),"automatic success has failed");
+STATIC_ASSERT(!(0&&1),"automatic success has failed");
+STATIC_ASSERT(1&& -1,"automatic success has failed");
+STATIC_ASSERT(!(1&&0),"automatic success has failed");
+STATIC_ASSERT(1&&1,"automatic success has failed");
+
+STATIC_ASSERT(-1|| -1,"automatic success has failed");
+STATIC_ASSERT(-1||0,"automatic success has failed");
+STATIC_ASSERT(-1||1,"automatic success has failed");
+STATIC_ASSERT(0|| -1,"automatic success has failed");
+STATIC_ASSERT(!(0||0),"automatic success has failed");
+STATIC_ASSERT(0||1,"automatic success has failed");
+STATIC_ASSERT(1|| -1,"automatic success has failed");
+STATIC_ASSERT(1||0,"automatic success has failed");
+STATIC_ASSERT(1||1,"automatic success has failed");
+
+// check ? :
+STATIC_ASSERT(-1 ? -1 : -1,"automatic success has failed");
+STATIC_ASSERT(-1 ? -1 : 0,"automatic success has failed");
+STATIC_ASSERT(-1 ? -1 : 1,"automatic success has failed");
+STATIC_ASSERT(!(-1 ? 0 : -1),"automatic success has failed");
+STATIC_ASSERT(!(-1 ? 0 : 0),"automatic success has failed");
+STATIC_ASSERT(!(-1 ? 0 : 1),"automatic success has failed");
+STATIC_ASSERT(-1 ? 1 : -1,"automatic success has failed");
+STATIC_ASSERT(-1 ? 1 : 0,"automatic success has failed");
+STATIC_ASSERT(-1 ? 1 : 1,"automatic success has failed");
+STATIC_ASSERT(0 ? -1 : -1,"automatic success has failed");
+STATIC_ASSERT(!(0 ? -1 : 0),"automatic success has failed");
+STATIC_ASSERT(0 ? -1 : 1,"automatic success has failed");
+STATIC_ASSERT(0 ? 0 : -1,"automatic success has failed");
+STATIC_ASSERT(!(0 ? 0 : 0),"automatic success has failed");
+STATIC_ASSERT(0 ? 0 : 1,"automatic success has failed");
+STATIC_ASSERT(0 ? 1 : -1,"automatic success has failed");
+STATIC_ASSERT(!(0 ? 1 : 0),"automatic success has failed");
+STATIC_ASSERT(0 ? 1 : 1,"automatic success has failed");
+STATIC_ASSERT(1 ? -1 : -1,"automatic success has failed");
+STATIC_ASSERT(1 ? -1 : 0,"automatic success has failed");
+STATIC_ASSERT(1 ? -1 : 1,"automatic success has failed");
+STATIC_ASSERT(!(1 ? 0 : -1),"automatic success has failed");
+STATIC_ASSERT(!(1 ? 0 : 0),"automatic success has failed");
+STATIC_ASSERT(!(1 ? 0 : 1),"automatic success has failed");
+STATIC_ASSERT(1 ? 1 : -1,"automatic success has failed");
+STATIC_ASSERT(1 ? 1 : 0,"automatic success has failed");
+STATIC_ASSERT(1 ? 1 : 1,"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-04-10 04:02:57 UTC (rev 370)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_enum_autosuccess.in	2010-04-10 15:57:08 UTC (rev 371)
@@ -157,3 +157,53 @@
 STATIC_ASSERT(one|zero,"automatic success has failed");
 STATIC_ASSERT(one|one,"automatic success has failed");
 
+// check && ||
+STATIC_ASSERT(neg_one&&neg_one,"automatic success has failed");
+STATIC_ASSERT(!(neg_one&&zero),"automatic success has failed");
+STATIC_ASSERT(neg_one&&one,"automatic success has failed");
+STATIC_ASSERT(!(zero&&neg_one),"automatic success has failed");
+STATIC_ASSERT(!(zero&&zero),"automatic success has failed");
+STATIC_ASSERT(!(zero&&one),"automatic success has failed");
+STATIC_ASSERT(one&&neg_one,"automatic success has failed");
+STATIC_ASSERT(!(one&&zero),"automatic success has failed");
+STATIC_ASSERT(one&&one,"automatic success has failed");
+
+STATIC_ASSERT(neg_one||neg_one,"automatic success has failed");
+STATIC_ASSERT(neg_one||zero,"automatic success has failed");
+STATIC_ASSERT(neg_one||one,"automatic success has failed");
+STATIC_ASSERT(zero||neg_one,"automatic success has failed");
+STATIC_ASSERT(!(zero||zero),"automatic success has failed");
+STATIC_ASSERT(zero||one,"automatic success has failed");
+STATIC_ASSERT(one||neg_one,"automatic success has failed");
+STATIC_ASSERT(one||zero,"automatic success has failed");
+STATIC_ASSERT(one||one,"automatic success has failed");
+
+// check ? :
+STATIC_ASSERT(neg_one ? neg_one : neg_one,"automatic success has failed");
+STATIC_ASSERT(neg_one ? neg_one : zero,"automatic success has failed");
+STATIC_ASSERT(neg_one ? neg_one : one,"automatic success has failed");
+STATIC_ASSERT(!(neg_one ? zero : neg_one),"automatic success has failed");
+STATIC_ASSERT(!(neg_one ? zero : zero),"automatic success has failed");
+STATIC_ASSERT(!(neg_one ? zero : one),"automatic success has failed");
+STATIC_ASSERT(neg_one ? one : neg_one,"automatic success has failed");
+STATIC_ASSERT(neg_one ? one : zero,"automatic success has failed");
+STATIC_ASSERT(neg_one ? one : one,"automatic success has failed");
+STATIC_ASSERT(zero ? neg_one : neg_one,"automatic success has failed");
+STATIC_ASSERT(!(zero ? neg_one : zero),"automatic success has failed");
+STATIC_ASSERT(zero ? neg_one : one,"automatic success has failed");
+STATIC_ASSERT(zero ? zero : neg_one,"automatic success has failed");
+STATIC_ASSERT(!(zero ? zero : zero),"automatic success has failed");
+STATIC_ASSERT(zero ? zero : one,"automatic success has failed");
+STATIC_ASSERT(zero ? one : neg_one,"automatic success has failed");
+STATIC_ASSERT(!(zero ? one : zero),"automatic success has failed");
+STATIC_ASSERT(zero ? one : one,"automatic success has failed");
+STATIC_ASSERT(one ? neg_one : neg_one,"automatic success has failed");
+STATIC_ASSERT(one ? neg_one : zero,"automatic success has failed");
+STATIC_ASSERT(one ? neg_one : one,"automatic success has failed");
+STATIC_ASSERT(!(one ? zero : neg_one),"automatic success has failed");
+STATIC_ASSERT(!(one ? zero : zero),"automatic success has failed");
+STATIC_ASSERT(!(one ? zero : one),"automatic success has failed");
+STATIC_ASSERT(one ? one : neg_one,"automatic success has failed");
+STATIC_ASSERT(one ? one : zero,"automatic success has failed");
+STATIC_ASSERT(one ? one : one,"automatic success has failed");
+



From zaimoni at mail.berlios.de  Sun Apr 11 00:57:54 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 11 Apr 2010 00:57:54 +0200
Subject: [Zcplusplus-commits] r372 - trunk
Message-ID: <201004102257.o3AMvsmc017260@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-11 00:57:48 +0200 (Sun, 11 Apr 2010)
New Revision: 372

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
preliminary support for sizeof operator

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-10 15:57:08 UTC (rev 371)
+++ trunk/CSupport.cpp	2010-04-10 22:57:48 UTC (rev 372)
@@ -622,7 +622,14 @@
 	assert(C_TYPE::INT<=base_type_index && C_TYPE::ULLONG>=base_type_index);
 	return (virtual_machine::std_int_enum)((base_type_index-C_TYPE::INT)/2+virtual_machine::std_int_int);
 }
+#/*cut-cpp*/
 
+static inline size_t unsigned_type_from_machine_type(virtual_machine::std_int_enum x)
+{
+	return C_TYPE::SCHAR+2*(x-virtual_machine::std_int_char)+1;
+}
+#/*cut-cpp*/
+
 #if 0
 static bool is_innate_type(size_t base_type_index)
 {
@@ -3575,6 +3582,7 @@
 #define C99_UNARY_SUBTYPE_ADDRESSOF 4
 #define C99_UNARY_SUBTYPE_NOT 5
 #define C99_UNARY_SUBTYPE_COMPL 6
+#define C99_UNARY_SUBTYPE_SIZEOF 7
 
 template<char c> static bool is_C99_unary_operator_expression(const parse_tree& src)
 {
@@ -3614,7 +3622,24 @@
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 //			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
 }
+#/*cut-cpp*/
 
+#ifndef NDEBUG
+static bool is_C99_CPP_sizeof_expression(const parse_tree& src)
+{
+	return		(robust_token_is_string<6>(src.index_tokens[0].token,"sizeof"))
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	src.empty<1>()
+			&&	1==src.size<2>() && ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
+//			&&	1==src.size<2>() && ((PARSE_UNARY_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
+}
+#endif
+#/*cut-cpp*/
+
 #define C99_MULT_SUBTYPE_DIV 1
 #define C99_MULT_SUBTYPE_MOD 2
 #define C99_MULT_SUBTYPE_MULT 3
@@ -6149,7 +6174,204 @@
 
 	return terse_locate_CPP_unary_plusminus(src,i,types);
 }
+#/*cut-cpp*/
 
+// handle C++0X sizeof... elsewhere (context-free syntax checks should be fixed first, possibly consider sizeof... a psuedo-identifier)
+static bool terse_locate_C99_CPP_sizeof(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"sizeof"))
+		{
+		assert(1<src.size<0>()-i);
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
+			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		if (   (PARSE_UNARY_EXPRESSION & src.data<0>()[i+1].flags)
+			|| (is_naked_parentheses_pair(src.data<0>()[i+1]) && (PARSE_TYPE & src.data<0>()[i+1].flags)))
+			{
+			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_SIZEOF);
+			src.c_array<0>()[i].type_code.set_type(unsigned_type_from_machine_type(target_machine->size_t_type()));
+			assert(is_C99_CPP_sizeof_expression(src.c_array<0>()[i]));
+			return true;			
+			}
+		}
+	return false;
+}
+
+static bool eval_sizeof_core_type(parse_tree& src,const size_t base_type_index,const type_system& types)
+{	//! \todo eventually handle the floating and complex types here as well
+	//! \todo types parameter is close to redundant
+	// floating is just a matter of modeling
+	// complex may also involve ABI issues (cf. Intel)
+	parse_tree tmp;
+	switch(base_type_index)
+	{
+	default: return false;
+	case C_TYPE::CHAR:
+	case C_TYPE::SCHAR:
+	case C_TYPE::UCHAR:
+		{	// defined to be 1: C99 6.5.3.4p3, C++98 5.3.3p1, same paragraphs in C1X and C++0X 
+		src.destroy();
+		src.index_tokens[0].token.first = "1";
+		src.index_tokens[0].token.second = 1;
+		src.index_tokens[0].flags = (C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_INTEGER | C_TESTFLAG_DECIMAL);
+		}	
+	case C_TYPE::SHRT:
+	case C_TYPE::USHRT:
+		{
+		if (!VM_to_literal(tmp,umaxint(target_machine->C_sizeof_short()),src,types)) return false;
+		src.destroy();
+		src = tmp;			
+		}
+	case C_TYPE::INT:
+	case C_TYPE::UINT:
+		{
+		if (!VM_to_literal(tmp,umaxint(target_machine->C_sizeof_int()),src,types)) return false;
+		src.destroy();
+		src = tmp;			
+		}
+	case C_TYPE::LONG:
+	case C_TYPE::ULONG:
+		{
+		if (!VM_to_literal(tmp,umaxint(target_machine->C_sizeof_long()),src,types)) return false;
+		src.destroy();
+		src = tmp;			
+		}
+	case C_TYPE::LLONG:
+	case C_TYPE::ULLONG:
+		{
+		if (!VM_to_literal(tmp,umaxint(target_machine->C_sizeof_long_long()),src,types)) return false;
+		src.destroy();
+		src = tmp;			
+		}
+	}
+#if 0
+	FLOAT,
+	DOUBLE,
+	LDOUBLE,
+	FLOAT__COMPLEX,
+	DOUBLE__COMPLEX,
+	LDOUBLE__COMPLEX,
+#endif
+	src.type_code.set_type(unsigned_type_from_machine_type(target_machine->size_t_type()));
+	return true;
+}
+
+static bool eval_C99_CPP_sizeof(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_CPP_sizeof_expression(src));
+	if (0==src.data<2>()->type_code.pointer_power_after_array_decay())
+		{
+		if (eval_sizeof_core_type(src,src.data<2>()->type_code.base_type_index,types)) return true;
+		}
+	return false;
+}
+
+static bool eval_C99_sizeof(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_CPP_sizeof_expression(src));
+	if (eval_C99_CPP_sizeof(src,types)) return true;
+	if (0==src.data<2>()->type_code.pointer_power_after_array_decay())
+		{
+		const enum_def* const tmp = types.get_enum_def(src.data<2>()->type_code.base_type_index);
+		if (tmp)
+			{
+			if (is_noticed_enumerator(src,types))
+				return eval_sizeof_core_type(src,C_TYPE::INT,types); // type is int per C99 6.7.2.2p3
+			if (!tmp->represent_as)
+				{
+				simple_error(src," applies sizeof to incomplete enumeration (C99 6.5.3.4p1)");
+				return false;
+				}
+			// process tmp->represent_as as a core type
+			// C99 6.7.2.2p4 merely requires the underlying type to be able to represent all values
+			assert(C_TYPE::CHAR<=tmp->represent_as && C_TYPE::INT>=tmp->represent_as);
+			return eval_sizeof_core_type(src,tmp->represent_as,types);
+			}
+		}
+	return false;
+}
+
+static bool eval_CPP_sizeof(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_CPP_sizeof_expression(src));
+	if (eval_C99_CPP_sizeof(src,types)) return true;
+	if (0==src.data<2>()->type_code.pointer_power_after_array_decay())
+		{
+		if (C_TYPE::WCHAR_T==src.data<2>()->type_code.base_type_index)
+			return eval_sizeof_core_type(src,unsigned_type_from_machine_type(target_machine->UNICODE_wchar_t()),types);
+		const enum_def* const tmp = types.get_enum_def(src.data<2>()->type_code.base_type_index);
+		if (tmp)
+			{
+			if (is_noticed_enumerator(*src.data<2>(),types))
+				{
+				const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.data<2>()->index_tokens[0].token.first);
+				assert(tmp2);
+				assert(C_TYPE::INT<=tmp2->second.first.second && C_TYPE::ULLONG>=tmp2->second.first.second);
+				return eval_sizeof_core_type(src,tmp2->second.first.second,types);
+				}
+			if (!tmp->represent_as)
+				{
+				simple_error(src," applies sizeof to incomplete enumeration (C++98 5.3.3p1)");
+				return false;
+				}
+			// C++0X 7.2p6 merely requires the underlying type to be able to represent all values
+			assert(C_TYPE::CHAR<=tmp->represent_as && C_TYPE::ULLONG>=tmp->represent_as);
+			return eval_sizeof_core_type(src,tmp->represent_as,types);
+			}
+		}
+	return false;
+}
+
+static void C99_sizeof_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_CPP_sizeof_expression(src));
+	//! \todo intercept incomplete types, function types here
+	if (eval_C99_sizeof(src,types)) return;
+}
+
+static void CPP_sizeof_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_CPP_sizeof_expression(src));
+	//! \todo intercept incomplete types, function types here
+	if (eval_CPP_sizeof(src,types)) return;
+}
+
+static bool locate_C99_sizeof(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+
+	if (	!(PARSE_OBVIOUS & src.data<0>()[i].flags)
+		&&	src.data<0>()[i].is_atomic()
+		&&	terse_locate_C99_CPP_sizeof(src,i,types))
+		{
+		C99_sizeof_easy_syntax_check(src.c_array<0>()[i],types);
+		return true;
+		}
+	return false;
+}
+
+static bool locate_CPP_sizeof(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+
+	if (	!(PARSE_OBVIOUS & src.data<0>()[i].flags)
+		&&	src.data<0>()[i].is_atomic()
+		&&	terse_locate_C99_CPP_sizeof(src,i,types))
+		{
+		CPP_sizeof_easy_syntax_check(src.c_array<0>()[i],types);
+		return true;
+		}
+	return false;
+}
+#/*cut-cpp*/
+
 /* Scan for unary operators and cast expressions
 unary-expression:
 	postfix-expression
@@ -6179,6 +6401,9 @@
 	if (locate_C99_logical_NOT(src,i,types)) return;
 	if (locate_C99_bitwise_complement(src,i,types)) return;
 	if (locate_C99_unary_plusminus(src,i,types)) return;
+#/*cut-cpp*/
+	if (locate_C99_sizeof(src,i,types)) return;
+#/*cut-cpp*/
 
 #if 0
 	if (terse_locate_unary_operator(src,i))
@@ -6192,9 +6417,6 @@
 	else if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"--"))
 		{
 		}
-	else if (token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"sizeof"))
-		{
-		}
 	else if (   token_is_char<'('>(src.data<0>()[i].index_tokens[0].token)
 			 && token_is_char<')'>(src.data<0>()[i].index_tokens[1].token))
 		{
@@ -6258,6 +6480,9 @@
 	if (locate_CPP_logical_NOT(src,i,types)) return;
 	if (locate_CPP_bitwise_complement(src,i,types)) return;
 	if (locate_CPP_unary_plusminus(src,i,types)) return;
+#/*cut-cpp*/
+	if (locate_CPP_sizeof(src,i,types)) return;
+#/*cut-cpp*/
 
 #if 0
 	if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"++"))
@@ -6266,9 +6491,6 @@
 	else if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"--"))
 		{
 		}
-	else if (token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"sizeof"))
-		{
-		}
 	else if (   token_is_char<'('>(src.data<0>()[i].index_tokens[0].token)
 			 && token_is_char<')'>(src.data<0>()[i].index_tokens[1].token))
 		{

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-04-10 15:57:08 UTC (rev 371)
+++ trunk/CSupport_pp.cpp	2010-04-10 22:57:48 UTC (rev 372)
@@ -3468,6 +3468,7 @@
 #define C99_UNARY_SUBTYPE_ADDRESSOF 4
 #define C99_UNARY_SUBTYPE_NOT 5
 #define C99_UNARY_SUBTYPE_COMPL 6
+#define C99_UNARY_SUBTYPE_SIZEOF 7
 
 template<char c> static bool is_C99_unary_operator_expression(const parse_tree& src)
 {
@@ -5672,9 +5673,6 @@
 	else if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"--"))
 		{
 		}
-	else if (token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"sizeof"))
-		{
-		}
 	else if (   token_is_char<'('>(src.data<0>()[i].index_tokens[0].token)
 			 && token_is_char<')'>(src.data<0>()[i].index_tokens[1].token))
 		{
@@ -5746,9 +5744,6 @@
 	else if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"--"))
 		{
 		}
-	else if (token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"sizeof"))
-		{
-		}
 	else if (   token_is_char<'('>(src.data<0>()[i].index_tokens[0].token)
 			 && token_is_char<')'>(src.data<0>()[i].index_tokens[1].token))
 		{



From zaimoni at mail.berlios.de  Sun Apr 11 04:39:35 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 11 Apr 2010 04:39:35 +0200
Subject: [Zcplusplus-commits] r373 - trunk
Message-ID: <201004110239.o3B2dZX7015073@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-11 04:39:30 +0200 (Sun, 11 Apr 2010)
New Revision: 373

Modified:
   trunk/Flat_UNI.cpp
   trunk/unsigned_fixed_int.hpp
   trunk/unsigned_var_int.cpp
   trunk/unsigned_var_int.hpp
Log:
minor code cleanup; fix theoretical out-of-bounds access in FlattenUNICODE

Modified: trunk/Flat_UNI.cpp
===================================================================
--- trunk/Flat_UNI.cpp	2010-04-10 22:57:48 UTC (rev 372)
+++ trunk/Flat_UNI.cpp	2010-04-11 02:39:30 UTC (rev 373)
@@ -27,8 +27,7 @@
 [also see Appendix E for a validation list...probably should update against latest UNICODE references]
 */
 
-bool
-FlattenUNICODE(char*& Text)
+bool FlattenUNICODE(char*& Text)
 {
 	if (NULL==Text) return true;
 
@@ -39,50 +38,50 @@
 	size_t TextLength = Text_len++;
 #endif
 	bool want_realloc = false;
-	if (10<=TextLength)
+	// full encoding
+	char* bloat_unicode = strstr(Text,"\\U0000");
+	if (bloat_unicode && 10>TextLength-(bloat_unicode-Text)) bloat_unicode = NULL;
+	while(NULL!=bloat_unicode)
 		{
-		char* bloat_unicode = strstr(Text,"\\U0000");
-		while(NULL!=bloat_unicode)
+		if (4<=strspn(bloat_unicode+6,C_HEXADECIMAL_DIGITS))
 			{
-			if (4<=strspn(bloat_unicode+6,C_HEXADECIMAL_DIGITS))
-				{
-				const size_t block_length = bloat_unicode-Text+2;
-				bloat_unicode[1] = 'u';
-				TextLength -= 4;
-				if (block_length<TextLength)
-					memmove(bloat_unicode+2,bloat_unicode+6,(TextLength-block_length));
-				memset(Text+TextLength,0,4);
-				want_realloc = true;
-				}
-			bloat_unicode += 6;
-			bloat_unicode = ((bloat_unicode-Text)+10U>TextLength) ? NULL : strstr(bloat_unicode,"\\U0000");
+			const size_t block_length = bloat_unicode-Text+2;
+			bloat_unicode[1] = 'u';
+			TextLength -= 4;
+			if (block_length<TextLength)
+				memmove(bloat_unicode+2,bloat_unicode+6,(TextLength-block_length));
+			memset(Text+TextLength,0,4);
+			want_realloc = true;
 			}
+		bloat_unicode += 6;
+		bloat_unicode = strstr(bloat_unicode,"\\U0000");
+		if (bloat_unicode && 10>TextLength-(bloat_unicode-Text)) bloat_unicode = NULL;
 		}
-	if (6<=TextLength)
-		{
-		char* bloat_unicode = strstr(Text,"\\u00");
-		while(NULL!=bloat_unicode)
-			{	// we down-convert a subset of allowed characters, excluding anything lower than ASCII space to avoid real weirdness
-				//! \todo portability target: want to adapt to preprocessor CHAR_BIT/UCHAR_MAX, this assumes 8/255; also assumes ASCII
-				// we restrict our attention here to the utterly safe \u00A0 - \u00FF conversion
-			if (strchr(C_HEXADECIMAL_DIGITS+10,bloat_unicode[4]) && strchr(C_HEXADECIMAL_DIGITS,bloat_unicode[5]))
-				{
-				const size_t block_length = bloat_unicode-Text+1;
-				const unsigned char tmp = (unsigned char)(16*InterpretHexadecimalDigit(bloat_unicode[4]+InterpretHexadecimalDigit(bloat_unicode[5])));
-				assert(160<=tmp);
-				bloat_unicode[0] = tmp;
-				TextLength -= 5;
-				if (block_length<TextLength)
-					memmove(bloat_unicode+1,bloat_unicode+6,(TextLength-block_length));
-				memset(Text+TextLength,0,5);
-				want_realloc = true;
-				++bloat_unicode;
-				}
-			else
-				bloat_unicode += 4;
-
-			bloat_unicode = ((bloat_unicode-Text)+6U>TextLength) ? NULL : strstr(bloat_unicode,"\\u00");
+	
+	bloat_unicode = strstr(Text,"\\u00");
+	if (bloat_unicode && 6>TextLength-(bloat_unicode-Text)) bloat_unicode = NULL;
+	while(NULL!=bloat_unicode)
+		{	// we down-convert a subset of allowed characters, excluding anything lower than ASCII space to avoid real weirdness
+			//! \todo portability target: want to adapt to preprocessor CHAR_BIT/UCHAR_MAX, this assumes 8/255; also assumes ASCII
+			// we restrict our attention here to the utterly safe \u00A0 - \u00FF conversion
+		if (strchr(C_HEXADECIMAL_DIGITS+10,bloat_unicode[4]) && strchr(C_HEXADECIMAL_DIGITS,bloat_unicode[5]))
+			{
+			const size_t block_length = bloat_unicode-Text+1;
+			const unsigned char tmp = (unsigned char)(16*InterpretHexadecimalDigit(bloat_unicode[4]+InterpretHexadecimalDigit(bloat_unicode[5])));
+			assert(160<=tmp);
+			bloat_unicode[0] = tmp;
+			TextLength -= 5;
+			if (block_length<TextLength)
+				memmove(bloat_unicode+1,bloat_unicode+6,(TextLength-block_length));
+			memset(Text+TextLength,0,5);
+			want_realloc = true;
+			++bloat_unicode;
 			}
+		else
+			bloat_unicode += 4;
+
+		bloat_unicode = strstr(bloat_unicode,"\\u00");
+		if (bloat_unicode && 6>TextLength-(bloat_unicode-Text)) bloat_unicode = NULL;
 		}
 #ifndef ZAIMONI_FORCE_ISO
 	if (want_realloc) _shrink(Text,TextLength);

Modified: trunk/unsigned_fixed_int.hpp
===================================================================
--- trunk/unsigned_fixed_int.hpp	2010-04-10 22:57:48 UTC (rev 372)
+++ trunk/unsigned_fixed_int.hpp	2010-04-11 02:39:30 UTC (rev 373)
@@ -23,21 +23,21 @@
 	_unsigned_fixed_charint& operator=(uintmax_t src);
 	_unsigned_fixed_charint& operator~() {bitwise_compl(_x,N); return *this;};
 	void auto_bitwise_complement() {bitwise_compl(_x,N);};
-	_unsigned_fixed_charint& operator+=(const _unsigned_fixed_charint& RHS) {unsigned_sum(_x,N,RHS._x); return *this;};
-	_unsigned_fixed_charint& operator+=(uintmax_t RHS) {unsigned_sum(_x,N,RHS); return *this;};
-	_unsigned_fixed_charint& operator-=(const _unsigned_fixed_charint& RHS) {unsigned_diff(_x,N,RHS._x); return *this;};
-	_unsigned_fixed_charint& operator-=(uintmax_t RHS) {unsigned_diff(_x,N,RHS); return *this;};
-	_unsigned_fixed_charint& operator*=(const _unsigned_fixed_charint& RHS);
-	_unsigned_fixed_charint& operator&=(const _unsigned_fixed_charint& RHS) {bitwise_and(_x,N,RHS._x); return *this;};
-	_unsigned_fixed_charint& operator^=(const _unsigned_fixed_charint& RHS) {bitwise_xor(_x,N,RHS._x); return *this;};
-	_unsigned_fixed_charint& operator|=(const _unsigned_fixed_charint& RHS) {bitwise_or(_x,N,RHS._x); return *this;};
-	_unsigned_fixed_charint& operator>>=(uintmax_t RHS) {unsigned_right_shift(_x,N,RHS); return *this;};
-	_unsigned_fixed_charint& operator<<=(uintmax_t RHS) {unsigned_left_shift(_x,N,RHS); return *this;};
+	_unsigned_fixed_charint& operator+=(const _unsigned_fixed_charint& rhs) {unsigned_sum(_x,N,rhs._x); return *this;};
+	_unsigned_fixed_charint& operator+=(uintmax_t rhs) {unsigned_sum(_x,N,rhs); return *this;};
+	_unsigned_fixed_charint& operator-=(const _unsigned_fixed_charint& rhs) {unsigned_diff(_x,N,rhs._x); return *this;};
+	_unsigned_fixed_charint& operator-=(uintmax_t rhs) {unsigned_diff(_x,N,rhs); return *this;};
+	_unsigned_fixed_charint& operator*=(const _unsigned_fixed_charint& rhs);
+	_unsigned_fixed_charint& operator&=(const _unsigned_fixed_charint& rhs) {bitwise_and(_x,N,rhs._x); return *this;};
+	_unsigned_fixed_charint& operator^=(const _unsigned_fixed_charint& rhs) {bitwise_xor(_x,N,rhs._x); return *this;};
+	_unsigned_fixed_charint& operator|=(const _unsigned_fixed_charint& rhs) {bitwise_or(_x,N,rhs._x); return *this;};
+	_unsigned_fixed_charint& operator>>=(uintmax_t rhs) {unsigned_right_shift(_x,N,rhs); return *this;};
+	_unsigned_fixed_charint& operator<<=(uintmax_t rhs) {unsigned_left_shift(_x,N,rhs); return *this;};
 
 	void div_op(const _unsigned_fixed_charint& divisor, _unsigned_fixed_charint& quotient) {remainder_quotient<N>(c_array(),divisor.data(),quotient.c_array());};
 
-	_unsigned_fixed_charint& operator/=(const _unsigned_fixed_charint& RHS);
-	_unsigned_fixed_charint& operator%=(const _unsigned_fixed_charint& RHS);
+	_unsigned_fixed_charint& operator/=(const _unsigned_fixed_charint& rhs);
+	_unsigned_fixed_charint& operator%=(const _unsigned_fixed_charint& rhs);
 
 	unsigned int int_log2() const {return ::int_log2(_x,N);};
 
@@ -171,112 +171,112 @@
 }
 
 template<size_t N>
-_unsigned_fixed_charint<N> operator+(const _unsigned_fixed_charint<N>& LHS,const _unsigned_fixed_charint<N>& RHS)
+_unsigned_fixed_charint<N> operator+(const _unsigned_fixed_charint<N>& lhs,const _unsigned_fixed_charint<N>& rhs)
 {
-	_unsigned_fixed_charint<N> tmp(LHS);
-	tmp += RHS;
+	_unsigned_fixed_charint<N> tmp(lhs);
+	tmp += rhs;
 	return tmp;
 }
 
 template<size_t N>
-_unsigned_fixed_charint<N> operator-(const _unsigned_fixed_charint<N>& LHS,const _unsigned_fixed_charint<N>& RHS)
+_unsigned_fixed_charint<N> operator-(const _unsigned_fixed_charint<N>& lhs,const _unsigned_fixed_charint<N>& rhs)
 {
-	_unsigned_fixed_charint<N> tmp(LHS);
-	tmp -= RHS;
+	_unsigned_fixed_charint<N> tmp(lhs);
+	tmp -= rhs;
 	return tmp;
 }
 
 template<size_t N>
 _unsigned_fixed_charint<N>&
-_unsigned_fixed_charint<N>::operator*=(const _unsigned_fixed_charint<N>& RHS)
+_unsigned_fixed_charint<N>::operator*=(const _unsigned_fixed_charint<N>& rhs)
 {
 	_unsigned_fixed_charint<N> tmp;
-	unsigned_mult(tmp._x,N,_x,N,RHS._x,N);
+	unsigned_mult(tmp._x,N,_x,N,rhs._x,N);
 	return *this = tmp;
 }
 
 template<size_t N>
 _unsigned_fixed_charint<N>
-operator/(_unsigned_fixed_charint<N> LHS,const _unsigned_fixed_charint<N>& RHS)
+operator/(_unsigned_fixed_charint<N> lhs,const _unsigned_fixed_charint<N>& rhs)
 {
 	_unsigned_fixed_charint<N> quotient;
-	LHS.div_op(RHS,quotient);
+	lhs.div_op(rhs,quotient);
 	return quotient;
 }
 
 
 template<size_t N>
 _unsigned_fixed_charint<N>&
-_unsigned_fixed_charint<N>::operator/=(const _unsigned_fixed_charint<N>& RHS)
+_unsigned_fixed_charint<N>::operator/=(const _unsigned_fixed_charint<N>& rhs)
 {
 	_unsigned_fixed_charint<N> quotient;
-	div_op(RHS,quotient);
+	div_op(rhs,quotient);
 	return *this = quotient;
 }
 
 template<size_t N>
 _unsigned_fixed_charint<N>&
-_unsigned_fixed_charint<N>::operator%=(const _unsigned_fixed_charint<N>& RHS)
+_unsigned_fixed_charint<N>::operator%=(const _unsigned_fixed_charint<N>& rhs)
 {
 	_unsigned_fixed_charint<N> quotient;
-	div_op(RHS,quotient);
+	div_op(rhs,quotient);
 	return *this;
 }
 
 // comparison operators
 template<size_t N> inline
-bool operator==(const _unsigned_fixed_charint<N>& LHS, const _unsigned_fixed_charint<N>& RHS) {return 0==unsigned_cmp(LHS._x,N,RHS._x);}
+bool operator==(const _unsigned_fixed_charint<N>& lhs, const _unsigned_fixed_charint<N>& rhs) {return 0==unsigned_cmp(lhs._x,N,rhs._x);}
 
 template<size_t N> inline
-bool operator==(const _unsigned_fixed_charint<N>& LHS, uintmax_t RHS) {return 0==unsigned_cmp(LHS._x,N,RHS);}
+bool operator==(const _unsigned_fixed_charint<N>& lhs, uintmax_t rhs) {return 0==unsigned_cmp(lhs._x,N,rhs);}
 
 template<size_t N> inline
-bool operator==(const uintmax_t LHS, const _unsigned_fixed_charint<N>& RHS) {return 0==unsigned_cmp(RHS._x,N,LHS);}
+bool operator==(const uintmax_t lhs, const _unsigned_fixed_charint<N>& rhs) {return 0==unsigned_cmp(rhs._x,N,lhs);}
 
 template<size_t N> inline
-bool operator!=(const _unsigned_fixed_charint<N>& LHS, const _unsigned_fixed_charint<N>& RHS) {return 0!=unsigned_cmp(LHS._x,N,RHS._x);}
+bool operator!=(const _unsigned_fixed_charint<N>& lhs, const _unsigned_fixed_charint<N>& rhs) {return 0!=unsigned_cmp(lhs._x,N,rhs._x);}
 
 template<size_t N> inline
-bool operator!=(const _unsigned_fixed_charint<N>& LHS, uintmax_t RHS) {return 0==unsigned_cmp(LHS._x,N,RHS);}
+bool operator!=(const _unsigned_fixed_charint<N>& lhs, uintmax_t rhs) {return 0==unsigned_cmp(lhs._x,N,rhs);}
 
 template<size_t N> inline
-bool operator!=(const uintmax_t LHS, const _unsigned_fixed_charint<N>& RHS) {return 0==unsigned_cmp(RHS._x,N,LHS);}
+bool operator!=(const uintmax_t lhs, const _unsigned_fixed_charint<N>& rhs) {return 0==unsigned_cmp(rhs._x,N,lhs);}
 
 template<size_t N> inline
-bool operator<(const _unsigned_fixed_charint<N>& LHS, const _unsigned_fixed_charint<N>& RHS) {return -1==unsigned_cmp(LHS._x,N,RHS._x);}
+bool operator<(const _unsigned_fixed_charint<N>& lhs, const _unsigned_fixed_charint<N>& rhs) {return -1==unsigned_cmp(lhs._x,N,rhs._x);}
 
 template<size_t N> inline
-bool operator<(const _unsigned_fixed_charint<N>& LHS, uintmax_t RHS) {return -1==unsigned_cmp(LHS._x,N,RHS);}
+bool operator<(const _unsigned_fixed_charint<N>& lhs, uintmax_t rhs) {return -1==unsigned_cmp(lhs._x,N,rhs);}
 
 template<size_t N> inline
-bool operator<(const uintmax_t LHS, const _unsigned_fixed_charint<N>& RHS) {return 1==unsigned_cmp(RHS._x,N,LHS);}
+bool operator<(const uintmax_t lhs, const _unsigned_fixed_charint<N>& rhs) {return 1==unsigned_cmp(rhs._x,N,lhs);}
 
 template<size_t N> inline
-bool operator>(const _unsigned_fixed_charint<N>& LHS, const _unsigned_fixed_charint<N>& RHS) {return 1==unsigned_cmp(LHS._x,N,RHS._x);}
+bool operator>(const _unsigned_fixed_charint<N>& lhs, const _unsigned_fixed_charint<N>& rhs) {return 1==unsigned_cmp(lhs._x,N,rhs._x);}
 
 template<size_t N> inline
-bool operator>(const _unsigned_fixed_charint<N>& LHS, uintmax_t RHS) {return 1==unsigned_cmp(LHS._x,N,RHS);}
+bool operator>(const _unsigned_fixed_charint<N>& lhs, uintmax_t rhs) {return 1==unsigned_cmp(lhs._x,N,rhs);}
 
 template<size_t N> inline
-bool operator>(const uintmax_t LHS, const _unsigned_fixed_charint<N>& RHS) {return -1==unsigned_cmp(RHS._x,N,LHS);}
+bool operator>(const uintmax_t lhs, const _unsigned_fixed_charint<N>& rhs) {return -1==unsigned_cmp(rhs._x,N,lhs);}
 
 template<size_t N> inline
-bool operator<=(const _unsigned_fixed_charint<N>& LHS, const _unsigned_fixed_charint<N>& RHS) {return 0>=unsigned_cmp(LHS._x,N,RHS._x);}
+bool operator<=(const _unsigned_fixed_charint<N>& lhs, const _unsigned_fixed_charint<N>& rhs) {return 0>=unsigned_cmp(lhs._x,N,rhs._x);}
 
 template<size_t N> inline
-bool operator<=(const _unsigned_fixed_charint<N>& LHS, uintmax_t RHS) {return 0>=unsigned_cmp(LHS._x,N,RHS);}
+bool operator<=(const _unsigned_fixed_charint<N>& lhs, uintmax_t rhs) {return 0>=unsigned_cmp(lhs._x,N,rhs);}
 
 template<size_t N> inline
-bool operator<=(const uintmax_t LHS, const _unsigned_fixed_charint<N>& RHS) {return 0<=unsigned_cmp(RHS._x,N,LHS);}
+bool operator<=(const uintmax_t lhs, const _unsigned_fixed_charint<N>& rhs) {return 0<=unsigned_cmp(rhs._x,N,lhs);}
 
 template<size_t N> inline
-bool operator>=(const _unsigned_fixed_charint<N>& LHS, const _unsigned_fixed_charint<N>& RHS) {return 0<=unsigned_cmp(LHS._x,N,RHS._x);}
+bool operator>=(const _unsigned_fixed_charint<N>& lhs, const _unsigned_fixed_charint<N>& rhs) {return 0<=unsigned_cmp(lhs._x,N,rhs._x);}
 
 template<size_t N> inline
-bool operator>=(const _unsigned_fixed_charint<N>& LHS, uintmax_t RHS) {return 0<=unsigned_cmp(LHS._x,N,RHS);}
+bool operator>=(const _unsigned_fixed_charint<N>& lhs, uintmax_t rhs) {return 0<=unsigned_cmp(lhs._x,N,rhs);}
 
 template<size_t N> inline
-bool operator>=(const uintmax_t LHS, const _unsigned_fixed_charint<N>& RHS) {return 0>=unsigned_cmp(RHS._x,N,LHS);}
+bool operator>=(const uintmax_t lhs, const _unsigned_fixed_charint<N>& rhs) {return 0>=unsigned_cmp(rhs._x,N,lhs);}
 
 template<size_t N>
 char* z_ucharint_toa(_unsigned_fixed_charint<N> target,char* const buf,unsigned int radix)

Modified: trunk/unsigned_var_int.cpp
===================================================================
--- trunk/unsigned_var_int.cpp	2010-04-10 22:57:48 UTC (rev 372)
+++ trunk/unsigned_var_int.cpp	2010-04-11 02:39:30 UTC (rev 373)
@@ -126,19 +126,13 @@
 
 unsigned_var_int& unsigned_var_int::operator^=(const unsigned_var_int& rhs)
 {
-	if (size()<=rhs.size())
-		bitwise_xor(c_array(),size(),rhs.data());
-	else
-		bitwise_xor(c_array(),rhs.size(),rhs.data());
+	bitwise_xor(c_array(),size()<=rhs.size() ? size() : rhs.size(),rhs.data());
 	return *this;
 }
 
 unsigned_var_int& unsigned_var_int::operator|=(const unsigned_var_int& rhs)
 {
-	if (size()<=rhs.size())
-		bitwise_or(c_array(),size(),rhs.data());
-	else
-		bitwise_or(c_array(),rhs.size(),rhs.data());
+	bitwise_or(c_array(),size()<=rhs.size() ? size() : rhs.size(),rhs.data());
 	return *this;
 }
 

Modified: trunk/unsigned_var_int.hpp
===================================================================
--- trunk/unsigned_var_int.hpp	2010-04-10 22:57:48 UTC (rev 372)
+++ trunk/unsigned_var_int.hpp	2010-04-11 02:39:30 UTC (rev 373)
@@ -81,9 +81,8 @@
 	bool representable_as_uint() const
 		{	//! \todo remove assumption host has no padding bits in uintmax_t
 		size_t i = _data.size();
-		if (sizeof(uintmax_t)>=i) return true;
-		do	if ((unsigned char)('\0')!=_data.data()[--i]) return false;
-		while(sizeof(uintmax_t)<i);
+		while(sizeof(uintmax_t)<i)
+			if (_data.data()[--i]) return false;
 		return true;
 		};
 



From zaimoni at mail.berlios.de  Sun Apr 11 19:46:38 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 11 Apr 2010 19:46:38 +0200
Subject: [Zcplusplus-commits] r374 - in trunk: . Zaimoni.STL
Message-ID: <201004111746.o3BHkcNh001758@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-11 19:46:31 +0200 (Sun, 11 Apr 2010)
New Revision: 374

Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc_pp.cpp
   trunk/POSIX.dep
   trunk/ParseTree.cpp
   trunk/Zaimoni.STL/MetaRAM2.hpp
   trunk/unsigned_aux.cpp
   trunk/z_cpp.cpp
   trunk/zcc.cpp
Log:
version configuration centralization, and other minor code cleanup

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2010-04-11 02:39:30 UTC (rev 373)
+++ trunk/CPreproc.cpp	2010-04-11 17:46:31 UTC (rev 374)
@@ -26,6 +26,7 @@
 #include "ParseTree.hpp"
 #include "type_system.hpp"
 #include "weak_token.hpp"
+#include "_version.h"
 #include "Zaimoni.STL/POD.hpp"
 #include "Zaimoni.STL/LexParse/Token.hpp"
 #include "Zaimoni.STL/LexParse/LangConf.hpp"
@@ -42,10 +43,6 @@
 #define WARN_STR "warning: "
 
 #define INSTALL_TO "\\CPP_App\\Z.C++"
-#define ZCC_VERSION "0.0.3"
-#define ZCC_VERSION_MAJOR 0
-#define ZCC_VERSION_MINOR 0
-#define ZCC_VERSION_PATCH 3
 
 //! \todo this should be language-sensitive; LangConf not a good location
 static const char* const fixed_system_include_search[] = {

Modified: trunk/CPreproc_pp.cpp
===================================================================
--- trunk/CPreproc_pp.cpp	2010-04-11 02:39:30 UTC (rev 373)
+++ trunk/CPreproc_pp.cpp	2010-04-11 17:46:31 UTC (rev 374)
@@ -20,6 +20,7 @@
 #include "ParseTree.hpp"
 #include "type_system.hpp"
 #include "weak_token.hpp"
+#include "_version.h"
 #include "Zaimoni.STL/POD.hpp"
 #include "Zaimoni.STL/LexParse/Token.hpp"
 #include "Zaimoni.STL/LexParse/LangConf.hpp"
@@ -36,10 +37,6 @@
 #define WARN_STR "warning: "
 
 #define INSTALL_TO "\\CPP_App\\Z.C++"
-#define ZCC_VERSION "0.0.3"
-#define ZCC_VERSION_MAJOR 0
-#define ZCC_VERSION_MINOR 0
-#define ZCC_VERSION_PATCH 3
 
 //! \todo this should be language-sensitive; LangConf not a good location
 static const char* const fixed_system_include_search[] = {

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-04-11 02:39:30 UTC (rev 373)
+++ trunk/POSIX.dep	2010-04-11 17:46:31 UTC (rev 374)
@@ -1,11 +1,11 @@
 OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
-OBJECTS_Z_CPP_LINK_PRIORITY = z_cpp.o CPreproc_autogen_pp.o CSupport_pp.o CPreproc_pp.o Flat_UNI.o langroute.o lex_core.o C_PPHexInteger.o CPUInfo.o AtomicString.o ParseTree.o type_system.o errors.o unsigned_var_int.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
+OBJECTS_Z_CPP_LINK_PRIORITY = CPreproc_pp.o z_cpp.o unsigned_aux.o ParseTree.o Flat_UNI.o unsigned_var_int.o CSupport_pp.o type_system.o CPUInfo.o CPreproc_autogen_pp.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o errors.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
 
 OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = CPreproc.o CSupport.o Flat_UNI.o zcc.o langroute.o lex_core.o C_PPHexInteger.o CPreproc_autogen.o CPUInfo.o AtomicString.o ParseTree.o type_system.o errors.o unsigned_var_int.o unsigned_aux.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
+OBJECTS_ZCC_LINK_PRIORITY = zcc.o CPreproc.o unsigned_aux.o ParseTree.o Flat_UNI.o unsigned_var_int.o CSupport.o type_system.o CPUInfo.o CPreproc_autogen.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o errors.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
 
 # dependencies
-z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc_pp.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
+z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc_pp.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
 errors.o: errors.hpp langroute.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 langroute.o: langroute.hpp _CSupport1.hpp Zaimoni.STL/Logging.h Zaimoni.STL/POD.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp
 AtomicString.o: AtomicString.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -16,10 +16,10 @@
 unsigned_var_int.o: unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp
 CPUInfo.o: CPUInfo.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp
 struct_type.o: struct_type.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp
-type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
+type_system.o: type_system.hpp type_system_pp.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.!
 STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL!
 /pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -30,10 +30,10 @@
 Trigraph.o: Trigraph.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 Flat_UNI.o: Flat_UNI.hpp lex_core.h Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/comptest.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
-CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexP!
 arse/MetaToken.hpp
+CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimo!
 ni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
-zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
-CSupport.o: CSupport.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Le!
 xparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
-CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/Meta!
 Token.hpp
-CPreproc_autogen.o: CPreproc.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
+zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
+CSupport.o: CSupport.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hp!
 p Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/meta!
 type/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2010-04-11 02:39:30 UTC (rev 373)
+++ trunk/ParseTree.cpp	2010-04-11 17:46:31 UTC (rev 374)
@@ -38,30 +38,29 @@
 #ifndef ZAIMONI_FORCE_ISO
 bool parse_tree::syntax_ok() const
 {
-	if (NULL!=args[0] && !_memory_block_start_valid(args[0])) return false;
-	if (NULL!=args[1] && !_memory_block_start_valid(args[1])) return false;
-	if (NULL!=args[2] && !_memory_block_start_valid(args[2])) return false;
+	if (args[0] && !_memory_block_start_valid(args[0])) return false;
+	if (args[1] && !_memory_block_start_valid(args[1])) return false;
+	if (args[2] && !_memory_block_start_valid(args[2])) return false;
 
 	if (own_index_token<0>())
 		{
-		if (NULL==index_tokens[0].token.first) return false;
-		if (!_memory_block_start_valid(index_tokens[0].token.first)) return false;
+		if (!index_tokens[0].token.first) return false;
+		if (!_memory_block_start_valid(index_tokens[0].token.first))
+			return false;
 		};
 	if (own_index_token<1>())
 		{
-		if (NULL==index_tokens[1].token.first) return false;
-		if (!_memory_block_start_valid(index_tokens[1].token.first)) return false;
+		if (!index_tokens[1].token.first) return false;
+		if (!_memory_block_start_valid(index_tokens[1].token.first))
+			return false;
 		};
 
 	size_t i = 0;
-	while(size<0>()>i)
-		if (!data<0>()[i++].syntax_ok()) return false;
+	while(size<0>()>i) if (!data<0>()[i++].syntax_ok()) return false;
 	i = 0;
-	while(size<1>()>i)
-		if (!data<1>()[i++].syntax_ok()) return false;
+	while(size<1>()>i) if (!data<1>()[i++].syntax_ok()) return false;
 	i = 0;
-	while(size<2>()>i)
-		if (!data<2>()[i++].syntax_ok()) return false;
+	while(size<2>()>i) if (!data<2>()[i++].syntax_ok()) return false;
 	return true;
 }
 #endif
@@ -352,9 +351,7 @@
 	if (begin<end)
 		{
 		if (begin+1==end)
-			{
 			value_copy(*this,src.data(dest_idx)[begin]);
-			}
 		else{
 			size_t i = end-begin;
 			if (!resize(dest_idx,end-begin)) throw std::bad_alloc();
@@ -366,5 +363,3 @@
 			}
 		}
 }
-
-

Modified: trunk/Zaimoni.STL/MetaRAM2.hpp
===================================================================
--- trunk/Zaimoni.STL/MetaRAM2.hpp	2010-04-11 02:39:30 UTC (rev 373)
+++ trunk/Zaimoni.STL/MetaRAM2.hpp	2010-04-11 17:46:31 UTC (rev 374)
@@ -159,7 +159,37 @@
 	return tmp;
 }
 
+
 template<typename T>
+inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
+_new_buffer_uninitialized(size_t Idx)
+{
+	if (((size_t)(-1))/sizeof(T)>=Idx) return NULL; // CERT C MEM07
+	return reinterpret_cast<T*>(malloc(Idx*sizeof(T)));
+}
+
+template<typename T>
+inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
+_new_buffer_uninitialized_nonNULL(size_t Idx)
+{
+	if (((size_t)(-1))/sizeof(T)>=Idx) // CERT C MEM07
+		_fatal("requested memory exceeds SIZE_T_MAX");
+	T* tmp = reinterpret_cast<T*>(malloc(Idx*sizeof(T)));
+	if (NULL==tmp) _fatal("Irrecoverable failure to allocate memory");
+	return tmp;
+}
+
+template<typename T>
+inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
+_new_buffer_uninitialized_nonNULL_throws(size_t Idx)
+{
+	if (((size_t)(-1))/sizeof(T)>=Idx) throw std::bad_alloc(); // CERT C MEM07
+	T* tmp = reinterpret_cast<T*>(malloc(Idx*sizeof(T)));
+	if (NULL==tmp) throw std::bad_alloc();
+	return tmp;
+}
+
+template<typename T>
 inline typename boost::disable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, void>::type
 _flush(T* _ptr)
 {

Modified: trunk/unsigned_aux.cpp
===================================================================
--- trunk/unsigned_aux.cpp	2010-04-11 02:39:30 UTC (rev 373)
+++ trunk/unsigned_aux.cpp	2010-04-11 17:46:31 UTC (rev 374)
@@ -325,8 +325,7 @@
 	return 0;
 }
 
-int
-_unsigned_cmp(const unsigned char* lhs, size_t lhs_len, uintmax_t rhs)
+int _unsigned_cmp(const unsigned char* lhs, size_t lhs_len, uintmax_t rhs)
 {	// reverse memcmp
 	do	{
 		--lhs_len;
@@ -354,7 +353,7 @@
 	memset(quotient,0,buf_len);
 	SUCCEED_OR_DIE(1==_unsigned_cmp(divisor,buf_len,quotient));
 	if (0==_unsigned_cmp(dividend_remainder,buf_len,quotient)) return;
-	unsigned char* interim = reinterpret_cast<unsigned char*>(malloc(2*buf_len));	//! \todo candidate for alloca
+	unsigned char* interim = reinterpret_cast<unsigned char*>(malloc(2*buf_len));
 	SUCCEED_OR_DIE(NULL!=interim);
 	while(0<=_unsigned_cmp(dividend_remainder,buf_len,divisor))
 		{

Modified: trunk/z_cpp.cpp
===================================================================
--- trunk/z_cpp.cpp	2010-04-11 02:39:30 UTC (rev 373)
+++ trunk/z_cpp.cpp	2010-04-11 17:46:31 UTC (rev 374)
@@ -13,6 +13,7 @@
 #include "errors.hpp"
 #include "CPUInfo.hpp"
 #include "errcount.hpp"
+#include "_version.h"
 
 #include "Zaimoni.STL/POD.hpp"
 #include <stdio.h>
@@ -147,7 +148,7 @@
 
 static void help(void)
 {
-	STRING_LITERAL_TO_STDOUT("Z.C++ 0.0.3 z_cpp\n");
+	STRING_LITERAL_TO_STDOUT("Z.C++ " ZCC_VERSION " z_cpp\n");
 	STRING_LITERAL_TO_STDOUT("usage: z_cpp [options] infile\n");
 	STRING_LITERAL_TO_STDOUT("boolean options\n");
 	size_t i = 0;

Modified: trunk/zcc.cpp
===================================================================
--- trunk/zcc.cpp	2010-04-11 02:39:30 UTC (rev 373)
+++ trunk/zcc.cpp	2010-04-11 17:46:31 UTC (rev 374)
@@ -15,6 +15,7 @@
 #include "errcount.hpp"
 #include "ParseTree.hpp"
 #include "ZParser.hpp"
+#include "_version.h"
 
 #include "Zaimoni.STL/POD.hpp"
 
@@ -152,7 +153,7 @@
 
 static void help(void)
 {
-	STRING_LITERAL_TO_STDOUT("Z.C++ 0.0.3 zcc\n");
+	STRING_LITERAL_TO_STDOUT("Z.C++ " ZCC_VERSION " zcc\n");
 	STRING_LITERAL_TO_STDOUT("usage: zcc [options] infile\n");
 	STRING_LITERAL_TO_STDOUT("boolean options\n");
 	size_t i = 0;



From zaimoni at mail.berlios.de  Sun Apr 11 19:51:21 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 11 Apr 2010 19:51:21 +0200
Subject: [Zcplusplus-commits] r375 - trunk
Message-ID: <201004111751.o3BHpLVK002277@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-11 19:51:18 +0200 (Sun, 11 Apr 2010)
New Revision: 375

Added:
   trunk/_version.h
Log:
unbreak SVN

Added: trunk/_version.h
===================================================================
--- trunk/_version.h	2010-04-11 17:46:31 UTC (rev 374)
+++ trunk/_version.h	2010-04-11 17:51:18 UTC (rev 375)
@@ -0,0 +1,11 @@
+/* _version.h */
+/* central version information for ZCC */
+/* (C)2010 Kenneth Boyd, license: MIT.txt */
+
+#ifndef ZCC_VERSION
+#define ZCC_VERSION "0.0.3"
+#define ZCC_VERSION_MAJOR 0
+#define ZCC_VERSION_MINOR 0
+#define ZCC_VERSION_PATCH 3
+#endif
+



From zaimoni at mail.berlios.de  Mon Apr 12 00:56:09 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 12 Apr 2010 00:56:09 +0200
Subject: [Zcplusplus-commits] r376 - trunk
Message-ID: <201004112256.o3BMu9Nf000692@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-12 00:56:05 +0200 (Mon, 12 Apr 2010)
New Revision: 376

Modified:
   trunk/CPreproc_autogen.cpp
   trunk/CPreproc_autogen_pp.cpp
Log:
upgrade some member functions to strong exception guarantee; remove memory leak triggered by throwing std::bad_alloc

Modified: trunk/CPreproc_autogen.cpp
===================================================================
--- trunk/CPreproc_autogen.cpp	2010-04-11 17:51:18 UTC (rev 375)
+++ trunk/CPreproc_autogen.cpp	2010-04-11 22:56:05 UTC (rev 376)
@@ -307,9 +307,9 @@
 		strcpy(tmp2,"#ifdef ");
 		strcpy(tmp2+sizeof("#ifdef ")-1,*identifiers);
 #ifndef ZAIMONI_FORCE_ISO
-		tmp[i] = new zaimoni::Token<char>(tmp2,NULL);
+		tmp[i] = new(std::nothrow) zaimoni::Token<char>(tmp2,NULL);
 #else
-		tmp[i] = new zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#ifdef ")-1+identifier_len),NULL);
+		tmp[i] = new(std::nothrow) zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#ifdef ")-1+identifier_len),NULL);
 #endif
 		if (NULL==tmp[i])
 			{
@@ -321,9 +321,9 @@
 		strcpy(tmp2,"#undef ");
 		strcpy(tmp2+sizeof("#undef ")-1,*identifiers);
 #ifndef ZAIMONI_FORCE_ISO
-		tmp[i+2] = new zaimoni::Token<char>(tmp2,NULL);
+		tmp[i+2] = new(std::nothrow) zaimoni::Token<char>(tmp2,NULL);
 #else
-		tmp[i+2] = new zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#undef ")-1+identifier_len),NULL);
+		tmp[i+2] = new(std::nothrow) zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#undef ")-1+identifier_len),NULL);
 #endif
 		if (NULL==tmp[i+2])
 			{
@@ -336,9 +336,9 @@
 		strcpy(tmp2+sizeof("#error Undefined Behavior: reserved identifier '")-1,*identifiers);
 		strcpy(tmp2+sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len,"' defined as macro");
 #ifndef ZAIMONI_FORCE_ISO
-		tmp[i+1] = new zaimoni::Token<char>(tmp2,NULL);
+		tmp[i+1] = new(std::nothrow) zaimoni::Token<char>(tmp2,NULL);
 #else
-		tmp[i+1] = new zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len+sizeof("' defined as macro")-1),NULL);
+		tmp[i+1] = new(std::nothrow) zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len+sizeof("' defined as macro")-1),NULL);
 #endif
 		if (NULL==tmp[i+1])
 			{
@@ -430,9 +430,10 @@
 	buf[0] = ' ';
 #endif
 	assert(NULL!=header_name);
-	TokenList.clear();
-	TokenList.resize(STATIC_SIZE(limits_h_core));
-	zaimoni::Token<char>** tmp = TokenList.c_array();
+	assert(TokenList.empty());
+	zaimoni::autovalarray_ptr<zaimoni::Token<char>* > TmpTokenList(STATIC_SIZE(limits_h_core));
+	zaimoni::Token<char>** tmp = TmpTokenList.c_array();
+	
 	size_t i = STATIC_SIZE(limits_h_core);
 	do	{
 		--i;
@@ -510,14 +511,15 @@
 	tmp[LIMITS_WORD_BIT_LINE]->append(z_umaxtoa(target_machine.C_bit<virtual_machine::std_int_int>(),buf+1,10)-1);
 	tmp[LIMITS_LONG_BIT_LINE]->append(z_umaxtoa(target_machine.C_bit<virtual_machine::std_int_long>(),buf+1,10)-1);
 
-	lockdown_reserved_identifiers(TokenList,LIMITS_INJECT_LOCK,limits_h_reserved+18,STATIC_SIZE(limits_h_reserved)-18);
-	lockdown_reserved_identifiers(TokenList,LIMITS_INJECT_LOCK,limits_h_reserved+12,6);
-	lockdown_reserved_identifiers(TokenList,LIMITS_INJECT_LOCK,limits_h_reserved+6,6);
-	lockdown_reserved_identifiers(TokenList,LIMITS_INJECT_LOCK,limits_h_reserved,6);
-	lockdown_reserved_identifiers(TokenList,LIMITS_POSIX_INJECT_LOCK,limits_h_POSIX_reserved,STATIC_SIZE(limits_h_POSIX_reserved));
-	disallow_prior_definitions(TokenList,LIMITS_POSIX_INJECT_REALITY,limits_h_POSIX_reserved,STATIC_SIZE(limits_h_POSIX_reserved));
-	disallow_prior_definitions(TokenList,LIMITS_INJECT_REALITY,limits_h_reserved,STATIC_SIZE(limits_h_reserved));
-
+	lockdown_reserved_identifiers(TmpTokenList,LIMITS_INJECT_LOCK,limits_h_reserved+18,STATIC_SIZE(limits_h_reserved)-18);
+	lockdown_reserved_identifiers(TmpTokenList,LIMITS_INJECT_LOCK,limits_h_reserved+12,6);
+	lockdown_reserved_identifiers(TmpTokenList,LIMITS_INJECT_LOCK,limits_h_reserved+6,6);
+	lockdown_reserved_identifiers(TmpTokenList,LIMITS_INJECT_LOCK,limits_h_reserved,6);
+	lockdown_reserved_identifiers(TmpTokenList,LIMITS_POSIX_INJECT_LOCK,limits_h_POSIX_reserved,STATIC_SIZE(limits_h_POSIX_reserved));
+	disallow_prior_definitions(TmpTokenList,LIMITS_POSIX_INJECT_REALITY,limits_h_POSIX_reserved,STATIC_SIZE(limits_h_POSIX_reserved));
+	disallow_prior_definitions(TmpTokenList,LIMITS_INJECT_REALITY,limits_h_reserved,STATIC_SIZE(limits_h_reserved));
+	zaimoni::swap(TokenList,TmpTokenList);
+	
 	final_init_tokenlist(TokenList.c_array(),TokenList.size(),header_name);
 }
 
@@ -608,9 +610,10 @@
 CPreprocessor::create_stddef_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
 	assert(NULL!=header_name);
-	TokenList.clear();
-	TokenList.resize(STATIC_SIZE(stddef_h_core));
-	zaimoni::Token<char>** tmp = TokenList.c_array();
+	assert(TokenList.empty());
+	zaimoni::autovalarray_ptr<zaimoni::Token<char>* > TmpTokenList(STATIC_SIZE(stddef_h_core));
+	zaimoni::Token<char>** tmp = TmpTokenList.c_array();
+
 	size_t i = STATIC_SIZE(stddef_h_core);
 	do	{
 		--i;
@@ -638,9 +641,10 @@
 	tmp[STDDEF_NULL_LINE]->append(NULL_constant_from_machine(target_machine.ptrdiff_t_type()));
 
 	BOOST_STATIC_ASSERT(6==STATIC_SIZE(stddef_h_reserved));
-	disallow_prior_definitions(TokenList,STDDEF_INJECT_CPP_REALITY,stddef_h_reserved+5,1);
-	disallow_prior_definitions(TokenList,STDDEF_INJECT_C_REALITY,stddef_h_reserved,1);
-	disallow_prior_definitions(TokenList,STDDEF_INJECT_REALITY,stddef_h_reserved+1,4);
+	disallow_prior_definitions(TmpTokenList,STDDEF_INJECT_CPP_REALITY,stddef_h_reserved+5,1);
+	disallow_prior_definitions(TmpTokenList,STDDEF_INJECT_C_REALITY,stddef_h_reserved,1);
+	disallow_prior_definitions(TmpTokenList,STDDEF_INJECT_REALITY,stddef_h_reserved+1,4);
+	zaimoni::swap(TokenList,TmpTokenList);
 
 	final_init_tokenlist(TokenList.c_array(),TokenList.size(),header_name);
 }
@@ -690,6 +694,7 @@
 CPreprocessor::create_stdint_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
 	assert(NULL!=header_name);
+	assert(TokenList.empty());
 	// 2 for: leading space, trailing null-termination
 	// (VM_MAX_BIT_PLATFORM/3) for: digits (using octal rather than decimal count because that's easy to do at compile-time)
 #ifdef ZCC_LEGACY_FIXED_INT
@@ -698,9 +703,11 @@
 #else
 	zaimoni::autovalarray_ptr_throws<char> buf(2+(VM_MAX_BIT_PLATFORM/3));
 #endif
-	TokenList.clear();
-	TokenList.resize(STATIC_SIZE(stdint_h_core));
-	zaimoni::Token<char>** tmp = TokenList.c_array();
+	zaimoni::autovalarray_ptr<zaimoni::Token<char>* > TmpTokenList(STATIC_SIZE(stdint_h_core));
+	zaimoni::Token<char>** tmp = TmpTokenList.c_array();
+
+//	TokenList.resize(STATIC_SIZE(stdint_h_core));
+//	zaimoni::Token<char>** tmp = TokenList.c_array();
 	size_t i = STATIC_SIZE(stdint_h_core);
 	do	{
 		--i;
@@ -997,14 +1004,14 @@
 		stack[stack_size++] = STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_UCHAR_OFFSET;
 		--inject_CPP_index;
 		}	
-	if (0<stack_size) TokenList.DeleteNSlots(stack,stack_size);
+	if (0<stack_size) TmpTokenList.DeleteNSlots(stack,stack_size);
 	}
 
 	// limits macros cleanup
 	char lock_buf[sizeof("#pragma ZCC lock INT_LEAST_MIN INT_LEAST_MAX UINT_LEAST_MAX INT_FAST_MIN INT_FAST_MAX UINT_FAST_MAX INT_C UINT_C")+8*2] = "#pragma ZCC lock ";
 	if (suppress[virtual_machine::std_int_long_long-2])
 		{
-		TokenList.DeleteNSlotsAt(3,STDINT_EXACT_LLONG_LIMITS_LINEORIGIN);
+		TmpTokenList.DeleteNSlotsAt(3,STDINT_EXACT_LLONG_LIMITS_LINEORIGIN);
 		inject_CPP_index -= 3;
 		inject_C_index -= 3;
 		}
@@ -1019,19 +1026,19 @@
 			strcat(lock_buf,buf+1);
 			};
 		strcat(lock_buf,"_MAX");
-		new_token_at(TokenList,STDINT_EXACT_LLONG_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
+		new_token_at(TmpTokenList,STDINT_EXACT_LLONG_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
 		++inject_CPP_index;
 		++inject_C_index;
 		if (!target_is_twos_complement)
 			{
-			TokenList.DeleteNSlotsAt(2,STDINT_EXACT_LLONG_LIMITS_LINEORIGIN);
+			TmpTokenList.DeleteNSlotsAt(2,STDINT_EXACT_LLONG_LIMITS_LINEORIGIN);
 			inject_CPP_index -= 2;
 			inject_C_index -= 2;
 			};
 		};
 	if (suppress[virtual_machine::std_int_long-2])
 		{
-		TokenList.DeleteNSlotsAt(3,STDINT_EXACT_LONG_LIMITS_LINEORIGIN);
+		TmpTokenList.DeleteNSlotsAt(3,STDINT_EXACT_LONG_LIMITS_LINEORIGIN);
 		inject_CPP_index -= 3;
 		inject_C_index -= 3;
 		}
@@ -1046,12 +1053,12 @@
 			strcat(lock_buf,buf+1);
 			};
 		strcat(lock_buf,"_MAX");
-		new_token_at(TokenList,STDINT_EXACT_LONG_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
+		new_token_at(TmpTokenList,STDINT_EXACT_LONG_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
 		++inject_CPP_index;
 		++inject_C_index;
 		if (!target_is_twos_complement)
 			{
-			TokenList.DeleteNSlotsAt(2,STDINT_EXACT_LONG_LIMITS_LINEORIGIN);
+			TmpTokenList.DeleteNSlotsAt(2,STDINT_EXACT_LONG_LIMITS_LINEORIGIN);
 			inject_CPP_index -= 2;
 			inject_C_index -= 2;
 			};
@@ -1067,18 +1074,18 @@
 		strcat(lock_buf,buf+1);
 		};
 	strcat(lock_buf,"_MAX");
-	new_token_at(TokenList,STDINT_EXACT_INT_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
+	new_token_at(TmpTokenList,STDINT_EXACT_INT_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
 	++inject_CPP_index;
 	++inject_C_index;
 	if (!target_is_twos_complement)
 		{
-		TokenList.DeleteNSlotsAt(2,STDINT_EXACT_INT_LIMITS_LINEORIGIN);
+		TmpTokenList.DeleteNSlotsAt(2,STDINT_EXACT_INT_LIMITS_LINEORIGIN);
 		inject_CPP_index -= 2;
 		inject_C_index -= 2;
 		};
 	if (suppress[virtual_machine::std_int_short-1])
 		{
-		TokenList.DeleteNSlotsAt(3,STDINT_EXACT_SHRT_LIMITS_LINEORIGIN);
+		TmpTokenList.DeleteNSlotsAt(3,STDINT_EXACT_SHRT_LIMITS_LINEORIGIN);
 		inject_CPP_index -= 3;
 		inject_C_index -= 3;
 		}
@@ -1093,19 +1100,19 @@
 			strcat(lock_buf,buf+1);
 			};
 		strcat(lock_buf,"_MAX");
-		new_token_at(TokenList,STDINT_EXACT_SHRT_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
+		new_token_at(TmpTokenList,STDINT_EXACT_SHRT_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
 		++inject_CPP_index;
 		++inject_C_index;
 		if (!target_is_twos_complement)
 			{
-			TokenList.DeleteNSlotsAt(2,STDINT_EXACT_SHRT_LIMITS_LINEORIGIN);
+			TmpTokenList.DeleteNSlotsAt(2,STDINT_EXACT_SHRT_LIMITS_LINEORIGIN);
 			inject_CPP_index -= 2;
 			inject_C_index -= 2;
 			}
 		}
 	if (suppress[virtual_machine::std_int_char-1])
 		{
-		TokenList.DeleteNSlotsAt(3,STDINT_EXACT_CHAR_LIMITS_LINEORIGIN);
+		TmpTokenList.DeleteNSlotsAt(3,STDINT_EXACT_CHAR_LIMITS_LINEORIGIN);
 		inject_CPP_index -= 3;
 		inject_C_index -= 3;
 		}
@@ -1120,12 +1127,12 @@
 			strcat(lock_buf,buf+1);
 			};
 		strcat(lock_buf,"_MAX");
-		new_token_at(TokenList,STDINT_EXACT_CHAR_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
+		new_token_at(TmpTokenList,STDINT_EXACT_CHAR_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
 		++inject_CPP_index;
 		++inject_C_index;
 		if (!target_is_twos_complement)
 			{
-			TokenList.DeleteNSlotsAt(2,STDINT_EXACT_CHAR_LIMITS_LINEORIGIN);
+			TmpTokenList.DeleteNSlotsAt(2,STDINT_EXACT_CHAR_LIMITS_LINEORIGIN);
 			inject_CPP_index -= 2;
 			inject_C_index -= 2;
 			}
@@ -1199,7 +1206,7 @@
 		--inject_CPP_index;
 		--inject_C_index;
 		}
-	if (0<stack_size) TokenList.DeleteNSlots(stack,stack_size);	
+	if (0<stack_size) TmpTokenList.DeleteNSlots(stack,stack_size);	
 	}
 
 	// prepare to inject least/fast types and their adapter macros
@@ -1212,8 +1219,8 @@
 	const unsigned short bitspan_types = type_bits[virtual_machine::std_int_long_long-1]-7;
 	assert(USHRT_MAX/13>=bitspan_types);
 	i = 4*bitspan_types;
-	TokenList.InsertNSlotsAt(i,inject_CPP_index);
-	tmp = TokenList.c_array()+inject_CPP_index;
+	TmpTokenList.InsertNSlotsAt(i,inject_CPP_index);
+	tmp = TmpTokenList.c_array()+inject_CPP_index;
 	do	{
 		const int target_bits = --i/4+8;
 		assert(target_bits<=target_machine.C_bit(virtual_machine::std_int_long_long));
@@ -1259,8 +1266,8 @@
 	strcpy(define_buf,"#define ");
 #endif
 	i = 13*bitspan_types;
-	TokenList.InsertNSlotsAt(i,inject_C_index);
-	tmp = TokenList.c_array()+inject_C_index;
+	TmpTokenList.InsertNSlotsAt(i,inject_C_index);
+	tmp = TmpTokenList.c_array()+inject_C_index;
 	do	{
 		const int target_bits = --i/13+8;
 		assert(target_bits<=target_machine.C_bit(virtual_machine::std_int_long_long));
@@ -1375,6 +1382,7 @@
 		tmp[i] = new zaimoni::Token<char>(typedef_buf,0,strlen(typedef_buf),0);
 		}
 	while(0<i);
+	zaimoni::swap(TokenList,TmpTokenList);
 
 	final_init_tokenlist(TokenList.c_array(),TokenList.size(),header_name);
 }

Modified: trunk/CPreproc_autogen_pp.cpp
===================================================================
--- trunk/CPreproc_autogen_pp.cpp	2010-04-11 17:51:18 UTC (rev 375)
+++ trunk/CPreproc_autogen_pp.cpp	2010-04-11 22:56:05 UTC (rev 376)
@@ -304,9 +304,9 @@
 		strcpy(tmp2,"#ifdef ");
 		strcpy(tmp2+sizeof("#ifdef ")-1,*identifiers);
 #ifndef ZAIMONI_FORCE_ISO
-		tmp[i] = new zaimoni::Token<char>(tmp2,NULL);
+		tmp[i] = new(std::nothrow) zaimoni::Token<char>(tmp2,NULL);
 #else
-		tmp[i] = new zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#ifdef ")-1+identifier_len),NULL);
+		tmp[i] = new(std::nothrow) zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#ifdef ")-1+identifier_len),NULL);
 #endif
 		if (NULL==tmp[i])
 			{
@@ -318,9 +318,9 @@
 		strcpy(tmp2,"#undef ");
 		strcpy(tmp2+sizeof("#undef ")-1,*identifiers);
 #ifndef ZAIMONI_FORCE_ISO
-		tmp[i+2] = new zaimoni::Token<char>(tmp2,NULL);
+		tmp[i+2] = new(std::nothrow) zaimoni::Token<char>(tmp2,NULL);
 #else
-		tmp[i+2] = new zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#undef ")-1+identifier_len),NULL);
+		tmp[i+2] = new(std::nothrow) zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#undef ")-1+identifier_len),NULL);
 #endif
 		if (NULL==tmp[i+2])
 			{
@@ -333,9 +333,9 @@
 		strcpy(tmp2+sizeof("#error Undefined Behavior: reserved identifier '")-1,*identifiers);
 		strcpy(tmp2+sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len,"' defined as macro");
 #ifndef ZAIMONI_FORCE_ISO
-		tmp[i+1] = new zaimoni::Token<char>(tmp2,NULL);
+		tmp[i+1] = new(std::nothrow) zaimoni::Token<char>(tmp2,NULL);
 #else
-		tmp[i+1] = new zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len+sizeof("' defined as macro")-1),NULL);
+		tmp[i+1] = new(std::nothrow) zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len+sizeof("' defined as macro")-1),NULL);
 #endif
 		if (NULL==tmp[i+1])
 			{
@@ -427,9 +427,10 @@
 	buf[0] = ' ';
 #endif
 	assert(NULL!=header_name);
-	TokenList.clear();
-	TokenList.resize(STATIC_SIZE(limits_h_core));
-	zaimoni::Token<char>** tmp = TokenList.c_array();
+	assert(TokenList.empty());
+	zaimoni::autovalarray_ptr<zaimoni::Token<char>* > TmpTokenList(STATIC_SIZE(limits_h_core));
+	zaimoni::Token<char>** tmp = TmpTokenList.c_array();
+	
 	size_t i = STATIC_SIZE(limits_h_core);
 	do	{
 		--i;
@@ -507,14 +508,15 @@
 	tmp[LIMITS_WORD_BIT_LINE]->append(z_umaxtoa(target_machine.C_bit<virtual_machine::std_int_int>(),buf+1,10)-1);
 	tmp[LIMITS_LONG_BIT_LINE]->append(z_umaxtoa(target_machine.C_bit<virtual_machine::std_int_long>(),buf+1,10)-1);
 
-	lockdown_reserved_identifiers(TokenList,LIMITS_INJECT_LOCK,limits_h_reserved+18,STATIC_SIZE(limits_h_reserved)-18);
-	lockdown_reserved_identifiers(TokenList,LIMITS_INJECT_LOCK,limits_h_reserved+12,6);
-	lockdown_reserved_identifiers(TokenList,LIMITS_INJECT_LOCK,limits_h_reserved+6,6);
-	lockdown_reserved_identifiers(TokenList,LIMITS_INJECT_LOCK,limits_h_reserved,6);
-	lockdown_reserved_identifiers(TokenList,LIMITS_POSIX_INJECT_LOCK,limits_h_POSIX_reserved,STATIC_SIZE(limits_h_POSIX_reserved));
-	disallow_prior_definitions(TokenList,LIMITS_POSIX_INJECT_REALITY,limits_h_POSIX_reserved,STATIC_SIZE(limits_h_POSIX_reserved));
-	disallow_prior_definitions(TokenList,LIMITS_INJECT_REALITY,limits_h_reserved,STATIC_SIZE(limits_h_reserved));
-
+	lockdown_reserved_identifiers(TmpTokenList,LIMITS_INJECT_LOCK,limits_h_reserved+18,STATIC_SIZE(limits_h_reserved)-18);
+	lockdown_reserved_identifiers(TmpTokenList,LIMITS_INJECT_LOCK,limits_h_reserved+12,6);
+	lockdown_reserved_identifiers(TmpTokenList,LIMITS_INJECT_LOCK,limits_h_reserved+6,6);
+	lockdown_reserved_identifiers(TmpTokenList,LIMITS_INJECT_LOCK,limits_h_reserved,6);
+	lockdown_reserved_identifiers(TmpTokenList,LIMITS_POSIX_INJECT_LOCK,limits_h_POSIX_reserved,STATIC_SIZE(limits_h_POSIX_reserved));
+	disallow_prior_definitions(TmpTokenList,LIMITS_POSIX_INJECT_REALITY,limits_h_POSIX_reserved,STATIC_SIZE(limits_h_POSIX_reserved));
+	disallow_prior_definitions(TmpTokenList,LIMITS_INJECT_REALITY,limits_h_reserved,STATIC_SIZE(limits_h_reserved));
+	zaimoni::swap(TokenList,TmpTokenList);
+	
 	final_init_tokenlist(TokenList.c_array(),TokenList.size(),header_name);
 }
 
@@ -605,9 +607,10 @@
 CPreprocessor::create_stddef_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
 	assert(NULL!=header_name);
-	TokenList.clear();
-	TokenList.resize(STATIC_SIZE(stddef_h_core));
-	zaimoni::Token<char>** tmp = TokenList.c_array();
+	assert(TokenList.empty());
+	zaimoni::autovalarray_ptr<zaimoni::Token<char>* > TmpTokenList(STATIC_SIZE(stddef_h_core));
+	zaimoni::Token<char>** tmp = TmpTokenList.c_array();
+
 	size_t i = STATIC_SIZE(stddef_h_core);
 	do	{
 		--i;
@@ -635,9 +638,10 @@
 	tmp[STDDEF_NULL_LINE]->append(NULL_constant_from_machine(target_machine.ptrdiff_t_type()));
 
 	BOOST_STATIC_ASSERT(6==STATIC_SIZE(stddef_h_reserved));
-	disallow_prior_definitions(TokenList,STDDEF_INJECT_CPP_REALITY,stddef_h_reserved+5,1);
-	disallow_prior_definitions(TokenList,STDDEF_INJECT_C_REALITY,stddef_h_reserved,1);
-	disallow_prior_definitions(TokenList,STDDEF_INJECT_REALITY,stddef_h_reserved+1,4);
+	disallow_prior_definitions(TmpTokenList,STDDEF_INJECT_CPP_REALITY,stddef_h_reserved+5,1);
+	disallow_prior_definitions(TmpTokenList,STDDEF_INJECT_C_REALITY,stddef_h_reserved,1);
+	disallow_prior_definitions(TmpTokenList,STDDEF_INJECT_REALITY,stddef_h_reserved+1,4);
+	zaimoni::swap(TokenList,TmpTokenList);
 
 	final_init_tokenlist(TokenList.c_array(),TokenList.size(),header_name);
 }
@@ -687,6 +691,7 @@
 CPreprocessor::create_stdint_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
 	assert(NULL!=header_name);
+	assert(TokenList.empty());
 	// 2 for: leading space, trailing null-termination
 	// (VM_MAX_BIT_PLATFORM/3) for: digits (using octal rather than decimal count because that's easy to do at compile-time)
 #ifdef ZCC_LEGACY_FIXED_INT
@@ -695,9 +700,11 @@
 #else
 	zaimoni::autovalarray_ptr_throws<char> buf(2+(VM_MAX_BIT_PLATFORM/3));
 #endif
-	TokenList.clear();
-	TokenList.resize(STATIC_SIZE(stdint_h_core));
-	zaimoni::Token<char>** tmp = TokenList.c_array();
+	zaimoni::autovalarray_ptr<zaimoni::Token<char>* > TmpTokenList(STATIC_SIZE(stdint_h_core));
+	zaimoni::Token<char>** tmp = TmpTokenList.c_array();
+
+//	TokenList.resize(STATIC_SIZE(stdint_h_core));
+//	zaimoni::Token<char>** tmp = TokenList.c_array();
 	size_t i = STATIC_SIZE(stdint_h_core);
 	do	{
 		--i;
@@ -994,14 +1001,14 @@
 		stack[stack_size++] = STDINT_CPP_EXACT_LINEORIGIN+STDINT_EXACT_UCHAR_OFFSET;
 		--inject_CPP_index;
 		}	
-	if (0<stack_size) TokenList.DeleteNSlots(stack,stack_size);
+	if (0<stack_size) TmpTokenList.DeleteNSlots(stack,stack_size);
 	}
 
 	// limits macros cleanup
 	char lock_buf[sizeof("#pragma ZCC lock INT_LEAST_MIN INT_LEAST_MAX UINT_LEAST_MAX INT_FAST_MIN INT_FAST_MAX UINT_FAST_MAX INT_C UINT_C")+8*2] = "#pragma ZCC lock ";
 	if (suppress[virtual_machine::std_int_long_long-2])
 		{
-		TokenList.DeleteNSlotsAt(3,STDINT_EXACT_LLONG_LIMITS_LINEORIGIN);
+		TmpTokenList.DeleteNSlotsAt(3,STDINT_EXACT_LLONG_LIMITS_LINEORIGIN);
 		inject_CPP_index -= 3;
 		inject_C_index -= 3;
 		}
@@ -1016,19 +1023,19 @@
 			strcat(lock_buf,buf+1);
 			};
 		strcat(lock_buf,"_MAX");
-		new_token_at(TokenList,STDINT_EXACT_LLONG_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
+		new_token_at(TmpTokenList,STDINT_EXACT_LLONG_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
 		++inject_CPP_index;
 		++inject_C_index;
 		if (!target_is_twos_complement)
 			{
-			TokenList.DeleteNSlotsAt(2,STDINT_EXACT_LLONG_LIMITS_LINEORIGIN);
+			TmpTokenList.DeleteNSlotsAt(2,STDINT_EXACT_LLONG_LIMITS_LINEORIGIN);
 			inject_CPP_index -= 2;
 			inject_C_index -= 2;
 			};
 		};
 	if (suppress[virtual_machine::std_int_long-2])
 		{
-		TokenList.DeleteNSlotsAt(3,STDINT_EXACT_LONG_LIMITS_LINEORIGIN);
+		TmpTokenList.DeleteNSlotsAt(3,STDINT_EXACT_LONG_LIMITS_LINEORIGIN);
 		inject_CPP_index -= 3;
 		inject_C_index -= 3;
 		}
@@ -1043,12 +1050,12 @@
 			strcat(lock_buf,buf+1);
 			};
 		strcat(lock_buf,"_MAX");
-		new_token_at(TokenList,STDINT_EXACT_LONG_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
+		new_token_at(TmpTokenList,STDINT_EXACT_LONG_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
 		++inject_CPP_index;
 		++inject_C_index;
 		if (!target_is_twos_complement)
 			{
-			TokenList.DeleteNSlotsAt(2,STDINT_EXACT_LONG_LIMITS_LINEORIGIN);
+			TmpTokenList.DeleteNSlotsAt(2,STDINT_EXACT_LONG_LIMITS_LINEORIGIN);
 			inject_CPP_index -= 2;
 			inject_C_index -= 2;
 			};
@@ -1064,18 +1071,18 @@
 		strcat(lock_buf,buf+1);
 		};
 	strcat(lock_buf,"_MAX");
-	new_token_at(TokenList,STDINT_EXACT_INT_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
+	new_token_at(TmpTokenList,STDINT_EXACT_INT_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
 	++inject_CPP_index;
 	++inject_C_index;
 	if (!target_is_twos_complement)
 		{
-		TokenList.DeleteNSlotsAt(2,STDINT_EXACT_INT_LIMITS_LINEORIGIN);
+		TmpTokenList.DeleteNSlotsAt(2,STDINT_EXACT_INT_LIMITS_LINEORIGIN);
 		inject_CPP_index -= 2;
 		inject_C_index -= 2;
 		};
 	if (suppress[virtual_machine::std_int_short-1])
 		{
-		TokenList.DeleteNSlotsAt(3,STDINT_EXACT_SHRT_LIMITS_LINEORIGIN);
+		TmpTokenList.DeleteNSlotsAt(3,STDINT_EXACT_SHRT_LIMITS_LINEORIGIN);
 		inject_CPP_index -= 3;
 		inject_C_index -= 3;
 		}
@@ -1090,19 +1097,19 @@
 			strcat(lock_buf,buf+1);
 			};
 		strcat(lock_buf,"_MAX");
-		new_token_at(TokenList,STDINT_EXACT_SHRT_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
+		new_token_at(TmpTokenList,STDINT_EXACT_SHRT_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
 		++inject_CPP_index;
 		++inject_C_index;
 		if (!target_is_twos_complement)
 			{
-			TokenList.DeleteNSlotsAt(2,STDINT_EXACT_SHRT_LIMITS_LINEORIGIN);
+			TmpTokenList.DeleteNSlotsAt(2,STDINT_EXACT_SHRT_LIMITS_LINEORIGIN);
 			inject_CPP_index -= 2;
 			inject_C_index -= 2;
 			}
 		}
 	if (suppress[virtual_machine::std_int_char-1])
 		{
-		TokenList.DeleteNSlotsAt(3,STDINT_EXACT_CHAR_LIMITS_LINEORIGIN);
+		TmpTokenList.DeleteNSlotsAt(3,STDINT_EXACT_CHAR_LIMITS_LINEORIGIN);
 		inject_CPP_index -= 3;
 		inject_C_index -= 3;
 		}
@@ -1117,12 +1124,12 @@
 			strcat(lock_buf,buf+1);
 			};
 		strcat(lock_buf,"_MAX");
-		new_token_at(TokenList,STDINT_EXACT_CHAR_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
+		new_token_at(TmpTokenList,STDINT_EXACT_CHAR_LIMITS_LINEORIGIN+STDINT_UMAX_OFFSET+1,lock_buf);
 		++inject_CPP_index;
 		++inject_C_index;
 		if (!target_is_twos_complement)
 			{
-			TokenList.DeleteNSlotsAt(2,STDINT_EXACT_CHAR_LIMITS_LINEORIGIN);
+			TmpTokenList.DeleteNSlotsAt(2,STDINT_EXACT_CHAR_LIMITS_LINEORIGIN);
 			inject_CPP_index -= 2;
 			inject_C_index -= 2;
 			}
@@ -1196,7 +1203,7 @@
 		--inject_CPP_index;
 		--inject_C_index;
 		}
-	if (0<stack_size) TokenList.DeleteNSlots(stack,stack_size);	
+	if (0<stack_size) TmpTokenList.DeleteNSlots(stack,stack_size);	
 	}
 
 	// prepare to inject least/fast types and their adapter macros
@@ -1209,8 +1216,8 @@
 	const unsigned short bitspan_types = type_bits[virtual_machine::std_int_long_long-1]-7;
 	assert(USHRT_MAX/13>=bitspan_types);
 	i = 4*bitspan_types;
-	TokenList.InsertNSlotsAt(i,inject_CPP_index);
-	tmp = TokenList.c_array()+inject_CPP_index;
+	TmpTokenList.InsertNSlotsAt(i,inject_CPP_index);
+	tmp = TmpTokenList.c_array()+inject_CPP_index;
 	do	{
 		const int target_bits = --i/4+8;
 		assert(target_bits<=target_machine.C_bit(virtual_machine::std_int_long_long));
@@ -1256,8 +1263,8 @@
 	strcpy(define_buf,"#define ");
 #endif
 	i = 13*bitspan_types;
-	TokenList.InsertNSlotsAt(i,inject_C_index);
-	tmp = TokenList.c_array()+inject_C_index;
+	TmpTokenList.InsertNSlotsAt(i,inject_C_index);
+	tmp = TmpTokenList.c_array()+inject_C_index;
 	do	{
 		const int target_bits = --i/13+8;
 		assert(target_bits<=target_machine.C_bit(virtual_machine::std_int_long_long));
@@ -1372,6 +1379,7 @@
 		tmp[i] = new zaimoni::Token<char>(typedef_buf,0,strlen(typedef_buf),0);
 		}
 	while(0<i);
+	zaimoni::swap(TokenList,TmpTokenList);
 
 	final_init_tokenlist(TokenList.c_array(),TokenList.size(),header_name);
 }



From zaimoni at mail.berlios.de  Mon Apr 12 04:25:58 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 12 Apr 2010 04:25:58 +0200
Subject: [Zcplusplus-commits] r377 - in trunk: . tests/zcc/compat
Message-ID: <201004120225.o3C2PwRn002764@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-12 04:25:53 +0200 (Mon, 12 Apr 2010)
New Revision: 377

Added:
   trunk/tests/zcc/compat/Warn_enum_overflow.hpp
Modified:
   trunk/CSupport.cpp
Log:
-Wc-c++-compat now warns when an enumerator is default-initialized to INT_MAX+1

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-11 22:56:05 UTC (rev 376)
+++ trunk/CSupport.cpp	2010-04-12 02:25:53 UTC (rev 377)
@@ -11193,7 +11193,14 @@
 		//! \todo research how to rewrite this without the goto
 cpp_enum_was_retyped:
 		const promote_aux test(current_enumerator_type,types);
-		//! \bug need -Wc-c++-compat to go off here
+		// -Wc-c++-compat trips: C++ tolerates enumerator values that don't fit in int 
+		if (bool_options[boolopt::warn_crosslang_compatibility] && C_TYPE::INT==current_enumerator_type && prior_value==target_machine->signed_max(test.machine_type))
+			{	//! \test compat/Warn_enum_overflow.hpp
+			message_header(src);
+			INC_INFORM(WARN_STR);
+			INFORM("enumerator value not representable by int is an error in C (C99 6.7.2.2p3)");
+			if (bool_options[boolopt::warnings_are_errors]) zcc_errors.inc_error();
+			};
 		if (test.is_signed)
 			{
 			if (prior_value==target_machine->signed_max(test.machine_type))
@@ -11534,6 +11541,109 @@
 		if (allow_empty)
 			{	// C++
 			current_enumerator_type = tmp.type_code.base_type_index;
+			const promote_aux test(current_enumerator_type,types);
+			if (latest_value.test(test.bitcount-1))
+				{	// negative
+				unsigned_var_int abs_latest_value(latest_value);
+				target_machine->signed_additive_inverse(abs_latest_value,test.machine_type);
+				if (virtual_machine::twos_complement==target_machine->C_signed_int_representation() && !bool_options[boolopt::int_traps])
+					abs_latest_value-=1;
+				cpp_using_negative = true;
+				// sign filter
+				switch(base_enum_type)
+				{
+				case C_TYPE::INT:
+				case C_TYPE::LONG:
+				case C_TYPE::LLONG:
+					break;	// these three are already signed, no representation change incurred
+				case C_TYPE::UINT:
+					if (target_machine->C_sizeof_int()<target_machine->C_sizeof_long())
+						{
+						base_enum_type = C_TYPE::LONG;
+						break;
+						}
+				case C_TYPE::ULONG:
+					if (target_machine->C_sizeof_long()<target_machine->C_sizeof_long_long())
+						{
+						base_enum_type = C_TYPE::LLONG;
+						break;
+						}
+				default:	//! \bug needs test case
+					message_header(src.data<0>()[origin-2].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("enumeration requires both negative values and values above INTMAX_MAX, underlying type doesn't exist (C++0X 7.2p6)");
+					zcc_errors.inc_error();
+					return false;
+				}
+				// value filter
+				switch(base_enum_type)
+				{
+				case C_TYPE::INT:
+					if (target_machine->signed_max<virtual_machine::std_int_int>()>=abs_latest_value) break;
+					base_enum_type = C_TYPE::LONG;
+				case C_TYPE::LONG:
+					if (target_machine->signed_max<virtual_machine::std_int_long>()>=abs_latest_value) break;
+					base_enum_type = C_TYPE::LLONG;
+				case C_TYPE::LLONG:
+					if (target_machine->signed_max<virtual_machine::std_int_long_long>()>=abs_latest_value) break;
+				default:	//! \bug needs test case
+					message_header(src.data<0>()[origin-2].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("enumeration requires value below INTMAX_MIN, underlying type doesn't exist (C++0X 7.2p6)");
+					zcc_errors.inc_error();
+					return false;
+				}
+				}
+			else{	// positive
+				if (cpp_using_negative)
+					{
+					switch(base_enum_type)
+					{
+					case C_TYPE::INT:
+						if (target_machine->signed_max<virtual_machine::std_int_int>()>=latest_value) break;
+						base_enum_type = C_TYPE::LONG;
+					case C_TYPE::LONG:
+						if (target_machine->signed_max<virtual_machine::std_int_long>()>=latest_value) break;
+						base_enum_type = C_TYPE::LLONG;
+					case C_TYPE::LLONG:
+						if (target_machine->signed_max<virtual_machine::std_int_long_long>()>=latest_value) break;
+					default:	//! \bug needs test case
+						message_header(src.data<0>()[origin-2].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("enumeration requires both negative values and values above INTMAX_MAX, underlying type doesn't exist (C++0X 7.2p6)");
+						zcc_errors.inc_error();
+						return false;
+					}
+					}
+				else{
+					switch(base_enum_type)
+					{
+					case C_TYPE::INT:
+						if (target_machine->signed_max<virtual_machine::std_int_int>()>=latest_value) break;
+						base_enum_type = C_TYPE::UINT;
+					case C_TYPE::UINT:
+						if (target_machine->unsigned_max<virtual_machine::std_int_int>()>=latest_value) break;
+						base_enum_type = C_TYPE::LONG;
+					case C_TYPE::LONG:
+						if (target_machine->signed_max<virtual_machine::std_int_long>()>=latest_value) break;
+						base_enum_type = C_TYPE::ULONG;
+					case C_TYPE::ULONG:
+						if (target_machine->unsigned_max<virtual_machine::std_int_long>()>=latest_value) break;
+						base_enum_type = C_TYPE::LLONG;
+					case C_TYPE::LLONG:
+						if (target_machine->signed_max<virtual_machine::std_int_long_long>()>=latest_value) break;
+						base_enum_type = C_TYPE::ULLONG;
+					case C_TYPE::ULLONG:
+						if (target_machine->unsigned_max<virtual_machine::std_int_long_long>()>=latest_value) break;
+					default:	//! \bug needs test case
+						message_header(src.data<0>()[origin-2].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("enumeration requires values above UINTMAX_MAX, underlying type doesn't exist (C++0X 7.2p6)");
+						zcc_errors.inc_error();
+						return false;
+					}
+					}
+				}
 			}
 		else{	// C
 			const promote_aux test(tmp.type_code.base_type_index,types);
@@ -11577,39 +11687,6 @@
 			types.set_enumerator_def_CPP(src.data<0>()[origin-2].index_tokens[0].token.first, active_namespace,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
 		else
 			types.set_enumerator_def(src.data<0>()[origin-2].index_tokens[0].token.first,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
-		if (allow_empty && !cpp_using_negative)
-			{
-			const promote_aux test(current_enumerator_type,types);
-			if (test.is_signed && latest_value.test(test.bitcount-1))
-				{
-				cpp_using_negative = true;
-				switch(base_enum_type)
-				{
-				case C_TYPE::INT:
-				case C_TYPE::LONG:
-				case C_TYPE::LLONG:
-					break;	// these three are already signed, no representation change incurred
-				case C_TYPE::UINT:
-					if (target_machine->C_sizeof_int()<target_machine->C_sizeof_long())
-						{
-						base_enum_type = C_TYPE::LONG;
-						break;
-						}
-				case C_TYPE::ULONG:
-					if (target_machine->C_sizeof_long()<target_machine->C_sizeof_long_long())
-						{
-						base_enum_type = C_TYPE::LLONG;
-						break;
-						}
-				default:	//! \bug needs test case
-					message_header(src.data<0>()[origin-2].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("enumeration requires both negative values and values above INTMAX_MAX, underlying type doesn't exist (C++0X 7.2p6)");
-					zcc_errors.inc_error();
-					return false;
-				}
-				}
-			}
 		}
 		}
 	// now ok to crunch underlying type/machine representation

Added: trunk/tests/zcc/compat/Warn_enum_overflow.hpp
===================================================================
--- trunk/tests/zcc/compat/Warn_enum_overflow.hpp	2010-04-11 22:56:05 UTC (rev 376)
+++ trunk/tests/zcc/compat/Warn_enum_overflow.hpp	2010-04-12 02:25:53 UTC (rev 377)
@@ -0,0 +1,15 @@
+// compat/Warn_enum_overflow.hpp
+// overflowing enum would fail in C
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#include <limits.h>
+#include <stdint.h>
+
+#if INT_MAX<UINTMAX_MAX
+enum bad_enum {
+	x = INT_MAX,
+	x1
+}
+#else
+#error test not meaningful for exotic target (INT_MAX==UINTMAX_MAX)
+#endif



From zaimoni at mail.berlios.de  Mon Apr 12 04:45:32 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 12 Apr 2010 04:45:32 +0200
Subject: [Zcplusplus-commits] r378 - in trunk: . tests/zcc/decl.C99
Message-ID: <201004120245.o3C2jWa5003451@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-12 04:45:25 +0200 (Mon, 12 Apr 2010)
New Revision: 378

Added:
   trunk/tests/zcc/decl.C99/Error_enum_nobase.hpp
   trunk/tests/zcc/decl.C99/Error_enum_nobase2.hpp
Modified:
   trunk/CSupport.cpp
Log:
error when C++ enumerators contain both negative values, and values exceeding INTMAX_MAX

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-12 02:25:53 UTC (rev 377)
+++ trunk/CSupport.cpp	2010-04-12 02:45:25 UTC (rev 378)
@@ -11542,7 +11542,7 @@
 			{	// C++
 			current_enumerator_type = tmp.type_code.base_type_index;
 			const promote_aux test(current_enumerator_type,types);
-			if (latest_value.test(test.bitcount-1))
+			if (test.is_signed && latest_value.test(test.bitcount-1))
 				{	// negative
 				unsigned_var_int abs_latest_value(latest_value);
 				target_machine->signed_additive_inverse(abs_latest_value,test.machine_type);
@@ -11568,7 +11568,7 @@
 						base_enum_type = C_TYPE::LLONG;
 						break;
 						}
-				default:	//! \bug needs test case
+				default:	//! \test decl.C99\Error_enum_nobase.hpp
 					message_header(src.data<0>()[origin-2].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INFORM("enumeration requires both negative values and values above INTMAX_MAX, underlying type doesn't exist (C++0X 7.2p6)");
@@ -11607,7 +11607,7 @@
 						base_enum_type = C_TYPE::LLONG;
 					case C_TYPE::LLONG:
 						if (target_machine->signed_max<virtual_machine::std_int_long_long>()>=latest_value) break;
-					default:	//! \bug needs test case
+					default:	//! \test decl.C99\Error_enum_nobase2.hpp
 						message_header(src.data<0>()[origin-2].index_tokens[0]);
 						INC_INFORM(ERR_STR);
 						INFORM("enumeration requires both negative values and values above INTMAX_MAX, underlying type doesn't exist (C++0X 7.2p6)");

Added: trunk/tests/zcc/decl.C99/Error_enum_nobase.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_nobase.hpp	2010-04-12 02:25:53 UTC (rev 377)
+++ trunk/tests/zcc/decl.C99/Error_enum_nobase.hpp	2010-04-12 02:45:25 UTC (rev 378)
@@ -0,0 +1,14 @@
+// decl.C99\Error_enum_nobase.hpp
+// overflowing enum doesn't work
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#include <stdint.h>
+
+#if INT_MAX<UINTMAX_MAX
+enum bad_enum {
+	x = UINTMAX_MAX,
+	y = -1
+}
+#else
+#error test not meaningful for exotic target (INT_MAX==UINTMAX_MAX)
+#endif

Added: trunk/tests/zcc/decl.C99/Error_enum_nobase2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_enum_nobase2.hpp	2010-04-12 02:25:53 UTC (rev 377)
+++ trunk/tests/zcc/decl.C99/Error_enum_nobase2.hpp	2010-04-12 02:45:25 UTC (rev 378)
@@ -0,0 +1,14 @@
+// decl.C99\Error_enum_nobase2.hpp
+// overflowing enum doesn't work
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#include <stdint.h>
+
+#if INT_MAX<UINTMAX_MAX
+enum bad_enum {
+	x = -1,
+	y = UINTMAX_MAX
+}
+#else
+#error test not meaningful for exotic target (INT_MAX==UINTMAX_MAX)
+#endif



From zaimoni at mail.berlios.de  Mon Apr 12 06:02:57 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 12 Apr 2010 06:02:57 +0200
Subject: [Zcplusplus-commits] r379 - trunk
Message-ID: <201004120402.o3C42vr7006725@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-12 06:02:52 +0200 (Mon, 12 Apr 2010)
New Revision: 379

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
minor improvements to vi readability; adjust in-source documentation of test cases

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-12 02:45:25 UTC (rev 378)
+++ trunk/CSupport.cpp	2010-04-12 04:02:52 UTC (rev 379)
@@ -7950,7 +7950,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_shift_expression(src,i)) C_shift_expression_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_shift_expression(src,i))
+		C_shift_expression_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 /*
@@ -8156,7 +8157,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_relation_expression(src,i)) C_relation_expression_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_relation_expression(src,i))
+		C_relation_expression_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 /*
@@ -8395,7 +8397,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_C99_equality_expression(src,i)) C_equality_expression_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_C99_equality_expression(src,i))
+		C_equality_expression_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 /*
@@ -8592,7 +8595,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_C99_bitwise_AND(src,i)) C_bitwise_AND_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_C99_bitwise_AND(src,i))
+		C_bitwise_AND_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 /*
@@ -11661,11 +11665,12 @@
 				}
 			if (out_of_range)
 				{	//! \test decl.C99/Error_enum_overflow2.h
-					//! \bug need -Wc-c++-compat to go off here
 				message_header(src.data<0>()[origin-2].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("initializer of enumerator not representable as signed int (C99 6.7.2.2p3)");
 				zcc_errors.inc_error();
+				if (bool_options[boolopt::warn_crosslang_compatibility])
+					INFORM("(this may be valid C++, if the value is representable as either uintmax_t or intmax_t)");
 				return false;
 				}
 			if (is_negative)
@@ -12084,7 +12089,7 @@
 									zcc_errors.inc_error();
 								}
 							else{	// error if there is a prior, inconsistent definition
-									//! \test zcc/decl.C99/Warn_redeclare_typedef.h
+									//! \test zcc/decl.C99/Error_redeclare_typedef.h
 								message_header(src.data<0>()[initdecl_identifier_idx].index_tokens[0]);
 								INC_INFORM(ERR_STR);
 								INC_INFORM("redeclaring typedef ");
@@ -12100,10 +12105,9 @@
 						else{	// prepare to register this with types object
 							const type_system::enumerator_info* tmp2 = types.get_enumerator(src.data<0>()[initdecl_identifier_idx].index_tokens[0].token.first);
 							if (tmp2)
-								{	//! \bug needs test case
+								{	//! \test zcc/decl.C99/Error_typedef_enum.h
 								message_header(src.data<0>()[i].index_tokens[0]);
 								INC_INFORM(ERR_STR);
-//								INFORM("enumerator is already defined, conflicts with typedef (C99 6.7.2.2p3/C++98 3.2)");
 								INFORM("enumerator is already defined, conflicts with typedef (C99 6.7.2.2p3)");
 								INC_INFORM(tmp2->second.second.first);
 								INC_INFORM(":");
@@ -12849,7 +12853,8 @@
 							free(namespace_name);
 							const type_system::enumerator_info* tmp2 = types.get_enumerator_CPP(src.data<0>()[initdecl_identifier_idx].index_tokens[0].token.first,active_namespace);
 							if (tmp2)
-								{	//! \bug needs test case
+								{	//! \test zcc/decl.C99/Error_typedef_enum.hpp
+									//! \test zcc/decl.C99/Error_typedef_enum2.hpp
 								message_header(src.data<0>()[i].index_tokens[0]);
 								INC_INFORM(ERR_STR);
 								INFORM("enumerator is already defined, conflicts with typedef (C++98 3.2)");
@@ -12968,8 +12973,7 @@
 }
 #endif
 
-void
-InitializeCLexerDefs(const virtual_machine::CPUInfo& target)
+void InitializeCLexerDefs(const virtual_machine::CPUInfo& target)
 {
 	// main code
 	target_machine = &target;

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-04-12 02:45:25 UTC (rev 378)
+++ trunk/CSupport_pp.cpp	2010-04-12 04:02:52 UTC (rev 379)
@@ -7138,7 +7138,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_shift_expression(src,i)) C_shift_expression_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_shift_expression(src,i))
+		C_shift_expression_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 /*
@@ -7344,7 +7345,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_relation_expression(src,i)) C_relation_expression_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_relation_expression(src,i))
+		C_relation_expression_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 /*
@@ -7583,7 +7585,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_C99_equality_expression(src,i)) C_equality_expression_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_C99_equality_expression(src,i))
+		C_equality_expression_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 /*
@@ -7760,7 +7763,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_C99_bitwise_AND(src,i)) C_bitwise_AND_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_C99_bitwise_AND(src,i))
+		C_bitwise_AND_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 /*
@@ -9616,8 +9620,7 @@
 }
 #endif
 
-void
-InitializeCLexerDefs(const virtual_machine::CPUInfo& target)
+void InitializeCLexerDefs(const virtual_machine::CPUInfo& target)
 {
 	// main code
 	target_machine = &target;



From zaimoni at mail.berlios.de  Wed Apr 14 10:14:22 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 14 Apr 2010 10:14:22 +0200
Subject: [Zcplusplus-commits] r380 - trunk/Zaimoni.STL
Message-ID: <201004140814.o3E8EMEN002134@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-14 10:14:19 +0200 (Wed, 14 Apr 2010)
New Revision: 380

Modified:
   trunk/Zaimoni.STL/MetaRAM2.hpp
Log:
math AI Franci requires this fix

Modified: trunk/Zaimoni.STL/MetaRAM2.hpp
===================================================================
--- trunk/Zaimoni.STL/MetaRAM2.hpp	2010-04-12 04:02:52 UTC (rev 379)
+++ trunk/Zaimoni.STL/MetaRAM2.hpp	2010-04-14 08:14:19 UTC (rev 380)
@@ -164,7 +164,7 @@
 inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
 _new_buffer_uninitialized(size_t Idx)
 {
-	if (((size_t)(-1))/sizeof(T)>=Idx) return NULL; // CERT C MEM07
+	if (((size_t)(-1))/sizeof(T)<Idx) return NULL; // CERT C MEM07
 	return reinterpret_cast<T*>(malloc(Idx*sizeof(T)));
 }
 
@@ -172,7 +172,7 @@
 inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
 _new_buffer_uninitialized_nonNULL(size_t Idx)
 {
-	if (((size_t)(-1))/sizeof(T)>=Idx) // CERT C MEM07
+	if (((size_t)(-1))/sizeof(T)<Idx) // CERT C MEM07
 		_fatal("requested memory exceeds SIZE_T_MAX");
 	T* tmp = reinterpret_cast<T*>(malloc(Idx*sizeof(T)));
 	if (NULL==tmp) _fatal("Irrecoverable failure to allocate memory");
@@ -183,7 +183,7 @@
 inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
 _new_buffer_uninitialized_nonNULL_throws(size_t Idx)
 {
-	if (((size_t)(-1))/sizeof(T)>=Idx) throw std::bad_alloc(); // CERT C MEM07
+	if (((size_t)(-1))/sizeof(T)<Idx) throw std::bad_alloc(); // CERT C MEM07
 	T* tmp = reinterpret_cast<T*>(malloc(Idx*sizeof(T)));
 	if (NULL==tmp) throw std::bad_alloc();
 	return tmp;



From zaimoni at mail.berlios.de  Sat Apr 17 20:12:02 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 17 Apr 2010 20:12:02 +0200
Subject: [Zcplusplus-commits] r381 - trunk
Message-ID: <201004171812.o3HIC2QS007772@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-17 20:11:58 +0200 (Sat, 17 Apr 2010)
New Revision: 381

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
fix sizeof to not hit asserts

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-14 08:14:19 UTC (rev 380)
+++ trunk/CSupport.cpp	2010-04-17 18:11:58 UTC (rev 381)
@@ -5304,6 +5304,7 @@
 // return code is true for success, false for memory failure
 static bool VM_to_token(const umaxint& src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
 {
+	assert(C_TYPE::INT<=base_type_index && C_TYPE::ULLONG>=base_type_index);
 	const char* const suffix = literal_suffix(base_type_index);
 #ifdef ZCC_LEGACY_FIXED_INT
 	char buf[(VM_MAX_BIT_PLATFORM/3)+4];	// null-termination: 1 byte; 3 bytes for type hint
@@ -6207,6 +6208,7 @@
 	//! \todo types parameter is close to redundant
 	// floating is just a matter of modeling
 	// complex may also involve ABI issues (cf. Intel)
+	const size_t size_t_type = unsigned_type_from_machine_type(target_machine->size_t_type());
 	parse_tree tmp;
 	switch(base_type_index)
 	{
@@ -6216,37 +6218,47 @@
 	case C_TYPE::UCHAR:
 		{	// defined to be 1: C99 6.5.3.4p3, C++98 5.3.3p1, same paragraphs in C1X and C++0X 
 		src.destroy();
-		src.index_tokens[0].token.first = "1";
-		src.index_tokens[0].token.second = 1;
+		src.index_tokens[0].token.first = "1U";
+		src.index_tokens[0].token.second = 2;
 		src.index_tokens[0].flags = (C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_INTEGER | C_TESTFLAG_DECIMAL);
-		}	
+		src.type_code.set_type(size_t_type);
+		break;
+		}
 	case C_TYPE::SHRT:
 	case C_TYPE::USHRT:
 		{
+		src.type_code.set_type(size_t_type);
 		if (!VM_to_literal(tmp,umaxint(target_machine->C_sizeof_short()),src,types)) return false;
 		src.destroy();
 		src = tmp;			
+		break;
 		}
 	case C_TYPE::INT:
 	case C_TYPE::UINT:
 		{
+		src.type_code.set_type(size_t_type);
 		if (!VM_to_literal(tmp,umaxint(target_machine->C_sizeof_int()),src,types)) return false;
 		src.destroy();
 		src = tmp;			
+		break;
 		}
 	case C_TYPE::LONG:
 	case C_TYPE::ULONG:
 		{
+		src.type_code.set_type(size_t_type);
 		if (!VM_to_literal(tmp,umaxint(target_machine->C_sizeof_long()),src,types)) return false;
 		src.destroy();
 		src = tmp;			
+		break;
 		}
 	case C_TYPE::LLONG:
 	case C_TYPE::ULLONG:
 		{
+		src.type_code.set_type(size_t_type);
 		if (!VM_to_literal(tmp,umaxint(target_machine->C_sizeof_long_long()),src,types)) return false;
 		src.destroy();
 		src = tmp;			
+//		break;
 		}
 	}
 #if 0
@@ -6257,7 +6269,7 @@
 	DOUBLE__COMPLEX,
 	LDOUBLE__COMPLEX,
 #endif
-	src.type_code.set_type(unsigned_type_from_machine_type(target_machine->size_t_type()));
+	assert(size_t_type==src.type_code.base_type_index);
 	return true;
 }
 

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-04-14 08:14:19 UTC (rev 380)
+++ trunk/CSupport_pp.cpp	2010-04-17 18:11:58 UTC (rev 381)
@@ -4843,6 +4843,7 @@
 // return code is true for success, false for memory failure
 static bool VM_to_token(const umaxint& src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
 {
+	assert(C_TYPE::INT<=base_type_index && C_TYPE::ULLONG>=base_type_index);
 	const char* const suffix = literal_suffix(base_type_index);
 #ifdef ZCC_LEGACY_FIXED_INT
 	char buf[(VM_MAX_BIT_PLATFORM/3)+4];	// null-termination: 1 byte; 3 bytes for type hint



From zaimoni at mail.berlios.de  Sun Apr 18 01:30:33 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 18 Apr 2010 01:30:33 +0200
Subject: [Zcplusplus-commits] r382 - in trunk: . tests/zcc/staticassert.C1X
	tests/zcc.in/staticassert.C1X
Message-ID: <201004172330.o3HNUXtq005732@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-18 01:30:22 +0200 (Sun, 18 Apr 2010)
New Revision: 382

Modified:
   trunk/CSupport.cpp
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
Log:
bring up sizeof(char)==1

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-17 18:11:58 UTC (rev 381)
+++ trunk/CSupport.cpp	2010-04-17 23:30:22 UTC (rev 382)
@@ -4871,6 +4871,15 @@
 				value_copy(src.type_code,src.data<0>()->type_code);
 				return true;
 				}
+#/*cut-cpp*/
+			else if (PARSE_TYPE & src.data<0>()->flags)
+				{	// abuse: handle parenthesized type-specifiers here
+				src.flags &= parse_tree::RESERVED_MASK;	// just in case
+				src.flags |= (PARSE_TYPE & src.data<0>()->flags);
+				value_copy(src.type_code,src.data<0>()->type_code);
+				return false;	// not an expression 
+				}
+#/*cut-cpp*/
 			};
 		}
 	return false;
@@ -6222,6 +6231,7 @@
 		src.index_tokens[0].token.second = 2;
 		src.index_tokens[0].flags = (C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_INTEGER | C_TESTFLAG_DECIMAL);
 		src.type_code.set_type(size_t_type);
+		src.flags |= (PARSE_PRIMARY_EXPRESSION | parse_tree::CONSTANT_EXPRESSION);
 		break;
 		}
 	case C_TYPE::SHRT:
@@ -11740,7 +11750,7 @@
 		// C static assertion scanner
 		if (robust_token_is_string<14>(src.data<0>()[i],"_Static_Assert"))
 			{	// _Static_Assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CLexer->pp_support,i," : control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)",NULL);
+			C99_CPP_handle_static_assertion(src,types,*CLexer->pp_support,i,"control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)",NULL);
 			continue;
 			};
 		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
@@ -12228,7 +12238,7 @@
 		// C++ static assertion scanner
 		if (robust_token_is_string<13>(src.data<0>()[i],"static_assert"))
 			{	// static_assert ( constant-expression , string-literal ) ;
-			C99_CPP_handle_static_assertion(src,types,*CPlusPlusLexer->pp_support,i," : control expression for static assertion must be a constant convertible to bool (C++0X 7p4)",active_namespace);
+			C99_CPP_handle_static_assertion(src,types,*CPlusPlusLexer->pp_support,i,"control expression for static assertion must be a constant convertible to bool (C++0X 7p4)",active_namespace);
 			continue;
 			};
 		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-04-17 18:11:58 UTC (rev 381)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-04-17 23:30:22 UTC (rev 382)
@@ -211,3 +211,13 @@
 _Static_Assert(1 ? 1 : 0,"automatic success has failed");
 _Static_Assert(1 ? 1 : 1,"automatic success has failed");
 
+// check sizeof
+_Static_Assert(1==sizeof 'A',"automatic success has failed");
+_Static_Assert(1==sizeof(char),"automatic success has failed");
+_Static_Assert(1==sizeof(signed char),"automatic success has failed");
+_Static_Assert(1==sizeof(unsigned char),"automatic success has failed");
+
+_Static_Assert(sizeof 'A'==1,"automatic success has failed");
+_Static_Assert(sizeof(char)==1,"automatic success has failed");
+_Static_Assert(sizeof(signed char)==1,"automatic success has failed");
+_Static_Assert(sizeof(unsigned char)==1,"automatic success has failed");

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-04-17 18:11:58 UTC (rev 381)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-04-17 23:30:22 UTC (rev 382)
@@ -211,3 +211,13 @@
 static_assert(1 ? 1 : 0,"automatic success has failed");
 static_assert(1 ? 1 : 1,"automatic success has failed");
 
+// check sizeof
+static_assert(1==sizeof 'A',"automatic success has failed");
+static_assert(1==sizeof(char),"automatic success has failed");
+static_assert(1==sizeof(signed char),"automatic success has failed");
+static_assert(1==sizeof(unsigned char),"automatic success has failed");
+
+static_assert(sizeof 'A'==1,"automatic success has failed");
+static_assert(sizeof(char)==1,"automatic success has failed");
+static_assert(sizeof(signed char)==1,"automatic success has failed");
+static_assert(sizeof(unsigned char)==1,"automatic success has failed");

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-17 18:11:58 UTC (rev 381)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-17 23:30:22 UTC (rev 382)
@@ -212,3 +212,13 @@
 STATIC_ASSERT(1 ? 1 : 0,"automatic success has failed");
 STATIC_ASSERT(1 ? 1 : 1,"automatic success has failed");
 
+// check sizeof
+STATIC_ASSERT(1==sizeof 'A',"automatic success has failed");
+STATIC_ASSERT(1==sizeof(char),"automatic success has failed");
+STATIC_ASSERT(1==sizeof(signed char),"automatic success has failed");
+STATIC_ASSERT(1==sizeof(unsigned char),"automatic success has failed");
+
+STATIC_ASSERT(sizeof 'A'==1,"automatic success has failed");
+STATIC_ASSERT(sizeof(char)==1,"automatic success has failed");
+STATIC_ASSERT(sizeof(signed char)==1,"automatic success has failed");
+STATIC_ASSERT(sizeof(unsigned char)==1,"automatic success has failed");



From zaimoni at mail.berlios.de  Mon Apr 19 18:42:40 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 19 Apr 2010 18:42:40 +0200
Subject: [Zcplusplus-commits] r383 - in trunk/tests: zcc/staticassert.C1X
	zcc.in/staticassert.C1X
Message-ID: <201004191642.o3JGgeYL022356@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-19 18:42:36 +0200 (Mon, 19 Apr 2010)
New Revision: 383

Modified:
   trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
Log:
some more basic checks on sizeof operator

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-04-17 23:30:22 UTC (rev 382)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2010-04-19 16:42:36 UTC (rev 383)
@@ -211,7 +211,7 @@
 _Static_Assert(1 ? 1 : 0,"automatic success has failed");
 _Static_Assert(1 ? 1 : 1,"automatic success has failed");
 
-// check sizeof
+// check sizeof: sizeof(char)==1 and so on
 _Static_Assert(1==sizeof 'A',"automatic success has failed");
 _Static_Assert(1==sizeof(char),"automatic success has failed");
 _Static_Assert(1==sizeof(signed char),"automatic success has failed");
@@ -221,3 +221,29 @@
 _Static_Assert(sizeof(char)==1,"automatic success has failed");
 _Static_Assert(sizeof(signed char)==1,"automatic success has failed");
 _Static_Assert(sizeof(unsigned char)==1,"automatic success has failed");
+
+// other target-independent reality checks on sizeof
+_Static_Assert(sizeof(short),"automatic success has failed");
+_Static_Assert(sizeof(signed short),"automatic success has failed");
+_Static_Assert(sizeof(unsigned short),"automatic success has failed");
+
+_Static_Assert(sizeof(int),"automatic success has failed");
+_Static_Assert(sizeof(signed int),"automatic success has failed");
+_Static_Assert(sizeof(unsigned int),"automatic success has failed");
+_Static_Assert(sizeof(signed),"automatic success has failed");
+_Static_Assert(sizeof(unsigned),"automatic success has failed");
+
+_Static_Assert(sizeof(long),"automatic success has failed");
+_Static_Assert(sizeof(signed long),"automatic success has failed");
+_Static_Assert(sizeof(unsigned long),"automatic success has failed");
+_Static_Assert(sizeof(long int),"automatic success has failed");
+_Static_Assert(sizeof(signed long int),"automatic success has failed");
+_Static_Assert(sizeof(unsigned long int),"automatic success has failed");
+
+_Static_Assert(sizeof(long long),"automatic success has failed");
+_Static_Assert(sizeof(signed long long),"automatic success has failed");
+_Static_Assert(sizeof(unsigned long long),"automatic success has failed");
+_Static_Assert(sizeof(long long int),"automatic success has failed");
+_Static_Assert(sizeof(signed long long int),"automatic success has failed");
+_Static_Assert(sizeof(unsigned long long int),"automatic success has failed");
+

Modified: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-04-17 23:30:22 UTC (rev 382)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2010-04-19 16:42:36 UTC (rev 383)
@@ -211,7 +211,7 @@
 static_assert(1 ? 1 : 0,"automatic success has failed");
 static_assert(1 ? 1 : 1,"automatic success has failed");
 
-// check sizeof
+// check sizeof: sizeof(char)==1 and so on
 static_assert(1==sizeof 'A',"automatic success has failed");
 static_assert(1==sizeof(char),"automatic success has failed");
 static_assert(1==sizeof(signed char),"automatic success has failed");
@@ -221,3 +221,29 @@
 static_assert(sizeof(char)==1,"automatic success has failed");
 static_assert(sizeof(signed char)==1,"automatic success has failed");
 static_assert(sizeof(unsigned char)==1,"automatic success has failed");
+
+// other target-independent reality checks on sizeof
+static_assert(sizeof(short),"automatic success has failed");
+static_assert(sizeof(signed short),"automatic success has failed");
+static_assert(sizeof(unsigned short),"automatic success has failed");
+
+static_assert(sizeof(int),"automatic success has failed");
+static_assert(sizeof(signed int),"automatic success has failed");
+static_assert(sizeof(unsigned int),"automatic success has failed");
+static_assert(sizeof(signed),"automatic success has failed");
+static_assert(sizeof(unsigned),"automatic success has failed");
+
+static_assert(sizeof(long),"automatic success has failed");
+static_assert(sizeof(signed long),"automatic success has failed");
+static_assert(sizeof(unsigned long),"automatic success has failed");
+static_assert(sizeof(long int),"automatic success has failed");
+static_assert(sizeof(signed long int),"automatic success has failed");
+static_assert(sizeof(unsigned long int),"automatic success has failed");
+
+static_assert(sizeof(long long),"automatic success has failed");
+static_assert(sizeof(signed long long),"automatic success has failed");
+static_assert(sizeof(unsigned long long),"automatic success has failed");
+static_assert(sizeof(long long int),"automatic success has failed");
+static_assert(sizeof(signed long long int),"automatic success has failed");
+static_assert(sizeof(unsigned long long int),"automatic success has failed");
+

Modified: trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-17 23:30:22 UTC (rev 382)
+++ trunk/tests/zcc.in/staticassert.C1X/Pass_autosuccess.in	2010-04-19 16:42:36 UTC (rev 383)
@@ -212,7 +212,7 @@
 STATIC_ASSERT(1 ? 1 : 0,"automatic success has failed");
 STATIC_ASSERT(1 ? 1 : 1,"automatic success has failed");
 
-// check sizeof
+// check sizeof: sizeof(char)==1 and so on
 STATIC_ASSERT(1==sizeof 'A',"automatic success has failed");
 STATIC_ASSERT(1==sizeof(char),"automatic success has failed");
 STATIC_ASSERT(1==sizeof(signed char),"automatic success has failed");
@@ -222,3 +222,29 @@
 STATIC_ASSERT(sizeof(char)==1,"automatic success has failed");
 STATIC_ASSERT(sizeof(signed char)==1,"automatic success has failed");
 STATIC_ASSERT(sizeof(unsigned char)==1,"automatic success has failed");
+
+// other target-independent reality checks on sizeof
+STATIC_ASSERT(sizeof(short),"automatic success has failed");
+STATIC_ASSERT(sizeof(signed short),"automatic success has failed");
+STATIC_ASSERT(sizeof(unsigned short),"automatic success has failed");
+
+STATIC_ASSERT(sizeof(int),"automatic success has failed");
+STATIC_ASSERT(sizeof(signed int),"automatic success has failed");
+STATIC_ASSERT(sizeof(unsigned int),"automatic success has failed");
+STATIC_ASSERT(sizeof(signed),"automatic success has failed");
+STATIC_ASSERT(sizeof(unsigned),"automatic success has failed");
+
+STATIC_ASSERT(sizeof(long),"automatic success has failed");
+STATIC_ASSERT(sizeof(signed long),"automatic success has failed");
+STATIC_ASSERT(sizeof(unsigned long),"automatic success has failed");
+STATIC_ASSERT(sizeof(long int),"automatic success has failed");
+STATIC_ASSERT(sizeof(signed long int),"automatic success has failed");
+STATIC_ASSERT(sizeof(unsigned long int),"automatic success has failed");
+
+STATIC_ASSERT(sizeof(long long),"automatic success has failed");
+STATIC_ASSERT(sizeof(signed long long),"automatic success has failed");
+STATIC_ASSERT(sizeof(unsigned long long),"automatic success has failed");
+STATIC_ASSERT(sizeof(long long int),"automatic success has failed");
+STATIC_ASSERT(sizeof(signed long long int),"automatic success has failed");
+STATIC_ASSERT(sizeof(unsigned long long int),"automatic success has failed");
+



From zaimoni at mail.berlios.de  Tue Apr 20 21:30:43 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 20 Apr 2010 21:30:43 +0200
Subject: [Zcplusplus-commits] r384 - trunk
Message-ID: <201004201930.o3KJUhsV014530@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-20 21:30:40 +0200 (Tue, 20 Apr 2010)
New Revision: 384

Modified:
   trunk/type_system.cpp
   trunk/unsigned_var_int.cpp
Log:
code and memory management cleanup

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2010-04-19 16:42:36 UTC (rev 383)
+++ trunk/type_system.cpp	2010-04-20 19:30:40 UTC (rev 384)
@@ -59,9 +59,8 @@
 	// it was remapped
 	while(tmp2.first<tmp2.second)
 		{
-		tmp = _get_id_union(inline_namespace_alias_map.data()[tmp2.first].second);
+		tmp = _get_id_union(inline_namespace_alias_map.data()[tmp2.first++].second);
 		if (0<tmp) return tmp;
-		++tmp2.first;
 		}
 	return _get_id_union(inline_namespace_alias_map.data()[tmp2.first].second);
 }
@@ -94,8 +93,7 @@
 			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
 			size_t i = extra_namespaces;
 			do	{
-				--i;
-				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,"::");
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[--i]-active_namespace,"::");
 				const type_index tmp2 = _get_id_union_CPP(tmp_alias);
 				if (tmp2) return (free(tmp_alias),tmp2);
 				}
@@ -147,9 +145,8 @@
 	// it was remapped
 	while(tmp2.first<tmp2.second)
 		{
-		tmp = _get_id_struct_class(inline_namespace_alias_map.data()[tmp2.first].second);
+		tmp = _get_id_struct_class(inline_namespace_alias_map.data()[tmp2.first++].second);
 		if (0<tmp) return tmp;
-		++tmp2.first;
 		}
 	return _get_id_struct_class(inline_namespace_alias_map.data()[tmp2.first].second);
 }
@@ -182,8 +179,7 @@
 			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
 			size_t i = extra_namespaces;
 			do	{
-				--i;
-				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,"::");
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[--i]-active_namespace,"::");
 				const type_index tmp2 = _get_id_struct_class_CPP(tmp_alias);
 				if (tmp2) return (free(tmp_alias),tmp2);
 				}
@@ -225,9 +221,8 @@
 	// it was remapped
 	while(tmp2.first<tmp2.second)
 		{
-		tmp = _get_id_enum(inline_namespace_alias_map.data()[tmp2.first].second);
+		tmp = _get_id_enum(inline_namespace_alias_map.data()[tmp2.first++].second);
 		if (0<tmp) return tmp;
-		++tmp2.first;
 		}
 	return _get_id_enum(inline_namespace_alias_map.data()[tmp2.first].second);
 }
@@ -260,8 +255,7 @@
 			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
 			size_t i = extra_namespaces;
 			do	{
-				--i;
-				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,"::");
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[--i]-active_namespace,"::");
 				const type_index tmp2 = _get_id_enum_CPP(tmp_alias);
 				if (tmp2) return (free(tmp_alias),tmp2);
 				}
@@ -333,9 +327,8 @@
 	// it was remapped
 	while(tmp2.first<tmp2.second)
 		{
-		tmp = get_typedef(inline_namespace_alias_map.data()[tmp2.first].second);
+		tmp = get_typedef(inline_namespace_alias_map.data()[tmp2.first++].second);
 		if (tmp) return tmp;
-		++tmp2.first;
 		}
 	return get_typedef(inline_namespace_alias_map.data()[tmp2.first].second);
 }
@@ -367,8 +360,7 @@
 			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
 			size_t i = extra_namespaces;
 			do	{
-				--i;
-				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,"::");
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[--i]-active_namespace,"::");
 				const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp2 = _get_typedef_CPP(tmp_alias);
 				if (tmp2) return (free(tmp_alias),tmp2);
 				}
@@ -434,9 +426,8 @@
 	// it was remapped
 	while(tmp2.first<tmp2.second)
 		{
-		tmp = get_enumerator(inline_namespace_alias_map.data()[tmp2.first].second);
+		tmp = get_enumerator(inline_namespace_alias_map.data()[tmp2.first++].second);
 		if (tmp) return tmp;
-		++tmp2.first;
 		}
 	return get_enumerator(inline_namespace_alias_map.data()[tmp2.first].second);
 }
@@ -468,8 +459,7 @@
 			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
 			size_t i = extra_namespaces;
 			do	{
-				--i;
-				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[i]-active_namespace,"::");
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[--i]-active_namespace,"::");
 				const enumerator_info* tmp2 = _get_enumerator_CPP(tmp_alias);
 				if (tmp2) return (free(tmp_alias),tmp2);
 				}
@@ -761,7 +751,11 @@
 	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_C_STRUCTDEF}};
 	tmp.third.first.third = new C_union_struct_def((union_struct_decl::keywords)keyword,alias,logical_line,src_filename);
 
-	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
+	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp))
+		{
+		delete tmp.third.first.third;
+		throw std::bad_alloc();
+		}
 	return dynamic_types_size+1+core_types_size;
 }
 
@@ -781,15 +775,20 @@
 {
 	assert(alias && *alias);
 	assert(src_filename && *src_filename);
-	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_ENUMDEF}};
-	tmp.third.first.fourth = new enum_def(alias,logical_line,src_filename);
-
 	const size_t dynamic_types_size = dynamic_types.size();
 	const size_t dynamic_types_max_size = dynamic_types.max_size();
 	if (	dynamic_types_max_size<2+core_types_size
 		|| 	dynamic_types_max_size-(2+core_types_size)<dynamic_types_size)
 		FATAL("Host implementation limit exceeded: cannot record enum type used in program");
-	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
+
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_ENUMDEF}};
+	tmp.third.first.fourth = new enum_def(alias,logical_line,src_filename);
+
+	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp))
+		{
+		delete tmp.third.first.fourth;
+		throw std::bad_alloc();
+		}
 	return dynamic_types_size+1+core_types_size;
 }
 
@@ -809,8 +808,7 @@
 {
 	if (core_types_size>=i) return NULL;
 	i -= core_types_size;
-	--i;
-	if (dynamic_types.size()<=i) return NULL;
+	if (dynamic_types.size()<= --i) return NULL;
 	const dynamic_type_format& tmp = dynamic_types[i];
 	if (DYNAMIC_FUNCTYPE!=tmp.third.second) return NULL;
 	return tmp.third.first.first;
@@ -820,8 +818,7 @@
 {
 	if (core_types_size>=i) return NULL;
 	i -= core_types_size;
-	--i;
-	if (dynamic_types.size()<=i) return NULL;
+	if (dynamic_types.size()<= --i) return NULL;
 	const dynamic_type_format& tmp = dynamic_types[i];
 	if (DYNAMIC_STRUCTDECL!=tmp.third.second) return NULL;
 	return tmp.third.first.second;
@@ -831,8 +828,7 @@
 {
 	if (core_types_size>=i) return NULL;
 	i -= core_types_size;
-	--i;
-	if (dynamic_types.size()<=i) return NULL;
+	if (dynamic_types.size()<= --i) return NULL;
 	const dynamic_type_format& tmp = dynamic_types[i];
 	if (DYNAMIC_C_STRUCTDEF!=tmp.third.second) return NULL;
 	return tmp.third.first.third;
@@ -842,8 +838,7 @@
 {
 	if (core_types_size>=i) return NULL;
 	i -= core_types_size;
-	--i;
-	if (dynamic_types.size()<=i) return NULL;
+	if (dynamic_types.size()<= --i) return NULL;
 	const dynamic_type_format& tmp = dynamic_types[i];
 	if (DYNAMIC_ENUMDEF!=tmp.third.second) return NULL;
 	return tmp.third.first.fourth;

Modified: trunk/unsigned_var_int.cpp
===================================================================
--- trunk/unsigned_var_int.cpp	2010-04-19 16:42:36 UTC (rev 383)
+++ trunk/unsigned_var_int.cpp	2010-04-20 19:30:40 UTC (rev 384)
@@ -109,7 +109,8 @@
 {
 	unsigned_var_int tmp(0,size());
 	unsigned_mult(tmp.c_array(),tmp.size(),data(),size(),rhs.data(),rhs.size());
-	return *this = tmp;
+	tmp.MoveInto(*this);
+	return *this;
 }
 
 unsigned_var_int& unsigned_var_int::operator&=(const unsigned_var_int& rhs)



From zaimoni at mail.berlios.de  Tue Apr 20 22:04:43 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 20 Apr 2010 22:04:43 +0200
Subject: [Zcplusplus-commits] r385 - in trunk/Zaimoni.STL: . Pure.C
	Pure.C/compile.test
Message-ID: <201004202004.o3KK4h6t017145@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-20 22:04:37 +0200 (Tue, 20 Apr 2010)
New Revision: 385

Added:
   trunk/Zaimoni.STL/Pure.C/compile.test/realloc_0.c
Modified:
   trunk/Zaimoni.STL/Pure.C/GNUmakefile
   trunk/Zaimoni.STL/Pure.C/NMakefile
   trunk/Zaimoni.STL/Pure.C/comptest.in
   trunk/Zaimoni.STL/z_memory.h
Log:
add behavior test for realloc(x,0)

Modified: trunk/Zaimoni.STL/Pure.C/GNUmakefile
===================================================================
--- trunk/Zaimoni.STL/Pure.C/GNUmakefile	2010-04-20 19:30:40 UTC (rev 384)
+++ trunk/Zaimoni.STL/Pure.C/GNUmakefile	2010-04-20 20:04:37 UTC (rev 385)
@@ -34,6 +34,9 @@
 	-$(CC) -oexists_MS_io_h.exe $(CFLAGS) -mconsole $(ARCH_FLAGS) compile.test/exists_MS_io_h.c
 	-./exists_MS_io_h.exe >> comptest.h
 	-rm exists_MS_io_h.exe
+	-$(CC) -orealloc_0.exe $(CFLAGS) -mconsole $(ARCH_FLAGS) compile.test/realloc_0.c
+	-./realloc_0.exe >> comptest.h
+	-rm realloc_0.exe
 
 .c.o:
 	$(CC) -c $< $(CFLAGS) $(ARCH_FLAGS) -o $*.o

Modified: trunk/Zaimoni.STL/Pure.C/NMakefile
===================================================================
--- trunk/Zaimoni.STL/Pure.C/NMakefile	2010-04-20 19:30:40 UTC (rev 384)
+++ trunk/Zaimoni.STL/Pure.C/NMakefile	2010-04-20 20:04:37 UTC (rev 385)
@@ -37,6 +37,10 @@
 	.\exists_MS_io_h.exe >> comptest.h
 	del exists_MS_io_h.exe.manifest
 	del exists_MS_io_h.exe
+	$(CC) /OUT:realloc_0.exe $(CFLAGS) compile.test/realloc_0.c
+	.\realloc_0.exe >> comptest.h
+	del realloc_0.exe.manifest
+	del realloc_0.exe
 
 # defaulting .c.obj
 z_format_util.lib: format_util.obj

Added: trunk/Zaimoni.STL/Pure.C/compile.test/realloc_0.c
===================================================================
--- trunk/Zaimoni.STL/Pure.C/compile.test/realloc_0.c	2010-04-20 19:30:40 UTC (rev 384)
+++ trunk/Zaimoni.STL/Pure.C/compile.test/realloc_0.c	2010-04-20 20:04:37 UTC (rev 385)
@@ -0,0 +1,18 @@
+/* realloc_0.c */
+/* tests for whether realloc(...,0) returns NULL */
+/* (C)2010 Kenneth Boyd, license: MIT.txt */
+
+#define STRING_LITERAL_TO_STDOUT(A) fwrite(A,sizeof(A)-1,1,stdout)
+
+#include <stdlib.h>
+#include <stdio.h>
+
+int main()
+{
+	char* test = (char*)(malloc(3));
+	if (!test) return 0;
+	char* test2 = (char*)(realloc(test,0));
+	if (!test2) STRING_LITERAL_TO_STDOUT("#define ZAIMONI_REALLOC_TO_ZERO_IS_NULL 1\n");
+	return 0;
+}
+

Modified: trunk/Zaimoni.STL/Pure.C/comptest.in
===================================================================
--- trunk/Zaimoni.STL/Pure.C/comptest.in	2010-04-20 19:30:40 UTC (rev 384)
+++ trunk/Zaimoni.STL/Pure.C/comptest.in	2010-04-20 20:04:37 UTC (rev 385)
@@ -1,6 +1,10 @@
 /* comptest.h */
 /* compile test summary */
-/* (C)2009 Kenneth Boyd, license: MIT.txt */
+/* (C)2009,2010 Kenneth Boyd, license: MIT.txt */
 
-/* HAVE_MICROSOFT_IO_H: #include <io.h> works and allows compiling Microsoft-specific idioms */
+/* ZAIMONI_HAVE_MICROSOFT_IO_H: #include <io.h> works and allows compiling 
+   Microsoft-specific idioms */
+/* ZAIMONI_REALLOC_TO_ZERO_IS_NULL: realloc(x,0) is NULL.  Prohibited by C99,
+   but allowed as an implementation-specific decision by C90 and very useful
+   for optimization purposes. */
 

Modified: trunk/Zaimoni.STL/z_memory.h
===================================================================
--- trunk/Zaimoni.STL/z_memory.h	2010-04-20 19:30:40 UTC (rev 384)
+++ trunk/Zaimoni.STL/z_memory.h	2010-04-20 20:04:37 UTC (rev 385)
@@ -21,6 +21,11 @@
 #define ZAIMONI_LEN_WITH_NULL(A) (A)
 #define ZAIMONI_NULL_TERMINATE(A)
 
+/*
+ * our realloc implements realloc(x,0) is NULL
+ */
+#undef ZAIMONI_REALLOC_TO_ZERO_IS_NULL
+#define ZAIMONI_REALLOC_TO_ZERO_IS_NULL 1
 
 /*
  * defined in memory.cpp: controls Microsoft bypass for realloc.



From zaimoni at mail.berlios.de  Wed Apr 21 19:03:11 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 21 Apr 2010 19:03:11 +0200
Subject: [Zcplusplus-commits] r386 - in trunk/Zaimoni.STL: . LexParse
Message-ID: <201004211703.o3LH3BZJ018969@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-21 19:03:07 +0200 (Wed, 21 Apr 2010)
New Revision: 386

Modified:
   trunk/Zaimoni.STL/LexParse/LangConf.cpp
   trunk/Zaimoni.STL/MetaRAM2.hpp
Log:
code review for ZAIMONI_REALLOC_TO_ZERO_IS_NULL; update to current coding style

Modified: trunk/Zaimoni.STL/LexParse/LangConf.cpp
===================================================================
--- trunk/Zaimoni.STL/LexParse/LangConf.cpp	2010-04-20 20:04:37 UTC (rev 385)
+++ trunk/Zaimoni.STL/LexParse/LangConf.cpp	2010-04-21 17:03:07 UTC (rev 386)
@@ -58,17 +58,17 @@
 #else
 	size_t BufferLength = strlen(Buffer);
 #endif
-	size_t SweepIdx = 0;
+	size_t i = 0;
 	if (BreakTokenOnNewline)
 		{
-		while('\n'!=Buffer[SweepIdx])
+		while('\n'!=Buffer[i])
 			{
-			if (SweepIdx+2==BufferLength && '\n'==Buffer[SweepIdx+1])
+			if (i+2==BufferLength && '\n'==Buffer[i+1])
 				{
 				Buffer = REALLOC(Buffer,ZAIMONI_LEN_WITH_NULL(--BufferLength));
 				ZAIMONI_NULL_TERMINATE(Buffer[BufferLength]);
 				}
-			if (++SweepIdx==BufferLength)
+			if (++i==BufferLength)
 				{
 				NewLine = Buffer;
 				Buffer = NULL;
@@ -78,24 +78,24 @@
 		}
 	else{
 		bool InQuotes = false;
-		while('\n'!=Buffer[SweepIdx] || InQuotes)
+		while('\n'!=Buffer[i] || InQuotes)
 			{
-			if (SweepIdx+2==BufferLength && '\n'==Buffer[SweepIdx+1] && !InQuotes)
+			if (i+2==BufferLength && '\n'==Buffer[i+1] && !InQuotes)
 				{
 				Buffer = REALLOC(Buffer,ZAIMONI_LEN_WITH_NULL(--BufferLength));
 				ZAIMONI_NULL_TERMINATE(Buffer[BufferLength]);
 				}
-			if (strchr(Quotes,Buffer[SweepIdx]))
+			if (strchr(Quotes,Buffer[i]))
 				InQuotes = !InQuotes;
-			else if ((InQuotes || !EscapeOnlyWithinQuotes) && SweepIdx+1<BufferLength)
+			else if ((InQuotes || !EscapeOnlyWithinQuotes) && i+1<BufferLength)
 				{
-				if (	(   EscapeEscape==Buffer[SweepIdx]
-						 && Escape==Buffer[SweepIdx+1])
-					||	(   Escape==Buffer[SweepIdx]
-						 && strchr(Quotes,Buffer[SweepIdx+1])))
-					SweepIdx++;
+				if (	(   EscapeEscape==Buffer[i]
+						 && Escape==Buffer[i+1])
+					||	(   Escape==Buffer[i]
+						 && strchr(Quotes,Buffer[i+1])))
+					i++;
 				}
-			if (++SweepIdx==BufferLength)
+			if (++i==BufferLength)
 				{
 				NewLine = Buffer;
 				Buffer = NULL;
@@ -104,23 +104,27 @@
 			}
 		}
 
-	size_t NewLineLength = (SweepIdx<=(BufferLength>>1)) ? SweepIdx : BufferLength-(SweepIdx+1);
+	size_t NewLineLength = (i<=(BufferLength>>1)) ? i : BufferLength-(i+1);
+#if ZAIMONI_REALLOC_TO_ZERO_IS_NULL
+	NewLine = REALLOC(NewLine,ZAIMONI_LEN_WITH_NULL(NewLineLength));
+#else
 	NewLine = (0<NewLineLength) ? REALLOC(NewLine,ZAIMONI_LEN_WITH_NULL(NewLineLength)) : NULL;
-	if (NULL==NewLine) return;
+#endif
+	if (!NewLine) return;
 	ZAIMONI_NULL_TERMINATE(NewLine[NewLineLength]);
 
-	Buffer[SweepIdx] = '\0';
-	if (SweepIdx<=(BufferLength>>1))
+	Buffer[i] = '\0';
+	if (i<=(BufferLength>>1))
 		{
 		strcpy(NewLine,Buffer);
-		memmove(Buffer,&Buffer[SweepIdx+1],BufferLength-(SweepIdx+1));
-		Buffer = REALLOC(Buffer,ZAIMONI_LEN_WITH_NULL(BufferLength-(SweepIdx+1)));
-		ZAIMONI_NULL_TERMINATE(Buffer[BufferLength-(SweepIdx+1)]);
+		memmove(Buffer,&Buffer[i+1],BufferLength-(i+1));
+		Buffer = REALLOC(Buffer,ZAIMONI_LEN_WITH_NULL(BufferLength-(i+1)));
+		ZAIMONI_NULL_TERMINATE(Buffer[BufferLength-(i+1)]);
 		}
 	else{
-		strcpy(NewLine,&Buffer[SweepIdx+1]);
-		Buffer = REALLOC(Buffer,ZAIMONI_LEN_WITH_NULL(SweepIdx));
-		ZAIMONI_NULL_TERMINATE(Buffer[SweepIdx]);
+		strcpy(NewLine,&Buffer[i+1]);
+		Buffer = REALLOC(Buffer,ZAIMONI_LEN_WITH_NULL(i));
+		ZAIMONI_NULL_TERMINATE(Buffer[i]);
 		char* AltNewLine = Buffer;
 		Buffer = NewLine;
 		NewLine = AltNewLine;

Modified: trunk/Zaimoni.STL/MetaRAM2.hpp
===================================================================
--- trunk/Zaimoni.STL/MetaRAM2.hpp	2010-04-20 20:04:37 UTC (rev 385)
+++ trunk/Zaimoni.STL/MetaRAM2.hpp	2010-04-21 17:03:07 UTC (rev 386)
@@ -19,27 +19,27 @@
 template <class T> inline size_t
 ArraySize(T* memblock)
 {	// FORMALLY CORRECT: Kenneth Boyd, 12/08/2004
-	assert(NULL!=memblock);
+	assert(memblock);
 	return _msize(memblock)/sizeof(T);
 }
 
 template <class T> inline size_t
 SafeArraySize(T* memblock)
 {	// FORMALLY CORRECT: Kenneth Boyd, 11/2/2005
-	return (NULL==memblock) ? 0 : _msize(memblock)/sizeof(T);
+	return (memblock) ? _msize(memblock)/sizeof(T) : 0;
 }
 
 template <class T> inline size_t
 ArraySize(const T* memblock)
 {	// FORMALLY CORRECT: Kenneth Boyd, 12/08/2004
-	assert(NULL!=memblock);
+	assert(memblock);
 	return _msize(const_cast<T*>(memblock))/sizeof(T);
 }
 
 template <class T> inline size_t
 SafeArraySize(const T* memblock)
 {	// FORMALLY CORRECT: Kenneth Boyd, 11/2/2005
-	return (NULL==memblock) ? 0 : _msize(const_cast<T*>(memblock))/sizeof(T);
+	return (memblock) ? _msize(const_cast<T*>(memblock))/sizeof(T) : 0;
 }
 #endif
 
@@ -72,10 +72,9 @@
 }
 
 template<typename T>
-void
-FlushNULLFromArray(T**& _ptr, size_t StartIdx)
+void FlushNULLFromArray(T**& _ptr, size_t StartIdx)
 {	/* FORMALLY CORRECT: Kenneth Boyd, 11/12/2004 */\
-	assert(NULL!=_ptr);
+	assert(_ptr);
 	const size_t Limit = ArraySize(_ptr);
 	while(StartIdx<Limit)
 		{
@@ -84,7 +83,7 @@
 			size_t Offset = 1;
 			StartIdx--;
 			while(StartIdx+Offset<Limit)
-				if (NULL==_ptr[StartIdx+Offset])
+				if (!_ptr[StartIdx+Offset])
 					Offset++;
 				else{
 					_ptr[StartIdx] = _ptr[StartIdx+Offset];
@@ -97,8 +96,7 @@
 }
 
 template<typename T>
-inline bool
-ExtendByN(T*& _ptr, size_t N)
+inline bool ExtendByN(T*& _ptr, size_t N)
 {
 	return _resize(_ptr,SafeArraySize(_ptr)+N);
 }
@@ -107,32 +105,28 @@
 
 template<typename T>
 #ifndef ZAIMONI_FORCE_ISO
-inline void _safe_delete_idx(T*& _ptr, size_t Idx)
+inline void _safe_delete_idx(T*& _ptr, size_t i)
 {
-	if (NULL!=_ptr && Idx<ArraySize(_ptr))
-		_delete_idx(_ptr,Idx);
+	if (_ptr && i<ArraySize(_ptr)) _delete_idx(_ptr,i);
 }
 #else
-inline void _safe_delete_idx(T*& _ptr, size_t& _ptr_size, size_t Idx)
+inline void _safe_delete_idx(T*& _ptr, size_t& _ptr_size, size_t i)
 {
-	if (NULL!=_ptr && Idx<_ptr_size)
-		_delete_idx(_ptr,_ptr_size,Idx);
+	if (_ptr && i<_ptr_size) _delete_idx(_ptr,_ptr_size,i);
 }
 #endif
 
 #ifndef ZAIMONI_FORCE_ISO
 template<typename T>
-inline void _safe_weak_delete_idx(T*& __ptr, size_t Idx)
+inline void _safe_weak_delete_idx(T*& __ptr, size_t i)
 {
-	if (NULL!=__ptr && Idx<ArraySize(__ptr))
-		_weak_delete_idx(__ptr,Idx);
+	if (__ptr && i<ArraySize(__ptr)) _weak_delete_idx(__ptr,i);
 }
 #else
 template<typename T>
-inline void _safe_weak_delete_idx(T*& __ptr, size_t& _ptr_size, size_t Idx)
+inline void _safe_weak_delete_idx(T*& __ptr, size_t& _ptr_size, size_t i)
 {
-	if (NULL!=__ptr && Idx<_ptr_size)
-		_weak_delete_idx(__ptr,_ptr_size,Idx);
+	if (__ptr && i<_ptr_size) _weak_delete_idx(__ptr,_ptr_size,i);
 }
 #endif
 
@@ -143,49 +137,48 @@
 // _new_buffer and _new_buffer_nonNULL_throws are in MetaRAM.hpp (they don't depend on Logging.h)
 template<typename T>
 typename boost::disable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
-_new_buffer_nonNULL(size_t Idx)
+_new_buffer_nonNULL(size_t i)
 {
-	T* tmp = new(std::nothrow) T[Idx];
-	if (NULL==tmp) _fatal("Irrecoverable failure to allocate memory");
+	T* tmp = new(std::nothrow) T[i];
+	if (!tmp) _fatal("Irrecoverable failure to allocate memory");
 	return tmp;
 }
 
 template<typename T>
 inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
-_new_buffer_nonNULL(size_t Idx)
+_new_buffer_nonNULL(size_t i)
 {
-	T* tmp = reinterpret_cast<T*>(calloc(Idx,sizeof(T)));
-	if (NULL==tmp) _fatal("Irrecoverable failure to allocate memory");
+	T* tmp = reinterpret_cast<T*>(calloc(i,sizeof(T)));
+	if (!tmp) _fatal("Irrecoverable failure to allocate memory");
 	return tmp;
 }
 
-
 template<typename T>
 inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
-_new_buffer_uninitialized(size_t Idx)
+_new_buffer_uninitialized(size_t i)
 {
-	if (((size_t)(-1))/sizeof(T)<Idx) return NULL; // CERT C MEM07
-	return reinterpret_cast<T*>(malloc(Idx*sizeof(T)));
+	if (((size_t)(-1))/sizeof(T)<i) return NULL; // CERT C MEM07
+	return reinterpret_cast<T*>(malloc(i*sizeof(T)));
 }
 
 template<typename T>
 inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
-_new_buffer_uninitialized_nonNULL(size_t Idx)
+_new_buffer_uninitialized_nonNULL(size_t i)
 {
-	if (((size_t)(-1))/sizeof(T)<Idx) // CERT C MEM07
+	if (((size_t)(-1))/sizeof(T)<i) // CERT C MEM07
 		_fatal("requested memory exceeds SIZE_T_MAX");
-	T* tmp = reinterpret_cast<T*>(malloc(Idx*sizeof(T)));
-	if (NULL==tmp) _fatal("Irrecoverable failure to allocate memory");
+	T* tmp = reinterpret_cast<T*>(malloc(i*sizeof(T)));
+	if (!tmp) _fatal("Irrecoverable failure to allocate memory");
 	return tmp;
 }
 
 template<typename T>
 inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value>, T*>::type
-_new_buffer_uninitialized_nonNULL_throws(size_t Idx)
+_new_buffer_uninitialized_nonNULL_throws(size_t i)
 {
-	if (((size_t)(-1))/sizeof(T)<Idx) throw std::bad_alloc(); // CERT C MEM07
-	T* tmp = reinterpret_cast<T*>(malloc(Idx*sizeof(T)));
-	if (NULL==tmp) throw std::bad_alloc();
+	if (((size_t)(-1))/sizeof(T)<i) throw std::bad_alloc(); // CERT C MEM07
+	T* tmp = reinterpret_cast<T*>(malloc(i*sizeof(T)));
+	if (!tmp) throw std::bad_alloc();
 	return tmp;
 }
 
@@ -213,8 +206,8 @@
 #else
 void _flush(T** _ptr, size_t& _ptr_size)
 {
-	assert((NULL!=_ptr && 0<_ptr_size) || (NULL==_ptr && 0==_ptr_size));
-	if (NULL!=_ptr)
+	assert(_ptr ? 0<_ptr_size : 0==_ptr_size);
+	if (_ptr)
 		{
 		size_t i = _ptr_size;
 #endif
@@ -228,8 +221,7 @@
 }
 
 template<typename T>
-void
-CopyDataFromPtrToPtr(T*& dest, const T* src, size_t src_size)
+void CopyDataFromPtrToPtr(T*& dest, const T* src, size_t src_size)
 {	/* FORMALLY CORRECT: Kenneth Boyd, 4/28/2006 */
 	if (!_resize(dest,src_size))
 		{
@@ -279,7 +271,7 @@
 typename boost::disable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value, boost::has_trivial_assign<T>::value >, bool>::type
 _resize(T*& _ptr, size_t& _ptr_size, size_t n)
 {
-	assert((NULL!=_ptr && 0<_ptr_size) || (NULL==_ptr && 0==_ptr_size));
+	assert(_ptr ? 0<_ptr_size : 0==_ptr_size);
 #endif
 	if (0>=n)
 		{
@@ -290,13 +282,13 @@
 #endif
 		return true;
 		};
-	if (NULL==_ptr)
+	if (!_ptr)
 		{
 		_ptr = _new_buffer<T>(n);
 #ifndef ZAIMONI_FORCE_ISO
 		return NULL!=_ptr;
 #else
-		if (NULL==_ptr) return false;
+		if (!_ptr) return false;
 		_ptr_size = n;
 		return true;
 #endif
@@ -309,8 +301,7 @@
 #endif
 
 	T* Tmp = _new_buffer<T>(n);
-	if (NULL==Tmp)
-		return false;
+	if (!Tmp) return false;
 
 #ifndef ZAIMONI_FORCE_ISO
 	_copy_expendable_buffer(Tmp,_ptr,min(ArraySize(_ptr),n));
@@ -334,7 +325,7 @@
 typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_destructor<T>::value, boost::has_trivial_assign<T>::value >, bool>::type
 _resize(T*& _ptr, size_t& _ptr_size, size_t n)
 {
-	assert((NULL!=_ptr && 0<_ptr_size) || (NULL==_ptr && 0==_ptr_size));
+	assert(_ptr ? 0<_ptr_size : 0==_ptr_size);
 #endif
 	if (0>=n)
 		{
@@ -346,7 +337,7 @@
 		return true;
 		};
 	T* Tmp = REALLOC(_ptr,n*sizeof(T));
-	if (NULL!=Tmp)
+	if (Tmp)
 		{
 		_ptr = Tmp;
 #ifdef ZAIMONI_FORCE_ISO
@@ -366,7 +357,7 @@
 bool
 _resize(T**& _ptr, size_t& _ptr_size, size_t n)
 {
-	assert((NULL!=_ptr && 0<_ptr_size) || (NULL==_ptr && 0==_ptr_size));
+	assert(_ptr ? 0<_ptr_size : 0==_ptr_size);
 #endif
 	if (0>=n)
 		{
@@ -377,7 +368,7 @@
 #endif
 		return true;
 		};
-	if (NULL==_ptr)
+	if (!_ptr)
 		{
 		_ptr = reinterpret_cast<T**>(calloc(n,sizeof(T*)));
 #ifndef ZAIMONI_FORCE_ISO
@@ -396,12 +387,12 @@
 #endif
 	if (_ptr_size_old>n)
 		{
-		size_t Idx = _ptr_size_old;
-		do	_single_flush(_ptr[--Idx]);
-		while(n<Idx);
+		size_t i = _ptr_size_old;
+		do	_single_flush(_ptr[--i]);
+		while(n<i);
 		};
 	T** Tmp = REALLOC(_ptr,n*sizeof(T*));
-	if (NULL!=Tmp)
+	if (Tmp)
 		{
 		_ptr = Tmp;
 		if (_ptr_size_old<n) memset(_ptr+_ptr_size_old,0,sizeof(T*)*(n-_ptr_size_old));
@@ -432,14 +423,14 @@
 #ifndef ZAIMONI_FORCE_ISO
 inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_destructor<T>::value, boost::has_trivial_assign<T>::value >, void>::type
 _shrink(T*& _ptr, size_t n)
-{	/*! /pre NULL!=_ptr, n<ArraySize(__ptr) */
-	assert(NULL!=_ptr);
+{	//! \pre NULL!=_ptr, n<ArraySize(__ptr)
+	assert(_ptr);
 	assert(n<ArraySize(_ptr));
 #else
 inline typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_destructor<T>::value, boost::has_trivial_assign<T>::value >, void>::type
 _shrink(T*& _ptr, size_t& _ptr_size, size_t n)
-{	/*! /pre NULL!=_ptr, n<ArraySize(__ptr) */
-	assert(NULL!=_ptr);
+{	//! \pre NULL!=_ptr, n<ArraySize(__ptr)
+	assert(_ptr);
 	assert(n<_ptr_size);
 	assert(0<_ptr_size);
 #endif
@@ -450,10 +441,9 @@
 }
 
 template<typename T>
-void
-_shrink(T**& _ptr,size_t n)
-{	//! /pre NULL!=Target, n<ArraySize(__ptr)
-	assert(NULL!=_ptr);
+void _shrink(T**& _ptr,size_t n)
+{	//! \pre NULL!=Target, n<ArraySize(__ptr)
+	assert(_ptr);
 	assert(n<ArraySize(_ptr));
 	if (0>=n)
 		{
@@ -461,23 +451,23 @@
 		_ptr = NULL;
 		return;
 		}
-	size_t Idx = ArraySize(_ptr);
-	do	_single_flush(_ptr[--Idx]);
-	while(n<Idx);
+	size_t i = ArraySize(_ptr);
+	do	_single_flush(_ptr[--i]);
+	while(n<i);
 	_ptr = REALLOC(_ptr,n*sizeof(T*));
 }
 
 template<typename T>
 typename boost::disable_if<boost::type_traits::ice_and<boost::has_trivial_destructor<T>::value, boost::has_trivial_assign<T>::value >, void>::type
 #ifndef ZAIMONI_FORCE_ISO
-_delete_idx(T*& _ptr, size_t Idx)
+_delete_idx(T*& _ptr, size_t i)
 {
-	assert(NULL!=_ptr);
+	assert(_ptr);
 	const size_t _ptr_size = ArraySize(_ptr);
 #else
-_delete_idx(T*& _ptr, size_t& _ptr_size, size_t Idx)
+_delete_idx(T*& _ptr, size_t& _ptr_size, size_t i)
 {
-	assert(NULL!=_ptr && 0<_ptr_size);
+	assert(_ptr && 0<_ptr_size);
 #endif
 	if (1==_ptr_size)
 		{
@@ -489,10 +479,10 @@
 		return;
 		}
 	T* Tmp = _new_buffer_nonNULL<T>(_ptr_size-1);
-	if (Idx+1<_ptr_size)
-		_copy_expendable_buffer(Tmp+Idx,_ptr+Idx+1,_ptr_size-(Idx+1));
-	if (0<Idx)
-		_copy_expendable_buffer(Tmp,_ptr,Idx);
+	if (i+1<_ptr_size)
+		_copy_expendable_buffer(Tmp+i,_ptr+i+1,_ptr_size-(i+1));
+	if (0<i)
+		_copy_expendable_buffer(Tmp,_ptr,i);
 	_flush(_ptr);
 	_ptr = Tmp;		
 #ifdef ZAIMONI_FORCE_ISO
@@ -503,16 +493,16 @@
 template<typename T>
 typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_destructor<T>::value, boost::has_trivial_assign<T>::value >, void>::type
 #ifndef ZAIMONI_FORCE_ISO
-_delete_idx(T*& _ptr, size_t Idx)
+_delete_idx(T*& _ptr, size_t i)
 {
-	assert(NULL!=_ptr);
+	assert(_ptr);
 	const size_t _ptr_size = ArraySize(_ptr);
-	assert(Idx<_ptr_size);
+	assert(i<_ptr_size);
 #else
-_delete_idx(T*& _ptr, size_t& _ptr_size, size_t Idx)
+_delete_idx(T*& _ptr, size_t& _ptr_size, size_t i)
 {
-	assert(NULL!=_ptr);
-	assert(Idx<_ptr_size);
+	assert(_ptr);
+	assert(i<_ptr_size);
 	assert(0<_ptr_size);
 #endif
 	if (1==_ptr_size)
@@ -524,8 +514,8 @@
 #endif
 		return;
 		}
-	if (2<=_ptr_size-Idx)
-		memmove(_ptr+Idx,_ptr+Idx+1,sizeof(*_ptr)*(_ptr_size-Idx-1));
+	if (2<=_ptr_size-i)
+		memmove(_ptr+i,_ptr+i+1,sizeof(*_ptr)*(_ptr_size-i-1));
 #ifndef ZAIMONI_FORCE_ISO
 	_ptr=REALLOC(_ptr,sizeof(*_ptr)*(_ptr_size-1));
 #else
@@ -544,7 +534,7 @@
 #endif
 {
 #ifdef ZAIMONI_FORCE_ISO
-	assert((NULL!=_ptr && 0<_ptr_size) || (NULL==_ptr && 0==_ptr_size));
+	assert(_ptr ? 0<_ptr_size : 0==_ptr_size);
 #endif
 	if (0>=n)
 		{
@@ -555,7 +545,7 @@
 #endif
 		return true;
 		}
-	if (NULL==_ptr)
+	if (!_ptr)
 		{
 		_ptr = reinterpret_cast<T**>(calloc(n,sizeof(T*)));
 #ifndef ZAIMONI_FORCE_ISO
@@ -573,7 +563,7 @@
 	const size_t _ptr_size_old = _ptr_size;
 #endif
 	T** Tmp = REALLOC(_ptr,n*sizeof(T*));
-	if (NULL!=Tmp)
+	if (Tmp)
 		{
 		_ptr = Tmp;
 #ifdef ZAIMONI_FORCE_ISO
@@ -588,21 +578,21 @@
 template<typename T,typename U>
 typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_assign<T>::value >, bool>::type
 #ifndef ZAIMONI_FORCE_ISO
-_insert_slot_at(T*& _ptr,size_t Idx,U _default)
+_insert_slot_at(T*& _ptr,size_t i,U _default)
 {
 	const size_t _ptr_size_old = SafeArraySize(_ptr);
 	if (_resize(_ptr,_ptr_size_old+1))
 #else
-_insert_slot_at(T*& _ptr,size_t& _ptr_size,size_t Idx,U _default)
+_insert_slot_at(T*& _ptr,size_t& _ptr_size,size_t i,U _default)
 {
-	assert((NULL!=_ptr && 0<_ptr_size) || (NULL==_ptr && 0==_ptr_size));
+	assert(_ptr ? 0<_ptr_size : 0==_ptr_size);
 	const size_t _ptr_size_old = _ptr_size;
 	if (_resize(_ptr,_ptr_size,_ptr_size_old+1))
 #endif
 		{
-		T* const _offset_ptr = _ptr+Idx;
-		if (_ptr_size_old>Idx)
-			memmove(_offset_ptr+1,_offset_ptr,sizeof(*_ptr)*(_ptr_size_old-Idx));
+		T* const _offset_ptr = _ptr+i;
+		if (_ptr_size_old>i)
+			memmove(_offset_ptr+1,_offset_ptr,sizeof(*_ptr)*(_ptr_size_old-i));
 
 		*_offset_ptr = _default;	// do not static-cast
 		return true;
@@ -612,23 +602,21 @@
 
 template<typename T,typename U>
 #ifndef ZAIMONI_FORCE_ISO
-bool
-_insert_slot_at(T**& _ptr, size_t Idx, U* _default)
+bool _insert_slot_at(T**& _ptr, size_t i, U* _default)
 {
 	const size_t _ptr_size_old = SafeArraySize(_ptr);
 	if (_weak_resize(_ptr,_ptr_size_old+1))
 #else
-bool
-_insert_slot_at(T**& _ptr, size_t& _ptr_size, size_t Idx, U* _default)
+bool _insert_slot_at(T**& _ptr, size_t& _ptr_size, size_t i, U* _default)
 {
-	assert((NULL!=_ptr && 0<_ptr_size) || (NULL==_ptr && 0==_ptr_size));
+	assert(_ptr ? 0<_ptr_size : 0==_ptr_size);
 	const size_t _ptr_size_old = _ptr_size;
 	if (_weak_resize(_ptr,_ptr_size,_ptr_size_old+1))
 #endif
 		{
-		T** const _offset_ptr = _ptr+Idx;
-		if (_ptr_size_old>Idx)
-			memmove(_offset_ptr+1,_offset_ptr,sizeof(*_ptr)*(_ptr_size_old-Idx));
+		T** const _offset_ptr = _ptr+i;
+		if (_ptr_size_old>i)
+			memmove(_offset_ptr+1,_offset_ptr,sizeof(*_ptr)*(_ptr_size_old-i));
 
 		*_offset_ptr = _default;	// do not static-cast
 		return true;
@@ -639,22 +627,22 @@
 template<typename T>
 #ifndef ZAIMONI_FORCE_ISO
 typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_assign<T>::value >, bool>::type
-_insert_n_slots_at(T*& _ptr, size_t n, size_t Idx)
+_insert_n_slots_at(T*& _ptr, size_t n, size_t i)
 {
 	const size_t _ptr_size_old = SafeArraySize(_ptr);
 	if (_resize(_ptr,_ptr_size_old+n))
 #else
 typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_constructor<T>::value, boost::has_trivial_assign<T>::value >, bool>::type
-_insert_n_slots_at(T*& _ptr, size_t& _ptr_size, size_t n, size_t Idx)
+_insert_n_slots_at(T*& _ptr, size_t& _ptr_size, size_t n, size_t i)
 {
-	assert((NULL!=_ptr && 0<_ptr_size) || (NULL==_ptr && 0==_ptr_size));
+	assert(_ptr ? 0<_ptr_size : 0==_ptr_size);
 	const size_t _ptr_size_old = _ptr_size;
 	if (_resize(_ptr,_ptr_size,_ptr_size_old+n))
 #endif
 		{
-		T* const _offset_ptr = _ptr+Idx;
-		if (_ptr_size_old>Idx)
-			memmove(_offset_ptr+n,_offset_ptr,sizeof(*_ptr)*(_ptr_size_old-Idx));
+		T* const _offset_ptr = _ptr+i;
+		if (_ptr_size_old>i)
+			memmove(_offset_ptr+n,_offset_ptr,sizeof(*_ptr)*(_ptr_size_old-i));
 #ifdef ZAIMONI_FORCE_ISO
 		_ptr_size += n;
 #endif
@@ -665,21 +653,21 @@
 
 template<typename T>
 #ifndef ZAIMONI_FORCE_ISO
-bool _insert_n_slots_at(T**& _ptr, size_t n, size_t Idx)
+bool _insert_n_slots_at(T**& _ptr, size_t n, size_t i)
 {
 	const size_t _ptr_size_old = SafeArraySize(_ptr);
 	if (_weak_resize(_ptr,_ptr_size_old+n))
 #else
-bool _insert_n_slots_at(T**& _ptr, size_t& _ptr_size, size_t n, size_t Idx)
+bool _insert_n_slots_at(T**& _ptr, size_t& _ptr_size, size_t n, size_t i)
 {
-	assert((NULL!=_ptr && 0<_ptr_size) || (NULL==_ptr && 0==_ptr_size));
+	assert(_ptr ? 0<_ptr_size : 0==_ptr_size);
 	const size_t _ptr_size_old = _ptr_size;
 	if (_weak_resize(_ptr,_ptr_size,_ptr_size_old+n))
 #endif
 		{
-		T** const _offset_ptr = _ptr+Idx;
-		if (_ptr_size_old>Idx)
-			memmove(_offset_ptr+n,_offset_ptr,sizeof(*_ptr)*(_ptr_size_old-Idx));
+		T** const _offset_ptr = _ptr+i;
+		if (_ptr_size_old>i)
+			memmove(_offset_ptr+n,_offset_ptr,sizeof(*_ptr)*(_ptr_size_old-i));
 
 		if (0<n) memset(_offset_ptr,0,sizeof(T*)*n);
 #ifdef ZAIMONI_FORCE_ISO
@@ -692,16 +680,16 @@
 
 template<typename T>
 #ifndef ZAIMONI_FORCE_ISO
-void _weak_delete_idx(T**& _ptr, size_t Idx)
+void _weak_delete_idx(T**& _ptr, size_t i)
 {
-	assert(NULL!=_ptr);
+	assert(_ptr);
 	const size_t _ptr_size = ArraySize(_ptr);
 #else
-void _weak_delete_idx(T**& _ptr, size_t& _ptr_size, size_t Idx)
+void _weak_delete_idx(T**& _ptr, size_t& _ptr_size, size_t i)
 {
-	assert(NULL!=_ptr);
+	assert(_ptr);
 #endif
-	assert(Idx<_ptr_size);
+	assert(i<_ptr_size);
 	if (1==_ptr_size)
 		{
 		_weak_flush(_ptr);
@@ -711,8 +699,8 @@
 #endif
 		return;
 		}
-	if (2<=_ptr_size-Idx)
-		memmove(_ptr+Idx,_ptr+Idx+1,sizeof(T*)*(_ptr_size-Idx-1));
+	if (2<=_ptr_size-i)
+		memmove(_ptr+i,_ptr+i+1,sizeof(T*)*(_ptr_size-i-1));
 	_ptr=REALLOC(_ptr,sizeof(T*)*(_ptr_size-1));
 #ifdef ZAIMONI_FORCE_ISO
 	--_ptr_size;
@@ -722,18 +710,18 @@
 template<typename T>
 typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_destructor<T>::value, boost::has_trivial_assign<T>::value >, void>::type
 #ifndef ZAIMONI_FORCE_ISO
-_delete_n_slots_at(T*& _ptr, size_t n, size_t Idx)
+_delete_n_slots_at(T*& _ptr, size_t n, size_t i)
 {
-	assert(NULL!=_ptr);
+	assert(_ptr);
 	const size_t _ptr_size = ArraySize(_ptr);
 #else
-_delete_n_slots_at(T*& _ptr, size_t& _ptr_size, size_t n, size_t Idx)
+_delete_n_slots_at(T*& _ptr, size_t& _ptr_size, size_t n, size_t i)
 {
-	assert(NULL!=_ptr);
+	assert(_ptr);
 	assert(0<_ptr_size);
 #endif
 
-	if (0==Idx && _ptr_size<=n)
+	if (0==i && _ptr_size<=n)
 		{
 		_flush(_ptr);
 		_ptr = NULL;
@@ -742,11 +730,11 @@
 #endif
 		return;
 		}
-	T* const _offset_ptr = _ptr+Idx;
+	T* const _offset_ptr = _ptr+i;
 	if (n<_ptr_size)
 		{
-		if (Idx+n<_ptr_size)
-			memmove(_offset_ptr,_offset_ptr+n,sizeof(*_ptr)*(_ptr_size-Idx-n));
+		if (i+n<_ptr_size)
+			memmove(_offset_ptr,_offset_ptr+n,sizeof(*_ptr)*(_ptr_size-i-n));
 		_ptr = REALLOC(_ptr,sizeof(*_ptr)*(_ptr_size-n));
 #ifdef ZAIMONI_FORCE_ISO
 		_ptr_size -= n;
@@ -763,18 +751,18 @@
 
 template<typename T>
 #ifndef ZAIMONI_FORCE_ISO
-void _delete_n_slots_at(T**& _ptr, size_t n, size_t Idx)
+void _delete_n_slots_at(T**& _ptr, size_t n, size_t i)
 {
-	assert(NULL!=_ptr);
+	assert(_ptr);
 	const size_t _ptr_size = ArraySize(_ptr);
 #else
-void _delete_n_slots_at(T**& _ptr, size_t& _ptr_size, size_t n, size_t Idx)
+void _delete_n_slots_at(T**& _ptr, size_t& _ptr_size, size_t n, size_t i)
 {
-	assert(NULL!=_ptr);
+	assert(_ptr);
 	assert(0<_ptr_size);
 #endif
 
-	if (0==Idx && _ptr_size<=n)
+	if (0==i && _ptr_size<=n)
 		{
 		_flush(_ptr);
 		_ptr = NULL;
@@ -783,7 +771,7 @@
 #endif
 		return;
 		}
-	T** const _offset_ptr = _ptr+Idx;
+	T** const _offset_ptr = _ptr+i;
 	{
 	size_t NImage = n;
 	do	{
@@ -794,8 +782,8 @@
 	}
 	if (n<_ptr_size)
 		{
-		if (Idx+n<_ptr_size)
-			memmove(_offset_ptr,_offset_ptr+n,sizeof(*_ptr)*(_ptr_size-Idx-n));
+		if (i+n<_ptr_size)
+			memmove(_offset_ptr,_offset_ptr+n,sizeof(*_ptr)*(_ptr_size-i-n));
 		_ptr = REALLOC(_ptr,sizeof(*_ptr)*(_ptr_size-n));
 #ifdef ZAIMONI_FORCE_ISO
 		_ptr_size -= n;
@@ -895,22 +883,21 @@
 }
 
 template<typename T>
-void
-_weak_delete_n_slots_at(T**& _ptr, size_t n, size_t Idx)
+void _weak_delete_n_slots_at(T**& _ptr, size_t n, size_t i)
 {
-	assert(NULL!=_ptr);
+	assert(_ptr);
 	const size_t _ptr_size = ArraySize(_ptr);
-	if (0==Idx && _ptr_size<=n)
+	if (0==i && _ptr_size<=n)
 		{
 		_weak_flush(_ptr);
 		_ptr = NULL;
 		return;
 		}
-	T** const _offset_ptr = _ptr+Idx;
+	T** const _offset_ptr = _ptr+i;
 	if (n<_ptr_size)
 		{
-		if (Idx+n<_ptr_size)
-			memmove(_offset_ptr,_offset_ptr+n,sizeof(T*)*(_ptr_size-Idx-n));
+		if (i+n<_ptr_size)
+			memmove(_offset_ptr,_offset_ptr+n,sizeof(T*)*(_ptr_size-i-n));
 		_ptr = REALLOC(_ptr,sizeof(T*)*(_ptr_size-n));
 		}
 	else{



From zaimoni at mail.berlios.de  Thu Apr 22 07:10:15 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 22 Apr 2010 07:10:15 +0200
Subject: [Zcplusplus-commits] r387 - in trunk: . Zaimoni.STL/Pure.C
Message-ID: <201004220510.o3M5AFow006267@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-22 07:10:03 +0200 (Thu, 22 Apr 2010)
New Revision: 387

Added:
   trunk/Zaimoni.STL/Pure.C/stdio_c.c
   trunk/Zaimoni.STL/Pure.C/stdio_c.h
Modified:
   trunk/MakeMake.cfg
   trunk/Makefile
   trunk/Zaimoni.STL/Pure.C/GNUmakefile
   trunk/Zaimoni.STL/Pure.C/NMakefile
Log:
relocating get_filelength

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2010-04-21 17:03:07 UTC (rev 386)
+++ trunk/MakeMake.cfg	2010-04-22 05:10:03 UTC (rev 387)
@@ -14,7 +14,7 @@
 
 # language
 CPP_suffix = '.cpp'
-CPP_libraries = ' -lz_langconf -lz_log_adapter -lz_stdio_log -lz_mutex -lz_format_util' # -mwindows -mno-cygwin
+CPP_libraries = ' -lz_langconf -lz_log_adapter -lz_stdio_log -lz_mutex -lz_format_util -lz_stdio_c' # -mwindows -mno-cygwin
 CPP_override_libraries = {}
 
 if 0==C_defines.count('ZAIMONI_FORCE_ISO'):

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2010-04-21 17:03:07 UTC (rev 386)
+++ trunk/Makefile	2010-04-22 05:10:03 UTC (rev 387)
@@ -15,11 +15,11 @@
 include POSIX.dep
 
 z_cpp.exe : $(OBJECTS_Z_CPP_LINK_PRIORITY)
-	g++ $(LINK_FLAGS) -oz_cpp.exe $(OBJECTS_Z_CPP) -lz_langconf  -lz_langconf -lz_log_adapter -lz_stdio_log -lz_mutex -lz_format_util -lz_memory
+	g++ $(LINK_FLAGS) -oz_cpp.exe $(OBJECTS_Z_CPP) -lz_langconf  -lz_langconf -lz_log_adapter -lz_stdio_log -lz_mutex -lz_format_util -lz_stdio_c -lz_memory
 	strip --preserve-dates --strip-unneeded z_cpp.exe
 
 zcc.exe : $(OBJECTS_ZCC_LINK_PRIORITY)
-	g++ $(LINK_FLAGS) -ozcc.exe $(OBJECTS_ZCC) -lz_langconf  -lz_langconf -lz_log_adapter -lz_stdio_log -lz_mutex -lz_format_util -lz_memory
+	g++ $(LINK_FLAGS) -ozcc.exe $(OBJECTS_ZCC) -lz_langconf  -lz_langconf -lz_log_adapter -lz_stdio_log -lz_mutex -lz_format_util -lz_stdio_c -lz_memory
 	strip --preserve-dates --strip-unneeded zcc.exe
 
 # inference rules

Modified: trunk/Zaimoni.STL/Pure.C/GNUmakefile
===================================================================
--- trunk/Zaimoni.STL/Pure.C/GNUmakefile	2010-04-21 17:03:07 UTC (rev 386)
+++ trunk/Zaimoni.STL/Pure.C/GNUmakefile	2010-04-22 05:10:03 UTC (rev 387)
@@ -8,10 +8,10 @@
 
 CFLAGS := -Os -Wall -Wextra -finline -Winline -Wdisabled-optimization --param max-inline-insns-single=500 -pipe -DNDEBUG
 
-LIBS := libz_format_util.a
+LIBS := libz_format_util.a libz_stdio_c.a
 
 # GNU targets we know about
-all: $(LIBS) auto_int.h comptest.h
+all: auto_int.h comptest.h $(LIBS)
 
 clean:
 	rm -f *.a *.o auto_int.h comptest.h
@@ -20,6 +20,7 @@
 
 uninstall:
 	rm -f $(libdir)/libz_format_util.a
+	rm -f $(libdir)/libz_stdio_c.a
 
 # rules
 format_util.o: format_util.c format_util.h
@@ -44,6 +45,12 @@
 libz_format_util.a: format_util.o
 	$(AR) -ru libz_format_util.a format_util.o
 
+libz_stdio_c.a: stdio_c.o
+	$(AR) -ru libz_stdio_c.a stdio_c.o
+
 $(libdir)/libz_format_util.a: libz_format_util.a
 	cp libz_format_util.a $(libdir)/libz_format_util.a
+	
+$(libdir)/libz_stdio_c.a: libz_stdio_c.a
+	cp libz_stdio_c.a $(libdir)/libz_stdio_c.a
 

Modified: trunk/Zaimoni.STL/Pure.C/NMakefile
===================================================================
--- trunk/Zaimoni.STL/Pure.C/NMakefile	2010-04-21 17:03:07 UTC (rev 386)
+++ trunk/Zaimoni.STL/Pure.C/NMakefile	2010-04-22 05:10:03 UTC (rev 387)
@@ -9,21 +9,23 @@
 # /Wall warns on system headers in VC 2008, not good
 CFLAGS = /O1 /EHsc /MD /W3
 
-LIBS = z_format_util.lib
+LIBS = z_format_util.lib z_stdio_c.lib
 
 # GNU targets we know about
-all: $(LIBS) auto_int.h comptest.h
+all: auto_int.h comptest.h $(LIBS)
 
 clean:
 	del *.lib *.obj auto_int.h comptest.h
 
-install: $(libdir)\z_format_util.lib $(libdir)\z_logging.lib
+install: $(libdir)\z_format_util.lib $(libdir)\z_stdio_c.lib
 
 uninstall:
 	del $(libdir)\z_format_util.lib
+	del $(libdir)\z_stdio_c.lib
 
 # rules
 format_util.obj: format_util.c format_util.h
+stdio_c.obj: stdio_c.c stdio_c.h
 
 auto_int.h : int_probe.c
 	$(CC) /OUT:int_probe.exe $(CFLAGS) int_probe.c
@@ -46,6 +48,12 @@
 z_format_util.lib: format_util.obj
 	$(AR) /OUT:z_format_util.lib format_util.obj
 
+z_stdio_c.lib: stdio_c.obj
+	$(AR) /OUT:z_stdio_c.lib stdio_c.obj
+
 $(libdir)\z_format_util.lib: z_format_util.lib
 	copy /Y z_format_util.lib $(libdir)\z_format_util.lib
+	
+$(libdir)\z_stdio_c.lib: z_stdio_c.lib
+	copy /Y z_stdio_c.lib $(libdir)\z_stdio_c.lib
 

Added: trunk/Zaimoni.STL/Pure.C/stdio_c.c
===================================================================
--- trunk/Zaimoni.STL/Pure.C/stdio_c.c	2010-04-21 17:03:07 UTC (rev 386)
+++ trunk/Zaimoni.STL/Pure.C/stdio_c.c	2010-04-22 05:10:03 UTC (rev 387)
@@ -0,0 +1,24 @@
+/* stdio_c.c */
+
+#include "stdio_c.h"
+
+#include "comptest.h"
+#if ZAIMONI_HAVE_MICROSOFT_IO_H
+#include <io.h>
+#endif
+
+long get_filelength(FILE* src)
+{
+#if ZAIMONI_HAVE_MICROSOFT_IO_H
+	return _filelength(_fileno(src));
+#else
+	// Failing over to implementation-defined extension of ISO C.
+	fpos_t current_pos;
+	if (fgetpos(src,&current_pos)) return -1;
+	if (fseek(src,0,SEEK_END)) return -1;	// ISO does not guarantee this works.
+	long src_len = ftell(src);
+	if (fsetpos(src,&current_pos)) return -1;
+	return src_len;
+#endif	
+}
+

Added: trunk/Zaimoni.STL/Pure.C/stdio_c.h
===================================================================
--- trunk/Zaimoni.STL/Pure.C/stdio_c.h	2010-04-21 17:03:07 UTC (rev 386)
+++ trunk/Zaimoni.STL/Pure.C/stdio_c.h	2010-04-22 05:10:03 UTC (rev 387)
@@ -0,0 +1,17 @@
+/* stdio_c.h */
+#ifndef STDIO_C_H
+#define STDIO_C_H 1
+
+#include <stdio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+long get_filelength(FILE* src);
+
+#ifdef __cplusplus
+}	/* end extern "C" */
+#endif
+
+#endif



From zaimoni at mail.berlios.de  Thu Apr 22 08:32:14 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 22 Apr 2010 08:32:14 +0200
Subject: [Zcplusplus-commits] r388 - in trunk: Zaimoni.STL
	Zaimoni.STL/LexParse Zaimoni.STL/OS Zaimoni.STL/OS/Win32
	Zaimoni.STL/Pure.C Zaimoni.STL/Pure.C/stdio.log
	Zaimoni.STL/core.RAM lib
Message-ID: <201004220632.o3M6WEsn021437@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-22 08:32:06 +0200 (Thu, 22 Apr 2010)
New Revision: 388

Added:
   trunk/lib/host.zcc/
Modified:
   trunk/Zaimoni.STL/LexParse/GNUmakefile
   trunk/Zaimoni.STL/Makefile
   trunk/Zaimoni.STL/OS/GNUmakefile
   trunk/Zaimoni.STL/OS/Win32/GNUmakefile
   trunk/Zaimoni.STL/POSIX.inc
   trunk/Zaimoni.STL/Pure.C/GNUmakefile
   trunk/Zaimoni.STL/Pure.C/stdio.log/GNUmakefile
   trunk/Zaimoni.STL/core.RAM/GNUmakefile
Log:
start simplifying the build process

Modified: trunk/Zaimoni.STL/LexParse/GNUmakefile
===================================================================
--- trunk/Zaimoni.STL/LexParse/GNUmakefile	2010-04-22 05:10:03 UTC (rev 387)
+++ trunk/Zaimoni.STL/LexParse/GNUmakefile	2010-04-22 06:32:06 UTC (rev 388)
@@ -18,6 +18,7 @@
 	rm -f *.a *.o
 
 install: $(addprefix $(libdir)/, $(LIBS))
+host_install: $(addprefix ../../$(host_libdir)/, $(LIBS))
 
 uninstall:
 	rm -f $(addprefix $(libdir)/, $(LIBS))
@@ -44,3 +45,9 @@
 $(libdir)/libz_langconf_iso.a: libz_langconf_iso.a
 	cp libz_langconf_iso.a $(libdir)/libz_langconf_iso.a
 
+../../$(host_libdir)/libz_langconf.a: libz_langconf.a
+	cp libz_langconf.a ../../$(host_libdir)/libz_langconf.a
+
+../../$(host_libdir)/libz_langconf_iso.a: libz_langconf_iso.a
+	cp libz_langconf_iso.a ../../$(host_libdir)/libz_langconf_iso.a
+

Modified: trunk/Zaimoni.STL/Makefile
===================================================================
--- trunk/Zaimoni.STL/Makefile	2010-04-22 05:10:03 UTC (rev 387)
+++ trunk/Zaimoni.STL/Makefile	2010-04-22 06:32:06 UTC (rev 388)
@@ -1,6 +1,7 @@
 # POSIX makefile for Zaimoni.STL
 # POSIX requires make sets $(MAKE)
-# pure.C must be done first: Pure.C/auto_int.h is a generated file
+# pure.C must be done first: Pure.C/auto_int.h, Pure.C/comptest.h
+#  are generated files
 
 # GNU targets we know about
 all:
@@ -31,3 +32,11 @@
 	cd OS; $(MAKE) uninstall
 	cd OS; cd Win32; $(MAKE) uninstall
 
+# use this to avoid polluting host compiler with our libraries
+host_install:
+	cd pure.C; $(MAKE) host_install; cd stdio.log; $(MAKE) host_install
+	cd core.RAM; $(MAKE) host_install
+	cd LexParse; $(MAKE) host_install
+	cd OS; $(MAKE) host_install
+	cd OS; cd Win32; $(MAKE) host_install
+

Modified: trunk/Zaimoni.STL/OS/GNUmakefile
===================================================================
--- trunk/Zaimoni.STL/OS/GNUmakefile	2010-04-22 05:10:03 UTC (rev 387)
+++ trunk/Zaimoni.STL/OS/GNUmakefile	2010-04-22 06:32:06 UTC (rev 388)
@@ -19,6 +19,7 @@
 	rm -f *.a *.o
 
 install: $(addprefix $(libdir)/, $(LIBS))
+host_install: $(addprefix ../../$(host_libdir)/, $(LIBS))
 
 uninstall:
 	rm -f $(addprefix $(libdir)/, $(LIBS))
@@ -37,3 +38,6 @@
 $(libdir)/libz_log_adapter.a: libz_log_adapter.a
 	cp libz_log_adapter.a $(libdir)/libz_log_adapter.a
 
+../../$(host_libdir)/libz_log_adapter.a: libz_log_adapter.a
+	cp libz_log_adapter.a ../../$(host_libdir)/libz_log_adapter.a
+

Modified: trunk/Zaimoni.STL/OS/Win32/GNUmakefile
===================================================================
--- trunk/Zaimoni.STL/OS/Win32/GNUmakefile	2010-04-22 05:10:03 UTC (rev 387)
+++ trunk/Zaimoni.STL/OS/Win32/GNUmakefile	2010-04-22 06:32:06 UTC (rev 388)
@@ -18,6 +18,7 @@
 	rm -f *.a *.o
 
 install: $(addprefix $(libdir)/, $(LIBS))
+host_install: $(addprefix ../../../$(host_libdir)/, $(LIBS))
 
 uninstall:
 	rm -f $(addprefix $(libdir)/, $(LIBS))
@@ -29,12 +30,9 @@
 libz_mutex.a: mutex.o
 	$(AR) -ru libz_mutex.a mutex.o
 
-#define lib_install
-#$(libdir)/$(1): $(1)
-#	cp $(1) $(libdir)/$(1)
-#endef
-
-#$(foreach lib,$(LIBS),$(eval(call lib_install,$(lib))))
 $(libdir)/libz_mutex.a: libz_mutex.a
 	cp libz_mutex.a $(libdir)/libz_mutex.a
 
+../../../$(host_libdir)/libz_mutex.a: libz_mutex.a
+	cp libz_mutex.a ../../../$(host_libdir)/libz_mutex.a
+

Modified: trunk/Zaimoni.STL/POSIX.inc
===================================================================
--- trunk/Zaimoni.STL/POSIX.inc	2010-04-22 05:10:03 UTC (rev 387)
+++ trunk/Zaimoni.STL/POSIX.inc	2010-04-22 06:32:06 UTC (rev 388)
@@ -5,6 +5,10 @@
 includedir = $(exec_prefix)/include
 libdir = $(exec_prefix)/lib
 
+# install host-built libraries here for Z.C++ here
+# (stage 1 of three-stage bootstrap)
+host_libdir = lib/host.zcc
+
 AR = ar
 CC = gcc
 CXX = g++

Modified: trunk/Zaimoni.STL/Pure.C/GNUmakefile
===================================================================
--- trunk/Zaimoni.STL/Pure.C/GNUmakefile	2010-04-22 05:10:03 UTC (rev 387)
+++ trunk/Zaimoni.STL/Pure.C/GNUmakefile	2010-04-22 06:32:06 UTC (rev 388)
@@ -17,6 +17,7 @@
 	rm -f *.a *.o auto_int.h comptest.h
 
 install: $(addprefix $(libdir)/, $(LIBS))
+host_install: $(addprefix ../../$(host_libdir)/, $(LIBS))
 
 uninstall:
 	rm -f $(libdir)/libz_format_util.a
@@ -54,3 +55,9 @@
 $(libdir)/libz_stdio_c.a: libz_stdio_c.a
 	cp libz_stdio_c.a $(libdir)/libz_stdio_c.a
 
+../../$(host_libdir)/libz_format_util.a: libz_format_util.a
+	cp libz_format_util.a ../../$(host_libdir)/libz_format_util.a
+	
+../../$(host_libdir)/libz_stdio_c.a: libz_stdio_c.a
+	cp libz_stdio_c.a ../../$(host_libdir)/libz_stdio_c.a
+

Modified: trunk/Zaimoni.STL/Pure.C/stdio.log/GNUmakefile
===================================================================
--- trunk/Zaimoni.STL/Pure.C/stdio.log/GNUmakefile	2010-04-22 05:10:03 UTC (rev 387)
+++ trunk/Zaimoni.STL/Pure.C/stdio.log/GNUmakefile	2010-04-22 06:32:06 UTC (rev 388)
@@ -17,6 +17,7 @@
 	rm -f *.a *.o
 
 install: $(addprefix $(libdir)/, $(LIBS))
+host_install: $(addprefix ../../../$(host_libdir)/, $(LIBS))
 
 uninstall:
 	rm -f $(addprefix $(libdir)/, $(LIBS))
@@ -28,6 +29,9 @@
 libz_stdio_log.a: fatal.o fatal_code.o inform.o inc_inform.o log.o
 	$(AR) -ru libz_stdio_log.a fatal.o fatal_code.o inform.o inc_inform.o log.o
 
-$(libdir)/libz_stdio_log.a: libz_stdio_log.a
-	cp libz_stdio_log.a $(libdir)/libz_stdio_log.a
+../../../$(libdir)/libz_stdio_log.a: libz_stdio_log.a
+	cp libz_stdio_log.a ../../../$(libdir)/libz_stdio_log.a
 
+../../../$(host_libdir)/libz_stdio_log.a: libz_stdio_log.a
+	cp libz_stdio_log.a ../../../$(host_libdir)/libz_stdio_log.a
+	

Modified: trunk/Zaimoni.STL/core.RAM/GNUmakefile
===================================================================
--- trunk/Zaimoni.STL/core.RAM/GNUmakefile	2010-04-22 05:10:03 UTC (rev 387)
+++ trunk/Zaimoni.STL/core.RAM/GNUmakefile	2010-04-22 06:32:06 UTC (rev 388)
@@ -18,6 +18,7 @@
 	rm -f *.a *.o
 
 install: $(addprefix $(libdir)/, $(LIBS))
+host_install: $(addprefix ../../$(host_libdir)/, $(LIBS))
 
 uninstall:
 	rm -f $(libdir)/libz_memory.a
@@ -42,3 +43,9 @@
 $(libdir)/libz_memory_c.a: libz_memory_c.a
 	cp libz_memory_c.a $(libdir)/libz_memory_c.a
 
+../../$(host_libdir)/libz_memory.a: libz_memory.a
+	cp libz_memory.a ../../$(host_libdir)/libz_memory.a
+
+../../$(host_libdir)/libz_memory_c.a: libz_memory_c.a
+	cp libz_memory_c.a ../../$(host_libdir)/libz_memory_c.a
+



From zaimoni at mail.berlios.de  Thu Apr 22 09:07:03 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 22 Apr 2010 09:07:03 +0200
Subject: [Zcplusplus-commits] r389 - in trunk: . Zaimoni.STL/Pure.C
Message-ID: <201004220707.o3M773sF023360@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-22 09:06:59 +0200 (Thu, 22 Apr 2010)
New Revision: 389

Modified:
   trunk/Makefile
   trunk/POSIX.inc
   trunk/README.txt
   trunk/Zaimoni.STL/Pure.C/GNUmakefile
Log:
adjust GNUMakefile to use the lib/host.zcc subdirectory for stage1 build of bootstrap

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2010-04-22 06:32:06 UTC (rev 388)
+++ trunk/Makefile	2010-04-22 07:06:59 UTC (rev 389)
@@ -9,16 +9,20 @@
 all: z_cpp.exe zcc.exe
 
 clean:
-	rm -f *.o *.exe
+	rm -f *.o *.exe lib/host.zcc/*.a
+	cd Zaimoni.STL; make clean
 
 # dependencies
 include POSIX.dep
 
-z_cpp.exe : $(OBJECTS_Z_CPP_LINK_PRIORITY)
+make_Zaimoni_STL:
+	cd Zaimoni.STL; make host_install
+
+z_cpp.exe : make_Zaimoni_STL $(OBJECTS_Z_CPP_LINK_PRIORITY)
 	g++ $(LINK_FLAGS) -oz_cpp.exe $(OBJECTS_Z_CPP) -lz_langconf  -lz_langconf -lz_log_adapter -lz_stdio_log -lz_mutex -lz_format_util -lz_stdio_c -lz_memory
 	strip --preserve-dates --strip-unneeded z_cpp.exe
 
-zcc.exe : $(OBJECTS_ZCC_LINK_PRIORITY)
+zcc.exe : make_Zaimoni_STL $(OBJECTS_ZCC_LINK_PRIORITY)
 	g++ $(LINK_FLAGS) -ozcc.exe $(OBJECTS_ZCC) -lz_langconf  -lz_langconf -lz_log_adapter -lz_stdio_log -lz_mutex -lz_format_util -lz_stdio_c -lz_memory
 	strip --preserve-dates --strip-unneeded zcc.exe
 

Modified: trunk/POSIX.inc
===================================================================
--- trunk/POSIX.inc	2010-04-22 06:32:06 UTC (rev 388)
+++ trunk/POSIX.inc	2010-04-22 07:06:59 UTC (rev 389)
@@ -16,7 +16,7 @@
 CFLAGS = -fargument-alias -finline -Os -Wall -Wno-long-long --pedantic
 CXXFLAGS =
 ARCH_FLAGS = -mconsole -mno-cygwin -march=pentium -mtune=pentium3
-LINK_FLAGS = 
+LINK_FLAGS = -Llib/host.zcc
 
 OTHER_INCLUDEDIR =
 C_MACROS = 

Modified: trunk/README.txt
===================================================================
--- trunk/README.txt	2010-04-22 06:32:06 UTC (rev 388)
+++ trunk/README.txt	2010-04-22 07:06:59 UTC (rev 389)
@@ -1,11 +1,7 @@
 Installation instructions with GNU make for MingW32 (Official 3.4.5, official 4.2.1, or TDM 4.3.3)
--1) Install the Boost libraries ( http://www.boost.org/ ) first.
-0) Install the Zaimoni.STL directory second.
-0.1) Adjust POSIX.inc to have the correct values for your system.
-0.2) make
-0.3) make install if there were no errors
+0) Install the Boost libraries ( http://www.boost.org/ ) first.
 
-1) Adjust POSIX.inc to have the correct values for your system.  Also adjust 
+1) Adjust POSIX.inc and Zaimoni.STL to have the correct values for your system.  Also adjust 
    the INSTALL_TO macro in CPreproc.cpp to point to the root build directory.
 2) make
 3) using a Bourne shell in the tests/cpp subdirectory:

Modified: trunk/Zaimoni.STL/Pure.C/GNUmakefile
===================================================================
--- trunk/Zaimoni.STL/Pure.C/GNUmakefile	2010-04-22 06:32:06 UTC (rev 388)
+++ trunk/Zaimoni.STL/Pure.C/GNUmakefile	2010-04-22 07:06:59 UTC (rev 389)
@@ -17,7 +17,7 @@
 	rm -f *.a *.o auto_int.h comptest.h
 
 install: $(addprefix $(libdir)/, $(LIBS))
-host_install: $(addprefix ../../$(host_libdir)/, $(LIBS))
+host_install: auto_int.h comptest.h $(addprefix ../../$(host_libdir)/, $(LIBS))
 
 uninstall:
 	rm -f $(libdir)/libz_format_util.a



From zaimoni at mail.berlios.de  Thu Apr 22 22:26:44 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 22 Apr 2010 22:26:44 +0200
Subject: [Zcplusplus-commits] r390 - trunk
Message-ID: <201004222026.o3MKQiuX001714@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-22 22:26:38 +0200 (Thu, 22 Apr 2010)
New Revision: 390

Modified:
   trunk/README.txt
   trunk/load_src.cpp
   trunk/type_spec.cpp
Log:
code cleanup, review for realloc(x,0) behavior

Modified: trunk/README.txt
===================================================================
--- trunk/README.txt	2010-04-22 07:06:59 UTC (rev 389)
+++ trunk/README.txt	2010-04-22 20:26:38 UTC (rev 390)
@@ -19,9 +19,9 @@
   for use with the Windows command processor, with mostly-comparable meaning.
 * They do not have the assertion-count capability.
 * They only list the last test case in each category that had unexpected behavior.
-* They do not run the content-comparison tests.
+* You'll need a POSIX-like cmp.  MingW's is recommended, but you can build the one in POSIX/cmp.
 
-4) make install [to be implemented]
+4) make install
 
 Installation instructions with Microsoft NMake for Visual C++ 2008 Express, 32-bit
 -1) Install the Boost libraries ( http://www.boost.org/ ) first.
@@ -48,6 +48,6 @@
   for use with the Windows command processor, with mostly-comparable meaning.
 * They do not have the assertion-count capability.
 * They only list the last test case in each category that had unexpected behavior.
-* They do not run the content-comparison tests.
+* You'll need a POSIX-like cmp.  MingW's is recommended, but you can build the one in POSIX/cmp.
 
 4) nmake /F NMakefile install [to be implemented]

Modified: trunk/load_src.cpp
===================================================================
--- trunk/load_src.cpp	2010-04-22 07:06:59 UTC (rev 389)
+++ trunk/load_src.cpp	2010-04-22 20:26:38 UTC (rev 390)
@@ -30,16 +30,16 @@
 	assert(TokenList.size()>v_idx);
 	bool want_to_zap_line = true;
 	if ('\\'==TokenList[v_idx]->data()[TokenList[v_idx]->size()-1])
-	{	// line continue
+		{	// line continue
 		if (TokenList[v_idx]->logical_line.first+1==TokenList[v_idx+1]->logical_line.first)
-		{
+			{
 			TokenList[v_idx]->append(1,*TokenList[v_idx+1]);
 			TokenList.DeleteIdx(v_idx+1);
 			want_to_zap_line = false;
-		}
+			}
 		else
 			TokenList[v_idx]->rtrim(1);
-	}
+		}
 	if (want_to_zap_line) clean_whitespace(TokenList,v_idx,lang);
 }
 
@@ -54,7 +54,7 @@
 	size_t Buffer_size = 0;
 #endif
 
-	assert(!zaimoni::is_empty_string(filename));
+	assert(filename && *filename);
 
 	// XXX should return true for empty files XXX
 #ifndef ZAIMONI_FORCE_ISO
@@ -73,31 +73,32 @@
 	while(newline_count<BufferSizeSub1 && '\n'==Buffer[BufferSizeSub1-newline_count]) ++newline_count;
 	if (0<newline_count)
 		{
+		if (Buffer_size<=newline_count) return free(Buffer),true;
 #ifndef ZAIMONI_FORCE_ISO
 		Buffer = REALLOC(Buffer,(ArraySize(Buffer)-newline_count));
 #else
 		Buffer = REALLOC(Buffer,(Buffer_size -= newline_count));
 #endif
-		if (NULL==Buffer) return true;
 		}
 	else{	// works for C/C++
 		INC_INFORM(filename);
 		INFORM(": warning: did not end in \\n, undefined behavior.  Proceeding as if it was there.");
-		if (bool_options[boolopt::warnings_are_errors]) zcc_errors.inc_error();
+		if (bool_options[boolopt::warnings_are_errors])
+			zcc_errors.inc_error();
 		}
 	}
 
 	if ('\\'==Buffer[Buffer_size-1])	// works for C/C++ and other line-continue languages
-	{
+		{
 		INC_INFORM(filename);
 		INFORM(": warning: line continue \\ without a subsequent line, undefined behavior.  Proceeding as if subsequent line was empty.");
+		if (1==Buffer_size) return free(Buffer),true;
 #ifndef ZAIMONI_FORCE_ISO
 		Buffer = REALLOC(Buffer,ArraySize(Buffer)-1);
 #else
 		Buffer = REALLOC(Buffer,--Buffer_size);
 #endif
-		if (NULL==Buffer) return true;
-	}
+		}
 	if (!lang.ApplyGlobalFilters(Buffer)) exit(EXIT_FAILURE);
 	lang.FlattenComments(Buffer);
 
@@ -111,17 +112,13 @@
 
 	// next: split on newline, to simplify spotting preprocessing-directives vs file to be preprocessed
 	TokenList[0]->ltrim(strspn(TokenList[0]->data(),"\n"));
-	if (TokenList[0]->empty())
-	{
-		TokenList.reset();
-		return true;
-	};
+	if (TokenList[0]->empty()) return TokenList.reset(),true;
 
 	if (lang.BreakTokenOnNewline)
-	{
-		char* newline_where = strchr(TokenList.back()->data(),'\n');
-		while(NULL!=newline_where)
 		{
+		char* newline_where = strchr(TokenList.back()->data(),'\n');
+		while(newline_where)
+			{
 			const size_t offset = newline_where-TokenList.back()->data();
 			if (!TokenList.InsertNSlotsAt(1,TokenList.size()-1)) throw std::bad_alloc();
 			TokenList[TokenList.size()-2] = new Token<char>(*TokenList.back(),offset,0);
@@ -129,29 +126,29 @@
 			if (3<=TokenList.size()) clean_linesplice_whitespace(TokenList,TokenList.size()-3,lang);
 			TokenList.back()->ltrim(strspn(TokenList.back()->data(),"\n"));
 			if (TokenList.back()->empty())
-			{
+				{
 				TokenList.DeleteIdx(TokenList.size()-1);
 				break;
-			}
+				}
 			newline_where = strchr(TokenList.back()->data(),'\n');
-		}
+			}
 
 		// final cleanup: works for line-continue languages that consider pure whitespace lines meaningless
 		if (2<=TokenList.size()) clean_linesplice_whitespace(TokenList,TokenList.size()-2,lang);
 		if (!TokenList.empty()) clean_whitespace(TokenList,TokenList.size()-1,lang);
-	}
+		}
 
 	// if the language approves, flush leading whitespace
 	// do not trim trailing whitespace at this time: this breaks error reporting for incomplete C [wide/narrow] character/string literals
 	//! \todo work out how to handle tab stops cleanly
 	{
-		size_t i = TokenList.size();
-		while(0<i)
+	size_t i = TokenList.size();
+	while(0<i)
 		{
-			assert(NULL!=TokenList[i-1]);
-			size_t LeadingWS = strspn(TokenList[--i]->data(),lang.WhiteSpace+1);
-			TokenList[i]->ltrim(LeadingWS);
-			assert(!TokenList[i]->empty());
+		assert(NULL!=TokenList[i-1]);
+		size_t LeadingWS = strspn(TokenList[--i]->data(),lang.WhiteSpace+1);
+		TokenList[i]->ltrim(LeadingWS);
+		assert(!TokenList[i]->empty());
 		}
 	}
 
@@ -190,7 +187,7 @@
 	size_t Buffer_size = 0;
 #endif
 
-	assert(!zaimoni::is_empty_string(filename));
+	assert(filename && *filename);
 
 	// XXX should return true for empty files XXX
 #ifndef ZAIMONI_FORCE_ISO
@@ -209,12 +206,12 @@
 	while(newline_count<BufferSizeSub1 && '\n'==Buffer[BufferSizeSub1-newline_count]) ++newline_count;
 	if (0<newline_count)
 		{
+		if (Buffer_size<=newline_count) return free(Buffer),true;
 #ifndef ZAIMONI_FORCE_ISO
 		Buffer = REALLOC(Buffer,(ArraySize(Buffer)-newline_count));
 #else
 		Buffer = REALLOC(Buffer,(Buffer_size -= newline_count));
 #endif
-		if (NULL==Buffer) return true;
 		}
 	else{	// works for C/C++
 		INC_INFORM(filename);
@@ -238,20 +235,19 @@
 		}
 
 	char* newline_where = strchr(TokenList.back()->data(),'\n');
-	while(NULL!=newline_where)
-	{
+	while(newline_where)
+		{
 		const size_t offset = newline_where-TokenList.back()->data();
 		if (!TokenList.InsertNSlotsAt(1,TokenList.size()-1)) throw std::bad_alloc();
 		TokenList[TokenList.size()-2] = new Token<char>(*TokenList.back(),offset,0);
 		assert('\n'==TokenList.back()->data()[0]);
 		TokenList.back()->ltrim(strspn(TokenList.back()->data(),"\n"));
 		if (TokenList.back()->empty())
-		{
+			{
 			TokenList.DeleteIdx(TokenList.size()-1);
 			break;
-		}
+			}
 		newline_where = strchr(TokenList.back()->data(),'\n');
-	}
+		}
 	return true;
 }
-

Modified: trunk/type_spec.cpp
===================================================================
--- trunk/type_spec.cpp	2010-04-22 07:06:59 UTC (rev 389)
+++ trunk/type_spec.cpp	2010-04-22 20:26:38 UTC (rev 390)
@@ -72,6 +72,9 @@
 	q_vector.resize(old_ptr_power);	// lost a level of indirection
 	if (0<pointer_power)
 		{
+#if ZAIMONI_REALLOC_TO_ZERO_IS_NULL
+		extent_vector = REALLOC(extent_vector,--pointer_power*sizeof(*extent_vector));
+#else
 		if (0== --pointer_power)
 			{
 			FREE_AND_NULL(extent_vector);
@@ -79,6 +82,7 @@
 		else{
 			extent_vector = REALLOC(extent_vector,pointer_power*sizeof(*extent_vector));
 			}
+#endif
 		return true;
 		}
 	assert(0<static_array_size);	// other cause of non-zero pointer power after array decay



From zaimoni at mail.berlios.de  Sun Apr 25 20:08:33 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 25 Apr 2010 20:08:33 +0200
Subject: [Zcplusplus-commits] r391 - in trunk: . Zaimoni.STL Zaimoni.STL/bits
Message-ID: <201004251808.o3PI8Xbn008082@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-25 20:08:22 +0200 (Sun, 25 Apr 2010)
New Revision: 391

Added:
   trunk/Zaimoni.STL/bits/cstdio_autoptr.hpp
Modified:
   trunk/POSIX.dep
   trunk/Zaimoni.STL/AutoPtr.hpp
   trunk/Zaimoni.STL/cstdio
Log:
finish get_filelength relocation

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-04-22 20:26:38 UTC (rev 390)
+++ trunk/POSIX.dep	2010-04-25 18:08:22 UTC (rev 391)
@@ -5,7 +5,7 @@
 OBJECTS_ZCC_LINK_PRIORITY = zcc.o CPreproc.o unsigned_aux.o ParseTree.o Flat_UNI.o unsigned_var_int.o CSupport.o type_system.o CPUInfo.o CPreproc_autogen.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o errors.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
 
 # dependencies
-z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc_pp.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
+z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc_pp.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
 errors.o: errors.hpp langroute.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 langroute.o: langroute.hpp _CSupport1.hpp Zaimoni.STL/Logging.h Zaimoni.STL/POD.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp
 AtomicString.o: AtomicString.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -15,11 +15,11 @@
 uchar_blob.o: uchar_blob.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp
 unsigned_var_int.o: unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp
 CPUInfo.o: CPUInfo.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp
-struct_type.o: struct_type.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp
-type_system.o: type_system.hpp type_system_pp.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
+struct_type.o: struct_type.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp
+type_system.o: type_system.hpp type_system_pp.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL!
 /pure.C/format_util.h C_PPNumCore.hpp
+CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Za!
 imoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -29,11 +29,11 @@
 unsigned_aux.o: unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 Trigraph.o: Trigraph.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 Flat_UNI.o: Flat_UNI.hpp lex_core.h Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
-load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/comptest.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
-CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimo!
 ni.STL/LexParse/MetaToken.hpp
-CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
-zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
-CSupport.o: CSupport.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hp!
 p Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
-CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/meta!
 type/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
-CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
-ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/stdio_c.h Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
+CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zai!
 moni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
+zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
+CSupport.o: CSupport.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned!
 _aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimo!
 ni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
+ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2010-04-22 20:26:38 UTC (rev 390)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2010-04-25 18:08:22 UTC (rev 391)
@@ -792,4 +792,6 @@
 
 }		// end namespace zaimoni
 
+#include "bits/cstdio_autoptr.hpp"
+
 #endif

Added: trunk/Zaimoni.STL/bits/cstdio_autoptr.hpp
===================================================================
--- trunk/Zaimoni.STL/bits/cstdio_autoptr.hpp	2010-04-22 20:26:38 UTC (rev 390)
+++ trunk/Zaimoni.STL/bits/cstdio_autoptr.hpp	2010-04-25 18:08:22 UTC (rev 391)
@@ -0,0 +1,42 @@
+#ifdef ZAIMONI_AUTOPTR_HPP 
+#ifdef ZAIMONI_CSTDIO 
+#ifndef ZAIMONI_STL_BITS_CSTDIO_AUTOPTR_HPP
+#define ZAIMONI_STL_BITS_CSTDIO_AUTOPTR_HPP 1
+
+namespace zaimoni {
+
+template<class T>
+inline typename boost::enable_if<boost::has_trivial_assign<T>, bool>::type
+GetBinaryFileImage(const char* const Filename,_meta_autoarray_ptr<T>& buf)
+{	// FORMALLY CORRECT: Kenneth Boyd, 11/10/2004
+	assert(Filename && *Filename);
+	assert(buf.empty());
+
+	FILE* TargetFile = fopen(Filename, "rb");
+	if (!TargetFile) return false;
+
+	// Want to know the file length *BEFORE* inhaling it
+	long ScriptLength = get_filelength(TargetFile);
+	if (-1==ScriptLength)
+		{
+		fclose(TargetFile);
+		return false;
+		}
+
+	assert(0==ScriptLength%sizeof(T));
+	size_t ActuallyRead = 0;
+	if (0<ScriptLength)
+		{
+		if (!buf.Resize(ScriptLength)) return false;
+		ActuallyRead = fread(buf,sizeof(T),ScriptLength/sizeof(T),TargetFile);
+		}
+
+	fclose(TargetFile);
+	return ActuallyRead==ScriptLength/sizeof(T);
+}
+
+}	// end namespace zaimoni
+
+#endif
+#endif
+#endif

Modified: trunk/Zaimoni.STL/cstdio
===================================================================
--- trunk/Zaimoni.STL/cstdio	2010-04-22 20:26:38 UTC (rev 390)
+++ trunk/Zaimoni.STL/cstdio	2010-04-25 18:08:22 UTC (rev 391)
@@ -7,13 +7,8 @@
 
 #include "Logging.h"
 #include "MetaRAM.hpp"
-#include <stdio.h>
-#include "Pure.C/comptest.h"
+#include "Pure.C/stdio_c.h"
 
-#ifdef ZAIMONI_HAVE_MICROSOFT_IO_H
-#include <io.h>
-#endif
-
 namespace zaimoni {
 
 template<class T>
@@ -74,28 +69,12 @@
 	if (NULL==TargetFile) return false;
 
 	// Want to know the file length *BEFORE* inhaling it
-#ifdef ZAIMONI_HAVE_MICROSOFT_IO_H
-	long ScriptLength = _filelength(_fileno(TargetFile));
-	if (-1==ScriptLength)	/* XXX required by secure coding standards XXX */
-	{
+	long ScriptLength = get_filelength(TargetFile);
+	if (-1==ScriptLength)
+		{
 		fclose(TargetFile);
 		return false;
-	}
-#else
-	// Failing over to implementation-defined extension of ISO C.
-	if (fseek(TargetFile,0,SEEK_END))	// ISO does not guarantee this works.
-	{
-		fclose(TargetFile);
-		return false;
-	};
-	long ScriptLength = ftell(TargetFile);
-	if (-1==ScriptLength)	/* XXX required by secure coding standards XXX */
-	{
-		fclose(TargetFile);
-		return false;
-	}
-	rewind(TargetFile);
-#endif
+		}
 
 	assert(0==ScriptLength%sizeof(T));
 	size_t ActuallyRead = 0;
@@ -129,4 +108,6 @@
 
 }	// end namespace zaimoni
 
+#include "bits/cstdio_autoptr.hpp"
+
 #endif



From zaimoni at mail.berlios.de  Sun Apr 25 22:56:22 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 25 Apr 2010 22:56:22 +0200
Subject: [Zcplusplus-commits] r392 - trunk
Message-ID: <201004252056.o3PKuM5U019686@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-25 22:56:15 +0200 (Sun, 25 Apr 2010)
New Revision: 392

Modified:
   trunk/CPUInfo.cpp
   trunk/CPUInfo.hpp
   trunk/CPreproc_autogen.cpp
   trunk/CPreproc_autogen_pp.cpp
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
remove ZCC_LEGACY_FIXED_INT and its preprocessor blocks

Modified: trunk/CPUInfo.cpp
===================================================================
--- trunk/CPUInfo.cpp	2010-04-25 18:08:22 UTC (rev 391)
+++ trunk/CPUInfo.cpp	2010-04-25 20:56:15 UTC (rev 392)
@@ -10,15 +10,6 @@
 
 void CPUInfo::_init()
 {
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM+1> tmp;
-
-#define SET_MAXIMUM(A)	\
-	tmp.clear();	\
-	tmp.set((SUCCEED_OR_DIE(VM_MAX_BIT_PLATFORM>=C_char_bit()*C_sizeof_##A()),C_char_bit()*C_sizeof_##A()));	\
-	tmp -= 1;	\
-	unsigned_maxima[std_int_##A-1] = tmp
-#else
 	unsigned_var_int tmp;
 
 #define SET_MAXIMUM(A)	\
@@ -28,7 +19,6 @@
 	tmp -= 1;	\
 	tmp.set_bitcount(C_bit<std_int_long_long>());	\
 	tmp.MoveInto(unsigned_maxima[std_int_##A-1])
-#endif
 
 	SET_MAXIMUM(char);
 	SET_MAXIMUM(short);
@@ -55,11 +45,7 @@
 	const unsigned int bitcount = C_bit(machine_type);
 	const int target_bytecount = bitcount/CHAR_BIT;
 	const unsigned int target_bitcount = bitcount%CHAR_BIT;
-#ifdef ZCC_LEGACY_FIXED_INT
-	assert(VM_MAX_BIT_PLATFORM>=bitcount && 1<=bitcount);
-#else
 	assert(C_bit<std_int_long_long>()>=bitcount && 1<=bitcount);
-#endif
 
 	switch(C_signed_int_representation())
 	{
@@ -99,29 +85,17 @@
 		tmp += 1;
 		tmp.mask_to(C_bit(machine_type));
 		}
-#ifdef ZCC_LEGACY_FIXED_INT
-	src_int = tmp;
-#else
 	tmp.MoveInto(src_int);
-#endif
 }
 
 void CPUInfo::unsigned_additive_inverse(umaxint& src_int,std_int_enum machine_type) const
 {
 	assert(machine_type);
 	assert(src_int<=unsigned_max(machine_type));
-#ifdef ZCC_LEGACY_FIXED_INT
-	umaxint tmp(0);
-#else
 	umaxint tmp(0,src_int.size());
-#endif
 	tmp -= src_int;
 	tmp.mask_to(C_bit(machine_type));
-#ifdef ZCC_LEGACY_FIXED_INT
-	src_int = tmp;
-#else
 	tmp.MoveInto(src_int);
-#endif
 }
 
 bool CPUInfo::is_zero(const unsigned char* x, size_t x_len, const promotion_info& targettype) const

Modified: trunk/CPUInfo.hpp
===================================================================
--- trunk/CPUInfo.hpp	2010-04-25 18:08:22 UTC (rev 391)
+++ trunk/CPUInfo.hpp	2010-04-25 20:56:15 UTC (rev 392)
@@ -4,11 +4,7 @@
 #ifndef CPUINFO_HPP
 #define CPUINFO_HPP
 
-#ifdef ZCC_LEGACY_FIXED_INT
-#include "unsigned_fixed_int.hpp"
-#else
 #include "unsigned_var_int.hpp"
-#endif
 
 namespace virtual_machine {
 
@@ -41,21 +37,13 @@
 	bool is_signed;	// as in std::numeric_limits
 };
 
-#ifdef ZCC_LEGACY_FIXED_INT
-// adjust this upwards as needed
-#define VM_MAX_BIT_PLATFORM 64
-#else
 // as the implementation, we are free to not provide a larger type than
 // C long long.  Yhis macro doesn't work so well outside of the language 
 // support files, which are expected to declare a CPUInfo* target_machine
 #define VM_MAX_BIT_PLATFORM target_machine->C_bit<virtual_machine::std_int_long_long>()
-#endif
 
-#ifdef ZCC_LEGACY_FIXED_INT
-	typedef unsigned_fixed_int<VM_MAX_BIT_PLATFORM> umaxint;
-#else
-	typedef unsigned_var_int umaxint;
-#endif	
+// leave this typedef, just in case we have to change this around again
+typedef unsigned_var_int umaxint;
 
 // names of macro parameters match names of constructor variables
 // target wchar_t is assumed to be an unsigned integral type

Modified: trunk/CPreproc_autogen.cpp
===================================================================
--- trunk/CPreproc_autogen.cpp	2010-04-25 18:08:22 UTC (rev 391)
+++ trunk/CPreproc_autogen.cpp	2010-04-25 20:56:15 UTC (rev 392)
@@ -14,13 +14,10 @@
 
 using virtual_machine::umaxint;
 
-#ifndef ZCC_LEGACY_FIXED_INT
 // XXX adjust VM_MAX_BIT_PLATFORM to work inside of CPreprocessor XXX
 #undef VM_MAX_BIT_PLATFORM
 #define VM_MAX_BIT_PLATFORM target_machine.C_bit<virtual_machine::std_int_long_long>()
-#endif
 
-
 //! \bug Once And Only Once violation
 #define DICT_STRUCT(A) { (A), sizeof(A)-1 }
 
@@ -286,7 +283,7 @@
 disallow_prior_definitions(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,size_t i,const char* const * identifiers,size_t identifiers_len)
 {
 	assert(TokenList.size()>i);
-	assert(NULL!=identifiers);
+	assert(identifiers);
 	assert(0<identifiers_len);
 	assert(SIZE_MAX/4>=identifiers_len);
 /*
@@ -298,7 +295,7 @@
 	if (!TokenList.InsertNSlotsAt(4*identifiers_len,i)) throw std::bad_alloc();
 	while(0<identifiers_len)
 		{
-		assert(NULL!=*identifiers && '\0'!=**identifiers);
+		assert(*identifiers && **identifiers);
 		zaimoni::Token<char>** const tmp = TokenList.c_array();
 		tmp[i+3] = new zaimoni::Token<char>("#endif",0,sizeof("#endif")-1,0);
 
@@ -357,12 +354,12 @@
 lockdown_reserved_identifiers(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const size_t i,const char* const * identifiers,size_t identifiers_len)
 {
 	assert(TokenList.size()>i);
-	assert(NULL!=identifiers);
+	assert(identifiers);
 	assert(0<identifiers_len);
 	size_t target_len = sizeof("#pragma ZCC lock")-1;
 	size_t j = 0;
 	do	{
-		assert(NULL!=*identifiers && '\0'!=**identifiers);
+		assert(*identifiers && **identifiers);
 		target_len += strlen(identifiers[j])+1;
 		}
 	while(identifiers_len> ++j);
@@ -397,13 +394,13 @@
 
 static void final_init_tokenlist(zaimoni::Token<char>* const * x, size_t x_len, const char* const header_name)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(0<x_len);
-	assert(NULL!=header_name);
+	assert(header_name && *header_name);
 	while(0<x_len)
 		{
 		--x_len;
-		assert(NULL!=x[x_len]);
+		assert(x[x_len]);
 		x[x_len]->logical_line.first = x_len+1;
 		x[x_len]->logical_line.second = 0;
 		x[x_len]->original_line = x[x_len]->logical_line;
@@ -420,17 +417,12 @@
 void
 CPreprocessor::create_limits_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
+	assert(header_name && *header_name);
+	assert(TokenList.empty());
 	// 2 for: leading space, trailing null-termination
 	// (VM_MAX_BIT_PLATFORM/3) for: digits (using octal rather than decimal count because that's easy to do at compile-time)
-#ifdef ZCC_LEGACY_FIXED_INT
-	// currently, worst-case platform we support has a 64-bit two's-complenent long long
-	char buf[2+(VM_MAX_BIT_PLATFORM/3)] = " ";
-#else
 	zaimoni::autovalarray_ptr_throws<char> buf(2+(VM_MAX_BIT_PLATFORM/3));
 	buf[0] = ' ';
-#endif
-	assert(NULL!=header_name);
-	assert(TokenList.empty());
 	zaimoni::autovalarray_ptr<zaimoni::Token<char>* > TmpTokenList(STATIC_SIZE(limits_h_core));
 	zaimoni::Token<char>** tmp = TmpTokenList.c_array();
 	
@@ -609,7 +601,7 @@
 void
 CPreprocessor::create_stddef_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
-	assert(NULL!=header_name);
+	assert(header_name && *header_name);
 	assert(TokenList.empty());
 	zaimoni::autovalarray_ptr<zaimoni::Token<char>* > TmpTokenList(STATIC_SIZE(stddef_h_core));
 	zaimoni::Token<char>** tmp = TmpTokenList.c_array();
@@ -623,17 +615,17 @@
 
 	// C99 17.7p2 : typedefs; C++ versions in namespace std
 	const char* const ptrdiff_str = signed_type_from_machine(target_machine.ptrdiff_t_type());
-	assert(NULL!=ptrdiff_str);
+	assert(ptrdiff_str);
 	tmp[STDDEF_PTRDIFF_T_LINE]->append(ptrdiff_str," ptrdiff_t;");
 	tmp[STDDEF_CPP_PTRDIFF_T_LINE]->append(ptrdiff_str," ptrdiff_t;");
 
 	const char* const size_t_str = unsigned_type_from_machine(target_machine.size_t_type());
-	assert(NULL!=size_t_str);
+	assert(size_t_str);
 	tmp[STDDEF_SIZE_T_LINE]->append(size_t_str," size_t;");
 	tmp[STDDEF_CPP_SIZE_T_LINE]->append(size_t_str," size_t;");
 
 	const char* const wchar_t_str = unsigned_type_from_machine(target_machine.UNICODE_wchar_t());
-	assert(NULL!=wchar_t_str);
+	assert(wchar_t_str);
 	tmp[STDDEF_WCHAR_T_LINE]->append(wchar_t_str," wchar_t;");
 
 	// C99 17.7p3 : macros
@@ -651,7 +643,7 @@
 
 static void new_token_at(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& dest,size_t i,const char* const src)
 {
-	assert(NULL!=src && *src);
+	assert(src && *src);
 	zaimoni::Token<char>* tmp = new zaimoni::Token<char>(src,0,strlen(src),0);
 	if (!dest.InsertSlotAt(i,tmp))
 		{
@@ -664,8 +656,8 @@
 static void memset_strcpy(char* dest,const char* src)
 {
 	BOOST_STATIC_ASSERT(offset<buf_size);
-	assert(NULL!=dest);
-	assert(NULL!=src);
+	assert(dest);
+	assert(src);
 	assert(buf_size-offset>strlen(src));
 	memset(dest += offset,0,buf_size-offset);
 	strcpy(dest,src);
@@ -675,8 +667,8 @@
 static void memset_strcpy(char* dest,const char* src,size_t buf_size)
 {
 	assert(offset<buf_size);
-	assert(NULL!=dest);
-	assert(NULL!=src);
+	assert(dest);
+	assert(src);
 	assert(buf_size-offset>strlen(src));
 	memset(dest += offset,0,buf_size-offset);
 	strcpy(dest,src);
@@ -693,16 +685,11 @@
 void
 CPreprocessor::create_stdint_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
-	assert(NULL!=header_name);
+	assert(header_name && *header_name);
 	assert(TokenList.empty());
 	// 2 for: leading space, trailing null-termination
 	// (VM_MAX_BIT_PLATFORM/3) for: digits (using octal rather than decimal count because that's easy to do at compile-time)
-#ifdef ZCC_LEGACY_FIXED_INT
-	// currently, worst-case platform we support has a 64-bit two's-complenent long long
-	char buf[2+(VM_MAX_BIT_PLATFORM/3)] = " ";
-#else
 	zaimoni::autovalarray_ptr_throws<char> buf(2+(VM_MAX_BIT_PLATFORM/3));
-#endif
 	zaimoni::autovalarray_ptr<zaimoni::Token<char>* > TmpTokenList(STATIC_SIZE(stdint_h_core));
 	zaimoni::Token<char>** tmp = TmpTokenList.c_array();
 
@@ -716,11 +703,7 @@
 	while(0<i);
 
 	// set up some result strings
-#ifdef ZCC_LEGACY_FIXED_INT
-	char signed_max_metabuf[virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+4)] = "";
-#else
 	zaimoni::autovalarray_ptr_throws<char> signed_max_metabuf(virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+4));
-#endif
 	char* signed_max_buf[virtual_machine::std_int_enum_max] = {signed_max_metabuf, signed_max_metabuf+(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_max_metabuf+2*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_max_metabuf+3*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_max_metabuf+4*(2+(VM_MAX_BIT_PLATFORM/3)+2)};
 	*signed_max_buf[0] = ' ';
 	*signed_max_buf[1] = ' ';
@@ -735,11 +718,7 @@
 	strcat(signed_max_buf[virtual_machine::std_int_long-1],"L");
 	strcat(signed_max_buf[virtual_machine::std_int_long_long-1],"LL");
 
-#ifdef ZCC_LEGACY_FIXED_INT
-	char unsigned_max_metabuf[virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+3)] = "";
-#else
 	zaimoni::autovalarray_ptr_throws<char> unsigned_max_metabuf(virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+3));
-#endif
 	char* unsigned_max_buf[virtual_machine::std_int_enum_max] = {unsigned_max_metabuf, unsigned_max_metabuf+(2+(VM_MAX_BIT_PLATFORM/3)+2), unsigned_max_metabuf+2*(2+(VM_MAX_BIT_PLATFORM/3)+2), unsigned_max_metabuf+3*(2+(VM_MAX_BIT_PLATFORM/3)+2), unsigned_max_metabuf+4*(2+(VM_MAX_BIT_PLATFORM/3)+2)};
 	*unsigned_max_buf[0] = ' ';
 	*unsigned_max_buf[1] = ' ';
@@ -758,11 +737,7 @@
 	strcat(unsigned_max_buf[virtual_machine::std_int_long_long-1],"ULL");
 
 	const bool target_is_twos_complement = virtual_machine::twos_complement==target_machine.C_signed_int_representation();
-#ifdef ZCC_LEGACY_FIXED_INT
-	char signed_min_metabuf[virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+4)] = "";
-#else
 	zaimoni::autovalarray_ptr_throws<char> signed_min_metabuf(virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+4));
-#endif
 	char* signed_min_buf[virtual_machine::std_int_enum_max] = {signed_min_metabuf, signed_min_metabuf+(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+2*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+3*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+4*(2+(VM_MAX_BIT_PLATFORM/3)+2)};
 	umaxint tmp_VM;
 	if (target_is_twos_complement && !bool_options[boolopt::int_traps])
@@ -791,13 +766,8 @@
 		strcat(signed_min_buf[virtual_machine::std_int_long_long-1],"LL)");
 		}
 	else{
-#ifdef ZCC_LEGACY_FIXED_INT
-		BOOST_STATIC_ASSERT(sizeof(signed_min_metabuf)==sizeof(signed_max_metabuf));
-		memmove(signed_min_metabuf,signed_max_metabuf,sizeof(signed_max_metabuf));
-#else
 		assert(signed_min_metabuf.size()==signed_max_metabuf.size());
 		memmove(signed_min_metabuf,signed_max_metabuf,signed_max_metabuf.size());
-#endif
 		*signed_min_buf[0] = '-';
 		*signed_min_buf[1] = '-';
 		*signed_min_buf[2] = '-';
@@ -1259,12 +1229,8 @@
 		}
 	while(0<i);
 
-#ifdef ZCC_LEGACY_FIXED_INT
-	char define_buf[sizeof("#define UINT_LEAST_MAX")+2+VM_MAX_BIT_PLATFORM/3+5] = "#define ";
-#else
 	zaimoni::autovalarray_ptr_throws<char> define_buf(sizeof("#define UINT_LEAST_MAX")+2+VM_MAX_BIT_PLATFORM/3+5);
 	strcpy(define_buf,"#define ");
-#endif
 	i = 13*bitspan_types;
 	TmpTokenList.InsertNSlotsAt(i,inject_C_index);
 	tmp = TmpTokenList.c_array()+inject_C_index;

Modified: trunk/CPreproc_autogen_pp.cpp
===================================================================
--- trunk/CPreproc_autogen_pp.cpp	2010-04-25 18:08:22 UTC (rev 391)
+++ trunk/CPreproc_autogen_pp.cpp	2010-04-25 20:56:15 UTC (rev 392)
@@ -11,13 +11,10 @@
 
 using virtual_machine::umaxint;
 
-#ifndef ZCC_LEGACY_FIXED_INT
 // XXX adjust VM_MAX_BIT_PLATFORM to work inside of CPreprocessor XXX
 #undef VM_MAX_BIT_PLATFORM
 #define VM_MAX_BIT_PLATFORM target_machine.C_bit<virtual_machine::std_int_long_long>()
-#endif
 
-
 //! \bug Once And Only Once violation
 #define DICT_STRUCT(A) { (A), sizeof(A)-1 }
 
@@ -283,7 +280,7 @@
 disallow_prior_definitions(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,size_t i,const char* const * identifiers,size_t identifiers_len)
 {
 	assert(TokenList.size()>i);
-	assert(NULL!=identifiers);
+	assert(identifiers);
 	assert(0<identifiers_len);
 	assert(SIZE_MAX/4>=identifiers_len);
 /*
@@ -295,7 +292,7 @@
 	if (!TokenList.InsertNSlotsAt(4*identifiers_len,i)) throw std::bad_alloc();
 	while(0<identifiers_len)
 		{
-		assert(NULL!=*identifiers && '\0'!=**identifiers);
+		assert(*identifiers && **identifiers);
 		zaimoni::Token<char>** const tmp = TokenList.c_array();
 		tmp[i+3] = new zaimoni::Token<char>("#endif",0,sizeof("#endif")-1,0);
 
@@ -354,12 +351,12 @@
 lockdown_reserved_identifiers(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const size_t i,const char* const * identifiers,size_t identifiers_len)
 {
 	assert(TokenList.size()>i);
-	assert(NULL!=identifiers);
+	assert(identifiers);
 	assert(0<identifiers_len);
 	size_t target_len = sizeof("#pragma ZCC lock")-1;
 	size_t j = 0;
 	do	{
-		assert(NULL!=*identifiers && '\0'!=**identifiers);
+		assert(*identifiers && **identifiers);
 		target_len += strlen(identifiers[j])+1;
 		}
 	while(identifiers_len> ++j);
@@ -394,13 +391,13 @@
 
 static void final_init_tokenlist(zaimoni::Token<char>* const * x, size_t x_len, const char* const header_name)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(0<x_len);
-	assert(NULL!=header_name);
+	assert(header_name && *header_name);
 	while(0<x_len)
 		{
 		--x_len;
-		assert(NULL!=x[x_len]);
+		assert(x[x_len]);
 		x[x_len]->logical_line.first = x_len+1;
 		x[x_len]->logical_line.second = 0;
 		x[x_len]->original_line = x[x_len]->logical_line;
@@ -417,17 +414,12 @@
 void
 CPreprocessor::create_limits_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
+	assert(header_name && *header_name);
+	assert(TokenList.empty());
 	// 2 for: leading space, trailing null-termination
 	// (VM_MAX_BIT_PLATFORM/3) for: digits (using octal rather than decimal count because that's easy to do at compile-time)
-#ifdef ZCC_LEGACY_FIXED_INT
-	// currently, worst-case platform we support has a 64-bit two's-complenent long long
-	char buf[2+(VM_MAX_BIT_PLATFORM/3)] = " ";
-#else
 	zaimoni::autovalarray_ptr_throws<char> buf(2+(VM_MAX_BIT_PLATFORM/3));
 	buf[0] = ' ';
-#endif
-	assert(NULL!=header_name);
-	assert(TokenList.empty());
 	zaimoni::autovalarray_ptr<zaimoni::Token<char>* > TmpTokenList(STATIC_SIZE(limits_h_core));
 	zaimoni::Token<char>** tmp = TmpTokenList.c_array();
 	
@@ -606,7 +598,7 @@
 void
 CPreprocessor::create_stddef_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
-	assert(NULL!=header_name);
+	assert(header_name && *header_name);
 	assert(TokenList.empty());
 	zaimoni::autovalarray_ptr<zaimoni::Token<char>* > TmpTokenList(STATIC_SIZE(stddef_h_core));
 	zaimoni::Token<char>** tmp = TmpTokenList.c_array();
@@ -620,17 +612,17 @@
 
 	// C99 17.7p2 : typedefs; C++ versions in namespace std
 	const char* const ptrdiff_str = signed_type_from_machine(target_machine.ptrdiff_t_type());
-	assert(NULL!=ptrdiff_str);
+	assert(ptrdiff_str);
 	tmp[STDDEF_PTRDIFF_T_LINE]->append(ptrdiff_str," ptrdiff_t;");
 	tmp[STDDEF_CPP_PTRDIFF_T_LINE]->append(ptrdiff_str," ptrdiff_t;");
 
 	const char* const size_t_str = unsigned_type_from_machine(target_machine.size_t_type());
-	assert(NULL!=size_t_str);
+	assert(size_t_str);
 	tmp[STDDEF_SIZE_T_LINE]->append(size_t_str," size_t;");
 	tmp[STDDEF_CPP_SIZE_T_LINE]->append(size_t_str," size_t;");
 
 	const char* const wchar_t_str = unsigned_type_from_machine(target_machine.UNICODE_wchar_t());
-	assert(NULL!=wchar_t_str);
+	assert(wchar_t_str);
 	tmp[STDDEF_WCHAR_T_LINE]->append(wchar_t_str," wchar_t;");
 
 	// C99 17.7p3 : macros
@@ -648,7 +640,7 @@
 
 static void new_token_at(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& dest,size_t i,const char* const src)
 {
-	assert(NULL!=src && *src);
+	assert(src && *src);
 	zaimoni::Token<char>* tmp = new zaimoni::Token<char>(src,0,strlen(src),0);
 	if (!dest.InsertSlotAt(i,tmp))
 		{
@@ -661,8 +653,8 @@
 static void memset_strcpy(char* dest,const char* src)
 {
 	BOOST_STATIC_ASSERT(offset<buf_size);
-	assert(NULL!=dest);
-	assert(NULL!=src);
+	assert(dest);
+	assert(src);
 	assert(buf_size-offset>strlen(src));
 	memset(dest += offset,0,buf_size-offset);
 	strcpy(dest,src);
@@ -672,8 +664,8 @@
 static void memset_strcpy(char* dest,const char* src,size_t buf_size)
 {
 	assert(offset<buf_size);
-	assert(NULL!=dest);
-	assert(NULL!=src);
+	assert(dest);
+	assert(src);
 	assert(buf_size-offset>strlen(src));
 	memset(dest += offset,0,buf_size-offset);
 	strcpy(dest,src);
@@ -690,16 +682,11 @@
 void
 CPreprocessor::create_stdint_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
-	assert(NULL!=header_name);
+	assert(header_name && *header_name);
 	assert(TokenList.empty());
 	// 2 for: leading space, trailing null-termination
 	// (VM_MAX_BIT_PLATFORM/3) for: digits (using octal rather than decimal count because that's easy to do at compile-time)
-#ifdef ZCC_LEGACY_FIXED_INT
-	// currently, worst-case platform we support has a 64-bit two's-complenent long long
-	char buf[2+(VM_MAX_BIT_PLATFORM/3)] = " ";
-#else
 	zaimoni::autovalarray_ptr_throws<char> buf(2+(VM_MAX_BIT_PLATFORM/3));
-#endif
 	zaimoni::autovalarray_ptr<zaimoni::Token<char>* > TmpTokenList(STATIC_SIZE(stdint_h_core));
 	zaimoni::Token<char>** tmp = TmpTokenList.c_array();
 
@@ -713,11 +700,7 @@
 	while(0<i);
 
 	// set up some result strings
-#ifdef ZCC_LEGACY_FIXED_INT
-	char signed_max_metabuf[virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+4)] = "";
-#else
 	zaimoni::autovalarray_ptr_throws<char> signed_max_metabuf(virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+4));
-#endif
 	char* signed_max_buf[virtual_machine::std_int_enum_max] = {signed_max_metabuf, signed_max_metabuf+(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_max_metabuf+2*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_max_metabuf+3*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_max_metabuf+4*(2+(VM_MAX_BIT_PLATFORM/3)+2)};
 	*signed_max_buf[0] = ' ';
 	*signed_max_buf[1] = ' ';
@@ -732,11 +715,7 @@
 	strcat(signed_max_buf[virtual_machine::std_int_long-1],"L");
 	strcat(signed_max_buf[virtual_machine::std_int_long_long-1],"LL");
 
-#ifdef ZCC_LEGACY_FIXED_INT
-	char unsigned_max_metabuf[virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+3)] = "";
-#else
 	zaimoni::autovalarray_ptr_throws<char> unsigned_max_metabuf(virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+3));
-#endif
 	char* unsigned_max_buf[virtual_machine::std_int_enum_max] = {unsigned_max_metabuf, unsigned_max_metabuf+(2+(VM_MAX_BIT_PLATFORM/3)+2), unsigned_max_metabuf+2*(2+(VM_MAX_BIT_PLATFORM/3)+2), unsigned_max_metabuf+3*(2+(VM_MAX_BIT_PLATFORM/3)+2), unsigned_max_metabuf+4*(2+(VM_MAX_BIT_PLATFORM/3)+2)};
 	*unsigned_max_buf[0] = ' ';
 	*unsigned_max_buf[1] = ' ';
@@ -755,11 +734,7 @@
 	strcat(unsigned_max_buf[virtual_machine::std_int_long_long-1],"ULL");
 
 	const bool target_is_twos_complement = virtual_machine::twos_complement==target_machine.C_signed_int_representation();
-#ifdef ZCC_LEGACY_FIXED_INT
-	char signed_min_metabuf[virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+4)] = "";
-#else
 	zaimoni::autovalarray_ptr_throws<char> signed_min_metabuf(virtual_machine::std_int_enum_max*(2+(VM_MAX_BIT_PLATFORM/3)+4));
-#endif
 	char* signed_min_buf[virtual_machine::std_int_enum_max] = {signed_min_metabuf, signed_min_metabuf+(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+2*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+3*(2+(VM_MAX_BIT_PLATFORM/3)+2), signed_min_metabuf+4*(2+(VM_MAX_BIT_PLATFORM/3)+2)};
 	umaxint tmp_VM;
 	if (target_is_twos_complement && !bool_options[boolopt::int_traps])
@@ -788,13 +763,8 @@
 		strcat(signed_min_buf[virtual_machine::std_int_long_long-1],"LL)");
 		}
 	else{
-#ifdef ZCC_LEGACY_FIXED_INT
-		BOOST_STATIC_ASSERT(sizeof(signed_min_metabuf)==sizeof(signed_max_metabuf));
-		memmove(signed_min_metabuf,signed_max_metabuf,sizeof(signed_max_metabuf));
-#else
 		assert(signed_min_metabuf.size()==signed_max_metabuf.size());
 		memmove(signed_min_metabuf,signed_max_metabuf,signed_max_metabuf.size());
-#endif
 		*signed_min_buf[0] = '-';
 		*signed_min_buf[1] = '-';
 		*signed_min_buf[2] = '-';
@@ -1256,12 +1226,8 @@
 		}
 	while(0<i);
 
-#ifdef ZCC_LEGACY_FIXED_INT
-	char define_buf[sizeof("#define UINT_LEAST_MAX")+2+VM_MAX_BIT_PLATFORM/3+5] = "#define ";
-#else
 	zaimoni::autovalarray_ptr_throws<char> define_buf(sizeof("#define UINT_LEAST_MAX")+2+VM_MAX_BIT_PLATFORM/3+5);
 	strcpy(define_buf,"#define ");
-#endif
 	i = 13*bitspan_types;
 	TmpTokenList.InsertNSlotsAt(i,inject_C_index);
 	tmp = TmpTokenList.c_array()+inject_C_index;

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-25 18:08:22 UTC (rev 391)
+++ trunk/CSupport.cpp	2010-04-25 20:56:15 UTC (rev 392)
@@ -2526,11 +2526,7 @@
 {
 	assert(NULL!=src);
 	assert(0<src_len);
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp(0);
-#else
 	unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
-#endif
 #ifndef NDEBUG
 	umaxint uchar_max(target_machine->unsigned_max<virtual_machine::std_int_long_long>());
 	uchar_max >>= 4;
@@ -3043,21 +3039,13 @@
 	{
 	default: return false;
 	case virtual_machine::ones_complement:		{
-#ifdef ZCC_LEGACY_FIXED_INT
-												unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp(0);
-#else
 												unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
-#endif
 												if (VM_MAX_BIT_PLATFORM>target_machine->C_char_bit()) tmp.set(target_machine->C_char_bit());
 												tmp -= 1;
 												return tmp==result;
 												}
 	case virtual_machine::sign_and_magnitude:	{
-#ifdef ZCC_LEGACY_FIXED_INT
-												unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp(0);
-#else
 												unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
-#endif
 												tmp.set(target_machine->C_char_bit()-1);
 												return tmp==result;
 												}
@@ -4207,13 +4195,8 @@
 	assert(8==src.radix || 10==src.radix || 16==src.radix);
 	assert(NULL!=src.ptr && 0<src.digit_span);
 
-#ifdef ZCC_LEGACY_FIXED_INT
-	const unsigned_fixed_int<VM_MAX_BIT_PLATFORM> alt_radix(src.radix);
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> strict_ub;
-#else
 	const unsigned_var_int alt_radix(src.radix,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 	unsigned_var_int strict_ub(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
-#endif
 	const char* target = src.ptr;
 	size_t target_len = src.digit_span;
 
@@ -5315,12 +5298,8 @@
 {
 	assert(C_TYPE::INT<=base_type_index && C_TYPE::ULLONG>=base_type_index);
 	const char* const suffix = literal_suffix(base_type_index);
-#ifdef ZCC_LEGACY_FIXED_INT
-	char buf[(VM_MAX_BIT_PLATFORM/3)+4];	// null-termination: 1 byte; 3 bytes for type hint
-#else
 	char* buf = _new_buffer<char>((VM_MAX_BIT_PLATFORM/3)+4);
 	if (!buf) return false;
-#endif
 	dest.second = literal_flags(base_type_index);
 	dest.second |= C_TESTFLAG_DECIMAL;
 	z_ucharint_toa(src_int,buf,10);
@@ -5329,19 +5308,13 @@
 	if (suffix) strcat(buf,suffix);
 
 	dest.first = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(strlen(buf)));
-#ifdef ZCC_LEGACY_FIXED_INT
-	if (!dest.first) return false;
-#else
 	if (!dest.first)
 		{
 		free(buf);
 		return false;
 		}
-#endif
 	strcpy(dest.first,buf);
-#ifndef ZCC_LEGACY_FIXED_INT
 	free(buf);
-#endif
 	return true;
 }
 

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-04-25 18:08:22 UTC (rev 391)
+++ trunk/CSupport_pp.cpp	2010-04-25 20:56:15 UTC (rev 392)
@@ -2434,11 +2434,7 @@
 {
 	assert(NULL!=src);
 	assert(0<src_len);
-#ifdef ZCC_LEGACY_FIXED_INT
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp(0);
-#else
 	unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
-#endif
 #ifndef NDEBUG
 	umaxint uchar_max(target_machine->unsigned_max<virtual_machine::std_int_long_long>());
 	uchar_max >>= 4;
@@ -2951,21 +2947,13 @@
 	{
 	default: return false;
 	case virtual_machine::ones_complement:		{
-#ifdef ZCC_LEGACY_FIXED_INT
-												unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp(0);
-#else
 												unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
-#endif
 												if (VM_MAX_BIT_PLATFORM>target_machine->C_char_bit()) tmp.set(target_machine->C_char_bit());
 												tmp -= 1;
 												return tmp==result;
 												}
 	case virtual_machine::sign_and_magnitude:	{
-#ifdef ZCC_LEGACY_FIXED_INT
-												unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp(0);
-#else
 												unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
-#endif
 												tmp.set(target_machine->C_char_bit()-1);
 												return tmp==result;
 												}
@@ -3813,13 +3801,8 @@
 	assert(8==src.radix || 10==src.radix || 16==src.radix);
 	assert(NULL!=src.ptr && 0<src.digit_span);
 
-#ifdef ZCC_LEGACY_FIXED_INT
-	const unsigned_fixed_int<VM_MAX_BIT_PLATFORM> alt_radix(src.radix);
-	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> strict_ub;
-#else
 	const unsigned_var_int alt_radix(src.radix,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 	unsigned_var_int strict_ub(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
-#endif
 	const char* target = src.ptr;
 	size_t target_len = src.digit_span;
 
@@ -4845,12 +4828,8 @@
 {
 	assert(C_TYPE::INT<=base_type_index && C_TYPE::ULLONG>=base_type_index);
 	const char* const suffix = literal_suffix(base_type_index);
-#ifdef ZCC_LEGACY_FIXED_INT
-	char buf[(VM_MAX_BIT_PLATFORM/3)+4];	// null-termination: 1 byte; 3 bytes for type hint
-#else
 	char* buf = _new_buffer<char>((VM_MAX_BIT_PLATFORM/3)+4);
 	if (!buf) return false;
-#endif
 	dest.second = literal_flags(base_type_index);
 	dest.second |= C_TESTFLAG_DECIMAL;
 	z_ucharint_toa(src_int,buf,10);
@@ -4859,19 +4838,13 @@
 	if (suffix) strcat(buf,suffix);
 
 	dest.first = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(strlen(buf)));
-#ifdef ZCC_LEGACY_FIXED_INT
-	if (!dest.first) return false;
-#else
 	if (!dest.first)
 		{
 		free(buf);
 		return false;
 		}
-#endif
 	strcpy(dest.first,buf);
-#ifndef ZCC_LEGACY_FIXED_INT
 	free(buf);
-#endif
 	return true;
 }
 



From zaimoni at mail.berlios.de  Sun Apr 25 22:57:01 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 25 Apr 2010 22:57:01 +0200
Subject: [Zcplusplus-commits] r393 - in trunk: . freezer
Message-ID: <201004252057.o3PKv1hT019727@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-25 22:56:57 +0200 (Sun, 25 Apr 2010)
New Revision: 393

Added:
   trunk/freezer/unsigned_fixed_int.hpp
Removed:
   trunk/unsigned_fixed_int.hpp
Log:
send unsigned_fixed_int support to freezer

Copied: trunk/freezer/unsigned_fixed_int.hpp (from rev 373, trunk/unsigned_fixed_int.hpp)

Deleted: trunk/unsigned_fixed_int.hpp
===================================================================
--- trunk/unsigned_fixed_int.hpp	2010-04-25 20:56:15 UTC (rev 392)
+++ trunk/unsigned_fixed_int.hpp	2010-04-25 20:56:57 UTC (rev 393)
@@ -1,313 +0,0 @@
-// unsigned_fixed_int.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
-
-#ifndef UNSIGNED_FIXED_INT_HPP
-#define UNSIGNED_FIXED_INT_HPP 1
-
-#include "unsigned_aux.hpp"
-
-// the main class
-template<size_t N>
-struct _unsigned_fixed_charint
-{
-	ZAIMONI_STATIC_ASSERT(0<N);
-	unsigned char _x[N];
-
-	_unsigned_fixed_charint() {};
-	explicit _unsigned_fixed_charint(uintmax_t src);
-	template<size_t M> explicit _unsigned_fixed_charint(const _unsigned_fixed_charint<M>& src);
-	_unsigned_fixed_charint(const _unsigned_fixed_charint& src) {memcpy(_x,src._x,N);};
-
-	_unsigned_fixed_charint& operator=(const _unsigned_fixed_charint& src) {memcpy(_x,src._x,N); return *this;};
-	template<size_t M> _unsigned_fixed_charint& operator=(const _unsigned_fixed_charint<M>& src);
-	_unsigned_fixed_charint& operator=(uintmax_t src);
-	_unsigned_fixed_charint& operator~() {bitwise_compl(_x,N); return *this;};
-	void auto_bitwise_complement() {bitwise_compl(_x,N);};
-	_unsigned_fixed_charint& operator+=(const _unsigned_fixed_charint& rhs) {unsigned_sum(_x,N,rhs._x); return *this;};
-	_unsigned_fixed_charint& operator+=(uintmax_t rhs) {unsigned_sum(_x,N,rhs); return *this;};
-	_unsigned_fixed_charint& operator-=(const _unsigned_fixed_charint& rhs) {unsigned_diff(_x,N,rhs._x); return *this;};
-	_unsigned_fixed_charint& operator-=(uintmax_t rhs) {unsigned_diff(_x,N,rhs); return *this;};
-	_unsigned_fixed_charint& operator*=(const _unsigned_fixed_charint& rhs);
-	_unsigned_fixed_charint& operator&=(const _unsigned_fixed_charint& rhs) {bitwise_and(_x,N,rhs._x); return *this;};
-	_unsigned_fixed_charint& operator^=(const _unsigned_fixed_charint& rhs) {bitwise_xor(_x,N,rhs._x); return *this;};
-	_unsigned_fixed_charint& operator|=(const _unsigned_fixed_charint& rhs) {bitwise_or(_x,N,rhs._x); return *this;};
-	_unsigned_fixed_charint& operator>>=(uintmax_t rhs) {unsigned_right_shift(_x,N,rhs); return *this;};
-	_unsigned_fixed_charint& operator<<=(uintmax_t rhs) {unsigned_left_shift(_x,N,rhs); return *this;};
-
-	void div_op(const _unsigned_fixed_charint& divisor, _unsigned_fixed_charint& quotient) {remainder_quotient<N>(c_array(),divisor.data(),quotient.c_array());};
-
-	_unsigned_fixed_charint& operator/=(const _unsigned_fixed_charint& rhs);
-	_unsigned_fixed_charint& operator%=(const _unsigned_fixed_charint& rhs);
-
-	unsigned int int_log2() const {return ::int_log2(_x,N);};
-
-	void set(size_t n)
-		{
-		assert(N>n/CHAR_BIT);
-		_x[n/CHAR_BIT] |= ((unsigned char)(1U))<<(n%CHAR_BIT);
-		};
-	void set(size_t n,bool x)
-		{
-		assert(N>n/CHAR_BIT);
-		if (x)
-			_x[n/CHAR_BIT] |= ((unsigned char)(1U))<<(n%CHAR_BIT);
-		else
-			_x[n/CHAR_BIT] &= ~(((unsigned char)(1U))<<(n%CHAR_BIT));
-		};
-	template<size_t n> void set()
-		{
-		ZAIMONI_STATIC_ASSERT(N>n/CHAR_BIT);
-		_x[n/CHAR_BIT] |= ((unsigned char)(1U))<<(n%CHAR_BIT);
-		}
-	template<size_t n> void set(bool x)
-		{
-		ZAIMONI_STATIC_ASSERT(N>n/CHAR_BIT);
-		if (x)
-			_x[n/CHAR_BIT] |= ((unsigned char)(1U))<<(n%CHAR_BIT);
-		else
-			_x[n/CHAR_BIT] &= ~(((unsigned char)(1U))<<(n%CHAR_BIT));
-		}
-	void reset(size_t n)
-		{
-		assert(N>n/CHAR_BIT);
-		_x[n/CHAR_BIT] &= ~(((unsigned char)(1U))<<(n%CHAR_BIT));
-		};
-	template<size_t n> void reset()
-		{
-		ZAIMONI_STATIC_ASSERT(N>n/CHAR_BIT);
-		_x[n/CHAR_BIT] &= ~(((unsigned char)(1U))<<(n%CHAR_BIT));
-		}
-
-	bool test(size_t n) const
-		{
-		assert(N>n/CHAR_BIT);
-		return _x[n/CHAR_BIT] & (((unsigned char)(1U))<<(n%CHAR_BIT));
-		}
-	template<size_t n> bool test() const
-		{
-		ZAIMONI_STATIC_ASSERT(N>n/CHAR_BIT);
-		return _x[n/CHAR_BIT] & (((unsigned char)(1U))<<(n%CHAR_BIT));
-		}
-
-	void toggle(size_t n)
-		{
-		assert(N>n/CHAR_BIT);
-		_x[n/CHAR_BIT] ^= (((unsigned char)(1U))<<(n%CHAR_BIT));
-		};
-	template<size_t n> void toggle()
-		{
-		ZAIMONI_STATIC_ASSERT(N>n/CHAR_BIT);
-		_x[n/CHAR_BIT] ^= (((unsigned char)(1U))<<(n%CHAR_BIT));
-		}
-
-	bool representable_as_uint() const
-		{
-		if (sizeof(uintmax_t)>=N) return true;
-		size_t i = N;
-		do	if ((unsigned char)('\0')!=_x[--i]) return false;
-		while(sizeof(uintmax_t)<i);
-		return true;
-		};
-
-	void mask_to(size_t bitcount) {assert(bitcount<=CHAR_BIT*N);return ::mask_to(_x,N,bitcount);};
-	uintmax_t to_uint() const {return ::to_uint<sizeof(uintmax_t)<N ? sizeof(uintmax_t) : N>(_x);};
-	void set_max() {memset(_x,UCHAR_MAX,N);};
-
-	// STL glue
-	void clear() {memset(_x,0,N);};
-	const unsigned char* data() const {return _x;};
-	unsigned char* c_array() {return _x;};
-	static size_t size() {return N;};
-
-	const unsigned char* begin() const {return _x;};
-	unsigned char* begin() {return _x;};
-	const unsigned char* end() const {return _x+N;};
-	unsigned char* end() {return _x+N;};
-
-	unsigned char front() const {return _x[0];};
-	unsigned char& front() {return _x[0];};
-	unsigned char back() const {return _x[N-1U];};
-	unsigned char& back() {return _x[N-1U];};
-};
-
-ZAIMONI_STATIC_ASSERT(1==sizeof(_unsigned_fixed_charint<1>));
-ZAIMONI_STATIC_ASSERT(sizeof(unsigned short)==sizeof(_unsigned_fixed_charint<sizeof(unsigned short)>));
-ZAIMONI_STATIC_ASSERT(sizeof(unsigned int)==sizeof(_unsigned_fixed_charint<sizeof(unsigned int)>));
-ZAIMONI_STATIC_ASSERT(sizeof(unsigned long)==sizeof(_unsigned_fixed_charint<sizeof(unsigned long)>));
-ZAIMONI_STATIC_ASSERT(sizeof(uintmax_t)==sizeof(_unsigned_fixed_charint<sizeof(uintmax_t)>));
-
-template<size_t N>
-_unsigned_fixed_charint<N>::_unsigned_fixed_charint(uintmax_t src)
-{
-	if (sizeof(uintmax_t)<N) memset(_x+sizeof(uintmax_t),0,N-sizeof(uintmax_t));
-	unsigned_copy<sizeof(uintmax_t)<N ? sizeof(uintmax_t) : N>(_x,src);
-}
-
-template<size_t N>
-template<size_t M>
-_unsigned_fixed_charint<N>::_unsigned_fixed_charint(const _unsigned_fixed_charint<M>& src)
-{
-	if (M<N) memset(_x+M,0,N-M);
-	unsigned_copy<M<N ? M : N>(_x,src._x);
-}
-
-template<size_t N>
-_unsigned_fixed_charint<N>&
-_unsigned_fixed_charint<N>::operator=(uintmax_t src)
-{
-	if (sizeof(uintmax_t)<N) memset(_x+sizeof(uintmax_t),0,N-sizeof(uintmax_t));
-	unsigned_copy<sizeof(uintmax_t)<N ? sizeof(uintmax_t) : N>(_x,src);
-	return *this;
-}
-
-template<size_t N>
-template<size_t M>
-_unsigned_fixed_charint<N>&
-_unsigned_fixed_charint<N>::operator=(const _unsigned_fixed_charint<M>& src)
-{
-	if (M<N) memset(_x+M,0,N-M);
-	unsigned_copy<M<N ? M : N>(_x,src._x);
-	return *this;
-}
-
-template<size_t N>
-_unsigned_fixed_charint<N> operator+(const _unsigned_fixed_charint<N>& lhs,const _unsigned_fixed_charint<N>& rhs)
-{
-	_unsigned_fixed_charint<N> tmp(lhs);
-	tmp += rhs;
-	return tmp;
-}
-
-template<size_t N>
-_unsigned_fixed_charint<N> operator-(const _unsigned_fixed_charint<N>& lhs,const _unsigned_fixed_charint<N>& rhs)
-{
-	_unsigned_fixed_charint<N> tmp(lhs);
-	tmp -= rhs;
-	return tmp;
-}
-
-template<size_t N>
-_unsigned_fixed_charint<N>&
-_unsigned_fixed_charint<N>::operator*=(const _unsigned_fixed_charint<N>& rhs)
-{
-	_unsigned_fixed_charint<N> tmp;
-	unsigned_mult(tmp._x,N,_x,N,rhs._x,N);
-	return *this = tmp;
-}
-
-template<size_t N>
-_unsigned_fixed_charint<N>
-operator/(_unsigned_fixed_charint<N> lhs,const _unsigned_fixed_charint<N>& rhs)
-{
-	_unsigned_fixed_charint<N> quotient;
-	lhs.div_op(rhs,quotient);
-	return quotient;
-}
-
-
-template<size_t N>
-_unsigned_fixed_charint<N>&
-_unsigned_fixed_charint<N>::operator/=(const _unsigned_fixed_charint<N>& rhs)
-{
-	_unsigned_fixed_charint<N> quotient;
-	div_op(rhs,quotient);
-	return *this = quotient;
-}
-
-template<size_t N>
-_unsigned_fixed_charint<N>&
-_unsigned_fixed_charint<N>::operator%=(const _unsigned_fixed_charint<N>& rhs)
-{
-	_unsigned_fixed_charint<N> quotient;
-	div_op(rhs,quotient);
-	return *this;
-}
-
-// comparison operators
-template<size_t N> inline
-bool operator==(const _unsigned_fixed_charint<N>& lhs, const _unsigned_fixed_charint<N>& rhs) {return 0==unsigned_cmp(lhs._x,N,rhs._x);}
-
-template<size_t N> inline
-bool operator==(const _unsigned_fixed_charint<N>& lhs, uintmax_t rhs) {return 0==unsigned_cmp(lhs._x,N,rhs);}
-
-template<size_t N> inline
-bool operator==(const uintmax_t lhs, const _unsigned_fixed_charint<N>& rhs) {return 0==unsigned_cmp(rhs._x,N,lhs);}
-
-template<size_t N> inline
-bool operator!=(const _unsigned_fixed_charint<N>& lhs, const _unsigned_fixed_charint<N>& rhs) {return 0!=unsigned_cmp(lhs._x,N,rhs._x);}
-
-template<size_t N> inline
-bool operator!=(const _unsigned_fixed_charint<N>& lhs, uintmax_t rhs) {return 0==unsigned_cmp(lhs._x,N,rhs);}
-
-template<size_t N> inline
-bool operator!=(const uintmax_t lhs, const _unsigned_fixed_charint<N>& rhs) {return 0==unsigned_cmp(rhs._x,N,lhs);}
-
-template<size_t N> inline
-bool operator<(const _unsigned_fixed_charint<N>& lhs, const _unsigned_fixed_charint<N>& rhs) {return -1==unsigned_cmp(lhs._x,N,rhs._x);}
-
-template<size_t N> inline
-bool operator<(const _unsigned_fixed_charint<N>& lhs, uintmax_t rhs) {return -1==unsigned_cmp(lhs._x,N,rhs);}
-
-template<size_t N> inline
-bool operator<(const uintmax_t lhs, const _unsigned_fixed_charint<N>& rhs) {return 1==unsigned_cmp(rhs._x,N,lhs);}
-
-template<size_t N> inline
-bool operator>(const _unsigned_fixed_charint<N>& lhs, const _unsigned_fixed_charint<N>& rhs) {return 1==unsigned_cmp(lhs._x,N,rhs._x);}
-
-template<size_t N> inline
-bool operator>(const _unsigned_fixed_charint<N>& lhs, uintmax_t rhs) {return 1==unsigned_cmp(lhs._x,N,rhs);}
-
-template<size_t N> inline
-bool operator>(const uintmax_t lhs, const _unsigned_fixed_charint<N>& rhs) {return -1==unsigned_cmp(rhs._x,N,lhs);}
-
-template<size_t N> inline
-bool operator<=(const _unsigned_fixed_charint<N>& lhs, const _unsigned_fixed_charint<N>& rhs) {return 0>=unsigned_cmp(lhs._x,N,rhs._x);}
-
-template<size_t N> inline
-bool operator<=(const _unsigned_fixed_charint<N>& lhs, uintmax_t rhs) {return 0>=unsigned_cmp(lhs._x,N,rhs);}
-
-template<size_t N> inline
-bool operator<=(const uintmax_t lhs, const _unsigned_fixed_charint<N>& rhs) {return 0<=unsigned_cmp(rhs._x,N,lhs);}
-
-template<size_t N> inline
-bool operator>=(const _unsigned_fixed_charint<N>& lhs, const _unsigned_fixed_charint<N>& rhs) {return 0<=unsigned_cmp(lhs._x,N,rhs._x);}
-
-template<size_t N> inline
-bool operator>=(const _unsigned_fixed_charint<N>& lhs, uintmax_t rhs) {return 0<=unsigned_cmp(lhs._x,N,rhs);}
-
-template<size_t N> inline
-bool operator>=(const uintmax_t lhs, const _unsigned_fixed_charint<N>& rhs) {return 0>=unsigned_cmp(rhs._x,N,lhs);}
-
-template<size_t N>
-char* z_ucharint_toa(_unsigned_fixed_charint<N> target,char* const buf,unsigned int radix)
-{
-	char* ret = buf;
-	const _unsigned_fixed_charint<N> radix_copy(radix);
-	_unsigned_fixed_charint<N> power_up(1);
-	while(power_up<=target/radix_copy) power_up *= radix_copy;
-	do	{
-		unsigned char tmp = (unsigned char)((target/power_up).to_uint());
-		tmp += (10>tmp) ? (unsigned char)('0') : (unsigned char)('A')-10U;	// ahem...assumes ASCII linear A-Z
-		*ret++ = tmp;
-		target %= power_up;
-		power_up /= radix_copy;
-		}
-	while(0<power_up);
-	*ret = '\0';
-	return buf;
-}
-
-template<size_t N>
-class unsigned_fixed_int : public _unsigned_fixed_charint<((N-1)/CHAR_BIT)+1>
-{
-	ZAIMONI_STATIC_ASSERT(0<N);
-public:
-	explicit unsigned_fixed_int() {};
-	explicit unsigned_fixed_int(uintmax_t src) : _unsigned_fixed_charint<((N-1)/CHAR_BIT)+1>(src) {};
-
-	unsigned_fixed_int& operator=(const unsigned_fixed_int& src) {_unsigned_fixed_charint<((N-1)/CHAR_BIT)+1>::operator=(src); return *this;};
-	unsigned_fixed_int& operator=(uintmax_t src) {_unsigned_fixed_charint<((N-1)/CHAR_BIT)+1>::operator=(src); return *this;};
-	template<size_t M> unsigned_fixed_int& operator=(const unsigned_fixed_int<M>& src) {_unsigned_fixed_charint<((N-1)/CHAR_BIT)+1>::operator=(src); return *this;}
-};
-
-#endif



From zaimoni at mail.berlios.de  Mon Apr 26 06:07:09 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 26 Apr 2010 06:07:09 +0200
Subject: [Zcplusplus-commits] r394 - trunk
Message-ID: <201004260407.o3Q479vr029041@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-26 06:07:04 +0200 (Mon, 26 Apr 2010)
New Revision: 394

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/POSIX.dep
Log:
unbreak SVN; code clean

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-25 20:56:57 UTC (rev 393)
+++ trunk/CSupport.cpp	2010-04-26 04:07:04 UTC (rev 394)
@@ -6493,9 +6493,6 @@
 	else if (token_is_string<3>(src.data<0>()[i].index_tokens[0].token,"new"))
 		{
 		}
-	else if (token_is_string<5>(src.data<0>()[i].index_tokens[0].token,"compl"))
-		{
-		}
 	else if (token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"delete"))
 		{
 		}

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-04-25 20:56:57 UTC (rev 393)
+++ trunk/CSupport_pp.cpp	2010-04-26 04:07:04 UTC (rev 394)
@@ -5725,9 +5725,6 @@
 	else if (token_is_string<3>(src.data<0>()[i].index_tokens[0].token,"new"))
 		{
 		}
-	else if (token_is_string<5>(src.data<0>()[i].index_tokens[0].token,"compl"))
-		{
-		}
 	else if (token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"delete"))
 		{
 		}

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-04-25 20:56:57 UTC (rev 393)
+++ trunk/POSIX.dep	2010-04-26 04:07:04 UTC (rev 394)
@@ -5,7 +5,7 @@
 OBJECTS_ZCC_LINK_PRIORITY = zcc.o CPreproc.o unsigned_aux.o ParseTree.o Flat_UNI.o unsigned_var_int.o CSupport.o type_system.o CPUInfo.o CPreproc_autogen.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o errors.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
 
 # dependencies
-z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc_pp.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
+z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc_pp.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
 errors.o: errors.hpp langroute.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 langroute.o: langroute.hpp _CSupport1.hpp Zaimoni.STL/Logging.h Zaimoni.STL/POD.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp
 AtomicString.o: AtomicString.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -14,12 +14,12 @@
 filesystem.o: filesystem.h Zaimoni.STL/Compiler.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h
 uchar_blob.o: uchar_blob.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp
 unsigned_var_int.o: unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp
-CPUInfo.o: CPUInfo.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp
+CPUInfo.o: CPUInfo.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp
 struct_type.o: struct_type.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp
 type_system.o: type_system.hpp type_system_pp.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Za!
 imoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.!
 h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -30,10 +30,10 @@
 Trigraph.o: Trigraph.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 Flat_UNI.o: Flat_UNI.hpp lex_core.h Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/stdio_c.h Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
-CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zai!
 moni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
-CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
-zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
-CSupport.o: CSupport.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned!
 _aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
-CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimo!
 ni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
-CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_var_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
+CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/opera!
 tor.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
+zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
+CSupport.o: CSupport.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp!
  type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zai!
 moni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp



From zaimoni at mail.berlios.de  Mon Apr 26 23:02:44 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 26 Apr 2010 23:02:44 +0200
Subject: [Zcplusplus-commits] r395 - trunk/POSIX/cmp
Message-ID: <201004262102.o3QL2i0d019557@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-26 23:02:42 +0200 (Mon, 26 Apr 2010)
New Revision: 395

Modified:
   trunk/POSIX/cmp/Makefile
Log:
fix SVN build of Z.C++ cmp

Modified: trunk/POSIX/cmp/Makefile
===================================================================
--- trunk/POSIX/cmp/Makefile	2010-04-26 04:07:04 UTC (rev 394)
+++ trunk/POSIX/cmp/Makefile	2010-04-26 21:02:42 UTC (rev 395)
@@ -4,6 +4,8 @@
 .SUFFIXES:  .c .o .exe
 
 include ../../POSIX.inc
+# override link flags
+LINK_FLAGS = -L../../lib/host.zcc
 
 # GNU targets we know about
 all: cmp.exe



From zaimoni at mail.berlios.de  Tue Apr 27 01:44:17 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 27 Apr 2010 01:44:17 +0200
Subject: [Zcplusplus-commits] r396 - trunk/doc
Message-ID: <201004262344.o3QNiHpm006886@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-27 01:44:15 +0200 (Tue, 27 Apr 2010)
New Revision: 396

Modified:
   trunk/doc/SOURCE_MAP.txt
Log:
update source map to reflect lib/host.zcc

Modified: trunk/doc/SOURCE_MAP.txt
===================================================================
--- trunk/doc/SOURCE_MAP.txt	2010-04-26 21:02:42 UTC (rev 395)
+++ trunk/doc/SOURCE_MAP.txt	2010-04-26 23:44:15 UTC (rev 396)
@@ -4,6 +4,7 @@
 * freezer: hard-to-replicate source code that used to be in Z.C++, but no longer is.
 * include: this would be the general include directory.
 * lib: this would be the binary library directory.
+** lib/host.zcc : library directory for building Z.C++
 ** lib/MSVC32.zcc : include directory for getting MSVC 32-bit builds going.  Known-good for MSVC 2008 Express.
 ** lib/zc++ : include directory for core Z.C++ files (C++ specific, those that are safe for all versions)
 ** lib/zcc : include director for core ZCC files (C++ specific, those that are safe for all versions)



From zaimoni at mail.berlios.de  Wed Apr 28 07:52:35 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 28 Apr 2010 07:52:35 +0200
Subject: [Zcplusplus-commits] r397 - trunk
Message-ID: <201004280552.o3S5qZxr007432@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-28 07:52:30 +0200 (Wed, 28 Apr 2010)
New Revision: 397

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
C preprocessor doesn't have to know about declarators

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-26 23:44:15 UTC (rev 396)
+++ trunk/CSupport.cpp	2010-04-28 05:52:30 UTC (rev 397)
@@ -10959,9 +10959,8 @@
 	uintmax_t get_flags() const {return flags;};
 	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
 };
-#/*cut-cpp*/
 
-size_t C99_init_declarator_scanner(const parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
+static size_t C99_init_declarator_scanner(const parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
 {
 	assert(x.size<0>()>i);
 	// identifier?
@@ -10973,7 +10972,7 @@
 	return 0;
 }
 
-size_t CPP_init_declarator_scanner(const parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
+static size_t CPP_init_declarator_scanner(const parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
 {
 	assert(x.size<0>()>i);
 	// identifier?
@@ -10985,7 +10984,6 @@
 	return 0;
 }
 
-#/*cut-cpp*/
 static size_t span_to_semicolon(const parse_tree* const first,const parse_tree* const last)
 {
 	assert(first);

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-04-26 23:44:15 UTC (rev 396)
+++ trunk/CSupport_pp.cpp	2010-04-28 05:52:30 UTC (rev 397)
@@ -9529,31 +9529,6 @@
 		};
 }
 
-size_t C99_init_declarator_scanner(const parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
-{
-	assert(x.size<0>()>i);
-	// identifier?
-	if (x.data<0>()[i].is_atomic() && (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags))
-		{	// for now, do nothing else
-		initdecl_identifier_idx = i;
-		return 1;
-		};
-	return 0;
-}
-
-size_t CPP_init_declarator_scanner(const parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
-{
-	assert(x.size<0>()>i);
-	// identifier?
-	if (x.data<0>()[i].is_atomic() && (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags))
-		{	// for now, do nothing else
-		initdecl_identifier_idx = i;
-		return 1;
-		};
-	return 0;
-}
-
-
 PP_auxfunc C99_aux
  = 	{
 	LengthOfCSystemHeader,



From zaimoni at mail.berlios.de  Wed Apr 28 20:44:30 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 28 Apr 2010 20:44:30 +0200
Subject: [Zcplusplus-commits] r398 - trunk
Message-ID: <201004281844.o3SIiUF8027126@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-28 20:44:27 +0200 (Wed, 28 Apr 2010)
New Revision: 398

Modified:
   trunk/CSupport.cpp
   trunk/type_spec.hpp
Log:
structure declarator recognition loosely like the C and C++ standards

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-28 05:52:30 UTC (rev 397)
+++ trunk/CSupport.cpp	2010-04-28 18:44:27 UTC (rev 398)
@@ -10960,27 +10960,208 @@
 	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
 };
 
-static size_t C99_init_declarator_scanner(const parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
+/*
+C99 6.7.5p1, C1X 6.7.6p1
+pointer:
+* type-qualifier-listopt
+* type-qualifier-listopt pointer
+*/
+static size_t C99_recognize_pointerlike_declarator_section(parse_tree& x, size_t i,type_spec& target_type)
 {
 	assert(x.size<0>()>i);
-	// identifier?
+	size_t ub = 0;
+	while(robust_token_is_char<'*'>(x.data<0>()[i+ub]))
+		{
+		unsigned int warn_queue = 0;
+		target_type.make_C_pointer();
+		while(x.size<0>()<=i+ ++ub)
+			{
+			if (robust_token_is_string<5>(x.data<0>()[i+ub],"const"))
+				{	//! \bug need test cases
+				if (target_type.q_vector.back() & type_spec::_const)
+					{
+					warn_queue |= type_spec::_const;
+					// optimize source
+					x.DeleteIdx<0>(i + ub--);
+					continue;
+					}
+				target_type.q_vector.back() |= type_spec::_const;
+				}
+			else if (robust_token_is_string<5>(x.data<0>()[i+ub],"volatile"))
+				{	//! \bug need test cases
+				if (target_type.q_vector.back() & type_spec::_volatile)
+					{
+					warn_queue |= type_spec::_volatile;
+					// optimize source
+					x.DeleteIdx<0>(i + ub--);
+					continue;
+					}
+				target_type.q_vector.back() |= type_spec::_volatile;
+				}
+			else if (robust_token_is_string<5>(x.data<0>()[i+ub],"restrict"))
+				{	//! \bug need test cases
+				if (target_type.q_vector.back() & type_spec::_restrict)
+					{
+					warn_queue |= type_spec::_restrict;
+					// optimize source
+					x.DeleteIdx<0>(i + ub--);
+					continue;
+					}
+				target_type.q_vector.back() |= type_spec::_restrict;
+				}
+			else break;
+			}
+		//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+		//! \todo should this be a context-free check?
+		if (warn_queue)
+			{	//! \bug need test cases
+			message_header(x.data<0>()[i].index_tokens[0]);
+			INC_INFORM(WARN_STR);
+			INFORM("duplicate type qualifiers have no effect (C99 6.7.3p4)");
+			if (bool_options[boolopt::warnings_are_errors])
+				zcc_errors.inc_error();
+			}
+		}
+	return ub;
+}
+
+/*
+C99 6.7.5p1, C1X 6.7.6p1
+direct-declarator:
+identifier
+( declarator )
+direct-declarator [ type-qualifier-listopt assignment-expressionopt ]
+direct-declarator [ static type-qualifier-listopt assignment-expression ]
+direct-declarator [ type-qualifier-list static assignment-expression ]
+direct-declarator [ type-qualifier-listopt * ]
+direct-declarator ( parameter-type-list )
+direct-declarator ( identifier-listopt )
+*/
+
+static size_t C99_recognize_direct_declaratorlike_section(parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
+{
+	assert(x.size<0>()>i);
+	size_t ub = 0;
 	if (x.data<0>()[i].is_atomic() && (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags))
-		{	// for now, do nothing else
+		{	// identifier counts
+		ub = 1;
 		initdecl_identifier_idx = i;
-		return 1;
-		};
+		}
+	return ub;
+}
+
+/*
+declarator:
+pointeropt direct-declarator
+*/
+static size_t C99_init_declarator_scanner(parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
+{
+	assert(x.size<0>()>i);
+	const size_t ptr_like = C99_recognize_pointerlike_declarator_section(x,i,target_type);
+	if (x.size<0>()-i <= ptr_like) return 0;
+	const size_t direct_decl_like = C99_recognize_direct_declaratorlike_section(x,i+ptr_like,target_type,initdecl_identifier_idx);
+	if (0<direct_decl_like) return ptr_like+direct_decl_like;
 	return 0;
 }
 
-static size_t CPP_init_declarator_scanner(const parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
+/*
+C++0X 8p4
+ptr-operator:
+* attribute-specifieropt cv-qualifier-seqopt
+& attribute-specifieropt
+&& attribute-specifieropt
+::opt nested-name-specifier * attribute-specifieropt cv-qualifier-seqopt*/
+static size_t CPP_recognize_pointerlike_declarator_section(parse_tree& x, size_t i,type_spec& target_type)
 {
 	assert(x.size<0>()>i);
-	// identifier?
+	size_t ub = 0;
+	// handle C-like case
+	while(robust_token_is_char<'*'>(x.data<0>()[i+ub]))
+		{
+		unsigned int warn_queue = 0;
+		target_type.make_C_pointer();
+		//! \todo would check for attributes here
+		while(x.size<0>()<=i+ ++ub)
+			{
+			if (robust_token_is_string<5>(x.data<0>()[i+ub],"const"))
+				{	//! \bug need test cases
+				if (target_type.q_vector.back() & type_spec::_const)
+					{
+					warn_queue |= type_spec::_const;
+					// optimize source
+					x.DeleteIdx<0>(i + ub--);
+					continue;
+					}
+				target_type.q_vector.back() |= type_spec::_const;
+				}
+			else if (robust_token_is_string<5>(x.data<0>()[i+ub],"volatile"))
+				{	//! \bug need test cases
+				if (target_type.q_vector.back() & type_spec::_volatile)
+					{
+					warn_queue |= type_spec::_volatile;
+					// optimize source
+					x.DeleteIdx<0>(i + ub--);
+					continue;
+					}
+				target_type.q_vector.back() |= type_spec::_volatile;
+				}
+			else break;
+			}
+		//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+		//! \todo should this be a context-free check?
+		if (warn_queue)
+			{	//! \bug need test cases
+			message_header(x.data<0>()[i].index_tokens[0]);
+			INC_INFORM(WARN_STR);
+			INFORM("duplicate type qualifiers have no effect (C++0X 7.1.6.1p1)");
+			if (bool_options[boolopt::warnings_are_errors])
+				zcc_errors.inc_error();
+			}
+		}
+	return ub;
+}
+
+/*
+noptr-declarator:
+declarator-id attribute-specifieropt
+noptr-declarator parameters-and-qualifiers
+noptr-declarator [ constant-expressionopt ] attribute-specifieropt
+( ptr-declarator )
+*/
+static size_t CPP_recognize_noptr_declaratorlike_section(parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
+{
+	assert(x.size<0>()>i);
+	size_t ub = 0;
 	if (x.data<0>()[i].is_atomic() && (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags))
-		{	// for now, do nothing else
+		{	// identifier counts
+		ub = 1;
 		initdecl_identifier_idx = i;
-		return 1;
-		};
+		//! \todo check for attributes here
+		}
+	return ub;
+}
+
+/*
+declarator:
+ptr-declarator
+noptr-declarator parameters-and-qualifiers trailing-return-type
+
+ptr-declarator:
+noptr-declarator
+ptr-operator ptr-declarator
+*/
+static size_t CPP_init_declarator_scanner(parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
+{
+	assert(x.size<0>()>i);
+	const size_t ptr_like = CPP_recognize_pointerlike_declarator_section(x,i,target_type);
+	if (x.size<0>()-i <= ptr_like) return 0;
+	const size_t noptr_like = CPP_recognize_noptr_declaratorlike_section(x,i+ptr_like,target_type,initdecl_identifier_idx);
+	if (0<noptr_like)
+		{
+		if (0<ptr_like) return ptr_like+noptr_like;
+		//! \todo handle rest of other case
+		return noptr_like;
+		}
 	return 0;
 }
 

Modified: trunk/type_spec.hpp
===================================================================
--- trunk/type_spec.hpp	2010-04-28 05:52:30 UTC (rev 397)
+++ trunk/type_spec.hpp	2010-04-28 18:44:27 UTC (rev 398)
@@ -47,6 +47,7 @@
 
 	void set_static_array_size(size_t _size);
 	void set_pointer_power(size_t _size);	// ACID, throws std::bad_alloc on failure
+	void make_C_pointer() {set_pointer_power(pointer_power+1);};
 	bool dereference();
 	unsigned char& qualifier(size_t i) {return q_vector.c_array()[i];};
 	template<size_t i> unsigned char& qualifier() {return q_vector.c_array()[i];}



From zaimoni at mail.berlios.de  Fri Apr 30 06:29:56 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 30 Apr 2010 06:29:56 +0200
Subject: [Zcplusplus-commits] r399 - trunk
Message-ID: <201004300429.o3U4Tu3n025620@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-30 06:29:46 +0200 (Fri, 30 Apr 2010)
New Revision: 399

Modified:
   trunk/ParseTree.cpp
   trunk/ParseTree.hpp
   trunk/type_spec.cpp
   trunk/type_spec.hpp
Log:
memory correuption debugging harness (only for Windows)

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2010-04-28 18:44:27 UTC (rev 398)
+++ trunk/ParseTree.cpp	2010-04-30 04:29:46 UTC (rev 399)
@@ -5,6 +5,9 @@
 
 using namespace zaimoni;
 
+// in case we have to debug memory corruption
+// #define IRRATIONAL_CAUTION 1
+
 bool parse_tree::is_atomic() const
 {
 	return (	NULL!=index_tokens[0].token.first
@@ -61,8 +64,168 @@
 	while(size<1>()>i) if (!data<1>()[i++].syntax_ok()) return false;
 	i = 0;
 	while(size<2>()>i) if (!data<2>()[i++].syntax_ok()) return false;
+	if (!type_code.syntax_ok()) return false;
 	return true;
 }
+
+bool parse_tree::entangled_with(const type_spec& x) const
+{
+	if (x.entangled_with(type_code)) return true;
+	size_t i = 0;
+	while(size<0>()>i)
+		{
+		if (data<0>()[i].entangled_with(x)) return true;
+		++i;
+		}
+	i = 0;
+	while(size<1>()>i)
+		{
+		if (data<1>()[i].entangled_with(x)) return true;
+		++i;
+		}
+	i = 0;
+	while(size<2>()>i)
+		{
+		if (data<2>()[i].entangled_with(x)) return true;
+		++i;
+		}
+	return false;
+}
+
+bool parse_tree::entangled_with(const parse_tree& x) const
+{
+	if (x.type_code.entangled_with(type_code)) return true;
+	if (args[0] && x.args[0] && args[0]==x.args[0]) return true;
+	if (args[0] && x.args[1] && args[0]==x.args[1]) return true;
+	if (args[0] && x.args[2] && args[0]==x.args[2]) return true;
+	if (args[1] && x.args[0] && args[1]==x.args[0]) return true;
+	if (args[1] && x.args[1] && args[1]==x.args[1]) return true;
+	if (args[1] && x.args[2] && args[1]==x.args[2]) return true;
+	if (args[2] && x.args[0] && args[2]==x.args[0]) return true;
+	if (args[2] && x.args[1] && args[2]==x.args[1]) return true;
+	if (args[2] && x.args[2] && args[2]==x.args[2]) return true;
+
+	size_t i = 0;
+	size_t j = 0;
+	while(size<0>()>i)
+		{
+		while(x.size<0>()>j)
+			{
+			if (data<0>()[i].entangled_with(x.data<0>()[j])) return true;
+			++j;
+			}
+		j = 0;
+		while(x.size<1>()>j)
+			{
+			if (data<0>()[i].entangled_with(x.data<1>()[j])) return true;
+			++j;
+			}
+		j = 0;
+		while(x.size<2>()>j)
+			{
+			if (data<0>()[i].entangled_with(x.data<2>()[j])) return true;
+			++j;
+			}
+		j = 0;
+		++i;
+		}
+	i = 0;
+	while(size<1>()>i)
+		{
+		while(x.size<0>()>j)
+			{
+			if (data<1>()[i].entangled_with(x.data<0>()[j])) return true;
+			++j;
+			}
+		j = 0;
+		while(x.size<1>()>j)
+			{
+			if (data<1>()[i].entangled_with(x.data<1>()[j])) return true;
+			++j;
+			}
+		j = 0;
+		while(x.size<2>()>j)
+			{
+			if (data<1>()[i].entangled_with(x.data<2>()[j])) return true;
+			++j;
+			}
+		j = 0;
+		++i;
+		}
+	i = 0;
+	while(size<2>()>i)
+		{
+		while(x.size<0>()>j)
+			{
+			if (data<2>()[i].entangled_with(x.data<0>()[j])) return true;
+			++j;
+			}
+		j = 0;
+		while(x.size<1>()>j)
+			{
+			if (data<2>()[i].entangled_with(x.data<1>()[j])) return true;
+			++j;
+			}
+		j = 0;
+		while(x.size<2>()>j)
+			{
+			if (data<2>()[i].entangled_with(x.data<2>()[j])) return true;
+			++j;
+			}
+		j = 0;
+		++i;
+		}
+	return false;
+}
+
+bool parse_tree::self_entangled() const
+{
+	if (args[0] && args[1] && args[0]==args[1]) return true;
+	if (args[0] && args[2] && args[0]==args[2]) return true;
+	if (args[1] && args[2] && args[1]==args[2]) return true;
+
+	size_t i = 0;
+	size_t j = 0;
+	while(size<0>()>i)
+		{
+		if (data<0>()[i].self_entangled()) return true;
+		if (data<0>()[i].entangled_with(type_code)) return true;
+		while(i>j)
+			{
+			if (data<0>()[i].entangled_with(data<0>()[j])) return true;
+			++j;
+			}
+		j = 0;
+		++i;
+		}
+	i = 0;
+	while(size<1>()>i)
+		{
+		if (data<1>()[i].self_entangled()) return true;
+		if (data<1>()[i].entangled_with(type_code)) return true;
+		while(i>j)
+			{
+			if (data<1>()[i].entangled_with(data<1>()[j])) return true;
+			++j;
+			}
+		j = 0;
+		++i;
+		}
+	i = 0;
+	while(size<2>()>i)
+		{
+		if (data<2>()[i].self_entangled()) return true;
+		if (data<2>()[i].entangled_with(type_code)) return true;
+		while(i>j)
+			{
+			if (data<2>()[i].entangled_with(data<2>()[j])) return true;
+			++j;
+			}
+		j = 0;
+		++i;
+		}
+	return false;
+}
 #endif
 
 void parse_tree::clear()
@@ -182,6 +345,10 @@
 	while(0<i);
 	src.DeleteNSlotsAt<0>(zap_span+1,target.first+1);
 	src.c_array<0>()[target.first] = tmp;
+#ifdef IRRATIONAL_CAUTION
+	assert(src.syntax_ok());
+	assert(!src.self_entangled());
+#endif
 	return true;
 }
 
@@ -232,6 +399,10 @@
 	dest.destroy();
 	dest = tmp;
 	tmp.clear();
+#ifdef IRRATIONAL_CAUTION
+	assert(dest.syntax_ok());
+	assert(!dest.self_entangled());
+#endif
 }
 
 void parse_tree::MoveInto(parse_tree& dest)
@@ -243,6 +414,10 @@
 	dest.subtype = subtype;
 	dest.type_code = type_code;
 	clear();
+#ifdef IRRATIONAL_CAUTION
+	assert(dest.syntax_ok());
+	assert(!dest.self_entangled());
+#endif
 }
 
 
@@ -252,6 +427,10 @@
 	c_array(arg_idx)[i].clear();
 	destroy();
 	*this = tmp;
+#ifdef IRRATIONAL_CAUTION
+	assert(syntax_ok());
+	assert(!self_entangled());
+#endif
 }
 
 bool parse_tree::_resize(const size_t arg_idx,size_t n)

Modified: trunk/ParseTree.hpp
===================================================================
--- trunk/ParseTree.hpp	2010-04-28 18:44:27 UTC (rev 398)
+++ trunk/ParseTree.hpp	2010-04-30 04:29:46 UTC (rev 399)
@@ -274,6 +274,9 @@
 	void core_flag_update();
 #ifndef ZAIMONI_FORCE_ISO
 	bool syntax_ok() const;
+	bool entangled_with(const type_spec& x) const;
+	bool entangled_with(const parse_tree& x) const;
+	bool self_entangled() const;
 #endif
 
 	template<size_t dest_idx> void fast_set_arg(parse_tree* src)

Modified: trunk/type_spec.cpp
===================================================================
--- trunk/type_spec.cpp	2010-04-28 18:44:27 UTC (rev 398)
+++ trunk/type_spec.cpp	2010-04-30 04:29:46 UTC (rev 399)
@@ -6,27 +6,18 @@
 #include "Zaimoni.STL/MetaRAM2.hpp"
 using namespace zaimoni;
 
-void type_spec::set_static_array_size(size_t _size)
-{
-	// expand pointer_power_after_array_decay() to be ACID
-	q_vector.resize(pointer_power+(0<_size)+1);
-	static_array_size = _size;
-	if (0==_size) return;
-	// XXX this may well require a more substantial recalculation XXX
-	q_vector.front() |= lvalue;
-}
-
 void type_spec::set_pointer_power(size_t _size)
 {
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
 	if (_size==pointer_power) return;
 	assert(0<_size);
 	const bool shrinking = _size<pointer_power;
-	const size_t pointer_power_copy = pointer_power;
-	const size_t old_ptr_power = pointer_power_after_array_decay();
-	const size_t new_ptr_power = old_ptr_power+(_size-pointer_power);	// modulo arithmetic
+	const size_t old_ptr_power = pointer_power;
 	// zaimoni::_resize always succeeds when shrinking; if it fails, then reverting q_vector's resize 
 	// is a shrinking operation which always succeeds.
-	q_vector.resize(new_ptr_power+1);
+	q_vector.resize(_size+1);
 #ifndef ZAIMONI_FORCE_ISO
 	if (!zaimoni::_resize(extent_vector,_size))
 #else
@@ -41,52 +32,73 @@
 #endif
 	if (!shrinking)
 		{
-		memset(extent_vector+pointer_power_copy,0,sizeof(uintmax_t)*(_size-pointer_power_copy));
+		memset(extent_vector+old_ptr_power,0,sizeof(uintmax_t)*(_size-old_ptr_power));
 		size_t i = old_ptr_power;
-		while(i<new_ptr_power) q_vector.c_array()[i++] = lvalue;
+		while(i<_size) q_vector.c_array()[i++] = lvalue;
 		// q_vector.second[new_ptr_power] = '\0';	// handled by uchar_blob
 		};
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
 }
 
+void type_spec::make_C_array(uintmax_t _size)
+{	// can't count on type_spec being initialized correctly beforehand
+	// (could be 0 coming in, but then pointer_power=0 as well coming in)
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
+	set_pointer_power(pointer_power+1);
+	q_vector.back() |= _array;
+	q_vector.c_array()[q_vector.size()-2] |= lvalue;
+	extent_vector[pointer_power-1] = _size;
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
+}
+
+
 // XXX properly operator= in C++, but type_spec has to be POD
 // ACID, throws std::bad_alloc on failure
 void value_copy(type_spec& dest,const type_spec& src)
-{
+{	// again, can't count on src.syntax_ok()
+#ifndef ZAIMONI_FORCE_ISO
+	assert(src.syntax_ok());
+#endif
 	type_spec tmp;
 	tmp.clear();
-	tmp.base_type_index = src.base_type_index;
-	tmp.set_static_array_size(src.static_array_size);
+	tmp.set_type(src.base_type_index);
 	tmp.set_pointer_power(src.pointer_power);
-	value_copy(tmp.q_vector,src.q_vector);
+	if (tmp.q_vector.size()==src.q_vector.size())
+		value_copy(tmp.q_vector,src.q_vector);
+	if (0<src.pointer_power) memmove(tmp.extent_vector,src.extent_vector,src.pointer_power*sizeof(uintmax_t));
 	dest.destroy();
 	dest = tmp;
+#ifndef ZAIMONI_FORCE_ISO
+	assert(dest.syntax_ok());
+#endif
 }
 
-
 bool type_spec::dereference()
 {
-	const size_t old_ptr_power = pointer_power_after_array_decay();
-	if (0==old_ptr_power) return false;
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
+	if (0==pointer_power) return false;
 //	q_vector.c_array()[old_ptr_power] = '\0';	// redundant, wiped by q_vector.resize()
-	assert(lvalue & q_vector.data()[old_ptr_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
-	q_vector.resize(old_ptr_power);	// lost a level of indirection
-	if (0<pointer_power)
-		{
+	assert(lvalue & q_vector.data()[pointer_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
+	q_vector.resize(pointer_power);	// lost a level of indirection
 #if ZAIMONI_REALLOC_TO_ZERO_IS_NULL
-		extent_vector = REALLOC(extent_vector,--pointer_power*sizeof(*extent_vector));
+	extent_vector = REALLOC(extent_vector,--pointer_power*sizeof(*extent_vector));
 #else
-		if (0== --pointer_power)
-			{
-			FREE_AND_NULL(extent_vector);
-			}
-		else{
-			extent_vector = REALLOC(extent_vector,pointer_power*sizeof(*extent_vector));
-			}
+	if (0== --pointer_power)
+		FREE_AND_NULL(extent_vector);
+	else
+		extent_vector = REALLOC(extent_vector,pointer_power*sizeof(*extent_vector));
 #endif
-		return true;
-		}
-	assert(0<static_array_size);	// other cause of non-zero pointer power after array decay
-	static_array_size = 0;
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
 	return true;
 }
 
@@ -94,35 +106,73 @@
 {
 	base_type_index = 0;
 	pointer_power = 0;
-	static_array_size = 0;
 	q_vector.init(0);
 	extent_vector = NULL;
 }
 
 void type_spec::destroy()
 {
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
 	FREE_AND_NULL(extent_vector);
 	q_vector.resize(0);
 	base_type_index = 0;
 	pointer_power = 0;
-	static_array_size = 0;
 }
 
 void type_spec::set_type(size_t _base_type_index)
 {
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
 	FREE_AND_NULL(extent_vector);
-	q_vector.resize(0);
+	q_vector.resize(1);
 	base_type_index = _base_type_index;
 	pointer_power = 0;
-	static_array_size = 0;
 }
 
 bool type_spec::operator==(const type_spec& rhs) const
 {
 	return 	base_type_index==rhs.base_type_index
 		&&	pointer_power==rhs.pointer_power
-		&& 	static_array_size==rhs.static_array_size
 		&&  q_vector==rhs.q_vector
 		&& (0==pointer_power || !memcmp(extent_vector,rhs.extent_vector,sizeof(uintmax_t)*pointer_power));
 }
 
+void type_spec::MoveInto(type_spec& dest)
+{
+	dest.destroy();
+	dest = *this;
+	clear();
+}
+
+void type_spec::OverwriteInto(type_spec& dest)
+{
+	dest = *this;
+	clear();
+}
+
+#ifndef ZAIMONI_FORCE_ISO
+bool type_spec::syntax_ok() const
+{
+	if (0==q_vector.size() && 0==pointer_power && !extent_vector) return true;
+	if (pointer_power>=q_vector.size() || pointer_power+1!=q_vector.size()) return false;
+	if (0==pointer_power)
+		{
+		if (extent_vector) return false;
+		}
+	else if (!_memory_block_start_valid(extent_vector))
+		return false;
+	return true;
+}
+
+bool type_spec::entangled_with(const type_spec& x) const
+{
+	if (extent_vector && x.extent_vector && extent_vector==x.extent_vector)
+		return true;
+	//! \todo Law of Demeter would delegate the entangled check for q_vector
+	return false;
+}
+#endif
+

Modified: trunk/type_spec.hpp
===================================================================
--- trunk/type_spec.hpp	2010-04-28 18:44:27 UTC (rev 398)
+++ trunk/type_spec.hpp	2010-04-30 04:29:46 UTC (rev 399)
@@ -30,7 +30,6 @@
 {
 	size_t base_type_index;
 	size_t pointer_power;		// use wrappers for altering this (affects valid memory representations) [implement]
-	size_t static_array_size;	// C-ish, but mitigates bloating the type manager; use wrappers for altering this [implement]
 
 	uchar_blob q_vector;	// q(ualifier)_vector
 	uintmax_t* extent_vector;
@@ -39,15 +38,16 @@
 		lvalue = 1,			// C/C++ sense, assume works for other languages
 		_const = (1<<1),	// C/C++ sense, assume works for other languages
 		_volatile = (1<<2),	// C/C++ sense, assume works for other languages
-		_restrict = (1<<3)	// C99 sense, assume works for other languages
+		_restrict = (1<<3),	// C99 sense, assume works for other languages
+		_array = (1<<4)		// C99 sense, assume works for other languages
 	};
 
-	size_t pointer_power_after_array_decay() const {return pointer_power+(0<static_array_size);};
-	bool decays_to_nonnull_pointer() const {return 0==pointer_power && 0<static_array_size;};
+	size_t pointer_power_after_array_decay() const {return pointer_power;};
+	bool decays_to_nonnull_pointer() const {return 0<pointer_power && (q_vector.back() & _array);};
 
-	void set_static_array_size(size_t _size);
 	void set_pointer_power(size_t _size);	// ACID, throws std::bad_alloc on failure
 	void make_C_pointer() {set_pointer_power(pointer_power+1);};
+	void make_C_array(uintmax_t _size);
 	bool dereference();
 	unsigned char& qualifier(size_t i) {return q_vector.c_array()[i];};
 	template<size_t i> unsigned char& qualifier() {return q_vector.c_array()[i];}
@@ -59,6 +59,12 @@
 	bool operator!=(const type_spec& rhs) const {return !(*this==rhs);};
 
 	static void value_copy(type_spec& dest, const type_spec& src) {::value_copy(dest,src);};
+	void MoveInto(type_spec& dest);
+	void OverwriteInto(type_spec& dest);
+#ifndef ZAIMONI_FORCE_ISO
+	bool syntax_ok() const;
+	bool entangled_with(const type_spec& x) const;
+#endif
 };
 
 #endif



From zaimoni at mail.berlios.de  Fri Apr 30 06:45:41 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 30 Apr 2010 06:45:41 +0200
Subject: [Zcplusplus-commits] r400 - trunk
Message-ID: <201004300445.o3U4jfTm005072@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-30 06:45:36 +0200 (Fri, 30 Apr 2010)
New Revision: 400

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
unbreak SVN; hackish static_array_size eliminated outright

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-30 04:29:46 UTC (rev 399)
+++ trunk/CSupport.cpp	2010-04-30 04:45:36 UTC (rev 400)
@@ -4419,7 +4419,7 @@
 		if (C_TESTFLAG_STRING_LITERAL==src.index_tokens[0].flags)
 			{
 			src.type_code.set_type(C_TYPE::CHAR);
-			src.type_code.set_static_array_size(LengthOfCStringLiteral(src.index_tokens[0].token.first,src.index_tokens[0].token.second));
+			src.type_code.make_C_array(LengthOfCStringLiteral(src.index_tokens[0].token.first,src.index_tokens[0].token.second));
 			return;
 			}
 		else if (C_TESTFLAG_CHAR_LITERAL==src.index_tokens[0].flags)
@@ -5334,9 +5334,9 @@
 
 static void force_decimal_literal(parse_tree& dest,const char* src,const type_system& types)
 {
-	assert(NULL!=src);
+	assert(src && *src);
 	dest.destroy();
-	assert(NULL!=dest.index_tokens[0].src_filename);
+	assert(dest.index_tokens[0].src_filename && *dest.index_tokens[0].src_filename);
 	dest.index_tokens[0].token.first = src;
 	dest.index_tokens[0].token.second = strlen(src);
 	dest.index_tokens[0].flags = (C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_INTEGER | C_TESTFLAG_DECIMAL);
@@ -5345,7 +5345,7 @@
 
 static parse_tree decimal_literal(const char* src,const parse_tree& loc_src,const type_system& types)
 {
-	assert(NULL!=src);
+	assert(src && *src);
 	parse_tree dest;
 	dest.clear();
 	dest.index_tokens[0].token.first = src;
@@ -7244,7 +7244,6 @@
 {
 	assert(is_C99_add_operator_expression<'+'>(src));
 
-	const type_spec old_type = src.type_code;
 	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power_after_array_decay();
 	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power_after_array_decay();	
 	// void pointers should have been intercepted by now
@@ -7262,19 +7261,23 @@
 			bool is_true = false;
 			if 		(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 				{	// 0 + __ |-> __
+				type_spec old_type;
+				src.type_code.OverwriteInto(old_type);
 				src.eval_to_arg<2>(0);
-				src.type_code = old_type;
+				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ + 0 |-> __
+				type_spec old_type;
+				src.type_code.OverwriteInto(old_type);
 				src.eval_to_arg<1>(0);
-				src.type_code = old_type;
+				old_type.MoveInto(src.type_code);
 				return true;
 				};
 			umaxint res_int;
 			umaxint rhs_int;
-			const promote_aux old(old_type.base_type_index ARG_TYPES);
+			const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 			const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 			assert(old.bitcount>=lhs.bitcount);
 			const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
@@ -7336,9 +7339,11 @@
 						parse_tree tmp;
 						if (!VM_to_literal(tmp,lhs_test,src,types)) return false;
 
+						type_spec old_type;
+						src.type_code.OverwriteInto(old_type);
 						src.DeleteIdx<1>(0);
 						force_unary_negative_literal(src,tmp);
-						src.type_code = old_type;
+						old_type.MoveInto(src.type_code);
 						return true;
 						};
 					res_int = lhs_test;
@@ -7349,8 +7354,7 @@
 				// convert to parsed + literal
 				parse_tree tmp;
 				if (!VM_to_literal(tmp,res_int,src,types)) return false;
-				tmp.type_code = old_type;
-
+				src.type_code.MoveInto(tmp.type_code);
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp ARG_TYPES);
 				return true;
@@ -7362,8 +7366,10 @@
 			bool is_true = false;
 			if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ + 0 |-> __
+				type_spec old_type;
+				src.type_code.OverwriteInto(old_type);
 				src.eval_to_arg<1>(0);
-				src.type_code = old_type;
+				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			break;
@@ -7373,8 +7379,10 @@
 			bool is_true = false;
 			if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 				{	// 0 + __ |-> __
+				type_spec old_type;
+				src.type_code.OverwriteInto(old_type);
 				src.eval_to_arg<2>(0);
-				src.type_code = old_type;
+				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			break;
@@ -7389,8 +7397,6 @@
 static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'-'>(src));
-
-	const type_spec old_type = src.type_code;
 	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power_after_array_decay();
 	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power_after_array_decay();	
 	// void pointers should have been intercepted by now
@@ -7400,7 +7406,7 @@
 	switch((0<lhs_pointer)+2*(0<rhs_pointer))
 	{
 #ifndef NDEBUG
-	default: FATAL_CODE("hardware/compiler error: invalid linear combination in eval_add_expression",3);
+	default: FATAL_CODE("hardware/compiler error: invalid linear combination in eval_sub_expression",3);
 #endif
 	case 0:	{
 			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES));
@@ -7413,13 +7419,14 @@
 				src.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 				src.subtype = C99_UNARY_SUBTYPE_NEG;
 				assert(is_C99_unary_operator_expression<'-'>(src));
-				src.type_code = old_type;				
 				return true;
 				}
 			else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ - 0 |-> __
+				type_spec old_type;
+				src.type_code.OverwriteInto(old_type);
 				src.eval_to_arg<1>(0);
-				src.type_code = old_type;
+				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			umaxint res_int;
@@ -7428,7 +7435,7 @@
 			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 			if (lhs_converted && rhs_converted)
 				{	//! \todo deal with signed integer arithmetic
-				const promote_aux old(old_type.base_type_index ARG_TYPES);
+				const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 				const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 				assert(old.bitcount>=lhs.bitcount);
 				const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
@@ -7487,10 +7494,11 @@
 						// convert to parsed - literal
 						parse_tree tmp;
 						if (!VM_to_literal(tmp,lhs_test,src,types)) return false;
-
+						type_spec old_type;
+						src.type_code.OverwriteInto(old_type);
 						src.DeleteIdx<1>(0);
 						force_unary_negative_literal(src,tmp);
-						src.type_code = old_type;
+						old_type.MoveInto(src.type_code);
 						return true;
 						};
 					res_int = lhs_test;
@@ -7501,8 +7509,7 @@
 				// convert to parsed + literal
 				parse_tree tmp;
 				if (!VM_to_literal(tmp,res_int,src,types)) return false;
-				tmp.type_code = old_type;
-
+				src.type_code.MoveInto(tmp.type_code);
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp ARG_TYPES);
 				return true;
@@ -7514,8 +7521,10 @@
 			bool is_true = false;
 			if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ - 0 |-> __
+				type_spec old_type;
+				src.type_code.OverwriteInto(old_type);
 				src.eval_to_arg<1>(0);
-				src.type_code = old_type;
+				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			break;
@@ -7528,8 +7537,10 @@
 			bool is_equal = false;
 			if (C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal) && is_equal)
 				{	//! \test default/Pass_if_zero.hpp, default/Pass_if_zero.h
+				type_spec old_type;
+				src.type_code.OverwriteInto(old_type);
 				force_decimal_literal(src,"0",types);
-				src.type_code = old_type;
+				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			break;
@@ -7600,7 +7611,7 @@
 			}
 	case 1:	{	// ptr + integer, hopefully
 				// requires floating-point literals to test errors from preprocessor
-			src.type_code = src.data<1>()->type_code;
+			value_copy(src.type_code,src.data<1>()->type_code);
 			if (!converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src," adds pointer to non-integer (C99 6.5.6p2; C++98 5.7p1)");
@@ -7611,7 +7622,7 @@
 			}
 	case 2:	{	// integer + ptr, hopefully
 				// requires floating-point literals to test errors from preprocessor
-			src.type_code = src.data<2>()->type_code;
+			value_copy(src.type_code,src.data<2>()->type_code);
 			if (!converts_to_integerlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src," adds pointer to non-integer (C99 6.5.6p2; C++98 5.7p1)");
@@ -7659,7 +7670,7 @@
 			break;
 			}
 	case 5:	{	// ptr - integer, hopefully; requires floating-point literal to test from preprocessor
-			src.type_code = src.data<1>()->type_code;
+			value_copy(src.type_code,src.data<1>()->type_code);
 			if (!converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src," subtracts non-integer from pointer (C99 6.5.6p3; C++98 5.7p2)");
@@ -9359,7 +9370,8 @@
 	if (literal_converts_to_bool(*src.c_array<1>(),is_true ARG_TYPES))
 		{
 		const bool was_invalid = src.flags & parse_tree::INVALID;
-		const type_spec old_type = src.type_code;
+		type_spec old_type;
+		src.type_code.OverwriteInto(old_type);
 		if (is_true)
 			// it's the infix arg
 			src.eval_to_arg<0>(0);
@@ -9367,12 +9379,13 @@
 			src.eval_to_arg<2>(0);
 		if (was_invalid && !(src.flags & parse_tree::INVALID))
 			{
+			old_type.destroy();
 			message_header(src.index_tokens[0]);
 			INC_INFORM("invalid ? : operator optimized to valid ");
 			INFORM(src);
 			}
 		else
-			src.type_code = old_type;
+			old_type.MoveInto(src.type_code);
 		return true;
 		}
 	return false;
@@ -9397,7 +9410,7 @@
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
-				src.type_code = src.data<0>()->type_code;
+				value_copy(src.type_code,src.data<0>()->type_code);
 			else{
 				src.type_code.set_type(0);	// incoherent type
 				// (...) ? string : int -- error
@@ -9416,7 +9429,7 @@
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
-				src.type_code = src.data<2>()->type_code;
+				value_copy(src.type_code,src.data<2>()->type_code);
 			else{
 				src.type_code.set_type(0);	// incoherent type
 				// (...) ? int : string -- error
@@ -9487,7 +9500,7 @@
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
-				src.type_code = src.data<0>()->type_code;
+				value_copy(src.type_code,src.data<0>()->type_code);
 			else{
 				src.type_code.set_type(0);	// incoherent type
 				// (...) ? string : int -- error
@@ -9506,7 +9519,7 @@
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
-				src.type_code = src.data<2>()->type_code;
+				value_copy(src.type_code,src.data<2>()->type_code);
 			else{
 				src.type_code.set_type(0);	// incoherent type
 				// (...) ? int : string -- error
@@ -9562,7 +9575,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_conditional_op(src,i)) C_conditional_op_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_conditional_op(src,i))
+		C_conditional_op_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 static void locate_CPP_conditional_op(parse_tree& src, size_t& i, const type_system& types)
@@ -9573,7 +9587,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_conditional_op(src,i)) CPP_conditional_op_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_conditional_op(src,i))
+		CPP_conditional_op_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 template<class T>

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-04-30 04:29:46 UTC (rev 399)
+++ trunk/CSupport_pp.cpp	2010-04-30 04:45:36 UTC (rev 400)
@@ -4004,7 +4004,7 @@
 		if (C_TESTFLAG_STRING_LITERAL==src.index_tokens[0].flags)
 			{
 			src.type_code.set_type(C_TYPE::CHAR);
-			src.type_code.set_static_array_size(LengthOfCStringLiteral(src.index_tokens[0].token.first,src.index_tokens[0].token.second));
+			src.type_code.make_C_array(LengthOfCStringLiteral(src.index_tokens[0].token.first,src.index_tokens[0].token.second));
 			return;
 			}
 		else if (C_TESTFLAG_CHAR_LITERAL==src.index_tokens[0].flags)
@@ -4864,9 +4864,9 @@
 
 static void force_decimal_literal(parse_tree& dest,const char* src,const type_system& types)
 {
-	assert(NULL!=src);
+	assert(src && *src);
 	dest.destroy();
-	assert(NULL!=dest.index_tokens[0].src_filename);
+	assert(dest.index_tokens[0].src_filename && *dest.index_tokens[0].src_filename);
 	dest.index_tokens[0].token.first = src;
 	dest.index_tokens[0].token.second = strlen(src);
 	dest.index_tokens[0].flags = (C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_INTEGER | C_TESTFLAG_DECIMAL);
@@ -4875,7 +4875,7 @@
 
 static parse_tree decimal_literal(const char* src,const parse_tree& loc_src,const type_system& types)
 {
-	assert(NULL!=src);
+	assert(src && *src);
 	parse_tree dest;
 	dest.clear();
 	dest.index_tokens[0].token.first = src;
@@ -6447,7 +6447,6 @@
 {
 	assert(is_C99_add_operator_expression<'+'>(src));
 
-	const type_spec old_type = src.type_code;
 	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power_after_array_decay();
 	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power_after_array_decay();	
 	// void pointers should have been intercepted by now
@@ -6465,19 +6464,23 @@
 			bool is_true = false;
 			if 		(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 				{	// 0 + __ |-> __
+				type_spec old_type;
+				src.type_code.OverwriteInto(old_type);
 				src.eval_to_arg<2>(0);
-				src.type_code = old_type;
+				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ + 0 |-> __
+				type_spec old_type;
+				src.type_code.OverwriteInto(old_type);
 				src.eval_to_arg<1>(0);
-				src.type_code = old_type;
+				old_type.MoveInto(src.type_code);
 				return true;
 				};
 			umaxint res_int;
 			umaxint rhs_int;
-			const promote_aux old(old_type.base_type_index ARG_TYPES);
+			const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 			const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 			assert(old.bitcount>=lhs.bitcount);
 			const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
@@ -6539,9 +6542,11 @@
 						parse_tree tmp;
 						if (!VM_to_literal(tmp,lhs_test,src,types)) return false;
 
+						type_spec old_type;
+						src.type_code.OverwriteInto(old_type);
 						src.DeleteIdx<1>(0);
 						force_unary_negative_literal(src,tmp);
-						src.type_code = old_type;
+						old_type.MoveInto(src.type_code);
 						return true;
 						};
 					res_int = lhs_test;
@@ -6552,8 +6557,7 @@
 				// convert to parsed + literal
 				parse_tree tmp;
 				if (!VM_to_literal(tmp,res_int,src,types)) return false;
-				tmp.type_code = old_type;
-
+				src.type_code.MoveInto(tmp.type_code);
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp ARG_TYPES);
 				return true;
@@ -6565,8 +6569,10 @@
 			bool is_true = false;
 			if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ + 0 |-> __
+				type_spec old_type;
+				src.type_code.OverwriteInto(old_type);
 				src.eval_to_arg<1>(0);
-				src.type_code = old_type;
+				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			break;
@@ -6576,8 +6582,10 @@
 			bool is_true = false;
 			if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 				{	// 0 + __ |-> __
+				type_spec old_type;
+				src.type_code.OverwriteInto(old_type);
 				src.eval_to_arg<2>(0);
-				src.type_code = old_type;
+				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			break;
@@ -6592,8 +6600,6 @@
 static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'-'>(src));
-
-	const type_spec old_type = src.type_code;
 	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power_after_array_decay();
 	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power_after_array_decay();	
 	// void pointers should have been intercepted by now
@@ -6603,7 +6609,7 @@
 	switch((0<lhs_pointer)+2*(0<rhs_pointer))
 	{
 #ifndef NDEBUG
-	default: FATAL_CODE("hardware/compiler error: invalid linear combination in eval_add_expression",3);
+	default: FATAL_CODE("hardware/compiler error: invalid linear combination in eval_sub_expression",3);
 #endif
 	case 0:	{
 			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES));
@@ -6616,13 +6622,14 @@
 				src.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 				src.subtype = C99_UNARY_SUBTYPE_NEG;
 				assert(is_C99_unary_operator_expression<'-'>(src));
-				src.type_code = old_type;				
 				return true;
 				}
 			else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ - 0 |-> __
+				type_spec old_type;
+				src.type_code.OverwriteInto(old_type);
 				src.eval_to_arg<1>(0);
-				src.type_code = old_type;
+				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			umaxint res_int;
@@ -6631,7 +6638,7 @@
 			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 			if (lhs_converted && rhs_converted)
 				{	//! \todo deal with signed integer arithmetic
-				const promote_aux old(old_type.base_type_index ARG_TYPES);
+				const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 				const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 				assert(old.bitcount>=lhs.bitcount);
 				const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
@@ -6690,10 +6697,11 @@
 						// convert to parsed - literal
 						parse_tree tmp;
 						if (!VM_to_literal(tmp,lhs_test,src,types)) return false;
-
+						type_spec old_type;
+						src.type_code.OverwriteInto(old_type);
 						src.DeleteIdx<1>(0);
 						force_unary_negative_literal(src,tmp);
-						src.type_code = old_type;
+						old_type.MoveInto(src.type_code);
 						return true;
 						};
 					res_int = lhs_test;
@@ -6704,8 +6712,7 @@
 				// convert to parsed + literal
 				parse_tree tmp;
 				if (!VM_to_literal(tmp,res_int,src,types)) return false;
-				tmp.type_code = old_type;
-
+				src.type_code.MoveInto(tmp.type_code);
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp ARG_TYPES);
 				return true;
@@ -6717,8 +6724,10 @@
 			bool is_true = false;
 			if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ - 0 |-> __
+				type_spec old_type;
+				src.type_code.OverwriteInto(old_type);
 				src.eval_to_arg<1>(0);
-				src.type_code = old_type;
+				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			break;
@@ -6731,8 +6740,10 @@
 			bool is_equal = false;
 			if (C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal) && is_equal)
 				{	//! \test default/Pass_if_zero.hpp, default/Pass_if_zero.h
+				type_spec old_type;
+				src.type_code.OverwriteInto(old_type);
 				force_decimal_literal(src,"0",types);
-				src.type_code = old_type;
+				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			break;
@@ -6788,7 +6799,7 @@
 			}
 	case 1:	{	// ptr + integer, hopefully
 				// requires floating-point literals to test errors from preprocessor
-			src.type_code = src.data<1>()->type_code;
+			value_copy(src.type_code,src.data<1>()->type_code);
 			if (!converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src," adds pointer to non-integer (C99 6.5.6p2; C++98 5.7p1)");
@@ -6799,7 +6810,7 @@
 			}
 	case 2:	{	// integer + ptr, hopefully
 				// requires floating-point literals to test errors from preprocessor
-			src.type_code = src.data<2>()->type_code;
+			value_copy(src.type_code,src.data<2>()->type_code);
 			if (!converts_to_integerlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src," adds pointer to non-integer (C99 6.5.6p2; C++98 5.7p1)");
@@ -6832,7 +6843,7 @@
 			break;
 			}
 	case 5:	{	// ptr - integer, hopefully; requires floating-point literal to test from preprocessor
-			src.type_code = src.data<1>()->type_code;
+			value_copy(src.type_code,src.data<1>()->type_code);
 			if (!converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
 				{
 				simple_error(src," subtracts non-integer from pointer (C99 6.5.6p3; C++98 5.7p2)");
@@ -8462,7 +8473,8 @@
 	if (literal_converts_to_bool(*src.c_array<1>(),is_true ARG_TYPES))
 		{
 		const bool was_invalid = src.flags & parse_tree::INVALID;
-		const type_spec old_type = src.type_code;
+		type_spec old_type;
+		src.type_code.OverwriteInto(old_type);
 		if (is_true)
 			// it's the infix arg
 			src.eval_to_arg<0>(0);
@@ -8470,12 +8482,13 @@
 			src.eval_to_arg<2>(0);
 		if (was_invalid && !(src.flags & parse_tree::INVALID))
 			{
+			old_type.destroy();
 			message_header(src.index_tokens[0]);
 			INC_INFORM("invalid ? : operator optimized to valid ");
 			INFORM(src);
 			}
 		else
-			src.type_code = old_type;
+			old_type.MoveInto(src.type_code);
 		return true;
 		}
 	return false;
@@ -8500,7 +8513,7 @@
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
-				src.type_code = src.data<0>()->type_code;
+				value_copy(src.type_code,src.data<0>()->type_code);
 			else{
 				src.type_code.set_type(0);	// incoherent type
 				// (...) ? string : int -- error
@@ -8519,7 +8532,7 @@
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
-				src.type_code = src.data<2>()->type_code;
+				value_copy(src.type_code,src.data<2>()->type_code);
 			else{
 				src.type_code.set_type(0);	// incoherent type
 				// (...) ? int : string -- error
@@ -8590,7 +8603,7 @@
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
-				src.type_code = src.data<0>()->type_code;
+				value_copy(src.type_code,src.data<0>()->type_code);
 			else{
 				src.type_code.set_type(0);	// incoherent type
 				// (...) ? string : int -- error
@@ -8609,7 +8622,7 @@
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
 				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
 				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
-				src.type_code = src.data<2>()->type_code;
+				value_copy(src.type_code,src.data<2>()->type_code);
 			else{
 				src.type_code.set_type(0);	// incoherent type
 				// (...) ? int : string -- error
@@ -8665,7 +8678,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_conditional_op(src,i)) C_conditional_op_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_conditional_op(src,i))
+		C_conditional_op_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 static void locate_CPP_conditional_op(parse_tree& src, size_t& i, const type_system& types)
@@ -8676,7 +8690,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_conditional_op(src,i)) CPP_conditional_op_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_conditional_op(src,i))
+		CPP_conditional_op_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 template<class T>



From zaimoni at mail.berlios.de  Fri Apr 30 07:46:48 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 30 Apr 2010 07:46:48 +0200
Subject: [Zcplusplus-commits] r401 - trunk
Message-ID: <201004300546.o3U5kmxu006735@sheep.berlios.de>

Author: zaimoni
Date: 2010-04-30 07:46:42 +0200 (Fri, 30 Apr 2010)
New Revision: 401

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/type_spec.hpp
Log:
remove now-useless type_spec::pointer_power_after_array_decay()

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-30 04:45:36 UTC (rev 400)
+++ trunk/CSupport.cpp	2010-04-30 05:46:42 UTC (rev 401)
@@ -669,13 +669,13 @@
 
 static bool converts_to_integerlike(const type_spec& type_code SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers
+	if (0<type_code.pointer_power) return false;	// pointers do not have a standard conversion to integers
 	return converts_to_integerlike(type_code.base_type_index ARG_TYPES);
 }
 
 static bool converts_to_integer(const type_spec& type_code SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers
+	if (0<type_code.pointer_power) return false;	// pointers do not have a standard conversion to integers
 #ifdef ZCC_NOT_BUILDING_CPP
 	if (C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index) return true;
 	return types.get_enum_def(type_code.base_type_index);
@@ -706,13 +706,13 @@
 
 static bool converts_to_arithmeticlike(const type_spec& type_code SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers/floats/complex
+	if (0<type_code.pointer_power) return false;	// pointers do not have a standard conversion to integers/floats/complex
 	return converts_to_arithmeticlike(type_code.base_type_index ARG_TYPES);
 }
 
 static bool converts_to_bool(const type_spec& type_code SIG_CONST_TYPES)
 {
-	if (0<type_code.pointer_power_after_array_decay()) return true;	// pointers are comparable to NULL
+	if (0<type_code.pointer_power) return true;	// pointers are comparable to NULL
 	if (converts_to_arithmeticlike(type_code.base_type_index ARG_TYPES)) return true;	// arithmetic types are comparable to zero, and include bool
 	// C++: run through type conversion weirdness
 	return false;
@@ -864,7 +864,7 @@
 static POD_pair<size_t,bool> default_promotion_is_integerlike(const type_spec& type_code SIG_CONST_TYPES)
 {	// uses NRVO
 	POD_pair<size_t,bool> tmp = {0,false};
-	if (0==type_code.pointer_power_after_array_decay())	// pointers do not have a standard conversion to integers
+	if (0==type_code.pointer_power)	// pointers do not have a standard conversion to integers
 		{
 		tmp.first = default_promote_type(type_code.base_type_index ARG_TYPES);
 		tmp.second = (C_TYPE::BOOL<=tmp.first && C_TYPE::INTEGERLIKE>=tmp.first);
@@ -875,7 +875,7 @@
 static POD_pair<size_t,bool> default_promotion_is_arithmeticlike(const type_spec& type_code SIG_CONST_TYPES)
 {	// uses NRVO
 	POD_pair<size_t,bool> tmp = {0,false};
-	if (0==type_code.pointer_power_after_array_decay())	// pointers do not have a standard conversion to integers
+	if (0==type_code.pointer_power)	// pointers do not have a standard conversion to integers
 		{
 		tmp.first = default_promote_type(type_code.base_type_index ARG_TYPES);
 		tmp.second = (C_TYPE::BOOL<=tmp.first && C_TYPE::LDOUBLE__COMPLEX>=tmp.first);
@@ -4985,8 +4985,8 @@
 {
 	if (parse_tree::INVALID & src.flags) return;	// cannot optimize to valid
 
-	const size_t effective_pointer_power_prefix = src.data<1>()->type_code.pointer_power_after_array_decay();
-	const size_t effective_pointer_power_infix = src.data<0>()->type_code.pointer_power_after_array_decay();
+	const size_t effective_pointer_power_prefix = src.data<1>()->type_code.pointer_power;
+	const size_t effective_pointer_power_infix = src.data<0>()->type_code.pointer_power;
 	if (0<effective_pointer_power_prefix)
 		{
 		if (0<effective_pointer_power_infix)
@@ -5443,7 +5443,7 @@
 static bool eval_unary_plus(parse_tree& src, const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'+'>(src));
-	if (0<src.data<2>()->type_code.pointer_power_after_array_decay())
+	if (0<src.data<2>()->type_code.pointer_power)
 		{	// assume C++98 interpretation, as this is illegal in C99
 		//! \test cpp/default/Pass_if_control27.hpp
 		if (!(parse_tree::INVALID & src.flags))
@@ -5541,7 +5541,7 @@
 	assert(C99_UNARY_SUBTYPE_NEG==src.subtype || C99_UNARY_SUBTYPE_PLUS==src.subtype);
 	assert((C99_UNARY_SUBTYPE_PLUS==src.subtype) ? is_C99_unary_operator_expression<'+'>(src) : is_C99_unary_operator_expression<'-'>(src));
 	// return immediately if applied to a pointer type (C++98 would type here)
-	if (0<src.data<2>()->type_code.pointer_power_after_array_decay())
+	if (0<src.data<2>()->type_code.pointer_power)
 		{
 		src.type_code.set_type(0);
 		simple_error(src,(C99_UNARY_SUBTYPE_PLUS==src.subtype) ? " applies unary + to a pointer (C99 6.5.3.3p1)" : " applies unary - to a pointer (C99 6.5.3.3p1)");
@@ -5606,7 +5606,7 @@
 	// 2) if inner +/- is applied to a raw pointer, error out and change type to 0
 	if (C99_UNARY_SUBTYPE_PLUS==src.subtype)
 		{
-		if (0<src.data<2>()->type_code.pointer_power_after_array_decay())
+		if (0<src.data<2>()->type_code.pointer_power)
 			// C++98 5.3.1p6: pointer type allowed for unary +, not for unary - (C99 errors)
 			//! \test default/Pass_if_control27.hpp
 			value_copy(src.type_code,src.data<2>()->type_code);
@@ -5618,14 +5618,14 @@
 		}
 	else{	// if (C99_UNARY_SUBTYPE_NEG==src.subtype)
 		// return immediately if result is a pointer type; nested application to a pointer type dies
-		if (0<src.data<2>()->type_code.pointer_power_after_array_decay())
+		if (0<src.data<2>()->type_code.pointer_power)
 			{
 			src.type_code.set_type(0);
 			simple_error(src," applies unary - to a pointer (C++98 5.3.1p7)");
 			return;
 			}
 
-		if (0<src.data<2>()->type_code.pointer_power_after_array_decay()) return;
+		if (0<src.data<2>()->type_code.pointer_power) return;
 
 		const size_t arg_unary_subtype 	= (is_C99_unary_operator_expression<'-'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_NEG
 										: (is_C99_unary_operator_expression<'+'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_PLUS : 0;
@@ -5765,7 +5765,7 @@
 	if (is_logical_NOT(*src.data<2>()))
 		{
 		if (	is_logical_NOT(*src.data<2>()->data<2>())
-			||	(C_TYPE::BOOL==src.data<2>()->type_code.base_type_index && 0==src.data<2>()->type_code.pointer_power_after_array_decay()))
+			||	(C_TYPE::BOOL==src.data<2>()->type_code.base_type_index && 0==src.data<2>()->type_code.pointer_power))
 			{
 			parse_tree tmp = *src.data<2>()->data<2>();
 			src.c_array<2>()->c_array<2>()->clear();
@@ -6259,7 +6259,7 @@
 static bool eval_C99_CPP_sizeof(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_CPP_sizeof_expression(src));
-	if (0==src.data<2>()->type_code.pointer_power_after_array_decay())
+	if (0==src.data<2>()->type_code.pointer_power)
 		{
 		if (eval_sizeof_core_type(src,src.data<2>()->type_code.base_type_index,types)) return true;
 		}
@@ -6270,7 +6270,7 @@
 {
 	assert(is_C99_CPP_sizeof_expression(src));
 	if (eval_C99_CPP_sizeof(src,types)) return true;
-	if (0==src.data<2>()->type_code.pointer_power_after_array_decay())
+	if (0==src.data<2>()->type_code.pointer_power)
 		{
 		const enum_def* const tmp = types.get_enum_def(src.data<2>()->type_code.base_type_index);
 		if (tmp)
@@ -6295,7 +6295,7 @@
 {
 	assert(is_C99_CPP_sizeof_expression(src));
 	if (eval_C99_CPP_sizeof(src,types)) return true;
-	if (0==src.data<2>()->type_code.pointer_power_after_array_decay())
+	if (0==src.data<2>()->type_code.pointer_power)
 		{
 		if (C_TYPE::WCHAR_T==src.data<2>()->type_code.base_type_index)
 			return eval_sizeof_core_type(src,unsigned_type_from_machine_type(target_machine->UNICODE_wchar_t()),types);
@@ -7244,8 +7244,8 @@
 {
 	assert(is_C99_add_operator_expression<'+'>(src));
 
-	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power_after_array_decay();
-	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power_after_array_decay();	
+	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power;
+	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power;	
 	// void pointers should have been intercepted by now
 	assert(1!=lhs_pointer || C_TYPE::VOID!=src.data<1>()->type_code.base_type_index);
 	assert(1!=rhs_pointer || C_TYPE::VOID!=src.data<2>()->type_code.base_type_index);
@@ -7397,8 +7397,8 @@
 static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'-'>(src));
-	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power_after_array_decay();
-	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power_after_array_decay();	
+	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power;
+	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power;	
 	// void pointers should have been intercepted by now
 	assert(1!=lhs_pointer || C_TYPE::VOID!=src.data<1>()->type_code.base_type_index);
 	assert(1!=rhs_pointer || C_TYPE::VOID!=src.data<2>()->type_code.base_type_index);
@@ -7555,8 +7555,8 @@
 {
 	assert((C99_ADD_SUBTYPE_PLUS==src.subtype && is_C99_add_operator_expression<'+'>(src)) || (C99_ADD_SUBTYPE_MINUS==src.subtype && is_C99_add_operator_expression<'-'>(src)));
 	BOOST_STATIC_ASSERT(1==C99_ADD_SUBTYPE_MINUS-C99_ADD_SUBTYPE_PLUS);
-	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power_after_array_decay();
-	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power_after_array_decay();	
+	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power;
+	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power;	
 
 	// pointers to void are disallowed; not testable from preprocessor
 	const bool exact_rhs_voidptr = 1==rhs_pointer && C_TYPE::VOID==src.data<2>()->type_code.base_type_index;
@@ -8099,7 +8099,7 @@
 
 static bool C_CPP_relation_expression_core_syntax_ok(parse_tree& src,const type_system& types)
 {
-	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power_after_array_decay())+2*(0<src.data<2>()->type_code.pointer_power_after_array_decay());
+	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power)+2*(0<src.data<2>()->type_code.pointer_power);
 	switch(ptr_case)
 	{
 	case 0:	{	// can't test from preprocessor
@@ -8270,7 +8270,7 @@
 			break;
 			}
 	case 1:	{
-			if (0<src.data<2>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES)) 
+			if (0<src.data<2>()->type_code.pointer_power && literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES)) 
 				{
 				if (!is_true)
 					{	
@@ -8291,7 +8291,7 @@
 			break;
 			}
 	case 2:	{
-			if (0<src.data<1>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES)) 
+			if (0<src.data<1>()->type_code.pointer_power && literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES)) 
 				{
 				if (!is_true)
 					{
@@ -8343,7 +8343,7 @@
 	// string literal == integer literal zero
 	// deny legality of : string literal == integer/float
 	// more to come later
-	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power_after_array_decay())+2*(0<src.data<2>()->type_code.pointer_power_after_array_decay());
+	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power)+2*(0<src.data<2>()->type_code.pointer_power);
 	switch(ptr_case)
 	{
 	case 0:	{	// can't test from preprocessor
@@ -9398,13 +9398,13 @@
 	// \todo change target for multidimensional arrays
 	// \todo change target for const/volatile/restricted pointers
 	// NOTE: result is always an rvalue in C (C99 6.5.15p4)
-	switch(cmp(src.data<0>()->type_code.pointer_power_after_array_decay(),src.data<2>()->type_code.pointer_power_after_array_decay()))
+	switch(cmp(src.data<0>()->type_code.pointer_power,src.data<2>()->type_code.pointer_power))
 	{
 	case 1:	{	// LHS has more guaranteed indirectability than RHS
 			if (C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
 				{	// recoverable
 				src.type_code.set_type(C_TYPE::NOT_VOID);
-				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
 				}
 			else if (is_null_pointer_constant(*src.data<2>(),C99_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
@@ -9423,7 +9423,7 @@
 			if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index)
 				{	// recoverable
 				src.type_code.set_type(C_TYPE::NOT_VOID);
-				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power);
 				}
 			else if (is_null_pointer_constant(*src.data<0>(),C99_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
@@ -9442,22 +9442,22 @@
 			if (src.data<0>()->type_code.base_type_index==src.data<2>()->type_code.base_type_index)
 				{
 				src.type_code.set_type(src.data<0>()->type_code.base_type_index);
-				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
 				}
-			else if (0==src.data<0>()->type_code.pointer_power_after_array_decay() && (C_TYPE::VOID>=src.data<0>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index))
+			else if (0==src.data<0>()->type_code.pointer_power && (C_TYPE::VOID>=src.data<0>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index))
 				{	// can't test this from preprocessor
 				src.type_code.set_type(0);	// incoherent type
 				simple_error(src," has incoherent type");
 				}
 			//! \todo test cases at preprocessor level
-			else if (0==src.data<0>()->type_code.pointer_power_after_array_decay() && is_innate_definite_type(src.data<0>()->type_code.base_type_index) && is_innate_definite_type(src.data<2>()->type_code.base_type_index))
+			else if (0==src.data<0>()->type_code.pointer_power && is_innate_definite_type(src.data<0>()->type_code.base_type_index) && is_innate_definite_type(src.data<2>()->type_code.base_type_index))
 				// standard arithmetic conversions
 				src.type_code.set_type(arithmetic_reconcile(src.data<0>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES));
 			//! \todo --do-what-i-mean can handle elementary integer types with same indirection as well
 			else if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index || C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
 				{
 				src.type_code.set_type(C_TYPE::NOT_VOID);
-				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
 				}
 			else{	// can't test this from preprocessor
 				src.type_code.set_type(0);	// incoherent type
@@ -9488,13 +9488,13 @@
 	// \todo change target for const/volatile/restricted pointers
 	// NOTE: result is an lvalue if both are lvalues of identical type (C++98 5.16p4)
 	// NOTE: throw expressions play nice (they always have the type of the other half)
-	switch(cmp(src.data<0>()->type_code.pointer_power_after_array_decay(),src.data<2>()->type_code.pointer_power_after_array_decay()))
+	switch(cmp(src.data<0>()->type_code.pointer_power,src.data<2>()->type_code.pointer_power))
 	{
 	case 1:	{	// LHS has more guaranteed indirectability than RHS
 			if (C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
 				{	// recoverable
 				src.type_code.set_type(C_TYPE::NOT_VOID);
-				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
 				}
 			else if (is_null_pointer_constant(*src.data<2>(),CPP_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
@@ -9513,7 +9513,7 @@
 			if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index)
 				{	// recoverable
 				src.type_code.set_type(C_TYPE::NOT_VOID);
-				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power);
 				}
 			else if (is_null_pointer_constant(*src.data<0>(),CPP_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
@@ -9532,21 +9532,21 @@
 			if (src.data<0>()->type_code.base_type_index==src.data<2>()->type_code.base_type_index)
 				{
 				src.type_code.set_type(src.data<0>()->type_code.base_type_index);
-				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
 				}
-			else if (0==src.data<0>()->type_code.pointer_power_after_array_decay() && (C_TYPE::VOID>=src.data<0>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index))
+			else if (0==src.data<0>()->type_code.pointer_power && (C_TYPE::VOID>=src.data<0>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index))
 				{	// can't test this from preprocessor
 				src.type_code.set_type(0);	// incoherent type
 				simple_error(src," has incoherent type");
 				}
-			else if (0==src.data<0>()->type_code.pointer_power_after_array_decay() && is_innate_definite_type(src.data<0>()->type_code.base_type_index) && is_innate_definite_type(src.data<2>()->type_code.base_type_index))
+			else if (0==src.data<0>()->type_code.pointer_power && is_innate_definite_type(src.data<0>()->type_code.base_type_index) && is_innate_definite_type(src.data<2>()->type_code.base_type_index))
 				// standard arithmetic conversions
 				src.type_code.set_type(arithmetic_reconcile(src.data<0>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES));
 			//! \todo --do-what-i-mean can handle elementary integer types with same indirection as well
 			else if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index || C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
 				{
 				src.type_code.set_type(C_TYPE::NOT_VOID);
-				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
 				}
 			else{	// can't test this from preprocessor
 				src.type_code.set_type(0);	// incoherent type
@@ -10371,7 +10371,7 @@
 	assert(is_C99_unary_operator_expression(src));
 	if ('&'==*src.index_tokens[0].token.first)
 		{	// strip off &*, and remove lvalue-ness of target
-		if (is_C99_unary_operator_expression<'*'>(*src.data<2>()) && 0<src.data<2>()->data<2>()->type_code.pointer_power_after_array_decay())
+		if (is_C99_unary_operator_expression<'*'>(*src.data<2>()) && 0<src.data<2>()->data<2>()->type_code.pointer_power)
 			{
 			parse_tree tmp = *src.data<2>()->data<2>();
 			tmp.type_code.traits &= ~type_spec::lvalue;

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-04-30 04:45:36 UTC (rev 400)
+++ trunk/CSupport_pp.cpp	2010-04-30 05:46:42 UTC (rev 401)
@@ -1,4 +1,4 @@
-// CSupport_pp.cpp
+// CSupport.cpp
 // support for C/C++ parsing
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
@@ -606,13 +606,13 @@
 
 static bool converts_to_integerlike(const type_spec& type_code SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers
+	if (0<type_code.pointer_power) return false;	// pointers do not have a standard conversion to integers
 	return converts_to_integerlike(type_code.base_type_index ARG_TYPES);
 }
 
 static bool converts_to_integer(const type_spec& type_code SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers
+	if (0<type_code.pointer_power) return false;	// pointers do not have a standard conversion to integers
 #ifdef ZCC_NOT_BUILDING_CPP
 	if (C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index) return true;
 	return types.get_enum_def(type_code.base_type_index);
@@ -643,13 +643,13 @@
 
 static bool converts_to_arithmeticlike(const type_spec& type_code SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-	if (0<type_code.pointer_power_after_array_decay()) return false;	// pointers do not have a standard conversion to integers/floats/complex
+	if (0<type_code.pointer_power) return false;	// pointers do not have a standard conversion to integers/floats/complex
 	return converts_to_arithmeticlike(type_code.base_type_index ARG_TYPES);
 }
 
 static bool converts_to_bool(const type_spec& type_code SIG_CONST_TYPES)
 {
-	if (0<type_code.pointer_power_after_array_decay()) return true;	// pointers are comparable to NULL
+	if (0<type_code.pointer_power) return true;	// pointers are comparable to NULL
 	if (converts_to_arithmeticlike(type_code.base_type_index ARG_TYPES)) return true;	// arithmetic types are comparable to zero, and include bool
 	// C++: run through type conversion weirdness
 	return false;
@@ -787,7 +787,7 @@
 static POD_pair<size_t,bool> default_promotion_is_integerlike(const type_spec& type_code SIG_CONST_TYPES)
 {	// uses NRVO
 	POD_pair<size_t,bool> tmp = {0,false};
-	if (0==type_code.pointer_power_after_array_decay())	// pointers do not have a standard conversion to integers
+	if (0==type_code.pointer_power)	// pointers do not have a standard conversion to integers
 		{
 		tmp.first = default_promote_type(type_code.base_type_index ARG_TYPES);
 		tmp.second = (C_TYPE::BOOL<=tmp.first && C_TYPE::INTEGERLIKE>=tmp.first);
@@ -798,7 +798,7 @@
 static POD_pair<size_t,bool> default_promotion_is_arithmeticlike(const type_spec& type_code SIG_CONST_TYPES)
 {	// uses NRVO
 	POD_pair<size_t,bool> tmp = {0,false};
-	if (0==type_code.pointer_power_after_array_decay())	// pointers do not have a standard conversion to integers
+	if (0==type_code.pointer_power)	// pointers do not have a standard conversion to integers
 		{
 		tmp.first = default_promote_type(type_code.base_type_index ARG_TYPES);
 		tmp.second = (C_TYPE::BOOL<=tmp.first && C_TYPE::LDOUBLE__COMPLEX>=tmp.first);
@@ -4525,8 +4525,8 @@
 {
 	if (parse_tree::INVALID & src.flags) return;	// cannot optimize to valid
 
-	const size_t effective_pointer_power_prefix = src.data<1>()->type_code.pointer_power_after_array_decay();
-	const size_t effective_pointer_power_infix = src.data<0>()->type_code.pointer_power_after_array_decay();
+	const size_t effective_pointer_power_prefix = src.data<1>()->type_code.pointer_power;
+	const size_t effective_pointer_power_infix = src.data<0>()->type_code.pointer_power;
 	if (0<effective_pointer_power_prefix)
 		{
 		if (0<effective_pointer_power_infix)
@@ -4946,7 +4946,7 @@
 static bool eval_unary_plus(parse_tree& src, const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'+'>(src));
-	if (0<src.data<2>()->type_code.pointer_power_after_array_decay())
+	if (0<src.data<2>()->type_code.pointer_power)
 		{	// assume C++98 interpretation, as this is illegal in C99
 		//! \test cpp/default/Pass_if_control27.hpp
 		if (!(parse_tree::INVALID & src.flags))
@@ -5015,7 +5015,7 @@
 	assert(C99_UNARY_SUBTYPE_NEG==src.subtype || C99_UNARY_SUBTYPE_PLUS==src.subtype);
 	assert((C99_UNARY_SUBTYPE_PLUS==src.subtype) ? is_C99_unary_operator_expression<'+'>(src) : is_C99_unary_operator_expression<'-'>(src));
 	// return immediately if applied to a pointer type (C++98 would type here)
-	if (0<src.data<2>()->type_code.pointer_power_after_array_decay())
+	if (0<src.data<2>()->type_code.pointer_power)
 		{
 		src.type_code.set_type(0);
 		simple_error(src,(C99_UNARY_SUBTYPE_PLUS==src.subtype) ? " applies unary + to a pointer (C99 6.5.3.3p1)" : " applies unary - to a pointer (C99 6.5.3.3p1)");
@@ -5060,7 +5060,7 @@
 	// 2) if inner +/- is applied to a raw pointer, error out and change type to 0
 	if (C99_UNARY_SUBTYPE_PLUS==src.subtype)
 		{
-		if (0<src.data<2>()->type_code.pointer_power_after_array_decay())
+		if (0<src.data<2>()->type_code.pointer_power)
 			// C++98 5.3.1p6: pointer type allowed for unary +, not for unary - (C99 errors)
 			//! \test default/Pass_if_control27.hpp
 			value_copy(src.type_code,src.data<2>()->type_code);
@@ -5072,14 +5072,14 @@
 		}
 	else{	// if (C99_UNARY_SUBTYPE_NEG==src.subtype)
 		// return immediately if result is a pointer type; nested application to a pointer type dies
-		if (0<src.data<2>()->type_code.pointer_power_after_array_decay())
+		if (0<src.data<2>()->type_code.pointer_power)
 			{
 			src.type_code.set_type(0);
 			simple_error(src," applies unary - to a pointer (C++98 5.3.1p7)");
 			return;
 			}
 
-		if (0<src.data<2>()->type_code.pointer_power_after_array_decay()) return;
+		if (0<src.data<2>()->type_code.pointer_power) return;
 
 		const size_t arg_unary_subtype 	= (is_C99_unary_operator_expression<'-'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_NEG
 										: (is_C99_unary_operator_expression<'+'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_PLUS : 0;
@@ -5219,7 +5219,7 @@
 	if (is_logical_NOT(*src.data<2>()))
 		{
 		if (	is_logical_NOT(*src.data<2>()->data<2>())
-			||	(C_TYPE::BOOL==src.data<2>()->type_code.base_type_index && 0==src.data<2>()->type_code.pointer_power_after_array_decay()))
+			||	(C_TYPE::BOOL==src.data<2>()->type_code.base_type_index && 0==src.data<2>()->type_code.pointer_power))
 			{
 			parse_tree tmp = *src.data<2>()->data<2>();
 			src.c_array<2>()->c_array<2>()->clear();
@@ -6447,8 +6447,8 @@
 {
 	assert(is_C99_add_operator_expression<'+'>(src));
 
-	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power_after_array_decay();
-	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power_after_array_decay();	
+	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power;
+	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power;	
 	// void pointers should have been intercepted by now
 	assert(1!=lhs_pointer || C_TYPE::VOID!=src.data<1>()->type_code.base_type_index);
 	assert(1!=rhs_pointer || C_TYPE::VOID!=src.data<2>()->type_code.base_type_index);
@@ -6600,8 +6600,8 @@
 static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'-'>(src));
-	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power_after_array_decay();
-	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power_after_array_decay();	
+	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power;
+	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power;	
 	// void pointers should have been intercepted by now
 	assert(1!=lhs_pointer || C_TYPE::VOID!=src.data<1>()->type_code.base_type_index);
 	assert(1!=rhs_pointer || C_TYPE::VOID!=src.data<2>()->type_code.base_type_index);
@@ -6758,8 +6758,8 @@
 {
 	assert((C99_ADD_SUBTYPE_PLUS==src.subtype && is_C99_add_operator_expression<'+'>(src)) || (C99_ADD_SUBTYPE_MINUS==src.subtype && is_C99_add_operator_expression<'-'>(src)));
 	BOOST_STATIC_ASSERT(1==C99_ADD_SUBTYPE_MINUS-C99_ADD_SUBTYPE_PLUS);
-	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power_after_array_decay();
-	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power_after_array_decay();	
+	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power;
+	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power;	
 
 	// pointers to void are disallowed; not testable from preprocessor
 	const bool exact_rhs_voidptr = 1==rhs_pointer && C_TYPE::VOID==src.data<2>()->type_code.base_type_index;
@@ -7266,7 +7266,7 @@
 
 static bool C_CPP_relation_expression_core_syntax_ok(parse_tree& src,const type_system& types)
 {
-	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power_after_array_decay())+2*(0<src.data<2>()->type_code.pointer_power_after_array_decay());
+	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power)+2*(0<src.data<2>()->type_code.pointer_power);
 	switch(ptr_case)
 	{
 	case 0:	{	// can't test from preprocessor
@@ -7437,7 +7437,7 @@
 			break;
 			}
 	case 1:	{
-			if (0<src.data<2>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES)) 
+			if (0<src.data<2>()->type_code.pointer_power && literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES)) 
 				{
 				if (!is_true)
 					{	
@@ -7458,7 +7458,7 @@
 			break;
 			}
 	case 2:	{
-			if (0<src.data<1>()->type_code.pointer_power_after_array_decay() && literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES)) 
+			if (0<src.data<1>()->type_code.pointer_power && literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES)) 
 				{
 				if (!is_true)
 					{
@@ -7510,7 +7510,7 @@
 	// string literal == integer literal zero
 	// deny legality of : string literal == integer/float
 	// more to come later
-	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power_after_array_decay())+2*(0<src.data<2>()->type_code.pointer_power_after_array_decay());
+	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power)+2*(0<src.data<2>()->type_code.pointer_power);
 	switch(ptr_case)
 	{
 	case 0:	{	// can't test from preprocessor
@@ -8501,13 +8501,13 @@
 	// \todo change target for multidimensional arrays
 	// \todo change target for const/volatile/restricted pointers
 	// NOTE: result is always an rvalue in C (C99 6.5.15p4)
-	switch(cmp(src.data<0>()->type_code.pointer_power_after_array_decay(),src.data<2>()->type_code.pointer_power_after_array_decay()))
+	switch(cmp(src.data<0>()->type_code.pointer_power,src.data<2>()->type_code.pointer_power))
 	{
 	case 1:	{	// LHS has more guaranteed indirectability than RHS
 			if (C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
 				{	// recoverable
 				src.type_code.set_type(C_TYPE::NOT_VOID);
-				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
 				}
 			else if (is_null_pointer_constant(*src.data<2>(),C99_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
@@ -8526,7 +8526,7 @@
 			if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index)
 				{	// recoverable
 				src.type_code.set_type(C_TYPE::NOT_VOID);
-				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power);
 				}
 			else if (is_null_pointer_constant(*src.data<0>(),C99_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
@@ -8545,22 +8545,22 @@
 			if (src.data<0>()->type_code.base_type_index==src.data<2>()->type_code.base_type_index)
 				{
 				src.type_code.set_type(src.data<0>()->type_code.base_type_index);
-				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
 				}
-			else if (0==src.data<0>()->type_code.pointer_power_after_array_decay() && (C_TYPE::VOID>=src.data<0>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index))
+			else if (0==src.data<0>()->type_code.pointer_power && (C_TYPE::VOID>=src.data<0>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index))
 				{	// can't test this from preprocessor
 				src.type_code.set_type(0);	// incoherent type
 				simple_error(src," has incoherent type");
 				}
 			//! \todo test cases at preprocessor level
-			else if (0==src.data<0>()->type_code.pointer_power_after_array_decay() && is_innate_definite_type(src.data<0>()->type_code.base_type_index) && is_innate_definite_type(src.data<2>()->type_code.base_type_index))
+			else if (0==src.data<0>()->type_code.pointer_power && is_innate_definite_type(src.data<0>()->type_code.base_type_index) && is_innate_definite_type(src.data<2>()->type_code.base_type_index))
 				// standard arithmetic conversions
 				src.type_code.set_type(arithmetic_reconcile(src.data<0>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES));
 			//! \todo --do-what-i-mean can handle elementary integer types with same indirection as well
 			else if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index || C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
 				{
 				src.type_code.set_type(C_TYPE::NOT_VOID);
-				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
 				}
 			else{	// can't test this from preprocessor
 				src.type_code.set_type(0);	// incoherent type
@@ -8591,13 +8591,13 @@
 	// \todo change target for const/volatile/restricted pointers
 	// NOTE: result is an lvalue if both are lvalues of identical type (C++98 5.16p4)
 	// NOTE: throw expressions play nice (they always have the type of the other half)
-	switch(cmp(src.data<0>()->type_code.pointer_power_after_array_decay(),src.data<2>()->type_code.pointer_power_after_array_decay()))
+	switch(cmp(src.data<0>()->type_code.pointer_power,src.data<2>()->type_code.pointer_power))
 	{
 	case 1:	{	// LHS has more guaranteed indirectability than RHS
 			if (C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
 				{	// recoverable
 				src.type_code.set_type(C_TYPE::NOT_VOID);
-				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
 				}
 			else if (is_null_pointer_constant(*src.data<2>(),CPP_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
@@ -8616,7 +8616,7 @@
 			if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index)
 				{	// recoverable
 				src.type_code.set_type(C_TYPE::NOT_VOID);
-				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power);
 				}
 			else if (is_null_pointer_constant(*src.data<0>(),CPP_intlike_literal_to_VM ARG_TYPES))
 				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
@@ -8635,21 +8635,21 @@
 			if (src.data<0>()->type_code.base_type_index==src.data<2>()->type_code.base_type_index)
 				{
 				src.type_code.set_type(src.data<0>()->type_code.base_type_index);
-				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
 				}
-			else if (0==src.data<0>()->type_code.pointer_power_after_array_decay() && (C_TYPE::VOID>=src.data<0>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index))
+			else if (0==src.data<0>()->type_code.pointer_power && (C_TYPE::VOID>=src.data<0>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index))
 				{	// can't test this from preprocessor
 				src.type_code.set_type(0);	// incoherent type
 				simple_error(src," has incoherent type");
 				}
-			else if (0==src.data<0>()->type_code.pointer_power_after_array_decay() && is_innate_definite_type(src.data<0>()->type_code.base_type_index) && is_innate_definite_type(src.data<2>()->type_code.base_type_index))
+			else if (0==src.data<0>()->type_code.pointer_power && is_innate_definite_type(src.data<0>()->type_code.base_type_index) && is_innate_definite_type(src.data<2>()->type_code.base_type_index))
 				// standard arithmetic conversions
 				src.type_code.set_type(arithmetic_reconcile(src.data<0>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES));
 			//! \todo --do-what-i-mean can handle elementary integer types with same indirection as well
 			else if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index || C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
 				{
 				src.type_code.set_type(C_TYPE::NOT_VOID);
-				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power_after_array_decay());
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
 				}
 			else{	// can't test this from preprocessor
 				src.type_code.set_type(0);	// incoherent type
@@ -9316,7 +9316,7 @@
 	assert(is_C99_unary_operator_expression(src));
 	if ('&'==*src.index_tokens[0].token.first)
 		{	// strip off &*, and remove lvalue-ness of target
-		if (is_C99_unary_operator_expression<'*'>(*src.data<2>()) && 0<src.data<2>()->data<2>()->type_code.pointer_power_after_array_decay())
+		if (is_C99_unary_operator_expression<'*'>(*src.data<2>()) && 0<src.data<2>()->data<2>()->type_code.pointer_power)
 			{
 			parse_tree tmp = *src.data<2>()->data<2>();
 			tmp.type_code.traits &= ~type_spec::lvalue;

Modified: trunk/type_spec.hpp
===================================================================
--- trunk/type_spec.hpp	2010-04-30 04:45:36 UTC (rev 400)
+++ trunk/type_spec.hpp	2010-04-30 05:46:42 UTC (rev 401)
@@ -42,7 +42,6 @@
 		_array = (1<<4)		// C99 sense, assume works for other languages
 	};
 
-	size_t pointer_power_after_array_decay() const {return pointer_power;};
 	bool decays_to_nonnull_pointer() const {return 0<pointer_power && (q_vector.back() & _array);};
 
 	void set_pointer_power(size_t _size);	// ACID, throws std::bad_alloc on failure



