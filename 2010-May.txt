From zaimoni at mail.berlios.de  Tue May  4 11:46:56 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 4 May 2010 11:46:56 +0200
Subject: [Zcplusplus-commits] r402 - trunk
Message-ID: <201005040946.o449kuow005477@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-04 11:46:52 +0200 (Tue, 04 May 2010)
New Revision: 402

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
remove newly dead code

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-04-30 05:46:42 UTC (rev 401)
+++ trunk/CSupport.cpp	2010-05-04 09:46:52 UTC (rev 402)
@@ -5625,8 +5625,6 @@
 			return;
 			}
 
-		if (0<src.data<2>()->type_code.pointer_power) return;
-
 		const size_t arg_unary_subtype 	= (is_C99_unary_operator_expression<'-'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_NEG
 										: (is_C99_unary_operator_expression<'+'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_PLUS : 0;
 		if (arg_unary_subtype)

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-04-30 05:46:42 UTC (rev 401)
+++ trunk/CSupport_pp.cpp	2010-05-04 09:46:52 UTC (rev 402)
@@ -1,4 +1,4 @@
-// CSupport.cpp
+// CSupport_pp.cpp
 // support for C/C++ parsing
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
@@ -5079,8 +5079,6 @@
 			return;
 			}
 
-		if (0<src.data<2>()->type_code.pointer_power) return;
-
 		const size_t arg_unary_subtype 	= (is_C99_unary_operator_expression<'-'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_NEG
 										: (is_C99_unary_operator_expression<'+'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_PLUS : 0;
 		if (arg_unary_subtype)



From zaimoni at mail.berlios.de  Wed May  5 19:54:18 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 5 May 2010 19:54:18 +0200
Subject: [Zcplusplus-commits] r403 - trunk
Message-ID: <201005051754.o45HsI3s024491@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-05 19:54:14 +0200 (Wed, 05 May 2010)
New Revision: 403

Modified:
   trunk/CPUInfo.hpp
   trunk/Flat_UNI.hpp
   trunk/Trigraph.hpp
Log:
documentation clean; initial hooks for pointer size; type_spec_class wrapper for type_spec

Modified: trunk/CPUInfo.hpp
===================================================================
--- trunk/CPUInfo.hpp	2010-05-04 09:46:52 UTC (rev 402)
+++ trunk/CPUInfo.hpp	2010-05-05 17:54:14 UTC (rev 403)
@@ -105,6 +105,10 @@
 	unsigned short C_sizeof_int() const {return sizeof_int;};
 	unsigned short C_sizeof_long() const {return sizeof_long;};
 	unsigned short C_sizeof_long_long() const {return sizeof_long_long;};
+	unsigned short C_sizeof(std_int_enum x) const {return	(std_int_char==x) ? 1 : 
+														(std_int_short==x) ? C_sizeof_short() : 
+														(std_int_int==x) ? C_sizeof_int() : 
+														(std_int_long==x) ? C_sizeof_long() : C_sizeof_long_long() ;};
 	unsigned short C_bit(std_int_enum x) const {return	(std_int_char==x) ? C_char_bit() : 
 														(std_int_short==x) ? C_char_bit()*C_sizeof_short() : 
 														(std_int_int==x) ? C_char_bit()*C_sizeof_int() : 
@@ -144,6 +148,11 @@
 	const umaxint& signed_max(std_int_enum x) const {return signed_maxima[x-1];};
 	template<std_int_enum x> const umaxint& signed_max() const {return signed_maxima[x-1];}
 
+	// we'll eventually want to make this independently specified, also
+	// until then, we're targeting a really flat memory space
+	unsigned short C_sizeof_data_ptr() const {return C_sizeof(ptrdiff_t_type());};
+	unsigned short C_sizeof_function_ptr() const {return C_sizeof(ptrdiff_t_type());};
+	
 	// return value is weird...it's true iff the promoted x is a negative numeral
 	bool C_promote_integer(umaxint& x,const promotion_info& src_type, const promotion_info& dest_type) const;
 };

Modified: trunk/Flat_UNI.hpp
===================================================================
--- trunk/Flat_UNI.hpp	2010-05-04 09:46:52 UTC (rev 402)
+++ trunk/Flat_UNI.hpp	2010-05-05 17:54:14 UTC (rev 403)
@@ -9,7 +9,7 @@
  *
  * \pre string allocated with Zaimoni.STL memory manager
  *
- * \ret true, return value is only to glue into LangConf
+ * \return true, return value is only to glue into LangConf
  */
 bool FlattenUNICODE(char*& Text);
 

Modified: trunk/Trigraph.hpp
===================================================================
--- trunk/Trigraph.hpp	2010-05-04 09:46:52 UTC (rev 402)
+++ trunk/Trigraph.hpp	2010-05-05 17:54:14 UTC (rev 403)
@@ -9,7 +9,7 @@
  *
  * \pre string allocated with Zaimoni.STL memory manager
  *
- * \ret true, return value is only to glue into LangConf
+ * \return true, return value is only to glue into LangConf
  */
 bool EnforceCTrigraphs(char*& Text);
 



From zaimoni at mail.berlios.de  Wed May  5 19:55:05 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 5 May 2010 19:55:05 +0200
Subject: [Zcplusplus-commits] r404 - trunk
Message-ID: <201005051755.o45Ht5FU024528@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-05 19:55:01 +0200 (Wed, 05 May 2010)
New Revision: 404

Modified:
   trunk/type_spec.hpp
Log:
complete prior commit

Modified: trunk/type_spec.hpp
===================================================================
--- trunk/type_spec.hpp	2010-05-05 17:54:14 UTC (rev 403)
+++ trunk/type_spec.hpp	2010-05-05 17:55:01 UTC (rev 404)
@@ -66,4 +66,34 @@
 #endif
 };
 
+// non-virtual, intentionally
+class type_spec_class : public type_spec
+{
+public:
+	type_spec_class() {this->clear();};
+	type_spec_class(const type_spec_class& src)
+		{
+		this->clear();
+		value_copy(*this,src);
+		};
+	type_spec_class(const type_spec& src)
+		{
+		this->clear();
+		value_copy(*this,src);
+		};
+	~type_spec_class() {this->destroy();};
+	const type_spec_class& operator=(const type_spec_class& src)
+		{
+		this->destroy();
+		value_copy(*this,src);
+		return *this;
+		}
+	const type_spec_class& operator=(const type_spec& src)
+		{
+		this->destroy();
+		value_copy(*this,src);
+		return *this;
+		}
+};
+
 #endif



From zaimoni at mail.berlios.de  Wed May  5 20:06:56 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 5 May 2010 20:06:56 +0200
Subject: [Zcplusplus-commits] r405 - trunk
Message-ID: <201005051806.o45I6uYe025541@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-05 20:06:53 +0200 (Wed, 05 May 2010)
New Revision: 405

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
reduce RAM flogging; minor code cleanup

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-05 17:55:01 UTC (rev 404)
+++ trunk/CSupport.cpp	2010-05-05 18:06:53 UTC (rev 405)
@@ -5307,14 +5307,8 @@
 	assert(dest.second);
 	if (suffix) strcat(buf,suffix);
 
-	dest.first = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(strlen(buf)));
-	if (!dest.first)
-		{
-		free(buf);
-		return false;
-		}
-	strcpy(dest.first,buf);
-	free(buf);
+	// shrinking realloc should be no-fail
+	dest.first = REALLOC(buf,ZAIMONI_LEN_WITH_NULL(strlen(buf)));
 	return true;
 }
 
@@ -5913,12 +5907,12 @@
 {
 	umaxint tmp_int(target_machine->signed_max(machine_type));
 	parse_tree* const tmp = _new_buffer<parse_tree>(1);	// XXX we recycle this variable later
-	if (NULL==tmp) return false;
+	if (!tmp) return false;
 	if (!VM_to_literal(*tmp,tmp_int,src_loc,types)) return false;
 
 	tmp_int = 1;
 	parse_tree* const tmp2 = _new_buffer<parse_tree>(1);
-	if (NULL==tmp2)
+	if (!tmp2)
 		{
 		tmp->destroy();
 		_flush(tmp);
@@ -5934,7 +5928,7 @@
 		}
 
 	parse_tree* const tmp3 = _new_buffer<parse_tree>(1);
-	if (NULL==tmp3)
+	if (!tmp3)
 		{
 		tmp2->destroy();
 		_flush(tmp2);
@@ -6261,6 +6255,20 @@
 		{
 		if (eval_sizeof_core_type(src,src.data<2>()->type_code.base_type_index,types)) return true;
 		}
+	else if (!(type_spec::_array & src.type_code.qualifier<0>()))
+		{	// data or function pointer...fine
+			//! \bug need test cases
+		const size_t size_t_type = unsigned_type_from_machine_type(target_machine->size_t_type());
+		parse_tree tmp;
+		src.type_code.set_type(size_t_type);
+		//! \todo eventually, need to check for data vs function pointer when pointer_power is 1
+		if (!VM_to_literal(tmp,umaxint(target_machine->C_sizeof_data_ptr()),src,types)) return false;
+		src.destroy();
+		src = tmp;			
+		assert(size_t_type==src.type_code.base_type_index);
+		return true;
+		}
+	// actual array of something
 	return false;
 }
 

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-05 17:55:01 UTC (rev 404)
+++ trunk/CSupport_pp.cpp	2010-05-05 18:06:53 UTC (rev 405)
@@ -4837,14 +4837,8 @@
 	assert(dest.second);
 	if (suffix) strcat(buf,suffix);
 
-	dest.first = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(strlen(buf)));
-	if (!dest.first)
-		{
-		free(buf);
-		return false;
-		}
-	strcpy(dest.first,buf);
-	free(buf);
+	// shrinking realloc should be no-fail
+	dest.first = REALLOC(buf,ZAIMONI_LEN_WITH_NULL(strlen(buf)));
 	return true;
 }
 



From zaimoni at mail.berlios.de  Wed May  5 20:15:13 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 5 May 2010 20:15:13 +0200
Subject: [Zcplusplus-commits] r406 - trunk
Message-ID: <201005051815.o45IFDAC026034@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-05 20:15:11 +0200 (Wed, 05 May 2010)
New Revision: 406

Modified:
   trunk/CSupport_pp.cpp
Log:
more code cleanup

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-05 18:06:53 UTC (rev 405)
+++ trunk/CSupport_pp.cpp	2010-05-05 18:15:11 UTC (rev 406)
@@ -5361,12 +5361,12 @@
 {
 	umaxint tmp_int(target_machine->signed_max(machine_type));
 	parse_tree* const tmp = _new_buffer<parse_tree>(1);	// XXX we recycle this variable later
-	if (NULL==tmp) return false;
+	if (!tmp) return false;
 	if (!VM_to_literal(*tmp,tmp_int,src_loc,types)) return false;
 
 	tmp_int = 1;
 	parse_tree* const tmp2 = _new_buffer<parse_tree>(1);
-	if (NULL==tmp2)
+	if (!tmp2)
 		{
 		tmp->destroy();
 		_flush(tmp);
@@ -5382,7 +5382,7 @@
 		}
 
 	parse_tree* const tmp3 = _new_buffer<parse_tree>(1);
-	if (NULL==tmp3)
+	if (!tmp3)
 		{
 		tmp2->destroy();
 		_flush(tmp2);



From zaimoni at mail.berlios.de  Wed May  5 20:42:52 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 5 May 2010 20:42:52 +0200
Subject: [Zcplusplus-commits] r407 - trunk
Message-ID: <201005051842.o45IgqNK028464@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-05 20:42:48 +0200 (Wed, 05 May 2010)
New Revision: 407

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
split upcoming diff into two chunks to slide under 40K size limit; soon-to-be-correct documentation changes

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-05 18:15:11 UTC (rev 406)
+++ trunk/CSupport.cpp	2010-05-05 18:42:48 UTC (rev 407)
@@ -5434,6 +5434,7 @@
 	return converts_to_integerlike(x.type_code ARG_TYPES) && (PARSE_PRIMARY_EXPRESSION & x.flags);
 }
 
+//! \throw std::bad_alloc()
 static bool eval_unary_plus(parse_tree& src, const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'+'>(src));
@@ -5473,6 +5474,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_unary_minus(parse_tree& src, const type_system& types,literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_unary_operator_expression<'-'>(src));
@@ -5956,6 +5958,7 @@
 	return true;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_bitwise_compl(parse_tree& src, const type_system& types,bool hard_error,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_bitwise_complement_expression(src));
@@ -6730,7 +6733,8 @@
 	return false;
 }
 
-static bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+//! \throw std::bad_alloc()
+tatic bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'/'>(src));
 
@@ -6857,6 +6861,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_mod_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'%'>(src));
@@ -7246,6 +7251,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_add_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'+'>(src));
@@ -7400,6 +7406,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'-'>(src));
@@ -7557,6 +7564,7 @@
 
 // +: either both are arithmetic, or one is raw pointer and one is integer
 // -: either both are arithmetic, or both are compatible raw pointer, or left is raw pointer and right is integer
+//! \throw std::bad_alloc()
 static void C_CPP_add_expression_easy_syntax_check(parse_tree& src,const type_system& types,literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert((C99_ADD_SUBTYPE_PLUS==src.subtype && is_C99_add_operator_expression<'+'>(src)) || (C99_ADD_SUBTYPE_MINUS==src.subtype && is_C99_add_operator_expression<'-'>(src)));
@@ -7836,6 +7844,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_shift(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
@@ -8481,6 +8490,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
@@ -8677,6 +8687,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
@@ -8857,6 +8868,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_bitwise_OR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-05 18:15:11 UTC (rev 406)
+++ trunk/CSupport_pp.cpp	2010-05-05 18:42:48 UTC (rev 407)
@@ -4937,6 +4937,7 @@
 	return converts_to_integerlike(x.type_code ARG_TYPES) && (PARSE_PRIMARY_EXPRESSION & x.flags);
 }
 
+//! \throw std::bad_alloc()
 static bool eval_unary_plus(parse_tree& src, const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'+'>(src));
@@ -4962,6 +4963,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_unary_minus(parse_tree& src, const type_system& types,literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_unary_operator_expression<'-'>(src));
@@ -5410,6 +5412,7 @@
 	return true;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_bitwise_compl(parse_tree& src, const type_system& types,bool hard_error,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_bitwise_complement_expression(src));
@@ -5948,6 +5951,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'/'>(src));
@@ -6075,6 +6079,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_mod_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'%'>(src));
@@ -6435,6 +6440,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_add_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'+'>(src));
@@ -6589,6 +6595,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'-'>(src));
@@ -6746,6 +6753,7 @@
 
 // +: either both are arithmetic, or one is raw pointer and one is integer
 // -: either both are arithmetic, or both are compatible raw pointer, or left is raw pointer and right is integer
+//! \throw std::bad_alloc()
 static void C_CPP_add_expression_easy_syntax_check(parse_tree& src,const type_system& types,literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert((C99_ADD_SUBTYPE_PLUS==src.subtype && is_C99_add_operator_expression<'+'>(src)) || (C99_ADD_SUBTYPE_MINUS==src.subtype && is_C99_add_operator_expression<'-'>(src)));
@@ -6995,6 +7003,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_shift(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
@@ -7634,6 +7643,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
@@ -7810,6 +7820,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
@@ -7978,6 +7989,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_bitwise_OR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));



From zaimoni at mail.berlios.de  Thu May  6 00:17:35 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 6 May 2010 00:17:35 +0200
Subject: [Zcplusplus-commits] r408 - trunk
Message-ID: <201005052217.o45MHZcl010467@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-06 00:17:30 +0200 (Thu, 06 May 2010)
New Revision: 408

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
change policy with respect to std::bad_alloc; exceptions should allow monitoring more precisely for incremental progress vs. memory issues

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-05 18:42:48 UTC (rev 407)
+++ trunk/CSupport.cpp	2010-05-05 22:17:30 UTC (rev 408)
@@ -5293,13 +5293,12 @@
 
 // can't do much syntax-checking or immediate-evaluation here because of binary +/-
 // unary +/- syntax checking out out of place as it's needed by all of the unary operators
-// return code is true for success, false for memory failure
-static bool VM_to_token(const umaxint& src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
+//! \throw std::bad_alloc()
+static void VM_to_token(const umaxint& src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
 {
 	assert(C_TYPE::INT<=base_type_index && C_TYPE::ULLONG>=base_type_index);
 	const char* const suffix = literal_suffix(base_type_index);
-	char* buf = _new_buffer<char>((VM_MAX_BIT_PLATFORM/3)+4);
-	if (!buf) return false;
+	char* buf = _new_buffer_nonNULL_throws<char>((VM_MAX_BIT_PLATFORM/3)+4);
 	dest.second = literal_flags(base_type_index);
 	dest.second |= C_TESTFLAG_DECIMAL;
 	z_ucharint_toa(src_int,buf,10);
@@ -5309,21 +5308,20 @@
 
 	// shrinking realloc should be no-fail
 	dest.first = REALLOC(buf,ZAIMONI_LEN_WITH_NULL(strlen(buf)));
-	return true;
 }
 
 // return code is true for success, false for memory failure
-static bool VM_to_literal(parse_tree& dest, const umaxint& src_int,const parse_tree& src,const type_system& types)
+//! \throw std::bad_alloc()
+static void VM_to_literal(parse_tree& dest, const umaxint& src_int,const parse_tree& src,const type_system& types)
 {
 	POD_pair<char*,lex_flags> new_token;
-	if (!VM_to_token(src_int,src.type_code.base_type_index,new_token)) return false;
+	VM_to_token(src_int,src.type_code.base_type_index,new_token);
 	dest.clear();
 	dest.grab_index_token_from<0>(new_token.first,new_token.second);
 	dest.grab_index_token_location_from<0,0>(src);
 	assert((C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_STRING_LITERAL | C_TESTFLAG_PP_NUMERAL) & dest.index_tokens[0].flags);
 	_label_one_literal(dest,types);
 	assert(PARSE_EXPRESSION & dest.flags);
-	return true;
 }
 
 static void force_decimal_literal(parse_tree& dest,const char* src,const type_system& types)
@@ -5387,23 +5385,29 @@
 
 // this one hides a slight inefficiency: negative literals take 2 dynamic memory allocations, positive literals take one
 // return code is true for success, false for memory failure
-static bool VM_to_signed_literal(parse_tree& x,const bool is_negative, const umaxint& src_int,const parse_tree& src,const type_system& types)
+//! \throw std::bad_alloc()
+static void VM_to_signed_literal(parse_tree& x,const bool is_negative, const umaxint& src_int,const parse_tree& src,const type_system& types)
 {
 	if (is_negative)
 		{
-		parse_tree* tmp = _new_buffer<parse_tree>(1);
-		if (NULL==tmp) return false;
-		if (!VM_to_literal(*tmp,src_int,src,types)) return false;
+		parse_tree* tmp = _new_buffer_nonNULL_throws<parse_tree>(1);
+		try {
+			VM_to_literal(*tmp,src_int,src,types);
+			}
+		catch(const std::bad_alloc&)
+			{
+			_flush(tmp);
+			throw;
+			}
 		assert(PARSE_EXPRESSION & tmp->flags);
 		force_unary_negative_token(x,tmp,*tmp ARG_TYPES);
 		}
-	else if (!VM_to_literal(x,src_int,src,types))
-		return false;
-	return true;
+	else VM_to_literal(x,src_int,src,types);
 }
 #/*cut-cpp*/
 
-static bool enumerator_to_integer_representation(parse_tree& x,const type_system& types)
+//! \throw std::bad_alloc()
+static void enumerator_to_integer_representation(parse_tree& x,const type_system& types)
 {
 	parse_tree tmp3;
 	const type_system::enumerator_info* const tmp2 = types.get_enumerator(x.index_tokens[0].token.first);
@@ -5416,16 +5420,18 @@
 	{	// pretend x is the type of the enumerator.
 	const type_system::type_index backup = x.type_code.base_type_index;
 	x.type_code.base_type_index = tmp2->second.first.second;
-	if (!VM_to_signed_literal(tmp3,tmp_negative,res_int,x,types))
+	try {
+		VM_to_signed_literal(tmp3,tmp_negative,res_int,x,types);
+		}
+	catch(const std::bad_alloc&)
 		{
 		x.type_code.base_type_index = backup;
-		return false;
+		throw;
 		}
 	}
 	}
 	x.destroy();
 	x = tmp3;
-	return true;
 }
 #/*cut-cpp*/
 
@@ -5452,7 +5458,7 @@
 #/*cut-cpp*/
 	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
-		if (!enumerator_to_integer_representation(*src.c_array<2>(),types)) return false;
+		enumerator_to_integer_representation(*src.c_array<2>(),types);
 		if (is_C99_unary_operator_expression<'-'>(*src.data<2>()))
 			{	// enumerator went negative: handle
 			parse_tree tmp = *src.c_array<2>();
@@ -5490,7 +5496,7 @@
 #/*cut-cpp*/
 	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
-		if (!enumerator_to_integer_representation(*src.c_array<2>(),types)) return false;
+		enumerator_to_integer_representation(*src.c_array<2>(),types);
 		if (is_C99_unary_operator_expression<'-'>(*src.data<2>()))
 			{	// enumerator went negative: handle
 			parse_tree tmp = *src.c_array<2>()->c_array<2>();
@@ -5512,7 +5518,7 @@
 
 		//! \todo flag failures to reduce as RAM-stalled
 		POD_pair<char*,lex_flags> new_token;
-		if (!VM_to_token(res_int,old_type.base_type_index,new_token)) return false;
+		VM_to_token(res_int,old_type.base_type_index,new_token);
 		src.c_array<2>()->grab_index_token_from<0>(new_token.first,new_token.second);
 		src.eval_to_arg<2>(0);
 		src.type_code = old_type;
@@ -5910,7 +5916,14 @@
 	umaxint tmp_int(target_machine->signed_max(machine_type));
 	parse_tree* const tmp = _new_buffer<parse_tree>(1);	// XXX we recycle this variable later
 	if (!tmp) return false;
-	if (!VM_to_literal(*tmp,tmp_int,src_loc,types)) return false;
+	try {
+		VM_to_literal(*tmp,tmp_int,src_loc,types);
+		}
+	catch(const std::bad_alloc&)
+		{
+		_flush(tmp);
+		return false;
+		}
 
 	tmp_int = 1;
 	parse_tree* const tmp2 = _new_buffer<parse_tree>(1);
@@ -5920,7 +5933,10 @@
 		_flush(tmp);
 		return false;
 		}
-	if (!VM_to_literal(*tmp2,tmp_int,src_loc,types))
+	try {
+		VM_to_literal(*tmp2,tmp_int,src_loc,types);
+		}
+	catch(const std::bad_alloc&)
 		{
 		tmp2->destroy();
 		_flush(tmp2);
@@ -5966,7 +5982,7 @@
 #/*cut-cpp*/
 	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
-		if (!enumerator_to_integer_representation(*src.c_array<2>(),types)) return false;
+		enumerator_to_integer_representation(*src.c_array<2>(),types);
 		src.type_code = src.data<2>()->type_code;
 		}
 #/*cut-cpp*/
@@ -5993,7 +6009,13 @@
 			}
 
 		parse_tree tmp;
-		if (!VM_to_literal(tmp,res_int,src,types)) return false;	// two's-complement non-trapping INT_MIN dies if it gets here
+		try {
+			VM_to_literal(tmp,res_int,src,types);	// two's-complement non-trapping INT_MIN dies if it gets here
+			}
+		catch(const std::bad_alloc&)
+			{
+			return false;
+			}
 
 		if (negative_signed_int)
 			// convert to parsed - literal
@@ -6180,6 +6202,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_sizeof_core_type(parse_tree& src,const size_t base_type_index,const type_system& types)
 {	//! \todo eventually handle the floating and complex types here as well
 	//! \todo types parameter is close to redundant
@@ -6206,7 +6229,7 @@
 	case C_TYPE::USHRT:
 		{
 		src.type_code.set_type(size_t_type);
-		if (!VM_to_literal(tmp,umaxint(target_machine->C_sizeof_short()),src,types)) return false;
+		VM_to_literal(tmp,umaxint(target_machine->C_sizeof_short()),src,types);
 		src.destroy();
 		src = tmp;			
 		break;
@@ -6215,7 +6238,7 @@
 	case C_TYPE::UINT:
 		{
 		src.type_code.set_type(size_t_type);
-		if (!VM_to_literal(tmp,umaxint(target_machine->C_sizeof_int()),src,types)) return false;
+		VM_to_literal(tmp,umaxint(target_machine->C_sizeof_int()),src,types);
 		src.destroy();
 		src = tmp;			
 		break;
@@ -6224,7 +6247,7 @@
 	case C_TYPE::ULONG:
 		{
 		src.type_code.set_type(size_t_type);
-		if (!VM_to_literal(tmp,umaxint(target_machine->C_sizeof_long()),src,types)) return false;
+		VM_to_literal(tmp,umaxint(target_machine->C_sizeof_long()),src,types);
 		src.destroy();
 		src = tmp;			
 		break;
@@ -6233,7 +6256,7 @@
 	case C_TYPE::ULLONG:
 		{
 		src.type_code.set_type(size_t_type);
-		if (!VM_to_literal(tmp,umaxint(target_machine->C_sizeof_long_long()),src,types)) return false;
+		VM_to_literal(tmp,umaxint(target_machine->C_sizeof_long_long()),src,types);
 		src.destroy();
 		src = tmp;			
 //		break;
@@ -6251,6 +6274,7 @@
 	return true;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_C99_CPP_sizeof(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_CPP_sizeof_expression(src));
@@ -6265,7 +6289,7 @@
 		parse_tree tmp;
 		src.type_code.set_type(size_t_type);
 		//! \todo eventually, need to check for data vs function pointer when pointer_power is 1
-		if (!VM_to_literal(tmp,umaxint(target_machine->C_sizeof_data_ptr()),src,types)) return false;
+		VM_to_literal(tmp,umaxint(target_machine->C_sizeof_data_ptr()),src,types);
 		src.destroy();
 		src = tmp;			
 		assert(size_t_type==src.type_code.base_type_index);
@@ -6623,6 +6647,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_mult_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'*'>(src));
@@ -6710,7 +6735,7 @@
 				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
 				// convert to parsed - literal
 				parse_tree tmp;
-				if (!VM_to_literal(tmp,lhs_test,src,types)) return false;
+				VM_to_literal(tmp,lhs_test,src,types);
 
 				src.DeleteIdx<1>(0);
 				force_unary_negative_literal(src,tmp);
@@ -6724,7 +6749,7 @@
 
 		// convert to parsed + literal
 		parse_tree tmp;
-		if (!VM_to_literal(tmp,res_int,src,types)) return false;
+		VM_to_literal(tmp,res_int,src,types);
 		tmp.type_code = old_type;
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp ARG_TYPES);
@@ -6734,7 +6759,7 @@
 }
 
 //! \throw std::bad_alloc()
-tatic bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'/'>(src));
 
@@ -6829,7 +6854,7 @@
 				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
 				// convert to parsed - literal
 				parse_tree tmp;
-				if (!VM_to_literal(tmp,lhs_test,src,types)) return false;
+				VM_to_literal(tmp,lhs_test,src,types);
 
 				src.DeleteIdx<1>(0);
 				force_unary_negative_literal(src,tmp);
@@ -6851,7 +6876,7 @@
 
 		// convert to parsed + literal
 		parse_tree tmp;
-		if (!VM_to_literal(tmp,res_int,src,types)) return false;
+		VM_to_literal(tmp,res_int,src,types);
 		tmp.type_code = old_type;
 
 		src.DeleteIdx<1>(0);
@@ -6944,7 +6969,7 @@
 				else{
 					// convert to parsed - literal
 					parse_tree tmp;
-					if (!VM_to_literal(tmp,lhs_test,src,types)) return false;
+					VM_to_literal(tmp,lhs_test,src,types);
 
 					src.DeleteIdx<1>(0);
 					force_unary_negative_literal(src,tmp);
@@ -6960,7 +6985,7 @@
 
 		// convert to parsed + literal
 		parse_tree tmp;
-		if (!VM_to_literal(tmp,res_int,src,types)) return false;
+		VM_to_literal(tmp,res_int,src,types);
 		tmp.type_code = old_type;
 
 		src.DeleteIdx<1>(0);
@@ -6992,13 +7017,13 @@
 #/*cut-cpp*/
 	if (is_noticed_enumerator(*src.data<1>(),types))
 		{
-		if (!enumerator_to_integer_representation(*src.c_array<1>(),types)) return false;
+		enumerator_to_integer_representation(*src.c_array<1>(),types);
 		lhs = default_promotion_is_integerlike(src.data<1>()->type_code,types);
 		assert(lhs.second);
 		}
 	if (is_noticed_enumerator(*src.data<2>(),types)) 
 		{
-		if (!enumerator_to_integer_representation(*src.c_array<2>(),types)) return false;
+		enumerator_to_integer_representation(*src.c_array<2>(),types);
 		rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
 		assert(rhs.second);
 		}
@@ -7032,13 +7057,13 @@
 	// arithmeticlike subsumes integerlike so this is fine
 	if (is_noticed_enumerator(*src.data<1>(),types))
 		{
-		if (!enumerator_to_integer_representation(*src.c_array<1>(),types)) return false;
+		enumerator_to_integer_representation(*src.c_array<1>(),types);
 		lhs = default_promotion_is_integerlike(src.data<1>()->type_code,types);
 		assert(lhs.second);
 		}
 	if (is_noticed_enumerator(*src.data<2>(),types)) 
 		{
-		if (!enumerator_to_integer_representation(*src.c_array<2>(),types)) return false;
+		enumerator_to_integer_representation(*src.c_array<2>(),types);
 		rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
 		assert(rhs.second);
 		}
@@ -7349,7 +7374,7 @@
 						{
 						// convert to parsed - literal
 						parse_tree tmp;
-						if (!VM_to_literal(tmp,lhs_test,src,types)) return false;
+						VM_to_literal(tmp,lhs_test,src,types);
 
 						type_spec old_type;
 						src.type_code.OverwriteInto(old_type);
@@ -7365,7 +7390,7 @@
 
 				// convert to parsed + literal
 				parse_tree tmp;
-				if (!VM_to_literal(tmp,res_int,src,types)) return false;
+				VM_to_literal(tmp,res_int,src,types);
 				src.type_code.MoveInto(tmp.type_code);
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp ARG_TYPES);
@@ -7506,7 +7531,7 @@
 						{
 						// convert to parsed - literal
 						parse_tree tmp;
-						if (!VM_to_literal(tmp,lhs_test,src,types)) return false;
+						VM_to_literal(tmp,lhs_test,src,types);
 						type_spec old_type;
 						src.type_code.OverwriteInto(old_type);
 						src.DeleteIdx<1>(0);
@@ -7521,7 +7546,7 @@
 
 				// convert to parsed + literal
 				parse_tree tmp;
-				if (!VM_to_literal(tmp,res_int,src,types)) return false;
+				VM_to_literal(tmp,res_int,src,types);
 				src.type_code.MoveInto(tmp.type_code);
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp ARG_TYPES);
@@ -7608,13 +7633,13 @@
 			// arithmeticlike subsumes integerlike so this is fine
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				{
-				if (!enumerator_to_integer_representation(*src.c_array<1>(),types)) return;
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
 				lhs = default_promotion_is_integerlike(src.data<1>()->type_code,types);
 				assert(lhs.second);
 				}
 			if (is_noticed_enumerator(*src.data<2>(),types)) 
 				{
-				if (!enumerator_to_integer_representation(*src.c_array<2>(),types)) return;
+				enumerator_to_integer_representation(*src.c_array<2>(),types);
 				rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
 				assert(rhs.second);
 				}
@@ -7668,13 +7693,13 @@
 			// arithmeticlike subsumes integerlike so this is fine
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				{
-				if (!enumerator_to_integer_representation(*src.c_array<1>(),types)) return;
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
 				lhs = default_promotion_is_integerlike(src.data<1>()->type_code,types);
 				assert(lhs.second);
 				}
 			if (is_noticed_enumerator(*src.data<2>(),types)) 
 				{
-				if (!enumerator_to_integer_representation(*src.c_array<2>(),types)) return;
+				enumerator_to_integer_representation(*src.c_array<2>(),types);
 				rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
 				assert(rhs.second);
 				}
@@ -7866,9 +7891,8 @@
 			{	// __ << 0 or __ >> 0: lift
 #/*cut-cpp*/
 			// handle enumerators now
-			if (   is_noticed_enumerator(*src.data<1>(),types)
-				&& !enumerator_to_integer_representation(*src.c_array<1>(),types))
-				return false;
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
 #/*cut-cpp*/
 			src.eval_to_arg<1>(0);
 			src.type_code = old_type;
@@ -7918,7 +7942,7 @@
 			const bool negative_signed_int = 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && res_int.test(target_machine->C_bit(machine_type)-1);
 			if (negative_signed_int) target_machine->signed_additive_inverse(res_int,machine_type);
 			parse_tree tmp;
-			if (!VM_to_literal(tmp,res_int,src,types)) return false;
+			VM_to_literal(tmp,res_int,src,types);
 
 			if (negative_signed_int)
 				{	// convert to parsed - literal
@@ -8490,7 +8514,7 @@
 	return false;
 }
 
-//! \throw std::bad_alloc()
+//! \throw std::bad_alloc
 static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
@@ -8536,9 +8560,8 @@
 #/*cut-cpp*/
 			{
 			// handle enumerators now
-			if (   is_noticed_enumerator(*src.data<1>(),types)
-				&& !enumerator_to_integer_representation(*src.c_array<1>(),types))
-				return false;
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
 #/*cut-cpp*/
 			src.eval_to_arg<1>(0);
 #/*cut-cpp*/
@@ -8549,9 +8572,8 @@
 #/*cut-cpp*/
 			{
 			// handle enumerators now
-			if (   is_noticed_enumerator(*src.data<2>(),types)
-				&& !enumerator_to_integer_representation(*src.c_array<2>(),types))
-				return false;
+			if (is_noticed_enumerator(*src.data<2>(),types))
+				enumerator_to_integer_representation(*src.c_array<2>(),types);
 #/*cut-cpp*/
 			src.eval_to_arg<2>(0);
 #/*cut-cpp*/
@@ -8571,7 +8593,7 @@
 				}
 
 			parse_tree tmp;
-			if (!VM_to_signed_literal(tmp,negative_signed_int,res_int,src,types)) return false;
+			VM_to_signed_literal(tmp,negative_signed_int,res_int,src,types);
 			src.destroy();
 			src = tmp;
 			}
@@ -8687,7 +8709,7 @@
 	return false;
 }
 
-//! \throw std::bad_alloc()
+// throws std::bad_alloc
 static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
@@ -8704,9 +8726,8 @@
 			{	// 0 ^ __
 #/*cut-cpp*/
 			// handle enumerators now
-			if (   is_noticed_enumerator(*src.data<2>(),types)
-				&& !enumerator_to_integer_representation(*src.c_array<2>(),types))
-				return false;
+			if (is_noticed_enumerator(*src.data<2>(),types))
+				enumerator_to_integer_representation(*src.c_array<2>(),types);
 #/*cut-cpp*/
 			src.eval_to_arg<2>(0);
 			//! \todo convert char literal to appropriate integer
@@ -8719,9 +8740,8 @@
 			{	// __ ^ 0
 #/*cut-cpp*/
 			// handle enumerators now
-			if (   is_noticed_enumerator(*src.data<1>(),types)
-				&& !enumerator_to_integer_representation(*src.c_array<1>(),types))
-				return false;
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
 #/*cut-cpp*/
 			src.eval_to_arg<1>(0);
 			//! \todo convert char literal to appropriate integer
@@ -8754,7 +8774,7 @@
 			}
 
 		parse_tree tmp;
-		if (!VM_to_signed_literal(tmp,negative_signed_int,res_int,src,types)) return false;
+		VM_to_signed_literal(tmp,negative_signed_int,res_int,src,types);
 		src.destroy();
 		src = tmp;
 		src.type_code = old_type;
@@ -8885,9 +8905,8 @@
 			{	// 0 | __
 #/*cut-cpp*/
 			// handle enumerators now
-			if (   is_noticed_enumerator(*src.data<2>(),types)
-				&& !enumerator_to_integer_representation(*src.c_array<2>(),types))
-				return false;
+			if (is_noticed_enumerator(*src.data<2>(),types))
+				enumerator_to_integer_representation(*src.c_array<2>(),types);
 #/*cut-cpp*/
 			src.eval_to_arg<2>(0);
 			//! \todo convert char literal to appropriate integer
@@ -8900,9 +8919,8 @@
 			{	// __ | 0
 #/*cut-cpp*/
 			// handle enumerators now
-			if (   is_noticed_enumerator(*src.data<1>(),types)
-				&& !enumerator_to_integer_representation(*src.c_array<1>(),types))
-				return false;
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
 #/*cut-cpp*/
 			src.eval_to_arg<1>(0);
 			//! \todo convert char literal to appropriate integer
@@ -8924,9 +8942,8 @@
 #/*cut-cpp*/
 			{
 			// handle enumerators now
-			if (   is_noticed_enumerator(*src.data<1>(),types)
-				&& !enumerator_to_integer_representation(*src.c_array<1>(),types))
-				return false;
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
 #/*cut-cpp*/
 			src.eval_to_arg<1>(0);
 #/*cut-cpp*/
@@ -8937,9 +8954,8 @@
 #/*cut-cpp*/
 			{
 			// handle enumerators now
-			if (   is_noticed_enumerator(*src.data<1>(),types)
-				&& !enumerator_to_integer_representation(*src.c_array<1>(),types))
-				return false;
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
 #/*cut-cpp*/
 			src.eval_to_arg<2>(0);
 #/*cut-cpp*/
@@ -8952,7 +8968,7 @@
 			const bool negative_signed_int = 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && res_int.test(target_machine->C_bit(machine_type)-1);
 			if (negative_signed_int) target_machine->signed_additive_inverse(res_int,machine_type);
 			parse_tree tmp;
-			if (!VM_to_literal(tmp,res_int,src,types)) return false;
+			VM_to_literal(tmp,res_int,src,types);
 
 			if (negative_signed_int)
 				{	// convert to parsed - literal
@@ -11253,6 +11269,7 @@
 	assert(x.empty<2>());
 }
 
+//! \throw std::bad_alloc()
 static void C99_CPP_handle_static_assertion(parse_tree& src,type_system& types,PP_auxfunc& langinfo,const size_t i,const char* const err,const char* const active_namespace)
 {
 	assert(err && *err);
@@ -11346,7 +11363,7 @@
 
 		// handle top-level enumerators
 		if (is_noticed_enumerator(parsetree,types))
-			if (!enumerator_to_integer_representation(parsetree,types)) throw std::bad_alloc();
+			enumerator_to_integer_representation(parsetree,types);
 
 		bool is_true = false;
 		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true,types))

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-05 18:42:48 UTC (rev 407)
+++ trunk/CSupport_pp.cpp	2010-05-05 22:17:30 UTC (rev 408)
@@ -4823,13 +4823,12 @@
 
 // can't do much syntax-checking or immediate-evaluation here because of binary +/-
 // unary +/- syntax checking out out of place as it's needed by all of the unary operators
-// return code is true for success, false for memory failure
-static bool VM_to_token(const umaxint& src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
+//! \throw std::bad_alloc()
+static void VM_to_token(const umaxint& src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
 {
 	assert(C_TYPE::INT<=base_type_index && C_TYPE::ULLONG>=base_type_index);
 	const char* const suffix = literal_suffix(base_type_index);
-	char* buf = _new_buffer<char>((VM_MAX_BIT_PLATFORM/3)+4);
-	if (!buf) return false;
+	char* buf = _new_buffer_nonNULL_throws<char>((VM_MAX_BIT_PLATFORM/3)+4);
 	dest.second = literal_flags(base_type_index);
 	dest.second |= C_TESTFLAG_DECIMAL;
 	z_ucharint_toa(src_int,buf,10);
@@ -4839,21 +4838,20 @@
 
 	// shrinking realloc should be no-fail
 	dest.first = REALLOC(buf,ZAIMONI_LEN_WITH_NULL(strlen(buf)));
-	return true;
 }
 
 // return code is true for success, false for memory failure
-static bool VM_to_literal(parse_tree& dest, const umaxint& src_int,const parse_tree& src,const type_system& types)
+//! \throw std::bad_alloc()
+static void VM_to_literal(parse_tree& dest, const umaxint& src_int,const parse_tree& src,const type_system& types)
 {
 	POD_pair<char*,lex_flags> new_token;
-	if (!VM_to_token(src_int,src.type_code.base_type_index,new_token)) return false;
+	VM_to_token(src_int,src.type_code.base_type_index,new_token);
 	dest.clear();
 	dest.grab_index_token_from<0>(new_token.first,new_token.second);
 	dest.grab_index_token_location_from<0,0>(src);
 	assert((C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_STRING_LITERAL | C_TESTFLAG_PP_NUMERAL) & dest.index_tokens[0].flags);
 	_label_one_literal(dest,types);
 	assert(PARSE_EXPRESSION & dest.flags);
-	return true;
 }
 
 static void force_decimal_literal(parse_tree& dest,const char* src,const type_system& types)
@@ -4917,19 +4915,24 @@
 
 // this one hides a slight inefficiency: negative literals take 2 dynamic memory allocations, positive literals take one
 // return code is true for success, false for memory failure
-static bool VM_to_signed_literal(parse_tree& x,const bool is_negative, const umaxint& src_int,const parse_tree& src,const type_system& types)
+//! \throw std::bad_alloc()
+static void VM_to_signed_literal(parse_tree& x,const bool is_negative, const umaxint& src_int,const parse_tree& src,const type_system& types)
 {
 	if (is_negative)
 		{
-		parse_tree* tmp = _new_buffer<parse_tree>(1);
-		if (NULL==tmp) return false;
-		if (!VM_to_literal(*tmp,src_int,src,types)) return false;
+		parse_tree* tmp = _new_buffer_nonNULL_throws<parse_tree>(1);
+		try {
+			VM_to_literal(*tmp,src_int,src,types);
+			}
+		catch(const std::bad_alloc&)
+			{
+			_flush(tmp);
+			throw;
+			}
 		assert(PARSE_EXPRESSION & tmp->flags);
 		force_unary_negative_token(x,tmp,*tmp ARG_TYPES);
 		}
-	else if (!VM_to_literal(x,src_int,src,types))
-		return false;
-	return true;
+	else VM_to_literal(x,src_int,src,types);
 }
 
 static bool is_integerlike_literal(const parse_tree& x SIG_CONST_TYPES)
@@ -4986,7 +4989,7 @@
 
 		//! \todo flag failures to reduce as RAM-stalled
 		POD_pair<char*,lex_flags> new_token;
-		if (!VM_to_token(res_int,old_type.base_type_index,new_token)) return false;
+		VM_to_token(res_int,old_type.base_type_index,new_token);
 		src.c_array<2>()->grab_index_token_from<0>(new_token.first,new_token.second);
 		src.eval_to_arg<2>(0);
 		src.type_code = old_type;
@@ -5364,7 +5367,14 @@
 	umaxint tmp_int(target_machine->signed_max(machine_type));
 	parse_tree* const tmp = _new_buffer<parse_tree>(1);	// XXX we recycle this variable later
 	if (!tmp) return false;
-	if (!VM_to_literal(*tmp,tmp_int,src_loc,types)) return false;
+	try {
+		VM_to_literal(*tmp,tmp_int,src_loc,types);
+		}
+	catch(const std::bad_alloc&)
+		{
+		_flush(tmp);
+		return false;
+		}
 
 	tmp_int = 1;
 	parse_tree* const tmp2 = _new_buffer<parse_tree>(1);
@@ -5374,7 +5384,10 @@
 		_flush(tmp);
 		return false;
 		}
-	if (!VM_to_literal(*tmp2,tmp_int,src_loc,types))
+	try {
+		VM_to_literal(*tmp2,tmp_int,src_loc,types);
+		}
+	catch(const std::bad_alloc&)
 		{
 		tmp2->destroy();
 		_flush(tmp2);
@@ -5440,7 +5453,13 @@
 			}
 
 		parse_tree tmp;
-		if (!VM_to_literal(tmp,res_int,src,types)) return false;	// two's-complement non-trapping INT_MIN dies if it gets here
+		try {
+			VM_to_literal(tmp,res_int,src,types);	// two's-complement non-trapping INT_MIN dies if it gets here
+			}
+		catch(const std::bad_alloc&)
+			{
+			return false;
+			}
 
 		if (negative_signed_int)
 			// convert to parsed - literal
@@ -5841,6 +5860,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_mult_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'*'>(src));
@@ -5928,7 +5948,7 @@
 				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
 				// convert to parsed - literal
 				parse_tree tmp;
-				if (!VM_to_literal(tmp,lhs_test,src,types)) return false;
+				VM_to_literal(tmp,lhs_test,src,types);
 
 				src.DeleteIdx<1>(0);
 				force_unary_negative_literal(src,tmp);
@@ -5942,7 +5962,7 @@
 
 		// convert to parsed + literal
 		parse_tree tmp;
-		if (!VM_to_literal(tmp,res_int,src,types)) return false;
+		VM_to_literal(tmp,res_int,src,types);
 		tmp.type_code = old_type;
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp ARG_TYPES);
@@ -6047,7 +6067,7 @@
 				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
 				// convert to parsed - literal
 				parse_tree tmp;
-				if (!VM_to_literal(tmp,lhs_test,src,types)) return false;
+				VM_to_literal(tmp,lhs_test,src,types);
 
 				src.DeleteIdx<1>(0);
 				force_unary_negative_literal(src,tmp);
@@ -6069,7 +6089,7 @@
 
 		// convert to parsed + literal
 		parse_tree tmp;
-		if (!VM_to_literal(tmp,res_int,src,types)) return false;
+		VM_to_literal(tmp,res_int,src,types);
 		tmp.type_code = old_type;
 
 		src.DeleteIdx<1>(0);
@@ -6162,7 +6182,7 @@
 				else{
 					// convert to parsed - literal
 					parse_tree tmp;
-					if (!VM_to_literal(tmp,lhs_test,src,types)) return false;
+					VM_to_literal(tmp,lhs_test,src,types);
 
 					src.DeleteIdx<1>(0);
 					force_unary_negative_literal(src,tmp);
@@ -6178,7 +6198,7 @@
 
 		// convert to parsed + literal
 		parse_tree tmp;
-		if (!VM_to_literal(tmp,res_int,src,types)) return false;
+		VM_to_literal(tmp,res_int,src,types);
 		tmp.type_code = old_type;
 
 		src.DeleteIdx<1>(0);
@@ -6538,7 +6558,7 @@
 						{
 						// convert to parsed - literal
 						parse_tree tmp;
-						if (!VM_to_literal(tmp,lhs_test,src,types)) return false;
+						VM_to_literal(tmp,lhs_test,src,types);
 
 						type_spec old_type;
 						src.type_code.OverwriteInto(old_type);
@@ -6554,7 +6574,7 @@
 
 				// convert to parsed + literal
 				parse_tree tmp;
-				if (!VM_to_literal(tmp,res_int,src,types)) return false;
+				VM_to_literal(tmp,res_int,src,types);
 				src.type_code.MoveInto(tmp.type_code);
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp ARG_TYPES);
@@ -6695,7 +6715,7 @@
 						{
 						// convert to parsed - literal
 						parse_tree tmp;
-						if (!VM_to_literal(tmp,lhs_test,src,types)) return false;
+						VM_to_literal(tmp,lhs_test,src,types);
 						type_spec old_type;
 						src.type_code.OverwriteInto(old_type);
 						src.DeleteIdx<1>(0);
@@ -6710,7 +6730,7 @@
 
 				// convert to parsed + literal
 				parse_tree tmp;
-				if (!VM_to_literal(tmp,res_int,src,types)) return false;
+				VM_to_literal(tmp,res_int,src,types);
 				src.type_code.MoveInto(tmp.type_code);
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp ARG_TYPES);
@@ -7071,7 +7091,7 @@
 			const bool negative_signed_int = 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && res_int.test(target_machine->C_bit(machine_type)-1);
 			if (negative_signed_int) target_machine->signed_additive_inverse(res_int,machine_type);
 			parse_tree tmp;
-			if (!VM_to_literal(tmp,res_int,src,types)) return false;
+			VM_to_literal(tmp,res_int,src,types);
 
 			if (negative_signed_int)
 				{	// convert to parsed - literal
@@ -7643,7 +7663,7 @@
 	return false;
 }
 
-//! \throw std::bad_alloc()
+//! \throw std::bad_alloc
 static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
@@ -7704,7 +7724,7 @@
 				}
 
 			parse_tree tmp;
-			if (!VM_to_signed_literal(tmp,negative_signed_int,res_int,src,types)) return false;
+			VM_to_signed_literal(tmp,negative_signed_int,res_int,src,types);
 			src.destroy();
 			src = tmp;
 			}
@@ -7820,7 +7840,7 @@
 	return false;
 }
 
-//! \throw std::bad_alloc()
+// throws std::bad_alloc
 static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
@@ -7875,7 +7895,7 @@
 			}
 
 		parse_tree tmp;
-		if (!VM_to_signed_literal(tmp,negative_signed_int,res_int,src,types)) return false;
+		VM_to_signed_literal(tmp,negative_signed_int,res_int,src,types);
 		src.destroy();
 		src = tmp;
 		src.type_code = old_type;
@@ -8041,7 +8061,7 @@
 			const bool negative_signed_int = 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && res_int.test(target_machine->C_bit(machine_type)-1);
 			if (negative_signed_int) target_machine->signed_additive_inverse(res_int,machine_type);
 			parse_tree tmp;
-			if (!VM_to_literal(tmp,res_int,src,types)) return false;
+			VM_to_literal(tmp,res_int,src,types);
 
 			if (negative_signed_int)
 				{	// convert to parsed - literal



From zaimoni at mail.berlios.de  Thu May  6 09:58:36 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 6 May 2010 09:58:36 +0200
Subject: [Zcplusplus-commits] r409 - in trunk: . Zaimoni.STL
Message-ID: <201005060758.o467waxu003567@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-06 09:58:28 +0200 (Thu, 06 May 2010)
New Revision: 409

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/ParseTree.cpp
   trunk/ParseTree.hpp
   trunk/Zaimoni.STL/AutoPtr.hpp
Log:
memory management turning; converge auto*_ptr classes towards STL

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-05 22:17:30 UTC (rev 408)
+++ trunk/CSupport.cpp	2010-05-06 07:58:28 UTC (rev 409)
@@ -5461,10 +5461,9 @@
 		enumerator_to_integer_representation(*src.c_array<2>(),types);
 		if (is_C99_unary_operator_expression<'-'>(*src.data<2>()))
 			{	// enumerator went negative: handle
-			parse_tree tmp = *src.c_array<2>();
-			src.c_array<2>()->clear();
-			src.destroy();
-			src = tmp;
+			parse_tree tmp;
+			src.c_array<2>()->OverwriteInto(tmp);
+			tmp.MoveInto(src);
 			return true;
 			}
 		}
@@ -5472,9 +5471,10 @@
  	// handle integer-like literals like a real integer literal
 	if (is_integerlike_literal(*src.data<2>() ARG_TYPES))
 		{
-		const type_spec old_type = src.type_code;
+		type_spec tmp;
+		src.type_code.OverwriteInto(tmp);
 		src.eval_to_arg<2>(0);
-		src.type_code = old_type;
+		tmp.MoveInto(src.type_code);
 		return true;
 		}
 	return false;
@@ -5488,9 +5488,10 @@
 	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true && (1==(src.type_code.base_type_index-C_TYPE::INT)%2 || virtual_machine::twos_complement==target_machine->C_signed_int_representation() || bool_options[boolopt::int_traps]))
 		{	// -0==0
 			// deal with unary - not being allowed to actually return -0 on these machines later
-		const type_spec old_type = src.type_code;
+		type_spec tmp;
+		src.type_code.OverwriteInto(tmp);
 		force_decimal_literal(src,"0",types);
-		src.type_code = old_type;		
+		tmp.MoveInto(src.type_code);
 		return true;
 		};
 #/*cut-cpp*/
@@ -5499,45 +5500,46 @@
 		enumerator_to_integer_representation(*src.c_array<2>(),types);
 		if (is_C99_unary_operator_expression<'-'>(*src.data<2>()))
 			{	// enumerator went negative: handle
-			parse_tree tmp = *src.c_array<2>()->c_array<2>();
-			src.c_array<2>()->c_array<2>()->clear();
-			src.destroy();
-			src = tmp;
+			parse_tree tmp;
+			src.c_array<2>()->OverwriteInto(tmp);
+			tmp.MoveInto(src);
 			return true;
 			}
-		src.type_code = src.data<2>()->type_code;
+		value_copy(src.type_code,src.data<2>()->type_code);
 		}
 #/*cut-cpp*/
 	if (is_integerlike_literal(*src.data<2>() ARG_TYPES) && 1==(src.type_code.base_type_index-C_TYPE::INT)%2)
 		{	// unsigned...we're fine
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
-		const type_spec old_type = src.type_code;
 		umaxint res_int;
 		intlike_literal_to_VM(res_int,*src.data<2>() ARG_TYPES);
 		target_machine->unsigned_additive_inverse(res_int,machine_type);
 
 		//! \todo flag failures to reduce as RAM-stalled
 		POD_pair<char*,lex_flags> new_token;
-		VM_to_token(res_int,old_type.base_type_index,new_token);
+		VM_to_token(res_int,src.type_code.base_type_index,new_token);
 		src.c_array<2>()->grab_index_token_from<0>(new_token.first,new_token.second);
+		type_spec tmp;
+		src.type_code.OverwriteInto(tmp);
 		src.eval_to_arg<2>(0);
-		src.type_code = old_type;
+		tmp.MoveInto(src.type_code);
 		return true;
 		};
 	if (converts_to_integerlike(src.data<2>()->type_code ARG_TYPES) && is_C99_unary_operator_expression<'-'>(*src.data<2>()))
 		{	// - - __ |-> __, trap-int machines fine as -0=0 for sign/magnitude and one's complement, and the offending literal for two's complement is an unsigned int
 		assert(converts_to_integerlike(src.data<2>()->data<2>()->type_code ARG_TYPES));
-		const type_spec old_type = src.type_code;
-		parse_tree tmp = *src.data<2>()->data<2>();
-		src.c_array<2>()->c_array<2>()->clear();
-		src.destroy();
-		src = tmp;
-		src.type_code = old_type;
+		parse_tree tmp;
+		src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
+		type_spec tmp2;
+		src.type_code.OverwriteInto(tmp2);
+		tmp.MoveInto(src);
+		tmp2.MoveInto(src.type_code);
 		return true;		
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static void C_unary_plusminus_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(C99_UNARY_SUBTYPE_NEG==src.subtype || C99_UNARY_SUBTYPE_PLUS==src.subtype);
@@ -5584,6 +5586,7 @@
 		}
 }
 
+//! \throw std::bad_alloc()
 static void CPP_unary_plusminus_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(C99_UNARY_SUBTYPE_NEG==src.subtype || C99_UNARY_SUBTYPE_PLUS==src.subtype);
@@ -5641,6 +5644,7 @@
 
 // no eval_deref because of &* cancellation
 // defer syntax check to after resolution of multiply-*, so no C/C++ fork
+//! \throw std::bad_alloc()
 static bool terse_locate_C99_deref(parse_tree& src, size_t& i,const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5664,6 +5668,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_CPP_deref(parse_tree& src, size_t& i,const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5691,8 +5696,7 @@
 {
 	assert(is_C99_unary_operator_expression<'*'>(src));
 	//! \todo: handle *& identity when we have &
-	//! \todo multidimensional array target
-	//! \todo cv-qualified pointer target
+	// multi-dimensional arrays and cv-qualified pointers should be automatically handled
 	value_copy(src.type_code,src.data<2>()->type_code);
 	// handle lvalueness in indirection type building and/or the dereference stage
 	if (!src.type_code.dereference())
@@ -5700,6 +5704,7 @@
 		simple_error(src," is not dereferencing a pointer (C99 6.5.3.2p2; C++98 5.3.1p1)");
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_C_logical_NOT(parse_tree& src, size_t& i,const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5723,6 +5728,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_CPP_logical_NOT(parse_tree& src, size_t& i,const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5767,10 +5773,9 @@
 		if (	is_logical_NOT(*src.data<2>()->data<2>())
 			||	(C_TYPE::BOOL==src.data<2>()->type_code.base_type_index && 0==src.data<2>()->type_code.pointer_power))
 			{
-			parse_tree tmp = *src.data<2>()->data<2>();
-			src.c_array<2>()->c_array<2>()->clear();
-			src.destroy();
-			src = tmp;
+			parse_tree tmp;
+			src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
+			tmp.MoveInto(src);
 			return true;
 			}
 		};
@@ -5862,6 +5867,7 @@
 	assert(is_C99_unary_operator_expression<'-'>(dest));
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_C99_bitwise_complement(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5885,6 +5891,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_CPP_bitwise_complement(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5908,21 +5915,18 @@
 	return false;
 }
 
-// This is called from the eval_ family of functions.  Use a return value
-// rather than throw std::bad_alloc because as we're hoping eval will 
-// eventually recover enough memory for this to complete.
-static bool construct_twos_complement_int_min(parse_tree& dest, const type_system& types, const virtual_machine::std_int_enum machine_type, const parse_tree& src_loc)
+//! \throw std::bad_alloc()
+static void construct_twos_complement_int_min(parse_tree& dest, const type_system& types, const virtual_machine::std_int_enum machine_type, const parse_tree& src_loc)
 {
 	umaxint tmp_int(target_machine->signed_max(machine_type));
-	parse_tree* const tmp = _new_buffer<parse_tree>(1);	// XXX we recycle this variable later
-	if (!tmp) return false;
+	parse_tree* const tmp = _new_buffer_nonNULL_throws<parse_tree>(1);	// XXX we recycle this variable later
 	try {
 		VM_to_literal(*tmp,tmp_int,src_loc,types);
 		}
 	catch(const std::bad_alloc&)
 		{
 		_flush(tmp);
-		return false;
+		throw;
 		}
 
 	tmp_int = 1;
@@ -5931,7 +5935,7 @@
 		{
 		tmp->destroy();
 		_flush(tmp);
-		return false;
+		throw std::bad_alloc();
 		}
 	try {
 		VM_to_literal(*tmp2,tmp_int,src_loc,types);
@@ -5942,7 +5946,7 @@
 		_flush(tmp2);
 		tmp->destroy();
 		_flush(tmp);
-		return false;
+		throw;
 		}
 
 	parse_tree* const tmp3 = _new_buffer<parse_tree>(1);
@@ -5952,7 +5956,7 @@
 		_flush(tmp2);
 		tmp->destroy();
 		_flush(tmp);
-		return false;
+		throw std::bad_alloc();
 		}
 	force_unary_negative_token(*tmp3,tmp,src_loc ARG_TYPES);
 
@@ -5968,10 +5972,9 @@
 	tmp4.subtype = C99_ADD_SUBTYPE_MINUS;
 	assert(is_C99_add_operator_expression<'-'>(tmp4));
 
-	dest.destroy();
-	dest = tmp4;
+	dest.type_code.MoveInto(tmp4.type_code);
+	tmp4.MoveInto(dest);
 	// do not handle type here: C++ operator overloading risk
-	return true;
 }
 
 //! \throw std::bad_alloc()
@@ -5983,14 +5986,13 @@
 	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
 		enumerator_to_integer_representation(*src.c_array<2>(),types);
-		src.type_code = src.data<2>()->type_code;
+		value_copy(src.type_code,src.data<2>()->type_code);
 		}
 #/*cut-cpp*/
 	umaxint res_int;
 	if (intlike_literal_to_VM(res_int,*src.data<2>() ARG_TYPES)) 
 		{
-		const type_spec old_type = src.type_code;
-		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(old_type.base_type_index);
+		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
 		res_int.auto_bitwise_complement();
 		res_int.mask_to(target_machine->C_bit(machine_type));
 
@@ -5998,12 +6000,19 @@
 
 		const bool negative_signed_int = 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && res_int.test(target_machine->C_bit(machine_type)-1);
 		if (negative_signed_int) target_machine->signed_additive_inverse(res_int,machine_type);
+		const type_spec old_type = src.type_code;
 		if (	virtual_machine::twos_complement==target_machine->C_signed_int_representation()
-			&& 	0==(old_type.base_type_index-C_TYPE::INT)%2
+			&& 	0==(src.type_code.base_type_index-C_TYPE::INT)%2
 			&& 	!bool_options[boolopt::int_traps]
 			&&	res_int>target_machine->signed_max(machine_type))
 			{	// trap representation; need to get it into -INT_MAX-1 form
-			if (!construct_twos_complement_int_min(src,types,machine_type,src)) return false;
+			try {
+				construct_twos_complement_int_min(src,types,machine_type,src);
+				}
+			catch(const std::bad_alloc&)
+				{
+				return false;
+				}
 			src.type_code = old_type;
 			return true;
 			}
@@ -6020,20 +6029,17 @@
 		if (negative_signed_int)
 			// convert to parsed - literal
 			force_unary_negative_literal(src,tmp);
-		else{	// convert to positive literal
-			src.destroy();
-			src = tmp;
-			}
+		else	// convert to positive literal
+			tmp.MoveInto(src);
 		src.type_code = old_type;
 		return true;
 		};
 	if (	is_bitwise_complement_expression(*src.data<2>())
 		&&	is_bitwise_complement_expression(*src.data<2>()->data<2>()))
 		{	// ~~~__ reduces to ~__ safely
-		parse_tree tmp = *src.data<2>()->data<2>();
-		src.c_array<2>()->c_array<2>()->clear();
-		src.destroy();
-		src = tmp;
+		parse_tree tmp;
+		src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
+		tmp.MoveInto(src);
 		return true;
 		}
 	return false;
@@ -8587,7 +8593,13 @@
 				&& 	!bool_options[boolopt::int_traps]
 				&&	res_int>target_machine->signed_max(old.machine_type))
 				{	// trap representation; need to get it into -INT_MAX-1 form
-				if (!construct_twos_complement_int_min(src,types,old.machine_type,src)) return false;
+				try {
+					construct_twos_complement_int_min(src,types,old.machine_type,src);
+					}
+				catch(const std::bad_alloc&)
+					{
+					return false;
+					}
 				src.type_code = old_type;
 				return true;
 				}
@@ -8768,7 +8780,13 @@
 			&& 	!bool_options[boolopt::int_traps]
 			&&	res_int>target_machine->signed_max(old.machine_type))
 			{	// trap representation; need to get it into -INT_MAX-1 form
-			if (!construct_twos_complement_int_min(src,types,old.machine_type,src)) return false;
+			try {
+				construct_twos_complement_int_min(src,types,old.machine_type,src);
+				}
+			catch(const std::bad_alloc&)
+				{
+				return false;
+				}
 			src.type_code = old_type;
 			return true;
 			}
@@ -8976,7 +8994,7 @@
 				force_unary_negative_literal(src,tmp);
 				}
 			else	// convert to positive literal
-				src = tmp;
+				tmp.MoveInto(src);
 			}
 		src.type_code = old_type;
 		return true;

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-05 22:17:30 UTC (rev 408)
+++ trunk/CSupport_pp.cpp	2010-05-06 07:58:28 UTC (rev 409)
@@ -1,4 +1,4 @@
-// CSupport_pp.cpp
+// CSupport.cpp
 // support for C/C++ parsing
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
@@ -4958,9 +4958,10 @@
  	// handle integer-like literals like a real integer literal
 	if (is_integerlike_literal(*src.data<2>() ARG_TYPES))
 		{
-		const type_spec old_type = src.type_code;
+		type_spec tmp;
+		src.type_code.OverwriteInto(tmp);
 		src.eval_to_arg<2>(0);
-		src.type_code = old_type;
+		tmp.MoveInto(src.type_code);
 		return true;
 		}
 	return false;
@@ -4974,41 +4975,44 @@
 	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true && (1==(src.type_code.base_type_index-C_TYPE::INT)%2 || virtual_machine::twos_complement==target_machine->C_signed_int_representation() || bool_options[boolopt::int_traps]))
 		{	// -0==0
 			// deal with unary - not being allowed to actually return -0 on these machines later
-		const type_spec old_type = src.type_code;
+		type_spec tmp;
+		src.type_code.OverwriteInto(tmp);
 		force_decimal_literal(src,"0",types);
-		src.type_code = old_type;		
+		tmp.MoveInto(src.type_code);
 		return true;
 		};
 	if (is_integerlike_literal(*src.data<2>() ARG_TYPES) && 1==(src.type_code.base_type_index-C_TYPE::INT)%2)
 		{	// unsigned...we're fine
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
-		const type_spec old_type = src.type_code;
 		umaxint res_int;
 		intlike_literal_to_VM(res_int,*src.data<2>() ARG_TYPES);
 		target_machine->unsigned_additive_inverse(res_int,machine_type);
 
 		//! \todo flag failures to reduce as RAM-stalled
 		POD_pair<char*,lex_flags> new_token;
-		VM_to_token(res_int,old_type.base_type_index,new_token);
+		VM_to_token(res_int,src.type_code.base_type_index,new_token);
 		src.c_array<2>()->grab_index_token_from<0>(new_token.first,new_token.second);
+		type_spec tmp;
+		src.type_code.OverwriteInto(tmp);
 		src.eval_to_arg<2>(0);
-		src.type_code = old_type;
+		tmp.MoveInto(src.type_code);
 		return true;
 		};
 	if (converts_to_integerlike(src.data<2>()->type_code ARG_TYPES) && is_C99_unary_operator_expression<'-'>(*src.data<2>()))
 		{	// - - __ |-> __, trap-int machines fine as -0=0 for sign/magnitude and one's complement, and the offending literal for two's complement is an unsigned int
 		assert(converts_to_integerlike(src.data<2>()->data<2>()->type_code ARG_TYPES));
-		const type_spec old_type = src.type_code;
-		parse_tree tmp = *src.data<2>()->data<2>();
-		src.c_array<2>()->c_array<2>()->clear();
-		src.destroy();
-		src = tmp;
-		src.type_code = old_type;
+		parse_tree tmp;
+		src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
+		type_spec tmp2;
+		src.type_code.OverwriteInto(tmp2);
+		tmp.MoveInto(src);
+		tmp2.MoveInto(src.type_code);
 		return true;		
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static void C_unary_plusminus_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(C99_UNARY_SUBTYPE_NEG==src.subtype || C99_UNARY_SUBTYPE_PLUS==src.subtype);
@@ -5045,6 +5049,7 @@
 		}
 }
 
+//! \throw std::bad_alloc()
 static void CPP_unary_plusminus_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(C99_UNARY_SUBTYPE_NEG==src.subtype || C99_UNARY_SUBTYPE_PLUS==src.subtype);
@@ -5092,6 +5097,7 @@
 
 // no eval_deref because of &* cancellation
 // defer syntax check to after resolution of multiply-*, so no C/C++ fork
+//! \throw std::bad_alloc()
 static bool terse_locate_C99_deref(parse_tree& src, size_t& i,const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5115,6 +5121,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_CPP_deref(parse_tree& src, size_t& i,const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5142,8 +5149,7 @@
 {
 	assert(is_C99_unary_operator_expression<'*'>(src));
 	//! \todo: handle *& identity when we have &
-	//! \todo multidimensional array target
-	//! \todo cv-qualified pointer target
+	// multi-dimensional arrays and cv-qualified pointers should be automatically handled
 	value_copy(src.type_code,src.data<2>()->type_code);
 	// handle lvalueness in indirection type building and/or the dereference stage
 	if (!src.type_code.dereference())
@@ -5151,6 +5157,7 @@
 		simple_error(src," is not dereferencing a pointer (C99 6.5.3.2p2; C++98 5.3.1p1)");
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_C_logical_NOT(parse_tree& src, size_t& i,const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5174,6 +5181,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_CPP_logical_NOT(parse_tree& src, size_t& i,const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5218,10 +5226,9 @@
 		if (	is_logical_NOT(*src.data<2>()->data<2>())
 			||	(C_TYPE::BOOL==src.data<2>()->type_code.base_type_index && 0==src.data<2>()->type_code.pointer_power))
 			{
-			parse_tree tmp = *src.data<2>()->data<2>();
-			src.c_array<2>()->c_array<2>()->clear();
-			src.destroy();
-			src = tmp;
+			parse_tree tmp;
+			src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
+			tmp.MoveInto(src);
 			return true;
 			}
 		};
@@ -5313,6 +5320,7 @@
 	assert(is_C99_unary_operator_expression<'-'>(dest));
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_C99_bitwise_complement(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5336,6 +5344,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_CPP_bitwise_complement(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5359,21 +5368,18 @@
 	return false;
 }
 
-// This is called from the eval_ family of functions.  Use a return value
-// rather than throw std::bad_alloc because as we're hoping eval will 
-// eventually recover enough memory for this to complete.
-static bool construct_twos_complement_int_min(parse_tree& dest, const type_system& types, const virtual_machine::std_int_enum machine_type, const parse_tree& src_loc)
+//! \throw std::bad_alloc()
+static void construct_twos_complement_int_min(parse_tree& dest, const type_system& types, const virtual_machine::std_int_enum machine_type, const parse_tree& src_loc)
 {
 	umaxint tmp_int(target_machine->signed_max(machine_type));
-	parse_tree* const tmp = _new_buffer<parse_tree>(1);	// XXX we recycle this variable later
-	if (!tmp) return false;
+	parse_tree* const tmp = _new_buffer_nonNULL_throws<parse_tree>(1);	// XXX we recycle this variable later
 	try {
 		VM_to_literal(*tmp,tmp_int,src_loc,types);
 		}
 	catch(const std::bad_alloc&)
 		{
 		_flush(tmp);
-		return false;
+		throw;
 		}
 
 	tmp_int = 1;
@@ -5382,7 +5388,7 @@
 		{
 		tmp->destroy();
 		_flush(tmp);
-		return false;
+		throw std::bad_alloc();
 		}
 	try {
 		VM_to_literal(*tmp2,tmp_int,src_loc,types);
@@ -5393,7 +5399,7 @@
 		_flush(tmp2);
 		tmp->destroy();
 		_flush(tmp);
-		return false;
+		throw;
 		}
 
 	parse_tree* const tmp3 = _new_buffer<parse_tree>(1);
@@ -5403,7 +5409,7 @@
 		_flush(tmp2);
 		tmp->destroy();
 		_flush(tmp);
-		return false;
+		throw std::bad_alloc();
 		}
 	force_unary_negative_token(*tmp3,tmp,src_loc ARG_TYPES);
 
@@ -5419,10 +5425,9 @@
 	tmp4.subtype = C99_ADD_SUBTYPE_MINUS;
 	assert(is_C99_add_operator_expression<'-'>(tmp4));
 
-	dest.destroy();
-	dest = tmp4;
+	dest.type_code.MoveInto(tmp4.type_code);
+	tmp4.MoveInto(dest);
 	// do not handle type here: C++ operator overloading risk
-	return true;
 }
 
 //! \throw std::bad_alloc()
@@ -5433,8 +5438,7 @@
 	umaxint res_int;
 	if (intlike_literal_to_VM(res_int,*src.data<2>() ARG_TYPES)) 
 		{
-		const type_spec old_type = src.type_code;
-		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(old_type.base_type_index);
+		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
 		res_int.auto_bitwise_complement();
 		res_int.mask_to(target_machine->C_bit(machine_type));
 
@@ -5442,12 +5446,19 @@
 
 		const bool negative_signed_int = 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && res_int.test(target_machine->C_bit(machine_type)-1);
 		if (negative_signed_int) target_machine->signed_additive_inverse(res_int,machine_type);
+		const type_spec old_type = src.type_code;
 		if (	virtual_machine::twos_complement==target_machine->C_signed_int_representation()
-			&& 	0==(old_type.base_type_index-C_TYPE::INT)%2
+			&& 	0==(src.type_code.base_type_index-C_TYPE::INT)%2
 			&& 	!bool_options[boolopt::int_traps]
 			&&	res_int>target_machine->signed_max(machine_type))
 			{	// trap representation; need to get it into -INT_MAX-1 form
-			if (!construct_twos_complement_int_min(src,types,machine_type,src)) return false;
+			try {
+				construct_twos_complement_int_min(src,types,machine_type,src);
+				}
+			catch(const std::bad_alloc&)
+				{
+				return false;
+				}
 			src.type_code = old_type;
 			return true;
 			}
@@ -5464,20 +5475,17 @@
 		if (negative_signed_int)
 			// convert to parsed - literal
 			force_unary_negative_literal(src,tmp);
-		else{	// convert to positive literal
-			src.destroy();
-			src = tmp;
-			}
+		else	// convert to positive literal
+			tmp.MoveInto(src);
 		src.type_code = old_type;
 		return true;
 		};
 	if (	is_bitwise_complement_expression(*src.data<2>())
 		&&	is_bitwise_complement_expression(*src.data<2>()->data<2>()))
 		{	// ~~~__ reduces to ~__ safely
-		parse_tree tmp = *src.data<2>()->data<2>();
-		src.c_array<2>()->c_array<2>()->clear();
-		src.destroy();
-		src = tmp;
+		parse_tree tmp;
+		src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
+		tmp.MoveInto(src);
 		return true;
 		}
 	return false;
@@ -7718,7 +7726,13 @@
 				&& 	!bool_options[boolopt::int_traps]
 				&&	res_int>target_machine->signed_max(old.machine_type))
 				{	// trap representation; need to get it into -INT_MAX-1 form
-				if (!construct_twos_complement_int_min(src,types,old.machine_type,src)) return false;
+				try {
+					construct_twos_complement_int_min(src,types,old.machine_type,src);
+					}
+				catch(const std::bad_alloc&)
+					{
+					return false;
+					}
 				src.type_code = old_type;
 				return true;
 				}
@@ -7889,7 +7903,13 @@
 			&& 	!bool_options[boolopt::int_traps]
 			&&	res_int>target_machine->signed_max(old.machine_type))
 			{	// trap representation; need to get it into -INT_MAX-1 form
-			if (!construct_twos_complement_int_min(src,types,old.machine_type,src)) return false;
+			try {
+				construct_twos_complement_int_min(src,types,old.machine_type,src);
+				}
+			catch(const std::bad_alloc&)
+				{
+				return false;
+				}
 			src.type_code = old_type;
 			return true;
 			}
@@ -8069,7 +8089,7 @@
 				force_unary_negative_literal(src,tmp);
 				}
 			else	// convert to positive literal
-				src = tmp;
+				tmp.MoveInto(src);
 			}
 		src.type_code = old_type;
 		return true;

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2010-05-05 22:17:30 UTC (rev 408)
+++ trunk/ParseTree.cpp	2010-05-06 07:58:28 UTC (rev 409)
@@ -408,11 +408,7 @@
 void parse_tree::MoveInto(parse_tree& dest)
 {
 	dest.destroy();
-	memmove(dest.index_tokens,index_tokens,2*sizeof(*index_tokens));
-	memmove(dest.args,args,3*sizeof(*args));
-	dest.flags = flags;
-	dest.subtype = subtype;
-	dest.type_code = type_code;
+	dest = *this;
 	clear();
 #ifdef IRRATIONAL_CAUTION
 	assert(dest.syntax_ok());
@@ -420,6 +416,11 @@
 #endif
 }
 
+void parse_tree::OverwriteInto(parse_tree& dest)
+{
+	dest = *this;
+	clear();
+}
 
 void parse_tree::_eval_to_arg(size_t arg_idx, size_t i)
 {

Modified: trunk/ParseTree.hpp
===================================================================
--- trunk/ParseTree.hpp	2010-05-05 22:17:30 UTC (rev 408)
+++ trunk/ParseTree.hpp	2010-05-06 07:58:28 UTC (rev 409)
@@ -50,6 +50,7 @@
     type_spec type_code;
 
 	void MoveInto(parse_tree& dest);
+	void OverwriteInto(parse_tree& dest);
 
 #ifdef ZAIMONI_FORCE_ISO
 #define	ZCC_PARSETREE_CARRAY(I) args[I].first

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2010-05-05 22:17:30 UTC (rev 408)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2010-05-06 07:58:28 UTC (rev 409)
@@ -39,7 +39,7 @@
 	void MoveInto(_meta_auto_ptr<T>& dest) {dest.reset(_ptr);};
 
 	template<typename U> void TransferOutAndNULL(U*& Target) {_single_flush(Target); Target = _ptr; _ptr = NULL;}
-	template<typename U> void OverwriteAndNULL(U*& Target) {Target = _ptr; _ptr = NULL;}
+	T* release() {T* tmp = _ptr; _ptr = NULL; return tmp;};
 	bool empty() const {return NULL==_ptr;};
 	void NULLPtr() {_ptr = NULL;};
 
@@ -104,7 +104,6 @@
 	friend bool operator==<>(const c_var_array_CRTP& lhs, const c_var_array_CRTP& rhs);
 
 	// other support
-	void OverwriteAndNULL(T*& Target) {Target = static_cast<Derived*>(this)->_ptr; static_cast<Derived*>(this)->_ptr = NULL;}
 #ifndef ZAIMONI_FORCE_ISO
 	void NULLPtr() {static_cast<Derived*>(this)->_ptr = NULL;};
 	size_t ArraySize() const {return zaimoni::ArraySize(static_cast<const Derived*>(this)->_ptr);};
@@ -140,7 +139,12 @@
 	void rangecheck(size_t i) const { if (i>=size()) FATAL("out-of-bounds array access"); };
 
 	void swap(c_var_array_CRTP& RHS) {std::swap(static_cast<Derived*>(this)->_ptr,static_cast<Derived&>(RHS)._ptr);};
-
+#ifndef ZAIMONI_FORCE_ISO
+	T* release() {T* tmp = static_cast<Derived*>(this)->_ptr; static_cast<Derived*>(this)->_ptr = NULL; return tmp;};
+#else
+	T* release() {T* tmp = static_cast<Derived*>(this)->_ptr; static_cast<Derived*>(this)->_ptr = NULL; static_cast<Derived*>(this)->_size = 0; return tmp;};
+#endif
+	
 	// Perl grep
 	template<typename U> void destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
 	template<typename U> void destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));



From zaimoni at mail.berlios.de  Fri May  7 01:29:17 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 7 May 2010 01:29:17 +0200
Subject: [Zcplusplus-commits] r410 - trunk
Message-ID: <201005062329.o46NTHgw002490@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-07 01:29:12 +0200 (Fri, 07 May 2010)
New Revision: 410

Modified:
   trunk/type_spec.cpp
   trunk/type_spec.hpp
   trunk/uchar_blob.cpp
   trunk/uchar_blob.hpp
Log:
update documentation of exceptions thrown; enhance robustness of type_spec's value_copy

Modified: trunk/type_spec.cpp
===================================================================
--- trunk/type_spec.cpp	2010-05-06 07:58:28 UTC (rev 409)
+++ trunk/type_spec.cpp	2010-05-06 23:29:12 UTC (rev 410)
@@ -6,6 +6,7 @@
 #include "Zaimoni.STL/MetaRAM2.hpp"
 using namespace zaimoni;
 
+//! \throw std::bad_alloc only if _size>pointer_power
 void type_spec::set_pointer_power(size_t _size)
 {
 #ifndef ZAIMONI_FORCE_ISO
@@ -42,6 +43,7 @@
 #endif
 }
 
+//! \throw std::bad_alloc
 void type_spec::make_C_array(uintmax_t _size)
 {	// can't count on type_spec being initialized correctly beforehand
 	// (could be 0 coming in, but then pointer_power=0 as well coming in)
@@ -59,21 +61,32 @@
 
 
 // XXX properly operator= in C++, but type_spec has to be POD
-// ACID, throws std::bad_alloc on failure
+// ACID
+//! \throw std::bad_alloc only if dest.pointer_power<src.pointer_power 
 void value_copy(type_spec& dest,const type_spec& src)
 {	// again, can't count on src.syntax_ok()
 #ifndef ZAIMONI_FORCE_ISO
 	assert(src.syntax_ok());
 #endif
-	type_spec tmp;
-	tmp.clear();
-	tmp.set_type(src.base_type_index);
-	tmp.set_pointer_power(src.pointer_power);
-	if (tmp.q_vector.size()==src.q_vector.size())
-		value_copy(tmp.q_vector,src.q_vector);
-	if (0<src.pointer_power) memmove(tmp.extent_vector,src.extent_vector,src.pointer_power*sizeof(uintmax_t));
-	dest.destroy();
-	dest = tmp;
+	if (dest.pointer_power<src.pointer_power)
+		{	// set_pointer_power can throw anyway, so be ACID
+		type_spec tmp;
+		tmp.clear();
+		tmp.set_type(src.base_type_index);
+		tmp.set_pointer_power(src.pointer_power);
+		if (tmp.q_vector.size()==src.q_vector.size())
+			value_copy(tmp.q_vector,src.q_vector);
+		if (0<src.pointer_power) memmove(tmp.extent_vector,src.extent_vector,src.pointer_power*sizeof(uintmax_t));
+		dest.destroy();
+		dest = tmp;
+		}
+	else{	// non-enlarging doesn't throw
+		dest.base_type_index = src.base_type_index;
+		dest.set_pointer_power(src.pointer_power);
+		if (dest.q_vector.size()==src.q_vector.size())
+			value_copy(dest.q_vector,src.q_vector);
+		if (0<src.pointer_power) memmove(dest.extent_vector,src.extent_vector,src.pointer_power*sizeof(uintmax_t));
+		}
 #ifndef ZAIMONI_FORCE_ISO
 	assert(dest.syntax_ok());
 #endif
@@ -106,7 +119,7 @@
 {
 	base_type_index = 0;
 	pointer_power = 0;
-	q_vector.init(0);
+	q_vector.init(1);
 	extent_vector = NULL;
 }
 
@@ -116,7 +129,8 @@
 	assert(syntax_ok());
 #endif
 	FREE_AND_NULL(extent_vector);
-	q_vector.resize(0);
+	q_vector.resize(1);
+	q_vector.front() = '\0';
 	base_type_index = 0;
 	pointer_power = 0;
 }
@@ -128,6 +142,7 @@
 #endif
 	FREE_AND_NULL(extent_vector);
 	q_vector.resize(1);
+	q_vector.front() = '\0';
 	base_type_index = _base_type_index;
 	pointer_power = 0;
 }

Modified: trunk/type_spec.hpp
===================================================================
--- trunk/type_spec.hpp	2010-05-06 07:58:28 UTC (rev 409)
+++ trunk/type_spec.hpp	2010-05-06 23:29:12 UTC (rev 410)
@@ -12,7 +12,7 @@
 
 struct type_spec;
 
-// ACID; throws std::bad_alloc on failure
+//! ACID; may be replaced by operator= when 0==dest.pointer_power and 0==src.pointer_power
 void value_copy(type_spec& dest, const type_spec& src);
 
 namespace boost {
@@ -44,8 +44,9 @@
 
 	bool decays_to_nonnull_pointer() const {return 0<pointer_power && (q_vector.back() & _array);};
 
-	void set_pointer_power(size_t _size);	// ACID, throws std::bad_alloc on failure
+	void set_pointer_power(size_t _size);
 	void make_C_pointer() {set_pointer_power(pointer_power+1);};
+	//! \throw std::bad_alloc
 	void make_C_array(uintmax_t _size);
 	bool dereference();
 	unsigned char& qualifier(size_t i) {return q_vector.c_array()[i];};
@@ -57,6 +58,7 @@
 	bool operator==(const type_spec& rhs) const;
 	bool operator!=(const type_spec& rhs) const {return !(*this==rhs);};
 
+	//! \throw std::bad_alloc only if dest.pointer_power<src.pointer_power 
 	static void value_copy(type_spec& dest, const type_spec& src) {::value_copy(dest,src);};
 	void MoveInto(type_spec& dest);
 	void OverwriteInto(type_spec& dest);

Modified: trunk/uchar_blob.cpp
===================================================================
--- trunk/uchar_blob.cpp	2010-05-06 07:58:28 UTC (rev 409)
+++ trunk/uchar_blob.cpp	2010-05-06 23:29:12 UTC (rev 410)
@@ -4,21 +4,23 @@
 #include "uchar_blob.hpp"
 #include "Zaimoni.STL/MetaRAM.hpp"
 
+//! \throw std::bad_alloc only if sizeof(unsigned char*)<new_size 
 void uchar_blob::init(size_t new_size)
 {
-	if (sizeof(unsigned char*)>new_size)
+	if (sizeof(unsigned char*)>=new_size)
 		memset(_x.first,0,sizeof(sizeof(unsigned char*)));
 	else
 		_x.second = zaimoni::_new_buffer_nonNULL_throws<unsigned char>(new_size);
 	_size = new_size;
 }
 
+//! \throw std::bad_alloc only if sizeof(unsigned char*)<new_size and _size<new_size 
 void uchar_blob::resize(size_t new_size)
 {
 	if (_size==new_size) return;
-	if (sizeof(unsigned char*)>_size)
+	if (sizeof(unsigned char*)>=_size)
 		{
-		if (sizeof(unsigned char*)>new_size)
+		if (sizeof(unsigned char*)>=new_size)
 			{
 			const size_t min_N = _size<new_size ? _size : new_size;
 			memset(_x.first+min_N,0,(sizeof(unsigned char*)-min_N));
@@ -34,7 +36,7 @@
 			}
 		}
 	else{
-		if (sizeof(unsigned char*)>new_size)
+		if (sizeof(unsigned char*)>=new_size)
 			{
 			unsigned char tmp[sizeof(unsigned char*)];
 			memset(tmp,0,sizeof(unsigned char*));
@@ -55,6 +57,7 @@
 		}
 }
 
+//! \throw std::bad_alloc only if sizeof(unsigned char*)<src.size() and _size<src.size() 
 void value_copy(uchar_blob& dest,const uchar_blob& src)
 {
 	const size_t src_size = src.size();

Modified: trunk/uchar_blob.hpp
===================================================================
--- trunk/uchar_blob.hpp	2010-05-06 07:58:28 UTC (rev 409)
+++ trunk/uchar_blob.hpp	2010-05-06 23:29:12 UTC (rev 410)
@@ -43,6 +43,7 @@
 
 	void resize(size_t new_size);
 	void init(size_t new_size);
+	//! \throw std::bad_alloc only if sizeof(unsigned char*)<src.size() and dest.size()<src.size() 
 	static void value_copy(uchar_blob& dest,const uchar_blob& src) {::value_copy(dest,src);};
 };
 



From zaimoni at mail.berlios.de  Fri May  7 05:37:50 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 7 May 2010 05:37:50 +0200
Subject: [Zcplusplus-commits] r411 - trunk
Message-ID: <201005070337.o473boPq019173@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-07 05:37:43 +0200 (Fri, 07 May 2010)
New Revision: 411

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/type_spec.cpp
   trunk/type_spec.hpp
Log:
code cleanup, some robustness enhancements

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-06 23:29:12 UTC (rev 410)
+++ trunk/CSupport.cpp	2010-05-07 03:37:43 UTC (rev 411)
@@ -4777,6 +4777,7 @@
 	//! \todo --do-what-i-mean should try to identify floats that are really integers
 }
 
+//! \throw std::bad_alloc()
 static zaimoni::Loki::CheckReturnDisallow<NULL,parse_tree*>::value_type repurpose_inner_parentheses(parse_tree& src)
 {
 	if (1==src.size<0>() && is_naked_parentheses_pair(*src.data<0>()))
@@ -4824,6 +4825,7 @@
  * \param err_count running error count
  * 
  * \return true iff ( ... ) expression was recognized
+ * \throw std::bad_alloc only if 1==src.size<0>() and src.type_code.pointer_power<src.data<0>()->type_code.pointer_power
  */
 static bool inspect_potential_paren_primary_expression(parse_tree& src)
 {
@@ -4908,14 +4910,15 @@
 	return false;
 }
 
+// \throw std::bad_alloc only if src.data<0>()[i-1].type_code.pointer_power<src.data<0>()[i-1].data<0>()->type_code.pointer_power
 static bool terse_locate_array_deref(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
 	assert(i<src.size<0>());
 	assert(src.data<0>()[i].empty<1>());
 	assert(src.data<0>()[i].empty<2>());
-	assert(NULL!=src.data<0>()[i].index_tokens[0].token.first);
-	assert(NULL!=src.data<0>()[i].index_tokens[1].token.first);
+	assert(src.data<0>()[i].index_tokens[0].token.first);
+	assert(src.data<0>()[i].index_tokens[1].token.first);
 
 	if (	!token_is_char<'['>(src.data<0>()[i].index_tokens[0].token)
 		|| 	!token_is_char<']'>(src.data<0>()[i].index_tokens[1].token))
@@ -4929,12 +4932,11 @@
 		if (PARSE_POSTFIX_EXPRESSION & src.data<0>()[i-1].flags)
 			{
 			parse_tree* const tmp = repurpose_inner_parentheses(src.c_array<0>()[i]);	// RAM conservation
-			*tmp = src.data<0>()[i-1];
+			src.c_array<0>()[i-1].OverwriteInto(*tmp);
 			src.c_array<0>()[i].fast_set_arg<1>(tmp);
 			src.c_array<0>()[i].core_flag_update();
 			src.c_array<0>()[i].flags |= PARSE_STRICT_POSTFIX_EXPRESSION;
-			src.c_array<0>()[--i].clear();
-			src.DeleteIdx<0>(i);
+			src.DeleteIdx<0>(--i);
 			assert(is_array_deref_strict(src.data<0>()[i]));
 			cancel_outermost_parentheses(src.c_array<0>()[i].c_array<1>()[0]);
 			cancel_outermost_parentheses(src.c_array<0>()[i].c_array<0>()[0]);
@@ -4981,6 +4983,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static void C_array_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	if (parse_tree::INVALID & src.flags) return;	// cannot optimize to valid
@@ -5059,7 +5062,6 @@
 	( type-name ) { initializer-list }
 	( type-name ) { initializer-list , }
 */
-/* returns error count */
 static void locate_C99_postfix_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5281,12 +5283,11 @@
 {
 	assert(1<src.size<0>()-i);
 	parse_tree* const tmp = repurpose_inner_parentheses(src.c_array<0>()[i+1]);	// RAM conservation
-	*tmp = src.data<0>()[i+1];
+	src.c_array<0>()[i+1].OverwriteInto(*tmp);
 	src.c_array<0>()[i].fast_set_arg<2>(tmp);
 	src.c_array<0>()[i].core_flag_update();
 	src.c_array<0>()[i].flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	src.c_array<0>()[i].subtype = _subtype;
-	src.c_array<0>()[i+1].clear();
 	src.DeleteIdx<0>(i+1);
 	cancel_outermost_parentheses(src.c_array<0>()[i].c_array<2>()[0]);
 }
@@ -5353,15 +5354,15 @@
 	assert(0==dest.size<0>());
 	assert(0==dest.size<1>());
 	assert(1==dest.size<2>());
-	assert(NULL==dest.index_tokens[1].token.first);
+	assert(!dest.index_tokens[1].token.first);
 	dest.grab_index_token_from_str_literal<0>("+",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
 	*dest.c_array<2>() = src;
 	dest.core_flag_update();
 	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	dest.subtype = C99_UNARY_SUBTYPE_PLUS;
 	if (converts_to_arithmeticlike(dest.data<2>()->type_code ARG_TYPES))
-		dest.type_code = dest.data<2>()->type_code;	//! \bug doesn't work for enumerators
-	assert(NULL!=dest.index_tokens[0].src_filename);
+		value_copy(dest.type_code,dest.data<2>()->type_code);	//! \bug doesn't work for enumerators
+	assert(dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'+'>(dest));
 }
 
@@ -5379,7 +5380,7 @@
 	if (converts_to_arithmeticlike(dest.data<2>()->type_code ARG_TYPES))
 		dest.type_code = dest.data<2>()->type_code;	//! \bug doesn't work for enumerators
 	// do not handle type here: C++ operator overloading risk
-	assert(NULL!=dest.index_tokens[0].src_filename);
+	assert(dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'-'>(dest));
 }
 

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-06 23:29:12 UTC (rev 410)
+++ trunk/CSupport_pp.cpp	2010-05-07 03:37:43 UTC (rev 411)
@@ -1,4 +1,4 @@
-// CSupport.cpp
+// CSupport_pp.cpp
 // support for C/C++ parsing
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
@@ -4326,6 +4326,7 @@
 	//! \todo --do-what-i-mean should try to identify floats that are really integers
 }
 
+//! \throw std::bad_alloc()
 static zaimoni::Loki::CheckReturnDisallow<NULL,parse_tree*>::value_type repurpose_inner_parentheses(parse_tree& src)
 {
 	if (1==src.size<0>() && is_naked_parentheses_pair(*src.data<0>()))
@@ -4373,6 +4374,7 @@
  * \param err_count running error count
  * 
  * \return true iff ( ... ) expression was recognized
+ * \throw std::bad_alloc only if 1==src.size<0>() and src.type_code.pointer_power<src.data<0>()->type_code.pointer_power
  */
 static bool inspect_potential_paren_primary_expression(parse_tree& src)
 {
@@ -4448,14 +4450,15 @@
 	return false;
 }
 
+// \throw std::bad_alloc only if src.data<0>()[i-1].type_code.pointer_power<src.data<0>()[i-1].data<0>()->type_code.pointer_power
 static bool terse_locate_array_deref(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
 	assert(i<src.size<0>());
 	assert(src.data<0>()[i].empty<1>());
 	assert(src.data<0>()[i].empty<2>());
-	assert(NULL!=src.data<0>()[i].index_tokens[0].token.first);
-	assert(NULL!=src.data<0>()[i].index_tokens[1].token.first);
+	assert(src.data<0>()[i].index_tokens[0].token.first);
+	assert(src.data<0>()[i].index_tokens[1].token.first);
 
 	if (	!token_is_char<'['>(src.data<0>()[i].index_tokens[0].token)
 		|| 	!token_is_char<']'>(src.data<0>()[i].index_tokens[1].token))
@@ -4469,12 +4472,11 @@
 		if (PARSE_POSTFIX_EXPRESSION & src.data<0>()[i-1].flags)
 			{
 			parse_tree* const tmp = repurpose_inner_parentheses(src.c_array<0>()[i]);	// RAM conservation
-			*tmp = src.data<0>()[i-1];
+			src.c_array<0>()[i-1].OverwriteInto(*tmp);
 			src.c_array<0>()[i].fast_set_arg<1>(tmp);
 			src.c_array<0>()[i].core_flag_update();
 			src.c_array<0>()[i].flags |= PARSE_STRICT_POSTFIX_EXPRESSION;
-			src.c_array<0>()[--i].clear();
-			src.DeleteIdx<0>(i);
+			src.DeleteIdx<0>(--i);
 			assert(is_array_deref_strict(src.data<0>()[i]));
 			cancel_outermost_parentheses(src.c_array<0>()[i].c_array<1>()[0]);
 			cancel_outermost_parentheses(src.c_array<0>()[i].c_array<0>()[0]);
@@ -4521,6 +4523,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static void C_array_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	if (parse_tree::INVALID & src.flags) return;	// cannot optimize to valid
@@ -4599,7 +4602,6 @@
 	( type-name ) { initializer-list }
 	( type-name ) { initializer-list , }
 */
-/* returns error count */
 static void locate_C99_postfix_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -4811,12 +4813,11 @@
 {
 	assert(1<src.size<0>()-i);
 	parse_tree* const tmp = repurpose_inner_parentheses(src.c_array<0>()[i+1]);	// RAM conservation
-	*tmp = src.data<0>()[i+1];
+	src.c_array<0>()[i+1].OverwriteInto(*tmp);
 	src.c_array<0>()[i].fast_set_arg<2>(tmp);
 	src.c_array<0>()[i].core_flag_update();
 	src.c_array<0>()[i].flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	src.c_array<0>()[i].subtype = _subtype;
-	src.c_array<0>()[i+1].clear();
 	src.DeleteIdx<0>(i+1);
 	cancel_outermost_parentheses(src.c_array<0>()[i].c_array<2>()[0]);
 }
@@ -4883,15 +4884,15 @@
 	assert(0==dest.size<0>());
 	assert(0==dest.size<1>());
 	assert(1==dest.size<2>());
-	assert(NULL==dest.index_tokens[1].token.first);
+	assert(!dest.index_tokens[1].token.first);
 	dest.grab_index_token_from_str_literal<0>("+",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
 	*dest.c_array<2>() = src;
 	dest.core_flag_update();
 	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	dest.subtype = C99_UNARY_SUBTYPE_PLUS;
 	if (converts_to_arithmeticlike(dest.data<2>()->type_code ARG_TYPES))
-		dest.type_code = dest.data<2>()->type_code;	//! \bug doesn't work for enumerators
-	assert(NULL!=dest.index_tokens[0].src_filename);
+		value_copy(dest.type_code,dest.data<2>()->type_code);	//! \bug doesn't work for enumerators
+	assert(dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'+'>(dest));
 }
 
@@ -4909,7 +4910,7 @@
 	if (converts_to_arithmeticlike(dest.data<2>()->type_code ARG_TYPES))
 		dest.type_code = dest.data<2>()->type_code;	//! \bug doesn't work for enumerators
 	// do not handle type here: C++ operator overloading risk
-	assert(NULL!=dest.index_tokens[0].src_filename);
+	assert(dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'-'>(dest));
 }
 

Modified: trunk/type_spec.cpp
===================================================================
--- trunk/type_spec.cpp	2010-05-06 23:29:12 UTC (rev 410)
+++ trunk/type_spec.cpp	2010-05-07 03:37:43 UTC (rev 411)
@@ -115,6 +115,23 @@
 	return true;
 }
 
+bool type_spec::dereference(type_spec& dest) const
+{
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
+	if (0==pointer_power) return false;
+	assert(lvalue & q_vector.data()[pointer_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
+	dest.base_type_index = base_type_index; 
+	dest.set_pointer_power(pointer_power-1); // lost a level of indirection
+	memmove(dest.q_vector.c_array(),q_vector.data(),dest.q_vector.size());
+	if (0<dest.pointer_power) memmove(dest.extent_vector,extent_vector,dest.pointer_power*sizeof(*extent_vector));
+#ifndef ZAIMONI_FORCE_ISO
+	assert(syntax_ok());
+#endif
+	return true;
+}
+
 void type_spec::clear()
 {
 	base_type_index = 0;

Modified: trunk/type_spec.hpp
===================================================================
--- trunk/type_spec.hpp	2010-05-06 23:29:12 UTC (rev 410)
+++ trunk/type_spec.hpp	2010-05-07 03:37:43 UTC (rev 411)
@@ -49,6 +49,7 @@
 	//! \throw std::bad_alloc
 	void make_C_array(uintmax_t _size);
 	bool dereference();
+	bool dereference(type_spec& dest) const;
 	unsigned char& qualifier(size_t i) {return q_vector.c_array()[i];};
 	template<size_t i> unsigned char& qualifier() {return q_vector.c_array()[i];}
 



From zaimoni at mail.berlios.de  Fri May  7 05:39:27 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 7 May 2010 05:39:27 +0200
Subject: [Zcplusplus-commits] r412 - trunk
Message-ID: <201005070339.o473dRpW019248@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-07 05:39:23 +0200 (Fri, 07 May 2010)
New Revision: 412

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
more code cleanup, documentation fixes, robustness tweaking

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-07 03:37:43 UTC (rev 411)
+++ trunk/CSupport.cpp	2010-05-07 03:39:23 UTC (rev 412)
@@ -4850,18 +4850,18 @@
 				}
 			else if (PARSE_EXPRESSION & src.data<0>()->flags)
 				{	// normal expression that got parenthesized
+				value_copy(src.type_code,src.data<0>()->type_code);
 				src.flags &= parse_tree::RESERVED_MASK;	// just in case
 				src.flags |= PARSE_PRIMARY_EXPRESSION;
 				src.flags |= (PARSE_PAREN_PRIMARY_PASSTHROUGH & src.data<0>()->flags);
-				value_copy(src.type_code,src.data<0>()->type_code);
 				return true;
 				}
 #/*cut-cpp*/
 			else if (PARSE_TYPE & src.data<0>()->flags)
 				{	// abuse: handle parenthesized type-specifiers here
+				value_copy(src.type_code,src.data<0>()->type_code);
 				src.flags &= parse_tree::RESERVED_MASK;	// just in case
 				src.flags |= (PARSE_TYPE & src.data<0>()->flags);
-				value_copy(src.type_code,src.data<0>()->type_code);
 				return false;	// not an expression 
 				}
 #/*cut-cpp*/
@@ -4999,10 +4999,7 @@
 			return;
 			}
 		else if (converts_to_integerlike(src.data<0>()->type_code.base_type_index ARG_TYPES))
-			{
-			value_copy(src.type_code,src.data<1>()->type_code);
-			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
-			}
+			ZAIMONI_PASSTHROUGH_ASSERT(src.data<1>()->type_code.dereference(src.type_code));
 		else{	// not testable from preprocessor yet (need floating-point literals as extension)
 			src.flags |= parse_tree::INVALID;
 			message_header(src.index_tokens[0]);
@@ -5017,10 +5014,7 @@
 	else if (0<effective_pointer_power_infix)
 		{
 		if (converts_to_integerlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
-			{
-			value_copy(src.type_code,src.data<0>()->type_code);
-			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
-			}
+			ZAIMONI_PASSTHROUGH_ASSERT(src.data<0>()->type_code.dereference(src.type_code));
 		else{	// autofails in C
 				// not testable from preprocessor yet (need floating-point literals, would be extension regardless)
 			src.flags |= parse_tree::INVALID;
@@ -5431,8 +5425,7 @@
 		}
 	}
 	}
-	x.destroy();
-	x = tmp3;
+	tmp3.MoveInto(x);
 }
 #/*cut-cpp*/
 
@@ -5472,10 +5465,8 @@
  	// handle integer-like literals like a real integer literal
 	if (is_integerlike_literal(*src.data<2>() ARG_TYPES))
 		{
-		type_spec tmp;
-		src.type_code.OverwriteInto(tmp);
+		src.type_code.OverwriteInto(src.c_array<2>()->type_code);
 		src.eval_to_arg<2>(0);
-		tmp.MoveInto(src.type_code);
 		return true;
 		}
 	return false;
@@ -5520,10 +5511,8 @@
 		POD_pair<char*,lex_flags> new_token;
 		VM_to_token(res_int,src.type_code.base_type_index,new_token);
 		src.c_array<2>()->grab_index_token_from<0>(new_token.first,new_token.second);
-		type_spec tmp;
-		src.type_code.OverwriteInto(tmp);
+		src.type_code.OverwriteInto(src.c_array<2>()->type_code);
 		src.eval_to_arg<2>(0);
-		tmp.MoveInto(src.type_code);
 		return true;
 		};
 	if (converts_to_integerlike(src.data<2>()->type_code ARG_TYPES) && is_C99_unary_operator_expression<'-'>(*src.data<2>()))
@@ -5531,10 +5520,8 @@
 		assert(converts_to_integerlike(src.data<2>()->data<2>()->type_code ARG_TYPES));
 		parse_tree tmp;
 		src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
-		type_spec tmp2;
-		src.type_code.OverwriteInto(tmp2);
+		src.type_code.OverwriteInto(tmp.type_code);
 		tmp.MoveInto(src);
-		tmp2.MoveInto(src.type_code);
 		return true;		
 		}
 	return false;
@@ -5693,6 +5680,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static void C_deref_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'*'>(src));
@@ -5853,18 +5841,19 @@
 	return false;
 }
 
+//! this doesn't do anything to dest's type
 static void force_unary_negative_literal(parse_tree& dest,const parse_tree& src)
 {
 	assert(0==dest.size<0>());
 	assert(0==dest.size<1>());
 	assert(1==dest.size<2>());
-	assert(NULL==dest.index_tokens[1].token.first);
+	assert(!dest.index_tokens[1].token.first);
 	dest.grab_index_token_from_str_literal<0>("-",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
 	*dest.c_array<2>() = src;
 	dest.core_flag_update();
 	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	dest.subtype = C99_UNARY_SUBTYPE_NEG;
-	assert(NULL!=dest.index_tokens[0].src_filename);
+	assert(dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'-'>(dest));
 }
 
@@ -5916,57 +5905,38 @@
 	return false;
 }
 
+// all three users of this want the resulting type to be the same as dest's type
 //! \throw std::bad_alloc()
 static void construct_twos_complement_int_min(parse_tree& dest, const type_system& types, const virtual_machine::std_int_enum machine_type, const parse_tree& src_loc)
 {
+	zaimoni::autoval_ptr<parse_tree> tmp2;
+	tmp2 = _new_buffer_nonNULL_throws<parse_tree>(1);	// XXX we recycle this variable later
+	zaimoni::autoval_ptr<parse_tree> tmp3;
+	tmp3 = _new_buffer_nonNULL_throws<parse_tree>(1);	// XXX we recycle this variable later
+	{
 	umaxint tmp_int(target_machine->signed_max(machine_type));
-	parse_tree* const tmp = _new_buffer_nonNULL_throws<parse_tree>(1);	// XXX we recycle this variable later
-	try {
-		VM_to_literal(*tmp,tmp_int,src_loc,types);
-		}
-	catch(const std::bad_alloc&)
-		{
-		_flush(tmp);
-		throw;
-		}
+	zaimoni::autoval_ptr<parse_tree> tmp;
+	tmp = _new_buffer_nonNULL_throws<parse_tree>(1);	// XXX we recycle this variable later
+	VM_to_literal(*tmp,tmp_int,src_loc,types);
 
 	tmp_int = 1;
-	parse_tree* const tmp2 = _new_buffer<parse_tree>(1);
-	if (!tmp2)
-		{
-		tmp->destroy();
-		_flush(tmp);
-		throw std::bad_alloc();
-		}
 	try {
 		VM_to_literal(*tmp2,tmp_int,src_loc,types);
 		}
 	catch(const std::bad_alloc&)
 		{
-		tmp2->destroy();
-		_flush(tmp2);
 		tmp->destroy();
-		_flush(tmp);
 		throw;
 		}
 
-	parse_tree* const tmp3 = _new_buffer<parse_tree>(1);
-	if (!tmp3)
-		{
-		tmp2->destroy();
-		_flush(tmp2);
-		tmp->destroy();
-		_flush(tmp);
-		throw std::bad_alloc();
-		}
-	force_unary_negative_token(*tmp3,tmp,src_loc ARG_TYPES);
-
-	parse_tree tmp4;
-	tmp4.clear();
+	force_unary_negative_token(*tmp3,tmp.release(),src_loc ARG_TYPES);
+	}
+	
+	parse_tree_class tmp4;
 	tmp4.grab_index_token_from_str_literal<0>("-",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
 	tmp4.grab_index_token_location_from<0,0>(src_loc);
-	tmp4.fast_set_arg<1>(tmp3);
-	tmp4.fast_set_arg<2>(tmp2);
+	tmp4.fast_set_arg<1>(tmp3.release());
+	tmp4.fast_set_arg<2>(tmp2.release());
 
 	tmp4.core_flag_update();
 	tmp4.flags |= PARSE_STRICT_ADD_EXPRESSION;
@@ -6001,38 +5971,26 @@
 
 		const bool negative_signed_int = 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && res_int.test(target_machine->C_bit(machine_type)-1);
 		if (negative_signed_int) target_machine->signed_additive_inverse(res_int,machine_type);
-		const type_spec old_type = src.type_code;
 		if (	virtual_machine::twos_complement==target_machine->C_signed_int_representation()
 			&& 	0==(src.type_code.base_type_index-C_TYPE::INT)%2
 			&& 	!bool_options[boolopt::int_traps]
 			&&	res_int>target_machine->signed_max(machine_type))
 			{	// trap representation; need to get it into -INT_MAX-1 form
-			try {
-				construct_twos_complement_int_min(src,types,machine_type,src);
-				}
-			catch(const std::bad_alloc&)
-				{
-				return false;
-				}
-			src.type_code = old_type;
+			construct_twos_complement_int_min(src,types,machine_type,src);
 			return true;
 			}
 
+		const type_spec old_type = src.type_code;
 		parse_tree tmp;
-		try {
-			VM_to_literal(tmp,res_int,src,types);	// two's-complement non-trapping INT_MIN dies if it gets here
-			}
-		catch(const std::bad_alloc&)
-			{
-			return false;
-			}
+		VM_to_literal(tmp,res_int,src,types);	// two's-complement non-trapping INT_MIN dies if it gets here
 
 		if (negative_signed_int)
 			// convert to parsed - literal
 			force_unary_negative_literal(src,tmp);
-		else	// convert to positive literal
+		else{	// convert to positive literal
+			src.type_code.MoveInto(tmp.type_code);
 			tmp.MoveInto(src);
-		src.type_code = old_type;
+			}
 		return true;
 		};
 	if (	is_bitwise_complement_expression(*src.data<2>())
@@ -6046,6 +6004,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static void C_bitwise_complement_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'~'>(src));
@@ -6060,6 +6019,7 @@
 	if (eval_bitwise_compl(src,types,false,is_C99_unary_operator_expression<'~'>,C99_intlike_literal_to_VM)) return;
 }
 
+//! \throw std::bad_alloc()
 static void CPP_bitwise_complement_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_CPP_bitwise_complement_expression(src));
@@ -6074,6 +6034,7 @@
 	if (eval_bitwise_compl(src,types,false,is_CPP_bitwise_complement_expression,CPP_intlike_literal_to_VM)) return;
 }
 
+//! \throw std::bad_alloc()
 static bool locate_C99_bitwise_complement(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6089,6 +6050,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool locate_CPP_bitwise_complement(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6104,6 +6066,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_C99_unary_plusminus(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6132,6 +6095,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_CPP_unary_plusminus(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6160,6 +6124,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool locate_C99_unary_plusminus(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6171,6 +6136,7 @@
 	return terse_locate_C99_unary_plusminus(src,i,types);
 }
 
+//! \throw std::bad_alloc()
 static bool locate_CPP_unary_plusminus(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6237,8 +6203,7 @@
 		{
 		src.type_code.set_type(size_t_type);
 		VM_to_literal(tmp,umaxint(target_machine->C_sizeof_short()),src,types);
-		src.destroy();
-		src = tmp;			
+		tmp.MoveInto(src);
 		break;
 		}
 	case C_TYPE::INT:
@@ -6246,8 +6211,7 @@
 		{
 		src.type_code.set_type(size_t_type);
 		VM_to_literal(tmp,umaxint(target_machine->C_sizeof_int()),src,types);
-		src.destroy();
-		src = tmp;			
+		tmp.MoveInto(src);
 		break;
 		}
 	case C_TYPE::LONG:
@@ -6255,8 +6219,7 @@
 		{
 		src.type_code.set_type(size_t_type);
 		VM_to_literal(tmp,umaxint(target_machine->C_sizeof_long()),src,types);
-		src.destroy();
-		src = tmp;			
+		tmp.MoveInto(src);
 		break;
 		}
 	case C_TYPE::LLONG:
@@ -6264,8 +6227,7 @@
 		{
 		src.type_code.set_type(size_t_type);
 		VM_to_literal(tmp,umaxint(target_machine->C_sizeof_long_long()),src,types);
-		src.destroy();
-		src = tmp;			
+		tmp.MoveInto(src);
 //		break;
 		}
 	}
@@ -6297,8 +6259,7 @@
 		src.type_code.set_type(size_t_type);
 		//! \todo eventually, need to check for data vs function pointer when pointer_power is 1
 		VM_to_literal(tmp,umaxint(target_machine->C_sizeof_data_ptr()),src,types);
-		src.destroy();
-		src = tmp;			
+		tmp.MoveInto(src);
 		assert(size_t_type==src.type_code.base_type_index);
 		return true;
 		}
@@ -6306,6 +6267,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_C99_sizeof(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_CPP_sizeof_expression(src));
@@ -6331,6 +6293,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool eval_CPP_sizeof(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_CPP_sizeof_expression(src));
@@ -6362,6 +6325,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static void C99_sizeof_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_CPP_sizeof_expression(src));
@@ -6369,6 +6333,7 @@
 	if (eval_C99_sizeof(src,types)) return;
 }
 
+//! \throw std::bad_alloc()
 static void CPP_sizeof_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_CPP_sizeof_expression(src));
@@ -6376,6 +6341,7 @@
 	if (eval_CPP_sizeof(src,types)) return;
 }
 
+//! \throw std::bad_alloc()
 static bool locate_C99_sizeof(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6391,6 +6357,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool locate_CPP_sizeof(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6424,6 +6391,7 @@
 
 Note that the binary operators *,+,- are effectively handled by first building the unary operator, then checking whether the left-hand-side qualifies for extension to binary operator
 */
+//! \throw std::bad_alloc()
 static void locate_C99_unary_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6503,6 +6471,7 @@
 
 Note that the binary operators *,+,- are effectively handled by first building the unary operator, then checking whether the left-hand-side qualifies for extension to binary operator
 */
+//! \throw std::bad_alloc()
 static void locate_CPP_unary_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6539,21 +6508,21 @@
 #endif
 }
 
+//! \throw std::bad_alloc()
 static void assemble_binary_infix_arguments(parse_tree& src, size_t& i, const lex_flags _flags)
 {
 	assert(1<=i && 2<=src.size<0>()-i);
 	{
 	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
-	parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
-	*tmp = tmp_c_array[0];
+	zaimoni::autoval_ptr<parse_tree> tmp;
+	tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
 	parse_tree* const tmp2 = repurpose_inner_parentheses(tmp_c_array[2]);	// RAM conservation
-	*tmp2 = tmp_c_array[2];
-	tmp_c_array[1].fast_set_arg<1>(tmp);
+	tmp_c_array[0].OverwriteInto(*tmp);
+	tmp_c_array[2].OverwriteInto(*tmp2);
+	tmp_c_array[1].fast_set_arg<1>(tmp.release());
 	tmp_c_array[1].fast_set_arg<2>(tmp2);
 	tmp_c_array[1].core_flag_update();
 	tmp_c_array[1].flags |= _flags;
-	tmp_c_array[0].clear();
-	tmp_c_array[2].clear();
 	}
 	src.DeleteIdx<0>(i+1);
 	src.DeleteIdx<0>(--i);
@@ -6563,23 +6532,24 @@
 	cancel_outermost_parentheses(tmp.c_array<2>()[0]);
 }
 
+//! \throw std::bad_alloc()
 static void merge_binary_infix_argument(parse_tree& src, size_t& i, const lex_flags _flags)
 {
 	assert(1<=i);
-	{
+ 	{
 	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
 	parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
-	*tmp = tmp_c_array[0];
+	tmp_c_array[0].MoveInto(*tmp);
 
 	tmp_c_array[1].fast_set_arg<1>(tmp);
 	tmp_c_array[1].core_flag_update();
 	tmp_c_array[1].flags |= _flags;
-	tmp_c_array[0].clear();
 	}
 	src.DeleteIdx<0>(--i);
 	cancel_outermost_parentheses(src.c_array<0>()[i].c_array<1>()[0]);
 }
 
+//! \throw std::bad_alloc()
 static bool terse_C99_augment_mult_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6600,6 +6570,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_CPP_augment_mult_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6621,6 +6592,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_mult_expression(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -6659,7 +6631,6 @@
 {
 	assert(is_C99_mult_operator_expression<'*'>(src));
 
-	const type_spec old_type = src.type_code;
 	bool is_true = false;
 
 	// do this first to avoid unnecessary dynamic memory allocation
@@ -6668,7 +6639,7 @@
 		{
 		// construct +0 to defuse 1-0*6
 		parse_tree tmp = decimal_literal("0",src,types);
-		if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
+		if (C_TYPE::INTEGERLIKE==src.type_code.base_type_index)
 			{
 			message_header(src.index_tokens[0]);
 			INC_INFORM("invalid ");
@@ -6676,7 +6647,7 @@
 			INFORM(" optimized to valid 0");
 			tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
 			}
-		else tmp.type_code = old_type;
+		else value_copy(tmp.type_code,src.type_code);
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
@@ -6688,19 +6659,19 @@
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 	if (lhs_converted && 1==res_int)
 		{
+		src.type_code.MoveInto(src.c_array<2>()->type_code);
 		src.eval_to_arg<2>(0);
-		src.type_code = old_type;
 		return true;
 		};
 	if (rhs_converted && 1==rhs_int)
 		{
+		src.type_code.MoveInto(src.c_array<1>()->type_code);
 		src.eval_to_arg<1>(0);
-		src.type_code = old_type;
 		return true;
 		};
 	if (lhs_converted && rhs_converted)
 		{
-		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=lhs.bitcount);
 		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
@@ -6746,7 +6717,6 @@
 
 				src.DeleteIdx<1>(0);
 				force_unary_negative_literal(src,tmp);
-				src.type_code = old_type;
 				return true;
 				}
 			res_int = lhs_test;
@@ -6757,7 +6727,7 @@
 		// convert to parsed + literal
 		parse_tree tmp;
 		VM_to_literal(tmp,res_int,src,types);
-		tmp.type_code = old_type;
+		src.type_code.MoveInto(tmp.type_code);
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
@@ -6770,7 +6740,6 @@
 {
 	assert(is_C99_mult_operator_expression<'/'>(src));
 
-	const type_spec old_type = src.type_code;
 	bool is_true = false;
 	if (converts_to_integerlike(src.type_code ARG_TYPES))
 		{
@@ -6786,7 +6755,7 @@
 			{
 			// construct +0 to defuse 1-0/6
 			parse_tree tmp = decimal_literal("0",src,types);
-			if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
+			if (C_TYPE::INTEGERLIKE==src.type_code.base_type_index)
 				{
 				message_header(src.index_tokens[0]);
 				INC_INFORM("invalid ");
@@ -6794,7 +6763,7 @@
 				INFORM(" optimized to valid 0");
 				tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
 				}
-			else tmp.type_code = old_type;
+			else src.type_code.MoveInto(tmp.type_code);
 			src.DeleteIdx<1>(0);
 			force_unary_positive_literal(src,tmp ARG_TYPES);
 			return true;
@@ -6808,16 +6777,15 @@
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 	if (rhs_converted && rhs_int==1)
 		{	// __/1 |-> __
+		src.type_code.MoveInto(src.c_array<1>()->type_code);
 		src.eval_to_arg<1>(0);
-		src.type_code = old_type;
 		return true;
 		};
-	//! \todo handle signed integer arithmetic
 	// two's complement can overflow: INT_MIN/-1
 	// implementation-defined whether negative results round away or to zero (standard prefers to zero, so default to that)
 	if (lhs_converted && rhs_converted)
 		{
-		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=lhs.bitcount);
 		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
@@ -6838,10 +6806,12 @@
 				{
 				const bool want_zero = rhs_negative==lhs_negative || !bool_options[boolopt::int_neg_div_rounds_away_from_zero];
 				parse_tree tmp = decimal_literal(want_zero ? "0" : "1",src,types);
-				tmp.type_code = old_type;
 				src.DeleteIdx<1>(0);
 				if (want_zero)
+					{
+					src.type_code.MoveInto(tmp.type_code);
 					force_unary_positive_literal(src,tmp ARG_TYPES); // +0
+					}
 				else	
 					force_unary_negative_literal(src,tmp); // -1
 				return true;
@@ -6865,7 +6835,6 @@
 
 				src.DeleteIdx<1>(0);
 				force_unary_negative_literal(src,tmp);
-				src.type_code = old_type;
 				return true;
 				}
 			if (ub<lhs_test)
@@ -6884,8 +6853,8 @@
 		// convert to parsed + literal
 		parse_tree tmp;
 		VM_to_literal(tmp,res_int,src,types);
-		tmp.type_code = old_type;
 
+		src.type_code.MoveInto(tmp.type_code);
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-07 03:37:43 UTC (rev 411)
+++ trunk/CSupport_pp.cpp	2010-05-07 03:39:23 UTC (rev 412)
@@ -4399,10 +4399,10 @@
 				}
 			else if (PARSE_EXPRESSION & src.data<0>()->flags)
 				{	// normal expression that got parenthesized
+				value_copy(src.type_code,src.data<0>()->type_code);
 				src.flags &= parse_tree::RESERVED_MASK;	// just in case
 				src.flags |= PARSE_PRIMARY_EXPRESSION;
 				src.flags |= (PARSE_PAREN_PRIMARY_PASSTHROUGH & src.data<0>()->flags);
-				value_copy(src.type_code,src.data<0>()->type_code);
 				return true;
 				}
 			};
@@ -4539,10 +4539,7 @@
 			return;
 			}
 		else if (converts_to_integerlike(src.data<0>()->type_code.base_type_index ARG_TYPES))
-			{
-			value_copy(src.type_code,src.data<1>()->type_code);
-			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
-			}
+			ZAIMONI_PASSTHROUGH_ASSERT(src.data<1>()->type_code.dereference(src.type_code));
 		else{	// not testable from preprocessor yet (need floating-point literals as extension)
 			src.flags |= parse_tree::INVALID;
 			message_header(src.index_tokens[0]);
@@ -4557,10 +4554,7 @@
 	else if (0<effective_pointer_power_infix)
 		{
 		if (converts_to_integerlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
-			{
-			value_copy(src.type_code,src.data<0>()->type_code);
-			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
-			}
+			ZAIMONI_PASSTHROUGH_ASSERT(src.data<0>()->type_code.dereference(src.type_code));
 		else{	// autofails in C
 				// not testable from preprocessor yet (need floating-point literals, would be extension regardless)
 			src.flags |= parse_tree::INVALID;
@@ -4959,10 +4953,8 @@
  	// handle integer-like literals like a real integer literal
 	if (is_integerlike_literal(*src.data<2>() ARG_TYPES))
 		{
-		type_spec tmp;
-		src.type_code.OverwriteInto(tmp);
+		src.type_code.OverwriteInto(src.c_array<2>()->type_code);
 		src.eval_to_arg<2>(0);
-		tmp.MoveInto(src.type_code);
 		return true;
 		}
 	return false;
@@ -4993,10 +4985,8 @@
 		POD_pair<char*,lex_flags> new_token;
 		VM_to_token(res_int,src.type_code.base_type_index,new_token);
 		src.c_array<2>()->grab_index_token_from<0>(new_token.first,new_token.second);
-		type_spec tmp;
-		src.type_code.OverwriteInto(tmp);
+		src.type_code.OverwriteInto(src.c_array<2>()->type_code);
 		src.eval_to_arg<2>(0);
-		tmp.MoveInto(src.type_code);
 		return true;
 		};
 	if (converts_to_integerlike(src.data<2>()->type_code ARG_TYPES) && is_C99_unary_operator_expression<'-'>(*src.data<2>()))
@@ -5004,10 +4994,8 @@
 		assert(converts_to_integerlike(src.data<2>()->data<2>()->type_code ARG_TYPES));
 		parse_tree tmp;
 		src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
-		type_spec tmp2;
-		src.type_code.OverwriteInto(tmp2);
+		src.type_code.OverwriteInto(tmp.type_code);
 		tmp.MoveInto(src);
-		tmp2.MoveInto(src.type_code);
 		return true;		
 		}
 	return false;
@@ -5146,6 +5134,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static void C_deref_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'*'>(src));
@@ -5306,18 +5295,19 @@
 	return false;
 }
 
+//! this doesn't do anything to dest's type
 static void force_unary_negative_literal(parse_tree& dest,const parse_tree& src)
 {
 	assert(0==dest.size<0>());
 	assert(0==dest.size<1>());
 	assert(1==dest.size<2>());
-	assert(NULL==dest.index_tokens[1].token.first);
+	assert(!dest.index_tokens[1].token.first);
 	dest.grab_index_token_from_str_literal<0>("-",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
 	*dest.c_array<2>() = src;
 	dest.core_flag_update();
 	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	dest.subtype = C99_UNARY_SUBTYPE_NEG;
-	assert(NULL!=dest.index_tokens[0].src_filename);
+	assert(dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'-'>(dest));
 }
 
@@ -5369,57 +5359,38 @@
 	return false;
 }
 
+// all three users of this want the resulting type to be the same as dest's type
 //! \throw std::bad_alloc()
 static void construct_twos_complement_int_min(parse_tree& dest, const type_system& types, const virtual_machine::std_int_enum machine_type, const parse_tree& src_loc)
 {
+	zaimoni::autoval_ptr<parse_tree> tmp2;
+	tmp2 = _new_buffer_nonNULL_throws<parse_tree>(1);	// XXX we recycle this variable later
+	zaimoni::autoval_ptr<parse_tree> tmp3;
+	tmp3 = _new_buffer_nonNULL_throws<parse_tree>(1);	// XXX we recycle this variable later
+	{
 	umaxint tmp_int(target_machine->signed_max(machine_type));
-	parse_tree* const tmp = _new_buffer_nonNULL_throws<parse_tree>(1);	// XXX we recycle this variable later
-	try {
-		VM_to_literal(*tmp,tmp_int,src_loc,types);
-		}
-	catch(const std::bad_alloc&)
-		{
-		_flush(tmp);
-		throw;
-		}
+	zaimoni::autoval_ptr<parse_tree> tmp;
+	tmp = _new_buffer_nonNULL_throws<parse_tree>(1);	// XXX we recycle this variable later
+	VM_to_literal(*tmp,tmp_int,src_loc,types);
 
 	tmp_int = 1;
-	parse_tree* const tmp2 = _new_buffer<parse_tree>(1);
-	if (!tmp2)
-		{
-		tmp->destroy();
-		_flush(tmp);
-		throw std::bad_alloc();
-		}
 	try {
 		VM_to_literal(*tmp2,tmp_int,src_loc,types);
 		}
 	catch(const std::bad_alloc&)
 		{
-		tmp2->destroy();
-		_flush(tmp2);
 		tmp->destroy();
-		_flush(tmp);
 		throw;
 		}
 
-	parse_tree* const tmp3 = _new_buffer<parse_tree>(1);
-	if (!tmp3)
-		{
-		tmp2->destroy();
-		_flush(tmp2);
-		tmp->destroy();
-		_flush(tmp);
-		throw std::bad_alloc();
-		}
-	force_unary_negative_token(*tmp3,tmp,src_loc ARG_TYPES);
-
-	parse_tree tmp4;
-	tmp4.clear();
+	force_unary_negative_token(*tmp3,tmp.release(),src_loc ARG_TYPES);
+	}
+	
+	parse_tree_class tmp4;
 	tmp4.grab_index_token_from_str_literal<0>("-",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
 	tmp4.grab_index_token_location_from<0,0>(src_loc);
-	tmp4.fast_set_arg<1>(tmp3);
-	tmp4.fast_set_arg<2>(tmp2);
+	tmp4.fast_set_arg<1>(tmp3.release());
+	tmp4.fast_set_arg<2>(tmp2.release());
 
 	tmp4.core_flag_update();
 	tmp4.flags |= PARSE_STRICT_ADD_EXPRESSION;
@@ -5447,38 +5418,26 @@
 
 		const bool negative_signed_int = 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && res_int.test(target_machine->C_bit(machine_type)-1);
 		if (negative_signed_int) target_machine->signed_additive_inverse(res_int,machine_type);
-		const type_spec old_type = src.type_code;
 		if (	virtual_machine::twos_complement==target_machine->C_signed_int_representation()
 			&& 	0==(src.type_code.base_type_index-C_TYPE::INT)%2
 			&& 	!bool_options[boolopt::int_traps]
 			&&	res_int>target_machine->signed_max(machine_type))
 			{	// trap representation; need to get it into -INT_MAX-1 form
-			try {
-				construct_twos_complement_int_min(src,types,machine_type,src);
-				}
-			catch(const std::bad_alloc&)
-				{
-				return false;
-				}
-			src.type_code = old_type;
+			construct_twos_complement_int_min(src,types,machine_type,src);
 			return true;
 			}
 
+		const type_spec old_type = src.type_code;
 		parse_tree tmp;
-		try {
-			VM_to_literal(tmp,res_int,src,types);	// two's-complement non-trapping INT_MIN dies if it gets here
-			}
-		catch(const std::bad_alloc&)
-			{
-			return false;
-			}
+		VM_to_literal(tmp,res_int,src,types);	// two's-complement non-trapping INT_MIN dies if it gets here
 
 		if (negative_signed_int)
 			// convert to parsed - literal
 			force_unary_negative_literal(src,tmp);
-		else	// convert to positive literal
+		else{	// convert to positive literal
+			src.type_code.MoveInto(tmp.type_code);
 			tmp.MoveInto(src);
-		src.type_code = old_type;
+			}
 		return true;
 		};
 	if (	is_bitwise_complement_expression(*src.data<2>())
@@ -5492,6 +5451,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static void C_bitwise_complement_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'~'>(src));
@@ -5506,6 +5466,7 @@
 	if (eval_bitwise_compl(src,types,false,is_C99_unary_operator_expression<'~'>,C99_intlike_literal_to_VM)) return;
 }
 
+//! \throw std::bad_alloc()
 static void CPP_bitwise_complement_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_CPP_bitwise_complement_expression(src));
@@ -5520,6 +5481,7 @@
 	if (eval_bitwise_compl(src,types,false,is_CPP_bitwise_complement_expression,CPP_intlike_literal_to_VM)) return;
 }
 
+//! \throw std::bad_alloc()
 static bool locate_C99_bitwise_complement(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5535,6 +5497,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool locate_CPP_bitwise_complement(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5550,6 +5513,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_C99_unary_plusminus(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5578,6 +5542,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_CPP_unary_plusminus(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5606,6 +5571,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool locate_C99_unary_plusminus(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5617,6 +5583,7 @@
 	return terse_locate_C99_unary_plusminus(src,i,types);
 }
 
+//! \throw std::bad_alloc()
 static bool locate_CPP_unary_plusminus(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5645,6 +5612,7 @@
 
 Note that the binary operators *,+,- are effectively handled by first building the unary operator, then checking whether the left-hand-side qualifies for extension to binary operator
 */
+//! \throw std::bad_alloc()
 static void locate_C99_unary_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5721,6 +5689,7 @@
 
 Note that the binary operators *,+,- are effectively handled by first building the unary operator, then checking whether the left-hand-side qualifies for extension to binary operator
 */
+//! \throw std::bad_alloc()
 static void locate_CPP_unary_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5754,21 +5723,21 @@
 #endif
 }
 
+//! \throw std::bad_alloc()
 static void assemble_binary_infix_arguments(parse_tree& src, size_t& i, const lex_flags _flags)
 {
 	assert(1<=i && 2<=src.size<0>()-i);
 	{
 	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
-	parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
-	*tmp = tmp_c_array[0];
+	zaimoni::autoval_ptr<parse_tree> tmp;
+	tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
 	parse_tree* const tmp2 = repurpose_inner_parentheses(tmp_c_array[2]);	// RAM conservation
-	*tmp2 = tmp_c_array[2];
-	tmp_c_array[1].fast_set_arg<1>(tmp);
+	tmp_c_array[0].OverwriteInto(*tmp);
+	tmp_c_array[2].OverwriteInto(*tmp2);
+	tmp_c_array[1].fast_set_arg<1>(tmp.release());
 	tmp_c_array[1].fast_set_arg<2>(tmp2);
 	tmp_c_array[1].core_flag_update();
 	tmp_c_array[1].flags |= _flags;
-	tmp_c_array[0].clear();
-	tmp_c_array[2].clear();
 	}
 	src.DeleteIdx<0>(i+1);
 	src.DeleteIdx<0>(--i);
@@ -5778,23 +5747,24 @@
 	cancel_outermost_parentheses(tmp.c_array<2>()[0]);
 }
 
+//! \throw std::bad_alloc()
 static void merge_binary_infix_argument(parse_tree& src, size_t& i, const lex_flags _flags)
 {
 	assert(1<=i);
-	{
+ 	{
 	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
 	parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
-	*tmp = tmp_c_array[0];
+	tmp_c_array[0].MoveInto(*tmp);
 
 	tmp_c_array[1].fast_set_arg<1>(tmp);
 	tmp_c_array[1].core_flag_update();
 	tmp_c_array[1].flags |= _flags;
-	tmp_c_array[0].clear();
 	}
 	src.DeleteIdx<0>(--i);
 	cancel_outermost_parentheses(src.c_array<0>()[i].c_array<1>()[0]);
 }
 
+//! \throw std::bad_alloc()
 static bool terse_C99_augment_mult_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5815,6 +5785,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_CPP_augment_mult_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5836,6 +5807,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_mult_expression(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -5874,7 +5846,6 @@
 {
 	assert(is_C99_mult_operator_expression<'*'>(src));
 
-	const type_spec old_type = src.type_code;
 	bool is_true = false;
 
 	// do this first to avoid unnecessary dynamic memory allocation
@@ -5883,7 +5854,7 @@
 		{
 		// construct +0 to defuse 1-0*6
 		parse_tree tmp = decimal_literal("0",src,types);
-		if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
+		if (C_TYPE::INTEGERLIKE==src.type_code.base_type_index)
 			{
 			message_header(src.index_tokens[0]);
 			INC_INFORM("invalid ");
@@ -5891,7 +5862,7 @@
 			INFORM(" optimized to valid 0");
 			tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
 			}
-		else tmp.type_code = old_type;
+		else value_copy(tmp.type_code,src.type_code);
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
@@ -5903,19 +5874,19 @@
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 	if (lhs_converted && 1==res_int)
 		{
+		src.type_code.MoveInto(src.c_array<2>()->type_code);
 		src.eval_to_arg<2>(0);
-		src.type_code = old_type;
 		return true;
 		};
 	if (rhs_converted && 1==rhs_int)
 		{
+		src.type_code.MoveInto(src.c_array<1>()->type_code);
 		src.eval_to_arg<1>(0);
-		src.type_code = old_type;
 		return true;
 		};
 	if (lhs_converted && rhs_converted)
 		{
-		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=lhs.bitcount);
 		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
@@ -5961,7 +5932,6 @@
 
 				src.DeleteIdx<1>(0);
 				force_unary_negative_literal(src,tmp);
-				src.type_code = old_type;
 				return true;
 				}
 			res_int = lhs_test;
@@ -5972,7 +5942,7 @@
 		// convert to parsed + literal
 		parse_tree tmp;
 		VM_to_literal(tmp,res_int,src,types);
-		tmp.type_code = old_type;
+		src.type_code.MoveInto(tmp.type_code);
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
@@ -5985,7 +5955,6 @@
 {
 	assert(is_C99_mult_operator_expression<'/'>(src));
 
-	const type_spec old_type = src.type_code;
 	bool is_true = false;
 	if (converts_to_integerlike(src.type_code ARG_TYPES))
 		{
@@ -6001,7 +5970,7 @@
 			{
 			// construct +0 to defuse 1-0/6
 			parse_tree tmp = decimal_literal("0",src,types);
-			if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
+			if (C_TYPE::INTEGERLIKE==src.type_code.base_type_index)
 				{
 				message_header(src.index_tokens[0]);
 				INC_INFORM("invalid ");
@@ -6009,7 +5978,7 @@
 				INFORM(" optimized to valid 0");
 				tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
 				}
-			else tmp.type_code = old_type;
+			else src.type_code.MoveInto(tmp.type_code);
 			src.DeleteIdx<1>(0);
 			force_unary_positive_literal(src,tmp ARG_TYPES);
 			return true;
@@ -6023,16 +5992,15 @@
 	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
 	if (rhs_converted && rhs_int==1)
 		{	// __/1 |-> __
+		src.type_code.MoveInto(src.c_array<1>()->type_code);
 		src.eval_to_arg<1>(0);
-		src.type_code = old_type;
 		return true;
 		};
-	//! \todo handle signed integer arithmetic
 	// two's complement can overflow: INT_MIN/-1
 	// implementation-defined whether negative results round away or to zero (standard prefers to zero, so default to that)
 	if (lhs_converted && rhs_converted)
 		{
-		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=lhs.bitcount);
 		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
@@ -6053,10 +6021,12 @@
 				{
 				const bool want_zero = rhs_negative==lhs_negative || !bool_options[boolopt::int_neg_div_rounds_away_from_zero];
 				parse_tree tmp = decimal_literal(want_zero ? "0" : "1",src,types);
-				tmp.type_code = old_type;
 				src.DeleteIdx<1>(0);
 				if (want_zero)
+					{
+					src.type_code.MoveInto(tmp.type_code);
 					force_unary_positive_literal(src,tmp ARG_TYPES); // +0
+					}
 				else	
 					force_unary_negative_literal(src,tmp); // -1
 				return true;
@@ -6080,7 +6050,6 @@
 
 				src.DeleteIdx<1>(0);
 				force_unary_negative_literal(src,tmp);
-				src.type_code = old_type;
 				return true;
 				}
 			if (ub<lhs_test)
@@ -6099,8 +6068,8 @@
 		// convert to parsed + literal
 		parse_tree tmp;
 		VM_to_literal(tmp,res_int,src,types);
-		tmp.type_code = old_type;
 
+		src.type_code.MoveInto(tmp.type_code);
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;



From zaimoni at mail.berlios.de  Fri May  7 11:52:20 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 7 May 2010 11:52:20 +0200
Subject: [Zcplusplus-commits] r413 - trunk
Message-ID: <201005070952.o479qKUv018426@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-07 11:52:16 +0200 (Fri, 07 May 2010)
New Revision: 413

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/type_spec.cpp
Log:
memory loading stabilization changes

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-07 03:39:23 UTC (rev 412)
+++ trunk/CSupport.cpp	2010-05-07 09:52:16 UTC (rev 413)
@@ -5063,9 +5063,9 @@
 	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
 		|| !src.data<0>()[i].empty<1>()
 		|| !src.data<0>()[i].empty<2>()
-		|| NULL==src.data<0>()[i].index_tokens[0].token.first) return;
+		|| !src.data<0>()[i].index_tokens[0].token.first) return;
 	
-	if (NULL!=src.data<0>()[i].index_tokens[1].token.first)
+	if (src.data<0>()[i].index_tokens[1].token.first)
 		{
 		if (terse_locate_array_deref(src,i))
 			{
@@ -5143,7 +5143,7 @@
 		|| !src.data<0>()[i].empty<1>()
 		|| !src.data<0>()[i].empty<2>()) return;
 
-	if (NULL!=src.data<0>()[i].index_tokens[1].token.first)
+	if (src.data<0>()[i].index_tokens[1].token.first)
 		{
 		if (terse_locate_array_deref(src,i))
 			{	//! \todo handle operator [] overloading
@@ -5273,6 +5273,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static void assemble_unary_postfix_arguments(parse_tree& src, size_t& i, const size_t _subtype)
 {
 	assert(1<src.size<0>()-i);
@@ -5343,6 +5344,8 @@
 	return dest;
 }
 
+//! usually want to use value_copy rather than MoveInto before this (easier to be ACID)
+//! \throw std::bad_alloc only if dest.type_code.pointer_power<dest.data<2>()->type_code.pointer_power 
 static void force_unary_positive_literal(parse_tree& dest,const parse_tree& src SIG_CONST_TYPES)
 {
 	assert(0==dest.size<0>());
@@ -5372,7 +5375,7 @@
 	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	dest.subtype = C99_UNARY_SUBTYPE_NEG;
 	if (converts_to_arithmeticlike(dest.data<2>()->type_code ARG_TYPES))
-		dest.type_code = dest.data<2>()->type_code;	//! \bug doesn't work for enumerators
+		value_copy(dest.type_code,dest.data<2>()->type_code);	//! \bug doesn't work for enumerators
 	// do not handle type here: C++ operator overloading risk
 	assert(dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'-'>(dest));
@@ -5434,7 +5437,9 @@
 	return converts_to_integerlike(x.type_code ARG_TYPES) && (PARSE_PRIMARY_EXPRESSION & x.flags);
 }
 
+#/*cut-cpp*/
 //! \throw std::bad_alloc()
+#/*cut-cpp*/
 static bool eval_unary_plus(parse_tree& src, const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'+'>(src));
@@ -5455,9 +5460,7 @@
 		enumerator_to_integer_representation(*src.c_array<2>(),types);
 		if (is_C99_unary_operator_expression<'-'>(*src.data<2>()))
 			{	// enumerator went negative: handle
-			parse_tree tmp;
-			src.c_array<2>()->OverwriteInto(tmp);
-			tmp.MoveInto(src);
+			src.eval_to_arg<2>(0);
 			return true;
 			}
 		}
@@ -5465,7 +5468,7 @@
  	// handle integer-like literals like a real integer literal
 	if (is_integerlike_literal(*src.data<2>() ARG_TYPES))
 		{
-		src.type_code.OverwriteInto(src.c_array<2>()->type_code);
+		src.type_code.MoveInto(src.c_array<2>()->type_code);
 		src.eval_to_arg<2>(0);
 		return true;
 		}
@@ -5492,9 +5495,7 @@
 		enumerator_to_integer_representation(*src.c_array<2>(),types);
 		if (is_C99_unary_operator_expression<'-'>(*src.data<2>()))
 			{	// enumerator went negative: handle
-			parse_tree tmp;
-			src.c_array<2>()->OverwriteInto(tmp);
-			tmp.MoveInto(src);
+			src.eval_to_arg<2>(0);
 			return true;
 			}
 		value_copy(src.type_code,src.data<2>()->type_code);
@@ -5511,7 +5512,7 @@
 		POD_pair<char*,lex_flags> new_token;
 		VM_to_token(res_int,src.type_code.base_type_index,new_token);
 		src.c_array<2>()->grab_index_token_from<0>(new_token.first,new_token.second);
-		src.type_code.OverwriteInto(src.c_array<2>()->type_code);
+		src.type_code.MoveInto(src.c_array<2>()->type_code);
 		src.eval_to_arg<2>(0);
 		return true;
 		};
@@ -5520,7 +5521,7 @@
 		assert(converts_to_integerlike(src.data<2>()->data<2>()->type_code ARG_TYPES));
 		parse_tree tmp;
 		src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
-		src.type_code.OverwriteInto(tmp.type_code);
+		src.type_code.MoveInto(tmp.type_code);
 		tmp.MoveInto(src);
 		return true;		
 		}
@@ -5797,6 +5798,7 @@
 		}
 }
 
+//! \throw std::bad_alloc()
 static bool locate_C99_logical_NOT(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5812,6 +5814,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool locate_CPP_logical_NOT(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5980,7 +5983,6 @@
 			return true;
 			}
 
-		const type_spec old_type = src.type_code;
 		parse_tree tmp;
 		VM_to_literal(tmp,res_int,src,types);	// two's-complement non-trapping INT_MIN dies if it gets here
 
@@ -6150,6 +6152,7 @@
 #/*cut-cpp*/
 
 // handle C++0X sizeof... elsewhere (context-free syntax checks should be fixed first, possibly consider sizeof... a psuedo-identifier)
+//! \throw std::bad_alloc
 static bool terse_locate_C99_CPP_sizeof(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6727,7 +6730,7 @@
 		// convert to parsed + literal
 		parse_tree tmp;
 		VM_to_literal(tmp,res_int,src,types);
-		src.type_code.MoveInto(tmp.type_code);
+		value_copy(tmp.type_code,src.type_code);
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
@@ -6763,7 +6766,7 @@
 				INFORM(" optimized to valid 0");
 				tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
 				}
-			else src.type_code.MoveInto(tmp.type_code);
+			else value_copy(tmp.type_code,src.type_code);
 			src.DeleteIdx<1>(0);
 			force_unary_positive_literal(src,tmp ARG_TYPES);
 			return true;
@@ -6809,7 +6812,7 @@
 				src.DeleteIdx<1>(0);
 				if (want_zero)
 					{
-					src.type_code.MoveInto(tmp.type_code);
+					value_copy(tmp.type_code,src.type_code);
 					force_unary_positive_literal(src,tmp ARG_TYPES); // +0
 					}
 				else	
@@ -6854,7 +6857,7 @@
 		parse_tree tmp;
 		VM_to_literal(tmp,res_int,src,types);
 
-		src.type_code.MoveInto(tmp.type_code);
+		value_copy(tmp.type_code,src.type_code);
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
@@ -6867,7 +6870,6 @@
 {
 	assert(is_C99_mult_operator_expression<'%'>(src));
 
-	const type_spec old_type = src.type_code;
 	bool is_true = false;
 	if (converts_to_integerlike(src.type_code ARG_TYPES))
 		{
@@ -6883,7 +6885,7 @@
 			{
 			// construct +0 to defuse 1-0%6
 			parse_tree tmp = decimal_literal("0",src,types);
-			if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
+			if (C_TYPE::INTEGERLIKE==src.type_code.base_type_index)
 				{
 				message_header(src.index_tokens[0]);
 				INC_INFORM("invalid ");
@@ -6891,7 +6893,7 @@
 				INFORM(" optimized to valid 0");
 				tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
 				}
-			else tmp.type_code = old_type;
+			else value_copy(tmp.type_code,src.type_code);
 			src.DeleteIdx<1>(0);
 			force_unary_positive_literal(src,tmp ARG_TYPES);
 			return true;
@@ -6906,8 +6908,8 @@
 	if (rhs_converted && rhs_int==1)
 		{	// __%1 |-> +0
 		parse_tree tmp = decimal_literal("0",src,types);
-		if (C_TYPE::INTEGERLIKE!=old_type.base_type_index)
-			tmp.type_code = old_type;
+		if (C_TYPE::INTEGERLIKE!=src.type_code.base_type_index)
+			value_copy(tmp.type_code,src.type_code);
 		else
 			tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
 		src.DeleteIdx<1>(0);
@@ -6916,7 +6918,7 @@
 		};
 	if (lhs_converted && rhs_converted)
 		{
-		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=lhs.bitcount);
 		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
@@ -6949,7 +6951,6 @@
 
 					src.DeleteIdx<1>(0);
 					force_unary_negative_literal(src,tmp);
-					src.type_code = old_type;
 					return true;
 					}
 				};
@@ -6962,8 +6963,8 @@
 		// convert to parsed + literal
 		parse_tree tmp;
 		VM_to_literal(tmp,res_int,src,types);
-		tmp.type_code = old_type;
 
+		value_copy(tmp.type_code,src.type_code);
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
@@ -6974,6 +6975,9 @@
 BOOST_STATIC_ASSERT(1==C99_MULT_SUBTYPE_MOD-C99_MULT_SUBTYPE_DIV);
 BOOST_STATIC_ASSERT(1==C99_MULT_SUBTYPE_MULT-C99_MULT_SUBTYPE_MOD);
 
+#/*cut-cpp*/
+//! \throw std::bad_alloc
+#/*cut-cpp*/
 static bool _mod_expression_typecheck(parse_tree& src SIG_CONST_TYPES)
 {
 	assert(C99_MULT_SUBTYPE_MOD==src.subtype && is_C99_mult_operator_expression<'%'>(src));
@@ -7008,6 +7012,9 @@
 	return true;
 }
 
+#/*cut-cpp*/
+//! \throw std::bad_alloc
+#/*cut-cpp*/
 static bool _mult_div_expression_typecheck(parse_tree& src SIG_CONST_TYPES)
 {
 	assert(C99_MULT_SUBTYPE_DIV==src.subtype || C99_MULT_SUBTYPE_MULT==src.subtype);
@@ -7048,6 +7055,7 @@
 	return true;
 }
 
+//! \throw std::bad_alloc()
 static void C_mult_expression_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(C99_MULT_SUBTYPE_DIV<=src.subtype && C99_MULT_SUBTYPE_MULT>=src.subtype);
@@ -7067,6 +7075,7 @@
 		}
 }
 
+//! \throw std::bad_alloc()
 static void CPP_mult_expression_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(C99_MULT_SUBTYPE_DIV<=src.subtype && C99_MULT_SUBTYPE_MULT>=src.subtype);
@@ -7093,6 +7102,7 @@
 	multiplicative-expression / cast-expression
 	multiplicative-expression % cast-expression
 */
+//! \throw std::bad_alloc()
 static void locate_C99_mult_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -7118,6 +7128,7 @@
 	multexpression / pmexpression
 	multexpression % pmexpression
 */
+//! \throw std::bad_alloc()
 static void locate_CPP_mult_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -7182,6 +7193,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_C99_augment_add_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -7202,6 +7214,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_CPP_augment_add_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -7222,6 +7235,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_add_expression(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -7274,18 +7288,14 @@
 			bool is_true = false;
 			if 		(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 				{	// 0 + __ |-> __
-				type_spec old_type;
-				src.type_code.OverwriteInto(old_type);
+				src.type_code.MoveInto(src.c_array<2>()->type_code);
 				src.eval_to_arg<2>(0);
-				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ + 0 |-> __
-				type_spec old_type;
-				src.type_code.OverwriteInto(old_type);
+				src.type_code.MoveInto(src.c_array<1>()->type_code);
 				src.eval_to_arg<1>(0);
-				old_type.MoveInto(src.type_code);
 				return true;
 				};
 			umaxint res_int;
@@ -7352,11 +7362,8 @@
 						parse_tree tmp;
 						VM_to_literal(tmp,lhs_test,src,types);
 
-						type_spec old_type;
-						src.type_code.OverwriteInto(old_type);
 						src.DeleteIdx<1>(0);
 						force_unary_negative_literal(src,tmp);
-						old_type.MoveInto(src.type_code);
 						return true;
 						};
 					res_int = lhs_test;
@@ -7367,7 +7374,7 @@
 				// convert to parsed + literal
 				parse_tree tmp;
 				VM_to_literal(tmp,res_int,src,types);
-				src.type_code.MoveInto(tmp.type_code);
+				value_copy(tmp.type_code,src.type_code);
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp ARG_TYPES);
 				return true;
@@ -7379,10 +7386,8 @@
 			bool is_true = false;
 			if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ + 0 |-> __
-				type_spec old_type;
-				src.type_code.OverwriteInto(old_type);
+				src.type_code.MoveInto(src.c_array<1>()->type_code);
 				src.eval_to_arg<1>(0);
-				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			break;
@@ -7392,10 +7397,8 @@
 			bool is_true = false;
 			if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 				{	// 0 + __ |-> __
-				type_spec old_type;
-				src.type_code.OverwriteInto(old_type);
+				src.type_code.MoveInto(src.c_array<2>()->type_code);
 				src.eval_to_arg<2>(0);
-				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			break;
@@ -7437,10 +7440,8 @@
 				}
 			else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ - 0 |-> __
-				type_spec old_type;
-				src.type_code.OverwriteInto(old_type);
+				src.type_code.MoveInto(src.c_array<1>()->type_code);
 				src.eval_to_arg<1>(0);
-				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			umaxint res_int;
@@ -7508,11 +7509,8 @@
 						// convert to parsed - literal
 						parse_tree tmp;
 						VM_to_literal(tmp,lhs_test,src,types);
-						type_spec old_type;
-						src.type_code.OverwriteInto(old_type);
 						src.DeleteIdx<1>(0);
 						force_unary_negative_literal(src,tmp);
-						old_type.MoveInto(src.type_code);
 						return true;
 						};
 					res_int = lhs_test;
@@ -7523,7 +7521,7 @@
 				// convert to parsed + literal
 				parse_tree tmp;
 				VM_to_literal(tmp,res_int,src,types);
-				src.type_code.MoveInto(tmp.type_code);
+				value_copy(tmp.type_code,src.type_code);
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp ARG_TYPES);
 				return true;
@@ -7535,10 +7533,8 @@
 			bool is_true = false;
 			if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ - 0 |-> __
-				type_spec old_type;
-				src.type_code.OverwriteInto(old_type);
+				src.type_code.MoveInto(src.c_array<1>()->type_code);
 				src.eval_to_arg<1>(0);
-				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			break;
@@ -7859,7 +7855,6 @@
 	// __ >> 0 |-> __
 	// two integer literals
 	// error if RHS is literal "out of bounds"
-	const type_spec old_type = src.type_code;
 	bool is_true = false;
 	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 		{
@@ -7870,8 +7865,8 @@
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
 #/*cut-cpp*/
+			src.type_code.MoveInto(src.c_array<1>()->type_code);
 			src.eval_to_arg<1>(0);
-			src.type_code = old_type;
 			return true;
 			}
 		};
@@ -7879,7 +7874,7 @@
 	umaxint rhs_int;
 	if (intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
-		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(old_type.base_type_index);
+		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
 		const bool undefined_behavior = target_machine->C_bit(machine_type)<=rhs_int;
 
 		//! \todo can't test with static test case (need to use bitcount of uintmax_t/intmax_t)
@@ -7890,8 +7885,10 @@
 			{
 			if (!is_true)
 				{	// 0 << __ or 0 >> __: zero out (note that we can do this even if we invoked undefined behavior)
+				type_spec tmp;
+				src.type_code.OverwriteInto(tmp);
 				force_decimal_literal(src,"0",types);
-				src.type_code = old_type;
+				tmp.MoveInto(src.type_code);
 				return true;
 				}
 			};
@@ -7905,7 +7902,7 @@
 				{
 				//! \todo but signed integers do go undefined in C if left-shifted too much; C++ accepts
 #if 0
-				if (0==(old_type.base_type_index-C_TYPE::INT)%2 && target_machine->C_bit(machine_type)<=rhs_int.to_uint()+lhs_int.int_log2()+1)
+				if (0==(src.type_code.base_type_index-C_TYPE::INT)%2 && target_machine->C_bit(machine_type)<=rhs_int.to_uint()+lhs_int.int_log2()+1)
 					simple_error(src," : result does not fit in LHS type; undefined behavior (C99 6.5.7p3)");
 #endif
 				res_int <<= rhs_int.to_uint();
@@ -7925,15 +7922,17 @@
 				src.DeleteIdx<1>(0);
 				force_unary_negative_literal(src,tmp);
 				}
-			else	// convert to positive literal
-				src = tmp;
-			src.type_code = old_type;
+			else{	// convert to positive literal
+				src.type_code.MoveInto(tmp.type_code);
+				tmp.MoveInto(src);
+				}
 			return true;
 			}
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static void C_shift_expression_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_shift_expression(src));
@@ -7944,6 +7943,7 @@
 	if (eval_shift(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
+//! \throw std::bad_alloc()
 static void CPP_shift_expression_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_shift_expression(src));
@@ -7960,6 +7960,7 @@
 	shift-expression << additive-expression
 	shift-expression >> additive-expression
 */
+//! \throw std::bad_alloc()
 static void locate_C99_shift_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -7978,6 +7979,7 @@
 	shift-expression << additive-expression
 	shift-expression >> additive-expression
 */
+//! \throw std::bad_alloc()
 static void locate_CPP_shift_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -7991,6 +7993,7 @@
 		CPP_shift_expression_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
+//! \throw std::bad_alloc
 static bool terse_locate_relation_expression(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -8167,6 +8170,7 @@
 	relational-expression <= shift-expression
 	relational-expression >= shift-expression
 */
+//! \throw std::bad_alloc
 static void locate_C99_relation_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -8187,6 +8191,7 @@
 	relational-expression <= shift-expression
 	relational-expression >= shift-expression
 */
+//! \throw std::bad_alloc
 static void locate_CPP_relation_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -8200,6 +8205,7 @@
 		CPP_relation_expression_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
+//! \throw std::bad_alloc
 static bool terse_locate_C99_equality_expression(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -8230,6 +8236,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool terse_locate_CPP_equality_expression(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -8407,6 +8414,7 @@
 	equality-expression == relational-expression
 	equality-expression != relational-expression
 */
+//! \throw std::bad_alloc
 static void locate_C99_equality_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -8425,6 +8433,7 @@
 	equality-expression == relational-expression
 	equality-expression != relational-expression
 */
+//! \throw std::bad_alloc
 static void locate_CPP_equality_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -8438,6 +8447,7 @@
 		CPP_equality_expression_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
+//! \throw std::bad_alloc
 static bool terse_locate_C99_bitwise_AND(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -8465,6 +8475,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool terse_locate_CPP_bitwise_AND(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-07 03:39:23 UTC (rev 412)
+++ trunk/CSupport_pp.cpp	2010-05-07 09:52:16 UTC (rev 413)
@@ -1,4 +1,4 @@
-// CSupport_pp.cpp
+// CSupport.cpp
 // support for C/C++ parsing
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
@@ -4603,9 +4603,9 @@
 	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
 		|| !src.data<0>()[i].empty<1>()
 		|| !src.data<0>()[i].empty<2>()
-		|| NULL==src.data<0>()[i].index_tokens[0].token.first) return;
+		|| !src.data<0>()[i].index_tokens[0].token.first) return;
 	
-	if (NULL!=src.data<0>()[i].index_tokens[1].token.first)
+	if (src.data<0>()[i].index_tokens[1].token.first)
 		{
 		if (terse_locate_array_deref(src,i))
 			{
@@ -4683,7 +4683,7 @@
 		|| !src.data<0>()[i].empty<1>()
 		|| !src.data<0>()[i].empty<2>()) return;
 
-	if (NULL!=src.data<0>()[i].index_tokens[1].token.first)
+	if (src.data<0>()[i].index_tokens[1].token.first)
 		{
 		if (terse_locate_array_deref(src,i))
 			{	//! \todo handle operator [] overloading
@@ -4803,6 +4803,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static void assemble_unary_postfix_arguments(parse_tree& src, size_t& i, const size_t _subtype)
 {
 	assert(1<src.size<0>()-i);
@@ -4873,6 +4874,8 @@
 	return dest;
 }
 
+//! usually want to use value_copy rather than MoveInto before this (easier to be ACID)
+//! \throw std::bad_alloc only if dest.type_code.pointer_power<dest.data<2>()->type_code.pointer_power 
 static void force_unary_positive_literal(parse_tree& dest,const parse_tree& src SIG_CONST_TYPES)
 {
 	assert(0==dest.size<0>());
@@ -4902,7 +4905,7 @@
 	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
 	dest.subtype = C99_UNARY_SUBTYPE_NEG;
 	if (converts_to_arithmeticlike(dest.data<2>()->type_code ARG_TYPES))
-		dest.type_code = dest.data<2>()->type_code;	//! \bug doesn't work for enumerators
+		value_copy(dest.type_code,dest.data<2>()->type_code);	//! \bug doesn't work for enumerators
 	// do not handle type here: C++ operator overloading risk
 	assert(dest.index_tokens[0].src_filename);
 	assert(is_C99_unary_operator_expression<'-'>(dest));
@@ -4935,7 +4938,6 @@
 	return converts_to_integerlike(x.type_code ARG_TYPES) && (PARSE_PRIMARY_EXPRESSION & x.flags);
 }
 
-//! \throw std::bad_alloc()
 static bool eval_unary_plus(parse_tree& src, const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'+'>(src));
@@ -4953,7 +4955,7 @@
  	// handle integer-like literals like a real integer literal
 	if (is_integerlike_literal(*src.data<2>() ARG_TYPES))
 		{
-		src.type_code.OverwriteInto(src.c_array<2>()->type_code);
+		src.type_code.MoveInto(src.c_array<2>()->type_code);
 		src.eval_to_arg<2>(0);
 		return true;
 		}
@@ -4985,7 +4987,7 @@
 		POD_pair<char*,lex_flags> new_token;
 		VM_to_token(res_int,src.type_code.base_type_index,new_token);
 		src.c_array<2>()->grab_index_token_from<0>(new_token.first,new_token.second);
-		src.type_code.OverwriteInto(src.c_array<2>()->type_code);
+		src.type_code.MoveInto(src.c_array<2>()->type_code);
 		src.eval_to_arg<2>(0);
 		return true;
 		};
@@ -4994,7 +4996,7 @@
 		assert(converts_to_integerlike(src.data<2>()->data<2>()->type_code ARG_TYPES));
 		parse_tree tmp;
 		src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
-		src.type_code.OverwriteInto(tmp.type_code);
+		src.type_code.MoveInto(tmp.type_code);
 		tmp.MoveInto(src);
 		return true;		
 		}
@@ -5251,6 +5253,7 @@
 		}
 }
 
+//! \throw std::bad_alloc()
 static bool locate_C99_logical_NOT(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5266,6 +5269,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool locate_CPP_logical_NOT(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5427,7 +5431,6 @@
 			return true;
 			}
 
-		const type_spec old_type = src.type_code;
 		parse_tree tmp;
 		VM_to_literal(tmp,res_int,src,types);	// two's-complement non-trapping INT_MIN dies if it gets here
 
@@ -5942,7 +5945,7 @@
 		// convert to parsed + literal
 		parse_tree tmp;
 		VM_to_literal(tmp,res_int,src,types);
-		src.type_code.MoveInto(tmp.type_code);
+		value_copy(tmp.type_code,src.type_code);
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
@@ -5978,7 +5981,7 @@
 				INFORM(" optimized to valid 0");
 				tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
 				}
-			else src.type_code.MoveInto(tmp.type_code);
+			else value_copy(tmp.type_code,src.type_code);
 			src.DeleteIdx<1>(0);
 			force_unary_positive_literal(src,tmp ARG_TYPES);
 			return true;
@@ -6024,7 +6027,7 @@
 				src.DeleteIdx<1>(0);
 				if (want_zero)
 					{
-					src.type_code.MoveInto(tmp.type_code);
+					value_copy(tmp.type_code,src.type_code);
 					force_unary_positive_literal(src,tmp ARG_TYPES); // +0
 					}
 				else	
@@ -6069,7 +6072,7 @@
 		parse_tree tmp;
 		VM_to_literal(tmp,res_int,src,types);
 
-		src.type_code.MoveInto(tmp.type_code);
+		value_copy(tmp.type_code,src.type_code);
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
@@ -6082,7 +6085,6 @@
 {
 	assert(is_C99_mult_operator_expression<'%'>(src));
 
-	const type_spec old_type = src.type_code;
 	bool is_true = false;
 	if (converts_to_integerlike(src.type_code ARG_TYPES))
 		{
@@ -6098,7 +6100,7 @@
 			{
 			// construct +0 to defuse 1-0%6
 			parse_tree tmp = decimal_literal("0",src,types);
-			if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
+			if (C_TYPE::INTEGERLIKE==src.type_code.base_type_index)
 				{
 				message_header(src.index_tokens[0]);
 				INC_INFORM("invalid ");
@@ -6106,7 +6108,7 @@
 				INFORM(" optimized to valid 0");
 				tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
 				}
-			else tmp.type_code = old_type;
+			else value_copy(tmp.type_code,src.type_code);
 			src.DeleteIdx<1>(0);
 			force_unary_positive_literal(src,tmp ARG_TYPES);
 			return true;
@@ -6121,8 +6123,8 @@
 	if (rhs_converted && rhs_int==1)
 		{	// __%1 |-> +0
 		parse_tree tmp = decimal_literal("0",src,types);
-		if (C_TYPE::INTEGERLIKE!=old_type.base_type_index)
-			tmp.type_code = old_type;
+		if (C_TYPE::INTEGERLIKE!=src.type_code.base_type_index)
+			value_copy(tmp.type_code,src.type_code);
 		else
 			tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
 		src.DeleteIdx<1>(0);
@@ -6131,7 +6133,7 @@
 		};
 	if (lhs_converted && rhs_converted)
 		{
-		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
 		assert(old.bitcount>=lhs.bitcount);
 		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
@@ -6164,7 +6166,6 @@
 
 					src.DeleteIdx<1>(0);
 					force_unary_negative_literal(src,tmp);
-					src.type_code = old_type;
 					return true;
 					}
 				};
@@ -6177,8 +6178,8 @@
 		// convert to parsed + literal
 		parse_tree tmp;
 		VM_to_literal(tmp,res_int,src,types);
-		tmp.type_code = old_type;
 
+		value_copy(tmp.type_code,src.type_code);
 		src.DeleteIdx<1>(0);
 		force_unary_positive_literal(src,tmp ARG_TYPES);
 		return true;
@@ -6234,6 +6235,7 @@
 	return true;
 }
 
+//! \throw std::bad_alloc()
 static void C_mult_expression_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(C99_MULT_SUBTYPE_DIV<=src.subtype && C99_MULT_SUBTYPE_MULT>=src.subtype);
@@ -6253,6 +6255,7 @@
 		}
 }
 
+//! \throw std::bad_alloc()
 static void CPP_mult_expression_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(C99_MULT_SUBTYPE_DIV<=src.subtype && C99_MULT_SUBTYPE_MULT>=src.subtype);
@@ -6279,6 +6282,7 @@
 	multiplicative-expression / cast-expression
 	multiplicative-expression % cast-expression
 */
+//! \throw std::bad_alloc()
 static void locate_C99_mult_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6304,6 +6308,7 @@
 	multexpression / pmexpression
 	multexpression % pmexpression
 */
+//! \throw std::bad_alloc()
 static void locate_CPP_mult_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6368,6 +6373,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_C99_augment_add_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6388,6 +6394,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_CPP_augment_add_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -6408,6 +6415,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static bool terse_locate_add_expression(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -6460,18 +6468,14 @@
 			bool is_true = false;
 			if 		(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 				{	// 0 + __ |-> __
-				type_spec old_type;
-				src.type_code.OverwriteInto(old_type);
+				src.type_code.MoveInto(src.c_array<2>()->type_code);
 				src.eval_to_arg<2>(0);
-				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ + 0 |-> __
-				type_spec old_type;
-				src.type_code.OverwriteInto(old_type);
+				src.type_code.MoveInto(src.c_array<1>()->type_code);
 				src.eval_to_arg<1>(0);
-				old_type.MoveInto(src.type_code);
 				return true;
 				};
 			umaxint res_int;
@@ -6538,11 +6542,8 @@
 						parse_tree tmp;
 						VM_to_literal(tmp,lhs_test,src,types);
 
-						type_spec old_type;
-						src.type_code.OverwriteInto(old_type);
 						src.DeleteIdx<1>(0);
 						force_unary_negative_literal(src,tmp);
-						old_type.MoveInto(src.type_code);
 						return true;
 						};
 					res_int = lhs_test;
@@ -6553,7 +6554,7 @@
 				// convert to parsed + literal
 				parse_tree tmp;
 				VM_to_literal(tmp,res_int,src,types);
-				src.type_code.MoveInto(tmp.type_code);
+				value_copy(tmp.type_code,src.type_code);
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp ARG_TYPES);
 				return true;
@@ -6565,10 +6566,8 @@
 			bool is_true = false;
 			if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ + 0 |-> __
-				type_spec old_type;
-				src.type_code.OverwriteInto(old_type);
+				src.type_code.MoveInto(src.c_array<1>()->type_code);
 				src.eval_to_arg<1>(0);
-				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			break;
@@ -6578,10 +6577,8 @@
 			bool is_true = false;
 			if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
 				{	// 0 + __ |-> __
-				type_spec old_type;
-				src.type_code.OverwriteInto(old_type);
+				src.type_code.MoveInto(src.c_array<2>()->type_code);
 				src.eval_to_arg<2>(0);
-				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			break;
@@ -6623,10 +6620,8 @@
 				}
 			else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ - 0 |-> __
-				type_spec old_type;
-				src.type_code.OverwriteInto(old_type);
+				src.type_code.MoveInto(src.c_array<1>()->type_code);
 				src.eval_to_arg<1>(0);
-				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			umaxint res_int;
@@ -6694,11 +6689,8 @@
 						// convert to parsed - literal
 						parse_tree tmp;
 						VM_to_literal(tmp,lhs_test,src,types);
-						type_spec old_type;
-						src.type_code.OverwriteInto(old_type);
 						src.DeleteIdx<1>(0);
 						force_unary_negative_literal(src,tmp);
-						old_type.MoveInto(src.type_code);
 						return true;
 						};
 					res_int = lhs_test;
@@ -6709,7 +6701,7 @@
 				// convert to parsed + literal
 				parse_tree tmp;
 				VM_to_literal(tmp,res_int,src,types);
-				src.type_code.MoveInto(tmp.type_code);
+				value_copy(tmp.type_code,src.type_code);
 				src.DeleteIdx<1>(0);
 				force_unary_positive_literal(src,tmp ARG_TYPES);
 				return true;
@@ -6721,10 +6713,8 @@
 			bool is_true = false;
 			if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 				{	// __ - 0 |-> __
-				type_spec old_type;
-				src.type_code.OverwriteInto(old_type);
+				src.type_code.MoveInto(src.c_array<1>()->type_code);
 				src.eval_to_arg<1>(0);
-				old_type.MoveInto(src.type_code);
 				return true;
 				}
 			break;
@@ -7015,14 +7005,13 @@
 	// __ >> 0 |-> __
 	// two integer literals
 	// error if RHS is literal "out of bounds"
-	const type_spec old_type = src.type_code;
 	bool is_true = false;
 	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 		{
 		if (!is_true)
 			{	// __ << 0 or __ >> 0: lift
+			src.type_code.MoveInto(src.c_array<1>()->type_code);
 			src.eval_to_arg<1>(0);
-			src.type_code = old_type;
 			return true;
 			}
 		};
@@ -7030,7 +7019,7 @@
 	umaxint rhs_int;
 	if (intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
-		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(old_type.base_type_index);
+		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
 		const bool undefined_behavior = target_machine->C_bit(machine_type)<=rhs_int;
 
 		//! \todo can't test with static test case (need to use bitcount of uintmax_t/intmax_t)
@@ -7041,8 +7030,10 @@
 			{
 			if (!is_true)
 				{	// 0 << __ or 0 >> __: zero out (note that we can do this even if we invoked undefined behavior)
+				type_spec tmp;
+				src.type_code.OverwriteInto(tmp);
 				force_decimal_literal(src,"0",types);
-				src.type_code = old_type;
+				tmp.MoveInto(src.type_code);
 				return true;
 				}
 			};
@@ -7056,7 +7047,7 @@
 				{
 				//! \todo but signed integers do go undefined in C if left-shifted too much; C++ accepts
 #if 0
-				if (0==(old_type.base_type_index-C_TYPE::INT)%2 && target_machine->C_bit(machine_type)<=rhs_int.to_uint()+lhs_int.int_log2()+1)
+				if (0==(src.type_code.base_type_index-C_TYPE::INT)%2 && target_machine->C_bit(machine_type)<=rhs_int.to_uint()+lhs_int.int_log2()+1)
 					simple_error(src," : result does not fit in LHS type; undefined behavior (C99 6.5.7p3)");
 #endif
 				res_int <<= rhs_int.to_uint();
@@ -7076,15 +7067,17 @@
 				src.DeleteIdx<1>(0);
 				force_unary_negative_literal(src,tmp);
 				}
-			else	// convert to positive literal
-				src = tmp;
-			src.type_code = old_type;
+			else{	// convert to positive literal
+				src.type_code.MoveInto(tmp.type_code);
+				tmp.MoveInto(src);
+				}
 			return true;
 			}
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static void C_shift_expression_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_shift_expression(src));
@@ -7095,6 +7088,7 @@
 	if (eval_shift(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
+//! \throw std::bad_alloc()
 static void CPP_shift_expression_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_shift_expression(src));
@@ -7111,6 +7105,7 @@
 	shift-expression << additive-expression
 	shift-expression >> additive-expression
 */
+//! \throw std::bad_alloc()
 static void locate_C99_shift_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -7129,6 +7124,7 @@
 	shift-expression << additive-expression
 	shift-expression >> additive-expression
 */
+//! \throw std::bad_alloc()
 static void locate_CPP_shift_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -7142,6 +7138,7 @@
 		CPP_shift_expression_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
+//! \throw std::bad_alloc
 static bool terse_locate_relation_expression(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -7318,6 +7315,7 @@
 	relational-expression <= shift-expression
 	relational-expression >= shift-expression
 */
+//! \throw std::bad_alloc
 static void locate_C99_relation_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -7338,6 +7336,7 @@
 	relational-expression <= shift-expression
 	relational-expression >= shift-expression
 */
+//! \throw std::bad_alloc
 static void locate_CPP_relation_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -7351,6 +7350,7 @@
 		CPP_relation_expression_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
+//! \throw std::bad_alloc
 static bool terse_locate_C99_equality_expression(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -7381,6 +7381,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool terse_locate_CPP_equality_expression(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -7558,6 +7559,7 @@
 	equality-expression == relational-expression
 	equality-expression != relational-expression
 */
+//! \throw std::bad_alloc
 static void locate_C99_equality_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -7576,6 +7578,7 @@
 	equality-expression == relational-expression
 	equality-expression != relational-expression
 */
+//! \throw std::bad_alloc
 static void locate_CPP_equality_expression(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -7589,6 +7592,7 @@
 		CPP_equality_expression_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
+//! \throw std::bad_alloc
 static bool terse_locate_C99_bitwise_AND(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -7616,6 +7620,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool terse_locate_CPP_bitwise_AND(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());

Modified: trunk/type_spec.cpp
===================================================================
--- trunk/type_spec.cpp	2010-05-07 03:39:23 UTC (rev 412)
+++ trunk/type_spec.cpp	2010-05-07 09:52:16 UTC (rev 413)
@@ -115,6 +115,7 @@
 	return true;
 }
 
+//! \throw std::bad_alloc only if pointer_power-1>dest.pointer_power
 bool type_spec::dereference(type_spec& dest) const
 {
 #ifndef ZAIMONI_FORCE_ISO



From zaimoni at mail.berlios.de  Sat May  8 00:05:16 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 8 May 2010 00:05:16 +0200
Subject: [Zcplusplus-commits] r414 - trunk
Message-ID: <201005072205.o47M5Gm5015764@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-08 00:05:11 +0200 (Sat, 08 May 2010)
New Revision: 414

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
more exception-safety enhancements

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-07 09:52:16 UTC (rev 413)
+++ trunk/CSupport.cpp	2010-05-07 22:05:11 UTC (rev 414)
@@ -8475,7 +8475,6 @@
 	return false;
 }
 
-//! \throw std::bad_alloc
 static bool terse_locate_CPP_bitwise_AND(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -8511,23 +8510,25 @@
 	// 0 & __ |-> 0
 	// int-literal | int-literal |-> int-literal *if* both fit
 	// unary - gives us problems (result is target-specific, could generate a trap representation)
-	const type_spec old_type = src.type_code;
 	bool is_true = false;
 	if (	(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)	// 0 & __
 		||	(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true))	// __ & 0
 		{
-		if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
+		if (C_TYPE::INTEGERLIKE==src.type_code.base_type_index)
 			{
 			message_header(src.index_tokens[0]);
 			INC_INFORM("invalid ");
 			INC_INFORM(src);
 			INFORM(" optimized to valid 0");
-			};
-		force_decimal_literal(src,"0",types);
-		if (C_TYPE::INTEGERLIKE!=old_type.base_type_index)
-			src.type_code = old_type;
-		else
+			force_decimal_literal(src,"0",types);
 			src.type_code.set_type(C_TYPE::LLONG);	// legalize
+			}
+		else{
+			type_spec tmp;
+			src.type_code.OverwriteInto(tmp);
+			force_decimal_literal(src,"0",types);
+			tmp.MoveInto(src.type_code);
+			}
 		return true;
 		};
 
@@ -8535,7 +8536,7 @@
 	umaxint rhs_int;
 	if (intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES) && intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
-		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		umaxint res_int(lhs_int);
 		res_int &= rhs_int;
 
@@ -8544,28 +8545,26 @@
 
 		if 		(res_int==lhs_int)
 			// lhs & rhs = lhs; conserve type
-#/*cut-cpp*/
 			{
+#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
 #/*cut-cpp*/
+			src.type_code.MoveInto(src.c_array<1>()->type_code);
 			src.eval_to_arg<1>(0);
-#/*cut-cpp*/
 			}
-#/*cut-cpp*/
 		else if (res_int==rhs_int)
 			// lhs & rhs = rhs; conserve type
-#/*cut-cpp*/
 			{
+#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<2>(),types))
 				enumerator_to_integer_representation(*src.c_array<2>(),types);
 #/*cut-cpp*/
+			src.type_code.MoveInto(src.c_array<2>()->type_code);
 			src.eval_to_arg<2>(0);
-#/*cut-cpp*/
 			}
-#/*cut-cpp*/
 		else{
 			const bool negative_signed_int = old.is_signed && res_int.test(old.bitcount-1);
 			if (negative_signed_int) target_machine->signed_additive_inverse(res_int,old.machine_type);
@@ -8574,28 +8573,21 @@
 				&& 	!bool_options[boolopt::int_traps]
 				&&	res_int>target_machine->signed_max(old.machine_type))
 				{	// trap representation; need to get it into -INT_MAX-1 form
-				try {
-					construct_twos_complement_int_min(src,types,old.machine_type,src);
-					}
-				catch(const std::bad_alloc&)
-					{
-					return false;
-					}
-				src.type_code = old_type;
+				construct_twos_complement_int_min(src,types,old.machine_type,src);
 				return true;
 				}
 
 			parse_tree tmp;
 			VM_to_signed_literal(tmp,negative_signed_int,res_int,src,types);
-			src.destroy();
-			src = tmp;
+			src.type_code.MoveInto(tmp.type_code);
+			tmp.MoveInto(src);
 			}
-		src.type_code = old_type;
 		return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static void C_bitwise_AND_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_bitwise_AND_expression(src));
@@ -8606,6 +8598,7 @@
 	if (eval_bitwise_AND(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
+//! \throw std::bad_alloc
 static void CPP_bitwise_AND_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_CPP_bitwise_AND_expression(src));
@@ -8621,6 +8614,7 @@
 	equality-expression
 	AND-expression & equality-expression
 */
+//! \throw std::bad_alloc
 static void locate_C99_bitwise_AND(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -8638,6 +8632,7 @@
 	equality-expression
 	AND-expression & equality-expression
 */
+//! \throw std::bad_alloc
 static void locate_CPP_bitwise_AND(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -8723,7 +8718,7 @@
 				enumerator_to_integer_representation(*src.c_array<2>(),types);
 #/*cut-cpp*/
 			src.eval_to_arg<2>(0);
-			//! \todo convert char literal to appropriate integer
+			//! \bug convert char literal to appropriate integer
 			return true;
 			}
 		};
@@ -8737,7 +8732,7 @@
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
 #/*cut-cpp*/
 			src.eval_to_arg<1>(0);
-			//! \todo convert char literal to appropriate integer
+			//! \bug convert char literal to appropriate integer
 			return true;
 			}
 		};
@@ -8746,8 +8741,7 @@
 	umaxint rhs_int;
 	if (intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES) && intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
-		const type_spec old_type = src.type_code;
-		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		umaxint res_int(lhs_int);
 		res_int ^= rhs_int;
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
@@ -8761,27 +8755,20 @@
 			&& 	!bool_options[boolopt::int_traps]
 			&&	res_int>target_machine->signed_max(old.machine_type))
 			{	// trap representation; need to get it into -INT_MAX-1 form
-			try {
-				construct_twos_complement_int_min(src,types,old.machine_type,src);
-				}
-			catch(const std::bad_alloc&)
-				{
-				return false;
-				}
-			src.type_code = old_type;
+			construct_twos_complement_int_min(src,types,old.machine_type,src);
 			return true;
 			}
 
 		parse_tree tmp;
 		VM_to_signed_literal(tmp,negative_signed_int,res_int,src,types);
-		src.destroy();
-		src = tmp;
-		src.type_code = old_type;
+		src.type_code.MoveInto(tmp.type_code);
+		tmp.MoveInto(src);
 		return true;
 		}
 	return false;
 }
 
+// throws std::bad_alloc
 static void C_bitwise_XOR_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_bitwise_XOR_expression(src));
@@ -8792,6 +8779,7 @@
 	if (eval_bitwise_XOR(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
+// throws std::bad_alloc
 static void CPP_bitwise_XOR_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_CPP_bitwise_XOR_expression(src));
@@ -8807,6 +8795,7 @@
 	AND-expression
 	exclusive-OR-expression ^ AND-expression
 */
+// throws std::bad_alloc
 static void locate_C99_bitwise_XOR(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -8823,6 +8812,7 @@
 	AND-expression
 	exclusive-OR-expression ^ AND-expression
 */
+// throws std::bad_alloc
 static void locate_CPP_bitwise_XOR(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -8908,7 +8898,7 @@
 				enumerator_to_integer_representation(*src.c_array<2>(),types);
 #/*cut-cpp*/
 			src.eval_to_arg<2>(0);
-			//! \todo convert char literal to appropriate integer
+			//! \bug convert char literal to appropriate integer
 			return true;
 			}
 		};
@@ -8922,7 +8912,7 @@
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
 #/*cut-cpp*/
 			src.eval_to_arg<1>(0);
-			//! \todo convert char literal to appropriate integer
+			//! \bug convert char literal to appropriate integer
 			return true;
 			}
 		};
@@ -8931,35 +8921,32 @@
 	umaxint rhs_int;
 	if (intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES) && intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
-		const type_spec old_type = src.type_code;
 		umaxint res_int(lhs_int);
 
 		res_int |= rhs_int;
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
 		if 		(res_int==lhs_int)
 			// lhs | rhs = lhs; conserve type
-#/*cut-cpp*/
 			{
+#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
 #/*cut-cpp*/
+			src.type_code.MoveInto(src.c_array<1>()->type_code);
 			src.eval_to_arg<1>(0);
-#/*cut-cpp*/
 			}
-#/*cut-cpp*/
 		else if (res_int==rhs_int)
 			// lhs | rhs = rhs; conserve type
-#/*cut-cpp*/
 			{
+#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
 #/*cut-cpp*/
+			src.type_code.MoveInto(src.c_array<2>()->type_code);
 			src.eval_to_arg<2>(0);
-#/*cut-cpp*/
 			}
-#/*cut-cpp*/
 		else{
 			if (int_has_trapped(src,res_int,hard_error)) return false;
 
@@ -8974,15 +8961,17 @@
 				src.DeleteIdx<1>(0);
 				force_unary_negative_literal(src,tmp);
 				}
-			else	// convert to positive literal
+			else{	// convert to positive literal
+				src.type_code.MoveInto(tmp.type_code);
 				tmp.MoveInto(src);
+				}
 			}
-		src.type_code = old_type;
 		return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static void C_bitwise_OR_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_bitwise_OR_expression(src));
@@ -8993,6 +8982,7 @@
 	if (eval_bitwise_OR(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
+//! \throw std::bad_alloc()
 static void CPP_bitwise_OR_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_CPP_bitwise_OR_expression(src));
@@ -9008,6 +8998,7 @@
 	exclusive-OR-expression
 	inclusive-OR-expression | exclusive-OR-expression
 */
+//! \throw std::bad_alloc()
 static void locate_C99_bitwise_OR(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -9025,6 +9016,7 @@
 	exclusive-OR-expression
 	inclusive-OR-expression | exclusive-OR-expression
 */
+//! \throw std::bad_alloc()
 static void locate_CPP_bitwise_OR(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -9041,17 +9033,19 @@
 static bool binary_infix_failed_boolean_arguments(parse_tree& src, const char* standard SIG_CONST_TYPES)
 {	//! \todo so the error message isn't technically right...convertible to bool in C++ is morally equivalent to scalar in C
 	// cannot test this within preprocessor
-	assert(NULL!=standard);
+	assert(standard && *standard);
 
 	const bool rhs_converts_to_bool =  converts_to_bool(src.data<2>()->type_code ARG_TYPES);
 	if (!converts_to_bool(src.data<1>()->type_code ARG_TYPES))
 		{
-		simple_error(src,rhs_converts_to_bool ? " has nonscalar LHS " : " has nonscalar LHS and RHS ");
+		simple_error(src,rhs_converts_to_bool ? " has nonscalar LHS" : " has nonscalar LHS and RHS");
+		INFORM(standard);
 		return true;
 		}
 	else if (!rhs_converts_to_bool)
 		{
-		simple_error(src," has nonscalar RHS ");
+		simple_error(src," has nonscalar RHS");
+		INFORM(standard);
 		return true;
 		}
 	return false;
@@ -9322,7 +9316,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_C99_logical_OR(src,i)) C_logical_OR_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_C99_logical_OR(src,i))
+		C_logical_OR_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 /*
@@ -9343,6 +9338,7 @@
 		CPP_logical_OR_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
+//! \throw std::bad_alloc
 static bool terse_locate_conditional_op(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -9365,23 +9361,22 @@
 				&&	(PARSE_EXPRESSION & src.data<0>()[i+1].flags)
 				&&	(PARSE_CONDITIONAL_EXPRESSION & src.data<0>()[i+3].flags))
 				{
-				parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
-				*tmp = tmp_c_array[0];
-				parse_tree* const tmp2 = repurpose_inner_parentheses(tmp_c_array[2]);	// RAM conservation
-				*tmp2 = tmp_c_array[2];
+				zaimoni::autoval_ptr<parse_tree> tmp;
+				zaimoni::autoval_ptr<parse_tree> tmp2;
+				tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
+				tmp2 = repurpose_inner_parentheses(tmp_c_array[2]);	// RAM conservation
 				parse_tree* const tmp3 = repurpose_inner_parentheses(tmp_c_array[4]);	// RAM conservation
-				*tmp3 = tmp_c_array[4];
+				tmp_c_array[0].OverwriteInto(*tmp);
+				tmp_c_array[2].OverwriteInto(*tmp2);
+				tmp_c_array[4].OverwriteInto(*tmp3);
 				tmp_c_array[1].grab_index_token_from<1,0>(tmp_c_array[3]);
 				tmp_c_array[1].grab_index_token_location_from<1,0>(tmp_c_array[3]);
-				tmp_c_array[1].fast_set_arg<0>(tmp2);
-				tmp_c_array[1].fast_set_arg<1>(tmp);
+				tmp_c_array[1].fast_set_arg<0>(tmp2.release());
+				tmp_c_array[1].fast_set_arg<1>(tmp.release());
 				tmp_c_array[1].fast_set_arg<2>(tmp3);
 				tmp_c_array[1].core_flag_update();
 				tmp_c_array[1].flags |= PARSE_STRICT_CONDITIONAL_EXPRESSION;
-				tmp_c_array[0].clear();
-				tmp_c_array[2].clear();
-				tmp_c_array[3].clear();
-				tmp_c_array[4].clear();
+				tmp_c_array[3].destroy();
 				src.DeleteNSlotsAt<0>(3,i+1);	// tmp_c_array becomes invalid here
 				src.DeleteIdx<0>(--i);
 				assert(is_C99_conditional_operator_expression_strict(src.data<0>()[i]));
@@ -9403,22 +9398,21 @@
 	if (literal_converts_to_bool(*src.c_array<1>(),is_true ARG_TYPES))
 		{
 		const bool was_invalid = src.flags & parse_tree::INVALID;
-		type_spec old_type;
-		src.type_code.OverwriteInto(old_type);
 		if (is_true)
-			// it's the infix arg
+			{	// it's the infix arg
+			src.type_code.MoveInto(src.c_array<0>()->type_code);
 			src.eval_to_arg<0>(0);
-		else	// it's the postfix arg
+			}
+		else{	// it's the postfix arg
+			src.type_code.MoveInto(src.c_array<2>()->type_code);
 			src.eval_to_arg<2>(0);
+			};
 		if (was_invalid && !(src.flags & parse_tree::INVALID))
 			{
-			old_type.destroy();
 			message_header(src.index_tokens[0]);
 			INC_INFORM("invalid ? : operator optimized to valid ");
 			INFORM(src);
 			}
-		else
-			old_type.MoveInto(src.type_code);
 		return true;
 		}
 	return false;

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-07 09:52:16 UTC (rev 413)
+++ trunk/CSupport_pp.cpp	2010-05-07 22:05:11 UTC (rev 414)
@@ -7620,7 +7620,6 @@
 	return false;
 }
 
-//! \throw std::bad_alloc
 static bool terse_locate_CPP_bitwise_AND(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -7656,23 +7655,25 @@
 	// 0 & __ |-> 0
 	// int-literal | int-literal |-> int-literal *if* both fit
 	// unary - gives us problems (result is target-specific, could generate a trap representation)
-	const type_spec old_type = src.type_code;
 	bool is_true = false;
 	if (	(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)	// 0 & __
 		||	(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true))	// __ & 0
 		{
-		if (C_TYPE::INTEGERLIKE==old_type.base_type_index)
+		if (C_TYPE::INTEGERLIKE==src.type_code.base_type_index)
 			{
 			message_header(src.index_tokens[0]);
 			INC_INFORM("invalid ");
 			INC_INFORM(src);
 			INFORM(" optimized to valid 0");
-			};
-		force_decimal_literal(src,"0",types);
-		if (C_TYPE::INTEGERLIKE!=old_type.base_type_index)
-			src.type_code = old_type;
-		else
+			force_decimal_literal(src,"0",types);
 			src.type_code.set_type(C_TYPE::LLONG);	// legalize
+			}
+		else{
+			type_spec tmp;
+			src.type_code.OverwriteInto(tmp);
+			force_decimal_literal(src,"0",types);
+			tmp.MoveInto(src.type_code);
+			}
 		return true;
 		};
 
@@ -7680,7 +7681,7 @@
 	umaxint rhs_int;
 	if (intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES) && intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
-		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		umaxint res_int(lhs_int);
 		res_int &= rhs_int;
 
@@ -7689,10 +7690,16 @@
 
 		if 		(res_int==lhs_int)
 			// lhs & rhs = lhs; conserve type
+			{
+			src.type_code.MoveInto(src.c_array<1>()->type_code);
 			src.eval_to_arg<1>(0);
+			}
 		else if (res_int==rhs_int)
 			// lhs & rhs = rhs; conserve type
+			{
+			src.type_code.MoveInto(src.c_array<2>()->type_code);
 			src.eval_to_arg<2>(0);
+			}
 		else{
 			const bool negative_signed_int = old.is_signed && res_int.test(old.bitcount-1);
 			if (negative_signed_int) target_machine->signed_additive_inverse(res_int,old.machine_type);
@@ -7701,28 +7708,21 @@
 				&& 	!bool_options[boolopt::int_traps]
 				&&	res_int>target_machine->signed_max(old.machine_type))
 				{	// trap representation; need to get it into -INT_MAX-1 form
-				try {
-					construct_twos_complement_int_min(src,types,old.machine_type,src);
-					}
-				catch(const std::bad_alloc&)
-					{
-					return false;
-					}
-				src.type_code = old_type;
+				construct_twos_complement_int_min(src,types,old.machine_type,src);
 				return true;
 				}
 
 			parse_tree tmp;
 			VM_to_signed_literal(tmp,negative_signed_int,res_int,src,types);
-			src.destroy();
-			src = tmp;
+			src.type_code.MoveInto(tmp.type_code);
+			tmp.MoveInto(src);
 			}
-		src.type_code = old_type;
 		return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static void C_bitwise_AND_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_bitwise_AND_expression(src));
@@ -7733,6 +7733,7 @@
 	if (eval_bitwise_AND(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
+//! \throw std::bad_alloc
 static void CPP_bitwise_AND_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_CPP_bitwise_AND_expression(src));
@@ -7748,6 +7749,7 @@
 	equality-expression
 	AND-expression & equality-expression
 */
+//! \throw std::bad_alloc
 static void locate_C99_bitwise_AND(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -7765,6 +7767,7 @@
 	equality-expression
 	AND-expression & equality-expression
 */
+//! \throw std::bad_alloc
 static void locate_CPP_bitwise_AND(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -7845,7 +7848,7 @@
 		if (!is_true)
 			{	// 0 ^ __
 			src.eval_to_arg<2>(0);
-			//! \todo convert char literal to appropriate integer
+			//! \bug convert char literal to appropriate integer
 			return true;
 			}
 		};
@@ -7854,7 +7857,7 @@
 		if (!is_true)
 			{	// __ ^ 0
 			src.eval_to_arg<1>(0);
-			//! \todo convert char literal to appropriate integer
+			//! \bug convert char literal to appropriate integer
 			return true;
 			}
 		};
@@ -7863,8 +7866,7 @@
 	umaxint rhs_int;
 	if (intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES) && intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
-		const type_spec old_type = src.type_code;
-		const promote_aux old(old_type.base_type_index ARG_TYPES);
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
 		umaxint res_int(lhs_int);
 		res_int ^= rhs_int;
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
@@ -7878,27 +7880,20 @@
 			&& 	!bool_options[boolopt::int_traps]
 			&&	res_int>target_machine->signed_max(old.machine_type))
 			{	// trap representation; need to get it into -INT_MAX-1 form
-			try {
-				construct_twos_complement_int_min(src,types,old.machine_type,src);
-				}
-			catch(const std::bad_alloc&)
-				{
-				return false;
-				}
-			src.type_code = old_type;
+			construct_twos_complement_int_min(src,types,old.machine_type,src);
 			return true;
 			}
 
 		parse_tree tmp;
 		VM_to_signed_literal(tmp,negative_signed_int,res_int,src,types);
-		src.destroy();
-		src = tmp;
-		src.type_code = old_type;
+		src.type_code.MoveInto(tmp.type_code);
+		tmp.MoveInto(src);
 		return true;
 		}
 	return false;
 }
 
+// throws std::bad_alloc
 static void C_bitwise_XOR_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_bitwise_XOR_expression(src));
@@ -7909,6 +7904,7 @@
 	if (eval_bitwise_XOR(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
+// throws std::bad_alloc
 static void CPP_bitwise_XOR_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_CPP_bitwise_XOR_expression(src));
@@ -7924,6 +7920,7 @@
 	AND-expression
 	exclusive-OR-expression ^ AND-expression
 */
+// throws std::bad_alloc
 static void locate_C99_bitwise_XOR(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -7940,6 +7937,7 @@
 	AND-expression
 	exclusive-OR-expression ^ AND-expression
 */
+// throws std::bad_alloc
 static void locate_CPP_bitwise_XOR(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -8020,7 +8018,7 @@
 		if (!is_true)
 			{	// 0 | __
 			src.eval_to_arg<2>(0);
-			//! \todo convert char literal to appropriate integer
+			//! \bug convert char literal to appropriate integer
 			return true;
 			}
 		};
@@ -8029,7 +8027,7 @@
 		if (!is_true)
 			{	// __ | 0
 			src.eval_to_arg<1>(0);
-			//! \todo convert char literal to appropriate integer
+			//! \bug convert char literal to appropriate integer
 			return true;
 			}
 		};
@@ -8038,17 +8036,22 @@
 	umaxint rhs_int;
 	if (intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES) && intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
 		{
-		const type_spec old_type = src.type_code;
 		umaxint res_int(lhs_int);
 
 		res_int |= rhs_int;
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
 		if 		(res_int==lhs_int)
 			// lhs | rhs = lhs; conserve type
+			{
+			src.type_code.MoveInto(src.c_array<1>()->type_code);
 			src.eval_to_arg<1>(0);
+			}
 		else if (res_int==rhs_int)
 			// lhs | rhs = rhs; conserve type
+			{
+			src.type_code.MoveInto(src.c_array<2>()->type_code);
 			src.eval_to_arg<2>(0);
+			}
 		else{
 			if (int_has_trapped(src,res_int,hard_error)) return false;
 
@@ -8063,15 +8066,17 @@
 				src.DeleteIdx<1>(0);
 				force_unary_negative_literal(src,tmp);
 				}
-			else	// convert to positive literal
+			else{	// convert to positive literal
+				src.type_code.MoveInto(tmp.type_code);
 				tmp.MoveInto(src);
+				}
 			}
-		src.type_code = old_type;
 		return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc()
 static void C_bitwise_OR_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_bitwise_OR_expression(src));
@@ -8082,6 +8087,7 @@
 	if (eval_bitwise_OR(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
+//! \throw std::bad_alloc()
 static void CPP_bitwise_OR_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_CPP_bitwise_OR_expression(src));
@@ -8097,6 +8103,7 @@
 	exclusive-OR-expression
 	inclusive-OR-expression | exclusive-OR-expression
 */
+//! \throw std::bad_alloc()
 static void locate_C99_bitwise_OR(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -8114,6 +8121,7 @@
 	exclusive-OR-expression
 	inclusive-OR-expression | exclusive-OR-expression
 */
+//! \throw std::bad_alloc()
 static void locate_CPP_bitwise_OR(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -8130,17 +8138,19 @@
 static bool binary_infix_failed_boolean_arguments(parse_tree& src, const char* standard SIG_CONST_TYPES)
 {	//! \todo so the error message isn't technically right...convertible to bool in C++ is morally equivalent to scalar in C
 	// cannot test this within preprocessor
-	assert(NULL!=standard);
+	assert(standard && *standard);
 
 	const bool rhs_converts_to_bool =  converts_to_bool(src.data<2>()->type_code ARG_TYPES);
 	if (!converts_to_bool(src.data<1>()->type_code ARG_TYPES))
 		{
-		simple_error(src,rhs_converts_to_bool ? " has nonscalar LHS " : " has nonscalar LHS and RHS ");
+		simple_error(src,rhs_converts_to_bool ? " has nonscalar LHS" : " has nonscalar LHS and RHS");
+		INFORM(standard);
 		return true;
 		}
 	else if (!rhs_converts_to_bool)
 		{
-		simple_error(src," has nonscalar RHS ");
+		simple_error(src," has nonscalar RHS");
+		INFORM(standard);
 		return true;
 		}
 	return false;
@@ -8411,7 +8421,8 @@
 		|| !src.data<0>()[i].is_atomic())
 		return;
 
-	if (terse_locate_C99_logical_OR(src,i)) C_logical_OR_easy_syntax_check(src.c_array<0>()[i],types);
+	if (terse_locate_C99_logical_OR(src,i))
+		C_logical_OR_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
 /*
@@ -8432,6 +8443,7 @@
 		CPP_logical_OR_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
+//! \throw std::bad_alloc
 static bool terse_locate_conditional_op(parse_tree& src, size_t& i)
 {
 	assert(!src.empty<0>());
@@ -8454,23 +8466,22 @@
 				&&	(PARSE_EXPRESSION & src.data<0>()[i+1].flags)
 				&&	(PARSE_CONDITIONAL_EXPRESSION & src.data<0>()[i+3].flags))
 				{
-				parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
-				*tmp = tmp_c_array[0];
-				parse_tree* const tmp2 = repurpose_inner_parentheses(tmp_c_array[2]);	// RAM conservation
-				*tmp2 = tmp_c_array[2];
+				zaimoni::autoval_ptr<parse_tree> tmp;
+				zaimoni::autoval_ptr<parse_tree> tmp2;
+				tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
+				tmp2 = repurpose_inner_parentheses(tmp_c_array[2]);	// RAM conservation
 				parse_tree* const tmp3 = repurpose_inner_parentheses(tmp_c_array[4]);	// RAM conservation
-				*tmp3 = tmp_c_array[4];
+				tmp_c_array[0].OverwriteInto(*tmp);
+				tmp_c_array[2].OverwriteInto(*tmp2);
+				tmp_c_array[4].OverwriteInto(*tmp3);
 				tmp_c_array[1].grab_index_token_from<1,0>(tmp_c_array[3]);
 				tmp_c_array[1].grab_index_token_location_from<1,0>(tmp_c_array[3]);
-				tmp_c_array[1].fast_set_arg<0>(tmp2);
-				tmp_c_array[1].fast_set_arg<1>(tmp);
+				tmp_c_array[1].fast_set_arg<0>(tmp2.release());
+				tmp_c_array[1].fast_set_arg<1>(tmp.release());
 				tmp_c_array[1].fast_set_arg<2>(tmp3);
 				tmp_c_array[1].core_flag_update();
 				tmp_c_array[1].flags |= PARSE_STRICT_CONDITIONAL_EXPRESSION;
-				tmp_c_array[0].clear();
-				tmp_c_array[2].clear();
-				tmp_c_array[3].clear();
-				tmp_c_array[4].clear();
+				tmp_c_array[3].destroy();
 				src.DeleteNSlotsAt<0>(3,i+1);	// tmp_c_array becomes invalid here
 				src.DeleteIdx<0>(--i);
 				assert(is_C99_conditional_operator_expression_strict(src.data<0>()[i]));
@@ -8492,22 +8503,21 @@
 	if (literal_converts_to_bool(*src.c_array<1>(),is_true ARG_TYPES))
 		{
 		const bool was_invalid = src.flags & parse_tree::INVALID;
-		type_spec old_type;
-		src.type_code.OverwriteInto(old_type);
 		if (is_true)
-			// it's the infix arg
+			{	// it's the infix arg
+			src.type_code.MoveInto(src.c_array<0>()->type_code);
 			src.eval_to_arg<0>(0);
-		else	// it's the postfix arg
+			}
+		else{	// it's the postfix arg
+			src.type_code.MoveInto(src.c_array<2>()->type_code);
 			src.eval_to_arg<2>(0);
+			};
 		if (was_invalid && !(src.flags & parse_tree::INVALID))
 			{
-			old_type.destroy();
 			message_header(src.index_tokens[0]);
 			INC_INFORM("invalid ? : operator optimized to valid ");
 			INFORM(src);
 			}
-		else
-			old_type.MoveInto(src.type_code);
 		return true;
 		}
 	return false;



From zaimoni at mail.berlios.de  Sat May  8 01:27:30 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 8 May 2010 01:27:30 +0200
Subject: [Zcplusplus-commits] r415 - trunk
Message-ID: <201005072327.o47NRUIE025402@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-08 01:27:25 +0200 (Sat, 08 May 2010)
New Revision: 415

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
more std::bad_alloc hardening

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-07 22:05:11 UTC (rev 414)
+++ trunk/CSupport.cpp	2010-05-07 23:27:25 UTC (rev 415)
@@ -9418,6 +9418,7 @@
 	return false;
 }
 
+//! \throws std::bad_alloc
 static void C_conditional_op_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_conditional_operator_expression(src));
@@ -9505,6 +9506,7 @@
 	if (eval_conditional_op(src,C99_literal_converts_to_bool ARG_TYPES)) return;
 }
 
+//! \throws std::bad_alloc
 static void CPP_conditional_op_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_conditional_operator_expression(src));
@@ -9594,6 +9596,7 @@
 	if (eval_conditional_op(src,CPP_literal_converts_to_bool ARG_TYPES)) return;
 }
 
+//! \throws std::bad_alloc
 static void locate_C99_conditional_op(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -9606,6 +9609,7 @@
 		C_conditional_op_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
+//! \throws std::bad_alloc
 static void locate_CPP_conditional_op(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -9649,16 +9653,53 @@
 }
 
 // top-level has SIZE_MAX for parent_identifier_count
+//! \throws std::bad_alloc
 static void C99_locate_expressions(parse_tree& src,const size_t parent_identifier_count,const type_system& types)
 {
 	if (PARSE_OBVIOUS & src.flags) return;
 	size_t identifier_count = (0==parent_identifier_count) ? 0 : _count_identifiers(src);
-	size_t i = src.size<0>();
-	while(0<i) C99_locate_expressions(src.c_array<0>()[--i],identifier_count,types);
-	i = src.size<1>();
-	while(0<i) C99_locate_expressions(src.c_array<1>()[--i],identifier_count,types);
-	i = src.size<2>();
-	while(0<i) C99_locate_expressions(src.c_array<2>()[--i],identifier_count,types);
+	{
+	size_t i[3] = {src.size<0>(), src.size<1>(), src.size<2>()};
+	size_t initial_i[3];
+full_restart:
+	memmove(initial_i,i,3*sizeof(size_t));
+	size_t stalled[3] = {SIZE_MAX,SIZE_MAX,SIZE_MAX};
+	try {
+		while(0<i[0]) C99_locate_expressions(src.c_array<0>()[--i[0]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[0] = i[0]++;
+		goto restart_1;
+		}
+restart_1:
+	try {
+		while(0<i[1]) C99_locate_expressions(src.c_array<1>()[--i[1]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[1] = i[1]++;
+		goto restart_2;
+		}
+restart_2:
+	try {
+		while(0<i[2]) C99_locate_expressions(src.c_array<2>()[--i[2]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[2] = i[2]++;
+		goto restart_3;
+		}
+restart_3:
+	if (SIZE_MAX>stalled[0] || SIZE_MAX>stalled[1] || SIZE_MAX>stalled[2])
+		{	// had a memory management problem
+		if (i[0]<initial_i[0] || i[1]<initial_i[1] || i[2]<initial_i[2])
+			// if we made some progress, restart
+			goto full_restart;
+		// otherwise give up
+		throw std::bad_alloc();
+		}
+	}
 
 	const bool top_level = SIZE_MAX==parent_identifier_count;
 	const bool parens_are_expressions = 0==parent_identifier_count	// no identifiers from outside
@@ -9716,17 +9757,54 @@
 }
 
 // top-level has SIZE_MAX for parent_identifier_count
+//! \throws std::bad_alloc
 static void CPP_locate_expressions(parse_tree& src,const size_t parent_identifier_count,const type_system& types)
 {
 	if (PARSE_OBVIOUS & src.flags) return;
 	const size_t identifier_count = (0==parent_identifier_count) ? 0 : _count_identifiers(src);
-	size_t i = src.size<0>();
-	while(0<i) CPP_locate_expressions(src.c_array<0>()[--i],identifier_count,types);
-	i = src.size<1>();
-	while(0<i) CPP_locate_expressions(src.c_array<1>()[--i],identifier_count,types);
-	i = src.size<2>();
-	while(0<i) CPP_locate_expressions(src.c_array<2>()[--i],identifier_count,types);
-
+	{
+	size_t i[3] = {src.size<0>(), src.size<1>(), src.size<2>()};
+	size_t initial_i[3];
+full_restart:
+	memmove(initial_i,i,3*sizeof(size_t));
+	size_t stalled[3] = {SIZE_MAX,SIZE_MAX,SIZE_MAX};
+	try {
+		while(0<i[0]) CPP_locate_expressions(src.c_array<0>()[--i[0]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[0] = i[0]++;
+		goto restart_1;
+		}
+restart_1:
+	try {
+		while(0<i[1]) CPP_locate_expressions(src.c_array<1>()[--i[1]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[1] = i[1]++;
+		goto restart_2;
+		}
+restart_2:
+	try {
+		while(0<i[2]) CPP_locate_expressions(src.c_array<2>()[--i[2]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[2] = i[2]++;
+		goto restart_3;
+		}
+restart_3:
+	if (SIZE_MAX>stalled[0] || SIZE_MAX>stalled[1] || SIZE_MAX>stalled[2])
+		{	// had a memory management problem
+		if (i[0]<initial_i[0] || i[1]<initial_i[1] || i[2]<initial_i[2])
+			// if we made some progress, restart
+			goto full_restart;
+		// otherwise give up
+		throw std::bad_alloc();
+		}
+	}
+	
 	const bool top_level = SIZE_MAX==parent_identifier_count;
 	const bool parens_are_expressions = 0==parent_identifier_count	// no identifiers from outside
 									|| (top_level && 0==identifier_count);	// top-level, no identifiers
@@ -9814,6 +9892,7 @@
 		}
 }
 
+//! \throw std::bad_alloc
 static bool C99_CondenseParseTree(parse_tree& src,const type_system& types)
 {
 	assert(src.is_raw_list());
@@ -9821,12 +9900,20 @@
 	const size_t starting_errors = zcc_errors.err_count();
 	_label_literals(src,types);
 	if (!_match_pairs(src)) return false;
-	C99_locate_expressions(src,SIZE_MAX,types);
+	try {
+		C99_locate_expressions(src,SIZE_MAX,types);
+		}
+	catch(std::bad_alloc&)
+		{	// error count change is already false
+		if (starting_errors<zcc_errors.err_count()) return false;
+		throw;
+		}
 	if (starting_errors<zcc_errors.err_count()) return false;
 	while(src.is_raw_list() && 1==src.size<0>()) src.eval_to_arg<0>(0);
 	return true;
 }
 
+//! \throw std::bad_alloc
 static bool CPP_CondenseParseTree(parse_tree& src,const type_system& types)
 {
 	assert(src.is_raw_list());
@@ -9839,7 +9926,14 @@
 	// check that this is at least within a brace pair or a parentheses pair (it is actually required to be in a non-static member function, or constructor mem-initializer
 	if (!_this_vaguely_where_it_could_be_cplusplus(src)) return false;
 #/*cut-cpp*/	
-	CPP_locate_expressions(src,SIZE_MAX,types);
+	try {
+		CPP_locate_expressions(src,SIZE_MAX,types);
+		}
+	catch(std::bad_alloc&)
+		{	// error count change is already false
+		if (starting_errors<zcc_errors.err_count()) return false;
+		throw;
+		}
 	if (starting_errors<zcc_errors.err_count()) return false;
 	while(src.is_raw_list() && 1==src.size<0>()) src.eval_to_arg<0>(0);
 	return true;
@@ -9868,6 +9962,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static void CPP_notice_scope_glue(parse_tree& src)
 {
 	assert(!src.empty<0>());
@@ -9961,30 +10056,18 @@
 	i = 0;
 	while(i<src.size<0>())
 		{
-		parse_tree& tmp = src.c_array<0>()[i];
-		if (is_naked_parentheses_pair(tmp))
-			{
-			if (!tmp.empty<0>())
-				// recurse into (...)
-				CPP_notice_scope_glue(tmp);
-			}
-		else if (is_naked_brace_pair(tmp))
-			{
-			if (!tmp.empty<0>())
-				// recurse into {...}
-				CPP_notice_scope_glue(tmp);
-			}
-		else if (is_naked_bracket_pair(tmp))
-			{
-			if (!tmp.empty<0>())
-				// recurse into [...]
-				CPP_notice_scope_glue(tmp);
-			}
-		++i;
+		parse_tree& tmp = src.c_array<0>()[i++];
+		if (tmp.empty<0>()) continue;
+		// recurse into ...
+		if (   is_naked_parentheses_pair(tmp) // (...)
+			|| is_naked_brace_pair(tmp) // {...}
+			|| is_naked_bracket_pair(tmp)) // [...]
+			CPP_notice_scope_glue(tmp);
 		};
 }
 
 //! \todo check that the fact all literals are already legal-form is used
+//! \throw std::bad_alloc
 static void CPP_ContextFreeParse(parse_tree& src,const type_system& types)
 {
 	assert(src.is_raw_list());
@@ -10003,7 +10086,7 @@
 //! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
 bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
 {
-	assert(NULL!=x);
+	assert(x && *x);
 	assert(0<x_len);
 	assert(C_TESTFLAG_PP_NUMERAL & flags);
 	assert(!(C_TESTFLAG_FLOAT & flags));
@@ -10089,12 +10172,31 @@
 	char* tmp2 = NULL;
 	assert(tmp.representable_as_uint());
 	GetCCharacterLiteralAt(str_lit.first,str_lit.second,tmp.to_uint(),tmp2);
-	assert(NULL!=tmp2);
+	assert(tmp2);
 	src.destroy();	// str_lit goes invalid here, don't use again
 	src.grab_index_token_from<0>(tmp2,C_TESTFLAG_CHAR_LITERAL);
 	_label_one_literal(src,types);
 }
 
+#define ZCC_EVALPARSETREE_PAIR_EVAL(A,B)	\
+	{	\
+	bool RAM_err = false;	\
+	try {	\
+		EvalParseTree(*src.c_array<A>(),types);	\
+		}	\
+	catch(std::bad_alloc&)	\
+		{	\
+		RAM_err = true;	\
+		goto restart_1;	\
+		}	\
+restart_1:	\
+	/* can't recover locally if this throws std::bad_alloc */	\
+	EvalParseTree(*src.c_array<B>(),types);	\
+	if (RAM_err) EvalParseTree(*src.c_array<A>(),types);	\
+	}
+
+
+//! \throw std::bad_alloc
 static bool
 eval_array_deref(parse_tree& src,const type_system& types,
 				 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
@@ -10104,8 +10206,7 @@
 	if (!is_array_deref(src)) return false;
 	// crunch __[...]
 	// canonical definition: *((__)+(...))
-	EvalParseTree(*src.c_array<0>(),types);
-	EvalParseTree(*src.c_array<1>(),types);
+	ZCC_EVALPARSETREE_PAIR_EVAL(0,1);
 	if (parse_tree::CONSTANT_EXPRESSION & src.flags)
 		{
 		const unsigned int str_index = 	(C_TESTFLAG_STRING_LITERAL==src.data<0>()->index_tokens[0].flags) ? 0 :
@@ -10123,6 +10224,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_deref(	parse_tree& src, const type_system& types,
 						func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
 {
@@ -10144,6 +10246,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_logical_NOT(parse_tree& src, const type_system& types,
 							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							 func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_NOT_expression,
@@ -10157,6 +10260,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_compl(	parse_tree& src, const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,
@@ -10170,6 +10274,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_unary_plus(parse_tree& src, const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
 {
@@ -10181,6 +10286,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_unary_minus(parse_tree& src, const type_system& types,
 							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							 literal_converts_to_bool_func& literal_converts_to_bool,
@@ -10194,6 +10300,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_mult_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								literal_converts_to_bool_func& literal_converts_to_bool,
@@ -10201,13 +10308,13 @@
 {
 	if (is_C99_mult_operator_expression<'*'>(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_mult_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_div_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								literal_converts_to_bool_func& literal_converts_to_bool,
@@ -10215,13 +10322,13 @@
 {
 	if (is_C99_mult_operator_expression<'/'>(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_div_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_mod_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								literal_converts_to_bool_func& literal_converts_to_bool,
@@ -10229,14 +10336,13 @@
 {
 	if (is_C99_mult_operator_expression<'%'>(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_mod_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
-
+//! \throw std::bad_alloc
 static bool eval_add_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							literal_converts_to_bool_func& literal_converts_to_bool,
@@ -10244,13 +10350,13 @@
 {
 	if (is_C99_add_operator_expression<'+'>(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_add_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_sub_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							literal_converts_to_bool_func& literal_converts_to_bool,
@@ -10258,13 +10364,13 @@
 {
 	if (is_C99_add_operator_expression<'-'>(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_sub_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_shift(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							literal_converts_to_bool_func& literal_converts_to_bool,
@@ -10272,26 +10378,26 @@
 {
 	if (is_C99_shift_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_shift(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_relation_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_relation_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_relation_expression(src,types,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_equality_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_equality_expression,
@@ -10300,13 +10406,13 @@
 {
 	if (is_equality_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_equality_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_AND(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_AND_expression,
@@ -10315,13 +10421,13 @@
 {
 	if (is_bitwise_AND_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_bitwise_AND(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_XOR(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_XOR_expression,
@@ -10330,13 +10436,13 @@
 {
 	if (is_bitwise_XOR_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_bitwise_XOR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_OR(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_OR_expression,
@@ -10345,13 +10451,13 @@
 {
 	if (is_bitwise_OR_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_bitwise_OR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_logical_AND(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_AND_expression,
@@ -10359,13 +10465,13 @@
 {
 	if (is_logical_AND_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_logical_AND(src,types,literal_converts_to_bool)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_logical_OR(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_OR_expression,
@@ -10373,13 +10479,13 @@
 {
 	if (is_logical_OR_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_logical_OR(src,types,literal_converts_to_bool)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_conditional_operator(parse_tree& src,const type_system& types,
 									  func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 									  literal_converts_to_bool_func& literal_converts_to_bool)
@@ -10400,12 +10506,10 @@
 		{	// strip off &*, and remove lvalue-ness of target
 		if (is_C99_unary_operator_expression<'*'>(*src.data<2>()) && 0<src.data<2>()->data<2>()->type_code.pointer_power)
 			{
-			parse_tree tmp = *src.data<2>()->data<2>();
+			parse_tree tmp;
+			src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
 			tmp.type_code.traits &= ~type_spec::lvalue;
-			src.c_array<2>()->c_array<2>()->clear();
-			src.destroy();
-			src = tmp;
-			return true;
+			tmp.MoveInto(src);
 			}
 #if 0
 		if (is_array_deref(*src.data<2>()))
@@ -10417,6 +10521,7 @@
 }
 #endif
 
+//! \throw std::bad_alloc
 static bool C99_EvalParseTree(parse_tree& src,const type_system& types)
 {
 	const size_t starting_errors = zcc_errors.err_count();
@@ -10445,6 +10550,7 @@
 	return starting_errors==zcc_errors.err_count();
 }
 
+//! \throw std::bad_alloc
 static bool CPP_EvalParseTree(parse_tree& src,const type_system& types)
 {
 	const size_t starting_errors = zcc_errors.err_count();

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-07 22:05:11 UTC (rev 414)
+++ trunk/CSupport_pp.cpp	2010-05-07 23:27:25 UTC (rev 415)
@@ -8523,6 +8523,7 @@
 	return false;
 }
 
+//! \throws std::bad_alloc
 static void C_conditional_op_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_conditional_operator_expression(src));
@@ -8610,6 +8611,7 @@
 	if (eval_conditional_op(src,C99_literal_converts_to_bool ARG_TYPES)) return;
 }
 
+//! \throws std::bad_alloc
 static void CPP_conditional_op_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_conditional_operator_expression(src));
@@ -8699,6 +8701,7 @@
 	if (eval_conditional_op(src,CPP_literal_converts_to_bool ARG_TYPES)) return;
 }
 
+//! \throws std::bad_alloc
 static void locate_C99_conditional_op(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -8711,6 +8714,7 @@
 		C_conditional_op_easy_syntax_check(src.c_array<0>()[i],types);
 }
 
+//! \throws std::bad_alloc
 static void locate_CPP_conditional_op(parse_tree& src, size_t& i, const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -8754,16 +8758,53 @@
 }
 
 // top-level has SIZE_MAX for parent_identifier_count
+//! \throws std::bad_alloc
 static void C99_locate_expressions(parse_tree& src,const size_t parent_identifier_count,const type_system& types)
 {
 	if (PARSE_OBVIOUS & src.flags) return;
 	size_t identifier_count = (0==parent_identifier_count) ? 0 : _count_identifiers(src);
-	size_t i = src.size<0>();
-	while(0<i) C99_locate_expressions(src.c_array<0>()[--i],identifier_count,types);
-	i = src.size<1>();
-	while(0<i) C99_locate_expressions(src.c_array<1>()[--i],identifier_count,types);
-	i = src.size<2>();
-	while(0<i) C99_locate_expressions(src.c_array<2>()[--i],identifier_count,types);
+	{
+	size_t i[3] = {src.size<0>(), src.size<1>(), src.size<2>()};
+	size_t initial_i[3];
+full_restart:
+	memmove(initial_i,i,3*sizeof(size_t));
+	size_t stalled[3] = {SIZE_MAX,SIZE_MAX,SIZE_MAX};
+	try {
+		while(0<i[0]) C99_locate_expressions(src.c_array<0>()[--i[0]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[0] = i[0]++;
+		goto restart_1;
+		}
+restart_1:
+	try {
+		while(0<i[1]) C99_locate_expressions(src.c_array<1>()[--i[1]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[1] = i[1]++;
+		goto restart_2;
+		}
+restart_2:
+	try {
+		while(0<i[2]) C99_locate_expressions(src.c_array<2>()[--i[2]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[2] = i[2]++;
+		goto restart_3;
+		}
+restart_3:
+	if (SIZE_MAX>stalled[0] || SIZE_MAX>stalled[1] || SIZE_MAX>stalled[2])
+		{	// had a memory management problem
+		if (i[0]<initial_i[0] || i[1]<initial_i[1] || i[2]<initial_i[2])
+			// if we made some progress, restart
+			goto full_restart;
+		// otherwise give up
+		throw std::bad_alloc();
+		}
+	}
 
 	const bool top_level = SIZE_MAX==parent_identifier_count;
 	const bool parens_are_expressions = 0==parent_identifier_count	// no identifiers from outside
@@ -8821,17 +8862,54 @@
 }
 
 // top-level has SIZE_MAX for parent_identifier_count
+//! \throws std::bad_alloc
 static void CPP_locate_expressions(parse_tree& src,const size_t parent_identifier_count,const type_system& types)
 {
 	if (PARSE_OBVIOUS & src.flags) return;
 	const size_t identifier_count = (0==parent_identifier_count) ? 0 : _count_identifiers(src);
-	size_t i = src.size<0>();
-	while(0<i) CPP_locate_expressions(src.c_array<0>()[--i],identifier_count,types);
-	i = src.size<1>();
-	while(0<i) CPP_locate_expressions(src.c_array<1>()[--i],identifier_count,types);
-	i = src.size<2>();
-	while(0<i) CPP_locate_expressions(src.c_array<2>()[--i],identifier_count,types);
-
+	{
+	size_t i[3] = {src.size<0>(), src.size<1>(), src.size<2>()};
+	size_t initial_i[3];
+full_restart:
+	memmove(initial_i,i,3*sizeof(size_t));
+	size_t stalled[3] = {SIZE_MAX,SIZE_MAX,SIZE_MAX};
+	try {
+		while(0<i[0]) CPP_locate_expressions(src.c_array<0>()[--i[0]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[0] = i[0]++;
+		goto restart_1;
+		}
+restart_1:
+	try {
+		while(0<i[1]) CPP_locate_expressions(src.c_array<1>()[--i[1]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[1] = i[1]++;
+		goto restart_2;
+		}
+restart_2:
+	try {
+		while(0<i[2]) CPP_locate_expressions(src.c_array<2>()[--i[2]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[2] = i[2]++;
+		goto restart_3;
+		}
+restart_3:
+	if (SIZE_MAX>stalled[0] || SIZE_MAX>stalled[1] || SIZE_MAX>stalled[2])
+		{	// had a memory management problem
+		if (i[0]<initial_i[0] || i[1]<initial_i[1] || i[2]<initial_i[2])
+			// if we made some progress, restart
+			goto full_restart;
+		// otherwise give up
+		throw std::bad_alloc();
+		}
+	}
+	
 	const bool top_level = SIZE_MAX==parent_identifier_count;
 	const bool parens_are_expressions = 0==parent_identifier_count	// no identifiers from outside
 									|| (top_level && 0==identifier_count);	// top-level, no identifiers
@@ -8919,6 +8997,7 @@
 		}
 }
 
+//! \throw std::bad_alloc
 static bool C99_CondenseParseTree(parse_tree& src,const type_system& types)
 {
 	assert(src.is_raw_list());
@@ -8926,12 +9005,20 @@
 	const size_t starting_errors = zcc_errors.err_count();
 	_label_literals(src,types);
 	if (!_match_pairs(src)) return false;
-	C99_locate_expressions(src,SIZE_MAX,types);
+	try {
+		C99_locate_expressions(src,SIZE_MAX,types);
+		}
+	catch(std::bad_alloc&)
+		{	// error count change is already false
+		if (starting_errors<zcc_errors.err_count()) return false;
+		throw;
+		}
 	if (starting_errors<zcc_errors.err_count()) return false;
 	while(src.is_raw_list() && 1==src.size<0>()) src.eval_to_arg<0>(0);
 	return true;
 }
 
+//! \throw std::bad_alloc
 static bool CPP_CondenseParseTree(parse_tree& src,const type_system& types)
 {
 	assert(src.is_raw_list());
@@ -8940,7 +9027,14 @@
 	_label_literals(src,types);
 	std::for_each(src.begin<0>(),src.end<0>(),_label_CPP_literal);	// intercepts: true, false, this
 	if (!_match_pairs(src)) return false;
-	CPP_locate_expressions(src,SIZE_MAX,types);
+	try {
+		CPP_locate_expressions(src,SIZE_MAX,types);
+		}
+	catch(std::bad_alloc&)
+		{	// error count change is already false
+		if (starting_errors<zcc_errors.err_count()) return false;
+		throw;
+		}
 	if (starting_errors<zcc_errors.err_count()) return false;
 	while(src.is_raw_list() && 1==src.size<0>()) src.eval_to_arg<0>(0);
 	return true;
@@ -8950,7 +9044,7 @@
 //! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
 bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
 {
-	assert(NULL!=x);
+	assert(x && *x);
 	assert(0<x_len);
 	assert(C_TESTFLAG_PP_NUMERAL & flags);
 	assert(!(C_TESTFLAG_FLOAT & flags));
@@ -9036,12 +9130,31 @@
 	char* tmp2 = NULL;
 	assert(tmp.representable_as_uint());
 	GetCCharacterLiteralAt(str_lit.first,str_lit.second,tmp.to_uint(),tmp2);
-	assert(NULL!=tmp2);
+	assert(tmp2);
 	src.destroy();	// str_lit goes invalid here, don't use again
 	src.grab_index_token_from<0>(tmp2,C_TESTFLAG_CHAR_LITERAL);
 	_label_one_literal(src,types);
 }
 
+#define ZCC_EVALPARSETREE_PAIR_EVAL(A,B)	\
+	{	\
+	bool RAM_err = false;	\
+	try {	\
+		EvalParseTree(*src.c_array<A>(),types);	\
+		}	\
+	catch(std::bad_alloc&)	\
+		{	\
+		RAM_err = true;	\
+		goto restart_1;	\
+		}	\
+restart_1:	\
+	/* can't recover locally if this throws std::bad_alloc */	\
+	EvalParseTree(*src.c_array<B>(),types);	\
+	if (RAM_err) EvalParseTree(*src.c_array<A>(),types);	\
+	}
+
+
+//! \throw std::bad_alloc
 static bool
 eval_array_deref(parse_tree& src,const type_system& types,
 				 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
@@ -9051,8 +9164,7 @@
 	if (!is_array_deref(src)) return false;
 	// crunch __[...]
 	// canonical definition: *((__)+(...))
-	EvalParseTree(*src.c_array<0>(),types);
-	EvalParseTree(*src.c_array<1>(),types);
+	ZCC_EVALPARSETREE_PAIR_EVAL(0,1);
 	if (parse_tree::CONSTANT_EXPRESSION & src.flags)
 		{
 		const unsigned int str_index = 	(C_TESTFLAG_STRING_LITERAL==src.data<0>()->index_tokens[0].flags) ? 0 :
@@ -9070,6 +9182,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_deref(	parse_tree& src, const type_system& types,
 						func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
 {
@@ -9091,6 +9204,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_logical_NOT(parse_tree& src, const type_system& types,
 							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							 func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_NOT_expression,
@@ -9104,6 +9218,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_compl(	parse_tree& src, const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,
@@ -9117,6 +9232,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_unary_plus(parse_tree& src, const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
 {
@@ -9128,6 +9244,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_unary_minus(parse_tree& src, const type_system& types,
 							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							 literal_converts_to_bool_func& literal_converts_to_bool,
@@ -9141,6 +9258,7 @@
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_mult_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								literal_converts_to_bool_func& literal_converts_to_bool,
@@ -9148,13 +9266,13 @@
 {
 	if (is_C99_mult_operator_expression<'*'>(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_mult_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_div_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								literal_converts_to_bool_func& literal_converts_to_bool,
@@ -9162,13 +9280,13 @@
 {
 	if (is_C99_mult_operator_expression<'/'>(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_div_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_mod_expression(parse_tree& src,const type_system& types,
 								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 								literal_converts_to_bool_func& literal_converts_to_bool,
@@ -9176,14 +9294,13 @@
 {
 	if (is_C99_mult_operator_expression<'%'>(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_mod_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
-
+//! \throw std::bad_alloc
 static bool eval_add_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							literal_converts_to_bool_func& literal_converts_to_bool,
@@ -9191,13 +9308,13 @@
 {
 	if (is_C99_add_operator_expression<'+'>(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_add_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_sub_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							literal_converts_to_bool_func& literal_converts_to_bool,
@@ -9205,13 +9322,13 @@
 {
 	if (is_C99_add_operator_expression<'-'>(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_sub_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_shift(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							literal_converts_to_bool_func& literal_converts_to_bool,
@@ -9219,26 +9336,26 @@
 {
 	if (is_C99_shift_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_shift(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_relation_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	if (is_C99_relation_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_relation_expression(src,types,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_equality_expression(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_equality_expression,
@@ -9247,13 +9364,13 @@
 {
 	if (is_equality_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_equality_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_AND(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_AND_expression,
@@ -9262,13 +9379,13 @@
 {
 	if (is_bitwise_AND_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_bitwise_AND(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_XOR(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_XOR_expression,
@@ -9277,13 +9394,13 @@
 {
 	if (is_bitwise_XOR_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_bitwise_XOR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_bitwise_OR(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_OR_expression,
@@ -9292,13 +9409,13 @@
 {
 	if (is_bitwise_OR_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_bitwise_OR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_logical_AND(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_AND_expression,
@@ -9306,13 +9423,13 @@
 {
 	if (is_logical_AND_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_logical_AND(src,types,literal_converts_to_bool)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_logical_OR(parse_tree& src,const type_system& types,
 							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_OR_expression,
@@ -9320,13 +9437,13 @@
 {
 	if (is_logical_OR_expression(src))
 		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
 		if (eval_logical_OR(src,types,literal_converts_to_bool)) return true;
 		}
 	return false;
 }
 
+//! \throw std::bad_alloc
 static bool eval_conditional_operator(parse_tree& src,const type_system& types,
 									  func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
 									  literal_converts_to_bool_func& literal_converts_to_bool)
@@ -9347,12 +9464,10 @@
 		{	// strip off &*, and remove lvalue-ness of target
 		if (is_C99_unary_operator_expression<'*'>(*src.data<2>()) && 0<src.data<2>()->data<2>()->type_code.pointer_power)
 			{
-			parse_tree tmp = *src.data<2>()->data<2>();
+			parse_tree tmp;
+			src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
 			tmp.type_code.traits &= ~type_spec::lvalue;
-			src.c_array<2>()->c_array<2>()->clear();
-			src.destroy();
-			src = tmp;
-			return true;
+			tmp.MoveInto(src);
 			}
 #if 0
 		if (is_array_deref(*src.data<2>()))
@@ -9364,6 +9479,7 @@
 }
 #endif
 
+//! \throw std::bad_alloc
 static bool C99_EvalParseTree(parse_tree& src,const type_system& types)
 {
 	const size_t starting_errors = zcc_errors.err_count();
@@ -9392,6 +9508,7 @@
 	return starting_errors==zcc_errors.err_count();
 }
 
+//! \throw std::bad_alloc
 static bool CPP_EvalParseTree(parse_tree& src,const type_system& types)
 {
 	const size_t starting_errors = zcc_errors.err_count();



From zaimoni at mail.berlios.de  Sat May  8 04:00:24 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 8 May 2010 04:00:24 +0200
Subject: [Zcplusplus-commits] r416 - trunk
Message-ID: <201005080200.o4820ORm007097@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-08 04:00:16 +0200 (Sat, 08 May 2010)
New Revision: 416

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/ParseTree.cpp
   trunk/ZParser.cpp
Log:
more memory management tuning

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-07 23:27:25 UTC (rev 415)
+++ trunk/CSupport.cpp	2010-05-08 02:00:16 UTC (rev 416)
@@ -4777,6 +4777,7 @@
 	//! \todo --do-what-i-mean should try to identify floats that are really integers
 }
 
+//! the returned parse_tree struct has no content; safe to use OvewriteInto on
 //! \throw std::bad_alloc()
 static zaimoni::Loki::CheckReturnDisallow<NULL,parse_tree*>::value_type repurpose_inner_parentheses(parse_tree& src)
 {
@@ -5306,7 +5307,6 @@
 	dest.first = REALLOC(buf,ZAIMONI_LEN_WITH_NULL(strlen(buf)));
 }
 
-// return code is true for success, false for memory failure
 //! \throw std::bad_alloc()
 static void VM_to_literal(parse_tree& dest, const umaxint& src_int,const parse_tree& src,const type_system& types)
 {
@@ -5320,6 +5320,39 @@
 	assert(PARSE_EXPRESSION & dest.flags);
 }
 
+// can't do much syntax-checking or immediate-evaluation here because of binary +/-
+// unary +/- syntax checking out out of place as it's needed by all of the unary operators
+//! \throw std::bad_alloc()
+static void uint_to_token(uintmax_t src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
+{
+	assert(C_TYPE::INT<=base_type_index && C_TYPE::ULLONG>=base_type_index);
+	const char* const suffix = literal_suffix(base_type_index);
+	char* buf = _new_buffer_nonNULL_throws<char>((VM_MAX_BIT_PLATFORM/3)+4);
+	dest.second = literal_flags(base_type_index);
+	dest.second |= C_TESTFLAG_DECIMAL;
+	z_umaxtoa(src_int,buf,10);
+	assert(!suffix || 3>=strlen(suffix));
+	assert(dest.second);
+	if (suffix) strcat(buf,suffix);
+
+	// shrinking realloc should be no-fail
+	dest.first = REALLOC(buf,ZAIMONI_LEN_WITH_NULL(strlen(buf)));
+}
+
+//! \throw std::bad_alloc()
+static void uint_to_literal(parse_tree& dest, uintmax_t src_int,const parse_tree& src,const type_system& types)
+{
+	POD_pair<char*,lex_flags> new_token;
+	uint_to_token(src_int,src.type_code.base_type_index,new_token);
+	dest.clear();
+	dest.grab_index_token_from<0>(new_token.first,new_token.second);
+	dest.grab_index_token_location_from<0,0>(src);
+	assert((C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_STRING_LITERAL | C_TESTFLAG_PP_NUMERAL) & dest.index_tokens[0].flags);
+	_label_one_literal(dest,types);
+	assert(PARSE_EXPRESSION & dest.flags);
+}
+
+
 static void force_decimal_literal(parse_tree& dest,const char* src,const type_system& types)
 {
 	assert(src && *src);
@@ -6205,7 +6238,7 @@
 	case C_TYPE::USHRT:
 		{
 		src.type_code.set_type(size_t_type);
-		VM_to_literal(tmp,umaxint(target_machine->C_sizeof_short()),src,types);
+		uint_to_literal(tmp,target_machine->C_sizeof_short(),src,types);
 		tmp.MoveInto(src);
 		break;
 		}
@@ -6213,7 +6246,7 @@
 	case C_TYPE::UINT:
 		{
 		src.type_code.set_type(size_t_type);
-		VM_to_literal(tmp,umaxint(target_machine->C_sizeof_int()),src,types);
+		uint_to_literal(tmp,target_machine->C_sizeof_int(),src,types);
 		tmp.MoveInto(src);
 		break;
 		}
@@ -6221,7 +6254,7 @@
 	case C_TYPE::ULONG:
 		{
 		src.type_code.set_type(size_t_type);
-		VM_to_literal(tmp,umaxint(target_machine->C_sizeof_long()),src,types);
+		uint_to_literal(tmp,target_machine->C_sizeof_long(),src,types);
 		tmp.MoveInto(src);
 		break;
 		}
@@ -6229,7 +6262,7 @@
 	case C_TYPE::ULLONG:
 		{
 		src.type_code.set_type(size_t_type);
-		VM_to_literal(tmp,umaxint(target_machine->C_sizeof_long_long()),src,types);
+		uint_to_literal(tmp,target_machine->C_sizeof_long_long(),src,types);
 		tmp.MoveInto(src);
 //		break;
 		}
@@ -6261,7 +6294,7 @@
 		parse_tree tmp;
 		src.type_code.set_type(size_t_type);
 		//! \todo eventually, need to check for data vs function pointer when pointer_power is 1
-		VM_to_literal(tmp,umaxint(target_machine->C_sizeof_data_ptr()),src,types);
+		uint_to_literal(tmp,target_machine->C_sizeof_data_ptr(),src,types);
 		tmp.MoveInto(src);
 		assert(size_t_type==src.type_code.base_type_index);
 		return true;
@@ -6542,7 +6575,7 @@
  	{
 	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
 	parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
-	tmp_c_array[0].MoveInto(*tmp);
+	tmp_c_array[0].OverwriteInto(*tmp);
 
 	tmp_c_array[1].fast_set_arg<1>(tmp);
 	tmp_c_array[1].core_flag_update();
@@ -9376,7 +9409,6 @@
 				tmp_c_array[1].fast_set_arg<2>(tmp3);
 				tmp_c_array[1].core_flag_update();
 				tmp_c_array[1].flags |= PARSE_STRICT_CONDITIONAL_EXPRESSION;
-				tmp_c_array[3].destroy();
 				src.DeleteNSlotsAt<0>(3,i+1);	// tmp_c_array becomes invalid here
 				src.DeleteIdx<0>(--i);
 				assert(is_C99_conditional_operator_expression_strict(src.data<0>()[i]));
@@ -10579,6 +10611,7 @@
 	return starting_errors==zcc_errors.err_count();
 }
 
+//! \throw std::bad_alloc
 void C99_PPHackTree(parse_tree& src,const type_system& types)
 {
 	if (parse_tree::INVALID & src.flags) return;
@@ -10655,6 +10688,7 @@
 #/*cut-cpp*/
 }
 
+//! \throw std::bad_alloc
 void CPP_PPHackTree(parse_tree& src,const type_system& types)
 {
 	if (parse_tree::INVALID & src.flags) return;
@@ -10762,8 +10796,8 @@
 //! \todo really should be somewhere in natural-language output
 void INFORM_separated_list(const char* const* x,size_t x_len, const char* const sep)
 {
-	assert(NULL!=sep && *sep);
-	assert(NULL!=x);
+	assert(sep && *sep);
+	assert(x);
 	if (0<x_len)
 		{
 		INC_INFORM(*x);
@@ -10777,10 +10811,11 @@
 #/*cut-cpp*/
 
 //! \todo should this be a type_system member?
+//! \throw std::bad_alloc
 static bool check_for_typedef(type_spec& dest,const char* const src,const type_system& types)
 {
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(src);
-	if (NULL!=tmp)
+	if (tmp)
 		{	//! \todo C++: check for access control if source ends up being a class or struct
 		value_copy(dest,tmp->first);
 		return true;
@@ -10789,10 +10824,11 @@
 }
 
 //! \todo should this be a type_system member?
+//! \throw std::bad_alloc
 static bool check_for_typedef(type_spec& dest,const char* const src,const char* const active_namespace,const type_system& types)
 {
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef_CPP(src,active_namespace);
-	if (NULL!=tmp)
+	if (tmp)
 		{	//! \todo C++: check for access control if source ends up being a class or struct
 		value_copy(dest,tmp->first);
 		return true;
@@ -10836,6 +10872,7 @@
 		base_type.clear();
 		};
 	// trivial destructor, copy constructor, assignment fine
+	//! \throw std::bad_alloc
 	bool operator()(const parse_tree& x)
 		{
 		BOOST_STATIC_ASSERT(CHAR_BIT*sizeof(uintmax_t)>=STATIC_SIZE(C99_decl_specifiers));
@@ -10934,6 +10971,7 @@
 		}
 	void fixup_type() { base_type.qualifier<0>() |= ((C99_CPP0X_DECLSPEC_CONST | C99_CPP0X_DECLSPEC_VOLATILE) & flags); };
 	uintmax_t get_flags() const {return flags;};
+	//! \throw std::bad_alloc
 	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
 };
 
@@ -10953,6 +10991,7 @@
 		base_type.clear();
 		}
 	// trivial destructor, copy constructor, assignment fine
+	//! \throw std::bad_alloc
 	bool operator()(parse_tree& x,const size_t i)
 		{
 		BOOST_STATIC_ASSERT(CHAR_BIT*sizeof(uintmax_t)>=STATIC_SIZE(CPP0X_decl_specifiers));
@@ -11105,6 +11144,7 @@
 		};
 	void fixup_type() { base_type.qualifier<0>() |= ((C99_CPP0X_DECLSPEC_CONST | C99_CPP0X_DECLSPEC_VOLATILE) & flags); };
 	uintmax_t get_flags() const {return flags;};
+	//! \throw std::bad_alloc
 	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
 };
 
@@ -11433,7 +11473,8 @@
 	(langinfo.LocateExpression)(parsetree,SIZE_MAX,types);
 	if (starting_errors==zcc_errors.err_count())
 		{
-		while(parsetree.is_raw_list() && 1==parsetree.size<0>()) parsetree.eval_to_arg<0>(0);
+		while(parsetree.is_raw_list() && 1==parsetree.size<0>())
+			parsetree.eval_to_arg<0>(0);
 		// end snip from Condense
 		// snip from CPreproc
 		if (!parsetree.is_atomic() && !(langinfo.EvalParseTree)(parsetree,types))
@@ -11492,7 +11533,7 @@
 				};
 
 			char* tmp = _new_buffer<char>(tmp_size);
-			if (NULL==tmp)
+			if (!tmp)
 				{
 				INFORM("(static assertion failure)");
 				zcc_errors.inc_error();
@@ -11563,6 +11604,7 @@
 	return true;
 }
 
+//! \throw std::bad_alloc
 static bool record_enum_values(parse_tree& src, type_system& types, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits<const char* (*)(const char*, size_t)>::function_ref_type echo_reserved_keyword, intlike_literal_to_VM_func& intlike_literal_to_VM, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type CondenseParseTree, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
 {
 	assert(enum_type_index);
@@ -12024,6 +12066,7 @@
 // incoming: n typespec records, flag for trailing ...
 // will need: typedef map: identifier |-> typespec record
 //! \todo check that the fact all literals are already legal-form is used
+//! \throw std::bad_alloc
 static void C99_ContextParse(parse_tree& src,type_system& types)
 {
 	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle in type_spec, which is required to be POD to allow C memory management:
@@ -12502,6 +12545,7 @@
 
 // handle namespaces or else
 //! \todo check that the fact all literals are already legal-form is used
+//! \throw std::bad_alloc
 static void CPP_ParseNamespace(parse_tree& src,type_system& types,const char* const active_namespace)
 {
 	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle
@@ -12927,8 +12971,7 @@
 					// regardless of official linkage, entities in anonymous namespaces aren't very accessible outside of the current translation unit;
 					// any reasonable linker thinks they have static linkage
 				src.c_array<0>()[i].resize<2>(2);
-				src.c_array<0>()[i].c_array<2>()[1] = src.data<0>()[i+1];
-				src.c_array<0>()[i+1].clear();
+				src.c_array<0>()[i+1].OverwriteInto(src.c_array<0>()[i].c_array<2>()[1]);
 				src.DeleteIdx<0>(i+1);
 
 				// anonymous namespace names are technically illegal
@@ -12990,10 +13033,8 @@
 			// the namespace name is likely to be reused: atomic string target
 			register_token<0>(src.c_array<0>()[i+1]);
 			src.c_array<0>()[i].resize<2>(2);
-			src.c_array<0>()[i].c_array<2>()[0] = src.data<0>()[i+1];
-			src.c_array<0>()[i].c_array<2>()[1] = src.data<0>()[i+2];
-			src.c_array<0>()[i+1].clear();
-			src.c_array<0>()[i+2].clear();
+			src.c_array<0>()[i+1].OverwriteInto(src.c_array<0>()[i].c_array<2>()[0]);
+			src.c_array<0>()[i+2].OverwriteInto(src.c_array<0>()[i].c_array<2>()[1]);
 			src.DeleteNSlotsAt<0>(2,i+1);
 			src.c_array<0>()[i].flags |= parse_tree::GOOD_LINE_BREAK;
 			assert(is_CPP_namespace(src.data<0>()[i]));
@@ -13234,6 +13275,7 @@
 		}
 }
 
+//! \throw std::bad_alloc
 static void CPP_ContextParse(parse_tree& src,type_system& types)
 {
 	CPP_ParseNamespace(src,types,NULL);

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-07 23:27:25 UTC (rev 415)
+++ trunk/CSupport_pp.cpp	2010-05-08 02:00:16 UTC (rev 416)
@@ -4326,6 +4326,7 @@
 	//! \todo --do-what-i-mean should try to identify floats that are really integers
 }
 
+//! the returned parse_tree struct has no content; safe to use OvewriteInto on
 //! \throw std::bad_alloc()
 static zaimoni::Loki::CheckReturnDisallow<NULL,parse_tree*>::value_type repurpose_inner_parentheses(parse_tree& src)
 {
@@ -4836,7 +4837,6 @@
 	dest.first = REALLOC(buf,ZAIMONI_LEN_WITH_NULL(strlen(buf)));
 }
 
-// return code is true for success, false for memory failure
 //! \throw std::bad_alloc()
 static void VM_to_literal(parse_tree& dest, const umaxint& src_int,const parse_tree& src,const type_system& types)
 {
@@ -4850,6 +4850,39 @@
 	assert(PARSE_EXPRESSION & dest.flags);
 }
 
+// can't do much syntax-checking or immediate-evaluation here because of binary +/-
+// unary +/- syntax checking out out of place as it's needed by all of the unary operators
+//! \throw std::bad_alloc()
+static void uint_to_token(uintmax_t src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
+{
+	assert(C_TYPE::INT<=base_type_index && C_TYPE::ULLONG>=base_type_index);
+	const char* const suffix = literal_suffix(base_type_index);
+	char* buf = _new_buffer_nonNULL_throws<char>((VM_MAX_BIT_PLATFORM/3)+4);
+	dest.second = literal_flags(base_type_index);
+	dest.second |= C_TESTFLAG_DECIMAL;
+	z_umaxtoa(src_int,buf,10);
+	assert(!suffix || 3>=strlen(suffix));
+	assert(dest.second);
+	if (suffix) strcat(buf,suffix);
+
+	// shrinking realloc should be no-fail
+	dest.first = REALLOC(buf,ZAIMONI_LEN_WITH_NULL(strlen(buf)));
+}
+
+//! \throw std::bad_alloc()
+static void uint_to_literal(parse_tree& dest, uintmax_t src_int,const parse_tree& src,const type_system& types)
+{
+	POD_pair<char*,lex_flags> new_token;
+	uint_to_token(src_int,src.type_code.base_type_index,new_token);
+	dest.clear();
+	dest.grab_index_token_from<0>(new_token.first,new_token.second);
+	dest.grab_index_token_location_from<0,0>(src);
+	assert((C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_STRING_LITERAL | C_TESTFLAG_PP_NUMERAL) & dest.index_tokens[0].flags);
+	_label_one_literal(dest,types);
+	assert(PARSE_EXPRESSION & dest.flags);
+}
+
+
 static void force_decimal_literal(parse_tree& dest,const char* src,const type_system& types)
 {
 	assert(src && *src);
@@ -5757,7 +5790,7 @@
  	{
 	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
 	parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
-	tmp_c_array[0].MoveInto(*tmp);
+	tmp_c_array[0].OverwriteInto(*tmp);
 
 	tmp_c_array[1].fast_set_arg<1>(tmp);
 	tmp_c_array[1].core_flag_update();
@@ -8481,7 +8514,6 @@
 				tmp_c_array[1].fast_set_arg<2>(tmp3);
 				tmp_c_array[1].core_flag_update();
 				tmp_c_array[1].flags |= PARSE_STRICT_CONDITIONAL_EXPRESSION;
-				tmp_c_array[3].destroy();
 				src.DeleteNSlotsAt<0>(3,i+1);	// tmp_c_array becomes invalid here
 				src.DeleteIdx<0>(--i);
 				assert(is_C99_conditional_operator_expression_strict(src.data<0>()[i]));
@@ -9537,6 +9569,7 @@
 	return starting_errors==zcc_errors.err_count();
 }
 
+//! \throw std::bad_alloc
 void C99_PPHackTree(parse_tree& src,const type_system& types)
 {
 	if (parse_tree::INVALID & src.flags) return;
@@ -9605,6 +9638,7 @@
 		}
 }
 
+//! \throw std::bad_alloc
 void CPP_PPHackTree(parse_tree& src,const type_system& types)
 {
 	if (parse_tree::INVALID & src.flags) return;
@@ -9677,8 +9711,8 @@
 //! \todo really should be somewhere in natural-language output
 void INFORM_separated_list(const char* const* x,size_t x_len, const char* const sep)
 {
-	assert(NULL!=sep && *sep);
-	assert(NULL!=x);
+	assert(sep && *sep);
+	assert(x);
 	if (0<x_len)
 		{
 		INC_INFORM(*x);

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2010-05-07 23:27:25 UTC (rev 415)
+++ trunk/ParseTree.cpp	2010-05-08 02:00:16 UTC (rev 416)
@@ -434,6 +434,7 @@
 #endif
 }
 
+//! the new slots have no content, OverwriteInto won't leak memory
 bool parse_tree::_resize(const size_t arg_idx,size_t n)
 {
 	assert(STATIC_SIZE(args)>arg_idx);

Modified: trunk/ZParser.cpp
===================================================================
--- trunk/ZParser.cpp	2010-05-07 23:27:25 UTC (rev 415)
+++ trunk/ZParser.cpp	2010-05-08 02:00:16 UTC (rev 416)
@@ -47,11 +47,6 @@
 #endif
 				};
 			if (!ParsedList[0]->resize<0>(old_parsed_size+append_tokens)) throw std::bad_alloc();
-#ifndef ZAIMONI_NULL_REALLY_IS_ZERO
-			i = append_tokens;
-			do	ParsedList[0]->c_array<0>()[old_parsed_size+ --i].clear();
-			while(0<i);
-#endif
 			// error the illegal preprocessing tokens here, not in CPreprocessor
 			i = pretokenized.size();
 			do	{



From zaimoni at mail.berlios.de  Sat May  8 07:55:37 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 8 May 2010 07:55:37 +0200
Subject: [Zcplusplus-commits] r417 - trunk
Message-ID: <201005080555.o485tbQw025661@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-08 07:55:32 +0200 (Sat, 08 May 2010)
New Revision: 417

Modified:
   trunk/CSupport.cpp
   trunk/type_spec.hpp
Log:
splice in some completely untested declaration-recognition code

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-08 02:00:16 UTC (rev 416)
+++ trunk/CSupport.cpp	2010-05-08 05:55:32 UTC (rev 417)
@@ -11148,29 +11148,20 @@
 	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
 };
 
-/*
-C99 6.7.5p1, C1X 6.7.6p1
-pointer:
-* type-qualifier-listopt
-* type-qualifier-listopt pointer
-*/
-static size_t C99_recognize_pointerlike_declarator_section(parse_tree& x, size_t i,type_spec& target_type)
+static size_t C99_cv_qualifier_span(parse_tree& x, size_t i,type_spec& target_type)
 {
-	assert(x.size<0>()>i);
+	unsigned int warn_queue = 0;
 	size_t ub = 0;
-	while(robust_token_is_char<'*'>(x.data<0>()[i+ub]))
+	if (x.size<0>()>i)
 		{
-		unsigned int warn_queue = 0;
-		target_type.make_C_pointer();
-		while(x.size<0>()<=i+ ++ub)
-			{
+		do	{
 			if (robust_token_is_string<5>(x.data<0>()[i+ub],"const"))
 				{	//! \bug need test cases
 				if (target_type.q_vector.back() & type_spec::_const)
-					{
+					{	
 					warn_queue |= type_spec::_const;
 					// optimize source
-					x.DeleteIdx<0>(i + ub--);
+					x.DeleteIdx<0>(i+ub);
 					continue;
 					}
 				target_type.q_vector.back() |= type_spec::_const;
@@ -11181,7 +11172,7 @@
 					{
 					warn_queue |= type_spec::_volatile;
 					// optimize source
-					x.DeleteIdx<0>(i + ub--);
+					x.DeleteIdx<0>(i+ub);
 					continue;
 					}
 				target_type.q_vector.back() |= type_spec::_volatile;
@@ -11192,13 +11183,14 @@
 					{
 					warn_queue |= type_spec::_restrict;
 					// optimize source
-					x.DeleteIdx<0>(i + ub--);
+					x.DeleteIdx<0>(i+ub);
 					continue;
 					}
 				target_type.q_vector.back() |= type_spec::_restrict;
 				}
 			else break;
 			}
+		while(x.size<0>()>i+ ++ub);
 		//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 		//! \todo should this be a context-free check?
 		if (warn_queue)
@@ -11215,6 +11207,28 @@
 
 /*
 C99 6.7.5p1, C1X 6.7.6p1
+pointer:
+* type-qualifier-listopt
+* type-qualifier-listopt pointer
+*/
+static size_t C99_recognize_pointerlike_declarator_section(parse_tree& x, size_t i,type_spec& target_type)
+{
+	assert(x.size<0>()>i);
+	size_t ub = 0;
+	while(robust_token_is_char<'*'>(x.data<0>()[i+ub]))
+		{
+		target_type.make_C_pointer();
+		++ub;
+		ub += C99_cv_qualifier_span(x,i+ub,target_type);
+		}
+	return ub;
+}
+
+// forward-declare for recursive definition
+static size_t C99_init_declarator_scanner(parse_tree& x, size_t i,type_spec& target_type, parse_tree*& initdecl_identifier);
+
+/*
+C99 6.7.5p1, C1X 6.7.6p1
 direct-declarator:
 identifier
 ( declarator )
@@ -11225,16 +11239,45 @@
 direct-declarator ( parameter-type-list )
 direct-declarator ( identifier-listopt )
 */
-
-static size_t C99_recognize_direct_declaratorlike_section(parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
+static size_t C99_recognize_direct_declaratorlike_section(parse_tree& x, size_t i,type_spec& target_type, parse_tree*& initdecl_identifier)
 {
 	assert(x.size<0>()>i);
+	assert(!initdecl_identifier);
 	size_t ub = 0;
-	if (x.data<0>()[i].is_atomic() && (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags))
+	if (	x.data<0>()[i].is_atomic()
+		&& (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags)
+		&& !(PARSE_TYPE & x.data<0>()[i].flags) 	// internal representation could land some types here, especially primary types
+		&& !C99_echo_reserved_keyword(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second))
 		{	// identifier counts
 		ub = 1;
-		initdecl_identifier_idx = i;
+		initdecl_identifier = x.c_array<0>()+i;
 		}
+	else if (is_naked_parentheses_pair(x.data<0>()[i]))
+		{
+		const size_t content_length = x.size<0>();
+		if (0<content_length && content_length==C99_init_declarator_scanner(x.c_array<0>()[i],0,target_type,initdecl_identifier))
+			ub = 1;
+		}
+	if (0<ub)
+		{
+		while(i+ub<x.size<0>())
+			{
+			if (is_naked_bracket_pair(x.data<0>()[i+ub]))
+				{	// we'll catch the array size, etc. later
+				if (!(target_type.qualifier<0>() & type_spec::_function_return_value))
+					target_type.make_C_array(0);
+				++ub;
+				continue;
+				}
+			else if (is_naked_parentheses_pair(x.data<0>()[i+ub]))
+				{	// handle the prototype later
+				target_type.qualifier<0>() |= type_spec::_function_return_value;
+				++ub;
+				continue;
+				}
+			break;
+			}
+		}
 	return ub;
 }
 
@@ -11242,42 +11285,61 @@
 declarator:
 pointeropt direct-declarator
 */
-static size_t C99_init_declarator_scanner(parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
+static size_t C99_init_declarator_scanner(parse_tree& x, size_t i,type_spec& target_type, parse_tree*& initdecl_identifier)
 {
 	assert(x.size<0>()>i);
+	assert(!initdecl_identifier);
 	const size_t ptr_like = C99_recognize_pointerlike_declarator_section(x,i,target_type);
 	if (x.size<0>()-i <= ptr_like) return 0;
-	const size_t direct_decl_like = C99_recognize_direct_declaratorlike_section(x,i+ptr_like,target_type,initdecl_identifier_idx);
+	const size_t direct_decl_like = C99_recognize_direct_declaratorlike_section(x,i+ptr_like,target_type,initdecl_identifier);
 	if (0<direct_decl_like) return ptr_like+direct_decl_like;
 	return 0;
 }
 
-/*
-C++0X 8p4
-ptr-operator:
-* attribute-specifieropt cv-qualifier-seqopt
-& attribute-specifieropt
-&& attribute-specifieropt
-::opt nested-name-specifier * attribute-specifieropt cv-qualifier-seqopt*/
-static size_t CPP_recognize_pointerlike_declarator_section(parse_tree& x, size_t i,type_spec& target_type)
+// very basic syntax check; defer real parsing to later
+static bool is_CPP0X_attribute(const parse_tree& x)
 {
-	assert(x.size<0>()>i);
+	if (   is_naked_bracket_pair(x)
+		&& 1==x.size<0>()
+		&& is_naked_bracket_pair(*x.data<0>()))
+		return true;
+	return false;
+}
+
+static bool is_CPP0X_ref_qualifier(const parse_tree& x)
+{
+	if (   robust_token_is_char<'&'>(x)
+		|| robust_token_is_string<2>(x,"&&"))
+		return true;
+	return false;
+}
+
+// very basic syntax check; defer real parsing to later
+static size_t is_CPP0X_exception_specification_here(const parse_tree& x,size_t i)
+{
+	if (x.size<0>()>i)
+		{
+		const bool have_parens = 1<x.size<0>()-i && is_naked_parentheses_pair(x.data<0>()[i+1]);
+		if (robust_token_is_string<8>(x,"noexcept")) return 1+have_parens;
+		if (have_parens && robust_token_is_string<5>(x,"throw")) return 2;
+		}
+	return 0;
+}
+
+static size_t CPP_cv_qualifier_span(parse_tree& x, size_t i,type_spec& target_type)
+{
+	unsigned int warn_queue = 0;
 	size_t ub = 0;
-	// handle C-like case
-	while(robust_token_is_char<'*'>(x.data<0>()[i+ub]))
+	if (x.size<0>()>i)
 		{
-		unsigned int warn_queue = 0;
-		target_type.make_C_pointer();
-		//! \todo would check for attributes here
-		while(x.size<0>()<=i+ ++ub)
-			{
+		do	{
 			if (robust_token_is_string<5>(x.data<0>()[i+ub],"const"))
 				{	//! \bug need test cases
 				if (target_type.q_vector.back() & type_spec::_const)
-					{
+					{	
 					warn_queue |= type_spec::_const;
 					// optimize source
-					x.DeleteIdx<0>(i + ub--);
+					x.DeleteIdx<0>(i+ub);
 					continue;
 					}
 				target_type.q_vector.back() |= type_spec::_const;
@@ -11288,13 +11350,14 @@
 					{
 					warn_queue |= type_spec::_volatile;
 					// optimize source
-					x.DeleteIdx<0>(i + ub--);
+					x.DeleteIdx<0>(i+ub);
 					continue;
 					}
 				target_type.q_vector.back() |= type_spec::_volatile;
 				}
 			else break;
 			}
+		while(x.size<0>()>i+ ++ub);
 		//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 		//! \todo should this be a context-free check?
 		if (warn_queue)
@@ -11310,22 +11373,81 @@
 }
 
 /*
+C++0X 8p4
+ptr-operator:
+* attribute-specifieropt cv-qualifier-seqopt
+& attribute-specifieropt
+&& attribute-specifieropt
+::opt nested-name-specifier * attribute-specifieropt cv-qualifier-seqopt*/
+static size_t CPP_recognize_pointerlike_declarator_section(parse_tree& x, size_t i,type_spec& target_type)
+{
+	assert(x.size<0>()>i);
+	size_t ub = 0;
+	// handle C-like case
+	while(robust_token_is_char<'*'>(x.data<0>()[i+ub]))
+		{
+		target_type.make_C_pointer();
+		++ub;
+		//! \todo would check for attributes here
+		ub += CPP_cv_qualifier_span(x,i+ub,target_type);
+		}
+	return ub;
+}
+
+// forward-declaration for recursive definition
+static size_t CPP_init_declarator_scanner(parse_tree& x, size_t i,type_spec& target_type, parse_tree*& initdecl_identifier);
+
+/*
 noptr-declarator:
 declarator-id attribute-specifieropt
 noptr-declarator parameters-and-qualifiers
 noptr-declarator [ constant-expressionopt ] attribute-specifieropt
 ( ptr-declarator )
 */
-static size_t CPP_recognize_noptr_declaratorlike_section(parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
+static size_t CPP_recognize_noptr_declaratorlike_section(parse_tree& x, size_t i,type_spec& target_type, parse_tree*& initdecl_identifier)
 {
 	assert(x.size<0>()>i);
 	size_t ub = 0;
-	if (x.data<0>()[i].is_atomic() && (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags))
+	if (	x.data<0>()[i].is_atomic()
+		&& (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags)
+		&& !(PARSE_TYPE & x.data<0>()[i].flags) 	// internal representation could land some types here, especially primary types
+		&& !CPP_echo_reserved_keyword(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second))
 		{	// identifier counts
 		ub = 1;
-		initdecl_identifier_idx = i;
-		//! \todo check for attributes here
+		initdecl_identifier = x.c_array<0>()+i;
+		if (x.size<0>()-i>ub) ub += is_CPP0X_attribute(x.data<0>()[i+ub]);
 		}
+	else if (is_naked_parentheses_pair(x.data<0>()[i]))
+		{
+		const size_t content_length = x.size<0>();
+		if (0<content_length && content_length==CPP_init_declarator_scanner(x.c_array<0>()[i],0,target_type,initdecl_identifier))
+			ub = 1;
+		}
+	if (0<ub)
+		{
+		while(x.size<0>()-i>ub)
+			{
+			if (is_naked_bracket_pair(x.data<0>()[i+ub]))
+				{	// we'll catch the array size, etc. later
+				if (!(target_type.qualifier<0>() & type_spec::_function_return_value))
+					target_type.make_C_array(0);
+				++ub;
+				if (x.size<0>()-i>ub) ub += is_CPP0X_attribute(x.data<0>()[i+ub]);
+				continue;
+				}
+			else if (is_naked_parentheses_pair(x.data<0>()[i+ub]))
+				{	// handle the prototype later
+				target_type.qualifier<0>() |= type_spec::_function_return_value;
+				++ub;
+				if (x.size<0>()-i>ub) ub += is_CPP0X_attribute(x.data<0>()[i+ub]);
+				if (x.size<0>()-i>ub) ub += CPP_cv_qualifier_span(x,i+ub,target_type);
+				if (x.size<0>()-i>ub) ub += is_CPP0X_ref_qualifier(x.c_array<0>()[i+ub]);
+				if (x.size<0>()-i>ub) ub += is_CPP0X_exception_specification_here(x,i+ub);
+				continue;
+				}
+			break;
+			}
+		}
 	return ub;
 }
 
@@ -11338,12 +11460,12 @@
 noptr-declarator
 ptr-operator ptr-declarator
 */
-static size_t CPP_init_declarator_scanner(parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
+static size_t CPP_init_declarator_scanner(parse_tree& x, size_t i,type_spec& target_type, parse_tree*& initdecl_identifier)
 {
 	assert(x.size<0>()>i);
 	const size_t ptr_like = CPP_recognize_pointerlike_declarator_section(x,i,target_type);
 	if (x.size<0>()-i <= ptr_like) return 0;
-	const size_t noptr_like = CPP_recognize_noptr_declaratorlike_section(x,i+ptr_like,target_type,initdecl_identifier_idx);
+	const size_t noptr_like = CPP_recognize_noptr_declaratorlike_section(x,i+ptr_like,target_type,initdecl_identifier);
 	if (0<noptr_like)
 		{
 		if (0<ptr_like) return ptr_like+noptr_like;
@@ -12384,12 +12506,11 @@
 				type_spec bootstrap;
 				bootstrap.clear();
 				declFind.value_copy_type(bootstrap);
-				size_t initdecl_identifier_idx = 0;
-				size_t initdecl_span = C99_init_declarator_scanner(src,i+decl_count+decl_offset,bootstrap,initdecl_identifier_idx);
-				assert(0<initdecl_span || 0==initdecl_identifier_idx);
+				parse_tree* initdecl_identifier = NULL;
+				size_t initdecl_span = C99_init_declarator_scanner(src,i+decl_count+decl_offset,bootstrap,initdecl_identifier);
+				assert(0<initdecl_span || !initdecl_identifier);
 				if (0==initdecl_span)
 					{	// no declarator where expected
-						// a botched function-declarator will have non-zero length
 					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INFORM("declarator missing (C99 6.7p1)");
@@ -12402,7 +12523,7 @@
 						src.DeleteNSlotsAt<0>((j-i)+(src.size<0>()>j),i);
 					break;
 					};
-				if (!initdecl_identifier_idx)
+				if (!initdecl_identifier)
 					{	// didn't find identifier when needed
 					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -12431,19 +12552,19 @@
 					{
 					if (C99_CPP0X_DECLSPEC_TYPEDEF & declFind.get_flags())
 						{	// typedef
-						register_token<0>(src.c_array<0>()[initdecl_identifier_idx]);
+						register_token<0>(*initdecl_identifier);
 						// verify that there is no prior definition
-						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(src.data<0>()[initdecl_identifier_idx].index_tokens[0].token.first);
-						if (NULL!=tmp)
+						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(initdecl_identifier->index_tokens[0].token.first);
+						if (tmp)
 							{
 							if (bootstrap==tmp->first)
 								{	// warn if there is a prior, consistent definition
 									//! \test zcc/decl.C99/Warn_redeclare_typedef.h
 									//! \todo control this warning with an option --no-OAOO or --no-DRY
-								message_header(src.data<0>()[initdecl_identifier_idx].index_tokens[0]);
+								message_header(initdecl_identifier->index_tokens[0]);
 								INC_INFORM(WARN_STR);
 								INC_INFORM("redeclaring typedef ");
-								INFORM(src.data<0>()[initdecl_identifier_idx].index_tokens[0].token.first);
+								INFORM(initdecl_identifier->index_tokens[0].token.first);
 								INC_INFORM(tmp->second);
 								INC_INFORM(':');
 								INC_INFORM(tmp->third);
@@ -12453,10 +12574,10 @@
 								}
 							else{	// error if there is a prior, inconsistent definition
 									//! \test zcc/decl.C99/Error_redeclare_typedef.h
-								message_header(src.data<0>()[initdecl_identifier_idx].index_tokens[0]);
+								message_header(initdecl_identifier->index_tokens[0]);
 								INC_INFORM(ERR_STR);
 								INC_INFORM("redeclaring typedef ");
-								INFORM(src.data<0>()[initdecl_identifier_idx].index_tokens[0].token.first);
+								INFORM(initdecl_identifier->index_tokens[0].token.first);
 								INC_INFORM(tmp->second);
 								INC_INFORM(':');
 								INC_INFORM(tmp->third);
@@ -12466,7 +12587,7 @@
 							// do not re-register if there is a prior definition
 							}
 						else{	// prepare to register this with types object
-							const type_system::enumerator_info* tmp2 = types.get_enumerator(src.data<0>()[initdecl_identifier_idx].index_tokens[0].token.first);
+							const type_system::enumerator_info* tmp2 = types.get_enumerator(initdecl_identifier->index_tokens[0].token.first);
 							if (tmp2)
 								{	//! \test zcc/decl.C99/Error_typedef_enum.h
 								message_header(src.data<0>()[i].index_tokens[0]);
@@ -12479,7 +12600,7 @@
 								zcc_errors.inc_error();
 								return;
 								}
-							types.set_typedef(src.data<0>()[initdecl_identifier_idx].index_tokens[0].token.first,src.data<0>()[initdecl_identifier_idx].index_tokens[0].src_filename,src.data<0>()[initdecl_identifier_idx].index_tokens[0].logical_line.first,bootstrap);
+							types.set_typedef(initdecl_identifier->index_tokens[0].token.first,initdecl_identifier->index_tokens[0].src_filename,initdecl_identifier->index_tokens[0].logical_line.first,bootstrap);
 							}
 						}
 #if 0
@@ -13122,12 +13243,11 @@
 				type_spec bootstrap;
 				bootstrap.clear();
 				declFind.value_copy_type(bootstrap);
-				size_t initdecl_identifier_idx = 0;
-				size_t initdecl_span = CPP_init_declarator_scanner(src,i+decl_count+decl_offset,bootstrap,initdecl_identifier_idx);
-				assert(0<initdecl_span || 0==initdecl_identifier_idx);
+				parse_tree* initdecl_identifier = NULL;
+				size_t initdecl_span = CPP_init_declarator_scanner(src,i+decl_count+decl_offset,bootstrap,initdecl_identifier);
+				assert(0<initdecl_span || !initdecl_identifier);
 				if (0==initdecl_span)
 					{	// no declarator where expected
-						// a botched function-declarator will have non-zero length
 					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					INFORM("declarator missing (C++98 7p1)");
@@ -13140,7 +13260,7 @@
 						src.DeleteNSlotsAt<0>((j-i)+(src.size<0>()>j),i);
 					break;
 					};
-				if (!initdecl_identifier_idx)
+				if (!initdecl_identifier)
 					{	// didn't find identifier when needed
 					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -13169,22 +13289,22 @@
 					{
 					if (C99_CPP0X_DECLSPEC_TYPEDEF & declFind.get_flags())
 						{	// typedef
-						register_token<0>(src.c_array<0>()[initdecl_identifier_idx]);
-						char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.c_array<0>()[initdecl_identifier_idx].index_tokens[0].token.first,active_namespace,"::") : NULL;
-						const char* fullname = namespace_name ? namespace_name : src.c_array<0>()[initdecl_identifier_idx].index_tokens[0].token.first;
+						register_token<0>(*initdecl_identifier);
+						char* namespace_name = active_namespace ? type_system::namespace_concatenate(initdecl_identifier->index_tokens[0].token.first,active_namespace,"::") : NULL;
+						const char* fullname = namespace_name ? namespace_name : initdecl_identifier->index_tokens[0].token.first;
 						// We could run an is_string_registered check to try to conserve RAM, but in this case conserving RAM 
 						// doesn't actually reduce maximum RAM loading before the types.set_typedef_CPP call.
 
 						// verify that there is no prior definition
 						// we're fine redeclaring at a different level, so do not use full C++ typedef lookup
 						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(fullname);					
-						if (NULL!=tmp)
+						if (tmp)
 							{
 							if (bootstrap==tmp->first)
 								{	// warn if there is a prior, consistent definition
 									//! \test zcc/decl.C99/Warn_redeclare_typedef.hpp
 									//! \todo control this warning with an option --no-OAOO or --no-DRY
-								message_header(src.data<0>()[initdecl_identifier_idx].index_tokens[0]);
+								message_header(initdecl_identifier->index_tokens[0]);
 								INC_INFORM(WARN_STR);
 								INC_INFORM("redeclaring typedef ");
 								INFORM(fullname);
@@ -13197,7 +13317,7 @@
 								}
 							else{	// error if there is a prior, inconsistent definition
 									//! \test zcc/decl.C99/Error_redeclare_typedef.hpp
-								message_header(src.data<0>()[initdecl_identifier_idx].index_tokens[0]);
+								message_header(initdecl_identifier->index_tokens[0]);
 								INC_INFORM(ERR_STR);
 								INC_INFORM("redeclaring typedef ");
 								INFORM(fullname);
@@ -13212,7 +13332,7 @@
 							}
 						else{	// register this with types object
 							free(namespace_name);
-							const type_system::enumerator_info* tmp2 = types.get_enumerator_CPP(src.data<0>()[initdecl_identifier_idx].index_tokens[0].token.first,active_namespace);
+							const type_system::enumerator_info* tmp2 = types.get_enumerator_CPP(initdecl_identifier->index_tokens[0].token.first,active_namespace);
 							if (tmp2)
 								{	//! \test zcc/decl.C99/Error_typedef_enum.hpp
 									//! \test zcc/decl.C99/Error_typedef_enum2.hpp
@@ -13226,7 +13346,7 @@
 								zcc_errors.inc_error();
 								return;
 								}							
-							types.set_typedef_CPP(src.c_array<0>()[initdecl_identifier_idx].index_tokens[0].token.first,active_namespace,src.data<0>()[initdecl_identifier_idx].index_tokens[0].src_filename,src.data<0>()[initdecl_identifier_idx].index_tokens[0].logical_line.first,bootstrap);
+							types.set_typedef_CPP(initdecl_identifier->index_tokens[0].token.first,active_namespace,initdecl_identifier->index_tokens[0].src_filename,initdecl_identifier->index_tokens[0].logical_line.first,bootstrap);
 							}
 						}
 #if 0

Modified: trunk/type_spec.hpp
===================================================================
--- trunk/type_spec.hpp	2010-05-08 02:00:16 UTC (rev 416)
+++ trunk/type_spec.hpp	2010-05-08 05:55:32 UTC (rev 417)
@@ -39,7 +39,8 @@
 		_const = (1<<1),	// C/C++ sense, assume works for other languages
 		_volatile = (1<<2),	// C/C++ sense, assume works for other languages
 		_restrict = (1<<3),	// C99 sense, assume works for other languages
-		_array = (1<<4)		// C99 sense, assume works for other languages
+		_array = (1<<4),	// C99 sense, assume works for other languages
+		_function_return_value = (1<<5)	// type for functions without useful prototype information	
 	};
 
 	bool decays_to_nonnull_pointer() const {return 0<pointer_power && (q_vector.back() & _array);};



From zaimoni at mail.berlios.de  Sat May  8 08:04:39 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 8 May 2010 08:04:39 +0200
Subject: [Zcplusplus-commits] r418 - trunk
Message-ID: <201005080604.o4864dxH026106@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-08 08:04:36 +0200 (Sat, 08 May 2010)
New Revision: 418

Modified:
   trunk/CSupport.cpp
Log:
formal memory corruption fix

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-08 05:55:32 UTC (rev 417)
+++ trunk/CSupport.cpp	2010-05-08 06:04:36 UTC (rev 418)
@@ -11407,6 +11407,7 @@
 static size_t CPP_recognize_noptr_declaratorlike_section(parse_tree& x, size_t i,type_spec& target_type, parse_tree*& initdecl_identifier)
 {
 	assert(x.size<0>()>i);
+	bool local_identifier = false;
 	size_t ub = 0;
 	if (	x.data<0>()[i].is_atomic()
 		&& (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags)
@@ -11416,6 +11417,7 @@
 		ub = 1;
 		initdecl_identifier = x.c_array<0>()+i;
 		if (x.size<0>()-i>ub) ub += is_CPP0X_attribute(x.data<0>()[i+ub]);
+		local_identifier = true;
 		}
 	else if (is_naked_parentheses_pair(x.data<0>()[i]))
 		{
@@ -11443,6 +11445,8 @@
 				if (x.size<0>()-i>ub) ub += CPP_cv_qualifier_span(x,i+ub,target_type);
 				if (x.size<0>()-i>ub) ub += is_CPP0X_ref_qualifier(x.c_array<0>()[i+ub]);
 				if (x.size<0>()-i>ub) ub += is_CPP0X_exception_specification_here(x,i+ub);
+				// regenerate the initdecl_identifier if we have it
+				if (local_identifier) initdecl_identifier = x.c_array<0>()+i; 
 				continue;
 				}
 			break;



From zaimoni at mail.berlios.de  Sun May  9 09:00:58 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 9 May 2010 09:00:58 +0200
Subject: [Zcplusplus-commits] r419 - in trunk: . Zaimoni.STL
Message-ID: <201005090700.o4970wms025481@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-09 09:00:49 +0200 (Sun, 09 May 2010)
New Revision: 419

Added:
   trunk/Zaimoni.STL/simple_lock.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/POSIX.dep
   trunk/errors.cpp
   trunk/errors.hpp
Log:
compiling isn't a naturally parallel process anyway at the file level; mock up a lock for suppressing errors that don't make sense for unevaluated expressions

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-08 06:04:36 UTC (rev 418)
+++ trunk/CSupport.cpp	2010-05-09 07:00:49 UTC (rev 419)
@@ -13,6 +13,7 @@
 #include "Zaimoni.STL/lite_alg.hpp"
 #include "Zaimoni.STL/LexParse/LangConf.hpp"
 #include "Zaimoni.STL/search.hpp"
+#include "Zaimoni.STL/simple_lock.hpp"
 #include "AtomicString.h"
 #include "str_aux.h"
 #include "Trigraph.hpp"
@@ -5863,14 +5864,14 @@
 	return false;
 }
 
-static bool int_has_trapped(parse_tree& src,const umaxint& src_int,bool hard_error)
+static bool int_has_trapped(parse_tree& src,const umaxint& src_int)
 {
 	assert(C_TYPE::INT<=src.type_code.base_type_index && C_TYPE::INTEGERLIKE>src.type_code.base_type_index);
 	// check for trap representation for signed types
 	const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
 	if (bool_options[boolopt::int_traps] && 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && target_machine->trap_int(src_int,machine_type))
 		{
-		if (hard_error)
+		if (!no_runtime_errors)
 			simple_error(src," generated a trap representation: undefined behavior (C99 6.2.6.1p5)");
 		return true;
 		}
@@ -5985,7 +5986,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_bitwise_compl(parse_tree& src, const type_system& types,bool hard_error,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_bitwise_compl(parse_tree& src, const type_system& types,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_bitwise_complement_expression(src));
 	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
@@ -6003,7 +6004,7 @@
 		res_int.auto_bitwise_complement();
 		res_int.mask_to(target_machine->C_bit(machine_type));
 
-		if (int_has_trapped(src,res_int,hard_error)) return false;
+		if (int_has_trapped(src,res_int)) return false;
 
 		const bool negative_signed_int = 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && res_int.test(target_machine->C_bit(machine_type)-1);
 		if (negative_signed_int) target_machine->signed_additive_inverse(res_int,machine_type);
@@ -6051,7 +6052,8 @@
 		return;
 		}
 	src.type_code.set_type(tmp.first);
-	if (eval_bitwise_compl(src,types,false,is_C99_unary_operator_expression<'~'>,C99_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_compl(src,types,is_C99_unary_operator_expression<'~'>,C99_intlike_literal_to_VM)) return;
 }
 
 //! \throw std::bad_alloc()
@@ -6066,7 +6068,8 @@
 		return;
 		}
 	src.type_code.set_type(tmp.first);
-	if (eval_bitwise_compl(src,types,false,is_CPP_bitwise_complement_expression,CPP_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_compl(src,types,is_CPP_bitwise_complement_expression,CPP_intlike_literal_to_VM)) return;
 }
 
 //! \throw std::bad_alloc()
@@ -6663,7 +6666,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_mult_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_mult_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'*'>(src));
 
@@ -6727,7 +6730,7 @@
 			if (tweak_ub) ub += 1;
 			if (ub<lhs_test || ub<rhs_test)
 				{
-				if (hard_error)
+				if (!no_runtime_errors)
 					//! \todo catch this in two's-complement specific testing
 					simple_error(src," signed * overflow, undefined behavior (C99 6.5p5, C++98 5p5)");
 				return false;
@@ -6736,7 +6739,7 @@
 			ub /= (lhs_lt_rhs) ? rhs_test : lhs_test;
 			if (ub<(lhs_lt_rhs ? lhs_test : rhs_test))
 				{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
-				if (hard_error)
+				if (!no_runtime_errors)
 					//! \test default/Error_if_control29.hpp, default/Error_if_control29.h
 					simple_error(src," signed * overflow, undefined behavior (C99 6.5p5, C++98 5p5)");
 				return false;
@@ -6772,7 +6775,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_div_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'/'>(src));
 
@@ -6781,7 +6784,7 @@
 		{
 		if 		(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 			{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
-			if (hard_error)
+			if (!no_runtime_errors)
 				//! \test default/Error_if_control30.hpp, default/Error_if_control30.h
 				simple_error(src," division by zero, undefined behavior (C99 6.5.5p5, C++98 5.6p4)");
 			return false;
@@ -6876,7 +6879,7 @@
 			if (ub<lhs_test)
 				{	//! \todo test this in two's complement code
 				assert(virtual_machine::twos_complement==target_machine->C_signed_int_representation());
-				if (hard_error)
+				if (!no_runtime_errors)
 					simple_error(src," signed / overflow, undefined behavior (C99 6.5p5, C++98 5p5)");
 				return false;
 				}
@@ -6899,7 +6902,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_mod_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_mod_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'%'>(src));
 
@@ -6908,7 +6911,7 @@
 		{
 		if 		(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 			{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
-			if (hard_error)
+			if (!no_runtime_errors)
 				//! \test default/Error_if_control31.hpp, Error_if_control31.h
 				simple_error(src," modulo by zero, undefined behavior (C99 6.5.5p5, C++98 5.6p4)");
 			return false;
@@ -7097,14 +7100,16 @@
 	if (C99_MULT_SUBTYPE_MOD==src.subtype)
 		{	// require integral type
 		if (!_mod_expression_typecheck(src ARG_TYPES)) return;
-		eval_mod_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+		zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+		eval_mod_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 		}
 	else{	// require arithmetic type
 		if (!_mult_div_expression_typecheck(src ARG_TYPES)) return;
+		zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
 		if (C99_MULT_SUBTYPE_MULT==src.subtype)
-			eval_mult_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			eval_mult_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 		else
-			eval_div_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);			
+			eval_div_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);			
 		}
 }
 
@@ -7117,14 +7122,16 @@
 	if (C99_MULT_SUBTYPE_MOD==src.subtype)
 		{	// require integral type
 		if (!_mod_expression_typecheck(src ARG_TYPES)) return;
-		eval_mod_expression(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
+		zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+		eval_mod_expression(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
 		}
 	else{	// require arithmetic type
 		if (!_mult_div_expression_typecheck(src ARG_TYPES)) return;
+		zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
 		if (C99_MULT_SUBTYPE_MULT==src.subtype)
-			eval_mult_expression(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
+			eval_mult_expression(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
 		else
-			eval_div_expression(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
+			eval_div_expression(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
 		}
 }
 
@@ -7300,7 +7307,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_add_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_add_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'+'>(src));
 
@@ -7379,7 +7386,7 @@
 						if (tweak_ub) ub += 1;
 						if (ub<lhs_test || ub<rhs_test || (ub -= lhs_test)<rhs_test)
 							{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
-							if (hard_error)
+							if (!no_runtime_errors)
 								//! \test default/Error_if_control41.hpp, default/Error_if_control41.h
 								simple_error(src," signed + overflow, undefined behavior (C99 6.5p5, C++98 5p5)");
 							return false;
@@ -7444,7 +7451,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_sub_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'-'>(src));
 	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power;
@@ -7527,7 +7534,7 @@
 						if (tweak_ub) ub += 1;
 						if (ub<lhs_test || ub<rhs_test || (ub -= lhs_test)<rhs_test)
 							{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
-							if (hard_error)
+							if (!no_runtime_errors)
 								//! \test default/Error_if_control42.hpp, default/Error_if_control42.h
 								simple_error(src," signed - overflow, undefined behavior (C99 6.5p5, C++98 5p5)");
 							return false;
@@ -7650,7 +7657,8 @@
 				}
 #/*cut-cpp*/
 			src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
-			eval_add_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_add_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	case 1:	{	// ptr + integer, hopefully
@@ -7661,7 +7669,8 @@
 				simple_error(src," adds pointer to non-integer (C99 6.5.6p2; C++98 5.7p1)");
 				return;
 				}
-			eval_add_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_add_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	case 2:	{	// integer + ptr, hopefully
@@ -7672,7 +7681,8 @@
 				simple_error(src," adds pointer to non-integer (C99 6.5.6p2; C++98 5.7p1)");
 				return;
 				}
-			eval_add_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_add_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	case 3:	{	//	ptr + ptr dies
@@ -7710,7 +7720,8 @@
 				}
 #/*cut-cpp*/
 			src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
-			eval_sub_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_sub_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	case 5:	{	// ptr - integer, hopefully; requires floating-point literal to test from preprocessor
@@ -7720,7 +7731,8 @@
 				simple_error(src," subtracts non-integer from pointer (C99 6.5.6p3; C++98 5.7p2)");
 				return;
 				}
-			eval_sub_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_sub_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	case 6:	{	// non-ptr - ptr dies
@@ -7738,7 +7750,8 @@
 							:	virtual_machine::std_int_long==tmp ? C_TYPE::LONG
 							:	virtual_machine::std_int_long_long==tmp ? C_TYPE::LLONG : 0));
 			assert(0!=src.type_code.base_type_index);
-			eval_sub_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_sub_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	}
@@ -7875,7 +7888,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_shift(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_shift(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
 	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
@@ -7939,7 +7952,7 @@
 					simple_error(src," : result does not fit in LHS type; undefined behavior (C99 6.5.7p3)");
 #endif
 				res_int <<= rhs_int.to_uint();
-				if (int_has_trapped(src,res_int,hard_error)) return false;
+				if (int_has_trapped(src,res_int)) return false;
 				}
 			else	// if (C99_SHIFT_SUBTYPE_RIGHT==src.subtype)
 				res_int >>= rhs_int.to_uint();
@@ -7973,7 +7986,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.7p2)" ARG_TYPES)) return;
 	src.type_code.base_type_index = default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_shift(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_shift(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
 //! \throw std::bad_alloc()
@@ -7984,7 +7998,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C++98 5.8p1)" ARG_TYPES)) return;
 	src.type_code.base_type_index = default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_shift(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_shift(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
 /*
@@ -8534,7 +8549,7 @@
 }
 
 //! \throw std::bad_alloc
-static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_bitwise_AND(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
 	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
@@ -8574,7 +8589,7 @@
 		res_int &= rhs_int;
 
 		// check for trap representation for signed types
-		if (int_has_trapped(src,res_int,hard_error)) return false;
+		if (int_has_trapped(src,res_int)) return false;
 
 		if 		(res_int==lhs_int)
 			// lhs & rhs = lhs; conserve type
@@ -8628,7 +8643,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.10p2)" ARG_TYPES)) return;
 	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_bitwise_AND(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_AND(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
 //! \throw std::bad_alloc
@@ -8639,7 +8655,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C++98 5.11p1)" ARG_TYPES)) return;
 	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_bitwise_AND(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_AND(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
 /*
@@ -8731,7 +8748,7 @@
 }
 
 // throws std::bad_alloc
-static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
 	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
@@ -8779,7 +8796,7 @@
 		res_int ^= rhs_int;
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
 
-		if (int_has_trapped(src,res_int,hard_error)) return false;
+		if (int_has_trapped(src,res_int)) return false;
 
 		const bool negative_signed_int = old.is_signed && res_int.test(old.bitcount-1);
 		if (negative_signed_int) target_machine->signed_additive_inverse(res_int,old.machine_type);
@@ -8809,7 +8826,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.11p2)" ARG_TYPES)) return;
 	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_bitwise_XOR(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_XOR(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
 // throws std::bad_alloc
@@ -8820,7 +8838,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C++98 5.12p1)" ARG_TYPES)) return;
 	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_bitwise_XOR(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_XOR(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
 /*
@@ -8911,7 +8930,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_bitwise_OR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_bitwise_OR(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
 	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
@@ -8981,7 +9000,7 @@
 			src.eval_to_arg<2>(0);
 			}
 		else{
-			if (int_has_trapped(src,res_int,hard_error)) return false;
+			if (int_has_trapped(src,res_int)) return false;
 
 			const virtual_machine::std_int_enum machine_type = (virtual_machine::std_int_enum)((src.type_code.base_type_index-C_TYPE::INT)/2+virtual_machine::std_int_int);
 			const bool negative_signed_int = 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && res_int.test(target_machine->C_bit(machine_type)-1);
@@ -9012,7 +9031,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.12p2)" ARG_TYPES)) return;
 	src.type_code.base_type_index = arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_bitwise_OR(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_OR(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
 //! \throw std::bad_alloc()
@@ -9023,7 +9043,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C++98 5.13p1)" ARG_TYPES)) return;
 	src.type_code.base_type_index = arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_bitwise_OR(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_OR(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
 /*
@@ -10301,7 +10322,7 @@
 	if (is_bitwise_complement_expression(src))
 		{
 		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_bitwise_compl(src,types,true,is_bitwise_complement_expression,intlike_literal_to_VM)) return true;
+		if (eval_bitwise_compl(src,types,is_bitwise_complement_expression,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -10341,7 +10362,7 @@
 	if (is_C99_mult_operator_expression<'*'>(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_mult_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_mult_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -10355,7 +10376,7 @@
 	if (is_C99_mult_operator_expression<'/'>(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_div_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_div_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -10369,7 +10390,7 @@
 	if (is_C99_mult_operator_expression<'%'>(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_mod_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_mod_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -10383,7 +10404,7 @@
 	if (is_C99_add_operator_expression<'+'>(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_add_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_add_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -10397,7 +10418,7 @@
 	if (is_C99_add_operator_expression<'-'>(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_sub_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_sub_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -10411,7 +10432,7 @@
 	if (is_C99_shift_expression(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_shift(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_shift(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -10454,7 +10475,7 @@
 	if (is_bitwise_AND_expression(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_bitwise_AND(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_bitwise_AND(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -10469,7 +10490,7 @@
 	if (is_bitwise_XOR_expression(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_bitwise_XOR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_bitwise_XOR(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -10484,7 +10505,7 @@
 	if (is_bitwise_OR_expression(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_bitwise_OR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_bitwise_OR(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-08 06:04:36 UTC (rev 418)
+++ trunk/CSupport_pp.cpp	2010-05-09 07:00:49 UTC (rev 419)
@@ -10,6 +10,7 @@
 #include "Zaimoni.STL/lite_alg.hpp"
 #include "Zaimoni.STL/LexParse/LangConf.hpp"
 #include "Zaimoni.STL/search.hpp"
+#include "Zaimoni.STL/simple_lock.hpp"
 #include "AtomicString.h"
 #include "str_aux.h"
 #include "Trigraph.hpp"
@@ -5318,14 +5319,14 @@
 	return false;
 }
 
-static bool int_has_trapped(parse_tree& src,const umaxint& src_int,bool hard_error)
+static bool int_has_trapped(parse_tree& src,const umaxint& src_int)
 {
 	assert(C_TYPE::INT<=src.type_code.base_type_index && C_TYPE::INTEGERLIKE>src.type_code.base_type_index);
 	// check for trap representation for signed types
 	const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
 	if (bool_options[boolopt::int_traps] && 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && target_machine->trap_int(src_int,machine_type))
 		{
-		if (hard_error)
+		if (!no_runtime_errors)
 			simple_error(src," generated a trap representation: undefined behavior (C99 6.2.6.1p5)");
 		return true;
 		}
@@ -5440,7 +5441,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_bitwise_compl(parse_tree& src, const type_system& types,bool hard_error,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_bitwise_compl(parse_tree& src, const type_system& types,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_bitwise_complement_expression(src));
 	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
@@ -5451,7 +5452,7 @@
 		res_int.auto_bitwise_complement();
 		res_int.mask_to(target_machine->C_bit(machine_type));
 
-		if (int_has_trapped(src,res_int,hard_error)) return false;
+		if (int_has_trapped(src,res_int)) return false;
 
 		const bool negative_signed_int = 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && res_int.test(target_machine->C_bit(machine_type)-1);
 		if (negative_signed_int) target_machine->signed_additive_inverse(res_int,machine_type);
@@ -5499,7 +5500,8 @@
 		return;
 		}
 	src.type_code.set_type(tmp.first);
-	if (eval_bitwise_compl(src,types,false,is_C99_unary_operator_expression<'~'>,C99_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_compl(src,types,is_C99_unary_operator_expression<'~'>,C99_intlike_literal_to_VM)) return;
 }
 
 //! \throw std::bad_alloc()
@@ -5514,7 +5516,8 @@
 		return;
 		}
 	src.type_code.set_type(tmp.first);
-	if (eval_bitwise_compl(src,types,false,is_CPP_bitwise_complement_expression,CPP_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_compl(src,types,is_CPP_bitwise_complement_expression,CPP_intlike_literal_to_VM)) return;
 }
 
 //! \throw std::bad_alloc()
@@ -5878,7 +5881,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_mult_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_mult_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'*'>(src));
 
@@ -5942,7 +5945,7 @@
 			if (tweak_ub) ub += 1;
 			if (ub<lhs_test || ub<rhs_test)
 				{
-				if (hard_error)
+				if (!no_runtime_errors)
 					//! \todo catch this in two's-complement specific testing
 					simple_error(src," signed * overflow, undefined behavior (C99 6.5p5, C++98 5p5)");
 				return false;
@@ -5951,7 +5954,7 @@
 			ub /= (lhs_lt_rhs) ? rhs_test : lhs_test;
 			if (ub<(lhs_lt_rhs ? lhs_test : rhs_test))
 				{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
-				if (hard_error)
+				if (!no_runtime_errors)
 					//! \test default/Error_if_control29.hpp, default/Error_if_control29.h
 					simple_error(src," signed * overflow, undefined behavior (C99 6.5p5, C++98 5p5)");
 				return false;
@@ -5987,7 +5990,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_div_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_div_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'/'>(src));
 
@@ -5996,7 +5999,7 @@
 		{
 		if 		(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 			{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
-			if (hard_error)
+			if (!no_runtime_errors)
 				//! \test default/Error_if_control30.hpp, default/Error_if_control30.h
 				simple_error(src," division by zero, undefined behavior (C99 6.5.5p5, C++98 5.6p4)");
 			return false;
@@ -6091,7 +6094,7 @@
 			if (ub<lhs_test)
 				{	//! \todo test this in two's complement code
 				assert(virtual_machine::twos_complement==target_machine->C_signed_int_representation());
-				if (hard_error)
+				if (!no_runtime_errors)
 					simple_error(src," signed / overflow, undefined behavior (C99 6.5p5, C++98 5p5)");
 				return false;
 				}
@@ -6114,7 +6117,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_mod_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_mod_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_mult_operator_expression<'%'>(src));
 
@@ -6123,7 +6126,7 @@
 		{
 		if 		(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
 			{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
-			if (hard_error)
+			if (!no_runtime_errors)
 				//! \test default/Error_if_control31.hpp, Error_if_control31.h
 				simple_error(src," modulo by zero, undefined behavior (C99 6.5.5p5, C++98 5.6p4)");
 			return false;
@@ -6277,14 +6280,16 @@
 	if (C99_MULT_SUBTYPE_MOD==src.subtype)
 		{	// require integral type
 		if (!_mod_expression_typecheck(src ARG_TYPES)) return;
-		eval_mod_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+		zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+		eval_mod_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 		}
 	else{	// require arithmetic type
 		if (!_mult_div_expression_typecheck(src ARG_TYPES)) return;
+		zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
 		if (C99_MULT_SUBTYPE_MULT==src.subtype)
-			eval_mult_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			eval_mult_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 		else
-			eval_div_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);			
+			eval_div_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);			
 		}
 }
 
@@ -6297,14 +6302,16 @@
 	if (C99_MULT_SUBTYPE_MOD==src.subtype)
 		{	// require integral type
 		if (!_mod_expression_typecheck(src ARG_TYPES)) return;
-		eval_mod_expression(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
+		zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+		eval_mod_expression(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
 		}
 	else{	// require arithmetic type
 		if (!_mult_div_expression_typecheck(src ARG_TYPES)) return;
+		zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
 		if (C99_MULT_SUBTYPE_MULT==src.subtype)
-			eval_mult_expression(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
+			eval_mult_expression(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
 		else
-			eval_div_expression(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
+			eval_div_expression(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
 		}
 }
 
@@ -6480,7 +6487,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_add_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_add_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'+'>(src));
 
@@ -6559,7 +6566,7 @@
 						if (tweak_ub) ub += 1;
 						if (ub<lhs_test || ub<rhs_test || (ub -= lhs_test)<rhs_test)
 							{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
-							if (hard_error)
+							if (!no_runtime_errors)
 								//! \test default/Error_if_control41.hpp, default/Error_if_control41.h
 								simple_error(src," signed + overflow, undefined behavior (C99 6.5p5, C++98 5p5)");
 							return false;
@@ -6624,7 +6631,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_sub_expression(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_sub_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(is_C99_add_operator_expression<'-'>(src));
 	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power;
@@ -6707,7 +6714,7 @@
 						if (tweak_ub) ub += 1;
 						if (ub<lhs_test || ub<rhs_test || (ub -= lhs_test)<rhs_test)
 							{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
-							if (hard_error)
+							if (!no_runtime_errors)
 								//! \test default/Error_if_control42.hpp, default/Error_if_control42.h
 								simple_error(src," signed - overflow, undefined behavior (C99 6.5p5, C++98 5p5)");
 							return false;
@@ -6815,7 +6822,8 @@
 				}
 
 			src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
-			eval_add_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_add_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	case 1:	{	// ptr + integer, hopefully
@@ -6826,7 +6834,8 @@
 				simple_error(src," adds pointer to non-integer (C99 6.5.6p2; C++98 5.7p1)");
 				return;
 				}
-			eval_add_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_add_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	case 2:	{	// integer + ptr, hopefully
@@ -6837,7 +6846,8 @@
 				simple_error(src," adds pointer to non-integer (C99 6.5.6p2; C++98 5.7p1)");
 				return;
 				}
-			eval_add_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_add_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	case 3:	{	//	ptr + ptr dies
@@ -6860,7 +6870,8 @@
 				}
 
 			src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
-			eval_sub_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_sub_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	case 5:	{	// ptr - integer, hopefully; requires floating-point literal to test from preprocessor
@@ -6870,7 +6881,8 @@
 				simple_error(src," subtracts non-integer from pointer (C99 6.5.6p3; C++98 5.7p2)");
 				return;
 				}
-			eval_sub_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_sub_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	case 6:	{	// non-ptr - ptr dies
@@ -6888,7 +6900,8 @@
 							:	virtual_machine::std_int_long==tmp ? C_TYPE::LONG
 							:	virtual_machine::std_int_long_long==tmp ? C_TYPE::LLONG : 0));
 			assert(0!=src.type_code.base_type_index);
-			eval_sub_expression(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_sub_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
 			break;
 			}
 	}
@@ -7025,7 +7038,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_shift(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_shift(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
 	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
@@ -7084,7 +7097,7 @@
 					simple_error(src," : result does not fit in LHS type; undefined behavior (C99 6.5.7p3)");
 #endif
 				res_int <<= rhs_int.to_uint();
-				if (int_has_trapped(src,res_int,hard_error)) return false;
+				if (int_has_trapped(src,res_int)) return false;
 				}
 			else	// if (C99_SHIFT_SUBTYPE_RIGHT==src.subtype)
 				res_int >>= rhs_int.to_uint();
@@ -7118,7 +7131,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.7p2)" ARG_TYPES)) return;
 	src.type_code.base_type_index = default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_shift(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_shift(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
 //! \throw std::bad_alloc()
@@ -7129,7 +7143,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C++98 5.8p1)" ARG_TYPES)) return;
 	src.type_code.base_type_index = default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_shift(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_shift(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
 /*
@@ -7679,7 +7694,7 @@
 }
 
 //! \throw std::bad_alloc
-static bool eval_bitwise_AND(parse_tree& src, const type_system& types,bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_bitwise_AND(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
 	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
@@ -7719,7 +7734,7 @@
 		res_int &= rhs_int;
 
 		// check for trap representation for signed types
-		if (int_has_trapped(src,res_int,hard_error)) return false;
+		if (int_has_trapped(src,res_int)) return false;
 
 		if 		(res_int==lhs_int)
 			// lhs & rhs = lhs; conserve type
@@ -7763,7 +7778,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.10p2)" ARG_TYPES)) return;
 	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_bitwise_AND(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_AND(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
 //! \throw std::bad_alloc
@@ -7774,7 +7790,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C++98 5.11p1)" ARG_TYPES)) return;
 	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_bitwise_AND(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_AND(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
 /*
@@ -7866,7 +7883,7 @@
 }
 
 // throws std::bad_alloc
-static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
 	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
@@ -7904,7 +7921,7 @@
 		res_int ^= rhs_int;
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
 
-		if (int_has_trapped(src,res_int,hard_error)) return false;
+		if (int_has_trapped(src,res_int)) return false;
 
 		const bool negative_signed_int = old.is_signed && res_int.test(old.bitcount-1);
 		if (negative_signed_int) target_machine->signed_additive_inverse(res_int,old.machine_type);
@@ -7934,7 +7951,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.11p2)" ARG_TYPES)) return;
 	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_bitwise_XOR(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_XOR(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
 // throws std::bad_alloc
@@ -7945,7 +7963,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C++98 5.12p1)" ARG_TYPES)) return;
 	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_bitwise_XOR(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_XOR(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
 /*
@@ -8036,7 +8055,7 @@
 }
 
 //! \throw std::bad_alloc()
-static bool eval_bitwise_OR(parse_tree& src, const type_system& types, bool hard_error, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+static bool eval_bitwise_OR(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {
 	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
 	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
@@ -8086,7 +8105,7 @@
 			src.eval_to_arg<2>(0);
 			}
 		else{
-			if (int_has_trapped(src,res_int,hard_error)) return false;
+			if (int_has_trapped(src,res_int)) return false;
 
 			const virtual_machine::std_int_enum machine_type = (virtual_machine::std_int_enum)((src.type_code.base_type_index-C_TYPE::INT)/2+virtual_machine::std_int_int);
 			const bool negative_signed_int = 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && res_int.test(target_machine->C_bit(machine_type)-1);
@@ -8117,7 +8136,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.12p2)" ARG_TYPES)) return;
 	src.type_code.base_type_index = arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_bitwise_OR(src,types,false,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_OR(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
 }
 
 //! \throw std::bad_alloc()
@@ -8128,7 +8148,8 @@
 	if (binary_infix_failed_integer_arguments(src,"(C++98 5.13p1)" ARG_TYPES)) return;
 	src.type_code.base_type_index = arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES);
 	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
-	if (eval_bitwise_OR(src,types,false,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_OR(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
 }
 
 /*
@@ -9259,7 +9280,7 @@
 	if (is_bitwise_complement_expression(src))
 		{
 		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_bitwise_compl(src,types,true,is_bitwise_complement_expression,intlike_literal_to_VM)) return true;
+		if (eval_bitwise_compl(src,types,is_bitwise_complement_expression,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -9299,7 +9320,7 @@
 	if (is_C99_mult_operator_expression<'*'>(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_mult_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_mult_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -9313,7 +9334,7 @@
 	if (is_C99_mult_operator_expression<'/'>(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_div_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_div_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -9327,7 +9348,7 @@
 	if (is_C99_mult_operator_expression<'%'>(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_mod_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_mod_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -9341,7 +9362,7 @@
 	if (is_C99_add_operator_expression<'+'>(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_add_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_add_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -9355,7 +9376,7 @@
 	if (is_C99_add_operator_expression<'-'>(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_sub_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_sub_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -9369,7 +9390,7 @@
 	if (is_C99_shift_expression(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_shift(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_shift(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -9412,7 +9433,7 @@
 	if (is_bitwise_AND_expression(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_bitwise_AND(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_bitwise_AND(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -9427,7 +9448,7 @@
 	if (is_bitwise_XOR_expression(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_bitwise_XOR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_bitwise_XOR(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }
@@ -9442,7 +9463,7 @@
 	if (is_bitwise_OR_expression(src))
 		{
 		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
-		if (eval_bitwise_OR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		if (eval_bitwise_OR(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
 		}
 	return false;
 }

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-05-08 06:04:36 UTC (rev 418)
+++ trunk/POSIX.dep	2010-05-09 07:00:49 UTC (rev 419)
@@ -1,8 +1,8 @@
 OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
-OBJECTS_Z_CPP_LINK_PRIORITY = CPreproc_pp.o z_cpp.o unsigned_aux.o ParseTree.o Flat_UNI.o unsigned_var_int.o CSupport_pp.o type_system.o CPUInfo.o CPreproc_autogen_pp.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o errors.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
+OBJECTS_Z_CPP_LINK_PRIORITY = CSupport_pp.o errors.o ParseTree.o type_spec.o uchar_blob.o CPreproc_autogen_pp.o CPUInfo.o load_src.o type_system.o unsigned_var_int.o CPreproc_pp.o z_cpp.o unsigned_aux.o Flat_UNI.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
 
 OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = zcc.o CPreproc.o unsigned_aux.o ParseTree.o Flat_UNI.o unsigned_var_int.o CSupport.o type_system.o CPUInfo.o CPreproc_autogen.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o errors.o uchar_blob.o struct_type.o type_spec.o load_src.o str_aux.o ZParser.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
+OBJECTS_ZCC_LINK_PRIORITY = CSupport.o errors.o ZParser.o ParseTree.o type_spec.o uchar_blob.o CPUInfo.o CPreproc_autogen.o load_src.o type_system.o unsigned_var_int.o zcc.o CPreproc.o unsigned_aux.o Flat_UNI.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
 
 # dependencies
 z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc_pp.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
@@ -19,7 +19,7 @@
 type_system.o: type_system.hpp type_system_pp.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.!
 h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.h!
 pp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -33,7 +33,7 @@
 CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/opera!
 tor.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
-CSupport.o: CSupport.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp!
  type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport.o: CSupport.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp uns!
 igned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zai!
 moni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp

Added: trunk/Zaimoni.STL/simple_lock.hpp
===================================================================
--- trunk/Zaimoni.STL/simple_lock.hpp	2010-05-08 06:04:36 UTC (rev 418)
+++ trunk/Zaimoni.STL/simple_lock.hpp	2010-05-09 07:00:49 UTC (rev 419)
@@ -0,0 +1,25 @@
+// simple_lock.hpp
+// (C)2007 Kenneth Boyd, license: MIT.txt
+
+#ifndef ZAIMONI_STL_SIMPLE_LOCK_HPP
+#define ZAIMONI_STL_SIMPLE_LOCK_HPP 1
+
+namespace zaimoni {
+
+template<class T>
+class simple_lock
+{
+private:
+	T& _lock_counter;
+
+	// copy is not meaningful
+	simple_lock(const simple_lock& src);
+	void operator=(const simple_lock& src);
+public:
+	simple_lock(T& _lock_this) : _lock_counter(_lock_this) {++_lock_counter;};
+	~simple_lock() {--_lock_counter;};
+};
+
+}
+
+#endif

Modified: trunk/errors.cpp
===================================================================
--- trunk/errors.cpp	2010-05-08 06:04:36 UTC (rev 418)
+++ trunk/errors.cpp	2010-05-09 07:00:49 UTC (rev 419)
@@ -149,6 +149,7 @@
 // unsigned short _char_bit, unsigned short _sizeof_short, unsigned short _sizeof_int, unsigned short _sizeof_long, unsigned short _sizeof_long_long
 
 zaimoni::OS::mutex errno_mutex;
+unsigned int no_runtime_errors = 0;
 
 #ifndef NDEBUG
 bool debug_tracer = false;

Modified: trunk/errors.hpp
===================================================================
--- trunk/errors.hpp	2010-05-08 06:04:36 UTC (rev 418)
+++ trunk/errors.hpp	2010-05-09 07:00:49 UTC (rev 419)
@@ -148,6 +148,13 @@
 
 extern zaimoni::OS::mutex errno_mutex;
 
+// following are for use by zaimoni::simple_lock
+/*
+ * some errors are only problems at runtime, and shouldn't be noticed if
+ * the expression is unevaluated
+ */ 
+extern unsigned int no_runtime_errors;
+
 #ifndef NDEBUG
 extern bool debug_tracer;
 #endif



From zaimoni at mail.berlios.de  Sun May  9 20:04:07 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 9 May 2010 20:04:07 +0200
Subject: [Zcplusplus-commits] r420 - in trunk: . Zaimoni.STL
	Zaimoni.STL/LexParse
Message-ID: <201005091804.o49I47tw022781@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-09 20:04:03 +0200 (Sun, 09 May 2010)
New Revision: 420

Modified:
   trunk/Zaimoni.STL/Compiler.h
   trunk/Zaimoni.STL/LexParse/LangConf.cpp
   trunk/Zaimoni.STL/LexParse/LangConf.hpp
   trunk/load_src.cpp
Log:
fix theoretical out-of-bounds array access in ISO build mode

Modified: trunk/Zaimoni.STL/Compiler.h
===================================================================
--- trunk/Zaimoni.STL/Compiler.h	2010-05-09 07:00:49 UTC (rev 419)
+++ trunk/Zaimoni.STL/Compiler.h	2010-05-09 18:04:03 UTC (rev 420)
@@ -1,6 +1,6 @@
 /* Compiler.h */
 /* cross-compiler compatiblity header */
-/* (C)2009 Kenneth Boyd, license: MIT.txt */
+/* (C)2009,2010 Kenneth Boyd, license: MIT.txt */
 
 #ifndef ZAIMONI_COMPILER_H
 #define ZAIMONI_COMPILER_H 1
@@ -13,7 +13,7 @@
 
 /* This macro turns on trying to compile as ISO, rather than with the memory manager extensions */
 #ifdef ZAIMONI_FORCE_ISO
-#define ZAIMONI_LEN_WITH_NULL(A) (A+1)
+#define ZAIMONI_LEN_WITH_NULL(A) ((A)+1)
 #define ZAIMONI_NULL_TERMINATE(A) A = '\0'
 #endif
 

Modified: trunk/Zaimoni.STL/LexParse/LangConf.cpp
===================================================================
--- trunk/Zaimoni.STL/LexParse/LangConf.cpp	2010-05-09 07:00:49 UTC (rev 419)
+++ trunk/Zaimoni.STL/LexParse/LangConf.cpp	2010-05-09 18:04:03 UTC (rev 420)
@@ -1,6 +1,6 @@
 // LangConf.cpp
 // configuration class for lexing programming languages
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 using namespace std;
 #include <memory.h>
@@ -326,13 +326,15 @@
 	return false;
 }
 
+#ifndef ZAIMONI_FORCE_ISO
 void LangConf::_flattenComments(char*& Text)
-{	// note: have to be able to lex
-#ifdef ZAIMONI_FORCE_ISO
-	const size_t TextLength = strlen(Text);
 #else
-	const size_t TextLength = ArraySize(Text);
+void LangConf::_flattenComments(char*& Text, size_t& TextLength)
 #endif
+{	// note: have to be able to lex
+#ifndef ZAIMONI_FORCE_ISO
+	size_t TextLength = ArraySize(Text);
+#endif
 	if (2>=TextLength) return;
 
 	// forward pass
@@ -383,8 +385,8 @@
 	while(TextLength-deduct>++Idx);
 	if (0<deduct)
 		{
-		Text = REALLOC(Text,ZAIMONI_LEN_WITH_NULL(TextLength-deduct));
-		ZAIMONI_NULL_TERMINATE(Text[TextLength-deduct]);
+		Text = REALLOC(Text,ZAIMONI_LEN_WITH_NULL(TextLength-=deduct));
+		ZAIMONI_NULL_TERMINATE(Text[TextLength]);
 		}
 	return;
 }

Modified: trunk/Zaimoni.STL/LexParse/LangConf.hpp
===================================================================
--- trunk/Zaimoni.STL/LexParse/LangConf.hpp	2010-05-09 07:00:49 UTC (rev 419)
+++ trunk/Zaimoni.STL/LexParse/LangConf.hpp	2010-05-09 18:04:03 UTC (rev 420)
@@ -1,6 +1,6 @@
-// LangConf.hxx
+// LangConf.hpp
 // configuration class for lexing programming languages
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #ifndef ZAIMONI_STL_LEXPARSE_LANGCONF_HPP
 #define ZAIMONI_STL_LEXPARSE_LANGCONF_HPP 1
@@ -204,12 +204,21 @@
 		assert(0!=len_MultiLineCommentEnd);	
 		return _len_MultiLineComment(Test);
 		};
-	void FlattenComments(char*& Text)
+#ifndef ZAIMONI_FORCE_ISO
+	void FlattenComments(char*& x)
+#else
+	void FlattenComments(char*& x, size_t& x_len)
+#endif
 		{
-		assert(NULL!=Text);
-		assert('\x00'!=Text[0]);
-		assert('\n'!=Text[strlen(Text)-1]);	// end-of-file check should have intercepted trailing \n
-		_flattenComments(Text);
+		assert(x && *x);
+		// end-of-file check should have intercepted trailing \n
+#ifndef ZAIMONI_FORCE_ISO
+		assert('\n'!=x[ArraySize(x)-1]);	
+		_flattenComments(x);
+#else
+		assert('\n'!=x[x_len-1]);
+		_flattenComments(x,x_len);
+#endif
 		};
 
 	bool ApplyGlobalFilters(char*& Target) const;
@@ -227,36 +236,28 @@
 
 	size_t lex_find(const char* const x, const char* const target) const
 		{
-		assert(NULL!=x);
-		assert('\x00'!=x[0]);
-		assert(NULL!=target);
-		assert('\x00'!=target[0]);
+		assert(x && *x);
+		assert(target && *target);
 		return _lex_find(x,strlen(x),target,strlen(target));
 		};
 	size_t lex_find(const char* const x, const char* const target, size_t target_len) const
 		{
-		assert(NULL!=x);
-		assert('\x00'!=x[0]);
-		assert(NULL!=target);
-		assert('\x00'!=target[0]);
+		assert(x && *x);
+		assert(target && *target);
 		assert(target_len<=strlen(target));
 		return _lex_find(x,strlen(x),target,target_len);
 		};
 	size_t lex_find(const char* const x, size_t x_len, const char* const target) const
 		{
-		assert(NULL!=x);
-		assert('\x00'!=x[0]);
-		assert(NULL!=target);
-		assert('\x00'!=target[0]);
+		assert(x && *x);
+		assert(target && *target);
 		assert(x_len==strlen(x));
 		return _lex_find(x,x_len,target,strlen(target));
 		};
 	size_t lex_find(const char* const x, size_t x_len, const char* const target, size_t target_len) const
 		{
-		assert(NULL!=x);
-		assert('\x00'!=x[0]);
-		assert(NULL!=target);
-		assert('\x00'!=target[0]);
+		assert(x && *x);
+		assert(target && *target);
 		assert(x_len==strlen(x));
 		assert(target_len<=strlen(target));
 		return _lex_find(x,x_len,target,target_len);
@@ -264,44 +265,35 @@
 	// usage of POD_triple: offset, token_len, flags
 	void line_lex(const char* const x, const size_t x_len, autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized) const
 		{
-		assert(NULL!=x);
-		assert('\x00'!=x[0]);
+		assert(x && *x);
 		assert(x_len==strlen(x));
 		_line_lex(x,x_len,pretokenized);
 		};
 
 	bool line_lex_find(const char* const x, const char* const target, autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized) const
 		{
-		assert(NULL!=x);
-		assert('\x00'!=x[0]);
-		assert(NULL!=target);
-		assert('\x00'!=target[0]);
+		assert(x && *x);
+		assert(target && *target);
 		return _line_lex_find(x,strlen(x),target,strlen(target),pretokenized);
 		};
 	bool line_lex_find(const char* const x, const char* const target, size_t target_len, autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized) const
 		{
-		assert(NULL!=x);
-		assert('\x00'!=x[0]);
-		assert(NULL!=target);
-		assert('\x00'!=target[0]);
+		assert(x && *x);
+		assert(target && *target);
 		assert(target_len<=strlen(target));
 		return _line_lex_find(x,strlen(x),target,target_len,pretokenized);
 		};
 	bool line_lex_find(const char* const x, const size_t x_len, const char* const target, autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized) const
 		{
-		assert(NULL!=x);
-		assert('\x00'!=x[0]);
-		assert(NULL!=target);
-		assert('\x00'!=target[0]);
+		assert(x && *x);
+		assert(target && *target);
 		assert(x_len==strlen(x));
 		return _line_lex_find(x,x_len,target,strlen(target),pretokenized);
 		};
 	bool line_lex_find(const char* const x, const size_t x_len, const char* const target, size_t target_len, autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized) const
 		{
-		assert(NULL!=x);
-		assert('\x00'!=x[0]);
-		assert(NULL!=target);
-		assert('\x00'!=target[0]);
+		assert(x && *x);
+		assert(target && *target);
 		assert(x_len==strlen(x));
 		assert(target_len<=strlen(target));
 		return _line_lex_find(x,x_len,target,target_len,pretokenized);
@@ -338,7 +330,11 @@
 	// returns SIZE_MAX on failure, as 0 is a valid offset
 	size_t _lex_find(const char* const x, size_t x_len, const char* const target, size_t target_len) const;
 	void _compactWSAtIdx(char*& Text,size_t Idx) const;
+#ifndef ZAIMONI_FORCE_ISO
 	void _flattenComments(char*& Text);
+#else
+	void _flattenComments(char*& Text, size_t& TextLength);
+#endif
 	void _line_lex(const char* const x, const size_t x_len, autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized) const;
 	bool _line_lex_find(const char* const x, const size_t x_len, const char* const target, size_t target_len, autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized) const;
 };

Modified: trunk/load_src.cpp
===================================================================
--- trunk/load_src.cpp	2010-05-09 07:00:49 UTC (rev 419)
+++ trunk/load_src.cpp	2010-05-09 18:04:03 UTC (rev 420)
@@ -1,5 +1,5 @@
 // load_src.cpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #include "Zaimoni.STL/cstdio"
 #include "Zaimoni.STL/LexParse/Token.hpp"
@@ -100,7 +100,11 @@
 #endif
 		}
 	if (!lang.ApplyGlobalFilters(Buffer)) exit(EXIT_FAILURE);
+#ifndef ZAIMONI_FORCE_ISO
 	lang.FlattenComments(Buffer);
+#else
+	lang.FlattenComments(Buffer,Buffer_size);
+#endif
 
 	SUCCEED_OR_DIE(TokenList.InsertNSlotsAt(1,0));
 #ifndef ZAIMONI_FORCE_ISO



From zaimoni at mail.berlios.de  Sun May  9 21:56:29 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 9 May 2010 21:56:29 +0200
Subject: [Zcplusplus-commits] r421 - in trunk: . Zaimoni.STL/LexParse
Message-ID: <201005091956.o49JuTiY030470@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-09 21:56:23 +0200 (Sun, 09 May 2010)
New Revision: 421

Modified:
   trunk/Flat_UNI.cpp
   trunk/Flat_UNI.hpp
   trunk/Trigraph.cpp
   trunk/Trigraph.hpp
   trunk/Zaimoni.STL/LexParse/LangConf.cpp
   trunk/Zaimoni.STL/LexParse/LangConf.hpp
   trunk/load_src.cpp
Log:
ISO build adjustments; prepare to allow filters to relay error messages (this simplifies load_sourcefile)

Modified: trunk/Flat_UNI.cpp
===================================================================
--- trunk/Flat_UNI.cpp	2010-05-09 18:04:03 UTC (rev 420)
+++ trunk/Flat_UNI.cpp	2010-05-09 19:56:23 UTC (rev 421)
@@ -1,5 +1,5 @@
 // Flat_UNI.cpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #include "Flat_UNI.hpp"
 
@@ -27,7 +27,7 @@
 [also see Appendix E for a validation list...probably should update against latest UNICODE references]
 */
 
-bool FlattenUNICODE(char*& Text)
+bool FlattenUNICODE(char*& Text, const char* filename)
 {
 	if (NULL==Text) return true;
 

Modified: trunk/Flat_UNI.hpp
===================================================================
--- trunk/Flat_UNI.hpp	2010-05-09 18:04:03 UTC (rev 420)
+++ trunk/Flat_UNI.hpp	2010-05-09 19:56:23 UTC (rev 421)
@@ -1,5 +1,5 @@
 // Flat_UNI.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #ifndef Z_CPLUSPLUS_FLAT_UNI_HPP
 #define Z_CPLUSPLUS_FLAT_UNI_HPP 1
@@ -11,7 +11,7 @@
  *
  * \return true, return value is only to glue into LangConf
  */
-bool FlattenUNICODE(char*& Text);
+bool FlattenUNICODE(char*& Text, const char* filename);
 
 #endif
 

Modified: trunk/Trigraph.cpp
===================================================================
--- trunk/Trigraph.cpp	2010-05-09 18:04:03 UTC (rev 420)
+++ trunk/Trigraph.cpp	2010-05-09 19:56:23 UTC (rev 421)
@@ -1,5 +1,5 @@
 // Trigraph.cpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #include "Trigraph.hpp"
 
@@ -49,8 +49,7 @@
 /* Aside: ??? is not supported in C99 or C++0x; example in 4 may be a doc. error for C++97.  Given table row was in HTML version but not PDF version. */
 /* C89 rationale suggest to omit ??? */
 
-static size_t
-EnforceTrigraphsAux(size_t& Offset, char* const Text)
+static size_t EnforceTrigraphsAux(size_t& Offset, char* const Text)
 {	// FORMALLY CORRECT: Kenneth Boyd, 10/17/2004
 	// this returns how much to increment i by (not directly passed)
 	if ('?'!=Text[1]) return 2;	// total miss: increment by 2
@@ -173,7 +172,7 @@
 	return 3;
 }
 
-bool EnforceCTrigraphs(char*& Text)
+bool EnforceCTrigraphs(char*& Text, const char* filename)
 {	// FORMALLY CORRECT: Kenneth Boyd, 8/1/2002
 	// there are 10 C trigraphs of interest (?)
 	// We use a modified Boyer-Moore algorithm, and compact after 

Modified: trunk/Trigraph.hpp
===================================================================
--- trunk/Trigraph.hpp	2010-05-09 18:04:03 UTC (rev 420)
+++ trunk/Trigraph.hpp	2010-05-09 19:56:23 UTC (rev 421)
@@ -1,5 +1,5 @@
 // Trigraph.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #ifndef Z_CPLUSPLUS_TRIGRAPH_HPP
 #define Z_CPLUSPLUS_TRIGRAPH_HPP 1
@@ -11,6 +11,6 @@
  *
  * \return true, return value is only to glue into LangConf
  */
-bool EnforceCTrigraphs(char*& Text);
+bool EnforceCTrigraphs(char*& Text, const char* filename);
 
 #endif

Modified: trunk/Zaimoni.STL/LexParse/LangConf.cpp
===================================================================
--- trunk/Zaimoni.STL/LexParse/LangConf.cpp	2010-05-09 18:04:03 UTC (rev 420)
+++ trunk/Zaimoni.STL/LexParse/LangConf.cpp	2010-05-09 19:56:23 UTC (rev 421)
@@ -26,11 +26,19 @@
 //! <br>NOTE: we can pre-emptively break on newline outside of strings no matter what.
 //! <br>NOTE: we can discard pure-whitespace lines no matter what
 
-static bool _applyFilters(LangConf::Filter** FilterList, const size_t FilterSize, char*& Target)
+#ifndef ZAIMONI_FORCE_ISO
+static bool _applyFilters(LangConf::Filter** FilterList, const size_t FilterSize, char*& x, const char* filename)
+#else
+static bool _applyFilters(LangConf::Filter** FilterList, const size_t FilterSize, char*& x, size_t& x_len, const char* filename)
+#endif
 {	//! \pre FilterList!=NULL
-	//! \pre Target!=NULL
+	//! \pre x!=NULL
 	size_t i = 0;
-	do	if (!FilterList[i](Target) || NULL==Target) return false;
+#ifndef ZAIMONI_FORCE_ISO
+	do	if (!FilterList[i](x,filename) || !x) return false;
+#else
+	do	if (!FilterList[i](x,x_len,filename) || !x) return false;
+#endif
 	while(FilterSize> ++i);
 	return true;
 }
@@ -131,20 +139,36 @@
 		}	
 }
 
-bool LangConf::ApplyGlobalFilters(char*& Target) const
+#ifndef ZAIMONI_FORCE_ISO
+bool LangConf::ApplyGlobalFilters(char*& x, const char* filename) const
+#else
+bool LangConf::ApplyGlobalFilters(char*& x, size_t& x_len, const char* filename) const
+#endif
 {
-	if (NULL!=Target)
+	if (x)
 		{	// legal char set is a global filter, but should be fairly late (after comment-stripping)
-		if (NULL!=GlobalFilters && !_applyFilters(GlobalFilters,GlobalFilters.size(),Target))
-			return NULL==Target;
+#ifndef ZAIMONI_FORCE_ISO
+		if (!GlobalFilters.empty() && !_applyFilters(GlobalFilters,GlobalFilters.size(),x,filename))
+#else
+		if (!GlobalFilters.empty() && !_applyFilters(GlobalFilters,GlobalFilters.size(),x,x_len,filename))
+#endif
+			return !x;
 		}
 	return true;
 }
 
-bool LangConf::ApplyTokenizingFilters(char*& Target) const
+#ifndef ZAIMONI_FORCE_ISO
+bool LangConf::ApplyTokenizingFilters(char*& x) const
+#else
+bool LangConf::ApplyTokenizingFilters(char*& x, size_t& x_len) const
+#endif
 {
-	if (NULL==TokenizingFilters || NULL==Target) return true;
-	return _applyFilters(TokenizingFilters,TokenizingFilters.size(),Target);
+	if (TokenizingFilters.empty() || !x) return true;
+#ifndef ZAIMONI_FORCE_ISO
+	return _applyFilters(TokenizingFilters,TokenizingFilters.size(),x,NULL);
+#else
+	return _applyFilters(TokenizingFilters,TokenizingFilters.size(),x,x_len,NULL);
+#endif
 }
 
 size_t LangConf::TokenizeCore(const char* Target, lex_flags& Flags) const
@@ -189,20 +213,28 @@
 	return TokenizeCore(Target,Flags);
 }
 
-size_t LangConf::NextToken(char*& Target, lex_flags& Flags) const
+#ifndef ZAIMONI_FORCE_ISO
+size_t LangConf::NextToken(char*& x, lex_flags& Flags) const
+#else
+size_t LangConf::NextToken(char*& x, size_t& x_len, lex_flags& Flags) const
+#endif
 {
-	if (NULL==Target) return 0;
-	if (NULL!=TokenizingFilters && !_applyFilters(TokenizingFilters,TokenizingFilters.size(),Target))
+	if (!x) return 0;
+#ifndef ZAIMONI_FORCE_ISO
+	if (!TokenizingFilters.empty() && !_applyFilters(TokenizingFilters,TokenizingFilters.size(),x,NULL))
+#else
+	if (!TokenizingFilters.empty() && !_applyFilters(TokenizingFilters,TokenizingFilters.size(),x,x_len,NULL))
+#endif
 		return 0;
 
-	return TokenizeCore(Target,Flags);
+	return TokenizeCore(x,Flags);
 }
 
-bool LangConf::InstallTokenizer(Tokenizer* Source,lex_flags SourceFlags)
+bool LangConf::InstallTokenizer(Tokenizer* src,lex_flags src_flags)
 {
 	const size_t StackSize = Tokenizers.size();
-	if (!Tokenizers.InsertSlotAt(StackSize,Source)) return false;
-	if (!TokenizerFlags.InsertSlotAt(StackSize,SourceFlags))
+	if (!Tokenizers.InsertSlotAt(StackSize,src)) return false;
+	if (!TokenizerFlags.InsertSlotAt(StackSize,src_flags))
 		{
 		Tokenizers.DeleteIdx(StackSize);
 		return false;

Modified: trunk/Zaimoni.STL/LexParse/LangConf.hpp
===================================================================
--- trunk/Zaimoni.STL/LexParse/LangConf.hpp	2010-05-09 18:04:03 UTC (rev 420)
+++ trunk/Zaimoni.STL/LexParse/LangConf.hpp	2010-05-09 19:56:23 UTC (rev 421)
@@ -89,7 +89,11 @@
 class LangConf
 {
 public:
-	typedef bool Filter(char*& Target);
+#ifndef ZAIMONI_FORCE_ISO
+	typedef bool Filter(char*& x, const char* filename);
+#else
+	typedef bool Filter(char*& x, size_t& x_len, const char* filename);
+#endif
 	typedef size_t Tokenizer(const char* Target);
 	typedef size_t PredictTransform(const char* Target, size_t src_len);
 	typedef void Transform(char* dest, const char* src, size_t src_len);
@@ -221,19 +225,28 @@
 #endif
 		};
 
-	bool ApplyGlobalFilters(char*& Target) const;
-	bool ApplyTokenizingFilters(char*& Target) const;
+#ifndef ZAIMONI_FORCE_ISO
+	bool ApplyGlobalFilters(char*& x, const char* filename) const;
+	bool ApplyTokenizingFilters(char*& x) const;
+#else
+	bool ApplyGlobalFilters(char*& x, size_t& x_len, const char* filename) const;
+	bool ApplyTokenizingFilters(char*& x, size_t& x_len) const;
+#endif
 private:
 	size_t TokenizeCore(const char* Target, lex_flags& Flags) const;
 	size_t UnfilteredCommentHidingNextToken(const char* Target, lex_flags& Flags) const;	// internal
 public:
 	size_t UnfilteredNextToken(const char* Target, lex_flags& Flags) const;
-	size_t NextToken(char*& Target, lex_flags& Flags) const;
+#ifndef ZAIMONI_FORCE_ISO
+	size_t NextToken(char*& x, lex_flags& Flags) const;
+#else
+	size_t NextToken(char*& x, size_t& x_len, lex_flags& Flags) const;
+#endif
+	
+	bool InstallGlobalFilter(Filter* src) { return GlobalFilters.InsertSlotAt(GlobalFilters.size(),src);	};
+	bool InstallTokenizingFilter(Filter* src)	{	return TokenizingFilters.InsertSlotAt(TokenizingFilters.size(),src);	};
+	bool InstallTokenizer(Tokenizer* src,lex_flags src_flags);
 
-	bool InstallGlobalFilter(Filter* Source) { return GlobalFilters.InsertSlotAt(GlobalFilters.size(),Source);	};
-	bool InstallTokenizingFilter(Filter* Source)	{	return TokenizingFilters.InsertSlotAt(TokenizingFilters.size(),Source);	};
-	bool InstallTokenizer(Tokenizer* Source,lex_flags SourceFlags);
-
 	size_t lex_find(const char* const x, const char* const target) const
 		{
 		assert(x && *x);

Modified: trunk/load_src.cpp
===================================================================
--- trunk/load_src.cpp	2010-05-09 18:04:03 UTC (rev 420)
+++ trunk/load_src.cpp	2010-05-09 19:56:23 UTC (rev 421)
@@ -99,10 +99,11 @@
 		Buffer = REALLOC(Buffer,--Buffer_size);
 #endif
 		}
-	if (!lang.ApplyGlobalFilters(Buffer)) exit(EXIT_FAILURE);
 #ifndef ZAIMONI_FORCE_ISO
+	if (!lang.ApplyGlobalFilters(Buffer,filename)) exit(EXIT_FAILURE);
 	lang.FlattenComments(Buffer);
 #else
+	if (!lang.ApplyGlobalFilters(Buffer,Buffer_size,filename)) exit(EXIT_FAILURE);
 	lang.FlattenComments(Buffer,Buffer_size);
 #endif
 



From zaimoni at mail.berlios.de  Mon May 10 00:28:41 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 10 May 2010 00:28:41 +0200
Subject: [Zcplusplus-commits] r422 - in trunk: . tools
Message-ID: <201005092228.o49MSfVM010864@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-10 00:28:38 +0200 (Mon, 10 May 2010)
New Revision: 422

Modified:
   trunk/MakeMake.cfg
   trunk/tools/MakeMake.py
Log:
adjust makefile generator to not require continual reversion with current configuration

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2010-05-09 19:56:23 UTC (rev 421)
+++ trunk/MakeMake.cfg	2010-05-09 22:28:38 UTC (rev 422)
@@ -7,6 +7,9 @@
 C_assembly_preprocessing = ''
 object_strip = ''
 #object_strip = 'strip --preserve-dates --strip-unneeded $*.o'
+extra_clean = ' lib/host.zcc/*.a\n\tcd Zaimoni.STL; make clean'
+extra_targets = 'make_Zaimoni_STL:\n\tcd Zaimoni.STL; make host_install\n\n'
+extra_prereqs = ' make_Zaimoni_STL'
 
 # defines catalog
 # ZAIMONI_FORCE_ISO: try to build as ISO C++ rather than with custom memory manager (pre-alpha)

Modified: trunk/tools/MakeMake.py
===================================================================
--- trunk/tools/MakeMake.py	2010-05-09 19:56:23 UTC (rev 421)
+++ trunk/tools/MakeMake.py	2010-05-09 22:28:38 UTC (rev 422)
@@ -205,19 +205,22 @@
 	LineList.append('\n')
 
 	LineList.append('clean:\n')
-	LineList.append('\trm -f *.o *.exe\n')
+	LineList.append('\trm -f *.o *.exe'+extra_clean+'\n')
 	LineList.append('\n')
 
 	LineList.append('# dependencies\n')
 	LineList.append('include POSIX.dep\n\n')
 
+	if extra_targets:
+		LineList.append(extra_targets)
+
 	# target spec (must attempt to make most recently altered files first)
 	for ProgName in ProgObjects.keys():
 		LineList2.append('OBJECTS_'+ProgName.upper()+' = '+join(map(lambda x: x+'.o',ProgObjects[ProgName]),' ')+'\n')
 		ObjfileListBase = map(lambda x: (x,stat(x+(CPP_suffix if isfile(x+CPP_suffix) else '.c'))[8]),ProgObjects[ProgName])
 		ObjfileListBase.sort(lambda x,y : -cmp(x[1],y[1]))
 		LineList2.append('OBJECTS_'+ProgName.upper()+'_LINK_PRIORITY = ' + join(map(lambda x: x[0] + '.o',ObjfileListBase),' ') + '\n\n')
-		LineList.append(ProgName+'.exe : $(OBJECTS_'+ProgName.upper()+'_LINK_PRIORITY)\n')
+		LineList.append(ProgName+'.exe :'+extra_prereqs+' $(OBJECTS_'+ProgName.upper()+'_LINK_PRIORITY)\n')
 		if ProgName in CPP_override_libraries:
 			LineList.append('\t'+CPP_compiler+' $(LINK_FLAGS) -o'+ProgName+'.exe $(OBJECTS_'+ProgName.upper()+') ' + CPP_override_libraries[ProgName] + '\n')
 		else:



From zaimoni at mail.berlios.de  Mon May 10 01:02:09 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 10 May 2010 01:02:09 +0200
Subject: [Zcplusplus-commits] r423 - trunk
Message-ID: <201005092302.o49N29GR032219@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-10 01:02:01 +0200 (Mon, 10 May 2010)
New Revision: 423

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/MakeMake.cfg
   trunk/POSIX.dep
   trunk/load_src.cpp
Log:
global filter for terminal line continue warning

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-09 22:28:38 UTC (rev 422)
+++ trunk/CSupport.cpp	2010-05-09 23:02:01 UTC (rev 423)
@@ -18,6 +18,7 @@
 #include "str_aux.h"
 #include "Trigraph.hpp"
 #include "Flat_UNI.hpp"
+#include "end_lc.hpp"
 #include "errors.hpp"
 #include "errcount.hpp"
 #include "CPUInfo.hpp"
@@ -13521,6 +13522,7 @@
 									0,2,
 									'\\','\\',true,true);
 
+	CLexer->InstallGlobalFilter(&TerminalLineContinue);
 	CLexer->InstallGlobalFilter(&EnforceCTrigraphs);
 	CLexer->InstallGlobalFilter(&FlattenUNICODE);
 
@@ -13530,6 +13532,7 @@
 	CLexer->InstallTokenizer(&LengthOfCIdentifier,CPP_FLAG_IDENTIFIER);
 	CLexer->InstallTokenizer(&LengthOfCPreprocessingNumber,CPP_FLAG_PP_NUMERAL);
 
+	CPlusPlusLexer->InstallGlobalFilter(&TerminalLineContinue);
 	CPlusPlusLexer->InstallGlobalFilter(&EnforceCTrigraphs);
 	CPlusPlusLexer->InstallGlobalFilter(&FlattenUNICODE);
 

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-09 22:28:38 UTC (rev 422)
+++ trunk/CSupport_pp.cpp	2010-05-09 23:02:01 UTC (rev 423)
@@ -15,6 +15,7 @@
 #include "str_aux.h"
 #include "Trigraph.hpp"
 #include "Flat_UNI.hpp"
+#include "end_lc.hpp"
 #include "errors.hpp"
 #include "errcount.hpp"
 #include "CPUInfo.hpp"
@@ -9823,6 +9824,7 @@
 									0,2,
 									'\\','\\',true,true);
 
+	CLexer->InstallGlobalFilter(&TerminalLineContinue);
 	CLexer->InstallGlobalFilter(&EnforceCTrigraphs);
 	CLexer->InstallGlobalFilter(&FlattenUNICODE);
 
@@ -9832,6 +9834,7 @@
 	CLexer->InstallTokenizer(&LengthOfCIdentifier,CPP_FLAG_IDENTIFIER);
 	CLexer->InstallTokenizer(&LengthOfCPreprocessingNumber,CPP_FLAG_PP_NUMERAL);
 
+	CPlusPlusLexer->InstallGlobalFilter(&TerminalLineContinue);
 	CPlusPlusLexer->InstallGlobalFilter(&EnforceCTrigraphs);
 	CPlusPlusLexer->InstallGlobalFilter(&FlattenUNICODE);
 

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2010-05-09 22:28:38 UTC (rev 422)
+++ trunk/MakeMake.cfg	2010-05-09 23:02:01 UTC (rev 423)
@@ -1,6 +1,6 @@
 ########
-ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport_pp','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc_pp','CPreproc_autogen_pp'),
-				'zcc':('zcc','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','load_src','CPreproc','CPreproc_autogen','ZParser')}
+ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport_pp','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','load_src','CPreproc_pp','CPreproc_autogen_pp'),
+				'zcc':('zcc','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','load_src','CPreproc','CPreproc_autogen','ZParser')}
 MainPrograms = ['z_cpp','zcc']
 
 # process control

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-05-09 22:28:38 UTC (rev 422)
+++ trunk/POSIX.dep	2010-05-09 23:02:01 UTC (rev 423)
@@ -1,8 +1,8 @@
-OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
-OBJECTS_Z_CPP_LINK_PRIORITY = CSupport_pp.o errors.o ParseTree.o type_spec.o uchar_blob.o CPreproc_autogen_pp.o CPUInfo.o load_src.o type_system.o unsigned_var_int.o CPreproc_pp.o z_cpp.o unsigned_aux.o Flat_UNI.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
+OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
+OBJECTS_Z_CPP_LINK_PRIORITY = CSupport_pp.o load_src.o end_lc.o Trigraph.o Flat_UNI.o errors.o ParseTree.o type_spec.o uchar_blob.o CPreproc_autogen_pp.o CPUInfo.o type_system.o unsigned_var_int.o CPreproc_pp.o z_cpp.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
 
-OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = CSupport.o errors.o ZParser.o ParseTree.o type_spec.o uchar_blob.o CPUInfo.o CPreproc_autogen.o load_src.o type_system.o unsigned_var_int.o zcc.o CPreproc.o unsigned_aux.o Flat_UNI.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o
+OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
+OBJECTS_ZCC_LINK_PRIORITY = CSupport.o load_src.o end_lc.o Trigraph.o Flat_UNI.o errors.o ZParser.o ParseTree.o type_spec.o uchar_blob.o CPUInfo.o CPreproc_autogen.o type_system.o unsigned_var_int.o zcc.o CPreproc.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
 
 # dependencies
 z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc_pp.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
@@ -19,7 +19,7 @@
 type_system.o: type_system.hpp type_system_pp.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.h!
 pp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp !
 type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -29,11 +29,12 @@
 unsigned_aux.o: unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 Trigraph.o: Trigraph.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 Flat_UNI.o: Flat_UNI.hpp lex_core.h Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
+end_lc.o: end_lc.hpp Zaimoni.STL/MetaRAM2.hpp errors.hpp errcount.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/stdio_c.h Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
 CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/opera!
 tor.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
-CSupport.o: CSupport.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp uns!
 igned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport.o: CSupport.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_!
 int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zai!
 moni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp

Modified: trunk/load_src.cpp
===================================================================
--- trunk/load_src.cpp	2010-05-09 22:28:38 UTC (rev 422)
+++ trunk/load_src.cpp	2010-05-09 23:02:01 UTC (rev 423)
@@ -88,18 +88,7 @@
 		}
 	}
 
-	if ('\\'==Buffer[Buffer_size-1])	// works for C/C++ and other line-continue languages
-		{
-		INC_INFORM(filename);
-		INFORM(": warning: line continue \\ without a subsequent line, undefined behavior.  Proceeding as if subsequent line was empty.");
-		if (1==Buffer_size) return free(Buffer),true;
 #ifndef ZAIMONI_FORCE_ISO
-		Buffer = REALLOC(Buffer,ArraySize(Buffer)-1);
-#else
-		Buffer = REALLOC(Buffer,--Buffer_size);
-#endif
-		}
-#ifndef ZAIMONI_FORCE_ISO
 	if (!lang.ApplyGlobalFilters(Buffer,filename)) exit(EXIT_FAILURE);
 	lang.FlattenComments(Buffer);
 #else



From zaimoni at mail.berlios.de  Mon May 10 02:44:20 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 10 May 2010 02:44:20 +0200
Subject: [Zcplusplus-commits] r424 - trunk
Message-ID: <201005100044.o4A0iKuB026664@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-10 02:44:07 +0200 (Mon, 10 May 2010)
New Revision: 424

Added:
   trunk/end_lc.cpp
   trunk/end_lc.hpp
   trunk/end_nl.cpp
   trunk/end_nl.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/MakeMake.cfg
   trunk/POSIX.dep
   trunk/load_src.cpp
Log:
unbreak SVN; move trailing newline cleanup to a global filter

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-09 23:02:01 UTC (rev 423)
+++ trunk/CSupport.cpp	2010-05-10 00:44:07 UTC (rev 424)
@@ -19,6 +19,7 @@
 #include "Trigraph.hpp"
 #include "Flat_UNI.hpp"
 #include "end_lc.hpp"
+#include "end_nl.hpp"
 #include "errors.hpp"
 #include "errcount.hpp"
 #include "CPUInfo.hpp"
@@ -13522,6 +13523,7 @@
 									0,2,
 									'\\','\\',true,true);
 
+	CLexer->InstallGlobalFilter(&TrimMandatoryTerminalNewline);
 	CLexer->InstallGlobalFilter(&TerminalLineContinue);
 	CLexer->InstallGlobalFilter(&EnforceCTrigraphs);
 	CLexer->InstallGlobalFilter(&FlattenUNICODE);
@@ -13532,6 +13534,7 @@
 	CLexer->InstallTokenizer(&LengthOfCIdentifier,CPP_FLAG_IDENTIFIER);
 	CLexer->InstallTokenizer(&LengthOfCPreprocessingNumber,CPP_FLAG_PP_NUMERAL);
 
+	CPlusPlusLexer->InstallGlobalFilter(&TrimMandatoryTerminalNewline);
 	CPlusPlusLexer->InstallGlobalFilter(&TerminalLineContinue);
 	CPlusPlusLexer->InstallGlobalFilter(&EnforceCTrigraphs);
 	CPlusPlusLexer->InstallGlobalFilter(&FlattenUNICODE);

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-09 23:02:01 UTC (rev 423)
+++ trunk/CSupport_pp.cpp	2010-05-10 00:44:07 UTC (rev 424)
@@ -16,6 +16,7 @@
 #include "Trigraph.hpp"
 #include "Flat_UNI.hpp"
 #include "end_lc.hpp"
+#include "end_nl.hpp"
 #include "errors.hpp"
 #include "errcount.hpp"
 #include "CPUInfo.hpp"
@@ -9824,6 +9825,7 @@
 									0,2,
 									'\\','\\',true,true);
 
+	CLexer->InstallGlobalFilter(&TrimMandatoryTerminalNewline);
 	CLexer->InstallGlobalFilter(&TerminalLineContinue);
 	CLexer->InstallGlobalFilter(&EnforceCTrigraphs);
 	CLexer->InstallGlobalFilter(&FlattenUNICODE);
@@ -9834,6 +9836,7 @@
 	CLexer->InstallTokenizer(&LengthOfCIdentifier,CPP_FLAG_IDENTIFIER);
 	CLexer->InstallTokenizer(&LengthOfCPreprocessingNumber,CPP_FLAG_PP_NUMERAL);
 
+	CPlusPlusLexer->InstallGlobalFilter(&TrimMandatoryTerminalNewline);
 	CPlusPlusLexer->InstallGlobalFilter(&TerminalLineContinue);
 	CPlusPlusLexer->InstallGlobalFilter(&EnforceCTrigraphs);
 	CPlusPlusLexer->InstallGlobalFilter(&FlattenUNICODE);

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2010-05-09 23:02:01 UTC (rev 423)
+++ trunk/MakeMake.cfg	2010-05-10 00:44:07 UTC (rev 424)
@@ -1,6 +1,6 @@
 ########
-ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport_pp','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','load_src','CPreproc_pp','CPreproc_autogen_pp'),
-				'zcc':('zcc','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','load_src','CPreproc','CPreproc_autogen','ZParser')}
+ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport_pp','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','end_nl','load_src','CPreproc_pp','CPreproc_autogen_pp'),
+				'zcc':('zcc','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','end_nl','load_src','CPreproc','CPreproc_autogen','ZParser')}
 MainPrograms = ['z_cpp','zcc']
 
 # process control

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-05-09 23:02:01 UTC (rev 423)
+++ trunk/POSIX.dep	2010-05-10 00:44:07 UTC (rev 424)
@@ -1,8 +1,8 @@
-OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
-OBJECTS_Z_CPP_LINK_PRIORITY = CSupport_pp.o load_src.o end_lc.o Trigraph.o Flat_UNI.o errors.o ParseTree.o type_spec.o uchar_blob.o CPreproc_autogen_pp.o CPUInfo.o type_system.o unsigned_var_int.o CPreproc_pp.o z_cpp.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
+OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
+OBJECTS_Z_CPP_LINK_PRIORITY = load_src.o CSupport_pp.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o ParseTree.o type_spec.o uchar_blob.o CPreproc_autogen_pp.o CPUInfo.o type_system.o unsigned_var_int.o CPreproc_pp.o z_cpp.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
 
-OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = CSupport.o load_src.o end_lc.o Trigraph.o Flat_UNI.o errors.o ZParser.o ParseTree.o type_spec.o uchar_blob.o CPUInfo.o CPreproc_autogen.o type_system.o unsigned_var_int.o zcc.o CPreproc.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
+OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
+OBJECTS_ZCC_LINK_PRIORITY = load_src.o end_nl.o CSupport.o end_lc.o Trigraph.o Flat_UNI.o errors.o ZParser.o ParseTree.o type_spec.o uchar_blob.o CPUInfo.o CPreproc_autogen.o type_system.o unsigned_var_int.o zcc.o CPreproc.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
 
 # dependencies
 z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc_pp.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
@@ -19,7 +19,7 @@
 type_system.o: type_system.hpp type_system_pp.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp !
 type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp ucha!
 r_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -30,11 +30,12 @@
 Trigraph.o: Trigraph.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 Flat_UNI.o: Flat_UNI.hpp lex_core.h Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 end_lc.o: end_lc.hpp Zaimoni.STL/MetaRAM2.hpp errors.hpp errcount.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
+end_nl.o: end_nl.hpp Zaimoni.STL/MetaRAM2.hpp errors.hpp errcount.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/stdio_c.h Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
 CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/opera!
 tor.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
-CSupport.o: CSupport.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_!
 int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport.o: CSupport.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp un!
 signed_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zai!
 moni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp

Added: trunk/end_lc.cpp
===================================================================
--- trunk/end_lc.cpp	2010-05-09 23:02:01 UTC (rev 423)
+++ trunk/end_lc.cpp	2010-05-10 00:44:07 UTC (rev 424)
@@ -0,0 +1,36 @@
+// end_lc.cpp
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#include "end_lc.hpp"
+
+#include "Zaimoni.STL/MetaRAM2.hpp"
+
+#include "errors.hpp"
+#include "errcount.hpp"
+
+using namespace zaimoni;
+
+#ifndef ZAIMONI_FORCE_ISO
+bool TerminalLineContinue(char*& x, const char* filename)
+#else
+bool TerminalLineContinue(char*& x, size_t& x_len, const char* filename)
+#endif
+{
+#ifndef ZAIMONI_FORCE_ISO
+#define x_len ArraySize(x)
+#endif
+	if ('\\'==x[x_len-1])	// works for C/C++ and other line-continue languages
+		{
+		INC_INFORM(filename);
+		INFORM(": warning: line continue \\ without a subsequent line, undefined behavior.  Proceeding as if subsequent line was empty.");
+		if (bool_options[boolopt::warnings_are_errors])
+			zcc_errors.inc_error();		
+		if (1==x_len) return free(x),true;
+#ifndef ZAIMONI_FORCE_ISO
+		x = REALLOC(x,ArraySize(x)-1);
+#else
+		x = REALLOC(x,--x_len);
+#endif
+		}
+	return true;
+}

Added: trunk/end_lc.hpp
===================================================================
--- trunk/end_lc.hpp	2010-05-09 23:02:01 UTC (rev 423)
+++ trunk/end_lc.hpp	2010-05-10 00:44:07 UTC (rev 424)
@@ -0,0 +1,26 @@
+// end_lc.hpp
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#ifndef Z_CPLUSPLUS_END_LC_HPP
+#define Z_CPLUSPLUS_END_LC_HPP 1
+
+/**
+ * Removes any terminal line continue from the char buffer x, and warns if one
+ * is found.
+ *
+ * \pre char buffer x allocated with C memory manager  x_len, in ISO mode, is
+ * \pre the length of the buffer x.
+ *
+ * \return true, return value is only to glue into LangConf
+ */
+#ifndef ZAIMONI_FORCE_ISO
+bool TerminalLineContinue(char*& x, const char* filename);
+#else
+#include <stddef.h>
+
+bool TerminalLineContinue(char*& x, size_t& x_len, const char* filename);
+#endif
+
+#endif
+
+

Added: trunk/end_nl.cpp
===================================================================
--- trunk/end_nl.cpp	2010-05-09 23:02:01 UTC (rev 423)
+++ trunk/end_nl.cpp	2010-05-10 00:44:07 UTC (rev 424)
@@ -0,0 +1,41 @@
+// end_nl.cpp
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#include "end_nl.hpp"
+
+#include "Zaimoni.STL/MetaRAM2.hpp"
+
+#include "errors.hpp"
+#include "errcount.hpp"
+
+using namespace zaimoni;
+
+#ifndef ZAIMONI_FORCE_ISO
+bool TrimMandatoryTerminalNewline(char*& x, const char* filename)
+#else
+bool TrimMandatoryTerminalNewline(char*& x, size_t& x_len, const char* filename)
+#endif
+{
+#ifndef ZAIMONI_FORCE_ISO
+#define x_len ArraySize(x)
+#endif
+	size_t newline_count = 0;
+	const size_t x_len_sub1 = x_len-1;
+	while(newline_count<x_len_sub1 && '\n'==x[x_len_sub1-newline_count]) ++newline_count;
+	if (0<newline_count)
+		{
+		if (x_len<=newline_count) return free(x),true;
+#ifndef ZAIMONI_FORCE_ISO
+		x = REALLOC(x,(x_len-newline_count));
+#else
+		x = REALLOC(x,(x_len -= newline_count));
+#endif
+		}
+	else{	// works for C/C++
+		INC_INFORM(filename);
+		INFORM(": warning: did not end in \\n, undefined behavior.  Proceeding as if it was there.");
+		if (bool_options[boolopt::warnings_are_errors])
+			zcc_errors.inc_error();
+		}
+	return true;
+}

Added: trunk/end_nl.hpp
===================================================================
--- trunk/end_nl.hpp	2010-05-09 23:02:01 UTC (rev 423)
+++ trunk/end_nl.hpp	2010-05-10 00:44:07 UTC (rev 424)
@@ -0,0 +1,24 @@
+// end_nl.hpp
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#ifndef Z_CPLUSPLUS_END_NL_HPP
+#define Z_CPLUSPLUS_END_NL_HPP 1
+
+/**
+ * Trims newlines from end of buffer x; warns if no such newlines exist.
+ *
+ * \pre char buffer x allocated with C memory manager  x_len, in ISO mode, is
+ * \pre the length of the buffer x.
+ *
+ * \return true, return value is only to glue into LangConf
+ */
+#ifndef ZAIMONI_FORCE_ISO
+bool TrimMandatoryTerminalNewline(char*& x, const char* filename);
+#else
+#include <stddef.h>
+
+bool TrimMandatoryTerminalNewline(char*& x, size_t& x_len, const char* filename);
+#endif
+
+#endif
+

Modified: trunk/load_src.cpp
===================================================================
--- trunk/load_src.cpp	2010-05-09 23:02:01 UTC (rev 423)
+++ trunk/load_src.cpp	2010-05-10 00:44:07 UTC (rev 424)
@@ -60,38 +60,11 @@
 #ifndef ZAIMONI_FORCE_ISO
 	if (!GetBinaryFileImage(filename,Buffer)) return false;
 	ConvertBinaryModeToTextMode(Buffer);
-#else
-	if (!GetBinaryFileImage(filename,Buffer,Buffer_size)) return false;
-	ConvertBinaryModeToTextMode(Buffer,Buffer_size);
-#endif
-
-	// if target language needs a warning for not ending in \n, emit one here
-	// but we normalize to that
-	{
-	size_t newline_count = 0;
-	const size_t BufferSizeSub1 = Buffer_size-1;
-	while(newline_count<BufferSizeSub1 && '\n'==Buffer[BufferSizeSub1-newline_count]) ++newline_count;
-	if (0<newline_count)
-		{
-		if (Buffer_size<=newline_count) return free(Buffer),true;
-#ifndef ZAIMONI_FORCE_ISO
-		Buffer = REALLOC(Buffer,(ArraySize(Buffer)-newline_count));
-#else
-		Buffer = REALLOC(Buffer,(Buffer_size -= newline_count));
-#endif
-		}
-	else{	// works for C/C++
-		INC_INFORM(filename);
-		INFORM(": warning: did not end in \\n, undefined behavior.  Proceeding as if it was there.");
-		if (bool_options[boolopt::warnings_are_errors])
-			zcc_errors.inc_error();
-		}
-	}
-
-#ifndef ZAIMONI_FORCE_ISO
 	if (!lang.ApplyGlobalFilters(Buffer,filename)) exit(EXIT_FAILURE);
 	lang.FlattenComments(Buffer);
 #else
+	if (!GetBinaryFileImage(filename,Buffer,Buffer_size)) return false;
+	ConvertBinaryModeToTextMode(Buffer,Buffer_size);
 	if (!lang.ApplyGlobalFilters(Buffer,Buffer_size,filename)) exit(EXIT_FAILURE);
 	lang.FlattenComments(Buffer,Buffer_size);
 #endif



From zaimoni at mail.berlios.de  Thu May 13 06:12:04 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 13 May 2010 06:12:04 +0200
Subject: [Zcplusplus-commits] r425 - trunk
Message-ID: <201005130412.o4D4C4Jt010811@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-13 06:12:01 +0200 (Thu, 13 May 2010)
New Revision: 425

Modified:
   trunk/POSIX.dep
   trunk/load_src.cpp
Log:
complete code cleanup of load_src.cpp

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-05-10 00:44:07 UTC (rev 424)
+++ trunk/POSIX.dep	2010-05-13 04:12:01 UTC (rev 425)
@@ -31,7 +31,7 @@
 Flat_UNI.o: Flat_UNI.hpp lex_core.h Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 end_lc.o: end_lc.hpp Zaimoni.STL/MetaRAM2.hpp errors.hpp errcount.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 end_nl.o: end_nl.hpp Zaimoni.STL/MetaRAM2.hpp errors.hpp errcount.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
-load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/stdio_c.h Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
+load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp end_nl.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/stdio_c.h Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
 CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/opera!
 tor.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h

Modified: trunk/load_src.cpp
===================================================================
--- trunk/load_src.cpp	2010-05-10 00:44:07 UTC (rev 424)
+++ trunk/load_src.cpp	2010-05-13 04:12:01 UTC (rev 425)
@@ -7,6 +7,7 @@
 #include "AtomicString.h"
 #include "errors.hpp"
 #include "errcount.hpp"
+#include "end_nl.hpp"
 
 using namespace zaimoni;
 
@@ -43,7 +44,7 @@
 	if (want_to_zap_line) clean_whitespace(TokenList,v_idx,lang);
 }
 
-// can throw std::bad_alloc.
+//! \throw std::bad_alloc
 bool
 load_sourcefile(autovalarray_ptr<Token<char>* >& TokenList, const char* const filename, LangConf& lang)
 {
@@ -144,7 +145,7 @@
 	return true;
 }
 
-// can throw std::bad_alloc.
+//! \throw std::bad_alloc
 bool load_raw_sourcefile(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList, const char* const filename)
 {
 	char* Buffer = NULL;
@@ -167,26 +168,12 @@
 
 	// if target language needs a warning for not ending in \n, emit one here
 	// but we normalize to that
-	{
-	size_t newline_count = 0;
-	const size_t BufferSizeSub1 = Buffer_size-1;
-	while(newline_count<BufferSizeSub1 && '\n'==Buffer[BufferSizeSub1-newline_count]) ++newline_count;
-	if (0<newline_count)
-		{
-		if (Buffer_size<=newline_count) return free(Buffer),true;
 #ifndef ZAIMONI_FORCE_ISO
-		Buffer = REALLOC(Buffer,(ArraySize(Buffer)-newline_count));
+	TrimMandatoryTerminalNewline(Buffer,filename);
 #else
-		Buffer = REALLOC(Buffer,(Buffer_size -= newline_count));
+	TrimMandatoryTerminalNewline(Buffer,Buffer_size,filename);
 #endif
-		}
-	else{	// works for C/C++
-		INC_INFORM(filename);
-		INFORM(": warning: did not end in \\n, undefined behavior.  Proceeding as if it was there.");
-		if (bool_options[boolopt::warnings_are_errors]) zcc_errors.inc_error();
-		}
-	}
-
+	
 	SUCCEED_OR_DIE(TokenList.InsertNSlotsAt(1,0));
 #ifndef ZAIMONI_FORCE_ISO
 	TokenList[0] = new(std::nothrow) Token<char>(Buffer,filename);



From zaimoni at mail.berlios.de  Thu May 13 06:50:50 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 13 May 2010 06:50:50 +0200
Subject: [Zcplusplus-commits] r426 - trunk/Zaimoni.STL
Message-ID: <201005130450.o4D4ooB8003717@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-13 06:50:38 +0200 (Thu, 13 May 2010)
New Revision: 426

Modified:
   trunk/Zaimoni.STL/AutoPtr.hpp
   trunk/Zaimoni.STL/MetaRAM2.hpp
Log:
want a throwing version of InsertNSlotsAt; GCC 4.3.3 warning suppression

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2010-05-13 04:12:01 UTC (rev 425)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2010-05-13 04:50:38 UTC (rev 426)
@@ -1,6 +1,6 @@
 // AutoPtr.hpp
 // a family of pointers that automatically delete themselves when going out of scope
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 // autodel_ptr: single pointer
 // weakautoarray_ptr: array of weak pointers
@@ -108,12 +108,14 @@
 	void NULLPtr() {static_cast<Derived*>(this)->_ptr = NULL;};
 	size_t ArraySize() const {return zaimoni::ArraySize(static_cast<const Derived*>(this)->_ptr);};
 	template<typename U> bool InsertSlotAt(size_t Idx, U _default) {return _insert_slot_at(static_cast<Derived*>(this)->_ptr,Idx,_default);}
-	bool InsertNSlotsAt(size_t n,size_t Idx) {return _insert_n_slots_at(static_cast<Derived*>(this)->_ptr,n,Idx);};
+	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(static_cast<Derived*>(this)->_ptr,n,i);};
+	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(static_cast<Derived*>(this)->_ptr,n,i)) throw std::bad_alloc();};
 #else
 	void NULLPtr() {static_cast<Derived*>(this)->_ptr = NULL; static_cast<Derived*>(this)->_size = 0;};
 	size_t ArraySize() const {return static_cast<const Derived*>(this)->_size;};
 	template<typename U> bool InsertSlotAt(size_t Idx, U _default) {return _insert_slot_at(static_cast<Derived*>(this)->_ptr,static_cast<Derived*>(this)->_size,Idx,_default);}
-	bool InsertNSlotsAt(size_t n,size_t Idx) {return _insert_n_slots_at(static_cast<Derived*>(this)->_ptr,static_cast<Derived*>(this)->_size,n,Idx);};
+	bool InsertNSlotsAt(size_t n,size_t i) {return _insert_n_slots_at(static_cast<Derived*>(this)->_ptr,static_cast<Derived*>(this)->_size,n,i);};
+	void insertNSlotsAt(size_t n,size_t i) {if (!_insert_n_slots_at(static_cast<Derived*>(this)->_ptr,static_cast<Derived*>(this)->_size,n,i)) throw std::bad_alloc();};
 #endif
 
 	// typecasts
@@ -144,7 +146,7 @@
 #else
 	T* release() {T* tmp = static_cast<Derived*>(this)->_ptr; static_cast<Derived*>(this)->_ptr = NULL; static_cast<Derived*>(this)->_size = 0; return tmp;};
 #endif
-	
+
 	// Perl grep
 	template<typename U> void destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
 	template<typename U> void destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));

Modified: trunk/Zaimoni.STL/MetaRAM2.hpp
===================================================================
--- trunk/Zaimoni.STL/MetaRAM2.hpp	2010-05-13 04:12:01 UTC (rev 425)
+++ trunk/Zaimoni.STL/MetaRAM2.hpp	2010-05-13 04:50:38 UTC (rev 426)
@@ -1,7 +1,7 @@
 // MetaRAM2.hpp
 // more C++ memory interface functions
 // these require the Iskandria memory manager
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #ifndef ZAIMONI_METARAM2_HPP
 #define ZAIMONI_METARAM2_HPP 1
@@ -244,7 +244,7 @@
 }
 #else
 inline typename boost::disable_if<boost::type_traits::ice_and<boost::has_trivial_destructor<T>::value, boost::has_trivial_assign<T>::value >, bool>::type
-__resize2(T*& _ptr, size_t& _ptr_size, size_t n)
+__resize2(size_t _ptr_size, size_t n)
 {
 	return n==_ptr_size;
 }
@@ -297,7 +297,7 @@
 #ifndef ZAIMONI_FORCE_ISO
 	if (__resize2(_ptr,n)) return true;
 #else
-	if (__resize2(_ptr,_ptr_size,n)) return true;
+	if (__resize2<T>(_ptr_size,n)) return true;
 #endif
 
 	T* Tmp = _new_buffer<T>(n);



From zaimoni at mail.berlios.de  Thu May 13 07:12:42 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 13 May 2010 07:12:42 +0200
Subject: [Zcplusplus-commits] r427 - trunk/Zaimoni.STL
Message-ID: <201005130512.o4D5CgtT025196@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-13 07:12:38 +0200 (Thu, 13 May 2010)
New Revision: 427

Modified:
   trunk/Zaimoni.STL/AutoPtr.hpp
   trunk/Zaimoni.STL/MetaRAM2.hpp
Log:
lines of code suppression while looking at these

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2010-05-13 04:50:38 UTC (rev 426)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2010-05-13 05:12:38 UTC (rev 427)
@@ -513,8 +513,7 @@
 {
 	const size_t ub = src.size();
 	if (!Resize(ub)) return false;
-	if (0<ub)
-		_copy_buffer(this->c_array(),src.data(),ub);
+	if (0<ub) _copy_buffer(this->c_array(),src.data(),ub);
 	return true;
 }
 
@@ -524,31 +523,21 @@
 bool
 _meta_weakautoarray_ptr<T>::grep(const U& src,op Predicate)
 {
-	if (src.empty())
-		{
-		reset();
-		return true;
-		}
+	if (src.empty()) return reset(),true;
 	size_t NonStrictLB = 0;
 	size_t StrictUB = src.size();
 	while(!Predicate(src.data()[NonStrictLB]) && StrictUB>++NonStrictLB);
-	if (StrictUB==NonStrictLB)
-		{
-		reset();
-		return true;
-		}
+	if (StrictUB==NonStrictLB) return reset(),true;
 	while(!Predicate(src[--StrictUB]));
 	++StrictUB;
-	if (!Resize(StrictUB-NonStrictLB))
-		return false;
+	if (!Resize(StrictUB-NonStrictLB)) return false;
 	size_t Offset = 0;
 	_ptr[Offset++] = src.data()[NonStrictLB++];
 	while(NonStrictLB<StrictUB-1)
 		if (Predicate(src.data()[NonStrictLB++]))
 			_ptr[Offset++] = src[NonStrictLB-1];
 	_ptr[Offset++] = src.data()[NonStrictLB++];
-	Resize(Offset);
-	return true;
+	return Resize(Offset),true;
 }
 
 template<typename T>
@@ -556,31 +545,21 @@
 bool
 _meta_weakautoarray_ptr<T>::invgrep(const U& src,op Predicate)
 {
-	if (src.empty())
-		{
-		reset();
-		return true;
-		}
+	if (src.empty()) return reset(),true;
 	size_t NonStrictLB = 0;
 	size_t StrictUB = src.size();
 	while(Predicate(src.data()[NonStrictLB]) && StrictUB>++NonStrictLB);
-	if (StrictUB==NonStrictLB)
-		{
-		reset();
-		return true;
-		}
+	if (StrictUB==NonStrictLB) return reset(),true;
 	while(Predicate(src[--StrictUB]));
 	++StrictUB;
-	if (!Resize(StrictUB-NonStrictLB))
-		return false;
+	if (!Resize(StrictUB-NonStrictLB)) return false;
 	size_t Offset = 0;
 	_ptr[Offset++] = src.data()[NonStrictLB++];
 	while(NonStrictLB<StrictUB-1)
 		if (!Predicate(src.data()[NonStrictLB++]))
 			_ptr[Offset++] = src[NonStrictLB-1];
 	_ptr[Offset++] = src.data()[NonStrictLB++];
-	Resize(Offset);
-	return true;
+	return Resize(Offset),true;
 }
 
 template<class Derived,class T>
@@ -671,75 +650,65 @@
 template<typename T>
 template<typename U>
 bool
-_meta_autoarray_ptr<T>::grep(UnaryPredicate* Predicate,_meta_autoarray_ptr<U*>& Target) const
+_meta_autoarray_ptr<T>::grep(UnaryPredicate* Predicate,_meta_autoarray_ptr<U*>& dest) const
 {
-	Target.reset();
-	if (this->empty())
-		return true;
+	dest.reset();
+	if (this->empty()) return true;
 
 	size_t NonStrictLB = 0;
 	size_t StrictUB = this->ArraySize();
 	while(!Predicate(*_ptr[NonStrictLB]) && StrictUB>++NonStrictLB);
-	if (StrictUB==NonStrictLB)
-		return true;
+	if (StrictUB==NonStrictLB) return true;
 
 	while(!Predicate(*_ptr[--StrictUB]));
 	++StrictUB;
-	if (!Target.Resize(StrictUB-NonStrictLB))
-		return false;
+	if (!dest.Resize(StrictUB-NonStrictLB)) return false;
 
 	size_t Offset = 0;
 	try	{
-		Target[Offset++] = new U(*_ptr[NonStrictLB++]);
+		dest[Offset++] = new U(*_ptr[NonStrictLB++]);
 		while(NonStrictLB<StrictUB-1)
 			if (Predicate(*_ptr[NonStrictLB++]))
-				Target[Offset++] = new U(*_ptr[NonStrictLB-1]);
-		Target[Offset++] = new U(*_ptr[NonStrictLB++]);
+				dest[Offset++] = new U(*_ptr[NonStrictLB-1]);
+		dest[Offset++] = new U(*_ptr[NonStrictLB++]);
 		}
 	catch(const std::bad_alloc&)
 		{
-		Target.Resize(Offset);
-		return false;	
+		return dest.Resize(Offset),false;	
 		}
-	Target.Resize(Offset);
-	return true;
+	return dest.Resize(Offset),true;
 }
 
 template<typename T>
 template<typename U>
 bool
-_meta_autoarray_ptr<T>::invgrep(UnaryPredicate* Predicate,_meta_autoarray_ptr<U*>& Target) const
+_meta_autoarray_ptr<T>::invgrep(UnaryPredicate* Predicate,_meta_autoarray_ptr<U*>& dest) const
 {
-	Target.reset();
-	if (this->empty())
-		return true;
+	dest.reset();
+	if (this->empty()) return true;
 
 	size_t NonStrictLB = 0;
 	size_t StrictUB = this->ArraySize();
 	while(Predicate(*_ptr[NonStrictLB]) && StrictUB>++NonStrictLB);
-	if (StrictUB==NonStrictLB)
-		return true;
+	if (StrictUB==NonStrictLB) return true;
 
 	while(Predicate(*_ptr[--StrictUB]));
 	++StrictUB;
-	if (!Target.Resize(StrictUB-NonStrictLB))
-		return false;
+	if (!dest.Resize(StrictUB-NonStrictLB)) return false;
 
 	size_t Offset = 0;
 	try	{
-		Target[Offset++] = new U(*_ptr[NonStrictLB++]);
+		dest[Offset++] = new U(*_ptr[NonStrictLB++]);
 		while(NonStrictLB<StrictUB-1)
 			if (!Predicate(*_ptr[NonStrictLB++]))
-				Target[Offset++] = new U(*_ptr[NonStrictLB-1]);
-		Target[Offset++] = new U(*_ptr[NonStrictLB++]);
+				dest[Offset++] = new U(*_ptr[NonStrictLB-1]);
+		dest[Offset++] = new U(*_ptr[NonStrictLB++]);
 		}
 	catch(const std::bad_alloc&)
 		{
-		Target.Resize(Offset);
-		return false;	
+		return dest.Resize(Offset),false;	
 		}
-	Target.Resize(Offset);
-	return true;
+	return dest.Resize(Offset),true;
 }
 
 template<class Derived,class T>

Modified: trunk/Zaimoni.STL/MetaRAM2.hpp
===================================================================
--- trunk/Zaimoni.STL/MetaRAM2.hpp	2010-05-13 04:50:38 UTC (rev 426)
+++ trunk/Zaimoni.STL/MetaRAM2.hpp	2010-05-13 05:12:38 UTC (rev 427)
@@ -254,11 +254,7 @@
 typename boost::enable_if<boost::type_traits::ice_and<boost::has_trivial_destructor<T>::value, boost::has_trivial_assign<T>::value >, bool>::type
 __resize2(T*& _ptr, size_t n)
 {
-	if (n<=ArraySize(_ptr))
-		{
-		_ptr = REALLOC(_ptr,n*sizeof(T));
-		return true;
-		};
+	if (n<=ArraySize(_ptr)) return _ptr = REALLOC(_ptr,n*sizeof(T)),true;
 	return false;
 }
 



From zaimoni at mail.berlios.de  Fri May 14 06:49:35 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 14 May 2010 06:49:35 +0200
Subject: [Zcplusplus-commits] r428 - trunk
Message-ID: <201005140449.o4E4nZAP010508@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-14 06:49:26 +0200 (Fri, 14 May 2010)
New Revision: 428

Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc_autogen.cpp
   trunk/CPreproc_autogen_pp.cpp
   trunk/CPreproc_pp.cpp
   trunk/load_src.cpp
Log:
switch to throwing insertNSlotsAt from return-value InsertNSlotsAt where convenient

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2010-05-13 05:12:38 UTC (rev 427)
+++ trunk/CPreproc.cpp	2010-05-14 04:49:26 UTC (rev 428)
@@ -1,5 +1,5 @@
 // CPreproc.cpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #/*cut-cpp*/
 #include "CPreproc.hpp"
@@ -1181,10 +1181,9 @@
 								continue;
 								};
 							const size_t object_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(object_macro_index);
-							if (   !macros_object.InsertNSlotsAt(1,object_macro_insertion_index)
-								|| !macros_object_expansion.InsertNSlotsAt(1,object_macro_insertion_index)
-								|| !macros_object_expansion_pre_eval.InsertNSlotsAt(1,object_macro_insertion_index))
-								throw std::bad_alloc();
+							macros_object.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion_pre_eval.insertNSlotsAt(1,object_macro_insertion_index);
 							macros_object[object_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
 							strncpy(macros_object[object_macro_insertion_index],TokenList[i]->data()+critical_offset,first_token_len);
 							ZAIMONI_NULL_TERMINATE(macros_object[object_macro_insertion_index][first_token_len]);
@@ -1231,10 +1230,9 @@
 
 							// DO NOT check for context free errors here; could legitimately want to deep-stringize every invocation of the macro
 							const size_t object_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(object_macro_index);
-							if (   !macros_object.InsertNSlotsAt(1,object_macro_insertion_index)
-								|| !macros_object_expansion.InsertNSlotsAt(1,object_macro_insertion_index)
-								|| !macros_object_expansion_pre_eval.InsertNSlotsAt(1,object_macro_insertion_index))
-								throw std::bad_alloc();
+							macros_object.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion_pre_eval.insertNSlotsAt(1,object_macro_insertion_index);
 							macros_object[object_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
 
 							strncpy(macros_object[object_macro_insertion_index],TokenList[i]->data()+critical_offset,first_token_len);
@@ -1308,11 +1306,10 @@
 									continue;
 									}
 								const size_t function_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(function_macro_index);
-								if (   !macros_function.InsertNSlotsAt(1,function_macro_insertion_index)
-									|| !macros_function_arglist.InsertNSlotsAt(1,function_macro_insertion_index)
-									|| !macros_function_expansion.InsertNSlotsAt(1,function_macro_insertion_index)
-									|| !macros_function_expansion_pre_eval.InsertNSlotsAt(1,function_macro_insertion_index))
-									throw std::bad_alloc();
+								macros_function.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_arglist.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_expansion.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_expansion_pre_eval.insertNSlotsAt(1,function_macro_insertion_index);
 								macros_function[function_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
 
 								strncpy(macros_function[function_macro_insertion_index],TokenList[i]->data()+critical_offset,first_token_len);
@@ -1354,11 +1351,10 @@
 
 							// DO NOT check for context free errors here; could legitimately want to deep-stringize every invocation of the macro
 							const size_t function_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(function_macro_index);
-							if (   !macros_function.InsertNSlotsAt(1,function_macro_insertion_index)
-								|| !macros_function_arglist.InsertNSlotsAt(1,function_macro_insertion_index)
-								|| !macros_function_expansion.InsertNSlotsAt(1,function_macro_insertion_index)
-								|| !macros_function_expansion_pre_eval.InsertNSlotsAt(1,function_macro_insertion_index))
-								throw std::bad_alloc();
+							macros_function.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_arglist.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_expansion.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_expansion_pre_eval.insertNSlotsAt(1,function_macro_insertion_index);
 							macros_function[function_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
 
 							strncpy(macros_function[function_macro_insertion_index],TokenList[i]->data()+critical_offset,first_token_len);
@@ -1981,9 +1977,8 @@
 					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(have_file_index);
 					const errr cache_index = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
 					const size_t include_file_cache_target = BINARY_SEARCH_DECODE_INSERTION_POINT(cache_index);
-					if (   !include_file_index.InsertNSlotsAt(1,include_file_index_target)
-						|| !include_file_cache.InsertNSlotsAt(1,include_file_cache_target))
-						throw std::bad_alloc();
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_cache.insertNSlotsAt(1,include_file_cache_target);
 					include_file_cache[include_file_cache_target].second = new autovalarray_ptr<Token<char>* >(IncludeTokenList);
 					include_file_cache[include_file_cache_target].first = main_index_name;
 					include_file_index[include_file_index_target].first = main_index_name;
@@ -2055,9 +2050,8 @@
 					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
 					tmp = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
 					const size_t include_file_cache_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
-					if (   !include_file_index.InsertNSlotsAt(1,include_file_index_target)
-						|| !include_file_cache.InsertNSlotsAt(1,include_file_cache_target))
-						throw std::bad_alloc();
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_cache.insertNSlotsAt(1,include_file_cache_target);
 					include_file_cache[include_file_cache_target].second = new autovalarray_ptr<Token<char>* >(IncludeTokenList);
 					include_file_cache[include_file_cache_target].first = main_index_name;
 					include_file_index[include_file_index_target].first = look_for;
@@ -2069,8 +2063,7 @@
 					// set up include_file_index
 					tmp = binary_find(look_for,filename_len,include_file_index);
 					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
-					if (!include_file_index.InsertNSlotsAt(1,include_file_index_target))
-						throw std::bad_alloc();
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
 					include_file_index[include_file_index_target].first = look_for;
 					include_file_index[include_file_index_target].second = NULL;
 					include_file_index[include_file_index_target].third = CPP_INCLUDE_NOT_FOUND;
@@ -2100,7 +2093,7 @@
 			if (!IncludeTokenList.empty())
 				{
 				size_t j = IncludeTokenList.size();
-				if (!TokenList.InsertNSlotsAt(j,include_where+1)) throw std::bad_alloc();
+				TokenList.insertNSlotsAt(j,include_where+1);
 				memmove(TokenList.c_array()+include_where+1,IncludeTokenList.data(),j*sizeof(Token<char*>*));
 #ifdef ZAIMONI_NULL_REALLY_IS_ZERO
 				memset(IncludeTokenList.c_array(),0,j*sizeof(Token<char*>*));
@@ -2320,7 +2313,7 @@
 	else{
 		size_t lb = 0;
 		autovalarray_ptr_throws<Token<char>* > TokenListAlt(ub+1);
-		if (!TokenList.InsertNSlotsAt(ub,i+1)) throw std::bad_alloc();
+		TokenList.insertNSlotsAt(ub,i+1);
 		{
 		const Token<char>& tmp = *TokenList[i];
 		while(lb<ub)
@@ -3541,7 +3534,7 @@
 			intradirective_preprocess(Test,0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,&macro_stack);
 			}
 		else{
-			if (!used_macro_stack->InsertNSlotsAt(1,used_macro_stack->size())) throw std::bad_alloc();
+			used_macro_stack->insertNSlotsAt(1,used_macro_stack->size());
 			used_macro_stack->back() = _new_buffer_nonNULL_throws<char>(token_len);
 			memmove(used_macro_stack->back(),x.data()+critical_offset,token_len);
 			intradirective_preprocess(Test,0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack);
@@ -3641,7 +3634,7 @@
 			dynamic_function_macro_prereplace_once(macros_object, macros_object_expansion, macros_function, macros_function_arglist, macros_function_expansion, &macro_stack, formal_arguments, actual_arguments, Test);
 			}
 		else{
-			if (!used_macro_stack->InsertNSlotsAt(1,used_macro_stack->size())) throw std::bad_alloc();
+			used_macro_stack->insertNSlotsAt(1,used_macro_stack->size());
 			used_macro_stack->back() = _new_buffer_nonNULL_throws<char>(token_len);
 			memmove(used_macro_stack->back(),x.data()+critical_offset,token_len);
 

Modified: trunk/CPreproc_autogen.cpp
===================================================================
--- trunk/CPreproc_autogen.cpp	2010-05-13 05:12:38 UTC (rev 427)
+++ trunk/CPreproc_autogen.cpp	2010-05-14 04:49:26 UTC (rev 428)
@@ -279,6 +279,7 @@
 #define STDINT_CPP_LEAST_FAST_INJECT_LINE 61
 
 // inject preprocessor block of preexisting definitions
+//! \throw std::bad_alloc
 static void
 disallow_prior_definitions(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,size_t i,const char* const * identifiers,size_t identifiers_len)
 {
@@ -292,7 +293,7 @@
 #undef __bool_true_false_are_defined
 #endif
 */
-	if (!TokenList.InsertNSlotsAt(4*identifiers_len,i)) throw std::bad_alloc();
+	TokenList.insertNSlotsAt(4*identifiers_len,i);
 	while(0<identifiers_len)
 		{
 		assert(*identifiers && **identifiers);
@@ -300,48 +301,33 @@
 		tmp[i+3] = new zaimoni::Token<char>("#endif",0,sizeof("#endif")-1,0);
 
 		const size_t identifier_len = strlen(*identifiers);
-		char* tmp2 = zaimoni::_new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(sizeof("#ifdef ")-1+identifier_len));
+		zaimoni::autovalarray_ptr_throws<char> tmp2(ZAIMONI_LEN_WITH_NULL(sizeof("#ifdef ")-1+identifier_len));
 		strcpy(tmp2,"#ifdef ");
 		strcpy(tmp2+sizeof("#ifdef ")-1,*identifiers);
 #ifndef ZAIMONI_FORCE_ISO
-		tmp[i] = new(std::nothrow) zaimoni::Token<char>(tmp2,NULL);
+		tmp[i] = new zaimoni::Token<char>(tmp2,NULL);
 #else
-		tmp[i] = new(std::nothrow) zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#ifdef ")-1+identifier_len),NULL);
+		tmp[i] = new zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#ifdef ")-1+identifier_len),NULL);
 #endif
-		if (NULL==tmp[i])
-			{
-			free(tmp2);
-			throw std::bad_alloc();
-			}
 
-		tmp2 = zaimoni::_new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(sizeof("#undef ")-1+identifier_len));
+		tmp2.resize(ZAIMONI_LEN_WITH_NULL(sizeof("#undef ")-1+identifier_len));
 		strcpy(tmp2,"#undef ");
 		strcpy(tmp2+sizeof("#undef ")-1,*identifiers);
 #ifndef ZAIMONI_FORCE_ISO
-		tmp[i+2] = new(std::nothrow) zaimoni::Token<char>(tmp2,NULL);
+		tmp[i+2] = new zaimoni::Token<char>(tmp2,NULL);
 #else
-		tmp[i+2] = new(std::nothrow) zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#undef ")-1+identifier_len),NULL);
+		tmp[i+2] = new zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#undef ")-1+identifier_len),NULL);
 #endif
-		if (NULL==tmp[i+2])
-			{
-			free(tmp2);
-			throw std::bad_alloc();
-			}
 
-		tmp2 = zaimoni::_new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len+sizeof("' defined as macro")-1));
+		tmp2.resize(ZAIMONI_LEN_WITH_NULL(sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len+sizeof("' defined as macro")-1));
 		strcpy(tmp2,"#error Undefined Behavior: reserved identifier '");
 		strcpy(tmp2+sizeof("#error Undefined Behavior: reserved identifier '")-1,*identifiers);
 		strcpy(tmp2+sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len,"' defined as macro");
 #ifndef ZAIMONI_FORCE_ISO
-		tmp[i+1] = new(std::nothrow) zaimoni::Token<char>(tmp2,NULL);
+		tmp[i+1] = new zaimoni::Token<char>(tmp2,NULL);
 #else
-		tmp[i+1] = new(std::nothrow) zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len+sizeof("' defined as macro")-1),NULL);
+		tmp[i+1] = new zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len+sizeof("' defined as macro")-1),NULL);
 #endif
-		if (NULL==tmp[i+1])
-			{
-			free(tmp2);
-			throw std::bad_alloc();
-			}
 
 		i += 4;
 		--identifiers_len;
@@ -350,6 +336,7 @@
 }
 
 // inject preprocessor lockdown for a reserved identifier
+//! \throw std::bad_alloc
 static void
 lockdown_reserved_identifiers(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const size_t i,const char* const * identifiers,size_t identifiers_len)
 {
@@ -363,8 +350,9 @@
 		target_len += strlen(identifiers[j])+1;
 		}
 	while(identifiers_len> ++j);
-	char* tmp = zaimoni::_new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(target_len));
-	char* tmp2 = tmp;
+	zaimoni::autovalarray_ptr_throws<char> tmp(ZAIMONI_LEN_WITH_NULL(target_len));
+	{
+	char* tmp2 = tmp.c_array();
 	strcpy(tmp2,"#pragma ZCC lock");
 	tmp2 += sizeof("#pragma ZCC lock")-1;
 	while(0<identifiers_len)
@@ -375,16 +363,12 @@
 		++identifiers;
 		--identifiers_len;
 		};
+	}
 #ifndef ZAIMONI_FORCE_ISO
-	zaimoni::Token<char>* relay = new(std::nothrow) zaimoni::Token<char>(tmp,NULL);
+	zaimoni::Token<char>* relay = new zaimoni::Token<char>(tmp,NULL);
 #else
-	zaimoni::Token<char>* relay = new(std::nothrow) zaimoni::Token<char>(tmp,ZAIMONI_LEN_WITH_NULL(target_len),NULL);
+	zaimoni::Token<char>* relay = new zaimoni::Token<char>(tmp,ZAIMONI_LEN_WITH_NULL(target_len),NULL);
 #endif
-	if (NULL==relay)
-		{
-		free(tmp);
-		throw std::bad_alloc();
-		};
 	if (!TokenList.InsertSlotAt(i,relay))
 		{
 		delete relay;
@@ -414,6 +398,7 @@
  * \param TokenList : where to improvise to
  * \param header_name : what header we were requesting.
  */
+//! \throw std::bad_alloc
 void
 CPreprocessor::create_limits_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
@@ -598,6 +583,7 @@
  * \param TokenList : where to improvise to
  * \param header_name : what header we were requesting.
  */
+//! \throw std::bad_alloc
 void
 CPreprocessor::create_stddef_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
@@ -682,6 +668,7 @@
  * \param TokenList : where to improvise to
  * \param header_name : what header we were requesting.
  */
+//! \throw std::bad_alloc
 void
 CPreprocessor::create_stdint_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
@@ -1189,7 +1176,7 @@
 	const unsigned short bitspan_types = type_bits[virtual_machine::std_int_long_long-1]-7;
 	assert(USHRT_MAX/13>=bitspan_types);
 	i = 4*bitspan_types;
-	TmpTokenList.InsertNSlotsAt(i,inject_CPP_index);
+	TmpTokenList.insertNSlotsAt(i,inject_CPP_index);
 	tmp = TmpTokenList.c_array()+inject_CPP_index;
 	do	{
 		const int target_bits = --i/4+8;
@@ -1232,7 +1219,7 @@
 	zaimoni::autovalarray_ptr_throws<char> define_buf(sizeof("#define UINT_LEAST_MAX")+2+VM_MAX_BIT_PLATFORM/3+5);
 	strcpy(define_buf,"#define ");
 	i = 13*bitspan_types;
-	TmpTokenList.InsertNSlotsAt(i,inject_C_index);
+	TmpTokenList.insertNSlotsAt(i,inject_C_index);
 	tmp = TmpTokenList.c_array()+inject_C_index;
 	do	{
 		const int target_bits = --i/13+8;

Modified: trunk/CPreproc_autogen_pp.cpp
===================================================================
--- trunk/CPreproc_autogen_pp.cpp	2010-05-13 05:12:38 UTC (rev 427)
+++ trunk/CPreproc_autogen_pp.cpp	2010-05-14 04:49:26 UTC (rev 428)
@@ -276,6 +276,7 @@
 #define STDINT_CPP_LEAST_FAST_INJECT_LINE 61
 
 // inject preprocessor block of preexisting definitions
+//! \throw std::bad_alloc
 static void
 disallow_prior_definitions(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,size_t i,const char* const * identifiers,size_t identifiers_len)
 {
@@ -289,7 +290,7 @@
 #undef __bool_true_false_are_defined
 #endif
 */
-	if (!TokenList.InsertNSlotsAt(4*identifiers_len,i)) throw std::bad_alloc();
+	TokenList.insertNSlotsAt(4*identifiers_len,i);
 	while(0<identifiers_len)
 		{
 		assert(*identifiers && **identifiers);
@@ -297,48 +298,33 @@
 		tmp[i+3] = new zaimoni::Token<char>("#endif",0,sizeof("#endif")-1,0);
 
 		const size_t identifier_len = strlen(*identifiers);
-		char* tmp2 = zaimoni::_new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(sizeof("#ifdef ")-1+identifier_len));
+		zaimoni::autovalarray_ptr_throws<char> tmp2(ZAIMONI_LEN_WITH_NULL(sizeof("#ifdef ")-1+identifier_len));
 		strcpy(tmp2,"#ifdef ");
 		strcpy(tmp2+sizeof("#ifdef ")-1,*identifiers);
 #ifndef ZAIMONI_FORCE_ISO
-		tmp[i] = new(std::nothrow) zaimoni::Token<char>(tmp2,NULL);
+		tmp[i] = new zaimoni::Token<char>(tmp2,NULL);
 #else
-		tmp[i] = new(std::nothrow) zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#ifdef ")-1+identifier_len),NULL);
+		tmp[i] = new zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#ifdef ")-1+identifier_len),NULL);
 #endif
-		if (NULL==tmp[i])
-			{
-			free(tmp2);
-			throw std::bad_alloc();
-			}
 
-		tmp2 = zaimoni::_new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(sizeof("#undef ")-1+identifier_len));
+		tmp2.resize(ZAIMONI_LEN_WITH_NULL(sizeof("#undef ")-1+identifier_len));
 		strcpy(tmp2,"#undef ");
 		strcpy(tmp2+sizeof("#undef ")-1,*identifiers);
 #ifndef ZAIMONI_FORCE_ISO
-		tmp[i+2] = new(std::nothrow) zaimoni::Token<char>(tmp2,NULL);
+		tmp[i+2] = new zaimoni::Token<char>(tmp2,NULL);
 #else
-		tmp[i+2] = new(std::nothrow) zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#undef ")-1+identifier_len),NULL);
+		tmp[i+2] = new zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#undef ")-1+identifier_len),NULL);
 #endif
-		if (NULL==tmp[i+2])
-			{
-			free(tmp2);
-			throw std::bad_alloc();
-			}
 
-		tmp2 = zaimoni::_new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len+sizeof("' defined as macro")-1));
+		tmp2.resize(ZAIMONI_LEN_WITH_NULL(sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len+sizeof("' defined as macro")-1));
 		strcpy(tmp2,"#error Undefined Behavior: reserved identifier '");
 		strcpy(tmp2+sizeof("#error Undefined Behavior: reserved identifier '")-1,*identifiers);
 		strcpy(tmp2+sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len,"' defined as macro");
 #ifndef ZAIMONI_FORCE_ISO
-		tmp[i+1] = new(std::nothrow) zaimoni::Token<char>(tmp2,NULL);
+		tmp[i+1] = new zaimoni::Token<char>(tmp2,NULL);
 #else
-		tmp[i+1] = new(std::nothrow) zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len+sizeof("' defined as macro")-1),NULL);
+		tmp[i+1] = new zaimoni::Token<char>(tmp2,ZAIMONI_LEN_WITH_NULL(sizeof("#error Undefined Behavior: reserved identifier '")-1+identifier_len+sizeof("' defined as macro")-1),NULL);
 #endif
-		if (NULL==tmp[i+1])
-			{
-			free(tmp2);
-			throw std::bad_alloc();
-			}
 
 		i += 4;
 		--identifiers_len;
@@ -347,6 +333,7 @@
 }
 
 // inject preprocessor lockdown for a reserved identifier
+//! \throw std::bad_alloc
 static void
 lockdown_reserved_identifiers(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const size_t i,const char* const * identifiers,size_t identifiers_len)
 {
@@ -360,8 +347,9 @@
 		target_len += strlen(identifiers[j])+1;
 		}
 	while(identifiers_len> ++j);
-	char* tmp = zaimoni::_new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(target_len));
-	char* tmp2 = tmp;
+	zaimoni::autovalarray_ptr_throws<char> tmp(ZAIMONI_LEN_WITH_NULL(target_len));
+	{
+	char* tmp2 = tmp.c_array();
 	strcpy(tmp2,"#pragma ZCC lock");
 	tmp2 += sizeof("#pragma ZCC lock")-1;
 	while(0<identifiers_len)
@@ -372,16 +360,12 @@
 		++identifiers;
 		--identifiers_len;
 		};
+	}
 #ifndef ZAIMONI_FORCE_ISO
-	zaimoni::Token<char>* relay = new(std::nothrow) zaimoni::Token<char>(tmp,NULL);
+	zaimoni::Token<char>* relay = new zaimoni::Token<char>(tmp,NULL);
 #else
-	zaimoni::Token<char>* relay = new(std::nothrow) zaimoni::Token<char>(tmp,ZAIMONI_LEN_WITH_NULL(target_len),NULL);
+	zaimoni::Token<char>* relay = new zaimoni::Token<char>(tmp,ZAIMONI_LEN_WITH_NULL(target_len),NULL);
 #endif
-	if (NULL==relay)
-		{
-		free(tmp);
-		throw std::bad_alloc();
-		};
 	if (!TokenList.InsertSlotAt(i,relay))
 		{
 		delete relay;
@@ -411,6 +395,7 @@
  * \param TokenList : where to improvise to
  * \param header_name : what header we were requesting.
  */
+//! \throw std::bad_alloc
 void
 CPreprocessor::create_limits_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
@@ -595,6 +580,7 @@
  * \param TokenList : where to improvise to
  * \param header_name : what header we were requesting.
  */
+//! \throw std::bad_alloc
 void
 CPreprocessor::create_stddef_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
@@ -679,6 +665,7 @@
  * \param TokenList : where to improvise to
  * \param header_name : what header we were requesting.
  */
+//! \throw std::bad_alloc
 void
 CPreprocessor::create_stdint_header(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList,const char* const header_name) const
 {
@@ -1186,7 +1173,7 @@
 	const unsigned short bitspan_types = type_bits[virtual_machine::std_int_long_long-1]-7;
 	assert(USHRT_MAX/13>=bitspan_types);
 	i = 4*bitspan_types;
-	TmpTokenList.InsertNSlotsAt(i,inject_CPP_index);
+	TmpTokenList.insertNSlotsAt(i,inject_CPP_index);
 	tmp = TmpTokenList.c_array()+inject_CPP_index;
 	do	{
 		const int target_bits = --i/4+8;
@@ -1229,7 +1216,7 @@
 	zaimoni::autovalarray_ptr_throws<char> define_buf(sizeof("#define UINT_LEAST_MAX")+2+VM_MAX_BIT_PLATFORM/3+5);
 	strcpy(define_buf,"#define ");
 	i = 13*bitspan_types;
-	TmpTokenList.InsertNSlotsAt(i,inject_C_index);
+	TmpTokenList.insertNSlotsAt(i,inject_C_index);
 	tmp = TmpTokenList.c_array()+inject_C_index;
 	do	{
 		const int target_bits = --i/13+8;

Modified: trunk/CPreproc_pp.cpp
===================================================================
--- trunk/CPreproc_pp.cpp	2010-05-13 05:12:38 UTC (rev 427)
+++ trunk/CPreproc_pp.cpp	2010-05-14 04:49:26 UTC (rev 428)
@@ -1,5 +1,5 @@
 // CPreproc_pp.cpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #include "CPreproc_pp.hpp"
 
@@ -1175,10 +1175,9 @@
 								continue;
 								};
 							const size_t object_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(object_macro_index);
-							if (   !macros_object.InsertNSlotsAt(1,object_macro_insertion_index)
-								|| !macros_object_expansion.InsertNSlotsAt(1,object_macro_insertion_index)
-								|| !macros_object_expansion_pre_eval.InsertNSlotsAt(1,object_macro_insertion_index))
-								throw std::bad_alloc();
+							macros_object.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion_pre_eval.insertNSlotsAt(1,object_macro_insertion_index);
 							macros_object[object_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
 							strncpy(macros_object[object_macro_insertion_index],TokenList[i]->data()+critical_offset,first_token_len);
 							ZAIMONI_NULL_TERMINATE(macros_object[object_macro_insertion_index][first_token_len]);
@@ -1225,10 +1224,9 @@
 
 							// DO NOT check for context free errors here; could legitimately want to deep-stringize every invocation of the macro
 							const size_t object_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(object_macro_index);
-							if (   !macros_object.InsertNSlotsAt(1,object_macro_insertion_index)
-								|| !macros_object_expansion.InsertNSlotsAt(1,object_macro_insertion_index)
-								|| !macros_object_expansion_pre_eval.InsertNSlotsAt(1,object_macro_insertion_index))
-								throw std::bad_alloc();
+							macros_object.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion_pre_eval.insertNSlotsAt(1,object_macro_insertion_index);
 							macros_object[object_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
 
 							strncpy(macros_object[object_macro_insertion_index],TokenList[i]->data()+critical_offset,first_token_len);
@@ -1302,11 +1300,10 @@
 									continue;
 									}
 								const size_t function_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(function_macro_index);
-								if (   !macros_function.InsertNSlotsAt(1,function_macro_insertion_index)
-									|| !macros_function_arglist.InsertNSlotsAt(1,function_macro_insertion_index)
-									|| !macros_function_expansion.InsertNSlotsAt(1,function_macro_insertion_index)
-									|| !macros_function_expansion_pre_eval.InsertNSlotsAt(1,function_macro_insertion_index))
-									throw std::bad_alloc();
+								macros_function.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_arglist.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_expansion.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_expansion_pre_eval.insertNSlotsAt(1,function_macro_insertion_index);
 								macros_function[function_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
 
 								strncpy(macros_function[function_macro_insertion_index],TokenList[i]->data()+critical_offset,first_token_len);
@@ -1348,11 +1345,10 @@
 
 							// DO NOT check for context free errors here; could legitimately want to deep-stringize every invocation of the macro
 							const size_t function_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(function_macro_index);
-							if (   !macros_function.InsertNSlotsAt(1,function_macro_insertion_index)
-								|| !macros_function_arglist.InsertNSlotsAt(1,function_macro_insertion_index)
-								|| !macros_function_expansion.InsertNSlotsAt(1,function_macro_insertion_index)
-								|| !macros_function_expansion_pre_eval.InsertNSlotsAt(1,function_macro_insertion_index))
-								throw std::bad_alloc();
+							macros_function.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_arglist.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_expansion.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_expansion_pre_eval.insertNSlotsAt(1,function_macro_insertion_index);
 							macros_function[function_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
 
 							strncpy(macros_function[function_macro_insertion_index],TokenList[i]->data()+critical_offset,first_token_len);
@@ -1975,9 +1971,8 @@
 					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(have_file_index);
 					const errr cache_index = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
 					const size_t include_file_cache_target = BINARY_SEARCH_DECODE_INSERTION_POINT(cache_index);
-					if (   !include_file_index.InsertNSlotsAt(1,include_file_index_target)
-						|| !include_file_cache.InsertNSlotsAt(1,include_file_cache_target))
-						throw std::bad_alloc();
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_cache.insertNSlotsAt(1,include_file_cache_target);
 					include_file_cache[include_file_cache_target].second = new autovalarray_ptr<Token<char>* >(IncludeTokenList);
 					include_file_cache[include_file_cache_target].first = main_index_name;
 					include_file_index[include_file_index_target].first = main_index_name;
@@ -2049,9 +2044,8 @@
 					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
 					tmp = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
 					const size_t include_file_cache_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
-					if (   !include_file_index.InsertNSlotsAt(1,include_file_index_target)
-						|| !include_file_cache.InsertNSlotsAt(1,include_file_cache_target))
-						throw std::bad_alloc();
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_cache.insertNSlotsAt(1,include_file_cache_target);
 					include_file_cache[include_file_cache_target].second = new autovalarray_ptr<Token<char>* >(IncludeTokenList);
 					include_file_cache[include_file_cache_target].first = main_index_name;
 					include_file_index[include_file_index_target].first = look_for;
@@ -2063,8 +2057,7 @@
 					// set up include_file_index
 					tmp = binary_find(look_for,filename_len,include_file_index);
 					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
-					if (!include_file_index.InsertNSlotsAt(1,include_file_index_target))
-						throw std::bad_alloc();
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
 					include_file_index[include_file_index_target].first = look_for;
 					include_file_index[include_file_index_target].second = NULL;
 					include_file_index[include_file_index_target].third = CPP_INCLUDE_NOT_FOUND;
@@ -2094,7 +2087,7 @@
 			if (!IncludeTokenList.empty())
 				{
 				size_t j = IncludeTokenList.size();
-				if (!TokenList.InsertNSlotsAt(j,include_where+1)) throw std::bad_alloc();
+				TokenList.insertNSlotsAt(j,include_where+1);
 				memmove(TokenList.c_array()+include_where+1,IncludeTokenList.data(),j*sizeof(Token<char*>*));
 #ifdef ZAIMONI_NULL_REALLY_IS_ZERO
 				memset(IncludeTokenList.c_array(),0,j*sizeof(Token<char*>*));
@@ -2314,7 +2307,7 @@
 	else{
 		size_t lb = 0;
 		autovalarray_ptr_throws<Token<char>* > TokenListAlt(ub+1);
-		if (!TokenList.InsertNSlotsAt(ub,i+1)) throw std::bad_alloc();
+		TokenList.insertNSlotsAt(ub,i+1);
 		{
 		const Token<char>& tmp = *TokenList[i];
 		while(lb<ub)
@@ -3535,7 +3528,7 @@
 			intradirective_preprocess(Test,0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,&macro_stack);
 			}
 		else{
-			if (!used_macro_stack->InsertNSlotsAt(1,used_macro_stack->size())) throw std::bad_alloc();
+			used_macro_stack->insertNSlotsAt(1,used_macro_stack->size());
 			used_macro_stack->back() = _new_buffer_nonNULL_throws<char>(token_len);
 			memmove(used_macro_stack->back(),x.data()+critical_offset,token_len);
 			intradirective_preprocess(Test,0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack);
@@ -3635,7 +3628,7 @@
 			dynamic_function_macro_prereplace_once(macros_object, macros_object_expansion, macros_function, macros_function_arglist, macros_function_expansion, &macro_stack, formal_arguments, actual_arguments, Test);
 			}
 		else{
-			if (!used_macro_stack->InsertNSlotsAt(1,used_macro_stack->size())) throw std::bad_alloc();
+			used_macro_stack->insertNSlotsAt(1,used_macro_stack->size());
 			used_macro_stack->back() = _new_buffer_nonNULL_throws<char>(token_len);
 			memmove(used_macro_stack->back(),x.data()+critical_offset,token_len);
 

Modified: trunk/load_src.cpp
===================================================================
--- trunk/load_src.cpp	2010-05-13 05:12:38 UTC (rev 427)
+++ trunk/load_src.cpp	2010-05-14 04:49:26 UTC (rev 428)
@@ -48,6 +48,8 @@
 bool
 load_sourcefile(autovalarray_ptr<Token<char>* >& TokenList, const char* const filename, LangConf& lang)
 {
+	{
+	autovalarray_ptr<Token<char>* > tmpTokenList(1);
 	char* Buffer = NULL;
 #ifndef ZAIMONI_FORCE_ISO
 #	define Buffer_size ArraySize(Buffer)
@@ -70,66 +72,74 @@
 	lang.FlattenComments(Buffer,Buffer_size);
 #endif
 
-	SUCCEED_OR_DIE(TokenList.InsertNSlotsAt(1,0));
+	try {
 #ifndef ZAIMONI_FORCE_ISO
-	TokenList[0] = new Token<char>(Buffer,filename);
+		tmpTokenList[0] = new Token<char>(Buffer,filename);
 #else
-	TokenList[0] = new Token<char>(Buffer,Buffer_size,filename);
-	Buffer_size = 0;
+		tmpTokenList[0] = new Token<char>(Buffer,Buffer_size,filename);
+//		Buffer_size = 0;	// dead code
 #endif
+		}
+	catch(...)
+		{
+		free(Buffer);
+		throw;
+		}
 
 	// next: split on newline, to simplify spotting preprocessing-directives vs file to be preprocessed
-	TokenList[0]->ltrim(strspn(TokenList[0]->data(),"\n"));
-	if (TokenList[0]->empty()) return TokenList.reset(),true;
+	tmpTokenList[0]->ltrim(strspn(tmpTokenList[0]->data(),"\n"));
+	if (tmpTokenList[0]->empty()) return TokenList.reset(),true;
 
 	if (lang.BreakTokenOnNewline)
 		{
-		char* newline_where = strchr(TokenList.back()->data(),'\n');
+		char* newline_where = strchr(tmpTokenList.back()->data(),'\n');
 		while(newline_where)
 			{
-			const size_t offset = newline_where-TokenList.back()->data();
-			if (!TokenList.InsertNSlotsAt(1,TokenList.size()-1)) throw std::bad_alloc();
-			TokenList[TokenList.size()-2] = new Token<char>(*TokenList.back(),offset,0);
-			assert('\n'==TokenList.back()->data()[0]);
-			if (3<=TokenList.size()) clean_linesplice_whitespace(TokenList,TokenList.size()-3,lang);
-			TokenList.back()->ltrim(strspn(TokenList.back()->data(),"\n"));
-			if (TokenList.back()->empty())
+			const size_t offset = newline_where-tmpTokenList.back()->data();
+			tmpTokenList.insertNSlotsAt(1,tmpTokenList.size()-1);
+			tmpTokenList[tmpTokenList.size()-2] = new Token<char>(*tmpTokenList.back(),offset,0);
+			assert('\n'==tmpTokenList.back()->data()[0]);
+			if (3<=tmpTokenList.size()) clean_linesplice_whitespace(tmpTokenList,tmpTokenList.size()-3,lang);
+			tmpTokenList.back()->ltrim(strspn(tmpTokenList.back()->data(),"\n"));
+			if (tmpTokenList.back()->empty())
 				{
-				TokenList.DeleteIdx(TokenList.size()-1);
+				tmpTokenList.DeleteIdx(tmpTokenList.size()-1);
 				break;
 				}
-			newline_where = strchr(TokenList.back()->data(),'\n');
+			newline_where = strchr(tmpTokenList.back()->data(),'\n');
 			}
 
 		// final cleanup: works for line-continue languages that consider pure whitespace lines meaningless
-		if (2<=TokenList.size()) clean_linesplice_whitespace(TokenList,TokenList.size()-2,lang);
-		if (!TokenList.empty()) clean_whitespace(TokenList,TokenList.size()-1,lang);
+		if (2<=tmpTokenList.size()) clean_linesplice_whitespace(tmpTokenList,tmpTokenList.size()-2,lang);
+		if (!tmpTokenList.empty()) clean_whitespace(tmpTokenList,tmpTokenList.size()-1,lang);
 		}
 
 	// if the language approves, flush leading whitespace
 	// do not trim trailing whitespace at this time: this breaks error reporting for incomplete C [wide/narrow] character/string literals
 	//! \todo work out how to handle tab stops cleanly
 	{
-	size_t i = TokenList.size();
+	size_t i = tmpTokenList.size();
 	while(0<i)
 		{
-		assert(NULL!=TokenList[i-1]);
-		size_t LeadingWS = strspn(TokenList[--i]->data(),lang.WhiteSpace+1);
-		TokenList[i]->ltrim(LeadingWS);
-		assert(!TokenList[i]->empty());
+		assert(tmpTokenList[i-1]);
+		size_t LeadingWS = strspn(tmpTokenList[--i]->data(),lang.WhiteSpace+1);
+		tmpTokenList[i]->ltrim(LeadingWS);
+		assert(!tmpTokenList[i]->empty());
 		}
 	}
 
 	// correct parent_dir
-	if (!TokenList.empty())
+	if (!tmpTokenList.empty())
 		{
 		char workspace[FILENAME_MAX];
 		z_realpath(workspace,filename);
-		size_t j = TokenList.size();
-		do	TokenList[--j]->parent_dir = register_string(workspace);
+		size_t j = tmpTokenList.size();
+		do	tmpTokenList[--j]->parent_dir = register_string(workspace);
 		while(0<j);
 		};
-
+	swap(tmpTokenList,TokenList);
+	}
+	
 #ifndef NDEBUG
 	// post-condition testing
 	{
@@ -146,8 +156,9 @@
 }
 
 //! \throw std::bad_alloc
-bool load_raw_sourcefile(zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& TokenList, const char* const filename)
+bool load_raw_sourcefile(autovalarray_ptr<Token<char>* >& TokenList, const char* const filename)
 {
+	autovalarray_ptr<Token<char>* > tmpTokenList(1);
 	char* Buffer = NULL;
 #ifndef ZAIMONI_FORCE_ISO
 #	define Buffer_size ArraySize(Buffer)
@@ -173,35 +184,35 @@
 #else
 	TrimMandatoryTerminalNewline(Buffer,Buffer_size,filename);
 #endif
-	
-	SUCCEED_OR_DIE(TokenList.InsertNSlotsAt(1,0));
+
+	try	{
 #ifndef ZAIMONI_FORCE_ISO
-	TokenList[0] = new(std::nothrow) Token<char>(Buffer,filename);
+		tmpTokenList[0] = new Token<char>(Buffer,filename);
 #else
-	TokenList[0] = new(std::nothrow) Token<char>(Buffer,Buffer_size,filename);
-	Buffer_size = 0;
+		tmpTokenList[0] = new Token<char>(Buffer,Buffer_size,filename);
+//		Buffer_size = 0;	// dead code
 #endif
-	if (NULL==TokenList[0])
+		}
+	catch(...)
 		{
 		free(Buffer);
-		TokenList.clear();
-		return false;
-		}
+		throw;
+		};
 
-	char* newline_where = strchr(TokenList.back()->data(),'\n');
+	char* newline_where = strchr(tmpTokenList.back()->data(),'\n');
 	while(newline_where)
 		{
-		const size_t offset = newline_where-TokenList.back()->data();
-		if (!TokenList.InsertNSlotsAt(1,TokenList.size()-1)) throw std::bad_alloc();
-		TokenList[TokenList.size()-2] = new Token<char>(*TokenList.back(),offset,0);
-		assert('\n'==TokenList.back()->data()[0]);
-		TokenList.back()->ltrim(strspn(TokenList.back()->data(),"\n"));
-		if (TokenList.back()->empty())
+		const size_t offset = newline_where-tmpTokenList.back()->data();
+		tmpTokenList.insertNSlotsAt(1,tmpTokenList.size()-1);
+		tmpTokenList[tmpTokenList.size()-2] = new Token<char>(*tmpTokenList.back(),offset,0);
+		assert('\n'==tmpTokenList.back()->data()[0]);
+		tmpTokenList.back()->ltrim(strspn(tmpTokenList.back()->data(),"\n"));
+		if (tmpTokenList.back()->empty())
 			{
-			TokenList.DeleteIdx(TokenList.size()-1);
+			tmpTokenList.DeleteIdx(tmpTokenList.size()-1);
 			break;
 			}
-		newline_where = strchr(TokenList.back()->data(),'\n');
+		newline_where = strchr(tmpTokenList.back()->data(),'\n');
 		}
-	return true;
+	return swap(tmpTokenList,TokenList),true;
 }



From zaimoni at mail.berlios.de  Sat May 15 00:09:09 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 15 May 2010 00:09:09 +0200
Subject: [Zcplusplus-commits] r429 - trunk
Message-ID: <201005142209.o4EM99lY004895@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-15 00:09:06 +0200 (Sat, 15 May 2010)
New Revision: 429

Modified:
   trunk/CPreproc.cpp
Log:
indentation adjust

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2010-05-14 04:49:26 UTC (rev 428)
+++ trunk/CPreproc.cpp	2010-05-14 22:09:06 UTC (rev 429)
@@ -1567,246 +1567,236 @@
 					else_where = i+1;
 				}
 			}
-		else{	// non-directive; lex, and check for macros and _Pragma operators
-				// remember to convert whitespace to single-space tokens, and flush those later
-				// we do not error illegal preprocessing tokens here; that's handled in ZParser
-			if (0==include_where && 0==restart_full_scan)
+		// non-directive; lex, and check for macros and _Pragma operators
+		// remember to convert whitespace to single-space tokens, and flush those later
+		else if (0==include_where && 0==restart_full_scan)
+			{
+			if (!tokenize_line(TokenList,i))
 				{
-				if (!tokenize_line(TokenList,i))
-					{
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+			if (C_TESTFLAG_PP_OP_PUNC & TokenList[i]->flags)
+				{	// check for categorically illegal tokens
+				const signed int old_pp_code = C_PP_DECODE(TokenList[i]->flags);
+				const signed int pp_code = (old_pp_code) ? old_pp_code : lang.pp_support->EncodePPOpPunc(TokenList[i]->data(),TokenList[i]->size());
+				assert(0<pp_code);
+				if (C_DISALLOW_POSTPROCESSED_SOURCE & lang.pp_support->GetPPOpPuncFlags(pp_code))
+					{	//! \todo need test cases
+						// actually, this might need to be language-sensitive (e.g., Perl)
+					message_header(*TokenList[i]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("Forbidden token '");
+					INC_INFORM(TokenList[i]->data(),TokenList[i]->size());
+					INFORM("' in postprocessed source.  Discarding.");
+					zcc_errors.inc_error();
+					TokenList.DeleteIdx(i);
 					if (0==i) goto Restart;
-					if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
-					if (include_where>=i+1) include_where = 0;			// failsafing
 					--i;
 					continue;
-					};
-				if (C_TESTFLAG_PP_OP_PUNC & TokenList[i]->flags)
-					{	// check for categorically illegal tokens
-					const signed int old_pp_code = C_PP_DECODE(TokenList[i]->flags);
-					const signed int pp_code = (old_pp_code) ? old_pp_code : lang.pp_support->EncodePPOpPunc(TokenList[i]->data(),TokenList[i]->size());
-					assert(0<pp_code);
-					if (C_DISALLOW_POSTPROCESSED_SOURCE & lang.pp_support->GetPPOpPuncFlags(pp_code))
-						{	//! \todo need test cases
-							// actually, this might need to be language-sensitive (e.g., Perl)
-						message_header(*TokenList[i]);
+					}
+				C_PP_ENCODE(TokenList[i]->flags,pp_code);
+				}
+			else if (C_TESTFLAG_IDENTIFIER==TokenList[i]->flags)
+				{
+				if (!strcmp(TokenList[i]->data(),"_Pragma"))
+					{	// could be pragma operator; syntax _Pragma ( C-string )
+					while(TokenList.size()>i+1 && !tokenize_line(TokenList,i+1));
+					if (        TokenList.size()<=i+1
+						||   1!=TokenList[i+1]->size()
+						|| '('!=TokenList[i+1]->front())
+						{	//! \test cpp/Pragma.C99/Error_op1.hpp, cpp/Pragma.C99/Error_op1.h
+							//! \test cpp/Pragma.C99/Error_op2.hpp, cpp/Pragma.C99/Error_op2.h
+						message_header2(*TokenList[i],TokenList[i]->logical_line.second);
 						INC_INFORM(ERR_STR);
-						INC_INFORM("Forbidden token '");
-						INC_INFORM(TokenList[i]->data(),TokenList[i]->size());
-						INFORM("' in postprocessed source.  Discarding.");
+						INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
 						zcc_errors.inc_error();
 						TokenList.DeleteIdx(i);
 						if (0==i) goto Restart;
 						--i;
 						continue;
-						}
-					C_PP_ENCODE(TokenList[i]->flags,pp_code);
+						};
+					while(TokenList.size()>i+2 && !tokenize_line(TokenList,i+2));
+					if (   TokenList.size()<=i+2
+						|| C_TESTFLAG_STRING_LITERAL!=TokenList[i+2]->flags)
+						{	//! \test cpp/Pragma.C99/Error_op3.hpp, cpp/Pragma.C99/Error_op3.h
+							//! \test cpp/Pragma.C99/Error_op4.hpp, cpp/Pragma.C99/Error_op4.h
+						message_header2(*TokenList[i],TokenList[i]->logical_line.second);
+						INC_INFORM(ERR_STR);
+						INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
+						zcc_errors.inc_error();
+						TokenList.DeleteNSlotsAt(2,i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					while(TokenList.size()>i+3 && !tokenize_line(TokenList,i+3));
+					if (        TokenList.size()<=i+3
+						||   1!=TokenList[i+3]->size()
+						|| ')'!=TokenList[i+3]->front())
+						{	//! \test cpp/Pragma.C99/Error_op5.hpp, cpp/Pragma.C99/Error_op5.h
+							//! \test cpp/Pragma.C99/Error_op6.hpp, cpp/Pragma.C99/Error_op6.h
+						message_header2(*TokenList[i],TokenList[i]->logical_line.second);
+						INC_INFORM(ERR_STR);
+						INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
+						zcc_errors.inc_error();
+						TokenList.DeleteNSlotsAt(3,i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					if ('L'==TokenList[i+2]->front())
+						TokenList[i+2]->ltrim(1);
+					if (2<TokenList[i+2]->size())
+						{	//! \test Pass_pragma_STDC.hpp
+						autovalarray_ptr_throws<char> pragma_string(lang.UnescapeStringLength(TokenList[i+2]->data()+1,TokenList[i+2]->size()-2));
+						lang.UnescapeString(pragma_string.c_array(),TokenList[i+2]->data()+1,TokenList[i+2]->size()-2);
+						interpret_pragma(pragma_string.data(),pragma_string.size(),locked_macros);
+						};
+					TokenList.DeleteNSlotsAt(4,i);						//! \todo fix once we have code-generation affecting pragmas
+					if (0==i) goto Restart;
+					--i;
+					continue;
 					}
-				else if (C_TESTFLAG_IDENTIFIER==TokenList[i]->flags)
-					{
-					if (!strcmp(TokenList[i]->data(),"_Pragma"))
-						{	// could be pragma operator; syntax _Pragma ( C-string )
-						while(TokenList.size()>i+1 && !tokenize_line(TokenList,i+1));
-						if (        TokenList.size()<=i+1
-							||   1!=TokenList[i+1]->size()
-							|| '('!=TokenList[i+1]->front())
-							{	//! \test cpp/Pragma.C99/Error_op1.hpp, cpp/Pragma.C99/Error_op1.h
-								//! \test cpp/Pragma.C99/Error_op2.hpp, cpp/Pragma.C99/Error_op2.h
-							message_header2(*TokenList[i],TokenList[i]->logical_line.second);
-							INC_INFORM(ERR_STR);
-							INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
-							zcc_errors.inc_error();
-							TokenList.DeleteIdx(i);
-							if (0==i) goto Restart;
-							--i;
-							continue;
-							};
-						while(TokenList.size()>i+2 && !tokenize_line(TokenList,i+2));
-						if (   TokenList.size()<=i+2
-							|| C_TESTFLAG_STRING_LITERAL!=TokenList[i+2]->flags)
-							{	//! \test cpp/Pragma.C99/Error_op3.hpp, cpp/Pragma.C99/Error_op3.h
-								//! \test cpp/Pragma.C99/Error_op4.hpp, cpp/Pragma.C99/Error_op4.h
-							message_header2(*TokenList[i],TokenList[i]->logical_line.second);
-							INC_INFORM(ERR_STR);
-							INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
-							zcc_errors.inc_error();
-							TokenList.DeleteNSlotsAt(2,i);
-							if (0==i) goto Restart;
-							--i;
-							continue;
-							};
-						while(TokenList.size()>i+3 && !tokenize_line(TokenList,i+3));
-						if (        TokenList.size()<=i+3
-							||   1!=TokenList[i+3]->size()
-							|| ')'!=TokenList[i+3]->front())
-							{	//! \test cpp/Pragma.C99/Error_op5.hpp, cpp/Pragma.C99/Error_op5.h
-								//! \test cpp/Pragma.C99/Error_op6.hpp, cpp/Pragma.C99/Error_op6.h
-							message_header2(*TokenList[i],TokenList[i]->logical_line.second);
-							INC_INFORM(ERR_STR);
-							INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
-							zcc_errors.inc_error();
-							TokenList.DeleteNSlotsAt(3,i);
-							if (0==i) goto Restart;
-							--i;
-							continue;
-							};
-						if ('L'==TokenList[i+2]->front())
-							TokenList[i+2]->ltrim(1);
-						if (2<TokenList[i+2]->size())
-							{	//! \test Pass_pragma_STDC.hpp
-							autovalarray_ptr_throws<char> pragma_string(lang.UnescapeStringLength(TokenList[i+2]->data()+1,TokenList[i+2]->size()-2));
-							lang.UnescapeString(pragma_string.c_array(),TokenList[i+2]->data()+1,TokenList[i+2]->size()-2);
-							interpret_pragma(pragma_string.data(),pragma_string.size(),locked_macros);
-							};
-						TokenList.DeleteNSlotsAt(4,i);						//! \todo fix once we have code-generation affecting pragmas
+
+				const errr object_macro_index = binary_find(TokenList[i]->data(),TokenList[i]->size(),macros_object);
+				const errr function_macro_index = binary_find(TokenList[i]->data(),TokenList[i]->size(),macros_function);
+				assert(0>object_macro_index || 0>function_macro_index);
+				if (0<=object_macro_index)
+					{	// object-like macro
+					if (!macros_object_expansion_pre_eval[object_macro_index])
+						{	// expands to nothing
+							//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
+						TokenList.DeleteIdx(i);
 						if (0==i) goto Restart;
 						--i;
 						continue;
 						}
-
-					const errr object_macro_index = binary_find(TokenList[i]->data(),TokenList[i]->size(),macros_object);
-					const errr function_macro_index = binary_find(TokenList[i]->data(),TokenList[i]->size(),macros_function);
-					assert(0>object_macro_index || 0>function_macro_index);
-					if (0<=object_macro_index)
-						{	// object-like macro
-						if (NULL==macros_object_expansion_pre_eval[object_macro_index])
-							{	// expands to nothing
-								//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
-							TokenList.DeleteIdx(i);
-							if (0==i) goto Restart;
-							--i;
-							continue;
-							}
-						assert(!macros_object_expansion_pre_eval[object_macro_index]->empty());
-						{	//! \test cpp/default/Preprocess_*.h/hpp
-						size_t discard = 0;
-						dynamic_macro_replace_once(*TokenList[i],discard,TokenList[i]->size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
-						}
-						size_t actual_tokens = tokenize_line(TokenList,i);
-						assert(0<actual_tokens);
-						i += actual_tokens-1;
-						}
-					else if (0<=function_macro_index)
-						{	// could be function-like macro
-						if (	TokenList.size()>i+1 && TokenList[i]->logical_line.first==TokenList[i+1]->logical_line.first
-							&& 	TokenList[i]->logical_line.second+TokenList[i]->size()==TokenList[i+1]->logical_line.second
-							&&	'('==TokenList[i+1]->front())
-							{
-							size_t paren_depth = 1;
-							size_t comma_count = 0;
-							size_t j = i+1;
-							do	{
-								if (TokenList.size()<=j+1)
-									{	//! \test cpp/Error_macro_arglist4.hpp
-										// error out, incomplete function-like macro
+					assert(!macros_object_expansion_pre_eval[object_macro_index]->empty());
+					{	//! \test cpp/default/Preprocess_*.h/hpp
+					size_t discard = 0;
+					dynamic_macro_replace_once(*TokenList[i],discard,TokenList[i]->size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
+					}
+					size_t actual_tokens = tokenize_line(TokenList,i);
+					assert(0<actual_tokens);
+					i += actual_tokens-1;
+					}
+				else if (0<=function_macro_index)
+					{	// could be function-like macro
+					if (	TokenList.size()>i+1 && TokenList[i]->logical_line.first==TokenList[i+1]->logical_line.first
+						&& 	TokenList[i]->logical_line.second+TokenList[i]->size()==TokenList[i+1]->logical_line.second
+						&&	'('==TokenList[i+1]->front())
+						{
+						size_t paren_depth = 1;
+						size_t comma_count = 0;
+						size_t j = i+1;
+						do	{
+							if (TokenList.size()<=j+1)
+								{	//! \test cpp/Error_macro_arglist4.hpp
+									// error out, incomplete function-like macro
+								message_header2(*TokenList[i],TokenList[i]->logical_line.second);
+								INC_INFORM(ERR_STR);
+								INC_INFORM("macro ");
+								INC_INFORM(TokenList[i]->data(),TokenList[i]->size());
+								INFORM(" did not close its argument list in time. (C99 6.10p1/C++98 16.1p1)");
+								zcc_errors.inc_error();
+								i = j;
+								break;
+								}
+							if (TokenList[j]->logical_line.first<TokenList[j+1]->logical_line.first)
+								{	// line advance; check for pp-directives (undefined behavior), then tokenize
+								if (line_is_preprocessing_directive(*TokenList[j+1]))
+									{	//! \test cpp/Error_macro_arglist7.hpp
+										// error out, undefined behavior
 									message_header2(*TokenList[i],TokenList[i]->logical_line.second);
 									INC_INFORM(ERR_STR);
-									INC_INFORM("macro ");
-									INC_INFORM(TokenList[i]->data(),TokenList[i]->size());
-									INFORM(" did not close its argument list in time. (C99 6.10p1/C++98 16.1p1)");
+									INFORM("macro invocation contains preprocessing directive.  Defining undefined behavior as ignoring macro invocation. (C99 6.10.3p11/C++98 16.3p10)");
 									zcc_errors.inc_error();
 									i = j;
 									break;
 									}
-								if (TokenList[j]->logical_line.first<TokenList[j+1]->logical_line.first)
-									{	// line advance; check for pp-directives (undefined behavior), then tokenize
-									if (line_is_preprocessing_directive(*TokenList[j+1]))
-										{	//! \test cpp/Error_macro_arglist7.hpp
-											// error out, undefined behavior
-										message_header2(*TokenList[i],TokenList[i]->logical_line.second);
-										INC_INFORM(ERR_STR);
-										INFORM("macro invocation contains preprocessing directive.  Defining undefined behavior as ignoring macro invocation. (C99 6.10.3p11/C++98 16.3p10)");
-										zcc_errors.inc_error();
-										i = j;
-										break;
-										}
-									if (!tokenize_line(TokenList,j+1)) continue;
-									}
-								if (1==TokenList[++j]->size())
-									{
-									switch(TokenList[j]->front())
-									{
-									case '(':	{
-												++paren_depth;
-												break;
-												}
-									case ',':	{
-												++comma_count;
-												break;
-												}
-									case ')':	{
-												--paren_depth;
-												//	break;
-												}
-									};
-									}
+								if (!tokenize_line(TokenList,j+1)) continue;
 								}
-							while(0<paren_depth);
-							if (0==paren_depth)
+							if (1==TokenList[++j]->size())
+								switch(TokenList[j]->front())
 								{
-								assert(NULL!=macros_function_arglist[function_macro_index]);
-								assert('('==macros_function_arglist[function_macro_index]->front());
-								assert(')'==macros_function_arglist[function_macro_index]->back());
-								const size_t formal_arg_span = macros_function_arglist[function_macro_index]->size();
-								const size_t formal_arg_count = (2<formal_arg_span) ? std::count(macros_function_arglist[function_macro_index]->begin(),macros_function_arglist[function_macro_index]->end(),',')+1 : 0;
-								const bool formal_varadic = 5<=formal_arg_span && !strncmp(macros_function_arglist[function_macro_index]->data()+(formal_arg_span-4),"...",sizeof("...")-1);
-								const size_t arg_count = (i+2==j) ? 0 : comma_count+1;
-								if (arg_count<formal_arg_count || (arg_count>formal_arg_count && !formal_varadic))
-									{	//! \test cpp/Error_macro_arglist5.hpp
-										//! \test cpp/Error_macro_arglist6.hpp
-									message_header2(*TokenList[i],TokenList[i]->logical_line.second);
-									INC_INFORM(ERR_STR);
-									INC_INFORM("macro ");
-									INC_INFORM(TokenList[i]->data(),TokenList[i]->size());
-									INC_INFORM(" had ");
-									INC_INFORM(arg_count);
-									INC_INFORM(" argument");
-									INC_INFORM((1==arg_count) ? "" : "s");
-									INC_INFORM(", needed ");
-									if (formal_varadic) INC_INFORM("at least ");
-									INC_INFORM(formal_arg_count);
-									INFORM(". (C99 6.10p1/C++0x 16.1p1)");
-									zcc_errors.inc_error();
-									i = j;
-									continue;
-									}
-								if (NULL==macros_function_expansion_pre_eval[function_macro_index])
-									{	// expands to nothing
-										//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
-									TokenList.DeleteNSlotsAt(j-i+1,i);
-									if (0==i) goto Restart;
-									--i;
-									continue;
-									}
-								assert(!macros_function_expansion_pre_eval[function_macro_index]->empty());
-								{	//! \test default/Preprocess_*.h/hpp 
-								Token<char>* Tmp = new Token<char>(*macros_function_expansion_pre_eval[function_macro_index]);
-								Tmp->logical_line = TokenList[i]->logical_line;
-								if (!nonrecursive_macro_replacement_list(Tmp->data()))
-									{	// XXX trashes line information to reuse intrapreprocessing stuff
-									size_t discard = i;
-									Token<char>* Tmp2 = new Token<char>(*TokenList[i]);
-									while(++discard <= j) Tmp2->append(TokenList[discard]->data());
-									discard = 0;
-									dynamic_macro_replace_once(*Tmp2,discard,TokenList[i]->size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
-									delete Tmp;
-									Tmp = Tmp2;
-									}
-								TokenList.DeleteNSlotsAt(j-i,i+1);
-								delete TokenList[i];
-								TokenList[i] = Tmp;
-								}
-								size_t actual_tokens = tokenize_line(TokenList,i);
-								assert(0<actual_tokens);
-								i += actual_tokens-1;
+								case '(':
+									++paren_depth;
+									break;
+								case ',':
+									++comma_count;
+									break;
+								case ')':
+									--paren_depth;
+									//	break;
 								};
 							}
+						while(0<paren_depth);
+						if (0==paren_depth)
+							{
+							assert(macros_function_arglist[function_macro_index]);
+							assert('('==macros_function_arglist[function_macro_index]->front());
+							assert(')'==macros_function_arglist[function_macro_index]->back());
+							const size_t formal_arg_span = macros_function_arglist[function_macro_index]->size();
+							const size_t formal_arg_count = (2<formal_arg_span) ? std::count(macros_function_arglist[function_macro_index]->begin(),macros_function_arglist[function_macro_index]->end(),',')+1 : 0;
+							const bool formal_varadic = 5<=formal_arg_span && !strncmp(macros_function_arglist[function_macro_index]->data()+(formal_arg_span-4),"...",sizeof("...")-1);
+							const size_t arg_count = (i+2==j) ? 0 : comma_count+1;
+							if (arg_count<formal_arg_count || (arg_count>formal_arg_count && !formal_varadic))
+								{	//! \test cpp/Error_macro_arglist5.hpp
+									//! \test cpp/Error_macro_arglist6.hpp
+								message_header2(*TokenList[i],TokenList[i]->logical_line.second);
+								INC_INFORM(ERR_STR);
+								INC_INFORM("macro ");
+								INC_INFORM(TokenList[i]->data(),TokenList[i]->size());
+								INC_INFORM(" had ");
+								INC_INFORM(arg_count);
+								INC_INFORM(" argument");
+								INC_INFORM((1==arg_count) ? "" : "s");
+								INC_INFORM(", needed ");
+								if (formal_varadic) INC_INFORM("at least ");
+								INC_INFORM(formal_arg_count);
+								INFORM(". (C99 6.10p1/C++0x 16.1p1)");
+								zcc_errors.inc_error();
+								i = j;
+								continue;
+								}
+							if (!macros_function_expansion_pre_eval[function_macro_index])
+								{	// expands to nothing
+									//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
+								TokenList.DeleteNSlotsAt(j-i+1,i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+							assert(!macros_function_expansion_pre_eval[function_macro_index]->empty());
+							{	//! \test default/Preprocess_*.h/hpp 
+							Token<char>* Tmp = new Token<char>(*macros_function_expansion_pre_eval[function_macro_index]);
+							Tmp->logical_line = TokenList[i]->logical_line;
+							if (!nonrecursive_macro_replacement_list(Tmp->data()))
+								{	// XXX trashes line information to reuse intrapreprocessing stuff
+								size_t discard = i;
+								Token<char>* Tmp2 = new Token<char>(*TokenList[i]);
+								while(++discard <= j) Tmp2->append(TokenList[discard]->data());
+								discard = 0;
+								dynamic_macro_replace_once(*Tmp2,discard,TokenList[i]->size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
+								delete Tmp;
+								Tmp = Tmp2;
+								}
+							TokenList.DeleteNSlotsAt(j-i,i+1);
+							delete TokenList[i];
+							TokenList[i] = Tmp;
+							}
+							size_t actual_tokens = tokenize_line(TokenList,i);
+							assert(0<actual_tokens);
+							i += actual_tokens-1;
+							};
 						}
-					else{	// replace predefined macros, if they are here
-							//! \test cpp/default/Preprocess_STDC_defines.hpp, cpp/default/Preprocess_STDC_defines.h
-						size_t discard = 0;
-						predefined_macro_replacement(*TokenList[i],discard);
-						}
 					}
+				else{	// replace predefined macros, if they are here
+						//! \test cpp/default/Preprocess_STDC_defines.hpp, cpp/default/Preprocess_STDC_defines.h
+					predefined_macro_replacement(*TokenList[i],0);
+					}
 				}
 			}
 		}



From zaimoni at mail.berlios.de  Sat May 15 00:09:19 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 15 May 2010 00:09:19 +0200
Subject: [Zcplusplus-commits] r430 - trunk
Message-ID: <201005142209.o4EM9J9d004921@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-15 00:09:16 +0200 (Sat, 15 May 2010)
New Revision: 430

Modified:
   trunk/CPreproc_pp.cpp
Log:
indentation adjust

Modified: trunk/CPreproc_pp.cpp
===================================================================
--- trunk/CPreproc_pp.cpp	2010-05-14 22:09:06 UTC (rev 429)
+++ trunk/CPreproc_pp.cpp	2010-05-14 22:09:16 UTC (rev 430)
@@ -1561,246 +1561,236 @@
 					else_where = i+1;
 				}
 			}
-		else{	// non-directive; lex, and check for macros and _Pragma operators
-				// remember to convert whitespace to single-space tokens, and flush those later
-				// we do not error illegal preprocessing tokens here; that's handled in ZParser
-			if (0==include_where && 0==restart_full_scan)
+		// non-directive; lex, and check for macros and _Pragma operators
+		// remember to convert whitespace to single-space tokens, and flush those later
+		else if (0==include_where && 0==restart_full_scan)
+			{
+			if (!tokenize_line(TokenList,i))
 				{
-				if (!tokenize_line(TokenList,i))
-					{
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+			if (C_TESTFLAG_PP_OP_PUNC & TokenList[i]->flags)
+				{	// check for categorically illegal tokens
+				const signed int old_pp_code = C_PP_DECODE(TokenList[i]->flags);
+				const signed int pp_code = (old_pp_code) ? old_pp_code : lang.pp_support->EncodePPOpPunc(TokenList[i]->data(),TokenList[i]->size());
+				assert(0<pp_code);
+				if (C_DISALLOW_POSTPROCESSED_SOURCE & lang.pp_support->GetPPOpPuncFlags(pp_code))
+					{	//! \todo need test cases
+						// actually, this might need to be language-sensitive (e.g., Perl)
+					message_header(*TokenList[i]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("Forbidden token '");
+					INC_INFORM(TokenList[i]->data(),TokenList[i]->size());
+					INFORM("' in postprocessed source.  Discarding.");
+					zcc_errors.inc_error();
+					TokenList.DeleteIdx(i);
 					if (0==i) goto Restart;
-					if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
-					if (include_where>=i+1) include_where = 0;			// failsafing
 					--i;
 					continue;
-					};
-				if (C_TESTFLAG_PP_OP_PUNC & TokenList[i]->flags)
-					{	// check for categorically illegal tokens
-					const signed int old_pp_code = C_PP_DECODE(TokenList[i]->flags);
-					const signed int pp_code = (old_pp_code) ? old_pp_code : lang.pp_support->EncodePPOpPunc(TokenList[i]->data(),TokenList[i]->size());
-					assert(0<pp_code);
-					if (C_DISALLOW_POSTPROCESSED_SOURCE & lang.pp_support->GetPPOpPuncFlags(pp_code))
-						{	//! \todo need test cases
-							// actually, this might need to be language-sensitive (e.g., Perl)
-						message_header(*TokenList[i]);
+					}
+				C_PP_ENCODE(TokenList[i]->flags,pp_code);
+				}
+			else if (C_TESTFLAG_IDENTIFIER==TokenList[i]->flags)
+				{
+				if (!strcmp(TokenList[i]->data(),"_Pragma"))
+					{	// could be pragma operator; syntax _Pragma ( C-string )
+					while(TokenList.size()>i+1 && !tokenize_line(TokenList,i+1));
+					if (        TokenList.size()<=i+1
+						||   1!=TokenList[i+1]->size()
+						|| '('!=TokenList[i+1]->front())
+						{	//! \test cpp/Pragma.C99/Error_op1.hpp, cpp/Pragma.C99/Error_op1.h
+							//! \test cpp/Pragma.C99/Error_op2.hpp, cpp/Pragma.C99/Error_op2.h
+						message_header2(*TokenList[i],TokenList[i]->logical_line.second);
 						INC_INFORM(ERR_STR);
-						INC_INFORM("Forbidden token '");
-						INC_INFORM(TokenList[i]->data(),TokenList[i]->size());
-						INFORM("' in postprocessed source.  Discarding.");
+						INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
 						zcc_errors.inc_error();
 						TokenList.DeleteIdx(i);
 						if (0==i) goto Restart;
 						--i;
 						continue;
-						}
-					C_PP_ENCODE(TokenList[i]->flags,pp_code);
+						};
+					while(TokenList.size()>i+2 && !tokenize_line(TokenList,i+2));
+					if (   TokenList.size()<=i+2
+						|| C_TESTFLAG_STRING_LITERAL!=TokenList[i+2]->flags)
+						{	//! \test cpp/Pragma.C99/Error_op3.hpp, cpp/Pragma.C99/Error_op3.h
+							//! \test cpp/Pragma.C99/Error_op4.hpp, cpp/Pragma.C99/Error_op4.h
+						message_header2(*TokenList[i],TokenList[i]->logical_line.second);
+						INC_INFORM(ERR_STR);
+						INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
+						zcc_errors.inc_error();
+						TokenList.DeleteNSlotsAt(2,i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					while(TokenList.size()>i+3 && !tokenize_line(TokenList,i+3));
+					if (        TokenList.size()<=i+3
+						||   1!=TokenList[i+3]->size()
+						|| ')'!=TokenList[i+3]->front())
+						{	//! \test cpp/Pragma.C99/Error_op5.hpp, cpp/Pragma.C99/Error_op5.h
+							//! \test cpp/Pragma.C99/Error_op6.hpp, cpp/Pragma.C99/Error_op6.h
+						message_header2(*TokenList[i],TokenList[i]->logical_line.second);
+						INC_INFORM(ERR_STR);
+						INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
+						zcc_errors.inc_error();
+						TokenList.DeleteNSlotsAt(3,i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					if ('L'==TokenList[i+2]->front())
+						TokenList[i+2]->ltrim(1);
+					if (2<TokenList[i+2]->size())
+						{	//! \test Pass_pragma_STDC.hpp
+						autovalarray_ptr_throws<char> pragma_string(lang.UnescapeStringLength(TokenList[i+2]->data()+1,TokenList[i+2]->size()-2));
+						lang.UnescapeString(pragma_string.c_array(),TokenList[i+2]->data()+1,TokenList[i+2]->size()-2);
+						interpret_pragma(pragma_string.data(),pragma_string.size(),locked_macros);
+						};
+					TokenList.DeleteNSlotsAt(4,i);						//! \todo fix once we have code-generation affecting pragmas
+					if (0==i) goto Restart;
+					--i;
+					continue;
 					}
-				else if (C_TESTFLAG_IDENTIFIER==TokenList[i]->flags)
-					{
-					if (!strcmp(TokenList[i]->data(),"_Pragma"))
-						{	// could be pragma operator; syntax _Pragma ( C-string )
-						while(TokenList.size()>i+1 && !tokenize_line(TokenList,i+1));
-						if (        TokenList.size()<=i+1
-							||   1!=TokenList[i+1]->size()
-							|| '('!=TokenList[i+1]->front())
-							{	//! \test cpp/Pragma.C99/Error_op1.hpp, cpp/Pragma.C99/Error_op1.h
-								//! \test cpp/Pragma.C99/Error_op2.hpp, cpp/Pragma.C99/Error_op2.h
-							message_header2(*TokenList[i],TokenList[i]->logical_line.second);
-							INC_INFORM(ERR_STR);
-							INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
-							zcc_errors.inc_error();
-							TokenList.DeleteIdx(i);
-							if (0==i) goto Restart;
-							--i;
-							continue;
-							};
-						while(TokenList.size()>i+2 && !tokenize_line(TokenList,i+2));
-						if (   TokenList.size()<=i+2
-							|| C_TESTFLAG_STRING_LITERAL!=TokenList[i+2]->flags)
-							{	//! \test cpp/Pragma.C99/Error_op3.hpp, cpp/Pragma.C99/Error_op3.h
-								//! \test cpp/Pragma.C99/Error_op4.hpp, cpp/Pragma.C99/Error_op4.h
-							message_header2(*TokenList[i],TokenList[i]->logical_line.second);
-							INC_INFORM(ERR_STR);
-							INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
-							zcc_errors.inc_error();
-							TokenList.DeleteNSlotsAt(2,i);
-							if (0==i) goto Restart;
-							--i;
-							continue;
-							};
-						while(TokenList.size()>i+3 && !tokenize_line(TokenList,i+3));
-						if (        TokenList.size()<=i+3
-							||   1!=TokenList[i+3]->size()
-							|| ')'!=TokenList[i+3]->front())
-							{	//! \test cpp/Pragma.C99/Error_op5.hpp, cpp/Pragma.C99/Error_op5.h
-								//! \test cpp/Pragma.C99/Error_op6.hpp, cpp/Pragma.C99/Error_op6.h
-							message_header2(*TokenList[i],TokenList[i]->logical_line.second);
-							INC_INFORM(ERR_STR);
-							INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
-							zcc_errors.inc_error();
-							TokenList.DeleteNSlotsAt(3,i);
-							if (0==i) goto Restart;
-							--i;
-							continue;
-							};
-						if ('L'==TokenList[i+2]->front())
-							TokenList[i+2]->ltrim(1);
-						if (2<TokenList[i+2]->size())
-							{	//! \test Pass_pragma_STDC.hpp
-							autovalarray_ptr_throws<char> pragma_string(lang.UnescapeStringLength(TokenList[i+2]->data()+1,TokenList[i+2]->size()-2));
-							lang.UnescapeString(pragma_string.c_array(),TokenList[i+2]->data()+1,TokenList[i+2]->size()-2);
-							interpret_pragma(pragma_string.data(),pragma_string.size(),locked_macros);
-							};
-						TokenList.DeleteNSlotsAt(4,i);						//! \todo fix once we have code-generation affecting pragmas
+
+				const errr object_macro_index = binary_find(TokenList[i]->data(),TokenList[i]->size(),macros_object);
+				const errr function_macro_index = binary_find(TokenList[i]->data(),TokenList[i]->size(),macros_function);
+				assert(0>object_macro_index || 0>function_macro_index);
+				if (0<=object_macro_index)
+					{	// object-like macro
+					if (!macros_object_expansion_pre_eval[object_macro_index])
+						{	// expands to nothing
+							//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
+						TokenList.DeleteIdx(i);
 						if (0==i) goto Restart;
 						--i;
 						continue;
 						}
-
-					const errr object_macro_index = binary_find(TokenList[i]->data(),TokenList[i]->size(),macros_object);
-					const errr function_macro_index = binary_find(TokenList[i]->data(),TokenList[i]->size(),macros_function);
-					assert(0>object_macro_index || 0>function_macro_index);
-					if (0<=object_macro_index)
-						{	// object-like macro
-						if (NULL==macros_object_expansion_pre_eval[object_macro_index])
-							{	// expands to nothing
-								//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
-							TokenList.DeleteIdx(i);
-							if (0==i) goto Restart;
-							--i;
-							continue;
-							}
-						assert(!macros_object_expansion_pre_eval[object_macro_index]->empty());
-						{	//! \test cpp/default/Preprocess_*.h/hpp
-						size_t discard = 0;
-						dynamic_macro_replace_once(*TokenList[i],discard,TokenList[i]->size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
-						}
-						size_t actual_tokens = tokenize_line(TokenList,i);
-						assert(0<actual_tokens);
-						i += actual_tokens-1;
-						}
-					else if (0<=function_macro_index)
-						{	// could be function-like macro
-						if (	TokenList.size()>i+1 && TokenList[i]->logical_line.first==TokenList[i+1]->logical_line.first
-							&& 	TokenList[i]->logical_line.second+TokenList[i]->size()==TokenList[i+1]->logical_line.second
-							&&	'('==TokenList[i+1]->front())
-							{
-							size_t paren_depth = 1;
-							size_t comma_count = 0;
-							size_t j = i+1;
-							do	{
-								if (TokenList.size()<=j+1)
-									{	//! \test cpp/Error_macro_arglist4.hpp
-										// error out, incomplete function-like macro
+					assert(!macros_object_expansion_pre_eval[object_macro_index]->empty());
+					{	//! \test cpp/default/Preprocess_*.h/hpp
+					size_t discard = 0;
+					dynamic_macro_replace_once(*TokenList[i],discard,TokenList[i]->size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
+					}
+					size_t actual_tokens = tokenize_line(TokenList,i);
+					assert(0<actual_tokens);
+					i += actual_tokens-1;
+					}
+				else if (0<=function_macro_index)
+					{	// could be function-like macro
+					if (	TokenList.size()>i+1 && TokenList[i]->logical_line.first==TokenList[i+1]->logical_line.first
+						&& 	TokenList[i]->logical_line.second+TokenList[i]->size()==TokenList[i+1]->logical_line.second
+						&&	'('==TokenList[i+1]->front())
+						{
+						size_t paren_depth = 1;
+						size_t comma_count = 0;
+						size_t j = i+1;
+						do	{
+							if (TokenList.size()<=j+1)
+								{	//! \test cpp/Error_macro_arglist4.hpp
+									// error out, incomplete function-like macro
+								message_header2(*TokenList[i],TokenList[i]->logical_line.second);
+								INC_INFORM(ERR_STR);
+								INC_INFORM("macro ");
+								INC_INFORM(TokenList[i]->data(),TokenList[i]->size());
+								INFORM(" did not close its argument list in time. (C99 6.10p1/C++98 16.1p1)");
+								zcc_errors.inc_error();
+								i = j;
+								break;
+								}
+							if (TokenList[j]->logical_line.first<TokenList[j+1]->logical_line.first)
+								{	// line advance; check for pp-directives (undefined behavior), then tokenize
+								if (line_is_preprocessing_directive(*TokenList[j+1]))
+									{	//! \test cpp/Error_macro_arglist7.hpp
+										// error out, undefined behavior
 									message_header2(*TokenList[i],TokenList[i]->logical_line.second);
 									INC_INFORM(ERR_STR);
-									INC_INFORM("macro ");
-									INC_INFORM(TokenList[i]->data(),TokenList[i]->size());
-									INFORM(" did not close its argument list in time. (C99 6.10p1/C++98 16.1p1)");
+									INFORM("macro invocation contains preprocessing directive.  Defining undefined behavior as ignoring macro invocation. (C99 6.10.3p11/C++98 16.3p10)");
 									zcc_errors.inc_error();
 									i = j;
 									break;
 									}
-								if (TokenList[j]->logical_line.first<TokenList[j+1]->logical_line.first)
-									{	// line advance; check for pp-directives (undefined behavior), then tokenize
-									if (line_is_preprocessing_directive(*TokenList[j+1]))
-										{	//! \test cpp/Error_macro_arglist7.hpp
-											// error out, undefined behavior
-										message_header2(*TokenList[i],TokenList[i]->logical_line.second);
-										INC_INFORM(ERR_STR);
-										INFORM("macro invocation contains preprocessing directive.  Defining undefined behavior as ignoring macro invocation. (C99 6.10.3p11/C++98 16.3p10)");
-										zcc_errors.inc_error();
-										i = j;
-										break;
-										}
-									if (!tokenize_line(TokenList,j+1)) continue;
-									}
-								if (1==TokenList[++j]->size())
-									{
-									switch(TokenList[j]->front())
-									{
-									case '(':	{
-												++paren_depth;
-												break;
-												}
-									case ',':	{
-												++comma_count;
-												break;
-												}
-									case ')':	{
-												--paren_depth;
-												//	break;
-												}
-									};
-									}
+								if (!tokenize_line(TokenList,j+1)) continue;
 								}
-							while(0<paren_depth);
-							if (0==paren_depth)
+							if (1==TokenList[++j]->size())
+								switch(TokenList[j]->front())
 								{
-								assert(NULL!=macros_function_arglist[function_macro_index]);
-								assert('('==macros_function_arglist[function_macro_index]->front());
-								assert(')'==macros_function_arglist[function_macro_index]->back());
-								const size_t formal_arg_span = macros_function_arglist[function_macro_index]->size();
-								const size_t formal_arg_count = (2<formal_arg_span) ? std::count(macros_function_arglist[function_macro_index]->begin(),macros_function_arglist[function_macro_index]->end(),',')+1 : 0;
-								const bool formal_varadic = 5<=formal_arg_span && !strncmp(macros_function_arglist[function_macro_index]->data()+(formal_arg_span-4),"...",sizeof("...")-1);
-								const size_t arg_count = (i+2==j) ? 0 : comma_count+1;
-								if (arg_count<formal_arg_count || (arg_count>formal_arg_count && !formal_varadic))
-									{	//! \test cpp/Error_macro_arglist5.hpp
-										//! \test cpp/Error_macro_arglist6.hpp
-									message_header2(*TokenList[i],TokenList[i]->logical_line.second);
-									INC_INFORM(ERR_STR);
-									INC_INFORM("macro ");
-									INC_INFORM(TokenList[i]->data(),TokenList[i]->size());
-									INC_INFORM(" had ");
-									INC_INFORM(arg_count);
-									INC_INFORM(" argument");
-									INC_INFORM((1==arg_count) ? "" : "s");
-									INC_INFORM(", needed ");
-									if (formal_varadic) INC_INFORM("at least ");
-									INC_INFORM(formal_arg_count);
-									INFORM(". (C99 6.10p1/C++0x 16.1p1)");
-									zcc_errors.inc_error();
-									i = j;
-									continue;
-									}
-								if (NULL==macros_function_expansion_pre_eval[function_macro_index])
-									{	// expands to nothing
-										//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
-									TokenList.DeleteNSlotsAt(j-i+1,i);
-									if (0==i) goto Restart;
-									--i;
-									continue;
-									}
-								assert(!macros_function_expansion_pre_eval[function_macro_index]->empty());
-								{	//! \test default/Preprocess_*.h/hpp 
-								Token<char>* Tmp = new Token<char>(*macros_function_expansion_pre_eval[function_macro_index]);
-								Tmp->logical_line = TokenList[i]->logical_line;
-								if (!nonrecursive_macro_replacement_list(Tmp->data()))
-									{	// XXX trashes line information to reuse intrapreprocessing stuff
-									size_t discard = i;
-									Token<char>* Tmp2 = new Token<char>(*TokenList[i]);
-									while(++discard <= j) Tmp2->append(TokenList[discard]->data());
-									discard = 0;
-									dynamic_macro_replace_once(*Tmp2,discard,TokenList[i]->size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
-									delete Tmp;
-									Tmp = Tmp2;
-									}
-								TokenList.DeleteNSlotsAt(j-i,i+1);
-								delete TokenList[i];
-								TokenList[i] = Tmp;
-								}
-								size_t actual_tokens = tokenize_line(TokenList,i);
-								assert(0<actual_tokens);
-								i += actual_tokens-1;
+								case '(':
+									++paren_depth;
+									break;
+								case ',':
+									++comma_count;
+									break;
+								case ')':
+									--paren_depth;
+									//	break;
 								};
 							}
+						while(0<paren_depth);
+						if (0==paren_depth)
+							{
+							assert(macros_function_arglist[function_macro_index]);
+							assert('('==macros_function_arglist[function_macro_index]->front());
+							assert(')'==macros_function_arglist[function_macro_index]->back());
+							const size_t formal_arg_span = macros_function_arglist[function_macro_index]->size();
+							const size_t formal_arg_count = (2<formal_arg_span) ? std::count(macros_function_arglist[function_macro_index]->begin(),macros_function_arglist[function_macro_index]->end(),',')+1 : 0;
+							const bool formal_varadic = 5<=formal_arg_span && !strncmp(macros_function_arglist[function_macro_index]->data()+(formal_arg_span-4),"...",sizeof("...")-1);
+							const size_t arg_count = (i+2==j) ? 0 : comma_count+1;
+							if (arg_count<formal_arg_count || (arg_count>formal_arg_count && !formal_varadic))
+								{	//! \test cpp/Error_macro_arglist5.hpp
+									//! \test cpp/Error_macro_arglist6.hpp
+								message_header2(*TokenList[i],TokenList[i]->logical_line.second);
+								INC_INFORM(ERR_STR);
+								INC_INFORM("macro ");
+								INC_INFORM(TokenList[i]->data(),TokenList[i]->size());
+								INC_INFORM(" had ");
+								INC_INFORM(arg_count);
+								INC_INFORM(" argument");
+								INC_INFORM((1==arg_count) ? "" : "s");
+								INC_INFORM(", needed ");
+								if (formal_varadic) INC_INFORM("at least ");
+								INC_INFORM(formal_arg_count);
+								INFORM(". (C99 6.10p1/C++0x 16.1p1)");
+								zcc_errors.inc_error();
+								i = j;
+								continue;
+								}
+							if (!macros_function_expansion_pre_eval[function_macro_index])
+								{	// expands to nothing
+									//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
+								TokenList.DeleteNSlotsAt(j-i+1,i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+							assert(!macros_function_expansion_pre_eval[function_macro_index]->empty());
+							{	//! \test default/Preprocess_*.h/hpp 
+							Token<char>* Tmp = new Token<char>(*macros_function_expansion_pre_eval[function_macro_index]);
+							Tmp->logical_line = TokenList[i]->logical_line;
+							if (!nonrecursive_macro_replacement_list(Tmp->data()))
+								{	// XXX trashes line information to reuse intrapreprocessing stuff
+								size_t discard = i;
+								Token<char>* Tmp2 = new Token<char>(*TokenList[i]);
+								while(++discard <= j) Tmp2->append(TokenList[discard]->data());
+								discard = 0;
+								dynamic_macro_replace_once(*Tmp2,discard,TokenList[i]->size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
+								delete Tmp;
+								Tmp = Tmp2;
+								}
+							TokenList.DeleteNSlotsAt(j-i,i+1);
+							delete TokenList[i];
+							TokenList[i] = Tmp;
+							}
+							size_t actual_tokens = tokenize_line(TokenList,i);
+							assert(0<actual_tokens);
+							i += actual_tokens-1;
+							};
 						}
-					else{	// replace predefined macros, if they are here
-							//! \test cpp/default/Preprocess_STDC_defines.hpp, cpp/default/Preprocess_STDC_defines.h
-						size_t discard = 0;
-						predefined_macro_replacement(*TokenList[i],discard);
-						}
 					}
+				else{	// replace predefined macros, if they are here
+						//! \test cpp/default/Preprocess_STDC_defines.hpp, cpp/default/Preprocess_STDC_defines.h
+					predefined_macro_replacement(*TokenList[i],0);
+					}
 				}
 			}
 		}



From zaimoni at mail.berlios.de  Sat May 15 01:57:51 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 15 May 2010 01:57:51 +0200
Subject: [Zcplusplus-commits] r431 - in trunk: . tests/cpp/default/keywords
Message-ID: <201005142357.o4ENvp3t019201@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-15 01:57:44 +0200 (Sat, 15 May 2010)
New Revision: 431

Added:
   trunk/tests/cpp/default/keywords/Error__Thread_Local.h
Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
per C1X, consider _Thread_Local a keyword

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-14 22:09:16 UTC (rev 430)
+++ trunk/CSupport.cpp	2010-05-14 23:57:44 UTC (rev 431)
@@ -450,7 +450,8 @@
 
 static const POD_pair<const char*,size_t> valid_keyword[]
 	=	{	DICT_STRUCT("__asm"),		// reserved to the implementation, so OK to make a keyword for C only
-			DICT_STRUCT("_Static_Assert"),	// C1X keyword not in C++0X
+			DICT_STRUCT("_Static_Assert"),	// C1X keywords not in C++0X
+			DICT_STRUCT("_Thread_Local"),
 			DICT_STRUCT("restrict"),	// C99 keywords not in C++98
 			DICT_STRUCT("_Bool"),
 			DICT_STRUCT("_Complex"),
@@ -534,12 +535,10 @@
 			DICT_STRUCT("thread_local")
 		};
 
-//! \todo some way to test that constexpr, thread_local are locked only for C++0X mode
-
 // think about C++0x keywords later.
 #define C_KEYWORD_NONSTRICT_LB 0
-#define CPP_KEYWORD_NONSTRICT_LB 6
-#define C_KEYWORD_STRICT_UB 39
+#define CPP_KEYWORD_NONSTRICT_LB 7
+#define C_KEYWORD_STRICT_UB 40
 #define CPP_KEYWORD_STRICT_UB STATIC_SIZE(valid_keyword)
 
 BOOST_STATIC_ASSERT(C_KEYWORD_NONSTRICT_LB<C_KEYWORD_STRICT_UB);

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-14 22:09:16 UTC (rev 430)
+++ trunk/CSupport_pp.cpp	2010-05-14 23:57:44 UTC (rev 431)
@@ -1,4 +1,4 @@
-// CSupport.cpp
+// CSupport_pp.cpp
 // support for C/C++ parsing
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
@@ -440,7 +440,8 @@
 
 static const POD_pair<const char*,size_t> valid_keyword[]
 	=	{	DICT_STRUCT("__asm"),		// reserved to the implementation, so OK to make a keyword for C only
-			DICT_STRUCT("_Static_Assert"),	// C1X keyword not in C++0X
+			DICT_STRUCT("_Static_Assert"),	// C1X keywords not in C++0X
+			DICT_STRUCT("_Thread_Local"),
 			DICT_STRUCT("restrict"),	// C99 keywords not in C++98
 			DICT_STRUCT("_Bool"),
 			DICT_STRUCT("_Complex"),
@@ -524,12 +525,10 @@
 			DICT_STRUCT("thread_local")
 		};
 
-//! \todo some way to test that constexpr, thread_local are locked only for C++0X mode
-
 // think about C++0x keywords later.
 #define C_KEYWORD_NONSTRICT_LB 0
-#define CPP_KEYWORD_NONSTRICT_LB 6
-#define C_KEYWORD_STRICT_UB 39
+#define CPP_KEYWORD_NONSTRICT_LB 7
+#define C_KEYWORD_STRICT_UB 40
 #define CPP_KEYWORD_STRICT_UB STATIC_SIZE(valid_keyword)
 
 BOOST_STATIC_ASSERT(C_KEYWORD_NONSTRICT_LB<C_KEYWORD_STRICT_UB);

Added: trunk/tests/cpp/default/keywords/Error__Thread_Local.h
===================================================================
--- trunk/tests/cpp/default/keywords/Error__Thread_Local.h	2010-05-14 22:09:16 UTC (rev 430)
+++ trunk/tests/cpp/default/keywords/Error__Thread_Local.h	2010-05-14 23:57:44 UTC (rev 431)
@@ -0,0 +1,5 @@
+// default\keywords\Error__Thread_Local.h
+// check that #define of _Thread_Local errors
+// (C)2010 Kenneth Boyd, license: MIT.txt
+#define _Thread_Local 1
+#include <stdbool.h>



From zaimoni at mail.berlios.de  Sat May 15 20:50:39 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 15 May 2010 20:50:39 +0200
Subject: [Zcplusplus-commits] r432 - in trunk: .
	tests/zcc/default/staticassert tests/zcc.in/default/staticassert
Message-ID: <201005151850.o4FIodkd006320@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-15 20:50:31 +0200 (Sat, 15 May 2010)
New Revision: 432

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
   trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
   trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp
   trunk/type_spec.hpp
Log:
make sizeof string literal work

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-14 23:57:44 UTC (rev 431)
+++ trunk/CSupport.cpp	2010-05-15 18:50:31 UTC (rev 432)
@@ -3112,8 +3112,7 @@
 /* XXX this may belong with parse_tree XXX */
 static void simple_error(parse_tree& src, const char* const err_str)
 {
-	assert(NULL!=err_str);
-	assert('\0'!=err_str[0]);
+	assert(err_str && *err_str);
 	if (!(parse_tree::INVALID & src.flags))
 		{
 		src.flags |= parse_tree::INVALID;
@@ -6215,61 +6214,30 @@
 	return false;
 }
 
-//! \throw std::bad_alloc()
-static bool eval_sizeof_core_type(parse_tree& src,const size_t base_type_index,const type_system& types)
+static size_t _eval_sizeof_core_type(const size_t base_type_index)
 {	//! \todo eventually handle the floating and complex types here as well
-	//! \todo types parameter is close to redundant
 	// floating is just a matter of modeling
 	// complex may also involve ABI issues (cf. Intel)
-	const size_t size_t_type = unsigned_type_from_machine_type(target_machine->size_t_type());
-	parse_tree tmp;
 	switch(base_type_index)
 	{
-	default: return false;
+	default: return 0;
 	case C_TYPE::CHAR:
 	case C_TYPE::SCHAR:
 	case C_TYPE::UCHAR:
-		{	// defined to be 1: C99 6.5.3.4p3, C++98 5.3.3p1, same paragraphs in C1X and C++0X 
-		src.destroy();
-		src.index_tokens[0].token.first = "1U";
-		src.index_tokens[0].token.second = 2;
-		src.index_tokens[0].flags = (C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_INTEGER | C_TESTFLAG_DECIMAL);
-		src.type_code.set_type(size_t_type);
-		src.flags |= (PARSE_PRIMARY_EXPRESSION | parse_tree::CONSTANT_EXPRESSION);
-		break;
-		}
+		// defined to be 1: C99 6.5.3.4p3, C++98 5.3.3p1, same paragraphs in C1X and C++0X
+		return 1;
 	case C_TYPE::SHRT:
 	case C_TYPE::USHRT:
-		{
-		src.type_code.set_type(size_t_type);
-		uint_to_literal(tmp,target_machine->C_sizeof_short(),src,types);
-		tmp.MoveInto(src);
-		break;
-		}
+		return target_machine->C_sizeof_short();
 	case C_TYPE::INT:
 	case C_TYPE::UINT:
-		{
-		src.type_code.set_type(size_t_type);
-		uint_to_literal(tmp,target_machine->C_sizeof_int(),src,types);
-		tmp.MoveInto(src);
-		break;
-		}
+		return target_machine->C_sizeof_int();
 	case C_TYPE::LONG:
 	case C_TYPE::ULONG:
-		{
-		src.type_code.set_type(size_t_type);
-		uint_to_literal(tmp,target_machine->C_sizeof_long(),src,types);
-		tmp.MoveInto(src);
-		break;
-		}
+		return target_machine->C_sizeof_long();
 	case C_TYPE::LLONG:
 	case C_TYPE::ULLONG:
-		{
-		src.type_code.set_type(size_t_type);
-		uint_to_literal(tmp,target_machine->C_sizeof_long_long(),src,types);
-		tmp.MoveInto(src);
-//		break;
-		}
+		return target_machine->C_sizeof_long_long();
 	}
 #if 0
 	FLOAT,
@@ -6279,93 +6247,160 @@
 	DOUBLE__COMPLEX,
 	LDOUBLE__COMPLEX,
 #endif
-	assert(size_t_type==src.type_code.base_type_index);
-	return true;
 }
 
 //! \throw std::bad_alloc()
-static bool eval_C99_CPP_sizeof(parse_tree& src,const type_system& types)
-{
-	assert(is_C99_CPP_sizeof_expression(src));
-	if (0==src.data<2>()->type_code.pointer_power)
+static bool eval_sizeof_core_type(parse_tree& src,const size_t base_type_index,const type_system& types)
+{	//! \todo eventually handle the floating and complex types here as well
+	//! \todo types parameter is close to redundant
+	// floating is just a matter of modeling
+	// complex may also involve ABI issues (cf. Intel)
+	const size_t fundamental_size = _eval_sizeof_core_type(base_type_index);
+	if (0<fundamental_size)
 		{
-		if (eval_sizeof_core_type(src,src.data<2>()->type_code.base_type_index,types)) return true;
-		}
-	else if (!(type_spec::_array & src.type_code.qualifier<0>()))
-		{	// data or function pointer...fine
-			//! \bug need test cases
+		parse_tree tmp;
 		const size_t size_t_type = unsigned_type_from_machine_type(target_machine->size_t_type());
-		parse_tree tmp;
 		src.type_code.set_type(size_t_type);
-		//! \todo eventually, need to check for data vs function pointer when pointer_power is 1
-		uint_to_literal(tmp,target_machine->C_sizeof_data_ptr(),src,types);
+		uint_to_literal(tmp,fundamental_size,src,types);
 		tmp.MoveInto(src);
 		assert(size_t_type==src.type_code.base_type_index);
 		return true;
 		}
-	// actual array of something
 	return false;
 }
 
 //! \throw std::bad_alloc()
-static bool eval_C99_sizeof(parse_tree& src,const type_system& types)
+static bool eval_C99_CPP_sizeof(parse_tree& src,const type_system& types, func_traits<size_t (*)(parse_tree&,const type_system&)>::function_ref_type failover_sizeof)
 {
 	assert(is_C99_CPP_sizeof_expression(src));
-	if (eval_C99_CPP_sizeof(src,types)) return true;
-	if (0==src.data<2>()->type_code.pointer_power)
+	//! \todo error if given a function type
+	//! \todo handle function pointers distinctly from data pointers
+	const size_t size_t_type = unsigned_type_from_machine_type(target_machine->size_t_type());
+	size_t i = src.data<2>()->type_code.pointer_power;
+	if (0==i) return eval_sizeof_core_type(src,src.data<2>()->type_code.base_type_index,types);
+	{
+	umaxint scaling(1,target_machine->unsigned_max(target_machine->size_t_type()).size());
+	{
+	umaxint tmp2(target_machine->unsigned_max(target_machine->size_t_type()));
+	const umaxint target_size_max(tmp2);
+	umaxint tmp;
+	bool want_fundamental = true;
+	do  {
+		--i;
+		if (type_spec::_array & src.type_code.qualifier(i))
+			{
+			if (0>=src.type_code.extent_vector[i])
+				// C99 variable-length array: can't sizeof it at compile time
+				return false;
+			tmp = src.type_code.extent_vector[i];
+			}
+		else{	// data pointer (for now); 0==i actually could be function pointer
+			tmp = _eval_sizeof_core_type(unsigned_type_from_machine_type(target_machine->size_t_type()));
+			assert(0<tmp);
+			want_fundamental = false;
+			}
+		if (1<tmp)
+			{
+			tmp2 /= scaling;
+			if (tmp2<tmp)
+				{
+				simple_error(src," sizeof operator evaluation failed: object is larger than target SIZE_MAX bytes.");
+				return false;
+				}
+			tmp2 = target_size_max;
+			scaling *= tmp;
+			}
+		}
+	while(0<i && want_fundamental);
+	if (want_fundamental)
 		{
-		const enum_def* const tmp = types.get_enum_def(src.data<2>()->type_code.base_type_index);
-		if (tmp)
+		tmp = _eval_sizeof_core_type(src.data<2>()->type_code.base_type_index);
+		if (0==tmp) tmp = failover_sizeof(src,types);
+		if (0==tmp) return false;
+		else if (1<tmp)
 			{
-			if (is_noticed_enumerator(src,types))
-				return eval_sizeof_core_type(src,C_TYPE::INT,types); // type is int per C99 6.7.2.2p3
-			if (!tmp->represent_as)
+			tmp2 /= scaling;
+			if (tmp2<tmp)
 				{
-				simple_error(src," applies sizeof to incomplete enumeration (C99 6.5.3.4p1)");
+				simple_error(src," sizeof operator evaluation failed: object is larger than target SIZE_MAX bytes.");
 				return false;
 				}
-			// process tmp->represent_as as a core type
-			// C99 6.7.2.2p4 merely requires the underlying type to be able to represent all values
-			assert(C_TYPE::CHAR<=tmp->represent_as && C_TYPE::INT>=tmp->represent_as);
-			return eval_sizeof_core_type(src,tmp->represent_as,types);
+			scaling *= tmp;
 			}
+		//! \todo handle struct, union, class here (or maybe as part of core type wrapper)
+		// enum is post-processed due to differences between C, C++
 		}
-	return false;
+	}
+	parse_tree tmp3;
+	src.type_code.set_type(size_t_type);
+	VM_to_literal(tmp3,scaling,src,types);
+	tmp3.MoveInto(src);
+	}
+	assert(size_t_type==src.type_code.base_type_index);
+	return true;
 }
 
+static size_t _C99_failover_sizeof(parse_tree& src,const type_system& types)
+{
+	const enum_def* const tmp = types.get_enum_def(src.data<2>()->type_code.base_type_index);
+	if (tmp)
+		{
+		if (0==src.data<2>()->type_code.pointer_power && is_noticed_enumerator(src,types))
+			return _eval_sizeof_core_type(C_TYPE::INT); // type is int per C99 6.7.2.2p3
+		if (!tmp->represent_as)
+			{
+			simple_error(src," applies sizeof to incomplete enumeration (C99 6.5.3.4p1)");
+			return false;
+			}
+		// process tmp->represent_as as a core type
+		// C99 6.7.2.2p4 merely requires the underlying type to be able to represent all values
+		assert(C_TYPE::CHAR<=tmp->represent_as && C_TYPE::INT>=tmp->represent_as);
+		return _eval_sizeof_core_type(tmp->represent_as);
+		}
+	return 0;
+}
+
 //! \throw std::bad_alloc()
-static bool eval_CPP_sizeof(parse_tree& src,const type_system& types)
+static bool eval_C99_sizeof(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_CPP_sizeof_expression(src));
-	if (eval_C99_CPP_sizeof(src,types)) return true;
-	if (0==src.data<2>()->type_code.pointer_power)
+	return eval_C99_CPP_sizeof(src,types,_C99_failover_sizeof);
+}
+
+static size_t _CPP_failover_sizeof(parse_tree& src,const type_system& types)
+{
+	if (C_TYPE::WCHAR_T==src.data<2>()->type_code.base_type_index)
+		return _eval_sizeof_core_type(unsigned_type_from_machine_type(target_machine->UNICODE_wchar_t()));
+	const enum_def* const tmp = types.get_enum_def(src.data<2>()->type_code.base_type_index);
+	if (tmp)
 		{
-		if (C_TYPE::WCHAR_T==src.data<2>()->type_code.base_type_index)
-			return eval_sizeof_core_type(src,unsigned_type_from_machine_type(target_machine->UNICODE_wchar_t()),types);
-		const enum_def* const tmp = types.get_enum_def(src.data<2>()->type_code.base_type_index);
-		if (tmp)
+		if (0==src.data<2>()->type_code.pointer_power && is_noticed_enumerator(*src.data<2>(),types))
 			{
-			if (is_noticed_enumerator(*src.data<2>(),types))
-				{
-				const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.data<2>()->index_tokens[0].token.first);
-				assert(tmp2);
-				assert(C_TYPE::INT<=tmp2->second.first.second && C_TYPE::ULLONG>=tmp2->second.first.second);
-				return eval_sizeof_core_type(src,tmp2->second.first.second,types);
-				}
-			if (!tmp->represent_as)
-				{
-				simple_error(src," applies sizeof to incomplete enumeration (C++98 5.3.3p1)");
-				return false;
-				}
-			// C++0X 7.2p6 merely requires the underlying type to be able to represent all values
-			assert(C_TYPE::CHAR<=tmp->represent_as && C_TYPE::ULLONG>=tmp->represent_as);
-			return eval_sizeof_core_type(src,tmp->represent_as,types);
+			const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.data<2>()->index_tokens[0].token.first);
+			assert(tmp2);
+			assert(C_TYPE::INT<=tmp2->second.first.second && C_TYPE::ULLONG>=tmp2->second.first.second);
+			return _eval_sizeof_core_type(tmp2->second.first.second);
 			}
+		if (!tmp->represent_as)
+			{
+			simple_error(src," applies sizeof to incomplete enumeration (C++98 5.3.3p1)");
+			return false;
+			}
+		// C++0X 7.2p6 merely requires the underlying type to be able to represent all values
+		assert(C_TYPE::CHAR<=tmp->represent_as && C_TYPE::ULLONG>=tmp->represent_as);
+		return _eval_sizeof_core_type(tmp->represent_as);
 		}
-	return false;
+	return 0;
 }
 
 //! \throw std::bad_alloc()
+static bool eval_CPP_sizeof(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_CPP_sizeof_expression(src));
+	return eval_C99_CPP_sizeof(src,types,_CPP_failover_sizeof);
+}
+
+//! \throw std::bad_alloc()
 static void C99_sizeof_easy_syntax_check(parse_tree& src,const type_system& types)
 {
 	assert(is_C99_CPP_sizeof_expression(src));

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-14 23:57:44 UTC (rev 431)
+++ trunk/CSupport_pp.cpp	2010-05-15 18:50:31 UTC (rev 432)
@@ -3020,8 +3020,7 @@
 /* XXX this may belong with parse_tree XXX */
 static void simple_error(parse_tree& src, const char* const err_str)
 {
-	assert(NULL!=err_str);
-	assert('\0'!=err_str[0]);
+	assert(err_str && *err_str);
 	if (!(parse_tree::INVALID & src.flags))
 		{
 		src.flags |= parse_tree::INVALID;

Modified: trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2010-05-14 23:57:44 UTC (rev 431)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2010-05-15 18:50:31 UTC (rev 432)
@@ -9,6 +9,7 @@
 _Static_Assert(+"A"[0],"automatic success has failed");
 _Static_Assert(-"A"[0],"automatic success has failed");
 _Static_Assert(!"A"[1],"automatic success has failed");
+_Static_Assert(*"A","automatic success has failed");
 
 _Static_Assert("A"+0,"automatic success has failed");
 _Static_Assert(0+"A","automatic success has failed");
@@ -22,4 +23,7 @@
 _Static_Assert("A"!=0,"automatic success has failed");
 _Static_Assert(0!="B","automatic success has failed");
 
-
+_Static_Assert(1==sizeof "","automatic success has failed");
+_Static_Assert(sizeof ""==1,"automatic success has failed");
+_Static_Assert(2==sizeof "A","automatic success has failed");
+_Static_Assert(sizeof "A"==2,"automatic success has failed");

Modified: trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp	2010-05-14 23:57:44 UTC (rev 431)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp	2010-05-15 18:50:31 UTC (rev 432)
@@ -9,6 +9,7 @@
 static_assert(+"A"[0],"automatic success has failed");
 static_assert(-"A"[0],"automatic success has failed");
 static_assert(!"A"[1],"automatic success has failed");
+static_assert(*"A","automatic success has failed");
 
 static_assert("A"+0,"automatic success has failed");
 static_assert(0+"A","automatic success has failed");
@@ -22,4 +23,7 @@
 static_assert("A"!=0,"automatic success has failed");
 static_assert(0!="B","automatic success has failed");
 
-
+static_assert(1==sizeof "","automatic success has failed");
+static_assert(sizeof ""==1,"automatic success has failed");
+static_assert(2==sizeof "A","automatic success has failed");
+static_assert(sizeof "A"==2,"automatic success has failed");

Modified: trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2010-05-14 23:57:44 UTC (rev 431)
+++ trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2010-05-15 18:50:31 UTC (rev 432)
@@ -10,6 +10,7 @@
 STATIC_ASSERT(+"A"[0],"automatic success has failed");
 STATIC_ASSERT(-"A"[0],"automatic success has failed");
 STATIC_ASSERT(!"A"[1],"automatic success has failed");
+STATIC_ASSERT(*"A","automatic success has failed");
 
 STATIC_ASSERT("A"+0,"automatic success has failed");
 STATIC_ASSERT(0+"A","automatic success has failed");
@@ -23,4 +24,7 @@
 STATIC_ASSERT("A"!=0,"automatic success has failed");
 STATIC_ASSERT(0!="B","automatic success has failed");
 
-
+STATIC_ASSERT(1==sizeof "","automatic success has failed");
+STATIC_ASSERT(sizeof ""==1,"automatic success has failed");
+STATIC_ASSERT(2==sizeof "A","automatic success has failed");
+STATIC_ASSERT(sizeof "A"==2,"automatic success has failed");

Modified: trunk/type_spec.hpp
===================================================================
--- trunk/type_spec.hpp	2010-05-14 23:57:44 UTC (rev 431)
+++ trunk/type_spec.hpp	2010-05-15 18:50:31 UTC (rev 432)
@@ -52,7 +52,9 @@
 	bool dereference();
 	bool dereference(type_spec& dest) const;
 	unsigned char& qualifier(size_t i) {return q_vector.c_array()[i];};
+	unsigned char qualifier(size_t i) const {return q_vector.data()[i];};
 	template<size_t i> unsigned char& qualifier() {return q_vector.c_array()[i];}
+	template<size_t i> unsigned char qualifier() const {return q_vector.data()[i];}
 
 	void clear();	// XXX should be constructor; good way to leak memory in other contexts
 	void destroy();	// XXX should be destructor



From zaimoni at mail.berlios.de  Sat May 15 22:48:45 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 15 May 2010 22:48:45 +0200
Subject: [Zcplusplus-commits] r433 - in trunk: .
	tests/zcc/default/staticassert tests/zcc.in/default/staticassert
Message-ID: <201005152048.o4FKmjIA016371@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-15 22:48:37 +0200 (Sat, 15 May 2010)
New Revision: 433

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
   trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
   trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp
Log:
handle unary * typing much like unary +- typing

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-15 18:50:31 UTC (rev 432)
+++ trunk/CSupport.cpp	2010-05-15 20:48:37 UTC (rev 433)
@@ -5665,6 +5665,22 @@
 		}
 }
 
+// this is going to have to be forked eventually; the CPP variant has to be more
+// careful with the *& identity as both deference * and reference & are 
+// overloadable operators
+//! \throw std::bad_alloc()
+static void C_deref_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_unary_operator_expression<'*'>(src));
+	//! \todo: handle *& identity when we have &
+	// multi-dimensional arrays and cv-qualified pointers should be automatically handled
+	value_copy(src.type_code,src.data<2>()->type_code);
+	// handle lvalueness in indirection type building and/or the dereference stage
+	if (!src.type_code.dereference())
+		//! \test default/Error_if_control24.hpp, default/Error_if_control24.h
+		simple_error(src," is not dereferencing a pointer (C99 6.5.3.2p2; C++98 5.3.1p1)");
+}
+
 // no eval_deref because of &* cancellation
 // defer syntax check to after resolution of multiply-*, so no C/C++ fork
 //! \throw std::bad_alloc()
@@ -5681,6 +5697,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_DEREF);
@@ -5705,6 +5723,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_DEREF);
@@ -5716,19 +5736,6 @@
 }
 
 //! \throw std::bad_alloc()
-static void C_deref_easy_syntax_check(parse_tree& src,const type_system& types)
-{
-	assert(is_C99_unary_operator_expression<'*'>(src));
-	//! \todo: handle *& identity when we have &
-	// multi-dimensional arrays and cv-qualified pointers should be automatically handled
-	value_copy(src.type_code,src.data<2>()->type_code);
-	// handle lvalueness in indirection type building and/or the dereference stage
-	if (!src.type_code.dereference())
-		//! \test default/Error_if_control24.hpp, default/Error_if_control24.h
-		simple_error(src," is not dereferencing a pointer (C99 6.5.3.2p2; C++98 5.3.1p1)");
-}
-
-//! \throw std::bad_alloc()
 static bool terse_locate_C_logical_NOT(parse_tree& src, size_t& i,const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5742,6 +5749,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_NOT);
@@ -5766,6 +5775,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_NOT);
@@ -5908,6 +5919,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_COMPL);
@@ -5932,6 +5945,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_COMPL);
@@ -6120,6 +6135,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,unary_subtype);
@@ -6149,6 +6166,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,unary_subtype);
@@ -6202,6 +6221,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (   (PARSE_UNARY_EXPRESSION & src.data<0>()[i+1].flags)
 			|| (is_naked_parentheses_pair(src.data<0>()[i+1]) && (PARSE_TYPE & src.data<0>()[i+1].flags)))
 			{
@@ -6287,12 +6308,12 @@
 	bool want_fundamental = true;
 	do  {
 		--i;
-		if (type_spec::_array & src.type_code.qualifier(i))
+		if (type_spec::_array & src.data<2>()->type_code.qualifier(i+1))
 			{
-			if (0>=src.type_code.extent_vector[i])
+			if (0>=src.data<2>()->type_code.extent_vector[i])
 				// C99 variable-length array: can't sizeof it at compile time
 				return false;
-			tmp = src.type_code.extent_vector[i];
+			tmp = src.data<2>()->type_code.extent_vector[i];
 			}
 		else{	// data pointer (for now); 0==i actually could be function pointer
 			tmp = _eval_sizeof_core_type(unsigned_type_from_machine_type(target_machine->size_t_type()));

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-15 18:50:31 UTC (rev 432)
+++ trunk/CSupport_pp.cpp	2010-05-15 20:48:37 UTC (rev 433)
@@ -5120,6 +5120,22 @@
 		}
 }
 
+// this is going to have to be forked eventually; the CPP variant has to be more
+// careful with the *& identity as both deference * and reference & are 
+// overloadable operators
+//! \throw std::bad_alloc()
+static void C_deref_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_unary_operator_expression<'*'>(src));
+	//! \todo: handle *& identity when we have &
+	// multi-dimensional arrays and cv-qualified pointers should be automatically handled
+	value_copy(src.type_code,src.data<2>()->type_code);
+	// handle lvalueness in indirection type building and/or the dereference stage
+	if (!src.type_code.dereference())
+		//! \test default/Error_if_control24.hpp, default/Error_if_control24.h
+		simple_error(src," is not dereferencing a pointer (C99 6.5.3.2p2; C++98 5.3.1p1)");
+}
+
 // no eval_deref because of &* cancellation
 // defer syntax check to after resolution of multiply-*, so no C/C++ fork
 //! \throw std::bad_alloc()
@@ -5136,6 +5152,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_DEREF);
@@ -5160,6 +5178,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_DEREF);
@@ -5171,19 +5191,6 @@
 }
 
 //! \throw std::bad_alloc()
-static void C_deref_easy_syntax_check(parse_tree& src,const type_system& types)
-{
-	assert(is_C99_unary_operator_expression<'*'>(src));
-	//! \todo: handle *& identity when we have &
-	// multi-dimensional arrays and cv-qualified pointers should be automatically handled
-	value_copy(src.type_code,src.data<2>()->type_code);
-	// handle lvalueness in indirection type building and/or the dereference stage
-	if (!src.type_code.dereference())
-		//! \test default/Error_if_control24.hpp, default/Error_if_control24.h
-		simple_error(src," is not dereferencing a pointer (C99 6.5.3.2p2; C++98 5.3.1p1)");
-}
-
-//! \throw std::bad_alloc()
 static bool terse_locate_C_logical_NOT(parse_tree& src, size_t& i,const type_system& types)
 {
 	assert(!src.empty<0>());
@@ -5197,6 +5204,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_NOT);
@@ -5221,6 +5230,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_NOT);
@@ -5363,6 +5374,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_COMPL);
@@ -5387,6 +5400,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_COMPL);
@@ -5568,6 +5583,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,unary_subtype);
@@ -5597,6 +5614,8 @@
 		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
 		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
 			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
 		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
 			{
 			assemble_unary_postfix_arguments(src,i,unary_subtype);

Modified: trunk/tests/zcc/default/staticassert/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2010-05-15 18:50:31 UTC (rev 432)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess.h	2010-05-15 20:48:37 UTC (rev 433)
@@ -10,6 +10,7 @@
 _Static_Assert(-"A"[0],"automatic success has failed");
 _Static_Assert(!"A"[1],"automatic success has failed");
 _Static_Assert(*"A","automatic success has failed");
+_Static_Assert(!*"","automatic success has failed");
 
 _Static_Assert("A"+0,"automatic success has failed");
 _Static_Assert(0+"A","automatic success has failed");
@@ -27,3 +28,9 @@
 _Static_Assert(sizeof ""==1,"automatic success has failed");
 _Static_Assert(2==sizeof "A","automatic success has failed");
 _Static_Assert(sizeof "A"==2,"automatic success has failed");
+
+_Static_Assert(1==sizeof *"A","automatic success has failed");
+_Static_Assert(sizeof *"A"==1,"automatic success has failed");
+_Static_Assert(1==sizeof *"","automatic success has failed");
+_Static_Assert(sizeof *""==1,"automatic success has failed");
+

Modified: trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp	2010-05-15 18:50:31 UTC (rev 432)
+++ trunk/tests/zcc/default/staticassert/Pass_autosuccess.hpp	2010-05-15 20:48:37 UTC (rev 433)
@@ -10,6 +10,7 @@
 static_assert(-"A"[0],"automatic success has failed");
 static_assert(!"A"[1],"automatic success has failed");
 static_assert(*"A","automatic success has failed");
+static_assert(!*"","automatic success has failed");
 
 static_assert("A"+0,"automatic success has failed");
 static_assert(0+"A","automatic success has failed");
@@ -27,3 +28,9 @@
 static_assert(sizeof ""==1,"automatic success has failed");
 static_assert(2==sizeof "A","automatic success has failed");
 static_assert(sizeof "A"==2,"automatic success has failed");
+
+static_assert(1==sizeof *"A","automatic success has failed");
+static_assert(sizeof *"A"==1,"automatic success has failed");
+static_assert(1==sizeof *"","automatic success has failed");
+static_assert(sizeof *""==1,"automatic success has failed");
+

Modified: trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in
===================================================================
--- trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2010-05-15 18:50:31 UTC (rev 432)
+++ trunk/tests/zcc.in/default/staticassert/Pass_autosuccess.in	2010-05-15 20:48:37 UTC (rev 433)
@@ -11,6 +11,7 @@
 STATIC_ASSERT(-"A"[0],"automatic success has failed");
 STATIC_ASSERT(!"A"[1],"automatic success has failed");
 STATIC_ASSERT(*"A","automatic success has failed");
+STATIC_ASSERT(!*"","automatic success has failed");
 
 STATIC_ASSERT("A"+0,"automatic success has failed");
 STATIC_ASSERT(0+"A","automatic success has failed");
@@ -28,3 +29,9 @@
 STATIC_ASSERT(sizeof ""==1,"automatic success has failed");
 STATIC_ASSERT(2==sizeof "A","automatic success has failed");
 STATIC_ASSERT(sizeof "A"==2,"automatic success has failed");
+
+STATIC_ASSERT(1==sizeof *"A","automatic success has failed");
+STATIC_ASSERT(sizeof *"A"==1,"automatic success has failed");
+STATIC_ASSERT(1==sizeof *"","automatic success has failed");
+STATIC_ASSERT(sizeof *""==1,"automatic success has failed");
+



From zaimoni at mail.berlios.de  Sun May 16 11:02:43 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 16 May 2010 11:02:43 +0200
Subject: [Zcplusplus-commits] r434 - trunk
Message-ID: <201005160902.o4G92hSa015180@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-16 11:02:40 +0200 (Sun, 16 May 2010)
New Revision: 434

Modified:
   trunk/ZParser.cpp
Log:
RAM conservation fix

Modified: trunk/ZParser.cpp
===================================================================
--- trunk/ZParser.cpp	2010-05-15 20:48:37 UTC (rev 433)
+++ trunk/ZParser.cpp	2010-05-16 09:02:40 UTC (rev 434)
@@ -116,15 +116,15 @@
 					const char* tmp = (C_TESTFLAG_IDENTIFIER==pretokenized[0].third ? lang.pp_support->EchoReservedKeyword(TokenList.front()->data()+pretokenized[i].first,pretokenized[0].second) : NULL);
 					if (tmp)
 						{
-						ParsedList[0]->c_array<0>()[old_parsed_size].index_tokens[0].token.first = tmp;
-						ParsedList[0]->c_array<0>()[old_parsed_size].control_index_token<0>(false);
+						ParsedList[0]->c_array<0>()[old_parsed_size+i].index_tokens[0].token.first = tmp;
+						ParsedList[0]->c_array<0>()[old_parsed_size+i].control_index_token<0>(false);
 						}
 					else{
 						tmp = (C_TESTFLAG_PP_OP_PUNC & pretokenized[0].third ? lang.pp_support->EchoReservedSymbol(TokenList.front()->data()+pretokenized[i].first,pretokenized[0].second) : NULL);
 						if (tmp)
 							{
-							ParsedList[0]->c_array<0>()[old_parsed_size].index_tokens[0].token.first = tmp;
-							ParsedList[0]->c_array<0>()[old_parsed_size].control_index_token<0>(false);
+							ParsedList[0]->c_array<0>()[old_parsed_size+i].index_tokens[0].token.first = tmp;
+							ParsedList[0]->c_array<0>()[old_parsed_size+i].control_index_token<0>(false);
 							}
 						else{
 							char* tmp2 = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(pretokenized[i].second));



From zaimoni at mail.berlios.de  Sun May 16 12:08:24 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 16 May 2010 12:08:24 +0200
Subject: [Zcplusplus-commits] r435 - trunk
Message-ID: <201005161008.o4GA8Our019163@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-16 12:08:21 +0200 (Sun, 16 May 2010)
New Revision: 435

Modified:
   trunk/ZParser.cpp
Log:
object file size reduction

Modified: trunk/ZParser.cpp
===================================================================
--- trunk/ZParser.cpp	2010-05-16 09:02:40 UTC (rev 434)
+++ trunk/ZParser.cpp	2010-05-16 10:08:21 UTC (rev 435)
@@ -26,13 +26,39 @@
 {
 }
 
+/**
+ * As the memory management situation varies when 
+ * dest.index_tokens[0].token.first is to be owned...
+ *
+ * \return false iff caller needs to handle memory management for an owned token 
+ */
+static bool init_parse_tree_from_token(parse_tree& dest, const Token<char>& tmp_front, const POD_triple<size_t,size_t,lex_flags>& src2, const zaimoni::LangConf& lang)
+{
+	dest.index_tokens[0].token.second = src2.second;
+	dest.index_tokens[0].logical_line.first = tmp_front.original_line.first;
+	dest.index_tokens[0].logical_line.second = tmp_front.original_line.second;
+	dest.index_tokens[0].flags = src2.third;
+	dest.index_tokens[0].src_filename = tmp_front.src_filename;
+	const char* const tmp = C_TESTFLAG_IDENTIFIER==src2.third ? lang.pp_support->EchoReservedKeyword(tmp_front.data(),src2.second) 
+						: C_TESTFLAG_PP_OP_PUNC & src2.third ? lang.pp_support->EchoReservedSymbol(tmp_front.data(),src2.second) : NULL;
+	if (tmp)
+		{
+		dest.index_tokens[0].token.first = tmp;
+		dest.control_index_token<0>(false);
+		}
+	return tmp;
+}
+
 bool ZParser::parse(autovalarray_ptr<Token<char>*>& TokenList,autovalarray_ptr<parse_tree*>& ParsedList)
 {
 	// first stage: rearrange to be suitable for LangConf
 	if (TokenList.empty()) return false;	// no-op, nothing to export to object file
+	{
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
 	do	{
-		lang.line_lex(TokenList.front()->data(), TokenList.front()->size(), pretokenized);
+		assert(TokenList.front());
+		Token<char>& tmp_front = *TokenList.front();
+		lang.line_lex(tmp_front.data(), tmp_front.size(), pretokenized);
 		if (!pretokenized.empty())
 			{	// ...
 			const size_t append_tokens = pretokenized.size();
@@ -55,18 +81,18 @@
 				// disable pedantic warnings to avoid fake warnings about string literals
 				const bool pedantic_backup = bool_options[boolopt::pedantic];
 				bool_options[boolopt::pedantic] = false;
-				lang.pp_support->AddPostLexFlags(TokenList.front()->data()+pretokenized[i].first, pretokenized[i].second, pretokenized[i].third, TokenList.front()->src_filename, TokenList.front()->original_line.first);
+				lang.pp_support->AddPostLexFlags(tmp_front.data()+pretokenized[i].first, pretokenized[i].second, pretokenized[i].third, tmp_front.src_filename, tmp_front.original_line.first);
 				bool_options[boolopt::pedantic] = pedantic_backup;
 				if (	(C_TESTFLAG_PP_OP_PUNC & pretokenized[i].third)
 					&& 	(C_DISALLOW_POSTPROCESSED_SOURCE & lang.pp_support->GetPPOpPuncFlags(C_PP_DECODE(pretokenized[i].third))))
 					{
-					INC_INFORM(TokenList.front()->src_filename);
+					INC_INFORM(tmp_front.src_filename);
 					INC_INFORM(':');
-					INC_INFORM(TokenList.front()->original_line.first);
+					INC_INFORM(tmp_front.original_line.first);
 					INC_INFORM(": ");
 					INC_INFORM(ERR_STR);
 					INC_INFORM("Forbidden token ");
-					INC_INFORM(TokenList.front()->data()+pretokenized[i].first, pretokenized[i].second);
+					INC_INFORM(tmp_front.data()+pretokenized[i].first, pretokenized[i].second);
 					INFORM(" in postprocessed source.");
 					zcc_errors.inc_error();
 					};
@@ -75,64 +101,29 @@
 
 			if (1==append_tokens)
 				{	// only one token: grab the memory from Token and just do it
-				TokenList.front()->ltrim(pretokenized[0].first);
-				TokenList.front()->lslice(pretokenized[0].second);
-				ParsedList[0]->c_array<0>()[old_parsed_size].index_tokens[0].token.second = pretokenized[0].second;
-				ParsedList[0]->c_array<0>()[old_parsed_size].index_tokens[0].logical_line.first = TokenList.front()->original_line.first;
-				ParsedList[0]->c_array<0>()[old_parsed_size].index_tokens[0].logical_line.second = TokenList.front()->original_line.second;
-				ParsedList[0]->c_array<0>()[old_parsed_size].index_tokens[0].flags = pretokenized[0].third;
-				ParsedList[0]->c_array<0>()[old_parsed_size].index_tokens[0].src_filename = TokenList.front()->src_filename;
-				const char* tmp = (C_TESTFLAG_IDENTIFIER==pretokenized[0].third ? lang.pp_support->EchoReservedKeyword(TokenList.front()->data(),pretokenized[0].second) : NULL);
-				if (tmp)
+				tmp_front.ltrim(pretokenized[0].first);
+				tmp_front.lslice(pretokenized[0].second);
+				parse_tree& tmp = ParsedList[0]->c_array<0>()[old_parsed_size];
+				if (!init_parse_tree_from_token(tmp,tmp_front,pretokenized[0],lang))
 					{
-					ParsedList[0]->c_array<0>()[old_parsed_size].index_tokens[0].token.first = tmp;
-					ParsedList[0]->c_array<0>()[old_parsed_size].control_index_token<0>(false);
+					char* tmp2 = NULL; //! \bug adjust API, should be able to add qualifications safely
+					tmp_front.TransferOutAndNULL(tmp2);
+					tmp.index_tokens[0].token.first = tmp2;
+					tmp.control_index_token<0>(true);
 					}
-				else{
-					tmp = (C_TESTFLAG_PP_OP_PUNC & pretokenized[0].third ? lang.pp_support->EchoReservedSymbol(TokenList.front()->data(),pretokenized[0].second) : NULL);
-					if (tmp)
-						{
-						ParsedList[0]->c_array<0>()[old_parsed_size].index_tokens[0].token.first = tmp;
-						ParsedList[0]->c_array<0>()[old_parsed_size].control_index_token<0>(false);
-						}
-					else{
-						char* tmp2 = NULL; //! \bug adjust API, should be able to add qualifications safely
-						TokenList.front()->TransferOutAndNULL(tmp2);
-						ParsedList[0]->c_array<0>()[old_parsed_size].index_tokens[0].token.first = tmp2;
-						ParsedList[0]->c_array<0>()[old_parsed_size].control_index_token<0>(true);
-						}
-					}
 				}
 			else{
 				i = append_tokens;
 				do	{	// copy it
-					--i;
-					ParsedList[0]->c_array<0>()[old_parsed_size+i].index_tokens[0].token.second = pretokenized[i].second;
-					ParsedList[0]->c_array<0>()[old_parsed_size+i].index_tokens[0].logical_line.first = TokenList.front()->original_line.first;
-					ParsedList[0]->c_array<0>()[old_parsed_size+i].index_tokens[0].logical_line.second = TokenList.front()->original_line.second;
-					ParsedList[0]->c_array<0>()[old_parsed_size+i].index_tokens[0].logical_line.second += pretokenized[i].first;
-					ParsedList[0]->c_array<0>()[old_parsed_size+i].index_tokens[0].flags = pretokenized[i].third;
-					ParsedList[0]->c_array<0>()[old_parsed_size+i].index_tokens[0].src_filename = TokenList.front()->src_filename;
-					const char* tmp = (C_TESTFLAG_IDENTIFIER==pretokenized[0].third ? lang.pp_support->EchoReservedKeyword(TokenList.front()->data()+pretokenized[i].first,pretokenized[0].second) : NULL);
-					if (tmp)
-						{
-						ParsedList[0]->c_array<0>()[old_parsed_size+i].index_tokens[0].token.first = tmp;
-						ParsedList[0]->c_array<0>()[old_parsed_size+i].control_index_token<0>(false);
+					parse_tree& tmp = ParsedList[0]->c_array<0>()[old_parsed_size+ --i];
+					POD_triple<size_t,size_t,lex_flags>& tmp3 = pretokenized[i];
+					if (!init_parse_tree_from_token(tmp,tmp_front,tmp3,lang))
+					    {
+						char* tmp2 = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(tmp3.second));
+						memmove(tmp2,tmp_front.data()+tmp3.first,tmp3.second);
+						tmp.index_tokens[0].token.first = tmp2;
+						tmp.control_index_token<0>(true);
 						}
-					else{
-						tmp = (C_TESTFLAG_PP_OP_PUNC & pretokenized[0].third ? lang.pp_support->EchoReservedSymbol(TokenList.front()->data()+pretokenized[i].first,pretokenized[0].second) : NULL);
-						if (tmp)
-							{
-							ParsedList[0]->c_array<0>()[old_parsed_size+i].index_tokens[0].token.first = tmp;
-							ParsedList[0]->c_array<0>()[old_parsed_size+i].control_index_token<0>(false);
-							}
-						else{
-							char* tmp2 = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(pretokenized[i].second));
-							memmove(tmp2,TokenList.front()->data()+pretokenized[i].first,pretokenized[i].second);
-							ParsedList[0]->c_array<0>()[old_parsed_size+i].index_tokens[0].token.first = tmp2;
-							ParsedList[0]->c_array<0>()[old_parsed_size+i].control_index_token<0>(true);
-							}
-						}
 					}
 				while(0<i);
 				}
@@ -141,6 +132,7 @@
 		TokenList.DeleteIdx(0);
 		}
 	while(!TokenList.empty());
+	}
 	die_on_parse_errors();
 	if (ParsedList.empty()) return false;	// no-op, nothing to export to object file
 



From zaimoni at mail.berlios.de  Mon May 17 21:05:42 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 17 May 2010 21:05:42 +0200
Subject: [Zcplusplus-commits] r436 - in trunk: . lib lib/zc++-0.0.5
	lib/zc++-0.0.5/include
Message-ID: <201005171905.o4HJ5grV004363@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-17 21:05:30 +0200 (Mon, 17 May 2010)
New Revision: 436

Added:
   trunk/_CSupport3.hpp
   trunk/lib/zc++-0.0.5/
   trunk/lib/zc++-0.0.5/include/
   trunk/lib/zc++-0.0.5/include/typeinfo
Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc.hpp
   trunk/CPreproc_pp.cpp
   trunk/CPreproc_pp.hpp
   trunk/CSupport.cpp
   trunk/POSIX.dep
   trunk/ZParser.cpp
   trunk/ZParser.hpp
   trunk/_version.h
Log:
handle the syntax error aspect of typeid support

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2010-05-16 10:08:21 UTC (rev 435)
+++ trunk/CPreproc.cpp	2010-05-17 19:05:30 UTC (rev 436)
@@ -14,6 +14,7 @@
 #include "AtomicString.h"
 #/*cut-cpp*/
 #include "CSupport.hpp"
+#include "_CSupport3.hpp"
 #/*cut-cpp*/
 #include "CSupport_pp.hpp"
 #include "C_PPDecimalInteger.hpp"
@@ -348,9 +349,28 @@
 
 static const POD_pair<const char*,size_t> pragma_ZCC_keywords[]
 	=	{	DICT_STRUCT("lock"),
+			DICT_STRUCT("enable_typeid")
 		};
 
 #define PRAGMA_ZCC_LOCK 0
+#define PRAGMA_ZCC_ENABLE_TYPEID 1
+#/*cut-cpp*/
+
+const POD_pair<const char*,size_t> pragma_relay_keywords[]
+	=	{	DICT_STRUCT("_ZCC_FP_CONTRACT_OFF"),
+			DICT_STRUCT("_ZCC_FP_CONTRACT_DEFAULT"),
+			DICT_STRUCT("_ZCC_FP_CONTRACT_ON"),
+			DICT_STRUCT("_ZCC_FENV_ACCESS_OFF"),
+			DICT_STRUCT("_ZCC_FENV_ACCESS_DEFAULT"),
+			DICT_STRUCT("_ZCC_FENV_ACCESS_ON"),
+			DICT_STRUCT("_ZCC_CX_LIMITED_RANGE_OFF"),
+			DICT_STRUCT("_ZCC_CX_LIMITED_RANGE_DEFAULT"),
+			DICT_STRUCT("_ZCC_CX_LIMITED_RANGE_ON"),
+			DICT_STRUCT("_ZCC_enable_typeid")
+		};
+
+BOOST_STATIC_ASSERT(PRAGMA_RELAY_KEYWORDS_STRICT_UB==STATIC_SIZE(pragma_relay_keywords));		
+#/*cut-cpp*/
 #undef DICT_STRUCT
 
 static void _init_weak_token(weak_token& dest, const Token<char>& x,const POD_triple<size_t,size_t,lex_flags>& pretoken)
@@ -1402,12 +1422,26 @@
 					if (PP::PRAGMA==directive_type)
 						{
 						const size_t critical_offset = valid_directives[directive_type].second+2;
+#/*cut-cpp*/
+						const unsigned int pragma_code =
+#/*cut-cpp*/
 						interpret_pragma(TokenList[i]->data()+critical_offset,TokenList[i]->size()-critical_offset,locked_macros);
+#/*cut-cpp*/
+						switch(pragma_code)
+						{
+						default:
+#/*cut-cpp*/
 						TokenList.DeleteIdx(i);
 						if (0==i) goto Restart;
 						--i;
 						continue;
+#/*cut-cpp*/
+						case RELAY_ZCC_ENABLE_TYPEID:
+							TokenList[i]->replace_once(0,TokenList[i]->size(),pragma_relay_keywords[pragma_code].first,pragma_relay_keywords[pragma_code].second);
+							continue;
 						}
+#/*cut-cpp*/
+						}
 					}
 				}
 
@@ -1652,9 +1686,21 @@
 						{	//! \test Pass_pragma_STDC.hpp
 						autovalarray_ptr_throws<char> pragma_string(lang.UnescapeStringLength(TokenList[i+2]->data()+1,TokenList[i+2]->size()-2));
 						lang.UnescapeString(pragma_string.c_array(),TokenList[i+2]->data()+1,TokenList[i+2]->size()-2);
+#/*cut-cpp*/
+						const unsigned int pragma_code =
+#/*cut-cpp*/
 						interpret_pragma(pragma_string.data(),pragma_string.size(),locked_macros);
+#/*cut-cpp*/
+						switch(pragma_code)
+						{
+						case RELAY_ZCC_ENABLE_TYPEID:
+							TokenList[i]->replace_once(0,TokenList[i]->size(),pragma_relay_keywords[pragma_code].first,pragma_relay_keywords[pragma_code].second);
+							TokenList.DeleteNSlotsAt(3,i+1);
+							continue;
+						}
+#/*cut-cpp*/
 						};
-					TokenList.DeleteNSlotsAt(4,i);						//! \todo fix once we have code-generation affecting pragmas
+					TokenList.DeleteNSlotsAt(4,i);
 					if (0==i) goto Restart;
 					--i;
 					continue;
@@ -2129,10 +2175,9 @@
 	return false;
 }
 
-void
+unsigned int
 CPreprocessor::interpret_pragma(const char* const x, size_t x_len, autovalarray_ptr<char*>& locked_macros)
 {
-	//! \todo: fix return value situation when enabling code-generation affecting pragmas
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
 	lang.line_lex(x, x_len, pretokenized);
 
@@ -2141,9 +2186,21 @@
 		{
 		if (1<pretokenized.size())
 			{
+#/*cut-cpp*/
+			BOOST_STATIC_ASSERT(RELAY_ZCC_ENABLE_TYPEID==STATIC_SIZE(pragma_STDC_on_off_switch)*STATIC_SIZE(pragma_STDC_keywords));
+#/*cut-cpp*/
 			const errr ZCC_pragma =  linear_find_lencached(x+pretokenized[1].first, pretokenized[1].second, pragma_ZCC_keywords, STATIC_SIZE(pragma_ZCC_keywords));
 			switch(ZCC_pragma)
 			{
+#/*cut-cpp*/
+			// #pragma ZCC enable_typeid gets rewritten to the 
+			// reserved-to-the-implementation keyword 
+			// _ZCC_pragma_enable_typeid, which in turn turns off the syntax
+			// errors for typeid .  We use this convolution so that we don't
+			// instantly break other compilers inadvertently using our 
+			// #include <typeinfo>
+			case PRAGMA_ZCC_ENABLE_TYPEID: return STATIC_SIZE(pragma_STDC_on_off_switch)*STATIC_SIZE(pragma_STDC_keywords)+1;				
+#/*cut-cpp*/
 			case PRAGMA_ZCC_LOCK:
 				{	//! \test Error_undef_locked_macro.hpp
 				size_t j = pretokenized.size();
@@ -2161,7 +2218,7 @@
 				}
 			}
 			}
-		return;
+		return 0;
 		}
 	else if (PRAGMA_LEADING_STDC==valid_pragma_class)
 		{
@@ -2179,7 +2236,7 @@
 					INC_INFORM("unhandled STDC pragma ");
 					INFORM(pragma_STDC_keywords[STDC_pragma].first);
 					zcc_errors.inc_error();
-					return;
+					return 0;
 					};
 #endif
 				case PRAGMA_STDC_FP_CONTRACT:
@@ -2199,13 +2256,15 @@
 						INC_INFORM("invalid STDC pragma ");
 						INFORM(x,x_len);
 						zcc_errors.inc_error();
-						return;
+						return 0;
 						}
+					// valid STDC pragma: relay encoding out
+					return STATIC_SIZE(pragma_STDC_on_off_switch)*STDC_pragma+on_off_switch+1;
 					};
 				}
 			}
 			}
-		return;
+		return 0;
 		}
 	else if (PRAGMA_MESSAGE==valid_pragma_class)
 		{
@@ -2218,7 +2277,7 @@
 			const bool wide_str = 'L'==x[pretokenized[2].first];
 			if (0<std::count(x+pretokenized[2].first,x+pretokenized[2].first+pretokenized[2].second,'\\'))
 				{	// no escapes
-				if (wide_str) return; //! \todo this should do a proper unescape to UNICODE, then use a wrapper library to push the UNICODE to whatever wide-char support there is
+				if (wide_str) return 0; //! \todo this should do a proper unescape to UNICODE, then use a wrapper library to push the UNICODE to whatever wide-char support there is
 
 				//! \todo change target, this only handles target CHAR_BIT<=host CHAR_BIT
 				const size_t tmp_len = lang.UnescapeStringLength(x+pretokenized[2].first,pretokenized[2].second);
@@ -2228,7 +2287,7 @@
 					lang.UnescapeString(tmp,x+pretokenized[2].first,pretokenized[2].second);
 					INFORM(tmp,tmp_len);
 					_flush(tmp);
-					return;
+					return 0;
 					}
 				};
 			// no escapes, or formatting failed: do something
@@ -2237,8 +2296,9 @@
 			else
 				INFORM(x+pretokenized[2].first+1,pretokenized[2].second-2);
 			}
-		return;
+		return 0;
 		}
+	return 0;
 }
 
 static void _complete_string_character_literal(Token<char>& x,const char delim, const char* const end_error)
@@ -4239,13 +4299,17 @@
 bool
 CPreprocessor::hard_locked_macro(const char* const x,const size_t x_len) const
 {
-	assert(!is_empty_string(x));
+	assert(x && *x);
 	assert(0<x_len);
 // C99: 6.11.9 Predefined macro names
 // Macro names beginning with __STDC_ are reserved for future standardization.
 //! \test Error20.hpp : #undef __STDC__
 //! \bug should have positive test suite for named __STDC_ macros
 	if (7<=x_len && !strncmp(x,"__STDC_",sizeof("__STDC_")-1)) return true;
+#/*cut-cpp*/
+// Lock down our relay identifiers. to be safe
+	if (0<=linear_find_lencached(x,x_len,pragma_relay_keywords,STATIC_SIZE(pragma_relay_keywords))) return true;
+#/*cut-cpp*/
 // C++0x 17.4.3.2.2 simply prohibits all keywords as macros; prefer this to C++98.  C99/C0X is handled elsewhere, as it isn't so draconian.
 // follow C++0x when generalizing to non-standard languages, as that's more intuitive.
 //! \bug should have positive test suite for all supported C++ keywords

Modified: trunk/CPreproc.hpp
===================================================================
--- trunk/CPreproc.hpp	2010-05-16 10:08:21 UTC (rev 435)
+++ trunk/CPreproc.hpp	2010-05-17 19:05:30 UTC (rev 436)
@@ -105,7 +105,7 @@
 	void function_macro_concatenate_novars(zaimoni::Token<char>& x, const zaimoni::Token<char>& arglist);
 
 	// pragma support
-	void interpret_pragma(const char* const x, size_t x_len, zaimoni::autovalarray_ptr<char*>& locked_macros);
+	unsigned int interpret_pragma(const char* const x, size_t x_len, zaimoni::autovalarray_ptr<char*>& locked_macros);
 };
 
 #endif

Modified: trunk/CPreproc_pp.cpp
===================================================================
--- trunk/CPreproc_pp.cpp	2010-05-16 10:08:21 UTC (rev 435)
+++ trunk/CPreproc_pp.cpp	2010-05-17 19:05:30 UTC (rev 436)
@@ -342,9 +342,11 @@
 
 static const POD_pair<const char*,size_t> pragma_ZCC_keywords[]
 	=	{	DICT_STRUCT("lock"),
+			DICT_STRUCT("enable_typeid")
 		};
 
 #define PRAGMA_ZCC_LOCK 0
+#define PRAGMA_ZCC_ENABLE_TYPEID 1
 #undef DICT_STRUCT
 
 static void _init_weak_token(weak_token& dest, const Token<char>& x,const POD_triple<size_t,size_t,lex_flags>& pretoken)
@@ -1648,7 +1650,7 @@
 						lang.UnescapeString(pragma_string.c_array(),TokenList[i+2]->data()+1,TokenList[i+2]->size()-2);
 						interpret_pragma(pragma_string.data(),pragma_string.size(),locked_macros);
 						};
-					TokenList.DeleteNSlotsAt(4,i);						//! \todo fix once we have code-generation affecting pragmas
+					TokenList.DeleteNSlotsAt(4,i);
 					if (0==i) goto Restart;
 					--i;
 					continue;
@@ -2123,10 +2125,9 @@
 	return false;
 }
 
-void
+unsigned int
 CPreprocessor::interpret_pragma(const char* const x, size_t x_len, autovalarray_ptr<char*>& locked_macros)
 {
-	//! \todo: fix return value situation when enabling code-generation affecting pragmas
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
 	lang.line_lex(x, x_len, pretokenized);
 
@@ -2155,7 +2156,7 @@
 				}
 			}
 			}
-		return;
+		return 0;
 		}
 	else if (PRAGMA_LEADING_STDC==valid_pragma_class)
 		{
@@ -2173,7 +2174,7 @@
 					INC_INFORM("unhandled STDC pragma ");
 					INFORM(pragma_STDC_keywords[STDC_pragma].first);
 					zcc_errors.inc_error();
-					return;
+					return 0;
 					};
 #endif
 				case PRAGMA_STDC_FP_CONTRACT:
@@ -2193,13 +2194,15 @@
 						INC_INFORM("invalid STDC pragma ");
 						INFORM(x,x_len);
 						zcc_errors.inc_error();
-						return;
+						return 0;
 						}
+					// valid STDC pragma: relay encoding out
+					return STATIC_SIZE(pragma_STDC_on_off_switch)*STDC_pragma+on_off_switch+1;
 					};
 				}
 			}
 			}
-		return;
+		return 0;
 		}
 	else if (PRAGMA_MESSAGE==valid_pragma_class)
 		{
@@ -2212,7 +2215,7 @@
 			const bool wide_str = 'L'==x[pretokenized[2].first];
 			if (0<std::count(x+pretokenized[2].first,x+pretokenized[2].first+pretokenized[2].second,'\\'))
 				{	// no escapes
-				if (wide_str) return; //! \todo this should do a proper unescape to UNICODE, then use a wrapper library to push the UNICODE to whatever wide-char support there is
+				if (wide_str) return 0; //! \todo this should do a proper unescape to UNICODE, then use a wrapper library to push the UNICODE to whatever wide-char support there is
 
 				//! \todo change target, this only handles target CHAR_BIT<=host CHAR_BIT
 				const size_t tmp_len = lang.UnescapeStringLength(x+pretokenized[2].first,pretokenized[2].second);
@@ -2222,7 +2225,7 @@
 					lang.UnescapeString(tmp,x+pretokenized[2].first,pretokenized[2].second);
 					INFORM(tmp,tmp_len);
 					_flush(tmp);
-					return;
+					return 0;
 					}
 				};
 			// no escapes, or formatting failed: do something
@@ -2231,8 +2234,9 @@
 			else
 				INFORM(x+pretokenized[2].first+1,pretokenized[2].second-2);
 			}
-		return;
+		return 0;
 		}
+	return 0;
 }
 
 static void _complete_string_character_literal(Token<char>& x,const char delim, const char* const end_error)
@@ -4233,7 +4237,7 @@
 bool
 CPreprocessor::hard_locked_macro(const char* const x,const size_t x_len) const
 {
-	assert(!is_empty_string(x));
+	assert(x && *x);
 	assert(0<x_len);
 // C99: 6.11.9 Predefined macro names
 // Macro names beginning with __STDC_ are reserved for future standardization.

Modified: trunk/CPreproc_pp.hpp
===================================================================
--- trunk/CPreproc_pp.hpp	2010-05-16 10:08:21 UTC (rev 435)
+++ trunk/CPreproc_pp.hpp	2010-05-17 19:05:30 UTC (rev 436)
@@ -105,7 +105,7 @@
 	void function_macro_concatenate_novars(zaimoni::Token<char>& x, const zaimoni::Token<char>& arglist);
 
 	// pragma support
-	void interpret_pragma(const char* const x, size_t x_len, zaimoni::autovalarray_ptr<char*>& locked_macros);
+	unsigned int interpret_pragma(const char* const x, size_t x_len, zaimoni::autovalarray_ptr<char*>& locked_macros);
 };
 
 #endif

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-16 10:08:21 UTC (rev 435)
+++ trunk/CSupport.cpp	2010-05-17 19:05:30 UTC (rev 436)
@@ -4,6 +4,7 @@
 
 #/*cut-cpp*/
 #include "CSupport.hpp"
+#include "_CSupport3.hpp"
 #/*cut-cpp*/
 #include "CSupport_pp.hpp"
 #include "_CSupport1.hpp"
@@ -10176,11 +10177,37 @@
 		};
 }
 
+static void CPP_handle_pragma_relay(parse_tree& src)
+{
+	assert(src.is_raw_list());
+	if (!src.empty<0>())
+		{
+		bool typeid_is_ok = false;	// has to be enabled in #include <typeinfo>
+		size_t i = 0;
+		do	{
+			if (src.data<0>()[i].is_atomic())
+				{
+				const errr Idx = linear_find(src.data<0>()[i].index_tokens[0].token.first, src.data<0>()[i].index_tokens[0].token.second,pragma_relay_keywords,PRAGMA_RELAY_KEYWORDS_STRICT_UB);
+				if (0<=Idx)
+					{	// react to any relay keywords that actually mean anything here
+					if (RELAY_ZCC_ENABLE_TYPEID==Idx) typeid_is_ok = true;
+					src.DeleteIdx<0>(i);
+					}
+				else if (!typeid_is_ok && token_is_string<7>(src.data<0>()[i].index_tokens[0].token,"type_id"))
+					//! \bug need test case
+					simple_error(src.c_array<0>()[i]," requires #include <typeinfo> first (C++0X 5.2.8p6)");
+				}
+			}
+		while(src.size<0>()> ++i);
+		}
+}
+
 //! \todo check that the fact all literals are already legal-form is used
 //! \throw std::bad_alloc
 static void CPP_ContextFreeParse(parse_tree& src,const type_system& types)
 {
 	assert(src.is_raw_list());
+	CPP_handle_pragma_relay(src);
 	_label_literals(src,types);
 	std::for_each(src.begin<0>(),src.end<0>(),_label_CPP_literal);	// intercepts: true, false, this
 	if (!_match_pairs(src)) return;

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-05-16 10:08:21 UTC (rev 435)
+++ trunk/POSIX.dep	2010-05-17 19:05:30 UTC (rev 436)
@@ -1,8 +1,8 @@
 OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
-OBJECTS_Z_CPP_LINK_PRIORITY = load_src.o CSupport_pp.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o ParseTree.o type_spec.o uchar_blob.o CPreproc_autogen_pp.o CPUInfo.o type_system.o unsigned_var_int.o CPreproc_pp.o z_cpp.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
+OBJECTS_Z_CPP_LINK_PRIORITY = CPreproc_pp.o CSupport_pp.o CPreproc_autogen_pp.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o ParseTree.o type_spec.o uchar_blob.o CPUInfo.o type_system.o unsigned_var_int.o z_cpp.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
 
 OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = load_src.o end_nl.o CSupport.o end_lc.o Trigraph.o Flat_UNI.o errors.o ZParser.o ParseTree.o type_spec.o uchar_blob.o CPUInfo.o CPreproc_autogen.o type_system.o unsigned_var_int.o zcc.o CPreproc.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
+OBJECTS_ZCC_LINK_PRIORITY = CPreproc.o CSupport.o ZParser.o CPreproc_autogen.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o ParseTree.o type_spec.o uchar_blob.o CPUInfo.o type_system.o unsigned_var_int.o zcc.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
 
 # dependencies
 z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc_pp.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
@@ -35,7 +35,7 @@
 CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/opera!
 tor.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
-CSupport.o: CSupport.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp un!
 signed_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
-CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zai!
 moni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+CSupport.o: CSupport.hpp _CSupport3.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/!
 operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp _CSupport3.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/l!
 ogic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp

Modified: trunk/ZParser.cpp
===================================================================
--- trunk/ZParser.cpp	2010-05-16 10:08:21 UTC (rev 435)
+++ trunk/ZParser.cpp	2010-05-17 19:05:30 UTC (rev 436)
@@ -1,8 +1,10 @@
 // ZParser.cpp
+// (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
 #include "ZParser.hpp"
 
 #include "CSupport.hpp"
+#include "_CSupport3.hpp"
 #include "errors.hpp"
 #include "errcount.hpp"
 #include "langroute.hpp"
@@ -10,6 +12,7 @@
 #include "type_system.hpp"
 
 #include "Zaimoni.STL/AutoPtr.hpp"
+#include "Zaimoni.STL/search.hpp"
 #include "Zaimoni.STL/LexParse/LangConf.hpp"
 #include "Zaimoni.STL/LexParse/Token.hpp"
 
@@ -59,7 +62,28 @@
 		assert(TokenList.front());
 		Token<char>& tmp_front = *TokenList.front();
 		lang.line_lex(tmp_front.data(), tmp_front.size(), pretokenized);
+
+		// handle unused relay keywords here
 		if (!pretokenized.empty())
+			{
+			size_t i = pretokenized.size();
+			if (Lang::C==lang_code || Lang::CPlusPlus==lang_code)
+				do	{
+					--i;
+					const errr Idx = linear_find(tmp_front.data()+pretokenized[i].first, pretokenized[i].second,pragma_relay_keywords,PRAGMA_RELAY_KEYWORDS_STRICT_UB);
+					if (0<=Idx)
+						{	// permit any relay keywords that actually mean anything here
+						bool blacklist = true;
+						// allow #include <typeinfo> to turn off context-free syntax errors for typeid
+						if (RELAY_ZCC_ENABLE_TYPEID==Idx && Lang::CPlusPlus==lang_code) blacklist = false;
+						if (blacklist) pretokenized.DeleteIdx(i);
+						continue;			
+						}
+					}
+				while(0<i);
+			}
+
+		if (!pretokenized.empty())
 			{	// ...
 			const size_t append_tokens = pretokenized.size();
 			const size_t old_parsed_size = ParsedList.empty() ? 0 : ParsedList[0]->size<0>();

Modified: trunk/ZParser.hpp
===================================================================
--- trunk/ZParser.hpp	2010-05-16 10:08:21 UTC (rev 435)
+++ trunk/ZParser.hpp	2010-05-17 19:05:30 UTC (rev 436)
@@ -1,4 +1,5 @@
 // ZParser.hpp
+// (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
 #ifndef ZPARSER_HPP
 #define ZPARSER_HPP 1

Added: trunk/_CSupport3.hpp
===================================================================
--- trunk/_CSupport3.hpp	2010-05-16 10:08:21 UTC (rev 435)
+++ trunk/_CSupport3.hpp	2010-05-17 19:05:30 UTC (rev 436)
@@ -0,0 +1,13 @@
+// _CSupport3.hpp
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+namespace zaimoni {
+template<class A, class B> struct POD_pair;
+}
+
+// defined in CPreproc.cpp
+extern const zaimoni::POD_pair<const char*,size_t> pragma_relay_keywords[];
+
+#define RELAY_ZCC_ENABLE_TYPEID 9
+#define PRAGMA_RELAY_KEYWORDS_STRICT_UB 10
+

Modified: trunk/_version.h
===================================================================
--- trunk/_version.h	2010-05-16 10:08:21 UTC (rev 435)
+++ trunk/_version.h	2010-05-17 19:05:30 UTC (rev 436)
@@ -3,9 +3,9 @@
 /* (C)2010 Kenneth Boyd, license: MIT.txt */
 
 #ifndef ZCC_VERSION
-#define ZCC_VERSION "0.0.3"
+#define ZCC_VERSION "0.0.5"
 #define ZCC_VERSION_MAJOR 0
 #define ZCC_VERSION_MINOR 0
-#define ZCC_VERSION_PATCH 3
+#define ZCC_VERSION_PATCH 5
 #endif
 

Added: trunk/lib/zc++-0.0.5/include/typeinfo
===================================================================
--- trunk/lib/zc++-0.0.5/include/typeinfo	2010-05-16 10:08:21 UTC (rev 435)
+++ trunk/lib/zc++-0.0.5/include/typeinfo	2010-05-17 19:05:30 UTC (rev 436)
@@ -0,0 +1,9 @@
+// typeinfo
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+// C++0X 5.2.8p6 requires using typeid to make the program ill-formed until
+// #include <typeinfo> .  The following pragma tells Z.C++ to turn off the
+// syntax errors.
+#pragma ZCC enable_typeid
+
+//! \todo almost all of this header.



From zaimoni at mail.berlios.de  Mon May 17 21:08:13 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 17 May 2010 21:08:13 +0200
Subject: [Zcplusplus-commits] r437 - trunk
Message-ID: <201005171908.o4HJ8DQ5004487@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-17 21:08:11 +0200 (Mon, 17 May 2010)
New Revision: 437

Modified:
   trunk/POSIX.dep
Log:
fix makefile dependencies

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-05-17 19:05:30 UTC (rev 436)
+++ trunk/POSIX.dep	2010-05-17 19:08:11 UTC (rev 437)
@@ -38,4 +38,4 @@
 CSupport.o: CSupport.hpp _CSupport3.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/!
 operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp _CSupport3.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/l!
 ogic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
-ZParser.o: ZParser.hpp CSupport.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+ZParser.o: ZParser.hpp CSupport.hpp _CSupport3.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/search.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp



From zaimoni at mail.berlios.de  Wed May 19 10:21:53 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 19 May 2010 10:21:53 +0200
Subject: [Zcplusplus-commits] r438 - in trunk: .
	tests/zcc/default/staticassert
Message-ID: <201005190821.o4J8Lr6c028263@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-19 10:21:44 +0200 (Wed, 19 May 2010)
New Revision: 438

Added:
   trunk/tests/zcc/default/staticassert/Pass_typeid.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport.hpp
   trunk/CSupport_pp.cpp
   trunk/CSupport_pp.hpp
   trunk/type_spec.cpp
   trunk/type_spec.hpp
Log:
first testing of typeid in extended integer constant expressions for C++

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-17 19:08:11 UTC (rev 437)
+++ trunk/CSupport.cpp	2010-05-19 08:21:44 UTC (rev 438)
@@ -615,7 +615,8 @@
 	FLOAT__COMPLEX,
 	DOUBLE__COMPLEX,
 	LDOUBLE__COMPLEX,
-	WCHAR_T
+	WCHAR_T,	// C++-specific
+	TYPEINFO	// C++-specific
 };
 
 }
@@ -983,7 +984,8 @@
 		DICT_STRUCT("float _Complex"),		/* start C++ extension support: C99 _Complex in C++ (we can do this as _Complex is reserved to the implementation) */
 		DICT_STRUCT("double _Complex"),
 		DICT_STRUCT("long double _Complex"),
-		DICT_STRUCT("wchar_t")
+		DICT_STRUCT("wchar_t"),			// C++-specific
+		DICT_STRUCT("std::typeinfo")	// C++-specific
 		};
 
 BOOST_STATIC_ASSERT(STATIC_SIZE(C_atomic_types)==C_TYPE_MAX);
@@ -3452,7 +3454,7 @@
 {
 	if (NULL!=src.index_tokens[0].token.first)
 		{
-		if (token_is_string<5>(src.index_tokens[0].token,"_Bool"))
+		if (token_is_string<4>(src.index_tokens[0].token,"bool"))
 			{
 			src.type_code.set_type(C_TYPE::BOOL);
 			src.flags |= PARSE_PRIMARY_TYPE;
@@ -3614,7 +3616,22 @@
 }
 #/*cut-cpp*/
 
+static bool is_CPP0X_typeid_expression(const parse_tree& src)
+{
+	return		(robust_token_is_string<6>(src.index_tokens[0].token,"typeid"))
 #ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	src.empty<1>()
+			&&	1==src.size<2>() && ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags)
+			&&	C_TYPE::TYPEINFO==src.type_code.base_type_index
+			&&	0==src.type_code.pointer_power
+			&&	(src.type_code.qualifier<0>() & (type_spec::lvalue | type_spec::_const))==(type_spec::lvalue | type_spec::_const);
+}
+
+#ifndef NDEBUG
 static bool is_C99_CPP_sizeof_expression(const parse_tree& src)
 {
 	return		(robust_token_is_string<6>(src.index_tokens[0].token,"sizeof"))
@@ -5120,6 +5137,58 @@
 		}
 }
 
+#/*cut-cpp*/
+
+// if #include <typeinfo> hasn't happened, context-free error stops this
+//! \throw std::bad_alloc
+static bool terse_locate_CPP0X_typeid(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"typeid")
+		&& 1<src.size<0>()-i
+		&& is_naked_parentheses_pair(src.data<0>()[i+1]))
+		{
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<0>()[i+1].flags)
+			{
+			{
+			parse_tree* const tmp = repurpose_inner_parentheses(src.c_array<0>()[i+1]);	// RAM conservation
+			src.c_array<0>()[i+1].OverwriteInto(*tmp);
+			src.c_array<0>()[i].fast_set_arg<2>(tmp);
+			src.c_array<0>()[i].core_flag_update();
+			src.c_array<0>()[i].flags |= PARSE_STRICT_POSTFIX_EXPRESSION;
+			src.DeleteIdx<0>(i+1);
+			cancel_outermost_parentheses(src.c_array<0>()[i].c_array<2>()[0]);
+			}
+			src.c_array<0>()[i].type_code.set_type(C_TYPE::TYPEINFO);
+			src.c_array<0>()[i].type_code.qualifier<0>() |= (type_spec::lvalue | type_spec::_const);
+			assert(is_CPP0X_typeid_expression(src.c_array<0>()[i]));
+			return true;			
+			}
+		}
+	return false;
+}
+
+// We can't eval typeid itself at compile-time, but we *can* eval == and != of
+// typeid.  Most other operators should error, through.
+
+//! \throw std::bad_alloc()
+static bool locate_CPP0X_typeid(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+
+	if (	!(PARSE_OBVIOUS & src.data<0>()[i].flags)
+		&&	src.data<0>()[i].is_atomic()
+		&&	terse_locate_CPP0X_typeid(src,i,types))
+		return true;
+	return false;
+}
+#/*cut-cpp*/
 /*postfixexpression:
 	primaryexpression
 	postfixexpression [ expression ]
@@ -5161,8 +5230,13 @@
 				{
 				}
 			}
+#/*cut-cpp*/
+#endif
 		}
 	else{	// if (NULL==src.data<0>()[i].index_tokens[1].token.first)
+		if (locate_CPP0X_typeid(src,i,types)) return;
+#if 0
+#/*cut-cpp*/
 		if (token_is_char<'.'>(src.data<0>()[i].index_tokens[0].token))
 			{
 			if (1<=i && 1<src.size<0>()-i)
@@ -8374,6 +8448,20 @@
 	return false;
 }
 
+#/*cut-cpp*/
+static bool typeid_equal_content(const parse_tree& lhs, const parse_tree& rhs,bool& is_equal)
+{
+	if (   is_CPP0X_typeid_expression(lhs) && is_CPP0X_typeid_expression(rhs)
+		&& C_TYPE::NOT_VOID!=lhs.data<2>()->type_code.base_type_index
+		&& C_TYPE::NOT_VOID!=rhs.data<2>()->type_code.base_type_index)
+		{
+		is_equal = lhs.type_code.typeid_equal(rhs.type_code);
+		return true;
+		}
+	return false;
+}
+
+#/*cut-cpp*/
 static bool eval_equality_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {	
 	BOOST_STATIC_ASSERT(1==C99_EQUALITY_SUBTYPE_NEQ-C99_EQUALITY_SUBTYPE_EQ);
@@ -8390,7 +8478,11 @@
 				//! \test default/Pass_if_nonzero.hpp, default/Pass_if_nonzero.h, 
 				//! \test default/Pass_if_zero.hpp, default/Pass_if_zero.h, 
 			bool is_equal = false;
-			if (C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal))
+			if (   C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal)
+#/*cut-cpp*/
+				|| typeid_equal_content(*src.data<1>(),*src.data<2>(),is_equal)
+#/*cut-cpp*/
+				)
 				{
 				force_decimal_literal(src,is_equal_op==is_equal ? "1" : "0",types);
 				return true;

Modified: trunk/CSupport.hpp
===================================================================
--- trunk/CSupport.hpp	2010-05-17 19:08:11 UTC (rev 437)
+++ trunk/CSupport.hpp	2010-05-19 08:21:44 UTC (rev 438)
@@ -1,4 +1,4 @@
-// CSupport.hpp
+// CSupport_pp.hpp
 // support for C/C++ language parsing
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
@@ -133,7 +133,7 @@
 extern const size_t C_int_priority[];
 
 #define C_TYPE_MAX 21
-#define CPP_TYPE_MAX 22
+#define CPP_TYPE_MAX 23
 #define C_INT_PRIORITY_SIZE 7
 #define C_PP_INT_PRIORITY_ORIGIN 4
 

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-17 19:08:11 UTC (rev 437)
+++ trunk/CSupport_pp.cpp	2010-05-19 08:21:44 UTC (rev 438)
@@ -558,7 +558,8 @@
 	FLOAT__COMPLEX,
 	DOUBLE__COMPLEX,
 	LDOUBLE__COMPLEX,
-	WCHAR_T
+	WCHAR_T,	// C++-specific
+	TYPEINFO	// C++-specific
 };
 
 }
@@ -905,7 +906,8 @@
 		DICT_STRUCT("float _Complex"),		/* start C++ extension support: C99 _Complex in C++ (we can do this as _Complex is reserved to the implementation) */
 		DICT_STRUCT("double _Complex"),
 		DICT_STRUCT("long double _Complex"),
-		DICT_STRUCT("wchar_t")
+		DICT_STRUCT("wchar_t"),			// C++-specific
+		DICT_STRUCT("std::typeinfo")	// C++-specific
 		};
 
 BOOST_STATIC_ASSERT(STATIC_SIZE(C_atomic_types)==C_TYPE_MAX);
@@ -3359,7 +3361,7 @@
 {
 	if (NULL!=src.index_tokens[0].token.first)
 		{
-		if (token_is_string<5>(src.index_tokens[0].token,"_Bool"))
+		if (token_is_string<4>(src.index_tokens[0].token,"bool"))
 			{
 			src.type_code.set_type(C_TYPE::BOOL);
 			src.flags |= PARSE_PRIMARY_TYPE;
@@ -4700,8 +4702,6 @@
 				{
 				}
 			}
-		}
-	else{	// if (NULL==src.data<0>()[i].index_tokens[1].token.first)
 		if (token_is_char<'.'>(src.data<0>()[i].index_tokens[0].token))
 			{
 			if (1<=i && 1<src.size<0>()-i)
@@ -7496,7 +7496,8 @@
 				//! \test default/Pass_if_nonzero.hpp, default/Pass_if_nonzero.h, 
 				//! \test default/Pass_if_zero.hpp, default/Pass_if_zero.h, 
 			bool is_equal = false;
-			if (C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal))
+			if (   C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal)
+				)
 				{
 				force_decimal_literal(src,is_equal_op==is_equal ? "1" : "0",types);
 				return true;

Modified: trunk/CSupport_pp.hpp
===================================================================
--- trunk/CSupport_pp.hpp	2010-05-17 19:08:11 UTC (rev 437)
+++ trunk/CSupport_pp.hpp	2010-05-19 08:21:44 UTC (rev 438)
@@ -1,4 +1,4 @@
-// CSupport_pp.hpp
+// CSupport.hpp
 // support for C/C++ language parsing
 // (C)2009 Kenneth Boyd, license: MIT.txt
 
@@ -123,7 +123,7 @@
 extern const size_t C_int_priority[];
 
 #define C_TYPE_MAX 21
-#define CPP_TYPE_MAX 22
+#define CPP_TYPE_MAX 23
 #define C_INT_PRIORITY_SIZE 7
 #define C_PP_INT_PRIORITY_ORIGIN 4
 

Added: trunk/tests/zcc/default/staticassert/Pass_typeid.hpp
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_typeid.hpp	2010-05-17 19:08:11 UTC (rev 437)
+++ trunk/tests/zcc/default/staticassert/Pass_typeid.hpp	2010-05-19 08:21:44 UTC (rev 438)
@@ -0,0 +1,29 @@
+// tests/zcc/default/Pass_typeid.hpp
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+// The result of the typeid operator itself isn't a compile-time expression
+// (it's a std::typeinfo structure) -- but the result of == and != operators
+// can be known at compile-time in simple cases.
+
+// identity checks
+static_assert(typeid(bool)==typeid(bool),"automatic success failed");
+static_assert(typeid(char)==typeid(char),"automatic success failed");
+static_assert(typeid(signed char)==typeid(signed char),"automatic success failed");
+static_assert(typeid(unsigned char)==typeid(unsigned char),"automatic success failed");
+static_assert(typeid(short)==typeid(short),"automatic success failed");
+static_assert(typeid(unsigned short)==typeid(unsigned short),"automatic success failed");
+static_assert(typeid(int)==typeid(int),"automatic success failed");
+static_assert(typeid(unsigned int)==typeid(unsigned int),"automatic success failed");
+static_assert(typeid(long)==typeid(long),"automatic success failed");
+static_assert(typeid(unsigned long)==typeid(unsigned long),"automatic success failed");
+static_assert(typeid(long long)==typeid(long long),"automatic success failed");
+static_assert(typeid(unsigned long long)==typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(float)==typeid(float),"automatic success failed");
+static_assert(typeid(double)==typeid(double),"automatic success failed");
+static_assert(typeid(long double)==typeid(long double),"automatic success failed");
+
+// these three aren't remotely required by the C++ standards, but Z.C++
+// wants to support C _Complex as an extension.
+static_assert(typeid(float _Complex)==typeid(float _Complex),"automatic success failed");
+static_assert(typeid(double _Complex)==typeid(double _Complex),"automatic success failed");
+static_assert(typeid(long double _Complex)==typeid(long double _Complex),"automatic success failed");

Modified: trunk/type_spec.cpp
===================================================================
--- trunk/type_spec.cpp	2010-05-17 19:08:11 UTC (rev 437)
+++ trunk/type_spec.cpp	2010-05-19 08:21:44 UTC (rev 438)
@@ -173,6 +173,21 @@
 		&& (0==pointer_power || !memcmp(extent_vector,rhs.extent_vector,sizeof(uintmax_t)*pointer_power));
 }
 
+bool type_spec::typeid_equal(const type_spec& rhs) const
+{
+	if (   base_type_index==rhs.base_type_index
+		&& pointer_power==rhs.pointer_power)
+		{	// C++0X 5.2.8p5: lose the topmost level of 
+			// C++ cv-qualification (extending to C would be 
+			// C type-qualifiers)
+		if (0==pointer_power) return true;
+		if (	!memcmp(extent_vector,rhs.extent_vector,sizeof(uintmax_t)*pointer_power)
+			&&	!memcmp(q_vector.data(),rhs.q_vector.data(),pointer_power))
+			return true;
+		}
+	return false;
+}
+
 void type_spec::MoveInto(type_spec& dest)
 {
 	dest.destroy();

Modified: trunk/type_spec.hpp
===================================================================
--- trunk/type_spec.hpp	2010-05-17 19:08:11 UTC (rev 437)
+++ trunk/type_spec.hpp	2010-05-19 08:21:44 UTC (rev 438)
@@ -64,6 +64,7 @@
 
 	//! \throw std::bad_alloc only if dest.pointer_power<src.pointer_power 
 	static void value_copy(type_spec& dest, const type_spec& src) {::value_copy(dest,src);};
+	bool typeid_equal(const type_spec& rhs) const;
 	void MoveInto(type_spec& dest);
 	void OverwriteInto(type_spec& dest);
 #ifndef ZAIMONI_FORCE_ISO



From zaimoni at mail.berlios.de  Wed May 19 11:01:00 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 19 May 2010 11:01:00 +0200
Subject: [Zcplusplus-commits] r439 - in trunk: .
	tests/zcc/default/staticassert
Message-ID: <201005190901.o4J910TA032323@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-19 11:00:55 +0200 (Wed, 19 May 2010)
New Revision: 439

Modified:
   trunk/CSupport.cpp
   trunk/tests/zcc/default/staticassert/Pass_typeid.hpp
Log:
better testing for typeid

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-19 08:21:44 UTC (rev 438)
+++ trunk/CSupport.cpp	2010-05-19 09:00:55 UTC (rev 439)
@@ -8455,7 +8455,7 @@
 		&& C_TYPE::NOT_VOID!=lhs.data<2>()->type_code.base_type_index
 		&& C_TYPE::NOT_VOID!=rhs.data<2>()->type_code.base_type_index)
 		{
-		is_equal = lhs.type_code.typeid_equal(rhs.type_code);
+		is_equal = lhs.data<2>()->type_code.typeid_equal(rhs.data<2>()->type_code);
 		return true;
 		}
 	return false;

Modified: trunk/tests/zcc/default/staticassert/Pass_typeid.hpp
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_typeid.hpp	2010-05-19 08:21:44 UTC (rev 438)
+++ trunk/tests/zcc/default/staticassert/Pass_typeid.hpp	2010-05-19 09:00:55 UTC (rev 439)
@@ -6,6 +6,7 @@
 // can be known at compile-time in simple cases.
 
 // identity checks
+static_assert(typeid(void)==typeid(void),"automatic success failed");
 static_assert(typeid(bool)==typeid(bool),"automatic success failed");
 static_assert(typeid(char)==typeid(char),"automatic success failed");
 static_assert(typeid(signed char)==typeid(signed char),"automatic success failed");
@@ -27,3 +28,24 @@
 static_assert(typeid(float _Complex)==typeid(float _Complex),"automatic success failed");
 static_assert(typeid(double _Complex)==typeid(double _Complex),"automatic success failed");
 static_assert(typeid(long double _Complex)==typeid(long double _Complex),"automatic success failed");
+
+// inequality checks
+static_assert(typeid(void)!=typeid(bool),"automatic success failed");
+static_assert(typeid(void)!=typeid(char),"automatic success failed");
+static_assert(typeid(void)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(void)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(void)!=typeid(short),"automatic success failed");
+static_assert(typeid(void)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(void)!=typeid(int),"automatic success failed");
+static_assert(typeid(void)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(void)!=typeid(long),"automatic success failed");
+static_assert(typeid(void)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(void)!=typeid(long long),"automatic success failed");
+static_assert(typeid(void)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(void)!=typeid(float),"automatic success failed");
+static_assert(typeid(void)!=typeid(double),"automatic success failed");
+static_assert(typeid(void)!=typeid(long double),"automatic success failed");
+static_assert(typeid(void)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(void)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(void)!=typeid(long double _Complex),"automatic success failed");
+



From zaimoni at mail.berlios.de  Wed May 19 11:51:06 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 19 May 2010 11:51:06 +0200
Subject: [Zcplusplus-commits] r440 - in trunk: .
	tests/zcc/default/staticassert tests/zcc/staticassert.C1X
Message-ID: <201005190951.o4J9p6mF005619@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-19 11:51:00 +0200 (Wed, 19 May 2010)
New Revision: 440

Added:
   trunk/tests/zcc/staticassert.C1X/Error_typeid_no_typeinfo.hpp
Modified:
   trunk/CPreproc.cpp
   trunk/CSupport.cpp
   trunk/tests/zcc/default/staticassert/Pass_typeid.hpp
Log:
make typeid fail without #include <typeinfo>

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2010-05-19 09:00:55 UTC (rev 439)
+++ trunk/CPreproc.cpp	2010-05-19 09:51:00 UTC (rev 440)
@@ -1436,8 +1436,8 @@
 						--i;
 						continue;
 #/*cut-cpp*/
-						case RELAY_ZCC_ENABLE_TYPEID:
-							TokenList[i]->replace_once(0,TokenList[i]->size(),pragma_relay_keywords[pragma_code].first,pragma_relay_keywords[pragma_code].second);
+						case RELAY_ZCC_ENABLE_TYPEID+1:
+							TokenList[i]->replace_once(0,TokenList[i]->size(),pragma_relay_keywords[pragma_code-1].first,pragma_relay_keywords[pragma_code-1].second);
 							continue;
 						}
 #/*cut-cpp*/
@@ -1693,8 +1693,8 @@
 #/*cut-cpp*/
 						switch(pragma_code)
 						{
-						case RELAY_ZCC_ENABLE_TYPEID:
-							TokenList[i]->replace_once(0,TokenList[i]->size(),pragma_relay_keywords[pragma_code].first,pragma_relay_keywords[pragma_code].second);
+						case RELAY_ZCC_ENABLE_TYPEID+1:
+							TokenList[i]->replace_once(0,TokenList[i]->size(),pragma_relay_keywords[pragma_code-1].first,pragma_relay_keywords[pragma_code-1].second);
 							TokenList.DeleteNSlotsAt(3,i+1);
 							continue;
 						}

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-19 09:00:55 UTC (rev 439)
+++ trunk/CSupport.cpp	2010-05-19 09:51:00 UTC (rev 440)
@@ -10285,7 +10285,7 @@
 					if (RELAY_ZCC_ENABLE_TYPEID==Idx) typeid_is_ok = true;
 					src.DeleteIdx<0>(i);
 					}
-				else if (!typeid_is_ok && token_is_string<7>(src.data<0>()[i].index_tokens[0].token,"type_id"))
+				else if (!typeid_is_ok && token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"typeid"))
 					//! \bug need test case
 					simple_error(src.c_array<0>()[i]," requires #include <typeinfo> first (C++0X 5.2.8p6)");
 				}

Modified: trunk/tests/zcc/default/staticassert/Pass_typeid.hpp
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_typeid.hpp	2010-05-19 09:00:55 UTC (rev 439)
+++ trunk/tests/zcc/default/staticassert/Pass_typeid.hpp	2010-05-19 09:51:00 UTC (rev 440)
@@ -5,6 +5,8 @@
 // (it's a std::typeinfo structure) -- but the result of == and != operators
 // can be known at compile-time in simple cases.
 
+#include <typeinfo>
+
 // identity checks
 static_assert(typeid(void)==typeid(void),"automatic success failed");
 static_assert(typeid(bool)==typeid(bool),"automatic success failed");

Added: trunk/tests/zcc/staticassert.C1X/Error_typeid_no_typeinfo.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_typeid_no_typeinfo.hpp	2010-05-19 09:00:55 UTC (rev 439)
+++ trunk/tests/zcc/staticassert.C1X/Error_typeid_no_typeinfo.hpp	2010-05-19 09:51:00 UTC (rev 440)
@@ -0,0 +1,5 @@
+// Error_typeid_no_typeinfo.hpp
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+static_assert(typeid(void)==typeid(void),"automatic success failed");
+



From zaimoni at mail.berlios.de  Thu May 20 10:05:05 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 20 May 2010 10:05:05 +0200
Subject: [Zcplusplus-commits] r441 - trunk/tests/zcc/default/staticassert
Message-ID: <201005200805.o4K855Fv005486@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-20 10:05:00 +0200 (Thu, 20 May 2010)
New Revision: 441

Modified:
   trunk/tests/zcc/default/staticassert/Pass_typeid.hpp
Log:
complete baseline inequality testing for static assertions of typeid

Modified: trunk/tests/zcc/default/staticassert/Pass_typeid.hpp
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_typeid.hpp	2010-05-19 09:51:00 UTC (rev 440)
+++ trunk/tests/zcc/default/staticassert/Pass_typeid.hpp	2010-05-20 08:05:00 UTC (rev 441)
@@ -51,3 +51,345 @@
 static_assert(typeid(void)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(void)!=typeid(long double _Complex),"automatic success failed");
 
+static_assert(typeid(bool)!=typeid(void),"automatic success failed");
+static_assert(typeid(bool)!=typeid(char),"automatic success failed");
+static_assert(typeid(bool)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(bool)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(bool)!=typeid(short),"automatic success failed");
+static_assert(typeid(bool)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(bool)!=typeid(int),"automatic success failed");
+static_assert(typeid(bool)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(bool)!=typeid(long),"automatic success failed");
+static_assert(typeid(bool)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(bool)!=typeid(long long),"automatic success failed");
+static_assert(typeid(bool)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(bool)!=typeid(float),"automatic success failed");
+static_assert(typeid(bool)!=typeid(double),"automatic success failed");
+static_assert(typeid(bool)!=typeid(long double),"automatic success failed");
+static_assert(typeid(bool)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(bool)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(bool)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(char)!=typeid(void),"automatic success failed");
+static_assert(typeid(char)!=typeid(bool),"automatic success failed");
+static_assert(typeid(char)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(char)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(char)!=typeid(short),"automatic success failed");
+static_assert(typeid(char)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(char)!=typeid(int),"automatic success failed");
+static_assert(typeid(char)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(char)!=typeid(long),"automatic success failed");
+static_assert(typeid(char)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(char)!=typeid(long long),"automatic success failed");
+static_assert(typeid(char)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(char)!=typeid(float),"automatic success failed");
+static_assert(typeid(char)!=typeid(double),"automatic success failed");
+static_assert(typeid(char)!=typeid(long double),"automatic success failed");
+static_assert(typeid(char)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(char)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(char)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(signed char)!=typeid(void),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(bool),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(char),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(short),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(int),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(long),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(long long),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(float),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(double),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(long double),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(unsigned char)!=typeid(void),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(bool),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(char),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(short),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(int),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(long),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(long long),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(float),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(double),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(long double),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(short)!=typeid(void),"automatic success failed");
+static_assert(typeid(short)!=typeid(bool),"automatic success failed");
+static_assert(typeid(short)!=typeid(char),"automatic success failed");
+static_assert(typeid(short)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(short)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(short)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(short)!=typeid(int),"automatic success failed");
+static_assert(typeid(short)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(short)!=typeid(long),"automatic success failed");
+static_assert(typeid(short)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(short)!=typeid(long long),"automatic success failed");
+static_assert(typeid(short)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(short)!=typeid(float),"automatic success failed");
+static_assert(typeid(short)!=typeid(double),"automatic success failed");
+static_assert(typeid(short)!=typeid(long double),"automatic success failed");
+static_assert(typeid(short)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(short)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(short)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(unsigned short)!=typeid(void),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(bool),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(char),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(short),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(int),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(long),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(long long),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(float),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(double),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(long double),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(int)!=typeid(void),"automatic success failed");
+static_assert(typeid(int)!=typeid(bool),"automatic success failed");
+static_assert(typeid(int)!=typeid(char),"automatic success failed");
+static_assert(typeid(int)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(int)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(int)!=typeid(short),"automatic success failed");
+static_assert(typeid(int)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(int)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(int)!=typeid(long),"automatic success failed");
+static_assert(typeid(int)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(int)!=typeid(long long),"automatic success failed");
+static_assert(typeid(int)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(int)!=typeid(float),"automatic success failed");
+static_assert(typeid(int)!=typeid(double),"automatic success failed");
+static_assert(typeid(int)!=typeid(long double),"automatic success failed");
+static_assert(typeid(int)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(int)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(int)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(unsigned int)!=typeid(void),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(bool),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(char),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(short),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(int),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(long),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(long long),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(float),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(double),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(long double),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(long)!=typeid(void),"automatic success failed");
+static_assert(typeid(long)!=typeid(bool),"automatic success failed");
+static_assert(typeid(long)!=typeid(char),"automatic success failed");
+static_assert(typeid(long)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(long)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(long)!=typeid(short),"automatic success failed");
+static_assert(typeid(long)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(long)!=typeid(int),"automatic success failed");
+static_assert(typeid(long)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(long)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(long)!=typeid(long long),"automatic success failed");
+static_assert(typeid(long)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(long)!=typeid(float),"automatic success failed");
+static_assert(typeid(long)!=typeid(double),"automatic success failed");
+static_assert(typeid(long)!=typeid(long double),"automatic success failed");
+static_assert(typeid(long)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(long)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(long)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(unsigned long)!=typeid(void),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(bool),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(char),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(short),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(int),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(long),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(long long),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(float),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(double),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(long double),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(long long)!=typeid(void),"automatic success failed");
+static_assert(typeid(long long)!=typeid(bool),"automatic success failed");
+static_assert(typeid(long long)!=typeid(char),"automatic success failed");
+static_assert(typeid(long long)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(long long)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(long long)!=typeid(short),"automatic success failed");
+static_assert(typeid(long long)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(long long)!=typeid(int),"automatic success failed");
+static_assert(typeid(long long)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(long long)!=typeid(long),"automatic success failed");
+static_assert(typeid(long long)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(long long)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(long long)!=typeid(float),"automatic success failed");
+static_assert(typeid(long long)!=typeid(double),"automatic success failed");
+static_assert(typeid(long long)!=typeid(long double),"automatic success failed");
+static_assert(typeid(long long)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(long long)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(long long)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(unsigned long long)!=typeid(void),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(bool),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(char),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(short),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(int),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(long),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(long long),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(float),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(double),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(long double),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(float)!=typeid(void),"automatic success failed");
+static_assert(typeid(float)!=typeid(bool),"automatic success failed");
+static_assert(typeid(float)!=typeid(char),"automatic success failed");
+static_assert(typeid(float)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(float)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(float)!=typeid(short),"automatic success failed");
+static_assert(typeid(float)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(float)!=typeid(int),"automatic success failed");
+static_assert(typeid(float)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(float)!=typeid(long),"automatic success failed");
+static_assert(typeid(float)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(float)!=typeid(long long),"automatic success failed");
+static_assert(typeid(float)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(float)!=typeid(double),"automatic success failed");
+static_assert(typeid(float)!=typeid(long double),"automatic success failed");
+static_assert(typeid(float)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(float)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(float)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(double)!=typeid(void),"automatic success failed");
+static_assert(typeid(double)!=typeid(bool),"automatic success failed");
+static_assert(typeid(double)!=typeid(char),"automatic success failed");
+static_assert(typeid(double)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(double)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(double)!=typeid(short),"automatic success failed");
+static_assert(typeid(double)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(double)!=typeid(int),"automatic success failed");
+static_assert(typeid(double)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(double)!=typeid(long),"automatic success failed");
+static_assert(typeid(double)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(double)!=typeid(long long),"automatic success failed");
+static_assert(typeid(double)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(double)!=typeid(float),"automatic success failed");
+static_assert(typeid(double)!=typeid(long double),"automatic success failed");
+static_assert(typeid(double)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(double)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(double)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(long double)!=typeid(void),"automatic success failed");
+static_assert(typeid(long double)!=typeid(bool),"automatic success failed");
+static_assert(typeid(long double)!=typeid(char),"automatic success failed");
+static_assert(typeid(long double)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(long double)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(long double)!=typeid(short),"automatic success failed");
+static_assert(typeid(long double)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(long double)!=typeid(int),"automatic success failed");
+static_assert(typeid(long double)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(long double)!=typeid(long),"automatic success failed");
+static_assert(typeid(long double)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(long double)!=typeid(long long),"automatic success failed");
+static_assert(typeid(long double)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(long double)!=typeid(float),"automatic success failed");
+static_assert(typeid(long double)!=typeid(double),"automatic success failed");
+static_assert(typeid(long double)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(long double)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(long double)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(float _Complex)!=typeid(void),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(bool),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(char),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(short),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(int),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(long),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(long long),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(float),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(double),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(long double),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(double _Complex)!=typeid(void),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(bool),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(char),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(short),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(int),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(long),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(long long),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(float),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(double),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(long double),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(long double _Complex),"automatic success failed");
+
+static_assert(typeid(long double _Complex)!=typeid(void),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(bool),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(char),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(short),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(int),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(long),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(long long),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(float),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(double),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(long double),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(double _Complex),"automatic success failed");
+



From zaimoni at mail.berlios.de  Thu May 20 20:11:29 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 20 May 2010 20:11:29 +0200
Subject: [Zcplusplus-commits] r442 - trunk
Message-ID: <201005201811.o4KIBTS9004184@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-20 20:10:59 +0200 (Thu, 20 May 2010)
New Revision: 442

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
make type of char literal correct for C++ (catch C later, need to be language-aware to handle that)

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-20 08:05:00 UTC (rev 441)
+++ trunk/CSupport.cpp	2010-05-20 18:10:59 UTC (rev 442)
@@ -2759,6 +2759,22 @@
 	return LengthOfUnescapedCString(src,src_len)+1;
 }
 
+static size_t LengthOfCCharLiteral(const char* src, size_t src_len)
+{
+	assert(NULL!=src);
+	assert(2<=src_len);
+	const bool wide_char = ('L'==src[0]);
+	if (wide_char)
+		{
+		++src;
+		if (2 > --src_len) return 0;
+		}
+	if ('\''!=src[--src_len]) return 0;
+	if ('\''!=*(src++)) return 0;
+	if (0 == --src_len) return 1;
+	return LengthOfUnescapedCString(src,src_len);
+}
+
 /*! 
  * Locates the character in a character literal as a substring.  Use this as preparation for "collapsing in place".
  * 
@@ -4442,8 +4458,12 @@
 			return;
 			}
 		else if (C_TESTFLAG_CHAR_LITERAL==src.index_tokens[0].flags)
-			{
-			src.type_code.set_type(C_TYPE::CHAR);
+			{	// C99 6.4.4.4p10: the type of a character literal is int
+				// C++0X 2.13.4p1: the type of a single character literal is char 
+				// but the type of a multiple-character literal is int
+				// unfortunately, we don't have the language here.  Go with
+				// C++ rules, and patch up C elsewhere
+			src.type_code.set_type(LengthOfCCharLiteral(src.index_tokens[0].token.first,src.index_tokens[0].token.second) ? C_TYPE::CHAR : C_TYPE::INT);
 			return;
 			};
 		assert(C_TESTFLAG_PP_NUMERAL & src.index_tokens[0].flags);

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-20 08:05:00 UTC (rev 441)
+++ trunk/CSupport_pp.cpp	2010-05-20 18:10:59 UTC (rev 442)
@@ -2666,6 +2666,22 @@
 	return LengthOfUnescapedCString(src,src_len)+1;
 }
 
+static size_t LengthOfCCharLiteral(const char* src, size_t src_len)
+{
+	assert(NULL!=src);
+	assert(2<=src_len);
+	const bool wide_char = ('L'==src[0]);
+	if (wide_char)
+		{
+		++src;
+		if (2 > --src_len) return 0;
+		}
+	if ('\''!=src[--src_len]) return 0;
+	if ('\''!=*(src++)) return 0;
+	if (0 == --src_len) return 1;
+	return LengthOfUnescapedCString(src,src_len);
+}
+
 /*! 
  * Locates the character in a character literal as a substring.  Use this as preparation for "collapsing in place".
  * 
@@ -4011,8 +4027,12 @@
 			return;
 			}
 		else if (C_TESTFLAG_CHAR_LITERAL==src.index_tokens[0].flags)
-			{
-			src.type_code.set_type(C_TYPE::CHAR);
+			{	// C99 6.4.4.4p10: the type of a character literal is int
+				// C++0X 2.13.4p1: the type of a single character literal is char 
+				// but the type of a multiple-character literal is int
+				// unfortunately, we don't have the language here.  Go with
+				// C++ rules, and patch up C elsewhere
+			src.type_code.set_type(LengthOfCCharLiteral(src.index_tokens[0].token.first,src.index_tokens[0].token.second) ? C_TYPE::CHAR : C_TYPE::INT);
 			return;
 			};
 		assert(C_TESTFLAG_PP_NUMERAL & src.index_tokens[0].flags);



From zaimoni at mail.berlios.de  Sat May 22 09:39:36 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 22 May 2010 09:39:36 +0200
Subject: [Zcplusplus-commits] r443 - trunk
Message-ID: <201005220739.o4M7daDf026067@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-22 09:39:32 +0200 (Sat, 22 May 2010)
New Revision: 443

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
eliminate unnecessary recursion

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-20 18:10:59 UTC (rev 442)
+++ trunk/CSupport.cpp	2010-05-22 07:39:32 UTC (rev 443)
@@ -3142,6 +3142,7 @@
 		zcc_errors.inc_error();
 		};
 }
+#/*cut-cpp*/
 
 /* deal with following type catalog
 atomic:
@@ -3425,9 +3426,9 @@
 	return 0;
 }
 
-static void C99_notice_primary_type(parse_tree& src)
+static void C99_notice_primary_type_atomic(parse_tree& src)
 {
-	if (NULL!=src.index_tokens[0].token.first)
+	if (src.is_atomic())
 		{
 		if (token_is_string<5>(src.index_tokens[0].token,"_Bool"))
 			{
@@ -3442,14 +3443,18 @@
 			return;
 			}
 		}
+}
 
+static void C99_notice_primary_type(parse_tree& src)
+{
+	assert(src.is_raw_list());
+	std::for_each(src.begin<0>(),src.end<0>(),C99_notice_primary_type_atomic);
 	size_t i = 0;
 	size_t offset = 0;
 	while(i+offset<src.size<0>())
 		{
-		{
+		{	//! \todo retest object size with/without tmp_ref
 		parse_tree& tmp_ref = src.c_array<0>()[i];
-		C99_notice_primary_type(tmp_ref);
 		const size_t truncate_by = (!(PARSE_PRIMARY_TYPE & tmp_ref.flags) && NULL!=tmp_ref.index_tokens[0].token.first) 
 								 ? _C99_CPP_notice_multitoken_primary_type(src,i) : 0;
 		if (0<truncate_by)
@@ -3466,9 +3471,9 @@
 	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
 }
 
-static void CPP_notice_primary_type(parse_tree& src)
+static void CPP_notice_primary_type_atomic(parse_tree& src)
 {
-	if (NULL!=src.index_tokens[0].token.first)
+	if (src.is_atomic())
 		{
 		if (token_is_string<4>(src.index_tokens[0].token,"bool"))
 			{
@@ -3489,14 +3494,18 @@
 			return;
 			}
 		}
+}
 
+static void CPP_notice_primary_type(parse_tree& src)
+{
+	assert(src.is_raw_list());
+	std::for_each(src.begin<0>(),src.end<0>(),CPP_notice_primary_type_atomic);
 	size_t i = 0;
 	size_t offset = 0;
 	while(i+offset<src.size<0>())
 		{
-		{
+		{	//! \todo retest object size with/without tmp_ref
 		parse_tree& tmp_ref = src.c_array<0>()[i];
-		CPP_notice_primary_type(tmp_ref);
 		const size_t truncate_by = (!(PARSE_PRIMARY_TYPE & tmp_ref.flags) && NULL!=tmp_ref.index_tokens[0].token.first) 
 								 ? _C99_CPP_notice_multitoken_primary_type(src,i) : 0;
 		if (0<truncate_by)
@@ -3512,6 +3521,7 @@
 		};
 	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
 }
+#/*cut-cpp*/
 
 //! \todo generalize -- function pointer parameter target, functor target
 static size_t _count_identifiers(const parse_tree& src)
@@ -5415,6 +5425,7 @@
 	_label_one_literal(dest,types);
 	assert(PARSE_EXPRESSION & dest.flags);
 }
+#/*cut-cpp*/
 
 // can't do much syntax-checking or immediate-evaluation here because of binary +/-
 // unary +/- syntax checking out out of place as it's needed by all of the unary operators
@@ -5447,8 +5458,8 @@
 	_label_one_literal(dest,types);
 	assert(PARSE_EXPRESSION & dest.flags);
 }
+#/*cut-cpp*/
 
-
 static void force_decimal_literal(parse_tree& dest,const char* src,const type_system& types)
 {
 	assert(src && *src);
@@ -10168,9 +10179,9 @@
 {
 	assert(src.is_raw_list());
 	_label_literals(src,types);
-	if (!_match_pairs(src)) return;
 	// handle core type specifiers
 	C99_notice_primary_type(src);
+	if (!_match_pairs(src)) return;
 	// struct/union/enum specifiers can occur in all sorts of strange places
 	C99_notice_struct_union_enum(src);
 }
@@ -10322,9 +10333,9 @@
 	CPP_handle_pragma_relay(src);
 	_label_literals(src,types);
 	std::for_each(src.begin<0>(),src.end<0>(),_label_CPP_literal);	// intercepts: true, false, this
-	if (!_match_pairs(src)) return;
 	// handle core type specifiers
 	CPP_notice_primary_type(src);
+	if (!_match_pairs(src)) return;
 	// do context-free part of qualified-names
 	CPP_notice_scope_glue(src);
 	// class/struct/union/enum specifiers can occur in all sorts of strange places

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-20 18:10:59 UTC (rev 442)
+++ trunk/CSupport_pp.cpp	2010-05-22 07:39:32 UTC (rev 443)
@@ -1,4 +1,4 @@
-// CSupport_pp.cpp
+// CSupport.cpp
 // support for C/C++ parsing
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
@@ -3050,376 +3050,6 @@
 		};
 }
 
-/* deal with following type catalog
-atomic:
-bool ?bool?	(_Bool for C)
-char16_t ?char16_t? (C++0x, don't worry about this yet)
-char32_t ?char32_t? (C++0x, don't worry about this yet)
-wchar_t ?wchar_t? (C++ only)
-void ?void?
-
-participates in composite:
-char ?char?
-unsigned char ?unsigned char?
-signed char ?signed char?
-
-unsigned ?unsigned int?
-unsigned int ?unsigned int?
-
-signed ?int?
-signed int ?int?
-int ?int?
-
-unsigned short int ?unsigned short int?
-unsigned short ?unsigned short int?
-
-unsigned long int ?unsigned long int?
-unsigned long ?unsigned long int?
-
-unsigned long long int ?unsigned long long int?
-unsigned long long ?unsigned long long int?
-
-signed long int ?long int?
-signed long ?long int?
-
-signed long long int ?long long int?
-signed long long ?long long int?
-long long int ?long long int?
-long long ?long long int?
-
-long int ?long int?
-long ?long int?
-
-signed short int ?short int?
-signed short ?short int?
-short int ?short int?
-short ?short int?
-
-float ?float?
-double ?double?
-long double ?long double?
-float _Complex "float"
-double _Complex "double"
-long double _Complex "long double"
-
-in any case, use up a flag to track "positively typename" status
-*/
-static int _C99_CPP_notice_multitoken_primary_type_token_to_index(const zaimoni::POD_pair<const char*,size_t> src)
-{
-	assert(NULL!=src.first);
-	return token_is_string<3>(src,"int") ? 1
-		: token_is_string<4>(src,"char") ? 2
-		: token_is_string<5>(src,"short") ? 3
-		: token_is_string<4>(src,"long") ? 4 : 0;
-}
-
-static size_t _C99_CPP_notice_multitoken_primary_type(parse_tree& src, size_t i)
-{
-	assert(src.size<0>()>i);
-	parse_tree& x = src.c_array<0>()[i];
-	assert(!(PARSE_PRIMARY_TYPE & x.flags) && NULL!=x.index_tokens[0].token.first);
-	if (token_is_string<4>(x.index_tokens[0].token,"char"))
-		{
-		x.type_code.set_type(C_TYPE::CHAR);
-		x.flags |= PARSE_PRIMARY_TYPE;
-		return 0;
-		}
-	else if (token_is_string<3>(x.index_tokens[0].token,"int"))
-		{
-		x.type_code.set_type(C_TYPE::INT);
-		x.flags |= PARSE_PRIMARY_TYPE;
-		return 0;
-		}
-	else if (token_is_string<5>(x.index_tokens[0].token,"short"))
-		{
-		const bool short_int = i<src.size<0>()-1 && robust_token_is_string<3>(src.c_array<0>()[i+1].index_tokens[0].token,"int");
-		if (short_int)
-			x.grab_index_token_from_str_literal<0>("short int",0);	//! \bug should use something informative; identifier not fine
-		x.type_code.set_type(C_TYPE::SHRT);
-		x.flags |= PARSE_PRIMARY_TYPE;
-		return short_int;
-		}
-	else if (token_is_string<5>(x.index_tokens[0].token,"float"))
-		{
-		const bool float__Complex = i<src.size<0>()-1 && robust_token_is_string<8>(src.c_array<0>()[i+1].index_tokens[0].token,"_Complex");
-		if (float__Complex)
-			{
-			x.grab_index_token_from_str_literal<0>("float _Complex",0);	//! \bug should use something informative; identifier not fine
-			x.type_code.set_type(C_TYPE::FLOAT__COMPLEX);
-			}
-		else
-			x.type_code.set_type(C_TYPE::FLOAT);
-		x.flags |= PARSE_PRIMARY_TYPE;
-		return float__Complex;
-		}
-	else if (token_is_string<6>(x.index_tokens[0].token,"double"))
-		{
-		const bool double__Complex = i<src.size<0>()-1 && robust_token_is_string<8>(src.c_array<0>()[i+1].index_tokens[0].token,"_Complex");
-		if (double__Complex)
-			{
-			x.grab_index_token_from_str_literal<0>("double _Complex",0);	//! \bug should use something informative; identifier not fine
-			x.type_code.set_type(C_TYPE::DOUBLE__COMPLEX);
-			}
-		else
-			x.type_code.set_type(C_TYPE::DOUBLE);
-		x.flags |= PARSE_PRIMARY_TYPE;
-		return double__Complex;
-		}
-	else if (token_is_string<4>(x.index_tokens[0].token,"long"))
-		{
-		const int keyindex 	= (i>=src.size<0>()-1 || NULL==src.data<0>()[i+1].index_tokens[0].token.first) ? 0 
-							: token_is_string<3>(src.c_array<0>()[i+1].index_tokens[0].token,"int") ? 1
-							: token_is_string<4>(src.c_array<0>()[i+1].index_tokens[0].token,"long") ? 2
-							: token_is_string<6>(src.c_array<0>()[i+1].index_tokens[0].token,"double") ? 3 : 0;
-		switch(keyindex)
-		{
-		case 3:	// long double
-			{
-			const bool long_double__Complex = (i<src.size<0>()-2 && robust_token_is_string<8>(src.c_array<0>()[i+2].index_tokens[0].token,"_Complex"));
-			if (long_double__Complex)
-				{
-				x.grab_index_token_from_str_literal<0>("long double _Complex",0);	//! \bug should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::LDOUBLE__COMPLEX);
-				}
-			else{
-				x.grab_index_token_from_str_literal<0>("long double",0);	//! \bug should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::LDOUBLE);
-				}
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return 1+long_double__Complex;
-			}
-		case 2:	// long long
-			{
-			const bool long_long_int = (i<src.size<0>()-2 && robust_token_is_string<3>(src.c_array<0>()[i+2].index_tokens[0].token,"int"));
-			x.grab_index_token_from_str_literal<0>(long_long_int ? "long long int" : "long long",0);	//! \bug should use something informative; identifier not fine
-			x.type_code.set_type(C_TYPE::LLONG);
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return 1+long_long_int;
-			}
-		case 1:	// long int
-			x.grab_index_token_from_str_literal<0>("long int",0);	//! \bug should use something informative; identifier not fine
-			// intentional fall-through
-		case 0:	// long
-			src.c_array<0>()[i].type_code.set_type(C_TYPE::LONG);
-			src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
-			return keyindex;
-		}
-		}
-	else if (token_is_string<6>(x.index_tokens[0].token,"signed"))
-		{
-		const int key_index	= (i>=src.size<0>()-1 || NULL==src.data<0>()[i+1].index_tokens[0].token.first) ? 0
-							: _C99_CPP_notice_multitoken_primary_type_token_to_index(src.data<0>()[i+1].index_tokens[0].token);
-		switch(key_index)
-		{
-		case 4:	// signed long
-			{
-			const int key_index2	= (i>=src.size<0>()-2 || NULL==src.data<0>()[i+2].index_tokens[0].token.first) ? 0
-									: token_is_string<3>(src.c_array<0>()[i+2].index_tokens[0].token,"int") ? 1
-									: token_is_string<4>(src.c_array<0>()[i+2].index_tokens[0].token,"long") ? 2 : 0;
-			switch(key_index2)
-			{
-			case 2:	// signed long long
-				{
-				const bool signed_long_long_int = i<src.size<0>()-3 && robust_token_is_string<3>(src.c_array<0>()[i+3].index_tokens[0].token,"int");
-				x.grab_index_token_from_str_literal<0>(signed_long_long_int ? "signed long long int" : "signed long long",0);	//! \todo should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::LLONG);
-				x.flags |= PARSE_PRIMARY_TYPE;
-				return 2+signed_long_long_int;
-				}
-			case 1:	// signed long int
-				{
-				x.grab_index_token_from_str_literal<0>("signed long int",0);	//! \bug should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::LONG);
-				x.flags |= PARSE_PRIMARY_TYPE;
-				return 2;
-				}
-			case 0:	// signed long
-				{
-				x.grab_index_token_from_str_literal<0>("signed long",0);	//! \bug should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::LONG);
-				x.flags |= PARSE_PRIMARY_TYPE;
-				return 1;
-				}
-			}
-			break;
-			}
-		case 3:	// signed short
-			{
-			x.grab_index_token_from_str_literal<0>("signed short",0);	//! \bug should use something informative; identifier not fine
-			x.type_code.set_type(C_TYPE::SHRT);
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return 1;
-			}
-		case 2:	// signed char
-			{
-			x.grab_index_token_from_str_literal<0>("signed char",0);	//! \bug should use something informative; identifier not fine
-			x.type_code.set_type(C_TYPE::SCHAR);
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return 1;
-			}
-		case 1:	// signed int
-			x.grab_index_token_from_str_literal<0>("signed int",0);	//! \bug should use something informative; identifier not fine
-			// intentional fall-through
-		case 0:	// signed
-			x.type_code.set_type(C_TYPE::INT);
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return key_index;
-		}
-		}
-	else if (token_is_string<8>(x.index_tokens[0].token,"unsigned"))
-		{
-		const int key_index	= (i>=src.size<0>()-1 || NULL==src.data<0>()[i+1].index_tokens[0].token.first) ? 0
-							: _C99_CPP_notice_multitoken_primary_type_token_to_index(src.data<0>()[i+1].index_tokens[0].token);
-		switch(key_index)
-		{
-		case 4:	// unsigned long
-			{
-			const int key_index2	= (i>=src.size<0>()-2 || NULL==src.data<0>()[i+2].index_tokens[0].token.first) ? 0
-									: token_is_string<3>(src.c_array<0>()[i+2].index_tokens[0].token,"int") ? 1
-									: token_is_string<4>(src.c_array<0>()[i+2].index_tokens[0].token,"long") ? 2 : 0;
-			switch(key_index2)
-			{
-			case 2:	// unsigned long long
-				{
-				const bool unsigned_long_long_int = i<src.size<0>()-3 && robust_token_is_string<3>(src.c_array<0>()[i+3].index_tokens[0].token,"int");
-				x.grab_index_token_from_str_literal<0>(unsigned_long_long_int ? "unsigned long long int" : "unsigned long long",0);	//! \todo should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::ULLONG);
-				x.flags |= PARSE_PRIMARY_TYPE;
-				return 2+unsigned_long_long_int;
-				}
-			case 1:	// unsigned long int
-				{
-				x.grab_index_token_from_str_literal<0>("unsigned long int",0);	//! \bug should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::ULONG);
-				x.flags |= PARSE_PRIMARY_TYPE;
-				return 2;
-				}
-			case 0:	// unsigned long
-				{
-				x.grab_index_token_from_str_literal<0>("unsigned long",0);	//! \bug should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::ULONG);
-				x.flags |= PARSE_PRIMARY_TYPE;
-				return 1;
-				}
-			}
-			break;
-			}
-		case 3:	// unsigned short
-			{
-			x.grab_index_token_from_str_literal<0>("unsigned short",0);	//! \bug should use something informative; identifier not fine
-			x.type_code.set_type(C_TYPE::USHRT);
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return 1;
-			}
-		case 2:	// unsigned char
-			{
-			x.grab_index_token_from_str_literal<0>("unsigned char",0);	//! \bug should use something informative; identifier not fine
-			x.type_code.set_type(C_TYPE::UCHAR);
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return 1;
-			}
-		case 1:	// unsigned int
-			x.grab_index_token_from_str_literal<0>("unsigned int",0);	//! \bug should use something informative; identifier not fine
-			// intentional fall-through
-		case 0:	// unsigned
-			x.type_code.set_type(C_TYPE::UINT);
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return key_index;
-		}
-		}
-	else if (token_is_string<8>(x.index_tokens[0].token,"_Complex"))
-		simple_error(x," does not have immediately preceding floating point type (C99 6.7.2p2)");
-	return 0;
-}
-
-static void C99_notice_primary_type(parse_tree& src)
-{
-	if (NULL!=src.index_tokens[0].token.first)
-		{
-		if (token_is_string<5>(src.index_tokens[0].token,"_Bool"))
-			{
-			src.type_code.set_type(C_TYPE::BOOL);
-			src.flags |= PARSE_PRIMARY_TYPE;
-			return;
-			};
-		if (token_is_string<4>(src.index_tokens[0].token,"void"))
-			{
-			src.type_code.set_type(C_TYPE::VOID);
-			src.flags |= PARSE_PRIMARY_TYPE;
-			return;
-			}
-		}
-
-	size_t i = 0;
-	size_t offset = 0;
-	while(i+offset<src.size<0>())
-		{
-		{
-		parse_tree& tmp_ref = src.c_array<0>()[i];
-		C99_notice_primary_type(tmp_ref);
-		const size_t truncate_by = (!(PARSE_PRIMARY_TYPE & tmp_ref.flags) && NULL!=tmp_ref.index_tokens[0].token.first) 
-								 ? _C99_CPP_notice_multitoken_primary_type(src,i) : 0;
-		if (0<truncate_by)
-			{
-			src.DestroyNAtAndRotateTo<0>(truncate_by,i+1,src.size<0>()-offset);
-			offset += truncate_by;
-			}
-		}
-		// disallow consecutive primary types
-		if (0<i && (PARSE_TYPE & src.c_array<0>()[i].flags) && (PARSE_TYPE & src.c_array<0>()[i-1].flags))
-			simple_error(src.c_array<0>()[i]," immediately after another type");
-		++i;
-		};
-	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
-}
-
-static void CPP_notice_primary_type(parse_tree& src)
-{
-	if (NULL!=src.index_tokens[0].token.first)
-		{
-		if (token_is_string<4>(src.index_tokens[0].token,"bool"))
-			{
-			src.type_code.set_type(C_TYPE::BOOL);
-			src.flags |= PARSE_PRIMARY_TYPE;
-			return;
-			};
-		if (token_is_string<7>(src.index_tokens[0].token,"wchar_t"))
-			{
-			src.type_code.set_type(C_TYPE::WCHAR_T);
-			src.flags |= PARSE_PRIMARY_TYPE;
-			return;
-			}
-		if (token_is_string<4>(src.index_tokens[0].token,"void"))
-			{
-			src.type_code.set_type(C_TYPE::VOID);
-			src.flags |= PARSE_PRIMARY_TYPE;
-			return;
-			}
-		}
-
-	size_t i = 0;
-	size_t offset = 0;
-	while(i+offset<src.size<0>())
-		{
-		{
-		parse_tree& tmp_ref = src.c_array<0>()[i];
-		CPP_notice_primary_type(tmp_ref);
-		const size_t truncate_by = (!(PARSE_PRIMARY_TYPE & tmp_ref.flags) && NULL!=tmp_ref.index_tokens[0].token.first) 
-								 ? _C99_CPP_notice_multitoken_primary_type(src,i) : 0;
-		if (0<truncate_by)
-			{
-			src.DestroyNAtAndRotateTo<0>(truncate_by,i+1,src.size<0>()-offset);
-			offset += truncate_by;
-			}
-		}
-		// disallow consecutive types
-		if (0<i && (PARSE_TYPE & src.c_array<0>()[i].flags) && (PARSE_TYPE & src.c_array<0>()[i-1].flags))
-			simple_error(src.c_array<0>()[i]," immediately after another primary type");
-		++i;
-		};
-	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
-}
-
 //! \todo generalize -- function pointer parameter target, functor target
 static size_t _count_identifiers(const parse_tree& src)
 {
@@ -4871,39 +4501,6 @@
 	assert(PARSE_EXPRESSION & dest.flags);
 }
 
-// can't do much syntax-checking or immediate-evaluation here because of binary +/-
-// unary +/- syntax checking out out of place as it's needed by all of the unary operators
-//! \throw std::bad_alloc()
-static void uint_to_token(uintmax_t src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
-{
-	assert(C_TYPE::INT<=base_type_index && C_TYPE::ULLONG>=base_type_index);
-	const char* const suffix = literal_suffix(base_type_index);
-	char* buf = _new_buffer_nonNULL_throws<char>((VM_MAX_BIT_PLATFORM/3)+4);
-	dest.second = literal_flags(base_type_index);
-	dest.second |= C_TESTFLAG_DECIMAL;
-	z_umaxtoa(src_int,buf,10);
-	assert(!suffix || 3>=strlen(suffix));
-	assert(dest.second);
-	if (suffix) strcat(buf,suffix);
-
-	// shrinking realloc should be no-fail
-	dest.first = REALLOC(buf,ZAIMONI_LEN_WITH_NULL(strlen(buf)));
-}
-
-//! \throw std::bad_alloc()
-static void uint_to_literal(parse_tree& dest, uintmax_t src_int,const parse_tree& src,const type_system& types)
-{
-	POD_pair<char*,lex_flags> new_token;
-	uint_to_token(src_int,src.type_code.base_type_index,new_token);
-	dest.clear();
-	dest.grab_index_token_from<0>(new_token.first,new_token.second);
-	dest.grab_index_token_location_from<0,0>(src);
-	assert((C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_STRING_LITERAL | C_TESTFLAG_PP_NUMERAL) & dest.index_tokens[0].flags);
-	_label_one_literal(dest,types);
-	assert(PARSE_EXPRESSION & dest.flags);
-}
-
-
 static void force_decimal_literal(parse_tree& dest,const char* src,const type_system& types)
 {
 	assert(src && *src);



From zaimoni at mail.berlios.de  Mon May 24 22:22:19 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 24 May 2010 22:22:19 +0200
Subject: [Zcplusplus-commits] r444 - trunk
Message-ID: <201005242022.o4OKMJqs030077@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-24 22:22:08 +0200 (Mon, 24 May 2010)
New Revision: 444

Added:
   trunk/kleene_star.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
Log:
start rewriting context-free type recognizer

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-22 07:39:32 UTC (rev 443)
+++ trunk/CSupport.cpp	2010-05-24 20:22:08 UTC (rev 444)
@@ -36,6 +36,7 @@
 #/*cut-cpp*/
 #include "enum_type.hpp"
 #include "struct_type.hpp"
+#include "kleene_star.hpp"
 #/*cut-cpp*/
 #include "CheckReturn.hpp"
 
@@ -990,6 +991,7 @@
 
 BOOST_STATIC_ASSERT(STATIC_SIZE(C_atomic_types)==C_TYPE_MAX);
 BOOST_STATIC_ASSERT(STATIC_SIZE(CPP_atomic_types)==CPP_TYPE_MAX);
+#/*cut-cpp*/
 
 static const POD_pair<const char*,size_t> C99_decl_specifiers[] =
 	{	DICT_STRUCT("typedef"),
@@ -1037,6 +1039,91 @@
 BOOST_STATIC_ASSERT(C99_CPP0X_DECLSPEC_CONST==type_spec::_const);
 BOOST_STATIC_ASSERT(C99_CPP0X_DECLSPEC_VOLATILE==type_spec::_volatile);
 
+// todo: rewrite of decl-specifiers that actually can handle the reordering requirements.  
+// decl-specifier-seq is mostly context-free, so first-pass should be in 
+// the context-free section, if not integrated preprocessor
+static const POD_pair<const char*,size_t> C99_decl_specifier_list[] =
+	{	DICT_STRUCT("typedef"),
+		DICT_STRUCT("const"),
+		DICT_STRUCT("volatile"),
+		DICT_STRUCT("restrict"),	// C99-specific
+		DICT_STRUCT("register"),
+		DICT_STRUCT("static"),
+		DICT_STRUCT("extern"),
+		DICT_STRUCT("inline"),
+		DICT_STRUCT("auto"),
+		DICT_STRUCT("void"),
+		DICT_STRUCT("char"),
+		DICT_STRUCT("short"),
+		DICT_STRUCT("int"),
+		DICT_STRUCT("long"),
+		DICT_STRUCT("float"),
+		DICT_STRUCT("double"),
+		DICT_STRUCT("signed"),
+		DICT_STRUCT("unsigned"),
+		DICT_STRUCT("_Bool"),
+		DICT_STRUCT("_Complex"),
+		DICT_STRUCT("_Thread_Local"),	// C1X, actually
+	};
+
+// we implement C++0X, not C++98.  auto as storage specifier is pretty much a waste of source code anyway.
+// may have to invoke weirdness to deal with C headers that use restrict (and link with C standard library functions!)
+// we don't handle char16_t and char32_t yet
+static const POD_pair<const char*,size_t> CPP0X_decl_specifier_list[] =
+	{	DICT_STRUCT("typedef"),
+		DICT_STRUCT("const"),
+		DICT_STRUCT("volatile"),
+		DICT_STRUCT("wchar_t"),	// C++-specific
+		DICT_STRUCT("register"),
+		DICT_STRUCT("static"),
+		DICT_STRUCT("extern"),
+		DICT_STRUCT("inline"),
+		DICT_STRUCT("auto"),	// storage-class in C, type-specifier in C++
+		DICT_STRUCT("void"),
+		DICT_STRUCT("char"),
+		DICT_STRUCT("short"),
+		DICT_STRUCT("int"),
+		DICT_STRUCT("long"),
+		DICT_STRUCT("float"),
+		DICT_STRUCT("double"),
+		DICT_STRUCT("signed"),
+		DICT_STRUCT("unsigned"),
+		DICT_STRUCT("bool"),	// _Bool in C
+		DICT_STRUCT("_Complex"),	// extension
+		DICT_STRUCT("thread_local"),	// C1X _Thread_Local
+		DICT_STRUCT("constexpr"),
+		DICT_STRUCT("mutable"),
+		DICT_STRUCT("virtual"),
+		DICT_STRUCT("explicit"),
+		DICT_STRUCT("friend")
+	};
+
+#define C99_CPP_TYPEDEF_IDX 0
+#define C99_CPP_CONST_IDX 1
+#define C99_CPP_VOLATILE_IDX 2
+#define C99_RESTRICT_IDX 3
+#define C99_CPP_REGISTER_IDX 4
+#define C99_CPP_STATIC_IDX 5
+#define C99_CPP_EXTERN_IDX 6
+#define C99_CPP_AUTO_IDX 8
+#define C1X_CPP0X_THREAD_LOCAL_IDX 20
+#define CPP_MUTABLE_IDX 22
+
+size_t C99_invariant_decl_specifier(const char* const x)
+{
+	const errr i = linear_find(x,C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list));
+	if (STATIC_SIZE(C99_decl_specifier_list)>i) return i;
+	return (size_t)(-1);
+}
+
+size_t CPP0X_invariant_decl_specifier(const char* const x)
+{
+	const errr i = linear_find(x,CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list));
+	if (STATIC_SIZE(CPP0X_decl_specifier_list)>i) return i;
+	return (size_t)(-1);
+}	
+#/*cut-cpp*/
+
 #undef DICT2_STRUCT
 #undef DICT_STRUCT
 
@@ -3449,7 +3536,162 @@
 {
 	assert(src.is_raw_list());
 	std::for_each(src.begin<0>(),src.end<0>(),C99_notice_primary_type_atomic);
+
 	size_t i = 0;
+	kleene_star<STATIC_SIZE(C99_decl_specifier_list),size_t (*)(const char*)> invariant_decl_scanner(C99_invariant_decl_specifier);
+	do	{
+		if (src.data<0>()[i].is_atomic() && invariant_decl_scanner(src.data<0>()[i].index_tokens[0].token.first))
+			{
+			bool have_warned_about_register = false;
+			bool have_warned_about_static = false;
+			bool have_warned_about_extern = false;
+			bool have_warned_about_thread_local = false;
+			bool have_warned_about_auto = false;
+			bool have_warned_about_typedef = false;
+			bool have_warned_about_const = false;
+			bool have_warned_about_volatile = false;
+			bool have_warned_about_restrict = false;
+
+			size_t offset = 0;
+			while(src.size<0>()>i+ ++offset && invariant_decl_scanner(src.data<0>()[i+offset].index_tokens[0].token.first))
+				{	// C1X 6.7.1p2: at most one storage-class specifier, except _Thread_Local may stack with static or extern
+				if (1<invariant_decl_scanner.count(C99_CPP_REGISTER_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_register)
+						{
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing prohibited duplicated register storage class and continuing (C99 6.7.1p2)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_register = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				if (1<invariant_decl_scanner.count(C99_CPP_STATIC_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_static)
+						{
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing prohibited duplicated static storage class and continuing (C99 6.7.1p2)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_static = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				if (1<invariant_decl_scanner.count(C99_CPP_EXTERN_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_extern)
+						{
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing prohibited duplicated extern storage class and continuing (C99 6.7.1p2)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_extern = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				if (1<invariant_decl_scanner.count(C1X_CPP0X_THREAD_LOCAL_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_thread_local)
+						{
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing prohibited duplicated _Thread_Local storage class and continuing (C1X 6.7.1p2)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_thread_local = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				if (1<invariant_decl_scanner.count(C99_CPP_AUTO_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_auto)
+						{
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing prohibited duplicated auto storage class and continuing (C99 6.7.1p2)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_auto = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				if (1<invariant_decl_scanner.count(C99_CPP_TYPEDEF_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_typedef)
+						{
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing prohibited duplicated typedef storage class and continuing (C99 6.7.1p2)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_typedef = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				// C1X 6.7.3p3: duplicate type-qualifiers should be cleaned (warn unless -Wno-OAOO or -Wno-DRY)
+				if (1<invariant_decl_scanner.count(C99_CPP_CONST_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_const)
+						{
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing redundant const type qualifier (C99 6.7.3p4)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_const = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				if (1<invariant_decl_scanner.count(C99_CPP_VOLATILE_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_volatile)
+						{
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing redundant volatile type qualifier (C99 6.7.3p4)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_volatile = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				if (1<invariant_decl_scanner.count(C99_RESTRICT_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_restrict)
+						{
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing redundant restrict type qualifier (C99 6.7.3p4)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_restrict = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				};
+
+			//! \todo handle allowed sequences of type-qualifiers (do need second pass later)
+			// defer handling: _Thread_Local, typedef, other storage class issues
+			invariant_decl_scanner.clear();
+			}
+		}
+	while(src.size<0>()> ++i);
+
+	i = 0;
 	size_t offset = 0;
 	while(i+offset<src.size<0>())
 		{
@@ -3500,7 +3742,164 @@
 {
 	assert(src.is_raw_list());
 	std::for_each(src.begin<0>(),src.end<0>(),CPP_notice_primary_type_atomic);
+
 	size_t i = 0;
+	kleene_star<STATIC_SIZE(CPP0X_decl_specifier_list),size_t (*)(const char*)> invariant_decl_scanner(CPP0X_invariant_decl_specifier);
+	do	{
+		if (src.data<0>()[i].is_atomic() && invariant_decl_scanner(src.data<0>()[i].index_tokens[0].token.first))
+			{
+			bool have_warned_about_register = false;
+			bool have_warned_about_static = false;
+			bool have_warned_about_extern = false;
+			bool have_warned_about_thread_local = false;
+			bool have_warned_about_mutable = false;
+			bool have_warned_about_typedef = false;
+			bool have_warned_about_const = false;
+			bool have_warned_about_volatile = false;
+			bool using_linkage = false;
+			size_t offset = 0;
+
+			// C++0X 7.5: intercept linkage specifications here, warn if discarding (must accept "C" and "C++")
+			if (C99_CPP_EXTERN_IDX==invariant_decl_scanner[0] && 1<src.size<0>()-i && (C_TESTFLAG_STRING_LITERAL & src.data<0>()[i+1].flags))
+				{	//! \todo should accept escape codes here as well
+				if (strcmp(src.data<0>()[i+1].index_tokens[0].token.first,"\"C\"") && strcmp(src.data<0>()[i+1].index_tokens[0].token.first,"\"C++\""))
+					{
+					message_header(src.data<0>()[i+1].index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("discarding unrecognized linkage (only C, C++ required: C++0X 7.5p2)");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					src.DeleteIdx<0>(i+1);
+					}
+				else
+					using_linkage = true;
+				}
+			
+			while(src.size<0>()>i+ ++offset+using_linkage && invariant_decl_scanner(src.data<0>()[i+offset+using_linkage].index_tokens[0].token.first))
+				{	// C++0X 7.1.1p1: at most one storage-class specifier, except thread_local may stack with static or extern
+				if (1<invariant_decl_scanner.count(C99_CPP_REGISTER_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_register)
+						{
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing prohibited duplicated register storage class and continuing (C++0X 7.1.1p1)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_register = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				if (1<invariant_decl_scanner.count(C99_CPP_STATIC_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_static)
+						{
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing prohibited duplicated static storage class and continuing (C++0X 7.1.1p1)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_static = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				if (1<invariant_decl_scanner.count(C99_CPP_EXTERN_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_extern)
+						{
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing prohibited duplicated extern storage class and continuing (C++0X 7.1.1p1)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_extern = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				if (1<invariant_decl_scanner.count(C1X_CPP0X_THREAD_LOCAL_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_thread_local)
+						{
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing prohibited duplicated thread_local storage class and continuing (C++0X 7.1.1p1)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_thread_local = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				if (1<invariant_decl_scanner.count(CPP_MUTABLE_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_mutable)
+						{
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing prohibited duplicated mutable storage class and continuing (C++0X 7.1.1p1)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_mutable = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				if (1<invariant_decl_scanner.count(C99_CPP_TYPEDEF_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_typedef)
+						{
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing prohibited duplicated typedef specifier and continuing (C++0X 7.1.3p1)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_typedef = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				// C++0X 7.1.6.1: duplicate cv-qualifiers should be cleaned (warn unless -Wno-OAOO or -Wno-DRY)
+				if (1<invariant_decl_scanner.count(C99_CPP_CONST_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_const)
+						{
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing redundant const cv-qualifier (C++0X 7.1.6.1p1)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_const = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				if (1<invariant_decl_scanner.count(C99_CPP_VOLATILE_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_volatile)
+						{
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_volatile = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				};
+			
+			//! \todo handle allowed sequences of type-qualifiers (do need second pass later)
+			// defer handling thread_local, typedef restrictions 
+			invariant_decl_scanner.clear();
+			}
+		}
+	while(src.size<0>()> ++i);
+
+	i = 0;
 	size_t offset = 0;
 	while(i+offset<src.size<0>())
 		{
@@ -13800,7 +14199,28 @@
 	assert(C_TYPE::DOUBLE__COMPLEX==linear_find("double _Complex",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::LDOUBLE__COMPLEX==linear_find("long double _Complex",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::WCHAR_T==linear_find("wchar_t",CPP_atomic_types,CPP_TYPE_MAX)+1);
+#/*cut-cpp*/
 
+	assert(C99_CPP_TYPEDEF_IDX==linear_find("typedef",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_TYPEDEF_IDX==linear_find("typedef",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_CONST_IDX==linear_find("const",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_CONST_IDX==linear_find("const",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_VOLATILE_IDX==linear_find("volatile",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_VOLATILE_IDX==linear_find("volatile",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_RESTRICT_IDX==linear_find("restrict",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_REGISTER_IDX==linear_find("register",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_REGISTER_IDX==linear_find("register",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_STATIC_IDX==linear_find("static",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_STATIC_IDX==linear_find("static",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_EXTERN_IDX==linear_find("extern",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_EXTERN_IDX==linear_find("extern",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_AUTO_IDX==linear_find("auto",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_AUTO_IDX==linear_find("auto",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("_Thread_Local",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("thread_local",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(CPP_MUTABLE_IDX==linear_find("mutable",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+#/*cut-cpp*/
+
 	/* does bool converts_to_integerlike(size_t base_type_index) work */
 	BOOST_STATIC_ASSERT(!(C_TYPE::BOOL<=C_TYPE::NOT_VOID && C_TYPE::NOT_VOID<=C_TYPE::INTEGERLIKE));
 	BOOST_STATIC_ASSERT(!(C_TYPE::BOOL<=C_TYPE::VOID && C_TYPE::VOID<=C_TYPE::INTEGERLIKE));

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-22 07:39:32 UTC (rev 443)
+++ trunk/CSupport_pp.cpp	2010-05-24 20:22:08 UTC (rev 444)
@@ -1,4 +1,4 @@
-// CSupport.cpp
+// CSupport_pp.cpp
 // support for C/C++ parsing
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
@@ -913,52 +913,6 @@
 BOOST_STATIC_ASSERT(STATIC_SIZE(C_atomic_types)==C_TYPE_MAX);
 BOOST_STATIC_ASSERT(STATIC_SIZE(CPP_atomic_types)==CPP_TYPE_MAX);
 
-static const POD_pair<const char*,size_t> C99_decl_specifiers[] =
-	{	DICT_STRUCT("typedef"),
-		DICT_STRUCT("const"),
-		DICT_STRUCT("volatile"),
-		DICT_STRUCT("restrict"),
-		DICT_STRUCT("register"),
-		DICT_STRUCT("static"),
-		DICT_STRUCT("extern"),
-		DICT_STRUCT("inline"),
-		DICT_STRUCT("auto")
-	};
-
-// we implement C++0X, not C++98.  auto as storage specifier is pretty much a waste of source code anyway.
-// may have to invoke weirdness to deal with C headers that use restrict (and link with C standard library functions!)
-static const POD_pair<const char*,size_t> CPP0X_decl_specifiers[] =
-	{	DICT_STRUCT("typedef"),
-		DICT_STRUCT("const"),
-		DICT_STRUCT("volatile"),
-		DICT_STRUCT("thread_local"),
-		DICT_STRUCT("register"),
-		DICT_STRUCT("static"),
-		DICT_STRUCT("extern"),
-		DICT_STRUCT("inline"),
-		DICT_STRUCT("constexpr"),
-		DICT_STRUCT("mutable"),
-		DICT_STRUCT("virtual"),
-		DICT_STRUCT("explicit"),
-		DICT_STRUCT("friend")
-	};
-
-#define C99_CPP0X_DECLSPEC_TYPEDEF (1ULL<<0)
-#define C99_CPP0X_DECLSPEC_CONST (1ULL<<1)
-#define C99_CPP0X_DECLSPEC_VOLATILE (1ULL<<2)
-#define C99_CPP0X_DECLSPEC_REGISTER (1ULL<<4)
-#define C99_CPP0X_DECLSPEC_STATIC (1ULL<<5)
-#define C99_CPP0X_DECLSPEC_EXTERN (1ULL<<6)
-#define C99_CPP0X_DECLSPEC_INLINE (1ULL<<7)
-#define C99_DECLSPEC_AUTO (1ULL<<8)
-#define CPP_DECLSPEC_MUTABLE (1ULL<<9)
-#define CPP_DECLSPEC_VIRTUAL (1ULL<<10)
-#define CPP_DECLSPEC_EXPLICIT (1ULL<<11)
-#define CPP_DECLSPEC_FRIEND (1ULL<<12)
-
-BOOST_STATIC_ASSERT(C99_CPP0X_DECLSPEC_CONST==type_spec::_const);
-BOOST_STATIC_ASSERT(C99_CPP0X_DECLSPEC_VOLATILE==type_spec::_volatile);
-
 #undef DICT2_STRUCT
 #undef DICT_STRUCT
 

Added: trunk/kleene_star.hpp
===================================================================
--- trunk/kleene_star.hpp	2010-05-22 07:39:32 UTC (rev 443)
+++ trunk/kleene_star.hpp	2010-05-24 20:22:08 UTC (rev 444)
@@ -0,0 +1,65 @@
+// kleene_star.hpp
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+#ifndef KLEENE_STAR_HPP
+#define KLEENE_STAR_HPP 1
+
+#include "Zaimoni.STL/AutoPtr.hpp"
+
+// classifier should be a unary function, or function object, returning size_t.
+template<typename classifier>
+class kleene_star_core
+{
+protected:
+	zaimoni::autovalarray_ptr<size_t> result_scan;	// XXX should be some sort of specialized array (limited range allows compression)
+	classifier _detector;
+	kleene_star_core(classifier detector) : _detector(detector) {};
+	// default copy, assignment, destructor ok
+	size_t deleteIdx(size_t i)
+		{
+		size_t tmp = result_scan[i];
+		result_scan.DeleteIdx(i);
+		return tmp;		
+		};
+public:
+	size_t empty() const {return result_scan.empty();};
+	size_t size() const {return result_scan.size();};
+	size_t operator[](size_t i) const {assert(size()>i);return result_scan[i];};
+	size_t front() const {return result_scan.front();};
+	size_t back() const {return result_scan.back();};
+};
+
+template<size_t strict_ub_valid_detect, typename classifier>
+class kleene_star : public kleene_star_core<classifier>
+{
+private:
+	size_t detect_count[strict_ub_valid_detect];
+public:
+	kleene_star(classifier detector) : kleene_star_core<classifier>(detector) {memset(detect_count,0,sizeof(detect_count));};
+	// default copy, assignment, destructor ok
+	template<class T> bool operator()(T& x)
+		{
+		size_t result = _detector(x);
+		if (strict_ub_valid_detect<=result) return false;
+		if (!this->result_scan.InsertSlotAt(this->result_scan.size(),result))
+			throw std::bad_alloc();
+		++detect_count[result];
+		return true;
+		}
+
+	size_t count(size_t i) const {assert(strict_ub_valid_detect>i);return detect_count[i];};
+	void DeleteIdx(size_t i)
+		{
+		assert(this->size()>i);
+		--detect_count[this->deleteIdx(i)];
+		}
+	
+	// conventional glue
+	void clear()
+		{
+		this->result_scan.reset();
+		memset(detect_count,0,sizeof(detect_count));
+		}
+};
+
+#endif



From zaimoni at mail.berlios.de  Mon May 31 06:26:52 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 31 May 2010 06:26:52 +0200
Subject: [Zcplusplus-commits] r445 - trunk
Message-ID: <201005310426.o4V4Qq6q019232@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-31 06:26:48 +0200 (Mon, 31 May 2010)
New Revision: 445

Modified:
   trunk/CSupport_pp.cpp
   trunk/kleene_star.hpp
Log:
preparing to become C99/C++98 compliant regarding any-order type specifiers

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-05-24 20:22:08 UTC (rev 444)
+++ trunk/CSupport_pp.cpp	2010-05-31 04:26:48 UTC (rev 445)
@@ -869,7 +869,7 @@
 		DICT_STRUCT("short"),
 		DICT_STRUCT("unsigned short"),
 		DICT_STRUCT("int"),
-		DICT_STRUCT("unsigned int"),
+		DICT_STRUCT("unsigned"),
 		DICT_STRUCT("long"),
 		DICT_STRUCT("unsigned long"),
 		DICT_STRUCT("long long"),
@@ -894,7 +894,7 @@
 		DICT_STRUCT("short"),
 		DICT_STRUCT("unsigned short"),
 		DICT_STRUCT("int"),
-		DICT_STRUCT("unsigned int"),
+		DICT_STRUCT("unsigned"),
 		DICT_STRUCT("long"),
 		DICT_STRUCT("unsigned long"),
 		DICT_STRUCT("long long"),
@@ -9451,7 +9451,7 @@
 	assert(C_TYPE::SHRT==linear_find("short",C_atomic_types,C_TYPE_MAX)+1);
 	assert(C_TYPE::USHRT==linear_find("unsigned short",C_atomic_types,C_TYPE_MAX)+1);
 	assert(C_TYPE::INT==linear_find("int",C_atomic_types,C_TYPE_MAX)+1);
-	assert(C_TYPE::UINT==linear_find("unsigned int",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::UINT==linear_find("unsigned",C_atomic_types,C_TYPE_MAX)+1);
 	assert(C_TYPE::LONG==linear_find("long",C_atomic_types,C_TYPE_MAX)+1);
 	assert(C_TYPE::ULONG==linear_find("unsigned long",C_atomic_types,C_TYPE_MAX)+1);
 	assert(C_TYPE::LLONG==linear_find("long long",C_atomic_types,C_TYPE_MAX)+1);
@@ -9473,7 +9473,7 @@
 	assert(C_TYPE::SHRT==linear_find("short",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::USHRT==linear_find("unsigned short",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::INT==linear_find("int",CPP_atomic_types,CPP_TYPE_MAX)+1);
-	assert(C_TYPE::UINT==linear_find("unsigned int",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::UINT==linear_find("unsigned",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::LONG==linear_find("long",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::ULONG==linear_find("unsigned long",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::LLONG==linear_find("long long",CPP_atomic_types,CPP_TYPE_MAX)+1);

Modified: trunk/kleene_star.hpp
===================================================================
--- trunk/kleene_star.hpp	2010-05-24 20:22:08 UTC (rev 444)
+++ trunk/kleene_star.hpp	2010-05-31 04:26:48 UTC (rev 445)
@@ -27,6 +27,12 @@
 	size_t operator[](size_t i) const {assert(size()>i);return result_scan[i];};
 	size_t front() const {return result_scan.front();};
 	size_t back() const {return result_scan.back();};
+	bool scan(const size_t target, size_t& offset, const size_t origin = 0) const;
+	bool scan(const size_t target, const size_t target2, size_t& offset, size_t& offset2, const size_t origin = 0) const;
+	bool scan(size_t* target, size_t scan_len, size_t* offset, const size_t origin = 0) const;
+	size_t scan_nofail(const size_t target, const size_t origin = 0) const {size_t tmp; if (!scan(target,tmp,origin)) _fatal_code("kleene_star<...>::scan_nofail failed",3); return tmp;};
+	void scan_nofail(const size_t target, const size_t target2, size_t& offset, size_t& offset2, const size_t origin = 0) const{if (!scan(target,target2,offset,offset2,origin)) _fatal_code("kleene_star<...>::scan_nofail failed",3);};
+	void scan_nofail(size_t* target, size_t scan_len, size_t* offset, const size_t origin = 0) const{if (!scan(target,scan_len,offset,origin)) _fatal_code("kleene_star<...>::scan_nofail failed",3);};
 };
 
 template<size_t strict_ub_valid_detect, typename classifier>
@@ -62,4 +68,67 @@
 		}
 };
 
+template<typename classifier>
+bool kleene_star_core<classifier>::scan(const size_t target, size_t& offset, const size_t origin) const
+{
+	size_t i = 0;
+	while(result_scan.size()>i+origin)
+		{
+		if (target==result_scan[i+origin])
+			return offset = i,true;
+		++i;
+		};
+	return false;
+}
+
+template<typename classifier>
+bool kleene_star_core<classifier>::scan(const size_t target, const size_t target2, size_t& offset, size_t& offset2, const size_t origin) const
+{
+	size_t i = 0;
+	while(result_scan.size()>i+origin)
+		{
+		if (target==result_scan[i+origin])
+			{
+			if (!scan(target2,offset2,i+origin+1)) return false;
+			return ++offset2,offset = i,true;
+			};
+		if (target2==result_scan[i+origin])
+			{
+			if (!scan(target,offset2,i+origin+1)) return false;
+			return ++offset2,offset = i,true;
+			}
+		++i;
+		}
+	return false;
+}
+
+// target array is writable in order to avoid dynamic memory allocation
+template<typename classifier>
+bool kleene_star_core<classifier>::scan(size_t* target, size_t scan_len, size_t* offset, const size_t origin) const
+{
+	assert(target);
+	assert(offset);
+	assert(1<=scan_len);
+	assert(result_scan.size()>=origin);
+	if (2==scan_len)
+		return scan(target[0],target[1],offset[0],offset[1],origin);
+	if (1==scan_len) return scan(target[0],offset[0],origin);
+	size_t i = 0;
+	while(result_scan.size()-origin>i)
+		{
+		size_t j = scan_len;
+		do	if (target[--j]==result_scan[i+origin])
+				{	//! \todo rework this to avoid useless recursion
+				if (0<j) memmove(target+j,target+j+1,sizeof(size_t)*(scan_len-j-1U));
+				if (!scan(target,scan_len-1,offset+1,i+origin+1))
+					return false;
+				do ++offset[--scan_len]; while(1<scan_len);
+				return offset[0] = i,true;
+				}
+		while(0<j);
+		++i;
+		}
+	return false;
+}
+
 #endif



From zaimoni at mail.berlios.de  Mon May 31 06:27:32 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 31 May 2010 06:27:32 +0200
Subject: [Zcplusplus-commits] r446 - trunk
Message-ID: <201005310427.o4V4RWmu019251@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-31 06:27:28 +0200 (Mon, 31 May 2010)
New Revision: 446

Modified:
   trunk/CSupport.cpp
Log:
becoming compliant regarding any-order type specifiers

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-31 04:26:48 UTC (rev 445)
+++ trunk/CSupport.cpp	2010-05-31 04:27:28 UTC (rev 446)
@@ -948,7 +948,7 @@
 		DICT_STRUCT("short"),
 		DICT_STRUCT("unsigned short"),
 		DICT_STRUCT("int"),
-		DICT_STRUCT("unsigned int"),
+		DICT_STRUCT("unsigned"),
 		DICT_STRUCT("long"),
 		DICT_STRUCT("unsigned long"),
 		DICT_STRUCT("long long"),
@@ -973,7 +973,7 @@
 		DICT_STRUCT("short"),
 		DICT_STRUCT("unsigned short"),
 		DICT_STRUCT("int"),
-		DICT_STRUCT("unsigned int"),
+		DICT_STRUCT("unsigned"),
 		DICT_STRUCT("long"),
 		DICT_STRUCT("unsigned long"),
 		DICT_STRUCT("long long"),
@@ -1061,8 +1061,8 @@
 		DICT_STRUCT("double"),
 		DICT_STRUCT("signed"),
 		DICT_STRUCT("unsigned"),
+		DICT_STRUCT("_Complex"),
 		DICT_STRUCT("_Bool"),
-		DICT_STRUCT("_Complex"),
 		DICT_STRUCT("_Thread_Local"),	// C1X, actually
 	};
 
@@ -1088,8 +1088,8 @@
 		DICT_STRUCT("double"),
 		DICT_STRUCT("signed"),
 		DICT_STRUCT("unsigned"),
+		DICT_STRUCT("_Complex"),	// extension
 		DICT_STRUCT("bool"),	// _Bool in C
-		DICT_STRUCT("_Complex"),	// extension
 		DICT_STRUCT("thread_local"),	// C1X _Thread_Local
 		DICT_STRUCT("constexpr"),
 		DICT_STRUCT("mutable"),
@@ -1106,6 +1106,15 @@
 #define C99_CPP_STATIC_IDX 5
 #define C99_CPP_EXTERN_IDX 6
 #define C99_CPP_AUTO_IDX 8
+#define C99_CPP_CHAR_IDX 10
+#define C99_CPP_SHORT_IDX 11
+#define C99_CPP_INT_IDX 12
+#define C99_CPP_LONG_IDX 13
+#define C99_CPP_FLOAT_IDX 14
+#define C99_CPP_DOUBLE_IDX 15
+#define C99_CPP_SIGNED_IDX 16
+#define C99_CPP_UNSIGNED_IDX 17
+#define C99_CPP_COMPLEX_IDX 18
 #define C1X_CPP0X_THREAD_LOCAL_IDX 20
 #define CPP_MUTABLE_IDX 22
 
@@ -3285,232 +3294,89 @@
 
 in any case, use up a flag to track "positively typename" status
 */
-static int _C99_CPP_notice_multitoken_primary_type_token_to_index(const zaimoni::POD_pair<const char*,size_t> src)
-{
-	assert(NULL!=src.first);
-	return token_is_string<3>(src,"int") ? 1
-		: token_is_string<4>(src,"char") ? 2
-		: token_is_string<5>(src,"short") ? 3
-		: token_is_string<4>(src,"long") ? 4 : 0;
+void set_C_canonical_type_representation(parse_tree& src,size_t i,size_t target_type)
+{	// range-restrict
+	assert(C_TYPE::VOID<=target_type && C_TYPE::LDOUBLE__COMPLEX>=target_type);
+	assert(C_TYPE::NOT_VOID!=target_type);	// not-void isn't a real type
+	assert(C_TYPE::BOOL!=target_type);	// this breaks in C++
+	assert(C_TYPE::INTEGERLIKE!=target_type);	// integerlike isn't a real type
+#define C_ATOMIC_TYPE_IDENTIFIER_BITFLAG ((1ULL<<C_TYPE::VOID) \
+	| (1ULL<<C_TYPE::BOOL) \
+	| (1ULL<<C_TYPE::CHAR) \
+	| (1ULL<<C_TYPE::SHRT) \
+	| (1ULL<<C_TYPE::INT) \
+	| (1ULL<<C_TYPE::UINT) \
+	| (1ULL<<C_TYPE::LONG) \
+	| (1ULL<<C_TYPE::FLOAT) \
+	| (1ULL<<C_TYPE::DOUBLE))
+
+	src.c_array<0>()[i].type_code.set_type(target_type);
+	//! \todo should use something informative in place of 0; identifier not fine
+	src.c_array<0>()[i].grab_index_token_from_str_literal<0>(C_atomic_types[target_type-1].first,C_ATOMIC_TYPE_IDENTIFIER_BITFLAG & (1ULL<<target_type) ? C_TESTFLAG_IDENTIFIER : 0);
+	src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+#undef C_ATOMIC_TYPE_IDENTIFIER_BITFLAG
 }
 
-static size_t _C99_CPP_notice_multitoken_primary_type(parse_tree& src, size_t i)
+template<size_t strict_ub_valid_detect> typename zaimoni::Loki::CheckReturnRequireRange<0,2,int>::value_type optional_keyword_choice(parse_tree& src,size_t i,kleene_star<strict_ub_valid_detect,size_t (*)(const char*)>& invariant_decl_scanner,size_t idx1,size_t idx2)
 {
+	size_t offset[2];
+	int tmp = 0;
+	assert(!invariant_decl_scanner.empty());
 	assert(src.size<0>()>i);
-	parse_tree& x = src.c_array<0>()[i];
-	assert(!(PARSE_PRIMARY_TYPE & x.flags) && NULL!=x.index_tokens[0].token.first);
-	if (token_is_string<4>(x.index_tokens[0].token,"char"))
+	assert(src.size<0>()-i>=invariant_decl_scanner.size());
+	assert(strict_ub_valid_detect>idx1);
+	assert(strict_ub_valid_detect>idx2);
+	if ((idx1==invariant_decl_scanner[0])<invariant_decl_scanner.count(idx1))
 		{
-		x.type_code.set_type(C_TYPE::CHAR);
-		x.flags |= PARSE_PRIMARY_TYPE;
-		return 0;
+		++tmp;
+		offset[0] = invariant_decl_scanner.scan_nofail(idx1,1);
 		}
-	else if (token_is_string<3>(x.index_tokens[0].token,"int"))
+	if ((idx2==invariant_decl_scanner[0])<invariant_decl_scanner.count(idx2))
 		{
-		x.type_code.set_type(C_TYPE::INT);
-		x.flags |= PARSE_PRIMARY_TYPE;
-		return 0;
+		tmp+=2;
+		offset[1] = invariant_decl_scanner.scan_nofail(idx2,1);
 		}
-	else if (token_is_string<5>(x.index_tokens[0].token,"short"))
+	// if ambiguous, use the one whose completion is sooner
+	if (3==tmp) tmp -= offset[0]<offset[1] ? 2 : 1;
+	if (0<tmp)
 		{
-		const bool short_int = i<src.size<0>()-1 && robust_token_is_string<3>(src.c_array<0>()[i+1].index_tokens[0].token,"int");
-		if (short_int)
-			x.grab_index_token_from_str_literal<0>("short int",0);	//! \bug should use something informative; identifier not fine
-		x.type_code.set_type(C_TYPE::SHRT);
-		x.flags |= PARSE_PRIMARY_TYPE;
-		return short_int;
+		src.DeleteIdx<0>(i+ ++offset[tmp-1]);
+		invariant_decl_scanner.DeleteIdx(offset[tmp-1]);
 		}
-	else if (token_is_string<5>(x.index_tokens[0].token,"float"))
+	return tmp;
+}
+
+template<size_t ub,size_t strict_ub_valid_detect> typename zaimoni::Loki::CheckReturnRequireRange<0,ub,size_t>::value_type optional_keyword_limit(parse_tree& src,size_t i,kleene_star<strict_ub_valid_detect,size_t (*)(const char*)>& invariant_decl_scanner,size_t idx1)
+{
+	size_t tmp = 0;
+	assert(!invariant_decl_scanner.empty());
+	assert(src.size<0>()>i);
+	assert(src.size<0>()-i>=invariant_decl_scanner.size());
+	assert(strict_ub_valid_detect>idx1);
+	while(ub>tmp && (idx1==invariant_decl_scanner[0])<invariant_decl_scanner.count(idx1))
 		{
-		const bool float__Complex = i<src.size<0>()-1 && robust_token_is_string<8>(src.c_array<0>()[i+1].index_tokens[0].token,"_Complex");
-		if (float__Complex)
-			{
-			x.grab_index_token_from_str_literal<0>("float _Complex",0);	//! \bug should use something informative; identifier not fine
-			x.type_code.set_type(C_TYPE::FLOAT__COMPLEX);
-			}
-		else
-			x.type_code.set_type(C_TYPE::FLOAT);
-		x.flags |= PARSE_PRIMARY_TYPE;
-		return float__Complex;
+		size_t tmp2 = invariant_decl_scanner.scan_nofail(idx1,1);
+		src.DeleteIdx<0>(i+ ++tmp2);
+		invariant_decl_scanner.DeleteIdx(tmp2);
+		++tmp;
 		}
-	else if (token_is_string<6>(x.index_tokens[0].token,"double"))
+	return tmp;
+}
+
+template<size_t strict_ub_valid_detect>  bool optional_keyword(parse_tree& src,size_t i,kleene_star<strict_ub_valid_detect,size_t (*)(const char*)>& invariant_decl_scanner,size_t idx1)
+{
+	assert(!invariant_decl_scanner.empty());
+	assert(src.size<0>()>i);
+	assert(src.size<0>()-i>=invariant_decl_scanner.size());
+	assert(strict_ub_valid_detect>idx1);
+	if ((idx1==invariant_decl_scanner[0])<invariant_decl_scanner.count(idx1))
 		{
-		const bool double__Complex = i<src.size<0>()-1 && robust_token_is_string<8>(src.c_array<0>()[i+1].index_tokens[0].token,"_Complex");
-		if (double__Complex)
-			{
-			x.grab_index_token_from_str_literal<0>("double _Complex",0);	//! \bug should use something informative; identifier not fine
-			x.type_code.set_type(C_TYPE::DOUBLE__COMPLEX);
-			}
-		else
-			x.type_code.set_type(C_TYPE::DOUBLE);
-		x.flags |= PARSE_PRIMARY_TYPE;
-		return double__Complex;
+		size_t tmp = invariant_decl_scanner.scan_nofail(idx1,1);
+		src.DeleteIdx<0>(i+ ++tmp);
+		invariant_decl_scanner.DeleteIdx(tmp);
+		return true;
 		}
-	else if (token_is_string<4>(x.index_tokens[0].token,"long"))
-		{
-		const int keyindex 	= (i>=src.size<0>()-1 || NULL==src.data<0>()[i+1].index_tokens[0].token.first) ? 0 
-							: token_is_string<3>(src.c_array<0>()[i+1].index_tokens[0].token,"int") ? 1
-							: token_is_string<4>(src.c_array<0>()[i+1].index_tokens[0].token,"long") ? 2
-							: token_is_string<6>(src.c_array<0>()[i+1].index_tokens[0].token,"double") ? 3 : 0;
-		switch(keyindex)
-		{
-		case 3:	// long double
-			{
-			const bool long_double__Complex = (i<src.size<0>()-2 && robust_token_is_string<8>(src.c_array<0>()[i+2].index_tokens[0].token,"_Complex"));
-			if (long_double__Complex)
-				{
-				x.grab_index_token_from_str_literal<0>("long double _Complex",0);	//! \bug should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::LDOUBLE__COMPLEX);
-				}
-			else{
-				x.grab_index_token_from_str_literal<0>("long double",0);	//! \bug should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::LDOUBLE);
-				}
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return 1+long_double__Complex;
-			}
-		case 2:	// long long
-			{
-			const bool long_long_int = (i<src.size<0>()-2 && robust_token_is_string<3>(src.c_array<0>()[i+2].index_tokens[0].token,"int"));
-			x.grab_index_token_from_str_literal<0>(long_long_int ? "long long int" : "long long",0);	//! \bug should use something informative; identifier not fine
-			x.type_code.set_type(C_TYPE::LLONG);
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return 1+long_long_int;
-			}
-		case 1:	// long int
-			x.grab_index_token_from_str_literal<0>("long int",0);	//! \bug should use something informative; identifier not fine
-			// intentional fall-through
-		case 0:	// long
-			src.c_array<0>()[i].type_code.set_type(C_TYPE::LONG);
-			src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
-			return keyindex;
-		}
-		}
-	else if (token_is_string<6>(x.index_tokens[0].token,"signed"))
-		{
-		const int key_index	= (i>=src.size<0>()-1 || NULL==src.data<0>()[i+1].index_tokens[0].token.first) ? 0
-							: _C99_CPP_notice_multitoken_primary_type_token_to_index(src.data<0>()[i+1].index_tokens[0].token);
-		switch(key_index)
-		{
-		case 4:	// signed long
-			{
-			const int key_index2	= (i>=src.size<0>()-2 || NULL==src.data<0>()[i+2].index_tokens[0].token.first) ? 0
-									: token_is_string<3>(src.c_array<0>()[i+2].index_tokens[0].token,"int") ? 1
-									: token_is_string<4>(src.c_array<0>()[i+2].index_tokens[0].token,"long") ? 2 : 0;
-			switch(key_index2)
-			{
-			case 2:	// signed long long
-				{
-				const bool signed_long_long_int = i<src.size<0>()-3 && robust_token_is_string<3>(src.c_array<0>()[i+3].index_tokens[0].token,"int");
-				x.grab_index_token_from_str_literal<0>(signed_long_long_int ? "signed long long int" : "signed long long",0);	//! \todo should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::LLONG);
-				x.flags |= PARSE_PRIMARY_TYPE;
-				return 2+signed_long_long_int;
-				}
-			case 1:	// signed long int
-				{
-				x.grab_index_token_from_str_literal<0>("signed long int",0);	//! \bug should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::LONG);
-				x.flags |= PARSE_PRIMARY_TYPE;
-				return 2;
-				}
-			case 0:	// signed long
-				{
-				x.grab_index_token_from_str_literal<0>("signed long",0);	//! \bug should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::LONG);
-				x.flags |= PARSE_PRIMARY_TYPE;
-				return 1;
-				}
-			}
-			break;
-			}
-		case 3:	// signed short
-			{
-			x.grab_index_token_from_str_literal<0>("signed short",0);	//! \bug should use something informative; identifier not fine
-			x.type_code.set_type(C_TYPE::SHRT);
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return 1;
-			}
-		case 2:	// signed char
-			{
-			x.grab_index_token_from_str_literal<0>("signed char",0);	//! \bug should use something informative; identifier not fine
-			x.type_code.set_type(C_TYPE::SCHAR);
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return 1;
-			}
-		case 1:	// signed int
-			x.grab_index_token_from_str_literal<0>("signed int",0);	//! \bug should use something informative; identifier not fine
-			// intentional fall-through
-		case 0:	// signed
-			x.type_code.set_type(C_TYPE::INT);
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return key_index;
-		}
-		}
-	else if (token_is_string<8>(x.index_tokens[0].token,"unsigned"))
-		{
-		const int key_index	= (i>=src.size<0>()-1 || NULL==src.data<0>()[i+1].index_tokens[0].token.first) ? 0
-							: _C99_CPP_notice_multitoken_primary_type_token_to_index(src.data<0>()[i+1].index_tokens[0].token);
-		switch(key_index)
-		{
-		case 4:	// unsigned long
-			{
-			const int key_index2	= (i>=src.size<0>()-2 || NULL==src.data<0>()[i+2].index_tokens[0].token.first) ? 0
-									: token_is_string<3>(src.c_array<0>()[i+2].index_tokens[0].token,"int") ? 1
-									: token_is_string<4>(src.c_array<0>()[i+2].index_tokens[0].token,"long") ? 2 : 0;
-			switch(key_index2)
-			{
-			case 2:	// unsigned long long
-				{
-				const bool unsigned_long_long_int = i<src.size<0>()-3 && robust_token_is_string<3>(src.c_array<0>()[i+3].index_tokens[0].token,"int");
-				x.grab_index_token_from_str_literal<0>(unsigned_long_long_int ? "unsigned long long int" : "unsigned long long",0);	//! \todo should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::ULLONG);
-				x.flags |= PARSE_PRIMARY_TYPE;
-				return 2+unsigned_long_long_int;
-				}
-			case 1:	// unsigned long int
-				{
-				x.grab_index_token_from_str_literal<0>("unsigned long int",0);	//! \bug should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::ULONG);
-				x.flags |= PARSE_PRIMARY_TYPE;
-				return 2;
-				}
-			case 0:	// unsigned long
-				{
-				x.grab_index_token_from_str_literal<0>("unsigned long",0);	//! \bug should use something informative; identifier not fine
-				x.type_code.set_type(C_TYPE::ULONG);
-				x.flags |= PARSE_PRIMARY_TYPE;
-				return 1;
-				}
-			}
-			break;
-			}
-		case 3:	// unsigned short
-			{
-			x.grab_index_token_from_str_literal<0>("unsigned short",0);	//! \bug should use something informative; identifier not fine
-			x.type_code.set_type(C_TYPE::USHRT);
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return 1;
-			}
-		case 2:	// unsigned char
-			{
-			x.grab_index_token_from_str_literal<0>("unsigned char",0);	//! \bug should use something informative; identifier not fine
-			x.type_code.set_type(C_TYPE::UCHAR);
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return 1;
-			}
-		case 1:	// unsigned int
-			x.grab_index_token_from_str_literal<0>("unsigned int",0);	//! \bug should use something informative; identifier not fine
-			// intentional fall-through
-		case 0:	// unsigned
-			x.type_code.set_type(C_TYPE::UINT);
-			x.flags |= PARSE_PRIMARY_TYPE;
-			return key_index;
-		}
-		}
-	else if (token_is_string<8>(x.index_tokens[0].token,"_Complex"))
-		simple_error(x," does not have immediately preceding floating point type (C99 6.7.2p2)");
-	return 0;
+	return false;
 }
 
 static void C99_notice_primary_type_atomic(parse_tree& src)
@@ -3684,33 +3550,155 @@
 					}
 				};
 
-			//! \todo handle allowed sequences of type-qualifiers (do need second pass later)
+			// handle allowed sequences of type-qualifiers (do need second pass later)
+			bool have_warned_about_Complex = false;
+			do	{
+				switch(invariant_decl_scanner[0])
+				{
+				case C99_CPP_CHAR_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					BOOST_STATIC_ASSERT(1==C_TYPE::SCHAR-C_TYPE::CHAR);
+					BOOST_STATIC_ASSERT(2==C_TYPE::UCHAR-C_TYPE::CHAR);
+					set_C_canonical_type_representation(src,i,C_TYPE::CHAR+optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX));
+					break;
+				case C99_CPP_SHORT_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					// short and signed short are the same type
+					BOOST_STATIC_ASSERT(1==C_TYPE::USHRT-C_TYPE::SHRT);
+					set_C_canonical_type_representation(src,i,C_TYPE::SHRT+(2==optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX)));
+					// short int is the same as short
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_INT_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					{
+					int tmp = optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX);
+					// XXX have to account for short
+					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX,C99_CPP_LONG_IDX))
+					{
+					case 0:
+						{
+						BOOST_STATIC_ASSERT(1==C_TYPE::UINT-C_TYPE::INT);
+						set_C_canonical_type_representation(src,i,C_TYPE::INT+(2==tmp));
+						break;
+						}
+					case 1:
+						{
+						BOOST_STATIC_ASSERT(1==C_TYPE::USHRT-C_TYPE::SHRT);
+						set_C_canonical_type_representation(src,i,C_TYPE::SHRT+(2==tmp));
+						break;
+						}
+					default:
+						{
+						BOOST_STATIC_ASSERT(3==C_TYPE::ULLONG-C_TYPE::LONG);
+						BOOST_STATIC_ASSERT(2==C_TYPE::LLONG-C_TYPE::LONG);
+						BOOST_STATIC_ASSERT(1==C_TYPE::ULONG-C_TYPE::LONG);
+						set_C_canonical_type_representation(src,i,C_TYPE::LONG+(2==tmp)+2*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+//						break;
+						}
+					}
+					}
+					break;
+				case C99_CPP_LONG_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_DOUBLE_IDX))
+						{
+						BOOST_STATIC_ASSERT(3==C_TYPE::LDOUBLE__COMPLEX-C_TYPE::LDOUBLE);
+						set_C_canonical_type_representation(src,i,C_TYPE::LDOUBLE+3*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_COMPLEX_IDX));
+						break;
+						}
+					BOOST_STATIC_ASSERT(3==C_TYPE::ULLONG-C_TYPE::LONG);
+					BOOST_STATIC_ASSERT(2==C_TYPE::LLONG-C_TYPE::LONG);
+					BOOST_STATIC_ASSERT(1==C_TYPE::ULONG-C_TYPE::LONG);
+					set_C_canonical_type_representation(src,i,C_TYPE::LONG+(2==optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX))+2*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+					// long int is the same as long
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_FLOAT_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					BOOST_STATIC_ASSERT(3==C_TYPE::FLOAT__COMPLEX-C_TYPE::FLOAT);
+					set_C_canonical_type_representation(src,i,C_TYPE::FLOAT+3*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_COMPLEX_IDX));
+					break;
+				case C99_CPP_DOUBLE_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					BOOST_STATIC_ASSERT(1==C_TYPE::LDOUBLE-C_TYPE::DOUBLE);
+					BOOST_STATIC_ASSERT(3==C_TYPE::DOUBLE__COMPLEX-C_TYPE::DOUBLE);
+					BOOST_STATIC_ASSERT(4==C_TYPE::LDOUBLE__COMPLEX-C_TYPE::DOUBLE);
+					set_C_canonical_type_representation(src,i,C_TYPE::DOUBLE+optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX)+3*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_COMPLEX_IDX));
+					break;
+				case C99_CPP_SIGNED_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_CHAR_IDX))
+						{
+						set_C_canonical_type_representation(src,i,C_TYPE::SCHAR);
+						break;
+						}
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX))
+						set_C_canonical_type_representation(src,i,C_TYPE::SHRT);
+					else{
+						BOOST_STATIC_ASSERT(2==C_TYPE::LONG-C_TYPE::INT);
+						BOOST_STATIC_ASSERT(4==C_TYPE::LLONG-C_TYPE::INT);
+						set_C_canonical_type_representation(src,i,C_TYPE::INT+2*optional_keyword_limit<2>(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+						}
+					// signed int is the same as signed
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_UNSIGNED_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_CHAR_IDX))
+						{
+						set_C_canonical_type_representation(src,i,C_TYPE::UCHAR);
+						break;
+						}
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX))
+						set_C_canonical_type_representation(src,i,C_TYPE::USHRT);
+					else{
+						BOOST_STATIC_ASSERT(2==C_TYPE::ULONG-C_TYPE::UINT);
+						BOOST_STATIC_ASSERT(4==C_TYPE::ULLONG-C_TYPE::UINT);
+						set_C_canonical_type_representation(src,i,C_TYPE::UINT+2*optional_keyword_limit<2>(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+						}
+					// unsigned int is the same as unsigned
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_COMPLEX_IDX:
+					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_FLOAT_IDX,C99_CPP_DOUBLE_IDX))
+					{
+					case 0:
+						{
+						if (!have_warned_about_Complex)
+							{
+							message_header(src.data<0>()[i].index_tokens[0]);
+							INC_INFORM(ERR_STR);
+							INFORM("type-specifier-sequence has _Complex without either float or double (C99 6.7.3p4)");
+							zcc_errors.inc_error();
+							have_warned_about_Complex = true;
+							}
+						// remove the unusable token
+						src.DeleteIdx<0>(i--);
+						break;
+						}
+					case 1:
+						src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+						set_C_canonical_type_representation(src,i,C_TYPE::FLOAT__COMPLEX);
+						break;
+					case 2:
+						src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+						BOOST_STATIC_ASSERT(1==C_TYPE::LDOUBLE__COMPLEX-C_TYPE::DOUBLE__COMPLEX);
+						set_C_canonical_type_representation(src,i,C_TYPE::DOUBLE__COMPLEX+optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+//						break;						
+					}
+//					break;					
+				}
+				invariant_decl_scanner.DeleteIdx(0);
+				++i;
+				}
+			while(!invariant_decl_scanner.empty());
+
 			// defer handling: _Thread_Local, typedef, other storage class issues
 			invariant_decl_scanner.clear();
 			}
 		}
 	while(src.size<0>()> ++i);
-
-	i = 0;
-	size_t offset = 0;
-	while(i+offset<src.size<0>())
-		{
-		{	//! \todo retest object size with/without tmp_ref
-		parse_tree& tmp_ref = src.c_array<0>()[i];
-		const size_t truncate_by = (!(PARSE_PRIMARY_TYPE & tmp_ref.flags) && NULL!=tmp_ref.index_tokens[0].token.first) 
-								 ? _C99_CPP_notice_multitoken_primary_type(src,i) : 0;
-		if (0<truncate_by)
-			{
-			src.DestroyNAtAndRotateTo<0>(truncate_by,i+1,src.size<0>()-offset);
-			offset += truncate_by;
-			}
-		}
-		// disallow consecutive primary types
-		if (0<i && (PARSE_TYPE & src.c_array<0>()[i].flags) && (PARSE_TYPE & src.c_array<0>()[i-1].flags))
-			simple_error(src.c_array<0>()[i]," immediately after another type");
-		++i;
-		};
-	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
 }
 
 static void CPP_notice_primary_type_atomic(parse_tree& src)
@@ -3891,34 +3879,156 @@
 					invariant_decl_scanner.DeleteIdx(offset--);					
 					}
 				};
-			
-			//! \todo handle allowed sequences of type-qualifiers (do need second pass later)
+
+			// handle allowed sequences of type-qualifiers (do need second pass later)
+			bool have_warned_about_Complex = false;
+			do	{
+				switch(invariant_decl_scanner[0])
+				{
+				case C99_CPP_CHAR_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					BOOST_STATIC_ASSERT(1==C_TYPE::SCHAR-C_TYPE::CHAR);
+					BOOST_STATIC_ASSERT(2==C_TYPE::UCHAR-C_TYPE::CHAR);
+					set_C_canonical_type_representation(src,i,C_TYPE::CHAR+optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX));
+					break;
+				case C99_CPP_SHORT_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					// short and signed short are the same type
+					BOOST_STATIC_ASSERT(1==C_TYPE::USHRT-C_TYPE::SHRT);
+					set_C_canonical_type_representation(src,i,C_TYPE::SHRT+(2==optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX)));
+					// short int is the same as short
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_INT_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					{
+					int tmp = optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX);
+					// XXX have to account for short
+					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX,C99_CPP_LONG_IDX))
+					{
+					case 0:
+						{
+						BOOST_STATIC_ASSERT(1==C_TYPE::UINT-C_TYPE::INT);
+						set_C_canonical_type_representation(src,i,C_TYPE::INT+(2==tmp));
+						break;
+						}
+					case 1:
+						{
+						BOOST_STATIC_ASSERT(1==C_TYPE::USHRT-C_TYPE::SHRT);
+						set_C_canonical_type_representation(src,i,C_TYPE::SHRT+(2==tmp));
+						break;
+						}
+					default:
+						{
+						BOOST_STATIC_ASSERT(3==C_TYPE::ULLONG-C_TYPE::LONG);
+						BOOST_STATIC_ASSERT(2==C_TYPE::LLONG-C_TYPE::LONG);
+						BOOST_STATIC_ASSERT(1==C_TYPE::ULONG-C_TYPE::LONG);
+						set_C_canonical_type_representation(src,i,C_TYPE::LONG+(2==tmp)+2*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+//						break;
+						}
+					}
+					}
+					break;
+				case C99_CPP_LONG_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_DOUBLE_IDX))
+						{
+						BOOST_STATIC_ASSERT(3==C_TYPE::LDOUBLE__COMPLEX-C_TYPE::LDOUBLE);
+						set_C_canonical_type_representation(src,i,C_TYPE::LDOUBLE+3*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_COMPLEX_IDX));
+						break;
+						}
+					BOOST_STATIC_ASSERT(3==C_TYPE::ULLONG-C_TYPE::LONG);
+					BOOST_STATIC_ASSERT(2==C_TYPE::LLONG-C_TYPE::LONG);
+					BOOST_STATIC_ASSERT(1==C_TYPE::ULONG-C_TYPE::LONG);
+					set_C_canonical_type_representation(src,i,C_TYPE::LONG+(2==optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX))+2*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+					// long int is the same as long
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_FLOAT_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					BOOST_STATIC_ASSERT(3==C_TYPE::FLOAT__COMPLEX-C_TYPE::FLOAT);
+					set_C_canonical_type_representation(src,i,C_TYPE::FLOAT+3*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_COMPLEX_IDX));
+					break;
+				case C99_CPP_DOUBLE_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					BOOST_STATIC_ASSERT(1==C_TYPE::LDOUBLE-C_TYPE::DOUBLE);
+					BOOST_STATIC_ASSERT(3==C_TYPE::DOUBLE__COMPLEX-C_TYPE::DOUBLE);
+					BOOST_STATIC_ASSERT(4==C_TYPE::LDOUBLE__COMPLEX-C_TYPE::DOUBLE);
+					set_C_canonical_type_representation(src,i,C_TYPE::DOUBLE+optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX)+3*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_COMPLEX_IDX));
+					break;
+				case C99_CPP_SIGNED_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_CHAR_IDX))
+						{
+						set_C_canonical_type_representation(src,i,C_TYPE::SCHAR);
+						break;
+						}
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX))
+						set_C_canonical_type_representation(src,i,C_TYPE::SHRT);
+					else{
+						BOOST_STATIC_ASSERT(2==C_TYPE::LONG-C_TYPE::INT);
+						BOOST_STATIC_ASSERT(4==C_TYPE::LLONG-C_TYPE::INT);
+						set_C_canonical_type_representation(src,i,C_TYPE::INT+2*optional_keyword_limit<2>(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+						}
+					// signed int is the same as signed
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_UNSIGNED_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_CHAR_IDX))
+						{
+						set_C_canonical_type_representation(src,i,C_TYPE::UCHAR);
+						break;
+						}
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX))
+						set_C_canonical_type_representation(src,i,C_TYPE::USHRT);
+					else{
+						BOOST_STATIC_ASSERT(2==C_TYPE::ULONG-C_TYPE::UINT);
+						BOOST_STATIC_ASSERT(4==C_TYPE::ULLONG-C_TYPE::UINT);
+						set_C_canonical_type_representation(src,i,C_TYPE::UINT+2*optional_keyword_limit<2>(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+						}
+					// unsigned int is the same as unsigned
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_COMPLEX_IDX:
+					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_FLOAT_IDX,C99_CPP_DOUBLE_IDX))
+					{
+					case 0:
+						{
+						if (!have_warned_about_Complex)
+							{
+							message_header(src.data<0>()[i].index_tokens[0]);
+							INC_INFORM(ERR_STR);
+							INFORM("type-specifier-sequence has _Complex without either float or double (C99 6.7.3p4)");
+							zcc_errors.inc_error();
+							have_warned_about_Complex = true;
+							}
+						// remove the unusable token
+						src.DeleteIdx<0>(i--);
+						break;
+						}
+					case 1:
+						src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+						set_C_canonical_type_representation(src,i,C_TYPE::FLOAT__COMPLEX);
+						break;
+					case 2:
+						src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+						BOOST_STATIC_ASSERT(1==C_TYPE::LDOUBLE__COMPLEX-C_TYPE::DOUBLE__COMPLEX);
+						set_C_canonical_type_representation(src,i,C_TYPE::DOUBLE__COMPLEX+optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+//						break;						
+					}
+//					break;					
+				}
+				invariant_decl_scanner.DeleteIdx(0);
+				++i;
+				}
+			while(!invariant_decl_scanner.empty());
+
 			// defer handling thread_local, typedef restrictions 
 			invariant_decl_scanner.clear();
 			}
 		}
 	while(src.size<0>()> ++i);
-
-	i = 0;
-	size_t offset = 0;
-	while(i+offset<src.size<0>())
-		{
-		{	//! \todo retest object size with/without tmp_ref
-		parse_tree& tmp_ref = src.c_array<0>()[i];
-		const size_t truncate_by = (!(PARSE_PRIMARY_TYPE & tmp_ref.flags) && NULL!=tmp_ref.index_tokens[0].token.first) 
-								 ? _C99_CPP_notice_multitoken_primary_type(src,i) : 0;
-		if (0<truncate_by)
-			{
-			src.DestroyNAtAndRotateTo<0>(truncate_by,i+1,src.size<0>()-offset);
-			offset += truncate_by;
-			}
-		}
-		// disallow consecutive types
-		if (0<i && (PARSE_TYPE & src.c_array<0>()[i].flags) && (PARSE_TYPE & src.c_array<0>()[i-1].flags))
-			simple_error(src.c_array<0>()[i]," immediately after another primary type");
-		++i;
-		};
-	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
 }
 #/*cut-cpp*/
 
@@ -14164,7 +14274,7 @@
 	assert(C_TYPE::SHRT==linear_find("short",C_atomic_types,C_TYPE_MAX)+1);
 	assert(C_TYPE::USHRT==linear_find("unsigned short",C_atomic_types,C_TYPE_MAX)+1);
 	assert(C_TYPE::INT==linear_find("int",C_atomic_types,C_TYPE_MAX)+1);
-	assert(C_TYPE::UINT==linear_find("unsigned int",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::UINT==linear_find("unsigned",C_atomic_types,C_TYPE_MAX)+1);
 	assert(C_TYPE::LONG==linear_find("long",C_atomic_types,C_TYPE_MAX)+1);
 	assert(C_TYPE::ULONG==linear_find("unsigned long",C_atomic_types,C_TYPE_MAX)+1);
 	assert(C_TYPE::LLONG==linear_find("long long",C_atomic_types,C_TYPE_MAX)+1);
@@ -14186,7 +14296,7 @@
 	assert(C_TYPE::SHRT==linear_find("short",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::USHRT==linear_find("unsigned short",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::INT==linear_find("int",CPP_atomic_types,CPP_TYPE_MAX)+1);
-	assert(C_TYPE::UINT==linear_find("unsigned int",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::UINT==linear_find("unsigned",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::LONG==linear_find("long",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::ULONG==linear_find("unsigned long",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::LLONG==linear_find("long long",CPP_atomic_types,CPP_TYPE_MAX)+1);
@@ -14216,6 +14326,26 @@
 	assert(C99_CPP_EXTERN_IDX==linear_find("extern",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
 	assert(C99_CPP_AUTO_IDX==linear_find("auto",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
 	assert(C99_CPP_AUTO_IDX==linear_find("auto",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_CHAR_IDX==linear_find("char",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_CHAR_IDX==linear_find("char",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_SHORT_IDX==linear_find("short",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_SHORT_IDX==linear_find("short",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_INT_IDX==linear_find("int",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_INT_IDX==linear_find("int",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_LONG_IDX==linear_find("long",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_LONG_IDX==linear_find("long",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_FLOAT_IDX==linear_find("float",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_FLOAT_IDX==linear_find("float",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_DOUBLE_IDX==linear_find("double",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_DOUBLE_IDX==linear_find("double",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_SIGNED_IDX==linear_find("signed",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_SIGNED_IDX==linear_find("signed",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_UNSIGNED_IDX==linear_find("unsigned",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_UNSIGNED_IDX==linear_find("unsigned",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_COMPLEX_IDX==linear_find("_Complex",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_COMPLEX_IDX==linear_find("_Complex",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_COMPLEX_IDX==linear_find("_Complex",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_COMPLEX_IDX==linear_find("_Complex",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
 	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("_Thread_Local",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
 	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("thread_local",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
 	assert(CPP_MUTABLE_IDX==linear_find("mutable",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));



From zaimoni at mail.berlios.de  Mon May 31 08:28:43 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 31 May 2010 08:28:43 +0200
Subject: [Zcplusplus-commits] r447 - trunk
Message-ID: <201005310628.o4V6Sh8s000995@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-31 08:28:39 +0200 (Mon, 31 May 2010)
New Revision: 447

Modified:
   trunk/CSupport.cpp
Log:
object file size reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-05-31 04:27:28 UTC (rev 446)
+++ trunk/CSupport.cpp	2010-05-31 06:28:39 UTC (rev 447)
@@ -3310,10 +3310,11 @@
 	| (1ULL<<C_TYPE::FLOAT) \
 	| (1ULL<<C_TYPE::DOUBLE))
 
-	src.c_array<0>()[i].type_code.set_type(target_type);
+	parse_tree& tmp = src.c_array<0>()[i];
+	tmp.type_code.set_type(target_type);
 	//! \todo should use something informative in place of 0; identifier not fine
-	src.c_array<0>()[i].grab_index_token_from_str_literal<0>(C_atomic_types[target_type-1].first,C_ATOMIC_TYPE_IDENTIFIER_BITFLAG & (1ULL<<target_type) ? C_TESTFLAG_IDENTIFIER : 0);
-	src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+	tmp.grab_index_token_from_str_literal<0>(C_atomic_types[target_type-1].first,C_ATOMIC_TYPE_IDENTIFIER_BITFLAG & (1ULL<<target_type) ? C_TESTFLAG_IDENTIFIER : 0);
+	tmp.flags |= PARSE_PRIMARY_TYPE;
 #undef C_ATOMIC_TYPE_IDENTIFIER_BITFLAG
 }
 
@@ -3435,7 +3436,7 @@
 					src.DeleteIdx<0>(i+offset);
 					invariant_decl_scanner.DeleteIdx(offset--);					
 					}
-				if (1<invariant_decl_scanner.count(C99_CPP_STATIC_IDX))
+				else if (1<invariant_decl_scanner.count(C99_CPP_STATIC_IDX))
 					{	//! \bug need test case
 					if (!have_warned_about_static)
 						{
@@ -3449,7 +3450,7 @@
 					src.DeleteIdx<0>(i+offset);
 					invariant_decl_scanner.DeleteIdx(offset--);					
 					}
-				if (1<invariant_decl_scanner.count(C99_CPP_EXTERN_IDX))
+				else if (1<invariant_decl_scanner.count(C99_CPP_EXTERN_IDX))
 					{	//! \bug need test case
 					if (!have_warned_about_extern)
 						{
@@ -3463,7 +3464,7 @@
 					src.DeleteIdx<0>(i+offset);
 					invariant_decl_scanner.DeleteIdx(offset--);					
 					}
-				if (1<invariant_decl_scanner.count(C1X_CPP0X_THREAD_LOCAL_IDX))
+				else if (1<invariant_decl_scanner.count(C1X_CPP0X_THREAD_LOCAL_IDX))
 					{	//! \bug need test case
 					if (!have_warned_about_thread_local)
 						{
@@ -3477,7 +3478,7 @@
 					src.DeleteIdx<0>(i+offset);
 					invariant_decl_scanner.DeleteIdx(offset--);					
 					}
-				if (1<invariant_decl_scanner.count(C99_CPP_AUTO_IDX))
+				else if (1<invariant_decl_scanner.count(C99_CPP_AUTO_IDX))
 					{	//! \bug need test case
 					if (!have_warned_about_auto)
 						{
@@ -3491,7 +3492,7 @@
 					src.DeleteIdx<0>(i+offset);
 					invariant_decl_scanner.DeleteIdx(offset--);					
 					}
-				if (1<invariant_decl_scanner.count(C99_CPP_TYPEDEF_IDX))
+				else if (1<invariant_decl_scanner.count(C99_CPP_TYPEDEF_IDX))
 					{	//! \bug need test case
 					if (!have_warned_about_typedef)
 						{
@@ -3506,7 +3507,7 @@
 					invariant_decl_scanner.DeleteIdx(offset--);					
 					}
 				// C1X 6.7.3p3: duplicate type-qualifiers should be cleaned (warn unless -Wno-OAOO or -Wno-DRY)
-				if (1<invariant_decl_scanner.count(C99_CPP_CONST_IDX))
+				else if (1<invariant_decl_scanner.count(C99_CPP_CONST_IDX))
 					{	//! \bug need test case
 					if (!have_warned_about_const)
 						{
@@ -3520,7 +3521,7 @@
 					src.DeleteIdx<0>(i+offset);
 					invariant_decl_scanner.DeleteIdx(offset--);					
 					}
-				if (1<invariant_decl_scanner.count(C99_CPP_VOLATILE_IDX))
+				else if (1<invariant_decl_scanner.count(C99_CPP_VOLATILE_IDX))
 					{	//! \bug need test case
 					if (!have_warned_about_volatile)
 						{
@@ -3534,7 +3535,7 @@
 					src.DeleteIdx<0>(i+offset);
 					invariant_decl_scanner.DeleteIdx(offset--);					
 					}
-				if (1<invariant_decl_scanner.count(C99_RESTRICT_IDX))
+				else if (1<invariant_decl_scanner.count(C99_RESTRICT_IDX))
 					{	//! \bug need test case
 					if (!have_warned_about_restrict)
 						{
@@ -3751,7 +3752,7 @@
 			if (C99_CPP_EXTERN_IDX==invariant_decl_scanner[0] && 1<src.size<0>()-i && (C_TESTFLAG_STRING_LITERAL & src.data<0>()[i+1].flags))
 				{	//! \todo should accept escape codes here as well
 				if (strcmp(src.data<0>()[i+1].index_tokens[0].token.first,"\"C\"") && strcmp(src.data<0>()[i+1].index_tokens[0].token.first,"\"C++\""))
-					{
+					{	//! \bug need test case
 					message_header(src.data<0>()[i+1].index_tokens[0]);
 					INC_INFORM(WARN_STR);
 					INFORM("discarding unrecognized linkage (only C, C++ required: C++0X 7.5p2)");
@@ -3793,7 +3794,7 @@
 					src.DeleteIdx<0>(i+offset+using_linkage);
 					invariant_decl_scanner.DeleteIdx(offset--);					
 					}
-				if (1<invariant_decl_scanner.count(C99_CPP_EXTERN_IDX))
+				else if (1<invariant_decl_scanner.count(C99_CPP_EXTERN_IDX))
 					{	//! \bug need test case
 					if (!have_warned_about_extern)
 						{
@@ -3807,7 +3808,7 @@
 					src.DeleteIdx<0>(i+offset+using_linkage);
 					invariant_decl_scanner.DeleteIdx(offset--);					
 					}
-				if (1<invariant_decl_scanner.count(C1X_CPP0X_THREAD_LOCAL_IDX))
+				else if (1<invariant_decl_scanner.count(C1X_CPP0X_THREAD_LOCAL_IDX))
 					{	//! \bug need test case
 					if (!have_warned_about_thread_local)
 						{
@@ -3821,7 +3822,7 @@
 					src.DeleteIdx<0>(i+offset+using_linkage);
 					invariant_decl_scanner.DeleteIdx(offset--);					
 					}
-				if (1<invariant_decl_scanner.count(CPP_MUTABLE_IDX))
+				else if (1<invariant_decl_scanner.count(CPP_MUTABLE_IDX))
 					{	//! \bug need test case
 					if (!have_warned_about_mutable)
 						{
@@ -3835,7 +3836,7 @@
 					src.DeleteIdx<0>(i+offset+using_linkage);
 					invariant_decl_scanner.DeleteIdx(offset--);					
 					}
-				if (1<invariant_decl_scanner.count(C99_CPP_TYPEDEF_IDX))
+				else if (1<invariant_decl_scanner.count(C99_CPP_TYPEDEF_IDX))
 					{	//! \bug need test case
 					if (!have_warned_about_typedef)
 						{
@@ -3850,7 +3851,7 @@
 					invariant_decl_scanner.DeleteIdx(offset--);					
 					}
 				// C++0X 7.1.6.1: duplicate cv-qualifiers should be cleaned (warn unless -Wno-OAOO or -Wno-DRY)
-				if (1<invariant_decl_scanner.count(C99_CPP_CONST_IDX))
+				else if (1<invariant_decl_scanner.count(C99_CPP_CONST_IDX))
 					{	//! \bug need test case
 					if (!have_warned_about_const)
 						{
@@ -3864,7 +3865,7 @@
 					src.DeleteIdx<0>(i+offset+using_linkage);
 					invariant_decl_scanner.DeleteIdx(offset--);					
 					}
-				if (1<invariant_decl_scanner.count(C99_CPP_VOLATILE_IDX))
+				else if (1<invariant_decl_scanner.count(C99_CPP_VOLATILE_IDX))
 					{	//! \bug need test case
 					if (!have_warned_about_volatile)
 						{



From zaimoni at mail.berlios.de  Mon May 31 19:03:54 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 31 May 2010 19:03:54 +0200
Subject: [Zcplusplus-commits] r448 - trunk/tests/zcc/default/staticassert
Message-ID: <201005311703.o4VH3sO9017390@sheep.berlios.de>

Author: zaimoni
Date: 2010-05-31 19:03:49 +0200 (Mon, 31 May 2010)
New Revision: 448

Modified:
   trunk/tests/zcc/default/staticassert/Pass_typeid.hpp
Log:
augment extension testing of ==, != of typeid

Modified: trunk/tests/zcc/default/staticassert/Pass_typeid.hpp
===================================================================
--- trunk/tests/zcc/default/staticassert/Pass_typeid.hpp	2010-05-31 06:28:39 UTC (rev 447)
+++ trunk/tests/zcc/default/staticassert/Pass_typeid.hpp	2010-05-31 17:03:49 UTC (rev 448)
@@ -5,6 +5,8 @@
 // (it's a std::typeinfo structure) -- but the result of == and != operators
 // can be known at compile-time in simple cases.
 
+// This tests the Z.C++ extension for resolving the above at compile-time.
+
 #include <typeinfo>
 
 // identity checks
@@ -31,6 +33,90 @@
 static_assert(typeid(double _Complex)==typeid(double _Complex),"automatic success failed");
 static_assert(typeid(long double _Complex)==typeid(long double _Complex),"automatic success failed");
 
+// C++ specific
+static_assert(typeid(wchar_t)==typeid(wchar_t),"automatic success failed");
+
+// permutated identity checks
+static_assert(typeid(signed char)==typeid(char signed),"automatic success failed");
+static_assert(typeid(unsigned char)==typeid(char unsigned),"automatic success failed");
+static_assert(typeid(short)==typeid(short int),"automatic success failed");
+static_assert(typeid(short)==typeid(int short),"automatic success failed");
+static_assert(typeid(short)==typeid(signed short),"automatic success failed");
+static_assert(typeid(short)==typeid(short signed),"automatic success failed");
+static_assert(typeid(short)==typeid(signed short int),"automatic success failed");
+static_assert(typeid(short)==typeid(short signed int),"automatic success failed");
+static_assert(typeid(short)==typeid(signed int short),"automatic success failed");
+static_assert(typeid(short)==typeid(int signed short),"automatic success failed");
+static_assert(typeid(short)==typeid(short int signed),"automatic success failed");
+static_assert(typeid(short)==typeid(int short signed),"automatic success failed");
+static_assert(typeid(unsigned short)==typeid(short unsigned),"automatic success failed");
+static_assert(typeid(unsigned short)==typeid(unsigned short int),"automatic success failed");
+static_assert(typeid(unsigned short)==typeid(short unsigned int),"automatic success failed");
+static_assert(typeid(unsigned short)==typeid(unsigned int short),"automatic success failed");
+static_assert(typeid(unsigned short)==typeid(int unsigned short),"automatic success failed");
+static_assert(typeid(unsigned short)==typeid(short int unsigned),"automatic success failed");
+static_assert(typeid(unsigned short)==typeid(int short unsigned),"automatic success failed");
+static_assert(typeid(int)==typeid(signed),"automatic success failed");
+static_assert(typeid(int)==typeid(signed int),"automatic success failed");
+static_assert(typeid(int)==typeid(int signed),"automatic success failed");
+static_assert(typeid(unsigned int)==typeid(unsigned),"automatic success failed");
+static_assert(typeid(unsigned int)==typeid(int unsigned),"automatic success failed");
+static_assert(typeid(long)==typeid(long int),"automatic success failed");
+static_assert(typeid(long)==typeid(int long),"automatic success failed");
+static_assert(typeid(long)==typeid(long signed),"automatic success failed");
+static_assert(typeid(long)==typeid(signed long int),"automatic success failed");
+static_assert(typeid(long)==typeid(long signed int),"automatic success failed");
+static_assert(typeid(long)==typeid(signed int long),"automatic success failed");
+static_assert(typeid(long)==typeid(int signed long),"automatic success failed");
+static_assert(typeid(long)==typeid(long int signed),"automatic success failed");
+static_assert(typeid(long)==typeid(int long signed),"automatic success failed");
+static_assert(typeid(unsigned long)==typeid(long unsigned),"automatic success failed");
+static_assert(typeid(unsigned long)==typeid(unsigned long int),"automatic success failed");
+static_assert(typeid(unsigned long)==typeid(long unsigned int),"automatic success failed");
+static_assert(typeid(unsigned long)==typeid(unsigned int long),"automatic success failed");
+static_assert(typeid(unsigned long)==typeid(int unsigned long),"automatic success failed");
+static_assert(typeid(unsigned long)==typeid(long int unsigned),"automatic success failed");
+static_assert(typeid(unsigned long)==typeid(int long unsigned),"automatic success failed");
+static_assert(typeid(long long)==typeid(long long int),"automatic success failed");
+static_assert(typeid(long long)==typeid(long int long),"automatic success failed");
+static_assert(typeid(long long)==typeid(int long long),"automatic success failed");
+static_assert(typeid(long long)==typeid(signed long long),"automatic success failed");
+static_assert(typeid(long long)==typeid(long signed long),"automatic success failed");
+static_assert(typeid(long long)==typeid(long long signed),"automatic success failed");
+static_assert(typeid(long long)==typeid(signed long long int),"automatic success failed");
+static_assert(typeid(long long)==typeid(int long long signed),"automatic success failed");
+static_assert(typeid(long long)==typeid(signed int long long),"automatic success failed");
+static_assert(typeid(long long)==typeid(int signed long long),"automatic success failed");
+static_assert(typeid(long long)==typeid(signed long int long),"automatic success failed");
+static_assert(typeid(long long)==typeid(int long signed long),"automatic success failed");
+static_assert(typeid(long long)==typeid(long long signed int),"automatic success failed");
+static_assert(typeid(long long)==typeid(long long int signed),"automatic success failed");
+static_assert(typeid(long long)==typeid(long signed long int),"automatic success failed");
+static_assert(typeid(long long)==typeid(long int long signed),"automatic success failed");
+static_assert(typeid(long long)==typeid(long signed int long),"automatic success failed");
+static_assert(typeid(long long)==typeid(long int signed long),"automatic success failed");
+static_assert(typeid(unsigned long long)==typeid(long long unsigned),"automatic success failed");
+static_assert(typeid(unsigned long long)==typeid(unsigned long long int),"automatic success failed");
+static_assert(typeid(unsigned long long)==typeid(int long long unsigned),"automatic success failed");
+static_assert(typeid(unsigned long long)==typeid(unsigned int long long),"automatic success failed");
+static_assert(typeid(unsigned long long)==typeid(int unsigned long long),"automatic success failed");
+static_assert(typeid(unsigned long long)==typeid(unsigned long int long),"automatic success failed");
+static_assert(typeid(unsigned long long)==typeid(int long unsigned long),"automatic success failed");
+static_assert(typeid(unsigned long long)==typeid(long long unsigned int),"automatic success failed");
+static_assert(typeid(unsigned long long)==typeid(long long int unsigned),"automatic success failed");
+static_assert(typeid(unsigned long long)==typeid(long unsigned long int),"automatic success failed");
+static_assert(typeid(unsigned long long)==typeid(long int long unsigned),"automatic success failed");
+static_assert(typeid(unsigned long long)==typeid(long unsigned int long),"automatic success failed");
+static_assert(typeid(unsigned long long)==typeid(long int unsigned long),"automatic success failed");
+static_assert(typeid(long double)==typeid(double long),"automatic success failed");
+static_assert(typeid(float _Complex)==typeid(_Complex float),"automatic success failed");
+static_assert(typeid(double _Complex)==typeid(_Complex double),"automatic success failed");
+static_assert(typeid(long double _Complex)==typeid(double long _Complex),"automatic success failed");
+static_assert(typeid(long double _Complex)==typeid(long _Complex double),"automatic success failed");
+static_assert(typeid(long double _Complex)==typeid(_Complex long double),"automatic success failed");
+static_assert(typeid(long double _Complex)==typeid(double _Complex long),"automatic success failed");
+static_assert(typeid(long double _Complex)==typeid(_Complex double long),"automatic success failed");
+
 // inequality checks
 static_assert(typeid(void)!=typeid(bool),"automatic success failed");
 static_assert(typeid(void)!=typeid(char),"automatic success failed");
@@ -50,6 +136,7 @@
 static_assert(typeid(void)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(void)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(void)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(void)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(bool)!=typeid(void),"automatic success failed");
 static_assert(typeid(bool)!=typeid(char),"automatic success failed");
@@ -69,6 +156,7 @@
 static_assert(typeid(bool)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(bool)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(bool)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(bool)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(char)!=typeid(void),"automatic success failed");
 static_assert(typeid(char)!=typeid(bool),"automatic success failed");
@@ -88,6 +176,7 @@
 static_assert(typeid(char)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(char)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(char)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(char)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(signed char)!=typeid(void),"automatic success failed");
 static_assert(typeid(signed char)!=typeid(bool),"automatic success failed");
@@ -107,6 +196,7 @@
 static_assert(typeid(signed char)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(signed char)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(signed char)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(signed char)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(unsigned char)!=typeid(void),"automatic success failed");
 static_assert(typeid(unsigned char)!=typeid(bool),"automatic success failed");
@@ -126,6 +216,7 @@
 static_assert(typeid(unsigned char)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(unsigned char)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(unsigned char)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(unsigned char)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(short)!=typeid(void),"automatic success failed");
 static_assert(typeid(short)!=typeid(bool),"automatic success failed");
@@ -145,6 +236,7 @@
 static_assert(typeid(short)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(short)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(short)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(short)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(unsigned short)!=typeid(void),"automatic success failed");
 static_assert(typeid(unsigned short)!=typeid(bool),"automatic success failed");
@@ -164,6 +256,7 @@
 static_assert(typeid(unsigned short)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(unsigned short)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(unsigned short)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(unsigned short)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(int)!=typeid(void),"automatic success failed");
 static_assert(typeid(int)!=typeid(bool),"automatic success failed");
@@ -183,6 +276,7 @@
 static_assert(typeid(int)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(int)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(int)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(int)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(unsigned int)!=typeid(void),"automatic success failed");
 static_assert(typeid(unsigned int)!=typeid(bool),"automatic success failed");
@@ -202,6 +296,7 @@
 static_assert(typeid(unsigned int)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(unsigned int)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(unsigned int)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(unsigned int)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(long)!=typeid(void),"automatic success failed");
 static_assert(typeid(long)!=typeid(bool),"automatic success failed");
@@ -221,6 +316,7 @@
 static_assert(typeid(long)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(long)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(long)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(long)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(unsigned long)!=typeid(void),"automatic success failed");
 static_assert(typeid(unsigned long)!=typeid(bool),"automatic success failed");
@@ -240,6 +336,7 @@
 static_assert(typeid(unsigned long)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(unsigned long)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(unsigned long)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(unsigned long)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(long long)!=typeid(void),"automatic success failed");
 static_assert(typeid(long long)!=typeid(bool),"automatic success failed");
@@ -259,6 +356,7 @@
 static_assert(typeid(long long)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(long long)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(long long)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(long long)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(unsigned long long)!=typeid(void),"automatic success failed");
 static_assert(typeid(unsigned long long)!=typeid(bool),"automatic success failed");
@@ -278,6 +376,7 @@
 static_assert(typeid(unsigned long long)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(unsigned long long)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(unsigned long long)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(unsigned long long)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(float)!=typeid(void),"automatic success failed");
 static_assert(typeid(float)!=typeid(bool),"automatic success failed");
@@ -297,6 +396,7 @@
 static_assert(typeid(float)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(float)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(float)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(float)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(double)!=typeid(void),"automatic success failed");
 static_assert(typeid(double)!=typeid(bool),"automatic success failed");
@@ -316,6 +416,7 @@
 static_assert(typeid(double)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(double)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(double)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(double)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(long double)!=typeid(void),"automatic success failed");
 static_assert(typeid(long double)!=typeid(bool),"automatic success failed");
@@ -335,6 +436,7 @@
 static_assert(typeid(long double)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(long double)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(long double)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(long double)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(float _Complex)!=typeid(void),"automatic success failed");
 static_assert(typeid(float _Complex)!=typeid(bool),"automatic success failed");
@@ -354,6 +456,7 @@
 static_assert(typeid(float _Complex)!=typeid(long double),"automatic success failed");
 static_assert(typeid(float _Complex)!=typeid(double _Complex),"automatic success failed");
 static_assert(typeid(float _Complex)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(float _Complex)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(double _Complex)!=typeid(void),"automatic success failed");
 static_assert(typeid(double _Complex)!=typeid(bool),"automatic success failed");
@@ -373,6 +476,7 @@
 static_assert(typeid(double _Complex)!=typeid(long double),"automatic success failed");
 static_assert(typeid(double _Complex)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(double _Complex)!=typeid(long double _Complex),"automatic success failed");
+static_assert(typeid(double _Complex)!=typeid(wchar_t),"automatic success failed");
 
 static_assert(typeid(long double _Complex)!=typeid(void),"automatic success failed");
 static_assert(typeid(long double _Complex)!=typeid(bool),"automatic success failed");
@@ -392,4 +496,25 @@
 static_assert(typeid(long double _Complex)!=typeid(long double),"automatic success failed");
 static_assert(typeid(long double _Complex)!=typeid(float _Complex),"automatic success failed");
 static_assert(typeid(long double _Complex)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(long double _Complex)!=typeid(wchar_t),"automatic success failed");
 
+static_assert(typeid(wchar_t)!=typeid(void),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(bool),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(char),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(signed char),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(unsigned char),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(short),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(unsigned short),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(int),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(unsigned int),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(long),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(unsigned long),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(long long),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(unsigned long long),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(float),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(double),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(long double),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(float _Complex),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(double _Complex),"automatic success failed");
+static_assert(typeid(wchar_t)!=typeid(long double _Complex),"automatic success failed");
+



