From zaimoni at mail.berlios.de  Sat Sep  5 00:05:25 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 5 Sep 2009 00:05:25 +0200
Subject: [Zcplusplus-commits] r242 - in trunk: . Zaimoni.STL
	Zaimoni.STL/Pure.C Zaimoni.STL/Pure.C/stdio.log lib lib/MSVC32.zcc
Message-ID: <200909042205.n84M5Pi5011677@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-05 00:05:15 +0200 (Sat, 05 Sep 2009)
New Revision: 242

Added:
   trunk/Zaimoni.STL/NMake.inc
   trunk/Zaimoni.STL/NMakefile
   trunk/Zaimoni.STL/Pure.C/NMakefile
   trunk/Zaimoni.STL/Pure.C/stdio.log/NMakefile
   trunk/lib/MSVC32.zcc/
   trunk/lib/MSVC32.zcc/stdbool.h
   trunk/lib/MSVC32.zcc/stdint.h
Modified:
   trunk/README.txt
Log:
start of NMake build system for MSVC

Modified: trunk/README.txt
===================================================================
--- trunk/README.txt	2009-08-29 23:43:22 UTC (rev 241)
+++ trunk/README.txt	2009-09-04 22:05:15 UTC (rev 242)
@@ -26,3 +26,32 @@
 * They do not run the content-comparison tests.
 
 4) make install [to be implemented]
+
+Installation instructions with Microsoft NMake for Visual C++ 2008 Express, 32-bit
+-1) Install the Boost libraries ( http://www.boost.org/ ) first.
+0) Install the Zaimoni.STL directory second.
+0.1) Adjust NMake.inc to have the correct values for your system.  The files in MSVC32.zcc must be on an include path, they are C99 compatibility glue.
+0.2) nmake /F NMakefile [this is incomplete currently compared to GNU Make]
+0.3) nmake /F NMakefile install if there were no errors
+
+1) Adjust NMake.inc to have the correct values for your system.  Also adjust 
+   the INSTALL_TO macro in CPreproc.cpp to point to the root build directory.
+2) nmake /F NMakefile [to be implemented]
+3) using a Bourne shell in the tests/cpp subdirectory:
+* ./run_tests.sh to check expected behavior
+** C99 conformance with -pedantic option
+** default non-conforming corner-case handling (intercept errors early)
+* ./run_tests_C99.sh is also present to check only C99 conformance; changing 
+  the preprocessor line here should allow checking other preprocessors for 
+  C99 conformance.
+* Both shell scripts will count: accepted rejection tests, rejected 
+  acceptance tests, and tests that were rejected because an assertion went off.  
+  (The last assumes compiling without NDEBUG, and that the exit code for 
+  an assertion is 3.)  All tests that have unexpected behavior should be listed.
+3a) Windows batch files run_tests.bat and run_tests_C99.bat are also provided 
+  for use with the Windows command processor, with mostly-comparable meaning.
+* They do not have the assertion-count capability.
+* They only list the last test case in each category that had unexpected behavior.
+* They do not run the content-comparison tests.
+
+4) nmake /F NMakefile install [to be implemented]

Added: trunk/Zaimoni.STL/NMake.inc
===================================================================
--- trunk/Zaimoni.STL/NMake.inc	2009-08-29 23:43:22 UTC (rev 241)
+++ trunk/Zaimoni.STL/NMake.inc	2009-09-04 22:05:15 UTC (rev 242)
@@ -0,0 +1,18 @@
+# GNU compatibility core
+prefix = \MSVC9.0\VC
+exec_prefix = $(prefix)
+bindir = $(exec_prefix)\bin
+includedir = $(exec_prefix)\include
+libdir = $(exec_prefix)\lib
+
+AR = lib
+# CC, CXX handled by NMake defaults
+
+EXEEXT = exe
+OBJEXT = obj
+
+# other control points
+# FORCE_ISO: ZAIMONI_FORCE_ISO disables the custom memory manager
+FORCE_ISO =
+# FORCE_ISO = -DZAIMONI_FORCE_ISO
+

Added: trunk/Zaimoni.STL/NMakefile
===================================================================
--- trunk/Zaimoni.STL/NMakefile	2009-08-29 23:43:22 UTC (rev 241)
+++ trunk/Zaimoni.STL/NMakefile	2009-09-04 22:05:15 UTC (rev 242)
@@ -0,0 +1,32 @@
+# NMake makefile for Zaimoni.STL
+# pure.C must be done first: Pure.C/auto_int.h is a generated file
+
+# GNU targets we know about
+all:
+	cd pure.C
+	nmake /F NMakefile all
+	cd stdio.log
+	nmake /F NMakefile all
+	cd ..\..
+
+clean:
+	cd pure.C
+	nmake /F NMakefile clean
+	cd stdio.log
+	nmake /F NMakefile clean
+	cd ..\..
+
+install:
+	cd pure.C
+	nmake /F NMakefile install
+	cd stdio.log
+	nmake /F NMakefile install
+	cd ..\..
+
+uninstall:
+	cd pure.C
+	nmake /F NMakefile uninstall
+	cd stdio.log
+	nmake /F NMakefile uninstall
+	cd ..\..
+

Added: trunk/Zaimoni.STL/Pure.C/NMakefile
===================================================================
--- trunk/Zaimoni.STL/Pure.C/NMakefile	2009-08-29 23:43:22 UTC (rev 241)
+++ trunk/Zaimoni.STL/Pure.C/NMakefile	2009-09-04 22:05:15 UTC (rev 242)
@@ -0,0 +1,40 @@
+# Makefile for pure.C directory
+# assumes M$ NMake
+
+.SUFFIXES:
+.SUFFIXES: .c .lib .obj
+
+!INCLUDE ..\NMake.inc
+
+# /Wall warns on system headers in VC 2008, not good
+CFLAGS = /O1 /EHsc /MD /W3
+
+LIBS = z_format_util.lib
+
+# GNU targets we know about
+all: $(LIBS) auto_int.h
+
+clean:
+	del *.lib *.obj auto_int.h
+
+install: $(libdir)\z_format_util.lib $(libdir)\z_logging.lib
+
+uninstall:
+	del $(libdir)\z_format_util.lib
+
+# rules
+format_util.obj: format_util.c format_util.h
+
+auto_int.h : int_probe.c
+	$(CC) -oint_probe.exe $(CFLAGS) int_probe.c
+	.\int_probe.exe > auto_int.h
+	del int_probe.exe.manifest
+	del int_probe.exe
+
+# defaulting .c.obj
+z_format_util.lib: format_util.obj
+	$(AR) /OUT:z_format_util.lib format_util.obj
+
+$(libdir)\z_format_util.lib: z_format_util.lib
+	copy /Y z_format_util.lib $(libdir)\z_format_util.lib
+

Added: trunk/Zaimoni.STL/Pure.C/stdio.log/NMakefile
===================================================================
--- trunk/Zaimoni.STL/Pure.C/stdio.log/NMakefile	2009-08-29 23:43:22 UTC (rev 241)
+++ trunk/Zaimoni.STL/Pure.C/stdio.log/NMakefile	2009-09-04 22:05:15 UTC (rev 242)
@@ -0,0 +1,31 @@
+# Makefile for pure.C directory
+# assumes M$ NMake
+
+.SUFFIXES:
+.SUFFIXES: .c .lib .obj
+
+!INCLUDE ..\..\NMake.inc
+
+# /Wall warns on system headers in VC 2008, not good
+CFLAGS = /O1 /EHsc /MD /W3
+
+LIBS = z_stdio_log.lib
+
+# GNU targets we know about
+all: $(LIBS)
+
+clean:
+	del *.lib *.obj
+
+install: $(libdir)\z_stdio_log.lib
+
+uninstall:
+	del $(libdir)\z_stdio_log.lib
+
+# rules (defaulting .c.obj)
+z_stdio_log.lib: fatal.obj fatal_code.obj inform.obj inc_inform.obj log.obj
+	$(AR) /OUT:z_stdio_log.lib fatal.obj fatal_code.obj inform.obj inc_inform.obj log.obj
+
+$(libdir)/z_stdio_log.lib: z_stdio_log.lib
+	copy /Y z_stdio_log.lib $(libdir)\z_stdio_log.lib
+

Added: trunk/lib/MSVC32.zcc/stdbool.h
===================================================================
--- trunk/lib/MSVC32.zcc/stdbool.h	2009-08-29 23:43:22 UTC (rev 241)
+++ trunk/lib/MSVC32.zcc/stdbool.h	2009-09-04 22:05:15 UTC (rev 242)
@@ -0,0 +1,38 @@
+/* stdbool.h */
+/* C99 7.16: define following macros: __bool_true_false_are_defined, bool, true, false */
+/* (C)2009 Kenneth Boyd, license: MIT.txt */
+
+#ifndef __STDBOOL_H__
+#define __STDBOOL_H__ 1
+
+#ifdef __bool_true_false_are_defined
+#error Undefined Behavior: reserved identifier '__bool_true_false_are_defined' defined as macro
+#undef __bool_true_false_are_defined
+#endif
+#define __bool_true_false_are_defined 1
+
+/* other macros aren't allowed in C++*/
+#ifndef __cplusplus
+#ifdef bool
+#error Undefined Behavior: reserved identifier 'bool' defined as macro
+#undef bool
+#endif
+/* MSVC, like other C90 compilers, does not provide _Bool. */
+#define bool unsigned char
+
+#ifdef true
+#error Undefined Behavior: reserved identifier 'true' defined as macro
+#undef true
+#endif
+#define true 1
+
+#ifdef false
+#error Undefined Behavior: reserved identifier 'false' defined as macro
+#undef false
+#endif
+#define false 0
+
+/* C99 standard explicitly allows undefining/redefining bool, true, and false -- so don't lock them */
+#endif
+
+#endif

Added: trunk/lib/MSVC32.zcc/stdint.h
===================================================================
--- trunk/lib/MSVC32.zcc/stdint.h	2009-08-29 23:43:22 UTC (rev 241)
+++ trunk/lib/MSVC32.zcc/stdint.h	2009-09-04 22:05:15 UTC (rev 242)
@@ -0,0 +1,971 @@
+#ifndef __STDINT_H__
+#define __STDINT_H__ 1
+typedef unsigned char uint8_t;
+typedef unsigned short uint16_t;
+typedef unsigned int uint32_t;
+typedef unsigned long long uint64_t;
+typedef signed char int8_t;
+typedef short int16_t;
+typedef int int32_t;
+typedef long long int64_t;
+#define INT8_MIN -128
+#define INT8_MAX 127
+#define UINT8_MAX 255U
+#define INT16_MIN -32768
+#define INT16_MAX 32767
+#define UINT16_MAX 65535U
+#define INT32_MIN -2147483648
+#define INT32_MAX 2147483647
+#define UINT32_MAX 4294967295U
+#define INT64_MIN (-1-9223372036854775807LL)
+#define INT64_MAX 9223372036854775807LL
+#define UINT64_MAX 18446744073709551615ULL
+typedef int intptr_t;
+typedef unsigned int uintptr_t;
+#define INTPTR_MIN -2147483648
+#define INTPTR_MAX 2147483647
+#define UINTPTR_MAX 4294967295U
+typedef long long intmax_t;
+typedef unsigned long long uintmax_t;
+#define INTMAX_MIN (-1-9223372036854775807LL)
+#define INTMAX_MAX 9223372036854775807LL
+#define UINTMAX_MAX 18446744073709551615ULL
+#define INTMAX_C(A) A##LL
+#define UINTMAX_C(A) A##ULL
+#define PTRDIFF_MIN -2147483648
+#define PTRDIFF_MAX 2147483647
+#ifndef SIZE_MAX
+/* native MSVC limits.h incorrectly defines SIZE_MAX */
+#define SIZE_MAX 4294967295U
+#endif
+#define WCHAR_MIN 0
+#define WCHAR_MAX 4294967295U
+typedef signed char int_fast8_t;
+typedef unsigned int uint_fast8_t;
+typedef signed char int_least8_t;
+typedef unsigned char uint_least8_t;
+#define INT_LEAST8_MIN -128
+#define INT_LEAST8_MAX 127
+#define UINT_LEAST8_MAX 255U
+#define INT_FAST8_MIN -2147483648
+#define INT_FAST8_MAX 2147483647
+#define UINT_FAST8_MAX 4294967295U
+#define INT8_C(A) A
+#define UINT8_C(A) A
+typedef short int_fast9_t;
+typedef unsigned int uint_fast9_t;
+typedef short int_least9_t;
+typedef unsigned short uint_least9_t;
+#define INT_LEAST9_MIN -32768
+#define INT_LEAST9_MAX 32767
+#define UINT_LEAST9_MAX 65535U
+#define INT_FAST9_MIN -2147483648
+#define INT_FAST9_MAX 2147483647
+#define UINT_FAST9_MAX 4294967295U
+#define INT9_C(A) A
+#define UINT9_C(A) A
+typedef short int_fast10_t;
+typedef unsigned int uint_fast10_t;
+typedef short int_least10_t;
+typedef unsigned short uint_least10_t;
+#define INT_LEAST10_MIN -32768
+#define INT_LEAST10_MAX 32767
+#define UINT_LEAST10_MAX 65535U
+#define INT_FAST10_MIN -2147483648
+#define INT_FAST10_MAX 2147483647
+#define UINT_FAST10_MAX 4294967295U
+#define INT10_C(A) A
+#define UINT10_C(A) A
+typedef short int_fast11_t;
+typedef unsigned int uint_fast11_t;
+typedef short int_least11_t;
+typedef unsigned short uint_least11_t;
+#define INT_LEAST11_MIN -32768
+#define INT_LEAST11_MAX 32767
+#define UINT_LEAST11_MAX 65535U
+#define INT_FAST11_MIN -2147483648
+#define INT_FAST11_MAX 2147483647
+#define UINT_FAST11_MAX 4294967295U
+#define INT11_C(A) A
+#define UINT11_C(A) A
+typedef short int_fast12_t;
+typedef unsigned int uint_fast12_t;
+typedef short int_least12_t;
+typedef unsigned short uint_least12_t;
+#define INT_LEAST12_MIN -32768
+#define INT_LEAST12_MAX 32767
+#define UINT_LEAST12_MAX 65535U
+#define INT_FAST12_MIN -2147483648
+#define INT_FAST12_MAX 2147483647
+#define UINT_FAST12_MAX 4294967295U
+#define INT12_C(A) A
+#define UINT12_C(A) A
+typedef short int_fast13_t;
+typedef unsigned int uint_fast13_t;
+typedef short int_least13_t;
+typedef unsigned short uint_least13_t;
+#define INT_LEAST13_MIN -32768
+#define INT_LEAST13_MAX 32767
+#define UINT_LEAST13_MAX 65535U
+#define INT_FAST13_MIN -2147483648
+#define INT_FAST13_MAX 2147483647
+#define UINT_FAST13_MAX 4294967295U
+#define INT13_C(A) A
+#define UINT13_C(A) A
+typedef short int_fast14_t;
+typedef unsigned int uint_fast14_t;
+typedef short int_least14_t;
+typedef unsigned short uint_least14_t;
+#define INT_LEAST14_MIN -32768
+#define INT_LEAST14_MAX 32767
+#define UINT_LEAST14_MAX 65535U
+#define INT_FAST14_MIN -2147483648
+#define INT_FAST14_MAX 2147483647
+#define UINT_FAST14_MAX 4294967295U
+#define INT14_C(A) A
+#define UINT14_C(A) A
+typedef short int_fast15_t;
+typedef unsigned int uint_fast15_t;
+typedef short int_least15_t;
+typedef unsigned short uint_least15_t;
+#define INT_LEAST15_MIN -32768
+#define INT_LEAST15_MAX 32767
+#define UINT_LEAST15_MAX 65535U
+#define INT_FAST15_MIN -2147483648
+#define INT_FAST15_MAX 2147483647
+#define UINT_FAST15_MAX 4294967295U
+#define INT15_C(A) A
+#define UINT15_C(A) A
+typedef short int_fast16_t;
+typedef unsigned int uint_fast16_t;
+typedef short int_least16_t;
+typedef unsigned short uint_least16_t;
+#define INT_LEAST16_MIN -32768
+#define INT_LEAST16_MAX 32767
+#define UINT_LEAST16_MAX 65535U
+#define INT_FAST16_MIN -2147483648
+#define INT_FAST16_MAX 2147483647
+#define UINT_FAST16_MAX 4294967295U
+#define INT16_C(A) A
+#define UINT16_C(A) A
+typedef int int_fast17_t;
+typedef unsigned int uint_fast17_t;
+typedef int int_least17_t;
+typedef unsigned int uint_least17_t;
+#define INT_LEAST17_MIN -2147483648
+#define INT_LEAST17_MAX 2147483647
+#define UINT_LEAST17_MAX 4294967295U
+#define INT_FAST17_MIN -2147483648
+#define INT_FAST17_MAX 2147483647
+#define UINT_FAST17_MAX 4294967295U
+#define INT17_C(A) A
+#define UINT17_C(A) A##U
+typedef int int_fast18_t;
+typedef unsigned int uint_fast18_t;
+typedef int int_least18_t;
+typedef unsigned int uint_least18_t;
+#define INT_LEAST18_MIN -2147483648
+#define INT_LEAST18_MAX 2147483647
+#define UINT_LEAST18_MAX 4294967295U
+#define INT_FAST18_MIN -2147483648
+#define INT_FAST18_MAX 2147483647
+#define UINT_FAST18_MAX 4294967295U
+#define INT18_C(A) A
+#define UINT18_C(A) A##U
+typedef int int_fast19_t;
+typedef unsigned int uint_fast19_t;
+typedef int int_least19_t;
+typedef unsigned int uint_least19_t;
+#define INT_LEAST19_MIN -2147483648
+#define INT_LEAST19_MAX 2147483647
+#define UINT_LEAST19_MAX 4294967295U
+#define INT_FAST19_MIN -2147483648
+#define INT_FAST19_MAX 2147483647
+#define UINT_FAST19_MAX 4294967295U
+#define INT19_C(A) A
+#define UINT19_C(A) A##U
+typedef int int_fast20_t;
+typedef unsigned int uint_fast20_t;
+typedef int int_least20_t;
+typedef unsigned int uint_least20_t;
+#define INT_LEAST20_MIN -2147483648
+#define INT_LEAST20_MAX 2147483647
+#define UINT_LEAST20_MAX 4294967295U
+#define INT_FAST20_MIN -2147483648
+#define INT_FAST20_MAX 2147483647
+#define UINT_FAST20_MAX 4294967295U
+#define INT20_C(A) A
+#define UINT20_C(A) A##U
+typedef int int_fast21_t;
+typedef unsigned int uint_fast21_t;
+typedef int int_least21_t;
+typedef unsigned int uint_least21_t;
+#define INT_LEAST21_MIN -2147483648
+#define INT_LEAST21_MAX 2147483647
+#define UINT_LEAST21_MAX 4294967295U
+#define INT_FAST21_MIN -2147483648
+#define INT_FAST21_MAX 2147483647
+#define UINT_FAST21_MAX 4294967295U
+#define INT21_C(A) A
+#define UINT21_C(A) A##U
+typedef int int_fast22_t;
+typedef unsigned int uint_fast22_t;
+typedef int int_least22_t;
+typedef unsigned int uint_least22_t;
+#define INT_LEAST22_MIN -2147483648
+#define INT_LEAST22_MAX 2147483647
+#define UINT_LEAST22_MAX 4294967295U
+#define INT_FAST22_MIN -2147483648
+#define INT_FAST22_MAX 2147483647
+#define UINT_FAST22_MAX 4294967295U
+#define INT22_C(A) A
+#define UINT22_C(A) A##U
+typedef int int_fast23_t;
+typedef unsigned int uint_fast23_t;
+typedef int int_least23_t;
+typedef unsigned int uint_least23_t;
+#define INT_LEAST23_MIN -2147483648
+#define INT_LEAST23_MAX 2147483647
+#define UINT_LEAST23_MAX 4294967295U
+#define INT_FAST23_MIN -2147483648
+#define INT_FAST23_MAX 2147483647
+#define UINT_FAST23_MAX 4294967295U
+#define INT23_C(A) A
+#define UINT23_C(A) A##U
+typedef int int_fast24_t;
+typedef unsigned int uint_fast24_t;
+typedef int int_least24_t;
+typedef unsigned int uint_least24_t;
+#define INT_LEAST24_MIN -2147483648
+#define INT_LEAST24_MAX 2147483647
+#define UINT_LEAST24_MAX 4294967295U
+#define INT_FAST24_MIN -2147483648
+#define INT_FAST24_MAX 2147483647
+#define UINT_FAST24_MAX 4294967295U
+#define INT24_C(A) A
+#define UINT24_C(A) A##U
+typedef int int_fast25_t;
+typedef unsigned int uint_fast25_t;
+typedef int int_least25_t;
+typedef unsigned int uint_least25_t;
+#define INT_LEAST25_MIN -2147483648
+#define INT_LEAST25_MAX 2147483647
+#define UINT_LEAST25_MAX 4294967295U
+#define INT_FAST25_MIN -2147483648
+#define INT_FAST25_MAX 2147483647
+#define UINT_FAST25_MAX 4294967295U
+#define INT25_C(A) A
+#define UINT25_C(A) A##U
+typedef int int_fast26_t;
+typedef unsigned int uint_fast26_t;
+typedef int int_least26_t;
+typedef unsigned int uint_least26_t;
+#define INT_LEAST26_MIN -2147483648
+#define INT_LEAST26_MAX 2147483647
+#define UINT_LEAST26_MAX 4294967295U
+#define INT_FAST26_MIN -2147483648
+#define INT_FAST26_MAX 2147483647
+#define UINT_FAST26_MAX 4294967295U
+#define INT26_C(A) A
+#define UINT26_C(A) A##U
+typedef int int_fast27_t;
+typedef unsigned int uint_fast27_t;
+typedef int int_least27_t;
+typedef unsigned int uint_least27_t;
+#define INT_LEAST27_MIN -2147483648
+#define INT_LEAST27_MAX 2147483647
+#define UINT_LEAST27_MAX 4294967295U
+#define INT_FAST27_MIN -2147483648
+#define INT_FAST27_MAX 2147483647
+#define UINT_FAST27_MAX 4294967295U
+#define INT27_C(A) A
+#define UINT27_C(A) A##U
+typedef int int_fast28_t;
+typedef unsigned int uint_fast28_t;
+typedef int int_least28_t;
+typedef unsigned int uint_least28_t;
+#define INT_LEAST28_MIN -2147483648
+#define INT_LEAST28_MAX 2147483647
+#define UINT_LEAST28_MAX 4294967295U
+#define INT_FAST28_MIN -2147483648
+#define INT_FAST28_MAX 2147483647
+#define UINT_FAST28_MAX 4294967295U
+#define INT28_C(A) A
+#define UINT28_C(A) A##U
+typedef int int_fast29_t;
+typedef unsigned int uint_fast29_t;
+typedef int int_least29_t;
+typedef unsigned int uint_least29_t;
+#define INT_LEAST29_MIN -2147483648
+#define INT_LEAST29_MAX 2147483647
+#define UINT_LEAST29_MAX 4294967295U
+#define INT_FAST29_MIN -2147483648
+#define INT_FAST29_MAX 2147483647
+#define UINT_FAST29_MAX 4294967295U
+#define INT29_C(A) A
+#define UINT29_C(A) A##U
+typedef int int_fast30_t;
+typedef unsigned int uint_fast30_t;
+typedef int int_least30_t;
+typedef unsigned int uint_least30_t;
+#define INT_LEAST30_MIN -2147483648
+#define INT_LEAST30_MAX 2147483647
+#define UINT_LEAST30_MAX 4294967295U
+#define INT_FAST30_MIN -2147483648
+#define INT_FAST30_MAX 2147483647
+#define UINT_FAST30_MAX 4294967295U
+#define INT30_C(A) A
+#define UINT30_C(A) A##U
+typedef int int_fast31_t;
+typedef unsigned int uint_fast31_t;
+typedef int int_least31_t;
+typedef unsigned int uint_least31_t;
+#define INT_LEAST31_MIN -2147483648
+#define INT_LEAST31_MAX 2147483647
+#define UINT_LEAST31_MAX 4294967295U
+#define INT_FAST31_MIN -2147483648
+#define INT_FAST31_MAX 2147483647
+#define UINT_FAST31_MAX 4294967295U
+#define INT31_C(A) A
+#define UINT31_C(A) A##U
+typedef int int_fast32_t;
+typedef unsigned int uint_fast32_t;
+typedef int int_least32_t;
+typedef unsigned int uint_least32_t;
+#define INT_LEAST32_MIN -2147483648
+#define INT_LEAST32_MAX 2147483647
+#define UINT_LEAST32_MAX 4294967295U
+#define INT_FAST32_MIN -2147483648
+#define INT_FAST32_MAX 2147483647
+#define UINT_FAST32_MAX 4294967295U
+#define INT32_C(A) A
+#define UINT32_C(A) A##U
+typedef long long int_fast33_t;
+typedef unsigned long long uint_fast33_t;
+typedef long long int_least33_t;
+typedef unsigned long long uint_least33_t;
+#define INT_LEAST33_MIN (-1-9223372036854775807LL)
+#define INT_LEAST33_MAX 9223372036854775807LL
+#define UINT_LEAST33_MAX 18446744073709551615ULL
+#define INT_FAST33_MIN (-1-9223372036854775807LL)
+#define INT_FAST33_MAX 9223372036854775807LL
+#define UINT_FAST33_MAX 18446744073709551615ULL
+#define INT33_C(A) A##LL
+#define UINT33_C(A) A##ULL
+typedef long long int_fast34_t;
+typedef unsigned long long uint_fast34_t;
+typedef long long int_least34_t;
+typedef unsigned long long uint_least34_t;
+#define INT_LEAST34_MIN (-1-9223372036854775807LL)
+#define INT_LEAST34_MAX 9223372036854775807LL
+#define UINT_LEAST34_MAX 18446744073709551615ULL
+#define INT_FAST34_MIN (-1-9223372036854775807LL)
+#define INT_FAST34_MAX 9223372036854775807LL
+#define UINT_FAST34_MAX 18446744073709551615ULL
+#define INT34_C(A) A##LL
+#define UINT34_C(A) A##ULL
+typedef long long int_fast35_t;
+typedef unsigned long long uint_fast35_t;
+typedef long long int_least35_t;
+typedef unsigned long long uint_least35_t;
+#define INT_LEAST35_MIN (-1-9223372036854775807LL)
+#define INT_LEAST35_MAX 9223372036854775807LL
+#define UINT_LEAST35_MAX 18446744073709551615ULL
+#define INT_FAST35_MIN (-1-9223372036854775807LL)
+#define INT_FAST35_MAX 9223372036854775807LL
+#define UINT_FAST35_MAX 18446744073709551615ULL
+#define INT35_C(A) A##LL
+#define UINT35_C(A) A##ULL
+typedef long long int_fast36_t;
+typedef unsigned long long uint_fast36_t;
+typedef long long int_least36_t;
+typedef unsigned long long uint_least36_t;
+#define INT_LEAST36_MIN (-1-9223372036854775807LL)
+#define INT_LEAST36_MAX 9223372036854775807LL
+#define UINT_LEAST36_MAX 18446744073709551615ULL
+#define INT_FAST36_MIN (-1-9223372036854775807LL)
+#define INT_FAST36_MAX 9223372036854775807LL
+#define UINT_FAST36_MAX 18446744073709551615ULL
+#define INT36_C(A) A##LL
+#define UINT36_C(A) A##ULL
+typedef long long int_fast37_t;
+typedef unsigned long long uint_fast37_t;
+typedef long long int_least37_t;
+typedef unsigned long long uint_least37_t;
+#define INT_LEAST37_MIN (-1-9223372036854775807LL)
+#define INT_LEAST37_MAX 9223372036854775807LL
+#define UINT_LEAST37_MAX 18446744073709551615ULL
+#define INT_FAST37_MIN (-1-9223372036854775807LL)
+#define INT_FAST37_MAX 9223372036854775807LL
+#define UINT_FAST37_MAX 18446744073709551615ULL
+#define INT37_C(A) A##LL
+#define UINT37_C(A) A##ULL
+typedef long long int_fast38_t;
+typedef unsigned long long uint_fast38_t;
+typedef long long int_least38_t;
+typedef unsigned long long uint_least38_t;
+#define INT_LEAST38_MIN (-1-9223372036854775807LL)
+#define INT_LEAST38_MAX 9223372036854775807LL
+#define UINT_LEAST38_MAX 18446744073709551615ULL
+#define INT_FAST38_MIN (-1-9223372036854775807LL)
+#define INT_FAST38_MAX 9223372036854775807LL
+#define UINT_FAST38_MAX 18446744073709551615ULL
+#define INT38_C(A) A##LL
+#define UINT38_C(A) A##ULL
+typedef long long int_fast39_t;
+typedef unsigned long long uint_fast39_t;
+typedef long long int_least39_t;
+typedef unsigned long long uint_least39_t;
+#define INT_LEAST39_MIN (-1-9223372036854775807LL)
+#define INT_LEAST39_MAX 9223372036854775807LL
+#define UINT_LEAST39_MAX 18446744073709551615ULL
+#define INT_FAST39_MIN (-1-9223372036854775807LL)
+#define INT_FAST39_MAX 9223372036854775807LL
+#define UINT_FAST39_MAX 18446744073709551615ULL
+#define INT39_C(A) A##LL
+#define UINT39_C(A) A##ULL
+typedef long long int_fast40_t;
+typedef unsigned long long uint_fast40_t;
+typedef long long int_least40_t;
+typedef unsigned long long uint_least40_t;
+#define INT_LEAST40_MIN (-1-9223372036854775807LL)
+#define INT_LEAST40_MAX 9223372036854775807LL
+#define UINT_LEAST40_MAX 18446744073709551615ULL
+#define INT_FAST40_MIN (-1-9223372036854775807LL)
+#define INT_FAST40_MAX 9223372036854775807LL
+#define UINT_FAST40_MAX 18446744073709551615ULL
+#define INT40_C(A) A##LL
+#define UINT40_C(A) A##ULL
+typedef long long int_fast41_t;
+typedef unsigned long long uint_fast41_t;
+typedef long long int_least41_t;
+typedef unsigned long long uint_least41_t;
+#define INT_LEAST41_MIN (-1-9223372036854775807LL)
+#define INT_LEAST41_MAX 9223372036854775807LL
+#define UINT_LEAST41_MAX 18446744073709551615ULL
+#define INT_FAST41_MIN (-1-9223372036854775807LL)
+#define INT_FAST41_MAX 9223372036854775807LL
+#define UINT_FAST41_MAX 18446744073709551615ULL
+#define INT41_C(A) A##LL
+#define UINT41_C(A) A##ULL
+typedef long long int_fast42_t;
+typedef unsigned long long uint_fast42_t;
+typedef long long int_least42_t;
+typedef unsigned long long uint_least42_t;
+#define INT_LEAST42_MIN (-1-9223372036854775807LL)
+#define INT_LEAST42_MAX 9223372036854775807LL
+#define UINT_LEAST42_MAX 18446744073709551615ULL
+#define INT_FAST42_MIN (-1-9223372036854775807LL)
+#define INT_FAST42_MAX 9223372036854775807LL
+#define UINT_FAST42_MAX 18446744073709551615ULL
+#define INT42_C(A) A##LL
+#define UINT42_C(A) A##ULL
+typedef long long int_fast43_t;
+typedef unsigned long long uint_fast43_t;
+typedef long long int_least43_t;
+typedef unsigned long long uint_least43_t;
+#define INT_LEAST43_MIN (-1-9223372036854775807LL)
+#define INT_LEAST43_MAX 9223372036854775807LL
+#define UINT_LEAST43_MAX 18446744073709551615ULL
+#define INT_FAST43_MIN (-1-9223372036854775807LL)
+#define INT_FAST43_MAX 9223372036854775807LL
+#define UINT_FAST43_MAX 18446744073709551615ULL
+#define INT43_C(A) A##LL
+#define UINT43_C(A) A##ULL
+typedef long long int_fast44_t;
+typedef unsigned long long uint_fast44_t;
+typedef long long int_least44_t;
+typedef unsigned long long uint_least44_t;
+#define INT_LEAST44_MIN (-1-9223372036854775807LL)
+#define INT_LEAST44_MAX 9223372036854775807LL
+#define UINT_LEAST44_MAX 18446744073709551615ULL
+#define INT_FAST44_MIN (-1-9223372036854775807LL)
+#define INT_FAST44_MAX 9223372036854775807LL
+#define UINT_FAST44_MAX 18446744073709551615ULL
+#define INT44_C(A) A##LL
+#define UINT44_C(A) A##ULL
+typedef long long int_fast45_t;
+typedef unsigned long long uint_fast45_t;
+typedef long long int_least45_t;
+typedef unsigned long long uint_least45_t;
+#define INT_LEAST45_MIN (-1-9223372036854775807LL)
+#define INT_LEAST45_MAX 9223372036854775807LL
+#define UINT_LEAST45_MAX 18446744073709551615ULL
+#define INT_FAST45_MIN (-1-9223372036854775807LL)
+#define INT_FAST45_MAX 9223372036854775807LL
+#define UINT_FAST45_MAX 18446744073709551615ULL
+#define INT45_C(A) A##LL
+#define UINT45_C(A) A##ULL
+typedef long long int_fast46_t;
+typedef unsigned long long uint_fast46_t;
+typedef long long int_least46_t;
+typedef unsigned long long uint_least46_t;
+#define INT_LEAST46_MIN (-1-9223372036854775807LL)
+#define INT_LEAST46_MAX 9223372036854775807LL
+#define UINT_LEAST46_MAX 18446744073709551615ULL
+#define INT_FAST46_MIN (-1-9223372036854775807LL)
+#define INT_FAST46_MAX 9223372036854775807LL
+#define UINT_FAST46_MAX 18446744073709551615ULL
+#define INT46_C(A) A##LL
+#define UINT46_C(A) A##ULL
+typedef long long int_fast47_t;
+typedef unsigned long long uint_fast47_t;
+typedef long long int_least47_t;
+typedef unsigned long long uint_least47_t;
+#define INT_LEAST47_MIN (-1-9223372036854775807LL)
+#define INT_LEAST47_MAX 9223372036854775807LL
+#define UINT_LEAST47_MAX 18446744073709551615ULL
+#define INT_FAST47_MIN (-1-9223372036854775807LL)
+#define INT_FAST47_MAX 9223372036854775807LL
+#define UINT_FAST47_MAX 18446744073709551615ULL
+#define INT47_C(A) A##LL
+#define UINT47_C(A) A##ULL
+typedef long long int_fast48_t;
+typedef unsigned long long uint_fast48_t;
+typedef long long int_least48_t;
+typedef unsigned long long uint_least48_t;
+#define INT_LEAST48_MIN (-1-9223372036854775807LL)
+#define INT_LEAST48_MAX 9223372036854775807LL
+#define UINT_LEAST48_MAX 18446744073709551615ULL
+#define INT_FAST48_MIN (-1-9223372036854775807LL)
+#define INT_FAST48_MAX 9223372036854775807LL
+#define UINT_FAST48_MAX 18446744073709551615ULL
+#define INT48_C(A) A##LL
+#define UINT48_C(A) A##ULL
+typedef long long int_fast49_t;
+typedef unsigned long long uint_fast49_t;
+typedef long long int_least49_t;
+typedef unsigned long long uint_least49_t;
+#define INT_LEAST49_MIN (-1-9223372036854775807LL)
+#define INT_LEAST49_MAX 9223372036854775807LL
+#define UINT_LEAST49_MAX 18446744073709551615ULL
+#define INT_FAST49_MIN (-1-9223372036854775807LL)
+#define INT_FAST49_MAX 9223372036854775807LL
+#define UINT_FAST49_MAX 18446744073709551615ULL
+#define INT49_C(A) A##LL
+#define UINT49_C(A) A##ULL
+typedef long long int_fast50_t;
+typedef unsigned long long uint_fast50_t;
+typedef long long int_least50_t;
+typedef unsigned long long uint_least50_t;
+#define INT_LEAST50_MIN (-1-9223372036854775807LL)
+#define INT_LEAST50_MAX 9223372036854775807LL
+#define UINT_LEAST50_MAX 18446744073709551615ULL
+#define INT_FAST50_MIN (-1-9223372036854775807LL)
+#define INT_FAST50_MAX 9223372036854775807LL
+#define UINT_FAST50_MAX 18446744073709551615ULL
+#define INT50_C(A) A##LL
+#define UINT50_C(A) A##ULL
+typedef long long int_fast51_t;
+typedef unsigned long long uint_fast51_t;
+typedef long long int_least51_t;
+typedef unsigned long long uint_least51_t;
+#define INT_LEAST51_MIN (-1-9223372036854775807LL)
+#define INT_LEAST51_MAX 9223372036854775807LL
+#define UINT_LEAST51_MAX 18446744073709551615ULL
+#define INT_FAST51_MIN (-1-9223372036854775807LL)
+#define INT_FAST51_MAX 9223372036854775807LL
+#define UINT_FAST51_MAX 18446744073709551615ULL
+#define INT51_C(A) A##LL
+#define UINT51_C(A) A##ULL
+typedef long long int_fast52_t;
+typedef unsigned long long uint_fast52_t;
+typedef long long int_least52_t;
+typedef unsigned long long uint_least52_t;
+#define INT_LEAST52_MIN (-1-9223372036854775807LL)
+#define INT_LEAST52_MAX 9223372036854775807LL
+#define UINT_LEAST52_MAX 18446744073709551615ULL
+#define INT_FAST52_MIN (-1-9223372036854775807LL)
+#define INT_FAST52_MAX 9223372036854775807LL
+#define UINT_FAST52_MAX 18446744073709551615ULL
+#define INT52_C(A) A##LL
+#define UINT52_C(A) A##ULL
+typedef long long int_fast53_t;
+typedef unsigned long long uint_fast53_t;
+typedef long long int_least53_t;
+typedef unsigned long long uint_least53_t;
+#define INT_LEAST53_MIN (-1-9223372036854775807LL)
+#define INT_LEAST53_MAX 9223372036854775807LL
+#define UINT_LEAST53_MAX 18446744073709551615ULL
+#define INT_FAST53_MIN (-1-9223372036854775807LL)
+#define INT_FAST53_MAX 9223372036854775807LL
+#define UINT_FAST53_MAX 18446744073709551615ULL
+#define INT53_C(A) A##LL
+#define UINT53_C(A) A##ULL
+typedef long long int_fast54_t;
+typedef unsigned long long uint_fast54_t;
+typedef long long int_least54_t;
+typedef unsigned long long uint_least54_t;
+#define INT_LEAST54_MIN (-1-9223372036854775807LL)
+#define INT_LEAST54_MAX 9223372036854775807LL
+#define UINT_LEAST54_MAX 18446744073709551615ULL
+#define INT_FAST54_MIN (-1-9223372036854775807LL)
+#define INT_FAST54_MAX 9223372036854775807LL
+#define UINT_FAST54_MAX 18446744073709551615ULL
+#define INT54_C(A) A##LL
+#define UINT54_C(A) A##ULL
+typedef long long int_fast55_t;
+typedef unsigned long long uint_fast55_t;
+typedef long long int_least55_t;
+typedef unsigned long long uint_least55_t;
+#define INT_LEAST55_MIN (-1-9223372036854775807LL)
+#define INT_LEAST55_MAX 9223372036854775807LL
+#define UINT_LEAST55_MAX 18446744073709551615ULL
+#define INT_FAST55_MIN (-1-9223372036854775807LL)
+#define INT_FAST55_MAX 9223372036854775807LL
+#define UINT_FAST55_MAX 18446744073709551615ULL
+#define INT55_C(A) A##LL
+#define UINT55_C(A) A##ULL
+typedef long long int_fast56_t;
+typedef unsigned long long uint_fast56_t;
+typedef long long int_least56_t;
+typedef unsigned long long uint_least56_t;
+#define INT_LEAST56_MIN (-1-9223372036854775807LL)
+#define INT_LEAST56_MAX 9223372036854775807LL
+#define UINT_LEAST56_MAX 18446744073709551615ULL
+#define INT_FAST56_MIN (-1-9223372036854775807LL)
+#define INT_FAST56_MAX 9223372036854775807LL
+#define UINT_FAST56_MAX 18446744073709551615ULL
+#define INT56_C(A) A##LL
+#define UINT56_C(A) A##ULL
+typedef long long int_fast57_t;
+typedef unsigned long long uint_fast57_t;
+typedef long long int_least57_t;
+typedef unsigned long long uint_least57_t;
+#define INT_LEAST57_MIN (-1-9223372036854775807LL)
+#define INT_LEAST57_MAX 9223372036854775807LL
+#define UINT_LEAST57_MAX 18446744073709551615ULL
+#define INT_FAST57_MIN (-1-9223372036854775807LL)
+#define INT_FAST57_MAX 9223372036854775807LL
+#define UINT_FAST57_MAX 18446744073709551615ULL
+#define INT57_C(A) A##LL
+#define UINT57_C(A) A##ULL
+typedef long long int_fast58_t;
+typedef unsigned long long uint_fast58_t;
+typedef long long int_least58_t;
+typedef unsigned long long uint_least58_t;
+#define INT_LEAST58_MIN (-1-9223372036854775807LL)
+#define INT_LEAST58_MAX 9223372036854775807LL
+#define UINT_LEAST58_MAX 18446744073709551615ULL
+#define INT_FAST58_MIN (-1-9223372036854775807LL)
+#define INT_FAST58_MAX 9223372036854775807LL
+#define UINT_FAST58_MAX 18446744073709551615ULL
+#define INT58_C(A) A##LL
+#define UINT58_C(A) A##ULL
+typedef long long int_fast59_t;
+typedef unsigned long long uint_fast59_t;
+typedef long long int_least59_t;
+typedef unsigned long long uint_least59_t;
+#define INT_LEAST59_MIN (-1-9223372036854775807LL)
+#define INT_LEAST59_MAX 9223372036854775807LL
+#define UINT_LEAST59_MAX 18446744073709551615ULL
+#define INT_FAST59_MIN (-1-9223372036854775807LL)
+#define INT_FAST59_MAX 9223372036854775807LL
+#define UINT_FAST59_MAX 18446744073709551615ULL
+#define INT59_C(A) A##LL
+#define UINT59_C(A) A##ULL
+typedef long long int_fast60_t;
+typedef unsigned long long uint_fast60_t;
+typedef long long int_least60_t;
+typedef unsigned long long uint_least60_t;
+#define INT_LEAST60_MIN (-1-9223372036854775807LL)
+#define INT_LEAST60_MAX 9223372036854775807LL
+#define UINT_LEAST60_MAX 18446744073709551615ULL
+#define INT_FAST60_MIN (-1-9223372036854775807LL)
+#define INT_FAST60_MAX 9223372036854775807LL
+#define UINT_FAST60_MAX 18446744073709551615ULL
+#define INT60_C(A) A##LL
+#define UINT60_C(A) A##ULL
+typedef long long int_fast61_t;
+typedef unsigned long long uint_fast61_t;
+typedef long long int_least61_t;
+typedef unsigned long long uint_least61_t;
+#define INT_LEAST61_MIN (-1-9223372036854775807LL)
+#define INT_LEAST61_MAX 9223372036854775807LL
+#define UINT_LEAST61_MAX 18446744073709551615ULL
+#define INT_FAST61_MIN (-1-9223372036854775807LL)
+#define INT_FAST61_MAX 9223372036854775807LL
+#define UINT_FAST61_MAX 18446744073709551615ULL
+#define INT61_C(A) A##LL
+#define UINT61_C(A) A##ULL
+typedef long long int_fast62_t;
+typedef unsigned long long uint_fast62_t;
+typedef long long int_least62_t;
+typedef unsigned long long uint_least62_t;
+#define INT_LEAST62_MIN (-1-9223372036854775807LL)
+#define INT_LEAST62_MAX 9223372036854775807LL
+#define UINT_LEAST62_MAX 18446744073709551615ULL
+#define INT_FAST62_MIN (-1-9223372036854775807LL)
+#define INT_FAST62_MAX 9223372036854775807LL
+#define UINT_FAST62_MAX 18446744073709551615ULL
+#define INT62_C(A) A##LL
+#define UINT62_C(A) A##ULL
+typedef long long int_fast63_t;
+typedef unsigned long long uint_fast63_t;
+typedef long long int_least63_t;
+typedef unsigned long long uint_least63_t;
+#define INT_LEAST63_MIN (-1-9223372036854775807LL)
+#define INT_LEAST63_MAX 9223372036854775807LL
+#define UINT_LEAST63_MAX 18446744073709551615ULL
+#define INT_FAST63_MIN (-1-9223372036854775807LL)
+#define INT_FAST63_MAX 9223372036854775807LL
+#define UINT_FAST63_MAX 18446744073709551615ULL
+#define INT63_C(A) A##LL
+#define UINT63_C(A) A##ULL
+typedef long long int_fast64_t;
+typedef unsigned long long uint_fast64_t;
+typedef long long int_least64_t;
+typedef unsigned long long uint_least64_t;
+#define INT_LEAST64_MIN (-1-9223372036854775807LL)
+#define INT_LEAST64_MAX 9223372036854775807LL
+#define UINT_LEAST64_MAX 18446744073709551615ULL
+#define INT_FAST64_MIN (-1-9223372036854775807LL)
+#define INT_FAST64_MAX 9223372036854775807LL
+#define UINT_FAST64_MAX 18446744073709551615ULL
+#define INT64_C(A) A##LL
+#define UINT64_C(A) A##ULL
+#ifdef __cplusplus
+namespace std {
+typedef unsigned char uint8_t;
+typedef unsigned short uint16_t;
+typedef unsigned int uint32_t;
+typedef unsigned long long uint64_t;
+typedef signed char int8_t;
+typedef short int16_t;
+typedef int int32_t;
+typedef long long int64_t;
+typedef int intptr_t;
+typedef unsigned int uintptr_t;
+typedef int int_fast8_t;
+typedef unsigned int uint_fast8_t;
+typedef signed char int_least8_t;
+typedef unsigned char uint_least8_t;
+typedef int int_fast9_t;
+typedef unsigned int uint_fast9_t;
+typedef short int_least9_t;
+typedef unsigned short uint_least9_t;
+typedef int int_fast10_t;
+typedef unsigned int uint_fast10_t;
+typedef short int_least10_t;
+typedef unsigned short uint_least10_t;
+typedef int int_fast11_t;
+typedef unsigned int uint_fast11_t;
+typedef short int_least11_t;
+typedef unsigned short uint_least11_t;
+typedef int int_fast12_t;
+typedef unsigned int uint_fast12_t;
+typedef short int_least12_t;
+typedef unsigned short uint_least12_t;
+typedef int int_fast13_t;
+typedef unsigned int uint_fast13_t;
+typedef short int_least13_t;
+typedef unsigned short uint_least13_t;
+typedef int int_fast14_t;
+typedef unsigned int uint_fast14_t;
+typedef short int_least14_t;
+typedef unsigned short uint_least14_t;
+typedef int int_fast15_t;
+typedef unsigned int uint_fast15_t;
+typedef short int_least15_t;
+typedef unsigned short uint_least15_t;
+typedef int int_fast16_t;
+typedef unsigned int uint_fast16_t;
+typedef short int_least16_t;
+typedef unsigned short uint_least16_t;
+typedef int int_fast17_t;
+typedef unsigned int uint_fast17_t;
+typedef int int_least17_t;
+typedef unsigned int uint_least17_t;
+typedef int int_fast18_t;
+typedef unsigned int uint_fast18_t;
+typedef int int_least18_t;
+typedef unsigned int uint_least18_t;
+typedef int int_fast19_t;
+typedef unsigned int uint_fast19_t;
+typedef int int_least19_t;
+typedef unsigned int uint_least19_t;
+typedef int int_fast20_t;
+typedef unsigned int uint_fast20_t;
+typedef int int_least20_t;
+typedef unsigned int uint_least20_t;
+typedef int int_fast21_t;
+typedef unsigned int uint_fast21_t;
+typedef int int_least21_t;
+typedef unsigned int uint_least21_t;
+typedef int int_fast22_t;
+typedef unsigned int uint_fast22_t;
+typedef int int_least22_t;
+typedef unsigned int uint_least22_t;
+typedef int int_fast23_t;
+typedef unsigned int uint_fast23_t;
+typedef int int_least23_t;
+typedef unsigned int uint_least23_t;
+typedef int int_fast24_t;
+typedef unsigned int uint_fast24_t;
+typedef int int_least24_t;
+typedef unsigned int uint_least24_t;
+typedef int int_fast25_t;
+typedef unsigned int uint_fast25_t;
+typedef int int_least25_t;
+typedef unsigned int uint_least25_t;
+typedef int int_fast26_t;
+typedef unsigned int uint_fast26_t;
+typedef int int_least26_t;
+typedef unsigned int uint_least26_t;
+typedef int int_fast27_t;
+typedef unsigned int uint_fast27_t;
+typedef int int_least27_t;
+typedef unsigned int uint_least27_t;
+typedef int int_fast28_t;
+typedef unsigned int uint_fast28_t;
+typedef int int_least28_t;
+typedef unsigned int uint_least28_t;
+typedef int int_fast29_t;
+typedef unsigned int uint_fast29_t;
+typedef int int_least29_t;
+typedef unsigned int uint_least29_t;
+typedef int int_fast30_t;
+typedef unsigned int uint_fast30_t;
+typedef int int_least30_t;
+typedef unsigned int uint_least30_t;
+typedef int int_fast31_t;
+typedef unsigned int uint_fast31_t;
+typedef int int_least31_t;
+typedef unsigned int uint_least31_t;
+typedef int int_fast32_t;
+typedef unsigned int uint_fast32_t;
+typedef int int_least32_t;
+typedef unsigned int uint_least32_t;
+typedef long long int_fast33_t;
+typedef unsigned long long uint_fast33_t;
+typedef long long int_least33_t;
+typedef unsigned long long uint_least33_t;
+typedef long long int_fast34_t;
+typedef unsigned long long uint_fast34_t;
+typedef long long int_least34_t;
+typedef unsigned long long uint_least34_t;
+typedef long long int_fast35_t;
+typedef unsigned long long uint_fast35_t;
+typedef long long int_least35_t;
+typedef unsigned long long uint_least35_t;
+typedef long long int_fast36_t;
+typedef unsigned long long uint_fast36_t;
+typedef long long int_least36_t;
+typedef unsigned long long uint_least36_t;
+typedef long long int_fast37_t;
+typedef unsigned long long uint_fast37_t;
+typedef long long int_least37_t;
+typedef unsigned long long uint_least37_t;
+typedef long long int_fast38_t;
+typedef unsigned long long uint_fast38_t;
+typedef long long int_least38_t;
+typedef unsigned long long uint_least38_t;
+typedef long long int_fast39_t;
+typedef unsigned long long uint_fast39_t;
+typedef long long int_least39_t;
+typedef unsigned long long uint_least39_t;
+typedef long long int_fast40_t;
+typedef unsigned long long uint_fast40_t;
+typedef long long int_least40_t;
+typedef unsigned long long uint_least40_t;
+typedef long long int_fast41_t;
+typedef unsigned long long uint_fast41_t;
+typedef long long int_least41_t;
+typedef unsigned long long uint_least41_t;
+typedef long long int_fast42_t;
+typedef unsigned long long uint_fast42_t;
+typedef long long int_least42_t;
+typedef unsigned long long uint_least42_t;
+typedef long long int_fast43_t;
+typedef unsigned long long uint_fast43_t;
+typedef long long int_least43_t;
+typedef unsigned long long uint_least43_t;
+typedef long long int_fast44_t;
+typedef unsigned long long uint_fast44_t;
+typedef long long int_least44_t;
+typedef unsigned long long uint_least44_t;
+typedef long long int_fast45_t;
+typedef unsigned long long uint_fast45_t;
+typedef long long int_least45_t;
+typedef unsigned long long uint_least45_t;
+typedef long long int_fast46_t;
+typedef unsigned long long uint_fast46_t;
+typedef long long int_least46_t;
+typedef unsigned long long uint_least46_t;
+typedef long long int_fast47_t;
+typedef unsigned long long uint_fast47_t;
+typedef long long int_least47_t;
+typedef unsigned long long uint_least47_t;
+typedef long long int_fast48_t;
+typedef unsigned long long uint_fast48_t;
+typedef long long int_least48_t;
+typedef unsigned long long uint_least48_t;
+typedef long long int_fast49_t;
+typedef unsigned long long uint_fast49_t;
+typedef long long int_least49_t;
+typedef unsigned long long uint_least49_t;
+typedef long long int_fast50_t;
+typedef unsigned long long uint_fast50_t;
+typedef long long int_least50_t;
+typedef unsigned long long uint_least50_t;
+typedef long long int_fast51_t;
+typedef unsigned long long uint_fast51_t;
+typedef long long int_least51_t;
+typedef unsigned long long uint_least51_t;
+typedef long long int_fast52_t;
+typedef unsigned long long uint_fast52_t;
+typedef long long int_least52_t;
+typedef unsigned long long uint_least52_t;
+typedef long long int_fast53_t;
+typedef unsigned long long uint_fast53_t;
+typedef long long int_least53_t;
+typedef unsigned long long uint_least53_t;
+typedef long long int_fast54_t;
+typedef unsigned long long uint_fast54_t;
+typedef long long int_least54_t;
+typedef unsigned long long uint_least54_t;
+typedef long long int_fast55_t;
+typedef unsigned long long uint_fast55_t;
+typedef long long int_least55_t;
+typedef unsigned long long uint_least55_t;
+typedef long long int_fast56_t;
+typedef unsigned long long uint_fast56_t;
+typedef long long int_least56_t;
+typedef unsigned long long uint_least56_t;
+typedef long long int_fast57_t;
+typedef unsigned long long uint_fast57_t;
+typedef long long int_least57_t;
+typedef unsigned long long uint_least57_t;
+typedef long long int_fast58_t;
+typedef unsigned long long uint_fast58_t;
+typedef long long int_least58_t;
+typedef unsigned long long uint_least58_t;
+typedef long long int_fast59_t;
+typedef unsigned long long uint_fast59_t;
+typedef long long int_least59_t;
+typedef unsigned long long uint_least59_t;
+typedef long long int_fast60_t;
+typedef unsigned long long uint_fast60_t;
+typedef long long int_least60_t;
+typedef unsigned long long uint_least60_t;
+typedef long long int_fast61_t;
+typedef unsigned long long uint_fast61_t;
+typedef long long int_least61_t;
+typedef unsigned long long uint_least61_t;
+typedef long long int_fast62_t;
+typedef unsigned long long uint_fast62_t;
+typedef long long int_least62_t;
+typedef unsigned long long uint_least62_t;
+typedef long long int_fast63_t;
+typedef unsigned long long uint_fast63_t;
+typedef long long int_least63_t;
+typedef unsigned long long uint_least63_t;
+typedef long long int_fast64_t;
+typedef unsigned long long uint_fast64_t;
+typedef long long int_least64_t;
+typedef unsigned long long uint_least64_t;
+typedef long long intmax_t;
+typedef unsigned long long uintmax_t;
+}
+#endif
+#endif



From zaimoni at mail.berlios.de  Sat Sep  5 01:11:00 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 5 Sep 2009 01:11:00 +0200
Subject: [Zcplusplus-commits] r243 - in trunk: . POSIX POSIX/cmp
	Zaimoni.STL/Pure.C
Message-ID: <200909042311.n84NB028026860@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-05 01:10:53 +0200 (Sat, 05 Sep 2009)
New Revision: 243

Added:
   trunk/NMake.inc
   trunk/POSIX/
   trunk/POSIX/cmp/
   trunk/POSIX/cmp/MakeMake.cfg
   trunk/POSIX/cmp/Makefile
   trunk/POSIX/cmp/NMake.dep
   trunk/POSIX/cmp/NMakefile
   trunk/POSIX/cmp/POSIX.dep
   trunk/POSIX/cmp/cmp.c
Modified:
   trunk/Zaimoni.STL/Pure.C/NMakefile
Log:
partial cmp reimplementation (enough to run test drivers)

Added: trunk/NMake.inc
===================================================================
--- trunk/NMake.inc	2009-09-04 22:05:15 UTC (rev 242)
+++ trunk/NMake.inc	2009-09-04 23:10:53 UTC (rev 243)
@@ -0,0 +1,20 @@
+# GNU compatibility core
+srcdir = \CPP_App\Z.C++
+prefix = \CPP_App\Z.C++
+exec_prefix = $(prefix)
+bindir = $(exec_prefix)\bin
+includedir = $(exec_prefix)\include
+libdir = $(exec_prefix)\lib
+
+AR = lib
+
+EXEEXT = exe
+OBJEXT = obj
+
+# /Wall warns on system headers in VC 2008, not good
+CFLAGS = /O1 /EHsc /MD /W3
+CXXFLAGS =
+
+OTHER_INCLUDEDIR = -I \MingWin.aux\Headers.lib
+C_MACROS = 
+CXX_MACROS = 

Added: trunk/POSIX/cmp/MakeMake.cfg
===================================================================
--- trunk/POSIX/cmp/MakeMake.cfg	2009-09-04 22:05:15 UTC (rev 242)
+++ trunk/POSIX/cmp/MakeMake.cfg	2009-09-04 23:10:53 UTC (rev 243)
@@ -0,0 +1,24 @@
+########
+ProgObjects = {	'cmp':['cmp'] }
+MainPrograms = ['cmp']
+
+# process control
+C_assembly_preprocessing = ''
+object_strip = ''
+#object_strip = 'strip --preserve-dates --strip-unneeded $*.o'
+
+# defines catalog
+# NDEBUG: release mode
+# ZAIMONI_FORCE_ISO: try to build as ISO C++ rather than with custom memory manager (pre-alpha)
+C_defines = []
+
+# language
+CPP_suffix = ''
+CPP_libraries = ' -lz_stdio_log' # -mwindows -mno-cygwin
+CPP_override_libraries = {}
+
+C_enabled = '.c'
+C_hard_nonsystem_includedirs = []
+C_soft_nonsystem_includedirs = ['c:/MingWin.aux/Headers.lib']
+C_backtrack_dirs = []
+

Added: trunk/POSIX/cmp/Makefile
===================================================================
--- trunk/POSIX/cmp/Makefile	2009-09-04 22:05:15 UTC (rev 242)
+++ trunk/POSIX/cmp/Makefile	2009-09-04 23:10:53 UTC (rev 243)
@@ -0,0 +1,27 @@
+# POSIX makefile
+
+.SUFFIXES:
+.SUFFIXES:  .c .o .exe
+
+include ../../POSIX.inc
+
+# GNU targets we know about
+all: cmp.exe
+
+clean:
+	rm -f *.o *.exe
+
+# dependencies
+include POSIX.dep
+
+cmp.exe : $(OBJECTS_CMP_LINK_PRIORITY)
+	$(CC) $(LINK_FLAGS) -ocmp.exe $(OBJECTS_CMP)  -lz_stdio_log
+	strip --preserve-dates --strip-unneeded cmp.exe
+
+# inference rules
+# global project search paths for headers
+# processing details
+
+.c.o:
+	$(CC) $(CFLAGS) $(ARCH_FLAGS) $(OTHER_INCLUDEDIR) $(C_MACROS) \
+	 -o $*.o -c -xc -pipe $<

Added: trunk/POSIX/cmp/NMake.dep
===================================================================
--- trunk/POSIX/cmp/NMake.dep	2009-09-04 22:05:15 UTC (rev 242)
+++ trunk/POSIX/cmp/NMake.dep	2009-09-04 23:10:53 UTC (rev 243)
@@ -0,0 +1,5 @@
+OBJECTS_CMP = cmp.obj
+OBJECTS_CMP_LINK_PRIORITY = cmp.obj
+
+# dependencies
+cmp.obj: c:\MingWin.aux\Headers.lib\Zaimoni.STL\Logging.h c:\MingWin.aux\Headers.lib\Zaimoni.STL\Compiler.h c:\MingWin.aux\Headers.lib\Zaimoni.STL\flat_alg.h

Added: trunk/POSIX/cmp/NMakefile
===================================================================
--- trunk/POSIX/cmp/NMakefile	2009-09-04 22:05:15 UTC (rev 242)
+++ trunk/POSIX/cmp/NMakefile	2009-09-04 23:10:53 UTC (rev 243)
@@ -0,0 +1,25 @@
+# NMake makefile
+
+.SUFFIXES:
+.SUFFIXES:  .c .obj .exe
+
+!INCLUDE ..\..\NMake.inc
+
+# GNU targets we know about
+all: cmp.exe
+
+clean:
+	del *.obj *.exe *.manifest
+
+# dependencies
+!INCLUDE NMake.dep
+
+cmp.exe : $(OBJECTS_CMP_LINK_PRIORITY)
+	$(CC) $(LINK_FLAGS) /OUT:cmp.exe $(OBJECTS_CMP) $(host_libdir)\z_stdio_log.lib
+
+# inference rules
+# global project search paths for headers
+# processing details
+
+# default .c.obj
+

Added: trunk/POSIX/cmp/POSIX.dep
===================================================================
--- trunk/POSIX/cmp/POSIX.dep	2009-09-04 22:05:15 UTC (rev 242)
+++ trunk/POSIX/cmp/POSIX.dep	2009-09-04 23:10:53 UTC (rev 243)
@@ -0,0 +1,5 @@
+OBJECTS_CMP = cmp.o
+OBJECTS_CMP_LINK_PRIORITY = cmp.o
+
+# dependencies
+cmp.o: c:/MingWin.aux/Headers.lib/Zaimoni.STL/Logging.h c:/MingWin.aux/Headers.lib/Zaimoni.STL/Compiler.h c:/MingWin.aux/Headers.lib/Zaimoni.STL/flat_alg.h

Added: trunk/POSIX/cmp/cmp.c
===================================================================
--- trunk/POSIX/cmp/cmp.c	2009-09-04 22:05:15 UTC (rev 242)
+++ trunk/POSIX/cmp/cmp.c	2009-09-04 23:10:53 UTC (rev 243)
@@ -0,0 +1,175 @@
+/*
+ * cmp.c
+ * this partially implements the POSIX cmp utility
+ * (C)2009 Kenneth Boyd, license: MIT.txt
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <limits.h>
+#include <fcntl.h>
+#include "Zaimoni.STL/Logging.h"
+
+#define OUTPUT_DEFAULT 0
+#define OUTPUT_VERBOSE 1
+#define OUTPUT_SILENT 2
+
+/*! \bug Once And Only Once violation (cf. cpp_util.h) */
+#define STRING_LITERAL_TO_STDOUT(A) fwrite(A,sizeof(A)-1,1,stdout)
+#define C_STRING_TO_STDOUT(A) fwrite(A,strlen(A),1,stdout)
+
+static int output_mode = OUTPUT_DEFAULT;
+static FILE* files[2] = { NULL, NULL };
+static const char* filenames[2] = { NULL, NULL };
+
+typedef struct {
+	const char* option;
+	const char* desc;
+} optdesc;
+
+static const optdesc option_map_bool[]
+=	{	{ "-",	"use this by itself for STDIN on either file1 or file2\n"},
+		{ "-l",	"POSIX 2/3 verbose listing on stdout\n"},
+		{ "-s",	"print nothing to stdout\n"} };
+
+static int recognize_bool_opt(const char* const x)
+{
+	if (NULL==x || !*x) return -1;
+	{
+	size_t j = STATIC_SIZE(option_map_bool);
+	do if (!strcmp(option_map_bool[--j].option,x)) return j;
+	while(0<j);
+	}
+	return -1;
+}
+
+/*! 
+ * processes command-line options.
+ * 
+ * \param argc main's argc
+ * \param argv main's argv
+ * 
+ * \return true if and only if a tty device is clearly involved (usually stdin)
+ */
+static unsigned int process_options(const size_t argc, char* argv[])
+{
+	unsigned int invoke_undefined_behavior = 0;
+	size_t i = 0;
+	size_t file_count = 0;
+	assert(3<=argc && NULL!=argv);
+	while(argc > ++i)
+		{
+		int index = recognize_bool_opt((assert(NULL!=argv[i]),argv[i]));
+		if (0<=index)
+			{	/* handle directly */
+			assert(STATIC_SIZE(option_map_bool)>(size_t)index);
+			switch(index)
+			{
+			default: _fatal_code("bug caused out-of-bounds index\n",3);
+			case 0:	/* - */
+				{
+				if (2==file_count) _fatal_code("POSIX 2/3 requires exactly two files\n",2);
+				if (1 & invoke_undefined_behavior) _fatal_code("cmp - - invokes undefined behavior",2);
+#ifdef ZAIMONI_HAVE_MICROSOFT_IO_H
+				/* _setmode uses invalid_parameter handlers in recent versions */
+				if (-1==_setmode(_fileno( stdin ),_O_BINARY )) _fatal_code("couldn't force binary stdin",2);
+#endif
+				filenames[file_count] = argv[i];
+				files[file_count++] = stdin;
+				invoke_undefined_behavior = 1;
+				break;
+				}
+			case 1:	/* -l */
+			case 2:	/* -s */
+				{
+				if (output_mode) _fatal_code("POSIX 2/3 only allows changing output mode once\n",2);
+				if (NULL!=files[0]) _fatal_code("POSIX 2/3 disallows changing output mode after starting to specify files\n",2);
+				output_mode = index;
+				break;
+				}
+			};
+			continue;
+			};
+		if (2==file_count) _fatal_code("POSIX 2/3 requires exactly two files\n",2);
+		filenames[file_count] = argv[i];
+		if (NULL==(files[file_count++] = fopen(argv[i],"rb")))
+			_fatal_code("target file not opened\n",2);
+		}
+	if (2!=file_count) _fatal_code("POSIX 2/3 requires exactly two files\n",2);
+	assert(OUTPUT_DEFAULT<=output_mode && output_mode<=OUTPUT_SILENT);
+/*#ifdef ZAIMONI_HAVE_MICROSOFT_IO_H*/
+#if 0
+	/* _isatty uses invalid_parameter handlers in recent versions */ 
+	return (_isatty(_fileno(files[0])) ? 1 : 0) | (_isatty(_fileno(files[1])) ? 2 : 0);
+#else
+	return 1 & invoke_undefined_behavior;
+#endif
+}
+
+static void help(void)
+{
+	size_t i = 0;
+	STRING_LITERAL_TO_STDOUT("Z.C++ cmp 0.1\n");
+	STRING_LITERAL_TO_STDOUT("usage: cmp [options] file1 file2\n");
+	STRING_LITERAL_TO_STDOUT("options\n");
+	do	{
+		STRING_LITERAL_TO_STDOUT(" ");
+		C_STRING_TO_STDOUT(option_map_bool[i].option);
+		STRING_LITERAL_TO_STDOUT(": ");
+		C_STRING_TO_STDOUT(option_map_bool[i].desc);
+		}
+	while(STATIC_SIZE(option_map_bool) > ++i);
+	STRING_LITERAL_TO_STDOUT("\nThis cmp doesn't respond to the following environment variables:\n");
+	STRING_LITERAL_TO_STDOUT("\tLANG LC_ALL LC_TYPE LC_MESSAGES NLSPATH\n");
+	exit(2);	/* invoking help is an error, technically */
+}
+
+int main(int argc, char* argv[])
+{
+	if (3>argc) help();
+	process_options(argc,argv);
+
+	{
+/*	const unsigned int using_stdin = process_options(argc,argv); */
+	/* slow path suitable for tty-type psuedofiles */
+	/*! \todo fast path for true files */
+	int linenum = 1;
+	int file0_char = fgetc(files[0]);
+	int file1_char = fgetc(files[1]);
+	int already_errored = 0;
+	int bytenum = 1;
+	while(EOF!=file0_char && EOF!=file1_char)
+		{
+		if (file0_char!=file1_char)
+			switch(output_mode)
+			{
+			default: _fatal_code("bug caused invalid output mode\n",3);
+			case OUTPUT_VERBOSE:
+				{
+				printf("%d %o %o\n", bytenum, file0_char, file1_char);
+				already_errored = 1;
+				break;
+				}
+			case OUTPUT_DEFAULT:
+				{
+				printf("%s %s differ: char %d, line %d\n", filenames[0], filenames[1], bytenum, linenum);
+				}
+			case OUTPUT_SILENT: exit(EXIT_FAILURE);
+			};
+		/* clamp byte number and line number at INT_MAX, to avoid undefined behavior */
+		if (INT_MAX>bytenum) ++bytenum;
+		if ('\n'==file0_char && INT_MAX>linenum) ++linenum;
+		};
+	if (already_errored) exit(EXIT_FAILURE);
+	{
+	const int truncated = (EOF==file0_char)-(EOF==file1_char);
+	if (truncated)
+		{
+		if (OUTPUT_SILENT!=output_mode)
+			fprintf(stderr,"cmp: EOF on %s\n",filenames[(0>truncated)]);
+		exit(EXIT_FAILURE);
+		};
+	}
+	}
+	exit(EXIT_SUCCESS);
+}

Modified: trunk/Zaimoni.STL/Pure.C/NMakefile
===================================================================
--- trunk/Zaimoni.STL/Pure.C/NMakefile	2009-09-04 22:05:15 UTC (rev 242)
+++ trunk/Zaimoni.STL/Pure.C/NMakefile	2009-09-04 23:10:53 UTC (rev 243)
@@ -26,7 +26,7 @@
 format_util.obj: format_util.c format_util.h
 
 auto_int.h : int_probe.c
-	$(CC) -oint_probe.exe $(CFLAGS) int_probe.c
+	$(CC) /OUT:int_probe.exe $(CFLAGS) int_probe.c
 	.\int_probe.exe > auto_int.h
 	del int_probe.exe.manifest
 	del int_probe.exe



From zaimoni at mail.berlios.de  Sat Sep  5 18:37:24 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 5 Sep 2009 18:37:24 +0200
Subject: [Zcplusplus-commits] r244 - in trunk: . POSIX/cmp Zaimoni.STL
	Zaimoni.STL/core.RAM
Message-ID: <200909051637.n85GbOqd026960@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-05 18:37:15 +0200 (Sat, 05 Sep 2009)
New Revision: 244

Removed:
   trunk/cpp_util.h
Modified:
   trunk/AtomicString.cpp
   trunk/POSIX/cmp/cmp.c
   trunk/Zaimoni.STL/Compiler.h
   trunk/Zaimoni.STL/core.RAM/memory.cpp
   trunk/type_spec.cpp
   trunk/z_cpp.cpp
   trunk/zcc.cpp
Log:
Object size tuning; handle a Once And Only Once violation between Z.C++ cmp and zcc/z_cpp

Modified: trunk/AtomicString.cpp
===================================================================
--- trunk/AtomicString.cpp	2009-09-04 23:10:53 UTC (rev 243)
+++ trunk/AtomicString.cpp	2009-09-05 16:37:15 UTC (rev 244)
@@ -41,8 +41,7 @@
 
 EXTERN_C const char* register_substring(const char* const x,const unsigned long x_len)
 {
-	if (NULL==x) return NULL;
-	if (0==x_len) return NULL;
+	if (NULL==x || 0==x_len) return NULL;
 	size_t LB = 0;
 	size_t StrictUB = string_cache_size;
 	while(LB<StrictUB)
@@ -80,8 +79,7 @@
 
 EXTERN_C const char* is_substring_registered(const char* const x,const unsigned long x_len)
 {
-	if (NULL==x) return NULL;
-	if (0==x_len) return NULL;
+	if (NULL==x || 0==x_len) return NULL;
 	size_t LB = 0;
 	size_t StrictUB = string_cache_size;
 	while(LB<StrictUB)

Modified: trunk/POSIX/cmp/cmp.c
===================================================================
--- trunk/POSIX/cmp/cmp.c	2009-09-04 23:10:53 UTC (rev 243)
+++ trunk/POSIX/cmp/cmp.c	2009-09-05 16:37:15 UTC (rev 244)
@@ -14,10 +14,6 @@
 #define OUTPUT_VERBOSE 1
 #define OUTPUT_SILENT 2
 
-/*! \bug Once And Only Once violation (cf. cpp_util.h) */
-#define STRING_LITERAL_TO_STDOUT(A) fwrite(A,sizeof(A)-1,1,stdout)
-#define C_STRING_TO_STDOUT(A) fwrite(A,strlen(A),1,stdout)
-
 static int output_mode = OUTPUT_DEFAULT;
 static FILE* files[2] = { NULL, NULL };
 static const char* filenames[2] = { NULL, NULL };

Modified: trunk/Zaimoni.STL/Compiler.h
===================================================================
--- trunk/Zaimoni.STL/Compiler.h	2009-09-04 23:10:53 UTC (rev 243)
+++ trunk/Zaimoni.STL/Compiler.h	2009-09-05 16:37:15 UTC (rev 244)
@@ -29,6 +29,14 @@
 
 #define STATIC_SIZE(A) (sizeof(A)/sizeof(*A))
 
+/* C strings to stdout; include stdio.h before using these */
+/* including cstdio ok if not on a deathstation */
+#define STRING_LITERAL_TO_STDOUT(A) fwrite(A,sizeof(A)-1,1,stdout)
+#define C_STRING_TO_STDOUT(A) fwrite(A,strlen(A),1,stdout)
+#ifdef __cplusplus
+#define STL_PTR_STRING_TO_STDOUT(A) fwrite((A)->data(),(A)->size(),1,stdout)
+#endif
+
 /* platform config copied from Boost */
 /* would prefer to use BOOST_PLATFORM, but strings aren't allowed in preprocessor tests */
 /* for now, detect Mac OS X by MACOSX pendng proper documentation */

Modified: trunk/Zaimoni.STL/core.RAM/memory.cpp
===================================================================
--- trunk/Zaimoni.STL/core.RAM/memory.cpp	2009-09-04 23:10:53 UTC (rev 243)
+++ trunk/Zaimoni.STL/core.RAM/memory.cpp	2009-09-05 16:37:15 UTC (rev 244)
@@ -899,7 +899,7 @@
 	return Tmp;
 }
 
-void* operator new(size_t NewSize, const std::nothrow_t& tracer) throw ()
+void* operator new[](std::size_t NewSize) throw (std::bad_alloc)
 {
 	void* Tmp = calloc(1,NewSize);
 	while(NULL==Tmp && NULL!=ZaimoniNewHandler)
@@ -911,7 +911,7 @@
 	return Tmp;
 }
 
-void* operator new[](std::size_t NewSize) throw (std::bad_alloc)
+void* operator new(size_t NewSize, const std::nothrow_t& tracer) throw ()
 {
 	void* Tmp = calloc(1,NewSize);
 	while(NULL==Tmp && NULL!=ZaimoniNewHandler)

Deleted: trunk/cpp_util.h
===================================================================
--- trunk/cpp_util.h	2009-09-04 23:10:53 UTC (rev 243)
+++ trunk/cpp_util.h	2009-09-05 16:37:15 UTC (rev 244)
@@ -1,12 +0,0 @@
-/* cpp_util.h */
-/* C preprocessor utilities */
-
-#ifndef CPP_UTIL_H
-#define CPP_UTIL_H 1
-
-/* C strings to stdout; include cstdio/stdio.h before using these */
-#define STRING_LITERAL_TO_STDOUT(A) fwrite(A,sizeof(A)-1,1,stdout)
-#define C_STRING_TO_STDOUT(A) fwrite(A,strlen(A),1,stdout)
-#define STL_PTR_STRING_TO_STDOUT(A) fwrite((A)->data(),(A)->size(),1,stdout)
-
-#endif

Modified: trunk/type_spec.cpp
===================================================================
--- trunk/type_spec.cpp	2009-09-04 23:10:53 UTC (rev 243)
+++ trunk/type_spec.cpp	2009-09-05 16:37:15 UTC (rev 244)
@@ -93,8 +93,7 @@
 		{
 		if (0== --pointer_power)
 			{
-			free(extent_vector);
-			extent_vector = NULL;
+			FREE_AND_NULL(extent_vector);
 			qualifier_vector.second[old_ptr_power] = '\0';
 			assert(lvalue & qualifier_vector.second[old_ptr_power-1]);	// result of dereference is a C/C++ lvalue; problem is elsewhere if this triggers
 			}
@@ -135,8 +134,7 @@
 {
 	if (0<base_type_index)
 		{
-		free(extent_vector);
-		extent_vector = NULL;
+		FREE_AND_NULL(extent_vector);
 		if (sizeof(unsigned char*)<=pointer_power_after_array_decay())
 			{
 			free(qualifier_vector.first);
@@ -154,8 +152,7 @@
 {
 	if (0<base_type_index)
 		{
-		free(extent_vector);
-		extent_vector = NULL;
+		FREE_AND_NULL(extent_vector);
 		if (sizeof(unsigned char*)<=pointer_power_after_array_decay())
 			{
 			free(qualifier_vector.first);

Modified: trunk/z_cpp.cpp
===================================================================
--- trunk/z_cpp.cpp	2009-09-04 23:10:53 UTC (rev 243)
+++ trunk/z_cpp.cpp	2009-09-05 16:37:15 UTC (rev 244)
@@ -8,7 +8,6 @@
 #include "CPreproc.hpp"
 #include "load_src.hpp"
 #include "AtomicString.h"
-#include "cpp_util.h"
 #include "filesystem.h"
 #include "langroute.hpp"
 #include "errors.hpp"

Modified: trunk/zcc.cpp
===================================================================
--- trunk/zcc.cpp	2009-09-04 23:10:53 UTC (rev 243)
+++ trunk/zcc.cpp	2009-09-05 16:37:15 UTC (rev 244)
@@ -8,7 +8,6 @@
 #include "CPreproc.hpp"
 #include "load_src.hpp"
 #include "AtomicString.h"
-#include "cpp_util.h"
 #include "filesystem.h"
 #include "errors.hpp"
 #include "langroute.hpp"



From zaimoni at mail.berlios.de  Sat Sep  5 19:09:38 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 5 Sep 2009 19:09:38 +0200
Subject: [Zcplusplus-commits] r245 - trunk
Message-ID: <200909051709.n85H9cMk020864@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-05 19:09:28 +0200 (Sat, 05 Sep 2009)
New Revision: 245

Modified:
   trunk/unsigned_aux.cpp
   trunk/unsigned_aux.hpp
Log:
mass renaming to reduce using reserved identifiers

Modified: trunk/unsigned_aux.cpp
===================================================================
--- trunk/unsigned_aux.cpp	2009-09-05 16:37:15 UTC (rev 244)
+++ trunk/unsigned_aux.cpp	2009-09-05 17:09:28 UTC (rev 245)
@@ -11,204 +11,205 @@
 #endif
 
 //! \todo rethink this for hosting machines where sizeof(char)==sizeof(uintmax_t)
-void _unsigned_copy(unsigned char* _x, uintmax_t src, unsigned int i)
+void _unsigned_copy(unsigned char* x, uintmax_t src, unsigned int i)
 {
 	do	{
 		--i;
-		_x[i] = ((src & ((uintmax_t)(UCHAR_MAX)<<(i*CHAR_BIT)))>>(i*CHAR_BIT));
+		x[i] = ((src & ((uintmax_t)(UCHAR_MAX)<<(i*CHAR_BIT)))>>(i*CHAR_BIT));
 		}
 	while(0<i);
 }
 
-void _mask_to(unsigned char* LHS, size_t LHS_len, size_t bitcount)
+void _mask_to(unsigned char* x, size_t x_len, size_t bitcount)
 {
 	const size_t target_bytes = bitcount/CHAR_BIT;
 	const size_t target_bits = bitcount%CHAR_BIT;
-	if (target_bytes>=LHS_len) return;
+	if (target_bytes>=x_len) return;
 	if (0==target_bits)
-		memset(LHS+target_bytes,0,LHS_len-target_bytes);
+		memset(x+target_bytes,0,x_len-target_bytes);
 	else{
-		if (target_bytes+1U<LHS_len) memset(LHS+target_bytes+1U,0,LHS_len-target_bytes-1U);
-		LHS[target_bytes] &= (UCHAR_MAX>>(CHAR_BIT-target_bits));
+		if (target_bytes+1U<x_len)
+			memset(x+target_bytes+1U,0,x_len-target_bytes-1U);
+		x[target_bytes] &= (UCHAR_MAX>>(CHAR_BIT-target_bits));
 		}
 }
 
-void _unsigned_sum(unsigned char* LHS, size_t LHS_len, const unsigned char* RHS)
+void _unsigned_sum(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs)
 {
 	size_t i = 0;
 #if FAST_ROUTE
 	unsigned int tmp = 0;
 	do	{
-		tmp += LHS[i];
-		tmp += RHS[i];
-		LHS[i] = (tmp & UCHAR_MAX);
+		tmp += lhs[i];
+		tmp += rhs[i];
+		lhs[i] = (tmp & UCHAR_MAX);
 		tmp >>= CHAR_BIT;
 		}
-	while(LHS_len > ++i);
+	while(lhs_len > ++i);
 #else
 	bool carry = false;
 	do	{
-		if (carry && UCHAR_MAX>LHS[i])
+		if (carry && UCHAR_MAX>lhs[i])
 			{
-			LHS[i] += 1;
+			lhs[i] += 1;
 			carry = false;
 			}
 
 		if (carry)
-			LHS[i] = RHS[i];
-		else if (UCHAR_MAX-LHS[i]>=RHS[i])
-			LHS[i] += RHS[i];
+			lhs[i] = rhs[i];
+		else if (UCHAR_MAX-lhs[i]>=rhs[i])
+			lhs[i] += rhs[i];
 		else{
-			LHS[i] = RHS[i]-(UCHAR_MAX-LHS[i])
-			LHS[i] -= 1;
+			lhs[i] = rhs[i]-(UCHAR_MAX-lhs[i])
+			lhs[i] -= 1;
 			carry = true;
 			}
 		}
-	while(LHS_len > ++i);
+	while(lhs_len > ++i);
 #endif
 }
 
-void _unsigned_sum(unsigned char* LHS, size_t LHS_len, uintmax_t RHS)
+void _unsigned_sum(unsigned char* lhs, size_t lhs_len, uintmax_t rhs)
 {
 	size_t i = 0;
 #if FAST_ROUTE
 	unsigned int tmp = 0;
 	do	{
-		tmp += LHS[i];
-		tmp += (RHS & UCHAR_MAX);
-		LHS[i] = (tmp & UCHAR_MAX);
+		tmp += lhs[i];
+		tmp += (rhs & UCHAR_MAX);
+		lhs[i] = (tmp & UCHAR_MAX);
 		tmp >>= CHAR_BIT;
-		RHS >>= CHAR_BIT;
+		rhs >>= CHAR_BIT;
 		}
-	while(LHS_len > ++i && (RHS || tmp));
+	while(lhs_len > ++i && (rhs || tmp));
 #else
 	bool carry = false;
 	do	{
-		if (carry && UCHAR_MAX>LHS[i])
+		if (carry && UCHAR_MAX>lhs[i])
 			{
-			LHS[i] += 1;
+			lhs[i] += 1;
 			carry = false;
 			}
 
-		const unsigned char RHS_image = (RHS & UCHAR_MAX);
-		RHS >>= CHAR_BIT;
+		const unsigned char rhs_image = (rhs & UCHAR_MAX);
+		rhs >>= CHAR_BIT;
 		if (carry)
-			LHS[i] = RHS_image;
-		else if (UCHAR_MAX-LHS[i]>=RHS_image)
-			LHS[i] += RHS_image;
+			lhs[i] = rhs_image;
+		else if (UCHAR_MAX-lhs[i]>=rhs_image)
+			lhs[i] += rhs_image;
 		else{
-			LHS[i] = RHS_image-(UCHAR_MAX-LHS[i])
-			LHS[i] -= 1;
+			lhs[i] = rhs_image-(UCHAR_MAX-lhs[i])
+			lhs[i] -= 1;
 			carry = true;
 			}
 		}
-	while(LHS_len > ++i && RHS);
+	while(lhs_len > ++i && rhs);
 #endif
 }
 
-void _unsigned_diff(unsigned char* LHS, size_t LHS_len, const unsigned char* RHS)
+void _unsigned_diff(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs)
 {
 	size_t i = 0;
 	bool carry = false;
 	do	{
 		if (carry)
 			{
-			LHS[i] -= 1;
-			carry = (UCHAR_MAX == LHS[i]);
+			lhs[i] -= 1;
+			carry = (UCHAR_MAX == lhs[i]);
 			};
 
-		carry = carry ||  LHS[i]<RHS[i];
-		LHS[i] -= RHS[i];
+		carry = carry ||  lhs[i]<rhs[i];
+		lhs[i] -= rhs[i];
 		}
-	while(LHS_len > ++i);
+	while(lhs_len > ++i);
 }
 
-void _unsigned_diff(unsigned char* LHS, size_t LHS_len, uintmax_t RHS)
+void _unsigned_diff(unsigned char* lhs, size_t lhs_len, uintmax_t rhs)
 {
 	size_t i = 0;
 	bool carry = false;
 	do	{
-		const unsigned char RHS_image = RHS;
-		RHS >>= CHAR_BIT;
+		const unsigned char rhs_image = rhs;
+		rhs >>= CHAR_BIT;
 		if (carry)
 			{
-			LHS[i] -= 1;
-			carry = (UCHAR_MAX == LHS[i]);
+			lhs[i] -= 1;
+			carry = (UCHAR_MAX == lhs[i]);
 			};
 
-		carry = carry || LHS[i]<RHS_image;
-		LHS[i] -= RHS_image;
+		carry = carry || lhs[i]<rhs_image;
+		lhs[i] -= rhs_image;
 		}
-	while(LHS_len > ++i && (RHS || carry));
+	while(lhs_len > ++i && (rhs || carry));
 }
 
-unsigned int _int_log2(unsigned char* buf, size_t buf_len)
+unsigned int _int_log2(unsigned char* x, size_t x_len)
 {
-	while(0<buf_len)
+	while(0<x_len)
 		{
 		size_t i = CHAR_BIT;
-		--buf_len;
-		do	if (buf[buf_len] & (1U<< --i)) return buf_len*CHAR_BIT+i;
+		--x_len;
+		do	if (x[x_len] & (1U<< --i)) return x_len*CHAR_BIT+i;
 		while(0<i);
 		};
 	return 0;
 }
 
-void _bitwise_compl(unsigned char* buf, size_t buf_len)
+void _bitwise_compl(unsigned char* x, size_t x_len)
 {
-	while(0<buf_len)
+	while(0<x_len)
 		{
-		--buf_len;
-		buf[buf_len] = ~buf[buf_len];
+		--x_len;
+		x[x_len] = ~x[x_len];
 		};
 }
 
-void _bitwise_and(unsigned char* LHS, size_t LHS_len, const unsigned char* RHS)
+void _bitwise_and(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs)
 {
-	while(0<LHS_len)
+	while(0<lhs_len)
 		{
-		--LHS_len;
-		LHS[LHS_len] &= RHS[LHS_len];
+		--lhs_len;
+		lhs[lhs_len] &= rhs[lhs_len];
 		};
 }
 
-void _bitwise_xor(unsigned char* LHS, size_t LHS_len, const unsigned char* RHS)
+void _bitwise_xor(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs)
 {
-	while(0<LHS_len)
+	while(0<lhs_len)
 		{
-		--LHS_len;
-		LHS[LHS_len] ^= RHS[LHS_len];
+		--lhs_len;
+		lhs[lhs_len] ^= rhs[lhs_len];
 		};
 }
 
-void _bitwise_or(unsigned char* LHS, size_t LHS_len, const unsigned char* RHS)
+void _bitwise_or(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs)
 {
-	while(0<LHS_len)
+	while(0<lhs_len)
 		{
-		--LHS_len;
-		LHS[LHS_len] |= RHS[LHS_len];
+		--lhs_len;
+		lhs[lhs_len] |= rhs[lhs_len];
 		};
 }
 
-void _unsigned_mult(unsigned char* buf, const size_t buf_len, const unsigned char* LHS, size_t LHS_len, const unsigned char* RHS, size_t RHS_len)
+void _unsigned_mult(unsigned char* buf, const size_t buf_len, const unsigned char* lhs, size_t lhs_len, const unsigned char* rhs, size_t rhs_len)
 {
 	memset(buf,0,buf_len);
 	// trim off leading zeros
-	while(2<=RHS_len && 0==RHS[RHS_len-1]) --RHS_len;
-	while(2<=LHS_len && 0==LHS[LHS_len-1]) --LHS_len;
-	if (1==LHS_len && 0==LHS[0]) return;	// multiply by 0 is 0
-	if (1==RHS_len && 0==RHS[0]) return;
+	while(2<=rhs_len && 0==rhs[rhs_len-1]) --rhs_len;
+	while(2<=lhs_len && 0==lhs[lhs_len-1]) --lhs_len;
+	if (1==lhs_len && 0==lhs[0]) return;	// multiply by 0 is 0
+	if (1==rhs_len && 0==rhs[0]) return;
 #if FAST_ROUTE
 	size_t k = 0;
 	unsigned int tmp = 0;
 	unsigned int tmp2 = 0;
 	do	{
-		if (LHS_len+RHS_len-2U>=k)
+		if (lhs_len+rhs_len-2U>=k)
 			{
 			size_t i = k+1;
 			do	{
-				if (LHS_len<= --i || RHS_len<=k-i) continue;
-				tmp += (unsigned int)(LHS[i])*(unsigned int)(RHS[k-i]);	// exploits: UCHAR_MAX*UCHAR_MAX-1 = (UCHAR_MAX+1)*(UCHAR_MAX-1)
+				if (lhs_len<= --i || rhs_len<=k-i) continue;
+				tmp += (unsigned int)(lhs[i])*(unsigned int)(rhs[k-i]);	// exploits: UCHAR_MAX*UCHAR_MAX-1 = (UCHAR_MAX+1)*(UCHAR_MAX-1)
 				tmp2 += (tmp >> CHAR_BIT);
 				tmp &= UCHAR_MAX;
 				}
@@ -221,27 +222,27 @@
 		}
 	while(buf_len> ++k);
 #else
-#error _unsigned_mult(unsigned char* buf, const size_t buf_len, const unsigned char* LHS, const size_t LHS_len, const unsigned char* RHS, const size_t RHS_len) not implemented
+#error _unsigned_mult(unsigned char* buf, const size_t buf_len, const unsigned char* lhs, const size_t lhs_len, const unsigned char* rhs, const size_t rhs_len) not implemented
 #endif
 }
 
 void
-_unsigned_right_shift(unsigned char* buf, size_t buf_len, uintmax_t bit_right_shift)
+_unsigned_right_shift(unsigned char* x, size_t x_len, uintmax_t bit_right_shift)
 {
 	if (0==bit_right_shift) return;
 	const uintmax_t whole_bytes = bit_right_shift/CHAR_BIT;
-	if (buf_len<=whole_bytes)
+	if (x_len<=whole_bytes)
 		{
-		memset(buf,0,buf_len);
+		memset(x,0,x_len);
 		return;
 		}
 
 	const unsigned int left_over_bits = bit_right_shift%CHAR_BIT;
-	const size_t content_span = buf_len-(size_t)(whole_bytes);
+	const size_t content_span = x_len-(size_t)(whole_bytes);
 	if (0==left_over_bits)
 		{
-		memmove(buf,buf+whole_bytes,content_span);
-		memset(buf+content_span,0,whole_bytes);
+		memmove(x,x+whole_bytes,content_span);
+		memset(x+content_span,0,whole_bytes);
 		return;
 		};
 
@@ -251,41 +252,41 @@
 		{
 		while(content_span_sub1>i)
 			{
-			buf[i] = (buf[i+whole_bytes]>>left_over_bits);
-			buf[i] += ((buf[i+whole_bytes+1]%(1U<<left_over_bits))<<(CHAR_BIT-left_over_bits));
+			x[i] = (x[i+whole_bytes]>>left_over_bits);
+			x[i] += ((x[i+whole_bytes+1]%(1U<<left_over_bits))<<(CHAR_BIT-left_over_bits));
 			++i;
 			};
-		buf[content_span_sub1] = (buf[content_span_sub1+whole_bytes]>>left_over_bits);
-		memset(buf+content_span,0,whole_bytes);
+		x[content_span_sub1] = (x[content_span_sub1+whole_bytes]>>left_over_bits);
+		memset(x+content_span,0,whole_bytes);
 		}
 	else{
 		while(content_span_sub1>i)
 			{
-			buf[i] >>= left_over_bits;
-			buf[i] += ((buf[i+1]%(1U<<left_over_bits))<<(CHAR_BIT-left_over_bits));
+			x[i] >>= left_over_bits;
+			x[i] += ((x[i+1]%(1U<<left_over_bits))<<(CHAR_BIT-left_over_bits));
 			++i;
 			};
-		buf[content_span_sub1] = (buf[content_span_sub1+whole_bytes]>>left_over_bits);
+		x[content_span_sub1] = (x[content_span_sub1+whole_bytes]>>left_over_bits);
 		}
 }
 
 void
-_unsigned_left_shift(unsigned char* buf, size_t buf_len, uintmax_t bit_left_shift)
+_unsigned_left_shift(unsigned char* x, size_t x_len, uintmax_t bit_left_shift)
 {
 	if (0==bit_left_shift) return;
 	const uintmax_t whole_bytes = bit_left_shift/CHAR_BIT;
-	if (buf_len<=whole_bytes)
+	if (x_len<=whole_bytes)
 		{
-		memset(buf,0,buf_len);
+		memset(x,0,x_len);
 		return;
 		}
 
 	const unsigned int left_over_bits = bit_left_shift%CHAR_BIT;
-	const size_t content_span = buf_len-(size_t)(whole_bytes);
+	const size_t content_span = x_len-(size_t)(whole_bytes);
 	if (0==left_over_bits)
 		{
-		memmove(buf+whole_bytes,buf,content_span);
-		memset(buf,0,content_span);
+		memmove(x+whole_bytes,x,content_span);
+		memset(x,0,content_span);
 		return;
 		};
 
@@ -294,57 +295,56 @@
 		{
 		while(0<i)
 			{
-			buf[i+whole_bytes] = ((buf[i]%(1U<<(CHAR_BIT-left_over_bits)))<<left_over_bits);
-			buf[i+whole_bytes] += (buf[i-1]>>(CHAR_BIT-left_over_bits));
+			x[i+whole_bytes] = ((x[i]%(1U<<(CHAR_BIT-left_over_bits)))<<left_over_bits);
+			x[i+whole_bytes] += (x[i-1]>>(CHAR_BIT-left_over_bits));
 			--i;
 			};
-		buf[whole_bytes] = ((buf[0]%(1U<<(CHAR_BIT-left_over_bits)))<<left_over_bits);
-		memset(buf,0,whole_bytes);
+		x[whole_bytes] = ((x[0]%(1U<<(CHAR_BIT-left_over_bits)))<<left_over_bits);
+		memset(x,0,whole_bytes);
 		}
 	else{
 		while(0<i)
 			{
-			(buf[i] %= (1U<<(CHAR_BIT-left_over_bits)))<<=left_over_bits;
-			buf[i] += (buf[i-1]>>(CHAR_BIT-left_over_bits));
+			(x[i] %= (1U<<(CHAR_BIT-left_over_bits)))<<=left_over_bits;
+			x[i] += (x[i-1]>>(CHAR_BIT-left_over_bits));
 			--i;
 			};
-		(buf[0] %= (1U<<(CHAR_BIT-left_over_bits)))<<=left_over_bits;
+		(x[0] %= (1U<<(CHAR_BIT-left_over_bits)))<<=left_over_bits;
 		}
 }
 
 int
-_unsigned_cmp(const unsigned char* LHS, size_t LHS_len, const unsigned char* RHS)
+_unsigned_cmp(const unsigned char* lhs, size_t lhs_len, const unsigned char* rhs)
 {	// reverse memcmp
 	do	{
-		--LHS_len;
-		if (LHS[LHS_len]<RHS[LHS_len]) return -1;
-		if (LHS[LHS_len]>RHS[LHS_len]) return 1;
+		--lhs_len;
+		if (lhs[lhs_len]<rhs[lhs_len]) return -1;
+		if (lhs[lhs_len]>rhs[lhs_len]) return 1;
 		}
-	while(0<LHS_len);
+	while(0<lhs_len);
 	return 0;
 }
 
 int
-_unsigned_cmp(const unsigned char* LHS, size_t LHS_len, uintmax_t RHS)
+_unsigned_cmp(const unsigned char* lhs, size_t lhs_len, uintmax_t rhs)
 {	// reverse memcmp
 	do	{
-		--LHS_len;
-		const unsigned char RHS_image = ((RHS & (uintmax_t)(UCHAR_MAX)<<(LHS_len*CHAR_BIT))>>(LHS_len*CHAR_BIT));
-		if (LHS[LHS_len]<RHS_image) return -1;
-		if (LHS[LHS_len]>RHS_image) return 1;
+		--lhs_len;
+		const unsigned char rhs_image = ((rhs & (uintmax_t)(UCHAR_MAX)<<(lhs_len*CHAR_BIT))>>(lhs_len*CHAR_BIT));
+		if (lhs[lhs_len]<rhs_image) return -1;
+		if (lhs[lhs_len]>rhs_image) return 1;
 		}
-	while(0<LHS_len);
+	while(0<lhs_len);
 	return 0;
 }
 
-uintmax_t
-_to_uint(const unsigned char* LHS, size_t LHS_len)
+uintmax_t _to_uint(const unsigned char* x, size_t x_len)
 {
-	uintmax_t tmp = LHS[--LHS_len];
-	while(0<LHS_len)
+	uintmax_t tmp = x[--x_len];
+	while(0<x_len)
 		{
 		tmp <<= CHAR_BIT;
-		tmp += LHS[--LHS_len];
+		tmp += x[--x_len];
 		};
 	return tmp;
 }

Modified: trunk/unsigned_aux.hpp
===================================================================
--- trunk/unsigned_aux.hpp	2009-09-05 16:37:15 UTC (rev 244)
+++ trunk/unsigned_aux.hpp	2009-09-05 17:09:28 UTC (rev 245)
@@ -7,84 +7,84 @@
 #include "Zaimoni.STL/Logging.h"
 
 // utility core to keep executable size from bloating too much
-void _unsigned_copy(unsigned char* _x, uintmax_t src, unsigned int i);
-void _mask_to(unsigned char* LHS, size_t LHS_len, size_t bitcount);
-void _unsigned_sum(unsigned char* LHS, size_t LHS_len, const unsigned char* RHS);
-void _unsigned_sum(unsigned char* LHS, size_t LHS_len, uintmax_t RHS);
-void _unsigned_diff(unsigned char* LHS, size_t LHS_len, const unsigned char* RHS);
-void _unsigned_diff(unsigned char* LHS, size_t LHS_len, uintmax_t RHS);
-unsigned int _int_log2(unsigned char* buf, size_t buf_len);
-void _bitwise_compl(unsigned char* buf, size_t buf_len);
-void _bitwise_and(unsigned char* buf, size_t buf_len, const unsigned char* RHS);
-void _bitwise_xor(unsigned char* buf, size_t buf_len, const unsigned char* RHS);
-void _bitwise_or(unsigned char* buf, size_t buf_len, const unsigned char* RHS);
-void _unsigned_mult(unsigned char* buf, const size_t buf_len, const unsigned char* LHS, size_t LHS_len, const unsigned char* RHS, size_t RHS_len);
-void _unsigned_right_shift(unsigned char* buf, size_t buf_len, uintmax_t bit_right_shift);
-void _unsigned_left_shift(unsigned char* buf, size_t buf_len, uintmax_t bit_left_shift);
-int _unsigned_cmp(const unsigned char* LHS, size_t LHS_len, const unsigned char* RHS);
-int _unsigned_cmp(const unsigned char* LHS, size_t LHS_len, uintmax_t RHS);
-uintmax_t _to_uint(const unsigned char* LHS, size_t LHS_len);
+void _unsigned_copy(unsigned char* x, uintmax_t src, unsigned int i);
+void _mask_to(unsigned char* x, size_t x_len, size_t bitcount);
+void _unsigned_sum(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs);
+void _unsigned_sum(unsigned char* lhs, size_t lhs_len, uintmax_t rhs);
+void _unsigned_diff(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs);
+void _unsigned_diff(unsigned char* lhs, size_t lhs_len, uintmax_t rhs);
+unsigned int _int_log2(unsigned char* x, size_t x_len);
+void _bitwise_compl(unsigned char* x, size_t x_len);
+void _bitwise_and(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs);
+void _bitwise_xor(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs);
+void _bitwise_or(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs);
+void _unsigned_mult(unsigned char* buf, const size_t buf_len, const unsigned char* lhs, size_t lhs_len, const unsigned char* rhs, size_t rhs_len);
+void _unsigned_right_shift(unsigned char* x, size_t x_len, uintmax_t bit_right_shift);
+void _unsigned_left_shift(unsigned char* x, size_t x_len, uintmax_t bit_left_shift);
+int _unsigned_cmp(const unsigned char* lhs, size_t lhs_len, const unsigned char* rhs);
+int _unsigned_cmp(const unsigned char* lhs, size_t lhs_len, uintmax_t rhs);
+uintmax_t _to_uint(const unsigned char* x, size_t x_len);
 void _remainder_quotient(const size_t buf_len,unsigned char* dividend_remainder,const unsigned char* divisor,unsigned char* quotient);
 
-inline void unsigned_copy(unsigned char* _x, uintmax_t src, unsigned int i)
+inline void unsigned_copy(unsigned char* x, uintmax_t src, unsigned int i)
 {
-	assert(NULL!=_x);
+	assert(NULL!=x);
 	assert(0<i);
-	_unsigned_copy(_x,src,i);
+	_unsigned_copy(x,src,i);
 }
 
-inline void mask_to(unsigned char* LHS, size_t LHS_len, size_t bitcount)
+inline void mask_to(unsigned char* x, size_t x_len, size_t bitcount)
 {
-	assert(NULL!=LHS);
-	assert(0<LHS_len);
-	_mask_to(LHS,LHS_len,bitcount);
+	assert(NULL!=x);
+	assert(0<x_len);
+	_mask_to(x,x_len,bitcount);
 }
 
 template<unsigned int i>
-inline void unsigned_copy(unsigned char* _x, uintmax_t src)
+inline void unsigned_copy(unsigned char* x, uintmax_t src)
 {
 	ZAIMONI_STATIC_ASSERT(0<i);
-	assert(NULL!=_x);
-	_unsigned_copy(_x,src,i);
+	assert(NULL!=x);
+	_unsigned_copy(x,src,i);
 }
 
 template<unsigned int i>
-inline void unsigned_copy(unsigned char* _x, const unsigned char* src)
+inline void unsigned_copy(unsigned char* x, const unsigned char* src)
 {
 	ZAIMONI_STATIC_ASSERT(0<i);
-	assert(NULL!=_x);
+	assert(NULL!=x);
 	assert(NULL!=src);
-	memmove(_x,src,i);
+	memmove(x,src,i);
 }
 
-inline void unsigned_sum(unsigned char* LHS, size_t LHS_len, const unsigned char* RHS)
+inline void unsigned_sum(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs)
 {
-	assert(NULL!=LHS);
-	assert(NULL!=RHS);
-	assert(0<LHS_len);
-	_unsigned_sum(LHS,LHS_len,RHS);
+	assert(NULL!=lhs);
+	assert(NULL!=rhs);
+	assert(0<lhs_len);
+	_unsigned_sum(lhs,lhs_len,rhs);
 }
 
-inline void unsigned_sum(unsigned char* LHS, size_t LHS_len, uintmax_t RHS)
+inline void unsigned_sum(unsigned char* lhs, size_t lhs_len, uintmax_t rhs)
 {
-	assert(NULL!=LHS);
-	assert(0<LHS_len);
-	_unsigned_sum(LHS,LHS_len,RHS);
+	assert(NULL!=lhs);
+	assert(0<lhs_len);
+	_unsigned_sum(lhs,lhs_len,rhs);
 }
 
-inline void unsigned_diff(unsigned char* LHS, size_t LHS_len, const unsigned char* RHS)
+inline void unsigned_diff(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs)
 {
-	assert(NULL!=LHS);
-	assert(NULL!=RHS);
-	assert(0<LHS_len);
-	_unsigned_diff(LHS,LHS_len,RHS);
+	assert(NULL!=lhs);
+	assert(NULL!=rhs);
+	assert(0<lhs_len);
+	_unsigned_diff(lhs,lhs_len,rhs);
 }
 
-inline void unsigned_diff(unsigned char* LHS, size_t LHS_len, uintmax_t RHS)
+inline void unsigned_diff(unsigned char* lhs, size_t lhs_len, uintmax_t rhs)
 {
-	assert(NULL!=LHS);
-	assert(0<LHS_len);
-	_unsigned_diff(LHS,LHS_len,RHS);
+	assert(NULL!=lhs);
+	assert(0<lhs_len);
+	_unsigned_diff(lhs,lhs_len,rhs);
 }
 
 inline unsigned int int_log2(unsigned char* buf, size_t buf_len)
@@ -94,90 +94,90 @@
 	return _int_log2(buf,buf_len);
 }
 
-inline void bitwise_compl(unsigned char* buf, size_t buf_len)
+inline void bitwise_compl(unsigned char* x, size_t x_len)
 {
-	assert(NULL!=buf);
-	assert(0<buf_len);
-	_bitwise_compl(buf,buf_len);
+	assert(NULL!=x);
+	assert(0<x_len);
+	_bitwise_compl(x,x_len);
 }
 
-inline void bitwise_and(unsigned char* LHS, size_t LHS_len, const unsigned char* RHS)
+inline void bitwise_and(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs)
 {
-	assert(NULL!=LHS);
-	assert(NULL!=RHS);
-	assert(0<LHS_len);
-	_bitwise_and(LHS,LHS_len,RHS);
+	assert(NULL!=lhs);
+	assert(NULL!=rhs);
+	assert(0<lhs_len);
+	_bitwise_and(lhs,lhs_len,rhs);
 }
 
-inline void bitwise_xor(unsigned char* LHS, size_t LHS_len, const unsigned char* RHS)
+inline void bitwise_xor(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs)
 {
-	assert(NULL!=LHS);
-	assert(NULL!=RHS);
-	assert(0<LHS_len);
-	_bitwise_xor(LHS,LHS_len,RHS);
+	assert(NULL!=lhs);
+	assert(NULL!=lhs);
+	assert(0<lhs_len);
+	_bitwise_xor(lhs,lhs_len,rhs);
 }
 
-inline void bitwise_or(unsigned char* LHS, size_t LHS_len, const unsigned char* RHS)
+inline void bitwise_or(unsigned char* lhs, size_t lhs_len, const unsigned char* rhs)
 {
-	assert(NULL!=LHS);
-	assert(NULL!=RHS);
-	assert(0<LHS_len);
-	_bitwise_or(LHS,LHS_len,RHS);
+	assert(NULL!=lhs);
+	assert(NULL!=rhs);
+	assert(0<lhs_len);
+	_bitwise_or(lhs,lhs_len,rhs);
 }
 
-inline void unsigned_mult(unsigned char* buf, const size_t buf_len, const unsigned char* LHS, const size_t LHS_len, const unsigned char* RHS, const size_t RHS_len)
+inline void unsigned_mult(unsigned char* buf, const size_t buf_len, const unsigned char* lhs, const size_t lhs_len, const unsigned char* rhs, const size_t rhs_len)
 {
 	assert(NULL!=buf);
 	assert(0<buf_len);
-	assert(NULL!=LHS);
-	assert(0<LHS_len);
-	assert(NULL!=RHS);
-	assert(0<RHS_len);
-	_unsigned_mult(buf,buf_len,LHS,LHS_len,RHS,RHS_len);
+	assert(NULL!=lhs);
+	assert(0<lhs_len);
+	assert(NULL!=rhs);
+	assert(0<rhs_len);
+	_unsigned_mult(buf,buf_len,lhs,lhs_len,rhs,rhs_len);
 }
 
-inline void unsigned_right_shift(unsigned char* buf, size_t buf_len, uintmax_t bit_right_shift)
+inline void unsigned_right_shift(unsigned char* x, size_t x_len, uintmax_t bit_right_shift)
 {
-	assert(NULL!=buf);
-	assert(0<buf_len);
-	_unsigned_right_shift(buf,buf_len,bit_right_shift);
+	assert(NULL!=x);
+	assert(0<x_len);
+	_unsigned_right_shift(x,x_len,bit_right_shift);
 }
 
-inline void unsigned_left_shift(unsigned char* buf, size_t buf_len, uintmax_t bit_right_shift)
+inline void unsigned_left_shift(unsigned char* x, size_t x_len, uintmax_t bit_right_shift)
 {
-	assert(NULL!=buf);
-	assert(0<buf_len);
-	_unsigned_left_shift(buf,buf_len,bit_right_shift);
+	assert(NULL!=x);
+	assert(0<x_len);
+	_unsigned_left_shift(x,x_len,bit_right_shift);
 }
 
-inline int unsigned_cmp(const unsigned char* LHS, size_t LHS_len, const unsigned char* RHS)
+inline int unsigned_cmp(const unsigned char* lhs, size_t lhs_len, const unsigned char* rhs)
 {
-	assert(NULL!=LHS);
-	assert(NULL!=RHS);
-	assert(0<LHS_len);
-	return _unsigned_cmp(LHS,LHS_len,RHS);
+	assert(NULL!=lhs);
+	assert(NULL!=rhs);
+	assert(0<lhs_len);
+	return _unsigned_cmp(lhs,lhs_len,rhs);
 }
 
-inline int unsigned_cmp(const unsigned char* LHS, size_t LHS_len, uintmax_t RHS)
+inline int unsigned_cmp(const unsigned char* lhs, size_t lhs_len, uintmax_t rhs)
 {
-	assert(NULL!=LHS);
-	assert(0<LHS_len);
-	return _unsigned_cmp(LHS,LHS_len,RHS);
+	assert(NULL!=lhs);
+	assert(0<lhs_len);
+	return _unsigned_cmp(lhs,lhs_len,rhs);
 }
 
-inline uintmax_t to_uint(const unsigned char* LHS, size_t LHS_len)
+inline uintmax_t to_uint(const unsigned char* x, size_t x_len)
 {
-	assert(NULL!=LHS);
-	assert(0<LHS_len);
-	return _to_uint(LHS,LHS_len);
+	assert(NULL!=x);
+	assert(0<x_len);
+	return _to_uint(x,x_len);
 }
 
-template<size_t LHS_len>
-inline uintmax_t to_uint(const unsigned char* LHS)
+template<size_t x_len>
+inline uintmax_t to_uint(const unsigned char* x)
 {
-	ZAIMONI_STATIC_ASSERT(0<LHS_len);
-	assert(NULL!=LHS);
-	return _to_uint(LHS,LHS_len);
+	ZAIMONI_STATIC_ASSERT(0<x_len);
+	assert(NULL!=x);
+	return _to_uint(x,x_len);
 }
 
 inline void remainder_quotient(size_t buf_len,unsigned char* dividend_remainder,const unsigned char* divisor,unsigned char* quotient)



From zaimoni at mail.berlios.de  Sun Sep  6 20:34:19 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 6 Sep 2009 20:34:19 +0200
Subject: [Zcplusplus-commits] r246 - trunk
Message-ID: <200909061834.n86IYJ28002690@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-06 20:34:16 +0200 (Sun, 06 Sep 2009)
New Revision: 246

Modified:
   trunk/CPreproc_autogen.cpp
   trunk/POSIX.dep
Log:
unbreak build :(  object-size reduction

Modified: trunk/CPreproc_autogen.cpp
===================================================================
--- trunk/CPreproc_autogen.cpp	2009-09-05 17:09:28 UTC (rev 245)
+++ trunk/CPreproc_autogen.cpp	2009-09-06 18:34:16 UTC (rev 246)
@@ -428,14 +428,8 @@
 	unsigned_fixed_int<VM_MAX_BIT_PLATFORM> s_max(target_machine.signed_max<virtual_machine::std_int_char>());
 	tmp[LIMITS_SCHAR_MAX_LINE]->append(z_ucharint_toa(s_max,buf+1,10)-1);
 	if (target_machine.char_is_signed_char()) tmp[LIMITS_CHAR_MAX_LINE]->append(buf);
-	if (virtual_machine::twos_complement==target_machine.C_signed_int_representation() && !bool_options[boolopt::int_traps])
-		{
-		s_max += 1;
-		tmp[LIMITS_SCHAR_MIN_LINE]->append(z_ucharint_toa(s_max,buf+1,10));
-		}
-	else{
-		tmp[LIMITS_SCHAR_MIN_LINE]->append(buf+1);
-		}
+	const bool twos_complement_non_trapping = virtual_machine::twos_complement==target_machine.C_signed_int_representation() && !bool_options[boolopt::int_traps];
+	tmp[LIMITS_SCHAR_MIN_LINE]->append(twos_complement_non_trapping ? z_ucharint_toa(s_max += 1,buf+1,10) : buf+1);
 	if (target_machine.char_is_signed_char()) tmp[LIMITS_CHAR_MIN_LINE]->append(buf+1);
 
 	// unsigned short limits
@@ -444,14 +438,7 @@
 	// signed short limits
 	s_max = target_machine.signed_max<virtual_machine::std_int_short>();
 	tmp[LIMITS_SHRT_MAX_LINE]->append(z_ucharint_toa(s_max,buf+1,10)-1);
-	if (virtual_machine::twos_complement==target_machine.C_signed_int_representation() && !bool_options[boolopt::int_traps])
-		{
-		s_max += 1;
-		tmp[LIMITS_SHRT_MIN_LINE]->append(z_ucharint_toa(s_max,buf+1,10));
-		}
-	else{
-		tmp[LIMITS_SHRT_MIN_LINE]->append(buf+1);
-		}
+	tmp[LIMITS_SHRT_MIN_LINE]->append(twos_complement_non_trapping ? z_ucharint_toa(s_max += 1,buf+1,10) : buf+1);
 
 	// unsigned int limits
 	tmp[LIMITS_UINT_MAX_LINE]->append(z_ucharint_toa(target_machine.unsigned_max<virtual_machine::std_int_int>(),buf+1,10)-1);
@@ -459,14 +446,7 @@
 	// signed int limits
 	s_max = target_machine.signed_max<virtual_machine::std_int_int>();
 	tmp[LIMITS_INT_MAX_LINE]->append(z_ucharint_toa(s_max,buf+1,10)-1);
-	if (virtual_machine::twos_complement==target_machine.C_signed_int_representation() && !bool_options[boolopt::int_traps])
-		{
-		s_max += 1;
-		tmp[LIMITS_INT_MIN_LINE]->append(z_ucharint_toa(s_max,buf+1,10));
-		}
-	else{
-		tmp[LIMITS_INT_MIN_LINE]->append(buf+1);
-		}
+	tmp[LIMITS_INT_MIN_LINE]->append(twos_complement_non_trapping ? z_ucharint_toa(s_max += 1,buf+1,10) : buf+1);
 
 	// unsigned long limits
 	tmp[LIMITS_ULONG_MAX_LINE]->append(z_ucharint_toa(target_machine.unsigned_max<virtual_machine::std_int_long>(),buf+1,10)-1,"UL");
@@ -474,14 +454,7 @@
 	s_max = target_machine.signed_max<virtual_machine::std_int_long>();
 	tmp[LIMITS_LONG_MAX_LINE]->append(z_ucharint_toa(s_max,buf+1,10)-1);
 	tmp[LIMITS_LONG_MAX_LINE]->append('L');
-	if (virtual_machine::twos_complement==target_machine.C_signed_int_representation() && !bool_options[boolopt::int_traps])
-		{
-		s_max += 1;
-		tmp[LIMITS_LONG_MIN_LINE]->append(z_ucharint_toa(s_max,buf+1,10));
-		}
-	else{
-		tmp[LIMITS_LONG_MIN_LINE]->append(buf+1);
-		}
+	tmp[LIMITS_LONG_MIN_LINE]->append(twos_complement_non_trapping ? z_ucharint_toa(s_max += 1,buf+1,10) : buf+1);
 	tmp[LIMITS_LONG_MIN_LINE]->append('L');
 
 	// unsigned long long limits
@@ -489,7 +462,7 @@
 	// signed long long limits
 	s_max = target_machine.signed_max<virtual_machine::std_int_long_long>();
 	tmp[LIMITS_LLONG_MAX_LINE]->append(z_ucharint_toa(s_max,buf+1,10)-1,"LL");
-	if (virtual_machine::twos_complement==target_machine.C_signed_int_representation() && !bool_options[boolopt::int_traps])
+	if (twos_complement_non_trapping)
 		{
 		tmp[LIMITS_LLONG_MIN_LINE]->append("(-1-");
 		tmp[LIMITS_LLONG_MIN_LINE]->append(buf+1,"LL)");

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2009-09-05 17:09:28 UTC (rev 245)
+++ trunk/POSIX.dep	2009-09-06 18:34:16 UTC (rev 246)
@@ -1,11 +1,11 @@
 OBJECTS_Z_CPP = z_cpp.o langroute.o AtomicString.o filesystem.o CPUInfo.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o
-OBJECTS_Z_CPP_LINK_PRIORITY = CSupport.o ParseTree.o type_system.o type_spec.o AtomicString.o CPreproc.o z_cpp.o langroute.o load_src.o C_PPHexInteger.o C_PPDecimalInteger.o C_PPOctalInteger.o CPUInfo.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o unsigned_aux.o CPreproc_autogen.o
+OBJECTS_Z_CPP_LINK_PRIORITY = CPreproc_autogen.o unsigned_aux.o type_spec.o AtomicString.o z_cpp.o CPreproc.o CSupport.o CPUInfo.o type_system.o ParseTree.o langroute.o load_src.o C_PPHexInteger.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
 OBJECTS_ZCC = zcc.o langroute.o AtomicString.o filesystem.o CPUInfo.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = CSupport.o ParseTree.o ZParser.o type_system.o zcc.o type_spec.o AtomicString.o CPreproc.o langroute.o load_src.o C_PPHexInteger.o C_PPDecimalInteger.o C_PPOctalInteger.o CPUInfo.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o unsigned_aux.o CPreproc_autogen.o
+OBJECTS_ZCC_LINK_PRIORITY = CPreproc_autogen.o unsigned_aux.o type_spec.o AtomicString.o zcc.o CPreproc.o CSupport.o CPUInfo.o type_system.o ParseTree.o ZParser.o langroute.o load_src.o C_PPHexInteger.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o Trigraph.o Flat_UNI.o
 
 # dependencies
-z_cpp.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h cpp_util.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/OS/mutex.hpp unsigned_fixed_int.hpp unsigned_aux.hpp
+z_cpp.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/OS/mutex.hpp unsigned_fixed_int.hpp unsigned_aux.hpp
 langroute.o: langroute.hpp CSupport.hpp Zaimoni.STL/Logging.h Zaimoni.STL/POD.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp
 AtomicString.o: AtomicString.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 filesystem.o: filesystem.h Zaimoni.STL/Compiler.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h
@@ -26,5 +26,5 @@
 load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/OS/mutex.hpp
 CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/OS/mutex.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_fixed_int.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
-zcc.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h cpp_util.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/OS/mutex.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
+zcc.o: Zaimoni.STL/LexParse/Token.hpp CSupport.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/OS/mutex.hpp unsigned_fixed_int.hpp unsigned_aux.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h
 ZParser.o: ZParser.hpp CSupport.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp type_algebra.hpp Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp



From zaimoni at mail.berlios.de  Sun Sep  6 22:39:00 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 6 Sep 2009 22:39:00 +0200
Subject: [Zcplusplus-commits] r247 - trunk
Message-ID: <200909062039.n86Kd04x017438@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-06 22:38:55 +0200 (Sun, 06 Sep 2009)
New Revision: 247

Modified:
   trunk/CPreproc.cpp
   trunk/CSupport.cpp
Log:
object size reduction

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2009-09-06 18:34:16 UTC (rev 246)
+++ trunk/CPreproc.cpp	2009-09-06 20:38:55 UTC (rev 247)
@@ -2735,8 +2735,11 @@
 	assert(target.first<target.second);
 	assert(1==pretokenized[target.first].second);
 	assert(1==pretokenized[target.second].second);
-	x.c_array()[pretokenized[target.first].first] = ' ';
-	x.c_array()[pretokenized[target.second].first] = ' ';
+	{
+	char* const tmp = x.c_array();
+	tmp[pretokenized[target.first].first] = ' ';
+	tmp[pretokenized[target.second].first] = ' ';
+	}
 	parenpair_stack.DeleteIdx(target_idx);
 	pretokenized.DeleteIdx(target.second);
 	pretokenized.DeleteIdx(target.first);

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-09-06 18:34:16 UTC (rev 246)
+++ trunk/CSupport.cpp	2009-09-06 20:38:55 UTC (rev 247)
@@ -1849,8 +1849,7 @@
 	return 0;
 }
 
-//! \bug ZParser needs this as well.  Lift out into a pp_support function hook.
-static void C99_bad_syntax_tokenized(const char* const x, size_t x_len, lex_flags& flags, const char* const src_filename, size_t line_no)
+static void _bad_syntax_tokenized(const char* const x, size_t x_len, lex_flags& flags, const char* const src_filename, size_t line_no, func_traits<signed int (*)(const char* const, size_t)>::function_type find_pp_code)
 {
 	assert(NULL!=x);
 	assert(NULL!=src_filename && '\0'!= *src_filename);
@@ -1920,7 +1919,7 @@
 		}
 	else if (C_TESTFLAG_PP_OP_PUNC & flags)
 		{	// language-sensitive token blacklisting
-		const signed int pp_code = CPurePreprocessingOperatorPunctuationCode(x,x_len);
+		const signed int pp_code = find_pp_code(x,x_len);
 		assert(0<pp_code);
 		C_PP_ENCODE(flags,pp_code);
 		}
@@ -1972,126 +1971,14 @@
 		}
 }
 
-static void CPP_bad_syntax_tokenized(const char* const x, size_t x_len, lex_flags& flags, const char* const src_filename, size_t line_no)
+static void C99_bad_syntax_tokenized(const char* const x, size_t x_len, lex_flags& flags, const char* const src_filename, size_t line_no)
 {
-	assert(NULL!=x);
-	assert(NULL!=src_filename && '\0'!= *src_filename);
-	assert(x_len<=strlen(x));
-	assert((C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_PP_OP_PUNC | C_TESTFLAG_STRING_LITERAL | C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_IDENTIFIER) & flags);
+	_bad_syntax_tokenized(x,x_len,flags,src_filename,line_no,CPurePreprocessingOperatorPunctuationCode);
+}
 
-	// reality checks on relation between flag constants and enums
-	BOOST_STATIC_ASSERT((C_PPFloatCore::F<<10)==C_TESTFLAG_F);
-	BOOST_STATIC_ASSERT((C_PPFloatCore::L<<10)==C_TESTFLAG_L);
-
-	BOOST_STATIC_ASSERT((C_PPIntCore::U<<10)==C_TESTFLAG_U);
-	BOOST_STATIC_ASSERT((C_PPIntCore::L<<10)==C_TESTFLAG_L);
-	BOOST_STATIC_ASSERT((C_PPIntCore::UL<<10)==(C_TESTFLAG_L | C_TESTFLAG_U));
-	BOOST_STATIC_ASSERT((C_PPIntCore::LL<<10)==C_TESTFLAG_LL);
-	BOOST_STATIC_ASSERT((C_PPIntCore::ULL<<10)==(C_TESTFLAG_LL | C_TESTFLAG_U));
-
-	if (C_TESTFLAG_PP_NUMERAL==flags)
-		{
-		union_quartet<C_PPIntCore,C_PPFloatCore,C_PPDecimalFloat,C_PPHexFloat> test;
-		if 		(C_PPDecimalFloat::is(x,x_len,test.third))
-			{
-			flags |= C_TESTFLAG_FLOAT | C_TESTFLAG_DECIMAL;
-			}
-		else if	(C_PPHexFloat::is(x,x_len,test.fourth))
-			{
-			flags |= C_TESTFLAG_FLOAT | C_TESTFLAG_HEXADECIMAL;
-			}
-		else if (C_PPIntCore::is(x,x_len,test.first))
-			{
-			assert(C_PPIntCore::ULL>=test.first.hinted_type);
-			flags |= (((lex_flags)(test.first.hinted_type))<<10);
-			assert(8==test.first.radix || 10==test.first.radix || 16==test.first.radix);
-			switch(test.first.radix)
-			{
-			case 8:		{
-						flags |= C_TESTFLAG_INTEGER | C_TESTFLAG_OCTAL;
-						break;
-						}
-			case 10:	{
-						flags |= C_TESTFLAG_INTEGER | C_TESTFLAG_DECIMAL;
-						break;
-						}
-			case 16:	{
-						flags |= C_TESTFLAG_INTEGER | C_TESTFLAG_HEXADECIMAL;
-						break;
-						}
-			};
-			}
-		if 		(flags & C_TESTFLAG_FLOAT)
-			{
-			assert(C_PPFloatCore::L>=test.second.hinted_type);
-			flags |= (((lex_flags)(test.second.hinted_type))<<10);
-			};
-		if (C_TESTFLAG_PP_NUMERAL==flags)
-			{
-			INC_INFORM(src_filename);
-			INC_INFORM(':');
-			INC_INFORM(line_no);
-			INC_INFORM(": ");
-			INC_INFORM(ERR_STR);
-			INC_INFORM("invalid preprocessing number");
-			INC_INFORM(x,x_len);
-			INFORM(" (C99 6.4.4.1p1,6.4.4.2p1/C++98 2.13.1,2.13.3)");
-			zcc_errors.inc_error();
-			return;
-			}
-		}
-	else if (C_TESTFLAG_PP_OP_PUNC & flags)
-		{	// language-sensitive token blacklisting
-		const signed int pp_code = CPPPurePreprocessingOperatorPunctuationCode(x,x_len);
-		assert(0<pp_code);
-		C_PP_ENCODE(flags,pp_code);
-		}
-	else if (C_TESTFLAG_STRING_LITERAL==flags)
-		{	// This gets in by C99 6.6p10, as 6.6p6 doesn't list string literals as legitimate
-		if (!IsLegalCString(x,x_len))
-			{
-			INC_INFORM(src_filename);
-			INC_INFORM(':');
-			INC_INFORM(line_no);
-			INC_INFORM(": ");
-			INC_INFORM(ERR_STR);
-			INC_INFORM(x,x_len);
-			INFORM(" : invalid string (C99 6.4.5p1/C++98 2.13.4)");
-			zcc_errors.inc_error();
-			return;
-			}
-		else if (bool_options[boolopt::pedantic])
-			{
-			INC_INFORM(src_filename);
-			INC_INFORM(':');
-			INC_INFORM(line_no);
-			INC_INFORM(": ");
-			INC_INFORM(WARN_STR);
-			INC_INFORM(x,x_len);
-			INFORM(" : string literals in integer constant expressions are only permitted, not required (C99 6.6p10)");
-			if (bool_options[boolopt::warnings_are_errors])
-				{
-				zcc_errors.inc_error();
-				return;
-				}
-			}
-		}
-	else if (C_TESTFLAG_CHAR_LITERAL==flags)
-		{
-		if (!IsLegalCCharacterLiteral(x,x_len))
-			{
-			INC_INFORM(src_filename);
-			INC_INFORM(':');
-			INC_INFORM(line_no);
-			INC_INFORM(": ");
-			INC_INFORM(ERR_STR);
-			INC_INFORM("invalid character literal ");
-			INC_INFORM(x,x_len);
-			INFORM(" (C99 6.4.4.4p1/C++98 2.13.2)");
-			zcc_errors.inc_error();
-			return;
-			}
-		}
+static void CPP_bad_syntax_tokenized(const char* const x, size_t x_len, lex_flags& flags, const char* const src_filename, size_t line_no)
+{
+	_bad_syntax_tokenized(x,x_len,flags,src_filename,line_no,CPPPurePreprocessingOperatorPunctuationCode);
 }
 
 //! \todo fix these to not assume perfect matching character sets
@@ -7548,8 +7435,8 @@
 			assert(old.bitcount>=rhs.bitcount);
 			const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>());
 			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
-			if (lhs_converted) target_machine->C_promote_integer(lhs_int,lhs,old);
-			if (rhs_converted) target_machine->C_promote_integer(rhs_int,rhs,old);
+			const bool lhs_negative = lhs_converted && target_machine->C_promote_integer(lhs_int,lhs,old);
+			const bool rhs_negative = rhs_converted && target_machine->C_promote_integer(rhs_int,rhs,old);
 			if (lhs_converted && rhs_converted)
 				{
 				force_decimal_literal(src,(lhs_int==rhs_int)==is_equal_op ? "1" : "0",types);



From zaimoni at mail.berlios.de  Sun Sep  6 23:25:42 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 6 Sep 2009 23:25:42 +0200
Subject: [Zcplusplus-commits] r248 - trunk
Message-ID: <200909062125.n86LPgYo021222@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-06 23:25:37 +0200 (Sun, 06 Sep 2009)
New Revision: 248

Modified:
   trunk/CSupport.cpp
   trunk/C_PPDecimalInteger.cpp
   trunk/C_PPHexInteger.cpp
   trunk/C_PPOctalInteger.cpp
Log:
undo redundant variables; object size reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-09-06 20:38:55 UTC (rev 247)
+++ trunk/CSupport.cpp	2009-09-06 21:25:37 UTC (rev 248)
@@ -7435,8 +7435,8 @@
 			assert(old.bitcount>=rhs.bitcount);
 			const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>());
 			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>());
-			const bool lhs_negative = lhs_converted && target_machine->C_promote_integer(lhs_int,lhs,old);
-			const bool rhs_negative = rhs_converted && target_machine->C_promote_integer(rhs_int,rhs,old);
+			if (lhs_converted) target_machine->C_promote_integer(lhs_int,lhs,old);
+			if (rhs_converted) target_machine->C_promote_integer(rhs_int,rhs,old);
 			if (lhs_converted && rhs_converted)
 				{
 				force_decimal_literal(src,(lhs_int==rhs_int)==is_equal_op ? "1" : "0",types);

Modified: trunk/C_PPDecimalInteger.cpp
===================================================================
--- trunk/C_PPDecimalInteger.cpp	2009-09-06 20:38:55 UTC (rev 247)
+++ trunk/C_PPDecimalInteger.cpp	2009-09-06 21:25:37 UTC (rev 248)
@@ -53,14 +53,7 @@
 		++LHS_ptr;
 		};
 	assert('0'<= *LHS_ptr && '9'>= *LHS_ptr);
-	if ('8'<= *LHS_ptr)
-		return 4U*LHS_digit_span;
-	if ('4'<= *LHS_ptr)
-		return 4U*LHS_digit_span-1U;
-	else if ('2'<= *LHS_ptr)
-		return 4U*LHS_digit_span-2U;
-	else
-		return 4U*LHS_digit_span-3U;
+	return 4U*LHS_digit_span-('8'<= *LHS_ptr ? 0U : '4'<= *LHS_ptr ? 1U : '2'<= *LHS_ptr ? 2U : 3U);
 }
 
 int cmp(const C_PPDecimalInteger& LHS, const C_PPDecimalInteger& RHS)

Modified: trunk/C_PPHexInteger.cpp
===================================================================
--- trunk/C_PPHexInteger.cpp	2009-09-06 20:38:55 UTC (rev 247)
+++ trunk/C_PPHexInteger.cpp	2009-09-06 21:25:37 UTC (rev 248)
@@ -8,8 +8,7 @@
 #include <stdlib.h>
 #include <string.h>
 
-bool
-C_PPHexInteger::is(const char* x,size_t token_len,C_PPHexInteger& target)
+bool C_PPHexInteger::is(const char* x,size_t token_len,C_PPHexInteger& target)
 {
 	assert(NULL!=x);
 	assert(0<token_len);
@@ -55,14 +54,7 @@
 		++LHS_ptr;
 		};
 	assert(IsHexadecimalDigit(*LHS_ptr));
-	if ('8'<= *LHS_ptr)
-		return 4U*LHS_digit_span;
-	else if ('4'<= *LHS_ptr)
-		return 4U*LHS_digit_span-1U;
-	else if ('2'<= *LHS_ptr)
-		return 4U*LHS_digit_span-2U;
-	else
-		return 4U*LHS_digit_span-3U;
+	return 4U*LHS_digit_span-('8'<= *LHS_ptr ? 0U : '4'<= *LHS_ptr ? 1U : '2'<= *LHS_ptr ? 2U : 3U);
 }
 
 int cmp(const C_PPHexInteger& LHS, const C_PPHexInteger& RHS)

Modified: trunk/C_PPOctalInteger.cpp
===================================================================
--- trunk/C_PPOctalInteger.cpp	2009-09-06 20:38:55 UTC (rev 247)
+++ trunk/C_PPOctalInteger.cpp	2009-09-06 21:25:37 UTC (rev 248)
@@ -49,12 +49,7 @@
 		++LHS_ptr;
 		};
 	assert('0'<= *LHS_ptr && '7'>= *LHS_ptr);
-	if ('4'<= *LHS_ptr)
-		return 3U*LHS_digit_span;
-	else if ('2'<= *LHS_ptr)
-		return 3U*LHS_digit_span-1U;
-	else
-		return 3U*LHS_digit_span-2U;
+	return 3U*LHS_digit_span-('4'<= *LHS_ptr ? 0U : '2'<= *LHS_ptr ? 1U : 2U);
 }
 
 int cmp(const C_PPOctalInteger& LHS, const C_PPOctalInteger& RHS)



From zaimoni at mail.berlios.de  Fri Sep 11 01:58:31 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 11 Sep 2009 01:58:31 +0200
Subject: [Zcplusplus-commits] r249 - in trunk/tests: zcc zcc.in
Message-ID: <200909102358.n8ANwVoC017750@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-11 01:58:25 +0200 (Fri, 11 Sep 2009)
New Revision: 249

Modified:
   trunk/tests/zcc.in/run_tests_C99.in
   trunk/tests/zcc/run_tests_C99.bat
   trunk/tests/zcc/run_tests_C99.sh
Log:
ZCC C99 tests should actually test error cases

Modified: trunk/tests/zcc/run_tests_C99.bat
===================================================================
--- trunk/tests/zcc/run_tests_C99.bat	2009-09-06 21:25:37 UTC (rev 248)
+++ trunk/tests/zcc/run_tests_C99.bat	2009-09-10 23:58:25 UTC (rev 249)
@@ -12,7 +12,7 @@
 
 @echo Checking ISO error requirements
 @echo ====
- at for %%f in (decl.C99\Error*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (decl.C99\Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
 @for %%f in (decl.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
 
 @echo Checking ISO acceptance requirements

Modified: trunk/tests/zcc/run_tests_C99.sh
===================================================================
--- trunk/tests/zcc/run_tests_C99.sh	2009-09-06 21:25:37 UTC (rev 248)
+++ trunk/tests/zcc/run_tests_C99.sh	2009-09-10 23:58:25 UTC (rev 249)
@@ -19,7 +19,7 @@
 
 	echo Checking ISO error requirements
 	echo ====
-	for F in decl.C99/Error*.h; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in decl.C99/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
 
 	echo Checking ISO acceptance requirements
 	echo ====

Modified: trunk/tests/zcc.in/run_tests_C99.in
===================================================================
--- trunk/tests/zcc.in/run_tests_C99.in	2009-09-06 21:25:37 UTC (rev 248)
+++ trunk/tests/zcc.in/run_tests_C99.in	2009-09-10 23:58:25 UTC (rev 249)
@@ -5,7 +5,7 @@
 VAR CPP ../../zcc --pedantic
 
 ECHO Checking ISO error requirements
-ERROR CPP_ISO decl.C99/Error*
+ERROR CPP decl.C99/Error*
 
 ECHO Checking ISO acceptance requirements
 PASS CPP Pass*



From zaimoni at mail.berlios.de  Fri Sep 11 02:17:49 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 11 Sep 2009 02:17:49 +0200
Subject: [Zcplusplus-commits] r250 - trunk/doc
Message-ID: <200909110017.n8B0HnLY020065@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-11 02:17:46 +0200 (Fri, 11 Sep 2009)
New Revision: 250

Added:
   trunk/doc/SOURCE_MAP.txt
Log:
terse guide to the source code

Added: trunk/doc/SOURCE_MAP.txt
===================================================================
--- trunk/doc/SOURCE_MAP.txt	2009-09-10 23:58:25 UTC (rev 249)
+++ trunk/doc/SOURCE_MAP.txt	2009-09-11 00:17:46 UTC (rev 250)
@@ -0,0 +1,21 @@
+Where is the source?
+* bin: binary directory, for example distribution
+* doc: documentation directory
+* freezer: hard-to-replicate source code that used to be in Z.C++, but no longer is.
+* include: this would be the general include directory.
+* lib: this would be the binary library directory.
+** lib/MSVC32.zcc : include directory for getting MSVC 32-bit builds going.  Known-good for MSVC 2008 Express.
+** lib/zc++ : include directory for core Z.C++ files (C++ specific, those that are safe for all versions)
+** lib/zcc : include director for core ZCC files (C++ specific, those that are safe for all versions)
+* POSIX: POSIX compatibility utilities.  *NIX systems should use the native one (if it works), so not part of the main build.
+** POSIX/cmp : Z.C++ cmp reimplementation.
+* tests: Regression test sets.
+** tests/cpp : tests for the C/C++ preprocessor z_cpp.
+** tests/cpp.in : maintenance files for the C/C++ preprocessor tests.
+** tests/zcc : tests for the C/C++ vaporware compiler zcc.
+** tests/zcc.in : maintenance files for the C/C++ compiler tests.
+* tools: scripts, etc. for test drivers
+** MakeMake.py : Python script for generating makefiles.
+** preproc_testbuilder.py : converts __.in files to synchronized test case sets.
+** testdriver_gen.py : converts __.in files to test driver scripts/batch files
+** keyword_error_gen.py : not sure if this is staying.



From zaimoni at mail.berlios.de  Fri Sep 11 05:49:07 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 11 Sep 2009 05:49:07 +0200
Subject: [Zcplusplus-commits] r251 - trunk/POSIX/cmp
Message-ID: <200909110349.n8B3n67c008841@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-11 05:49:03 +0200 (Fri, 11 Sep 2009)
New Revision: 251

Modified:
   trunk/POSIX/cmp/cmp.c
Log:
would like to include cmp in binary release, so it must build as-is and substitute for vendor cmp adequately

Modified: trunk/POSIX/cmp/cmp.c
===================================================================
--- trunk/POSIX/cmp/cmp.c	2009-09-11 00:17:46 UTC (rev 250)
+++ trunk/POSIX/cmp/cmp.c	2009-09-11 03:49:03 UTC (rev 251)
@@ -8,7 +8,7 @@
 #include <stdio.h>
 #include <limits.h>
 #include <fcntl.h>
-#include "Zaimoni.STL/Logging.h"
+#include "../../Zaimoni.STL/Logging.h"
 
 #define OUTPUT_DEFAULT 0
 #define OUTPUT_VERBOSE 1
@@ -155,6 +155,8 @@
 		/* clamp byte number and line number at INT_MAX, to avoid undefined behavior */
 		if (INT_MAX>bytenum) ++bytenum;
 		if ('\n'==file0_char && INT_MAX>linenum) ++linenum;
+		file0_char = fgetc(files[0]);
+		file1_char = fgetc(files[1]);
 		};
 	if (already_errored) exit(EXIT_FAILURE);
 	{



From zaimoni at mail.berlios.de  Sun Sep 20 07:13:12 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 20 Sep 2009 07:13:12 +0200
Subject: [Zcplusplus-commits] r252 - trunk
Message-ID: <200909200513.n8K5DCFj021371@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-20 07:13:04 +0200 (Sun, 20 Sep 2009)
New Revision: 252

Modified:
   trunk/CSupport.cpp
   trunk/ParseTree.cpp
   trunk/ParseTree.hpp
   trunk/zcc.cpp
Log:
create a default output of zcc when no errors: source transform

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-09-11 03:49:03 UTC (rev 251)
+++ trunk/CSupport.cpp	2009-09-20 05:13:04 UTC (rev 252)
@@ -9578,6 +9578,7 @@
 				// ;: done
 				if (src.data<0>()[i+decl_count+decl_offset].is_atomic() && token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset].index_tokens[0].token))
 					{
+					src.c_array<0>()[i+decl_count+decl_offset].flags |= parse_tree::GOOD_LINE_BREAK;
 					++decl_offset;
 					break;
 					};
@@ -9686,6 +9687,7 @@
 				// GCC uses <unknown> and handles uniqueness at link time
 				src.c_array<0>()[i].c_array<2>()[0].grab_index_token_from_str_literal<0>("<unknown>",C_TESTFLAG_IDENTIFIER);	// pretend it's an identifier
 				src.c_array<0>()[i].c_array<2>()[0].grab_index_token_location_from<0,0>(src.data<0>()[i].data<2>()[1]);	// inject it at where the namespace body starts
+				src.c_array<0>()[i].flags |= parse_tree::GOOD_LINE_BREAK;
 				assert(is_CPP_namespace(src.data<0>()[i]));
 
 				if (active_namespace)
@@ -9745,6 +9747,7 @@
 			src.c_array<0>()[i+1].clear();
 			src.c_array<0>()[i+2].clear();
 			src.DeleteNSlotsAt<0>(2,i+1);
+			src.c_array<0>()[i].flags |= parse_tree::GOOD_LINE_BREAK;
 			assert(is_CPP_namespace(src.data<0>()[i]));
 			// handle named namespace
 			if (NULL==active_namespace)
@@ -9950,6 +9953,7 @@
 				// ;: done
 				if (src.data<0>()[i+decl_count+decl_offset].is_atomic() && token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset].index_tokens[0].token))
 					{
+					src.c_array<0>()[i+decl_count+decl_offset].flags |= parse_tree::GOOD_LINE_BREAK;
 					++decl_offset;
 					break;
 					};

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2009-09-11 03:49:03 UTC (rev 251)
+++ trunk/ParseTree.cpp	2009-09-20 05:13:04 UTC (rev 252)
@@ -215,26 +215,69 @@
 #define USER_MASK (ULONG_MAX-((1U<<parse_tree::PREDEFINED_STRICT_UB)-1))
 	const lex_flags my_rank = src.flags & USER_MASK;
 	bool need_parens = (1==src.size<1>()) ? my_rank>(src.data<1>()->flags & USER_MASK) : false;
+	bool need_space = false;
 	if (need_parens) INC_INFORM('(');
 	size_t i = 0;
-	while(src.size<1>()>i) INC_INFORM(src.data<1>()[i++]);
-	if (need_parens) INC_INFORM(')');
+	while(src.size<1>()>i)
+		{
+		if (need_space) INC_INFORM(' ');
+		need_space = !(src.data<1>()[i].flags & parse_tree::GOOD_LINE_BREAK);
+		INC_INFORM(src.data<1>()[i++]);
+		}
+	if (need_parens)
+		{
+		INC_INFORM(')');
+		need_space = false;
+		};
 	// first index token
-	if (NULL!=src.index_tokens[0].token.first) INC_INFORM(src.index_tokens[0].token.first,src.index_tokens[0].token.second);
+	if (NULL!=src.index_tokens[0].token.first)
+		{
+		if (need_space) INC_INFORM(' ');
+		INC_INFORM(src.index_tokens[0].token.first,src.index_tokens[0].token.second);
+		need_space = true;
+		}
 	// infix data
 	need_parens = (1==src.size<0>()) ? my_rank>(src.data<0>()->flags & USER_MASK) : false;
-	if (need_parens) INC_INFORM('(');
+	if (need_parens)
+		{
+		INC_INFORM('(');
+		need_space = false;
+		}
 	i = 0;
-	while(src.size<0>()>i) INC_INFORM(src.data<0>()[i++]);
-	if (need_parens) INC_INFORM(')');
+	while(src.size<0>()>i)
+		{
+		if (need_space) INC_INFORM(' ');
+		need_space = !(src.data<0>()[i].flags & parse_tree::GOOD_LINE_BREAK);
+		INC_INFORM(src.data<0>()[i++]);
+		}
+	if (need_parens)
+		{
+		INC_INFORM(')');
+		need_space = false;
+		};
 	// second index token
-	if (NULL!=src.index_tokens[1].token.first) INC_INFORM(src.index_tokens[1].token.first,src.index_tokens[1].token.second);
+	if (NULL!=src.index_tokens[1].token.first)
+		{
+		if (need_space) INC_INFORM(' ');
+		INC_INFORM(src.index_tokens[1].token.first,src.index_tokens[1].token.second);
+		need_space = true;
+		}
 	// postfix data
 	need_parens = (1==src.size<2>()) ? my_rank>(src.data<2>()->flags & USER_MASK) : false;
-	if (need_parens) INC_INFORM('(');
+	if (need_parens)
+		{
+		INC_INFORM('(');
+		need_space = false;
+		}
 	i = 0;
-	while(src.size<2>()>i) INC_INFORM(src.data<2>()[i++]);
+	while(src.size<2>()>i)
+		{
+		if (need_space) INC_INFORM(' ');
+		need_space = !(src.data<2>()[i].flags & parse_tree::GOOD_LINE_BREAK);
+		INC_INFORM(src.data<2>()[i++]);
+		}
 	if (need_parens) INC_INFORM(')');
+	if (src.flags & parse_tree::GOOD_LINE_BREAK) INC_INFORM('\n');
 #undef USER_MASK
 }
 

Modified: trunk/ParseTree.hpp
===================================================================
--- trunk/ParseTree.hpp	2009-09-11 03:49:03 UTC (rev 251)
+++ trunk/ParseTree.hpp	2009-09-20 05:13:04 UTC (rev 252)
@@ -36,8 +36,9 @@
 	enum core_flags {	// standardize bitflag use
 		INVALID = (1<<2),	// invalid node
 		CONSTANT_EXPRESSION = (1<<3),	// compile-time constant expression
+		GOOD_LINE_BREAK = (1<<4),	// good place for a line break in INC_INFORM
 		RESERVED_MASK = 3,	// lowest two bits are used to track memory ownership of weak_token
-		PREDEFINED_STRICT_UB = 4	// number of bits reserved by parse_tree
+		PREDEFINED_STRICT_UB = 5	// number of bits reserved by parse_tree
 	};
 
 	weak_token index_tokens[2];	//!< 0: left, 1: right
@@ -364,6 +365,6 @@
 };
 
 void INC_INFORM(const parse_tree& src);
-inline void INFORM(const parse_tree& src) {INC_INFORM(src); INFORM(" ");}
+inline void INFORM(const parse_tree& src) {INC_INFORM(src); INC_INFORM("\n");}
 
 #endif

Modified: trunk/zcc.cpp
===================================================================
--- trunk/zcc.cpp	2009-09-11 03:49:03 UTC (rev 251)
+++ trunk/zcc.cpp	2009-09-20 05:13:04 UTC (rev 252)
@@ -416,14 +416,14 @@
 		//! \todo parse the resulting TokenList...
 		ZParser parser(target_machine,string_options[stringopt::lang]);
 		if (bool_options[boolopt::test]) parser.set_debug(true);
-#if 1
-		parser.parse(TokenList,ParsedList);
-#else
 		const bool export_to_object_ok = parser.parse(TokenList,ParsedList);
 		if (export_to_object_ok)
 			{
+			// export to source code
+			const size_t ParsedList_size = ParsedList.size();
+			size_t i = 0;
+			while(i<ParsedList_size) INFORM(*ParsedList[i++]);
 			};
-#endif
 		return EXIT_SUCCESS;
 		}
 	catch(const std::bad_alloc&)



From zaimoni at mail.berlios.de  Tue Sep 22 20:09:50 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 22 Sep 2009 20:09:50 +0200
Subject: [Zcplusplus-commits] r253 - trunk
Message-ID: <200909221809.n8MI9ofb009295@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-22 20:09:46 +0200 (Tue, 22 Sep 2009)
New Revision: 253

Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc.hpp
Log:
extension macros: __COUNTER__, __INCLUDE_DEPTH__, __TIMESTAMP__

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2009-09-20 05:13:04 UTC (rev 252)
+++ trunk/CPreproc.cpp	2009-09-22 18:09:46 UTC (rev 253)
@@ -24,6 +24,7 @@
 #include "Zaimoni.STL/LexParse/Token.hpp"
 #include "Zaimoni.STL/LexParse/LangConf.hpp"
 #include "Zaimoni.STL/search.hpp"
+#include "Zaimoni.STL/Pure.C/format_util.h"
 
 #include "DebugCSupport.h"
 
@@ -34,10 +35,10 @@
 #define WARN_STR "warning: "
 
 #define INSTALL_TO "\\CPP_App\\Z.C++"
-#define ZCC_VERSION "0.0.1"
+#define ZCC_VERSION "0.0.3"
 #define ZCC_VERSION_MAJOR 0
 #define ZCC_VERSION_MINOR 0
-#define ZCC_VERSION_PATCH 1
+#define ZCC_VERSION_PATCH 3
 
 //! \todo this should be language-sensitive; LangConf not a good location
 static const char* const fixed_system_include_search[] = {
@@ -214,6 +215,9 @@
 		DICT_STRUCT("__cplusplus"),				// undefined/C99, define to 1 for C++0x
 		DICT_STRUCT("defined"),					// must be undefined or else undefined behavior, even not considering C99 6.10.8 p4
 		DICT_STRUCT("_Pragma"),					// considering the syntactical role of the _Pragma operator, lock it even though the standards don't require us to. 
+		DICT_STRUCT("__TIMESTAMP__"),			// lock down our extension macros
+		DICT_STRUCT("__COUNTER__"),				// lock down our extension macros
+		DICT_STRUCT("__INCLUDE_LEVEL__"),		// lock down our extension macros
 		DICT_STRUCT("__ZCC__"),					// lock down our identity
 		DICT_STRUCT("__ZCC_MINOR__"),			// lock down our identity
 		DICT_STRUCT("__ZCC_PATCHLEVEL__")		// lock down our identity
@@ -226,14 +230,20 @@
 		{"__LINE__", NULL},
 		{"__STDC__", "1"},
 		{"__STDC_HOSTED__", "1"},
-		{"__STDC_VERSION__", "1"},	// end standard-mandated macros
-		{"__ZCC__", STRINGIZE(ZCC_VERSION_MAJOR)},				// identity : major version
-		{"__ZCC_MINOR__", STRINGIZE(ZCC_VERSION_MINOR)},		// minor version
-		{"__ZCC_PATCHLEVEL__", STRINGIZE(ZCC_VERSION_PATCH)}	// patchlevel
+		{"__STDC_VERSION__", "1"},		// end standard-mandated macros
+		{"__TIMESTAMP__", NULL},		// extension: GCC, CLang, MSVC
+		{"__COUNTER__", NULL},			// extension: GCC, CLang, MSVC
+		{"__INCLUDE_LEVEL__", NULL},	// extension: GCC, CLang
+		{"__ZCC__", DEEP_STRINGIZE(ZCC_VERSION_MAJOR)},				// identity : major version
+		{"__ZCC_MINOR__", DEEP_STRINGIZE(ZCC_VERSION_MINOR)},		// minor version
+		{"__ZCC_PATCHLEVEL__", DEEP_STRINGIZE(ZCC_VERSION_PATCH)}	// patchlevel
 	};
 
 static const POD_pair<const char*,const char*> CPP0x_macro_identifier_default[]
- =	{	{"__DATE__", NULL},			// start standard-mandated macros
+ =	{	{"__TIMESTAMP__", NULL},		// extension: GCC, CLang, MSVC
+		{"__COUNTER__", NULL},			// extension: GCC, CLang, MSVC
+		{"__INCLUDE_LEVEL__", NULL},	// extension: GCC, CLang
+		{"__DATE__", NULL},			// start standard-mandated macros
 		{"__TIME__", NULL},
 		{"__FILE__", NULL},
 		{"__LINE__", NULL},
@@ -241,13 +251,15 @@
 		{"__STDC_HOSTED__", "1"},
 		{"__STDC_VERSION__", "1"},
 		{"__cplusplus", "1"},		// end standard-mandated macros
-		{"__ZCC__", "0"},			// identity : major version
-		{"__ZCC_MINOR__", "0"},		// minor version
-		{"__ZCC_PATCHLEVEL__", "0"}	// patchlevel
+		{"__ZCC__", DEEP_STRINGIZE(ZCC_VERSION_MAJOR)},				// identity : major version
+		{"__ZCC_MINOR__", DEEP_STRINGIZE(ZCC_VERSION_MINOR)},		// minor version
+		{"__ZCC_PATCHLEVEL__", DEEP_STRINGIZE(ZCC_VERSION_PATCH)}	// patchlevel
 	};
 
 CPreprocessor::CPreprocessor(const virtual_machine::CPUInfo& _target_machine, const char* const _lang)
-:	lang_code(lang_index(_lang)),
+:	counter_macro(0),
+	include_level(0),
+	lang_code(lang_index(_lang)),
 	lang(lexer_from_lang(lang_code)),
 	target_machine(_target_machine),
 	macro_identifier_default(NULL),
@@ -668,16 +680,19 @@
 	// this is subject to the Y10K bug, per standard.
 	// construct __DATE__, __TIME__ macro targets
 	{
-	char time_date_buffer[26];	// C99 requires length 26
+	time_date_buffer[0] = '"';
+	time_buffer[0]='"';
+	date_buffer[0]='"';
 	time_t start_time = time(NULL);
-	strcpy(time_date_buffer,ctime(&start_time));
+	strcpy(time_date_buffer+1,ctime(&start_time));
+	strcpy(time_date_buffer+1+24,"\"");
 	// have base buffer, construct time
-	strncpy(time_buffer+1,time_date_buffer+11,8);
+	strncpy(time_buffer+1,time_date_buffer+12,8);
 	time_buffer[0]='"';
 	strcpy(time_buffer+9,"\"");
 	// construct date
-	strncpy(date_buffer+1,time_date_buffer+4,7);
-	strncpy(date_buffer+8,time_date_buffer+20,4);
+	strncpy(date_buffer+1,time_date_buffer+5,7);
+	strncpy(date_buffer+8,time_date_buffer+21,4);
 	date_buffer[0]='"';
 	strcpy(date_buffer+12,"\"");
 	}
@@ -2056,7 +2071,9 @@
 				// this implies:
 				// * conditional-compilation directives must be balanced for each file
 				// * #line directives never escape files anyway
+			++include_level;
 			_preprocess(IncludeTokenList, locked_macros, macros_object, macros_object_expansion, macros_object_expansion_pre_eval, macros_function, macros_function_arglist, macros_function_expansion, macros_function_expansion_pre_eval, include_file_index, include_file_cache, min_types);
+			--include_level;
 			if (!IncludeTokenList.empty())
 				{
 				size_t j = IncludeTokenList.size();
@@ -3247,8 +3264,8 @@
 	if (-1!=macro_index)
 		{
 		const char* macro_value = NULL;
-		char Buffer[10];
-		char FileBuffer[MAX_PATH+2];
+		char buf[10];
+		char file_buf[MAX_PATH+2];
 		if (NULL!=macro_identifier_default[macro_index].second)
 			// value known, substitute in
 			macro_value = macro_identifier_default[macro_index].second;
@@ -3256,16 +3273,22 @@
 		else if (!strcmp(macro_identifier_default[macro_index].first,"__FILE__"))
 			{
 			assert(NULL!=x.src_filename);
-			FileBuffer[0] = '"';
-			strcpy(FileBuffer+1,x.src_filename);
-			FileBuffer[1+strlen(x.src_filename)] = '"';
-			FileBuffer[2+strlen(x.src_filename)] = '\x00';
-			macro_value = FileBuffer;
+			file_buf[0] = '"';
+			strcpy(file_buf+1,x.src_filename);
+			file_buf[1+strlen(x.src_filename)] = '"';
+			file_buf[2+strlen(x.src_filename)] = '\0';
+			macro_value = file_buf;
 			}
 		else if (!strcmp(macro_identifier_default[macro_index].first,"__LINE__"))
-			macro_value = ltoa((long)(x.logical_line.first),Buffer,10);
+			macro_value = z_umaxtoa(x.logical_line.first,buf,10);
 		else if (!strcmp(macro_identifier_default[macro_index].first,"__TIME__"))
 			macro_value = time_buffer;
+		else if (!strcmp(macro_identifier_default[macro_index].first,"__TIMESTAMP__"))
+			macro_value = time_date_buffer;
+		else if (!strcmp(macro_identifier_default[macro_index].first,"__COUNTER__"))
+			macro_value = z_umaxtoa(counter_macro++,buf,10);
+		else if (!strcmp(macro_identifier_default[macro_index].first,"__INCLUDE_LEVEL__"))
+			macro_value = z_umaxtoa(include_level,buf,10);
 		else{
 			assert(!strcmp(macro_identifier_default[macro_index].first,"__DATE__"));
 			macro_value = date_buffer;
@@ -3861,7 +3884,9 @@
 		INFORM(date_buffer);
 		INC_INFORM("#define __TIME__ ");
 		INFORM(time_buffer);
-		i = 4;
+		INC_INFORM("#define __TIMESTAMP__ ");
+		INFORM(time_date_buffer);
+		i = 7;
 		while(i<macro_identifier_default_count)
 			{
 			INC_INFORM("#define ");

Modified: trunk/CPreproc.hpp
===================================================================
--- trunk/CPreproc.hpp	2009-09-20 05:13:04 UTC (rev 252)
+++ trunk/CPreproc.hpp	2009-09-22 18:09:46 UTC (rev 253)
@@ -39,6 +39,8 @@
 	void set_debug(bool _debug_mode) {debug_mode = _debug_mode;};
 	bool require_padding(char lhs, char rhs) const;
 private:
+	uintmax_t counter_macro;
+	uintmax_t include_level;
 	size_t lang_code;
 	zaimoni::LangConf& lang;					//!< lexer corresponding to the language being preprocessed
 	const virtual_machine::CPUInfo& target_machine;	//!< target machine information
@@ -46,6 +48,7 @@
 	const zaimoni::POD_pair<const char*,size_t>* macro_locked_default; 
 	size_t macro_identifier_default_count;
 	size_t macro_locked_default_count;
+	char time_date_buffer[26+3];	//!< for __TIMESTAMP__ predefined macro
 	char date_buffer[14];	//!< for __DATE__ predefined macro
 	char time_buffer[11];	//!< for __TIME__ predefined macro
 	bool debug_mode;		//!< triggers some diagnostics



From zaimoni at mail.berlios.de  Wed Sep 23 06:41:54 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 23 Sep 2009 06:41:54 +0200
Subject: [Zcplusplus-commits] r254 - in trunk: . tests/zcc
	tests/zcc/staticassert.C1X tests/zcc.in
Message-ID: <200909230441.n8N4fsW6032069@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-23 06:41:31 +0200 (Wed, 23 Sep 2009)
New Revision: 254

Added:
   trunk/tests/zcc/staticassert.C1X/
   trunk/tests/zcc/staticassert.C1X/Error_badarg1.h
   trunk/tests/zcc/staticassert.C1X/Error_badarg1.hpp
   trunk/tests/zcc/staticassert.C1X/Error_badarg2.h
   trunk/tests/zcc/staticassert.C1X/Error_badarg2.hpp
   trunk/tests/zcc/staticassert.C1X/Error_badarg3.h
   trunk/tests/zcc/staticassert.C1X/Error_badarg3.hpp
   trunk/tests/zcc/staticassert.C1X/Error_badarg4.h
   trunk/tests/zcc/staticassert.C1X/Error_badarg4.hpp
   trunk/tests/zcc/staticassert.C1X/Error_badarg5.h
   trunk/tests/zcc/staticassert.C1X/Error_badarg5.hpp
   trunk/tests/zcc/staticassert.C1X/Error_badarg6.h
   trunk/tests/zcc/staticassert.C1X/Error_badarg6.hpp
   trunk/tests/zcc/staticassert.C1X/Error_badarg7.h
   trunk/tests/zcc/staticassert.C1X/Error_badarg7.hpp
   trunk/tests/zcc/staticassert.C1X/Error_scope1.h
   trunk/tests/zcc/staticassert.C1X/Error_scope1.hpp
   trunk/tests/zcc/staticassert.C1X/Error_scope2.h
   trunk/tests/zcc/staticassert.C1X/Error_scope2.hpp
Modified:
   trunk/CSupport.cpp
   trunk/tests/zcc.in/run_tests.in
   trunk/tests/zcc/run_tests.bat
   trunk/tests/zcc/run_tests.sh
Log:
first part of handling _Static_Assert/static_assert

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/CSupport.cpp	2009-09-23 04:41:31 UTC (rev 254)
@@ -436,6 +436,7 @@
 
 static const POD_pair<const char*,size_t> valid_keyword[]
 	=	{	DICT_STRUCT("__asm"),		// reserved to the implementation, so OK to make a keyword for C only
+			DICT_STRUCT("_Static_Assert"),	// C1X keyword not in C++0X
 			DICT_STRUCT("restrict"),	// C99 keywords not in C++98
 			DICT_STRUCT("_Bool"),
 			DICT_STRUCT("_Complex"),
@@ -514,15 +515,16 @@
 			DICT_STRUCT("xor"),
 			DICT_STRUCT("xor_eq"),		// end C++98 alternate-operators
 			DICT_STRUCT("constexpr"),	// C++0X keywords we pay attention to
-			DICT_STRUCT("thread_local")		
+			DICT_STRUCT("static_assert"),
+			DICT_STRUCT("thread_local")
 		};
 
 //! \todo some way to test that constexpr, thread_local are locked only for C++0X mode
 
 // think about C++0x keywords later.
 #define C_KEYWORD_NONSTRICT_LB 0
-#define CPP_KEYWORD_NONSTRICT_LB 5
-#define C_KEYWORD_STRICT_UB 38
+#define CPP_KEYWORD_NONSTRICT_LB 6
+#define C_KEYWORD_STRICT_UB 39
 #define CPP_KEYWORD_STRICT_UB STATIC_SIZE(valid_keyword)
 
 BOOST_STATIC_ASSERT(C_KEYWORD_NONSTRICT_LB<C_KEYWORD_STRICT_UB);
@@ -9416,6 +9418,55 @@
 	while(i<src.size<0>())
 		{
 		conserve_tokens(src.c_array<0>()[i]);
+		// C static assertion scanner
+		if (robust_token_is_string<14>(src.data<0>()[i].index_tokens[0].token,"_Static_Assert"))
+			{	// _Static_Assert ( constant-expression , string-literal ) ;
+			// find the next ';'
+			size_t j = i;
+			while(src.size<0>()> ++j
+				  && (!src.data<0>()[j].is_atomic() || !robust_token_is_char<';'>(src.data<0>()[j].index_tokens[0].token)));
+			if (src.size<0>()==j)
+				{	//! \test zcc/staticassert.C99/Error_scope1.h
+					//! \test zcc/staticassert.C99/Error_scope2.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("static assertion cut off by end of scope");
+				zcc_errors.inc_error();
+				src.DeleteNSlotsAt<0>(j-i,i);
+				continue;
+				};
+			if (   !is_naked_parentheses_pair(src.data<0>()[i+1])
+				|| 3>src.data<0>()[i+1].size<0>()
+				|| !src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-2].is_atomic()
+				|| !src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].is_atomic()
+				|| !robust_token_is_char<','>(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-2].index_tokens[0].token)
+				|| C_TESTFLAG_STRING_LITERAL!=src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].flags)
+				{	//! \test zcc/staticassert.C99/Error_badarg1.h
+					//! \test zcc/staticassert.C99/Error_badarg2.h
+					//! \test zcc/staticassert.C99/Error_badarg3.h
+					//! \test zcc/staticassert.C99/Error_badarg5.h
+					//! \test zcc/staticassert.C99/Error_badarg6.h
+					//! \test zcc/staticassert.C99/Error_badarg7.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("malformed static assertion");
+				zcc_errors.inc_error();
+				src.DeleteNSlotsAt<0>(j-i+1,i);
+				continue;
+				};
+			if (2!=j-i)
+				{	//! \test zcc/staticassert.C99/Error_badarg4.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("garbage between static assertion arguments and terminating ;");
+				zcc_errors.inc_error();
+				src.DeleteNSlotsAt<0>(j-i+1,i);
+				continue;
+				};
+			//! \todo actually use the static assertion correctly.
+			src.DeleteNSlotsAt<0>(j-i+1,i);
+			continue;
+			};
 		// general declaration scanner 
 		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
 		// intercept declarations as follows
@@ -9652,6 +9703,55 @@
 	while(i<src.size<0>())
 		{
 		conserve_tokens(src.c_array<0>()[i]);
+		// C++ static assertion scanner
+		if (robust_token_is_string<13>(src.data<0>()[i].index_tokens[0].token,"static_assert"))
+			{	// static_assert ( constant-expression , string-literal ) ;
+			// find the next ';'
+			size_t j = i;
+			while(src.size<0>()> ++j
+				  && (!src.data<0>()[j].is_atomic() || !robust_token_is_char<';'>(src.data<0>()[j].index_tokens[0].token)));
+			if (src.size<0>()==j)
+				{	//! \test zcc/staticassert.C99/Error_scope1.hpp
+					//! \test zcc/staticassert.C99/Error_scope2.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("static assertion cut off by end of scope");
+				zcc_errors.inc_error();
+				src.DeleteNSlotsAt<0>(j-i,i);
+				continue;
+				};
+			if (   !is_naked_parentheses_pair(src.data<0>()[i+1])
+				|| 3>src.data<0>()[i+1].size<0>()
+				|| !src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-2].is_atomic()
+				|| !src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].is_atomic()
+				|| !robust_token_is_char<','>(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-2].index_tokens[0].token)
+				|| C_TESTFLAG_STRING_LITERAL!=src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].flags)
+				{	//! \test zcc/staticassert.C99/Error_badarg1.hpp
+					//! \test zcc/staticassert.C99/Error_badarg2.hpp
+					//! \test zcc/staticassert.C99/Error_badarg3.hpp
+					//! \test zcc/staticassert.C99/Error_badarg5.hpp
+					//! \test zcc/staticassert.C99/Error_badarg6.hpp
+					//! \test zcc/staticassert.C99/Error_badarg7.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("malformed static assertion");
+				zcc_errors.inc_error();
+				src.DeleteNSlotsAt<0>(j-i+1,i);
+				continue;
+				};
+			if (2!=j-i)
+				{	//! \test zcc/staticassert.C99/Error_badarg4.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("garbage between static assertion arguments and terminating ;");
+				zcc_errors.inc_error();
+				src.DeleteNSlotsAt<0>(j-i+1,i);
+				continue;
+				};
+			//! \todo actually use the static assertion correctly.
+			src.DeleteNSlotsAt<0>(j-i+1,i);
+			continue;
+			};
 		// namespace scanner
 		// need some scheme to handle unnamed namespaces (probably alphabetical counter after something illegal so unmatchable)
 		// C++0X has inline namespaces; ignore these for now (well, maybe not: consuming the inline will prevent problems)

Modified: trunk/tests/zcc/run_tests.bat
===================================================================
--- trunk/tests/zcc/run_tests.bat	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/run_tests.bat	2009-09-23 04:41:31 UTC (rev 254)
@@ -20,6 +20,10 @@
 @for %%f in (decl.C99\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
 @for %%f in (namespace.CPP\Error*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
 @for %%f in (namespace.CPP\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (staticassert.C1X\Error*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (staticassert.C1X\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (staticassert.C1X\Error*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (staticassert.C1X\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
 
 @echo Checking ZCC warnings on ISO-accepted code
 @echo ====

Modified: trunk/tests/zcc/run_tests.sh
===================================================================
--- trunk/tests/zcc/run_tests.sh	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/run_tests.sh	2009-09-23 04:41:31 UTC (rev 254)
@@ -24,6 +24,8 @@
 	for F in decl.C99/Error*.h; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
 	for F in decl.C99/Error*.hpp; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
 	for F in namespace.CPP/Error*.hpp; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in staticassert.C1X/Error*.h; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in staticassert.C1X/Error*.hpp; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
 
 	echo Checking ZCC warnings on ISO-accepted code
 	echo ====

Added: trunk/tests/zcc/staticassert.C1X/Error_badarg1.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg1.h	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg1.h	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_badarg1.h
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+_Static_Assert();
+

Added: trunk/tests/zcc/staticassert.C1X/Error_badarg1.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg1.hpp	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg1.hpp	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_badarg1.hpp
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+static_assert();
+

Added: trunk/tests/zcc/staticassert.C1X/Error_badarg2.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg2.h	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg2.h	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_badarg2.h
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+_Static_Assert(,);
+

Added: trunk/tests/zcc/staticassert.C1X/Error_badarg2.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg2.hpp	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg2.hpp	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_badarg2.hpp
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+static_assert(,);
+

Added: trunk/tests/zcc/staticassert.C1X/Error_badarg3.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg3.h	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg3.h	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_badarg3.h
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+_Static_Assert(,"bad form");
+

Added: trunk/tests/zcc/staticassert.C1X/Error_badarg3.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg3.hpp	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg3.hpp	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_badarg3.hpp
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+static_assert(,"bad form");
+

Added: trunk/tests/zcc/staticassert.C1X/Error_badarg4.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg4.h	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg4.h	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_badarg4.h
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+_Static_Assert(1,"good form") intercalating junk;
+

Added: trunk/tests/zcc/staticassert.C1X/Error_badarg4.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg4.hpp	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg4.hpp	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_badarg4.hpp
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+static_assert(1,"good form") intercalating junk;
+

Added: trunk/tests/zcc/staticassert.C1X/Error_badarg5.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg5.h	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg5.h	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_badarg5.h
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+_Static_Assert;
+

Added: trunk/tests/zcc/staticassert.C1X/Error_badarg5.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg5.hpp	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg5.hpp	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_badarg5.hpp
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+static_assert;
+

Added: trunk/tests/zcc/staticassert.C1X/Error_badarg6.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg6.h	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg6.h	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_badarg6.h
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+_Static_Assert(1()"bad form");
+

Added: trunk/tests/zcc/staticassert.C1X/Error_badarg6.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg6.hpp	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg6.hpp	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_badarg6.hpp
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+static_assert(1()"bad form");
+

Added: trunk/tests/zcc/staticassert.C1X/Error_badarg7.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg7.h	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg7.h	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_badarg7.h
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+_Static_Assert(1,());
+

Added: trunk/tests/zcc/staticassert.C1X/Error_badarg7.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_badarg7.hpp	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_badarg7.hpp	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_badarg7.hpp
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+static_assert(1,());
+

Added: trunk/tests/zcc/staticassert.C1X/Error_scope1.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_scope1.h	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_scope1.h	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_scope1.h
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+_Static_Assert
+

Added: trunk/tests/zcc/staticassert.C1X/Error_scope1.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_scope1.hpp	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_scope1.hpp	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_scope1.hpp
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+static_assert
+

Added: trunk/tests/zcc/staticassert.C1X/Error_scope2.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_scope2.h	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_scope2.h	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_scope2.h
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+_Static_Assert(1,"bad form")
+

Added: trunk/tests/zcc/staticassert.C1X/Error_scope2.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_scope2.hpp	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc/staticassert.C1X/Error_scope2.hpp	2009-09-23 04:41:31 UTC (rev 254)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_scope2.hpp
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+static_assert(1,"bad form")
+

Modified: trunk/tests/zcc.in/run_tests.in
===================================================================
--- trunk/tests/zcc.in/run_tests.in	2009-09-22 18:09:46 UTC (rev 253)
+++ trunk/tests/zcc.in/run_tests.in	2009-09-23 04:41:31 UTC (rev 254)
@@ -9,6 +9,7 @@
 ECHO Checking ISO error requirements
 ERROR CPP_ISO decl.C99/Error*
 ERROR CPP_ISO namespace.CPP/Error*
+ERROR CPP_ISO staticassert.C1X/Error*
 
 ECHO Checking ZCC warnings on ISO-accepted code
 WARN CPP_ISO namespace.CPP/Warn*



From zaimoni at mail.berlios.de  Thu Sep 24 04:16:25 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 24 Sep 2009 04:16:25 +0200
Subject: [Zcplusplus-commits] r255 - in trunk: . Zaimoni.STL
Message-ID: <200909240216.n8O2GP59010704@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-24 04:16:20 +0200 (Thu, 24 Sep 2009)
New Revision: 255

Modified:
   trunk/ParseTree.cpp
   trunk/ParseTree.hpp
   trunk/Zaimoni.STL/flat_alg.h
Log:
preliminary to bringing up simple static assertions

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2009-09-23 04:41:31 UTC (rev 254)
+++ trunk/ParseTree.cpp	2009-09-24 02:16:20 UTC (rev 255)
@@ -186,6 +186,55 @@
 	return true;
 }
 
+void value_copy(parse_tree& dest, const parse_tree& src)
+{	// favor ACID
+	parse_tree_class tmp;
+
+	tmp.type_code.value_copy(src.type_code);
+	if (!src.empty<0>())
+		{
+		size_t i = src.size<0>();
+		if (!tmp.resize<0>(i)) throw std::bad_alloc();
+		zaimoni::autotransform_n(tmp.c_array<0>(),src.data<0>(),i,value_copy);
+		};
+	if (!src.empty<1>())
+		{
+		size_t i = src.size<1>();
+		if (!tmp.resize<1>(i)) throw std::bad_alloc();
+		zaimoni::autotransform_n(tmp.c_array<1>(),src.data<1>(),i,value_copy);
+		}
+	if (!src.empty<2>())
+		{
+		size_t i = src.size<2>();
+		if (!tmp.resize<2>(i)) throw std::bad_alloc();
+		zaimoni::autotransform_n(tmp.c_array<2>(),src.data<2>(),i,value_copy);
+		}
+	// would like a value_copy for weak_token
+	tmp.index_tokens[0] = src.index_tokens[0];
+	tmp.index_tokens[1] = src.index_tokens[1];
+	if (src.own_index_token<0>())
+		{
+		char* tmp2 = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(tmp.index_tokens[0].token.second));
+		memmove(tmp2,src.index_tokens[0].token.first,src.index_tokens[0].token.second);
+		tmp.index_tokens[0].token.first = tmp2;
+		tmp.control_index_token<0>(true);
+		};
+	if (src.own_index_token<1>())
+		{
+		char* tmp2 = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(tmp.index_tokens[1].token.second));
+		memmove(tmp2,src.index_tokens[1].token.first,src.index_tokens[1].token.second);
+		tmp.index_tokens[1].token.first = tmp2;
+		tmp.control_index_token<1>(true);
+		};
+	tmp.flags = src.flags;
+	tmp.subtype = src.subtype;
+
+	dest.destroy();
+	dest = tmp;
+	tmp.clear();
+}
+
+
 void parse_tree::_eval_to_arg(size_t arg_idx, size_t i)
 {
 	parse_tree tmp = data(arg_idx)[i];

Modified: trunk/ParseTree.hpp
===================================================================
--- trunk/ParseTree.hpp	2009-09-23 04:41:31 UTC (rev 254)
+++ trunk/ParseTree.hpp	2009-09-24 02:16:20 UTC (rev 255)
@@ -356,6 +356,9 @@
 	void _eval_to_arg(size_t arg_idx, size_t i);
 };
 
+// wants to be ACID; throws std::bad_alloc on failure
+void value_copy(parse_tree& dest, const parse_tree& src);
+
 // non-virtual, intentionally
 class parse_tree_class : public parse_tree
 {

Modified: trunk/Zaimoni.STL/flat_alg.h
===================================================================
--- trunk/Zaimoni.STL/flat_alg.h	2009-09-23 04:41:31 UTC (rev 254)
+++ trunk/Zaimoni.STL/flat_alg.h	2009-09-24 02:16:20 UTC (rev 255)
@@ -75,6 +75,17 @@
 		};
 }
 
+/* forward-iterator version */
+template<class IO_Iterator,class IO_Iterator2,typename binary_op>
+inline void autotransform_n(IO_Iterator first,IO_Iterator2 first2,size_t N,binary_op op)
+{
+	while(0<N)
+		{
+		op(*first++,*first2++);
+		--N;
+		};
+}
+
 /* range version */
 template<typename unary_op,class IO_Iterator>
 inline bool and_range(unary_op op,IO_Iterator first,IO_Iterator last)



From zaimoni at mail.berlios.de  Thu Sep 24 05:03:14 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 24 Sep 2009 05:03:14 +0200
Subject: [Zcplusplus-commits] r256 - in trunk: . tests/zcc
	tests/zcc/staticassert.C1X tests/zcc.in
Message-ID: <200909240303.n8O33EQk013760@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-24 05:03:00 +0200 (Thu, 24 Sep 2009)
New Revision: 256

Added:
   trunk/tests/zcc/staticassert.C1X/Error_autofail.h
   trunk/tests/zcc/staticassert.C1X/Error_autofail.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
Modified:
   trunk/CSupport.cpp
   trunk/ZParser.cpp
   trunk/tests/zcc.in/run_tests.in
   trunk/tests/zcc/run_tests.bat
   trunk/tests/zcc/run_tests.sh
Log:
make trivial static assertions work

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/CSupport.cpp	2009-09-24 03:03:00 UTC (rev 256)
@@ -2872,13 +2872,13 @@
 	union_pair<char*,my_UNICODE*> buf;
 	if (str_target_wide)
 		{
-		buf.second = reinterpret_cast<my_UNICODE*>(calloc(buf_len,sizeof(my_UNICODE)));
+		buf.second = zaimoni::_new_buffer<my_UNICODE>(buf_len);
 		if (NULL==buf.second) return -5;
 		UnescapeCWideString(buf.second,str1,str1_len);
 		UnescapeCWideString(buf.second+str1_un_len,str2,str2_len);
 		//! \todo C vs C++
 		const size_t target_len = LengthOfEscapedCString(buf.second,buf_len);
-		target = reinterpret_cast<char*>(calloc(target_len,1));
+		target = zaimoni::_new_buffer<char>(target_len);
 		if (NULL==target)
 			{
 			free(buf.second);
@@ -2890,12 +2890,12 @@
 		return 1;
 		}
 	else{
-		buf.first = reinterpret_cast<char*>(calloc(buf_len,1));
+		buf.first = zaimoni::_new_buffer<char>(buf_len);
 		if (NULL==buf.first) return -5;
 		UnescapeCString(buf.first,str1,str1_len);
 		UnescapeCString(buf.first+str1_un_len,str2,str2_len);
 		const size_t target_len = LengthOfEscapedCString(buf.first,buf_len);
-		target = reinterpret_cast<char*>(calloc(target_len,1));		
+		target = zaimoni::_new_buffer<char>(target_len);
 		if (NULL==target)
 			{
 			free(buf.first);
@@ -8872,9 +8872,6 @@
 	if (!_match_pairs(src)) return false;
 	C99_locate_expressions(src,SIZE_MAX,types);
 	if (starting_errors<zcc_errors.err_count()) return false;
-
-	// ...
-
 	while(src.is_raw_list() && 1==src.size<0>()) src.eval_to_arg<0>(0);
 	return true;
 }
@@ -8891,9 +8888,6 @@
 	if (!_this_vaguely_where_it_could_be_cplusplus(src)) return false;
 	CPP_locate_expressions(src,SIZE_MAX,types);
 	if (starting_errors<zcc_errors.err_count()) return false;
-
-	// ...
-
 	while(src.is_raw_list() && 1==src.size<0>()) src.eval_to_arg<0>(0);
 	return true;
 }
@@ -8917,6 +8911,626 @@
 	CPP_notice_primary_type(src);
 }
 
+//! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
+bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
+{
+	assert(NULL!=x);
+	assert(0<x_len);
+	assert(C_TESTFLAG_PP_NUMERAL & flags);
+	assert(!(C_TESTFLAG_FLOAT & flags));
+	C_REALITY_CHECK_PP_NUMERAL_FLAGS(flags);
+	//! \todo need some way to signal legality for integer literals
+	switch(C_EXTRACT_BASE_CODE(flags))
+	{
+#ifndef NDEBUG
+	default: FATAL_CODE("unclassified integer literal",3);
+#endif
+	case C_BASE_OCTAL:
+		{	// all-zeros is zero, ok with leading 0 prefix
+		C_PPOctalInteger test_oct;
+#ifdef NDEBUG
+		C_PPOctalInteger::is(x,x_len,test_oct);
+#else
+		assert(C_PPOctalInteger::is(x,x_len,test_oct));
+#endif
+		return strspn(test_oct.ptr,"0") == test_oct.digit_span;
+		};
+	case C_BASE_DECIMAL:
+		{	// decimal is easy
+		C_PPDecimalInteger test_dec;
+#ifdef NDEBUG
+		C_PPDecimalInteger::is(x,x_len,test_dec);
+#else
+		assert(C_PPDecimalInteger::is(x,x_len,test_dec));
+#endif
+		return 1==test_dec.digit_span && '0'==test_dec.ptr[0];
+		};
+	case C_BASE_HEXADECIMAL:
+		{	// all-zeros is zero, but ignore the leading 0x prefix
+		C_PPHexInteger test_hex;
+#ifdef NDEBUG
+		C_PPHexInteger::is(x,x_len,test_hex);
+#else
+		assert(C_PPHexInteger::is(x,x_len,test_hex));
+#endif
+		return strspn(test_hex.ptr+2,"0")+2 == test_hex.digit_span;
+		};
+	}
+#ifdef NDEBUG
+	return false;
+#endif
+}
+
+static void eval_string_literal_deref(parse_tree& src,const type_system& types,const POD_pair<const char*,size_t>& str_lit,const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& tmp,bool is_negative,bool index_src_is_char)
+{
+	const size_t strict_ub = LengthOfCStringLiteral(str_lit.first,str_lit.second);
+	// C99 6.2.6.2p3 -0 is not actually allowed to generate the bitpattern -0, so no trapping
+	if (is_negative && tmp==0) is_negative = false;
+	if (is_negative)
+		{	//! \test default/Error_if_control66.hpp, default/Error_if_control66.h
+			//! \test default/Error_if_control67.hpp, default/Error_if_control67.h
+		if (!(src.flags & parse_tree::INVALID))
+			{
+			message_header(src.index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INC_INFORM("undefined behavior: ");
+			INC_INFORM(src);
+			INFORM(" dereferences string literal with negative index");
+			if (index_src_is_char)
+				INFORM("(does this source code want char to act like unsigned char?)");
+			src.flags |= parse_tree::INVALID;
+			zcc_errors.inc_error();
+			}
+		return;
+		}
+	else if (strict_ub <= tmp)
+		{	//! \test default/Error_if_control68.hpp, default/Error_if_control68.h
+			//! \test default/Error_if_control69.hpp, default/Error_if_control69.h
+		if (!(src.flags & parse_tree::INVALID))
+			{
+			message_header(src.index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INC_INFORM("undefined behavior: ");
+			INC_INFORM(src);
+			INFORM(" dereferences string literal past its end");
+			if (index_src_is_char && target_machine->signed_max<virtual_machine::std_int_char>()<tmp)
+				{
+				if (tmp.to_uint()-1==target_machine->signed_max<virtual_machine::std_int_char>())
+					{
+					INFORM("(does this source code want char to act like signed char, with integer representation sign-and-magnitude?)");
+					}
+				else if (tmp==target_machine->unsigned_max<virtual_machine::std_int_char>())
+					{
+					INFORM("(does this source code want char to act like signed char, with integer representation one's complement?)");
+					}
+				}
+			src.flags |= parse_tree::INVALID;
+			zcc_errors.inc_error();
+			}
+		return;
+		};
+	char* tmp2 = NULL;
+	assert(tmp.representable_as_uint());
+	GetCCharacterLiteralAt(str_lit.first,str_lit.second,tmp.to_uint(),tmp2);
+	assert(NULL!=tmp2);
+	src.destroy();	// str_lit goes invalid here, don't use again
+	src.grab_index_token_from<0>(tmp2,C_TESTFLAG_CHAR_LITERAL);
+	_label_one_literal(src,types);
+}
+
+static bool
+eval_array_deref(parse_tree& src,const type_system& types,
+				 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+				 func_traits<bool (*)(const parse_tree&)>::function_ref_type literal_converts_to_integer,
+				 func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+{
+	if (!is_array_deref(src)) return false;
+	// crunch __[...]
+	// canonical definition: *((__)+(...))
+	EvalParseTree(*src.c_array<0>(),types);
+	EvalParseTree(*src.c_array<1>(),types);
+	if (parse_tree::CONSTANT_EXPRESSION & src.flags)
+		{
+		const unsigned int str_index = 	(C_TESTFLAG_STRING_LITERAL==src.data<0>()->index_tokens[0].flags) ? 0 :
+										(C_TESTFLAG_STRING_LITERAL==src.data<1>()->index_tokens[0].flags) ? 1 : UINT_MAX;
+		if (UINT_MAX>str_index)
+			{
+			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp; 
+			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index))) return false;
+			const size_t promoted_type = default_promote_type(src.type_code.base_type_index);
+			const virtual_machine::std_int_enum machine_type = (virtual_machine::std_int_enum)((promoted_type-C_TYPE::INT)/2+virtual_machine::std_int_int);
+			eval_string_literal_deref(src,types,src.data(str_index)->index_tokens[0].token,tmp,tmp.test(target_machine->C_bit(machine_type)-1),C_TESTFLAG_CHAR_LITERAL==src.data(1-str_index)->index_tokens[0].flags);
+			return true;
+			}
+		}
+	return false;
+}
+
+static bool eval_deref(	parse_tree& src, const type_system& types,
+						func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
+{
+	//! \todo handle operator overloading (fork to handle C/C++?)
+	//! \todo catch *& cancellation
+	if (is_C99_unary_operator_expression<'*'>(src))
+		{
+		EvalParseTree(*src.c_array<2>(),types);
+		if (C_TESTFLAG_STRING_LITERAL==src.data<2>()->index_tokens[0].flags)
+			{
+			//! \test default/Pass_if_zero.hpp
+			//! \test default/Pass_if_zero.h
+			//! \test default/Pass_if_nonzero.hpp
+			//! \test default/Pass_if_nonzero.h
+			eval_string_literal_deref(src,types,src.data<2>()->index_tokens[0].token,unsigned_fixed_int<VM_MAX_BIT_PLATFORM>(0),false,false);
+			return true;
+			}
+		}
+	return false;
+}
+
+static bool eval_logical_NOT(parse_tree& src, const type_system& types,
+							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							 func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_NOT_expression,
+							 func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool)
+{
+	if (is_logical_NOT_expression(src))
+		{
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_logical_NOT(src,types,is_logical_NOT_expression,literal_converts_to_bool)) return true;
+		}
+	return false;
+}
+
+static bool eval_bitwise_compl(	parse_tree& src, const type_system& types,
+								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+								func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,
+								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+{
+	if (is_bitwise_complement_expression(src))
+		{
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_bitwise_compl(src,types,true,is_bitwise_complement_expression,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_unary_plus(parse_tree& src, const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
+{
+	if (is_C99_unary_operator_expression<'+'>(src))
+		{
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_unary_plus(src,types)) return true;
+		}
+	return false;
+}
+
+static bool eval_unary_minus(parse_tree& src, const type_system& types,
+							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							 func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,
+							 func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_unary_operator_expression<'-'>(src))
+		{
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_unary_minus(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_mult_expression(parse_tree& src,const type_system& types,
+								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_mult_operator_expression<'*'>(src))
+		{
+		EvalParseTree(*src.c_array<1>(),types);
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_mult_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_div_expression(parse_tree& src,const type_system& types,
+								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_mult_operator_expression<'/'>(src))
+		{
+		EvalParseTree(*src.c_array<1>(),types);
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_div_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_mod_expression(parse_tree& src,const type_system& types,
+								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_mult_operator_expression<'%'>(src))
+		{
+		EvalParseTree(*src.c_array<1>(),types);
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_mod_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_add_expression(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_add_operator_expression<'+'>(src))
+		{
+		EvalParseTree(*src.c_array<1>(),types);
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_add_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_sub_expression(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_add_operator_expression<'-'>(src))
+		{
+		EvalParseTree(*src.c_array<1>(),types);
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_sub_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_shift(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_shift_expression(src))
+		{
+		EvalParseTree(*src.c_array<1>(),types);
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_shift(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_relation_expression(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_relation_expression(src))
+		{
+		EvalParseTree(*src.c_array<1>(),types);
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_relation_expression(src,types,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_equality_expression(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_equality_expression,
+							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+{
+	if (is_equality_expression(src))
+		{
+		EvalParseTree(*src.c_array<1>(),types);
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_equality_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_bitwise_AND(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_AND_expression,
+							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+{
+	if (is_bitwise_AND_expression(src))
+		{
+		EvalParseTree(*src.c_array<1>(),types);
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_bitwise_AND(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_bitwise_XOR(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_XOR_expression,
+							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+{
+	if (is_bitwise_XOR_expression(src))
+		{
+		EvalParseTree(*src.c_array<1>(),types);
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_bitwise_XOR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_bitwise_OR(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_OR_expression,
+							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
+							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
+{
+	if (is_bitwise_OR_expression(src))
+		{
+		EvalParseTree(*src.c_array<1>(),types);
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_bitwise_OR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_logical_AND(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_AND_expression,
+							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool)
+{
+	if (is_logical_AND_expression(src))
+		{
+		EvalParseTree(*src.c_array<1>(),types);
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_logical_AND(src,types,literal_converts_to_bool)) return true;
+		}
+	return false;
+}
+
+static bool eval_logical_OR(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_OR_expression,
+							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool)
+{
+	if (is_logical_OR_expression(src))
+		{
+		EvalParseTree(*src.c_array<1>(),types);
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_logical_OR(src,types,literal_converts_to_bool)) return true;
+		}
+	return false;
+}
+
+static bool eval_conditional_operator(parse_tree& src,const type_system& types,
+									  func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+									  func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool)
+{
+	if (is_C99_conditional_operator_expression(src))
+		{	// prefix operator is boolean
+		EvalParseTree(*src.c_array<1>(),types);
+		if (eval_conditional_op(src,literal_converts_to_bool)) return true;
+		}
+	return false;
+}
+
+#if 0
+static bool cancel_addressof_deref_operators(parse_tree& src)
+{
+	assert(is_C99_unary_operator_expression(src));
+	if ('&'==*src.index_tokens[0].token.first)
+		{	// strip off &*, and remove lvalue-ness of target
+		if (is_C99_unary_operator_expression<'*'>(*src.data<2>()) && 0<src.data<2>()->data<2>()->type_code.pointer_power_after_array_decay())
+			{
+			parse_tree tmp = *src.data<2>()->data<2>();
+			tmp.type_code.traits &= ~type_spec::lvalue;
+			src.c_array<2>()->c_array<2>()->clear();
+			src.destroy();
+			src = tmp;
+			return true;
+			}
+#if 0
+		if (is_array_deref(*src.data<2>()))
+			{	//! \todo convert &(___[...]) to (__+...)
+			}
+#endif
+		};
+	return false;
+}
+#endif
+
+static bool C99_EvalParseTree(parse_tree& src,const type_system& types)
+{
+	const size_t starting_errors = zcc_errors.err_count();
+RestartEval:
+	if (src.is_atomic() || (parse_tree::INVALID & src.flags)) return starting_errors==zcc_errors.err_count();
+	if (eval_array_deref(src,types,C99_EvalParseTree,C99_literal_converts_to_integer,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_conditional_operator(src,types,C99_EvalParseTree,C99_literal_converts_to_bool)) goto RestartEval;
+	if (eval_logical_OR(src,types,C99_EvalParseTree,is_C99_logical_OR_expression,C99_literal_converts_to_bool)) goto RestartEval;
+	if (eval_logical_AND(src,types,C99_EvalParseTree,is_C99_logical_AND_expression,C99_literal_converts_to_bool)) goto RestartEval;
+	if (eval_deref(src,types,C99_EvalParseTree)) goto RestartEval; 
+	if (eval_logical_NOT(src,types,C99_EvalParseTree,is_C99_unary_operator_expression<'!'>,C99_literal_converts_to_bool)) goto RestartEval;
+	if (eval_unary_plus(src,types,C99_EvalParseTree)) goto RestartEval;
+	if (eval_unary_minus(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_mult_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_div_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_mod_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_add_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_sub_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_shift(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_relation_expression(src,types,C99_EvalParseTree,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_equality_expression(src,types,C99_EvalParseTree,is_C99_equality_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_AND(src,types,C99_EvalParseTree,is_C99_bitwise_AND_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_XOR(src,types,C99_EvalParseTree,is_C99_bitwise_XOR_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_OR(src,types,C99_EvalParseTree,is_C99_bitwise_OR_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_compl(src,types,C99_EvalParseTree,is_C99_unary_operator_expression<'~'>,C99_intlike_literal_to_VM)) goto RestartEval;
+	return starting_errors==zcc_errors.err_count();
+}
+
+static bool CPP_EvalParseTree(parse_tree& src,const type_system& types)
+{
+	const size_t starting_errors = zcc_errors.err_count();
+RestartEval:
+	if (src.is_atomic() || (parse_tree::INVALID & src.flags)) return starting_errors==zcc_errors.err_count();
+	if (eval_array_deref(src,types,CPP_EvalParseTree,CPP_literal_converts_to_integer,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_conditional_operator(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool)) goto RestartEval;
+	if (eval_logical_OR(src,types,CPP_EvalParseTree,is_CPP_logical_OR_expression,CPP_literal_converts_to_bool)) goto RestartEval;
+	if (eval_logical_AND(src,types,CPP_EvalParseTree,is_CPP_logical_AND_expression,CPP_literal_converts_to_bool)) goto RestartEval;
+	if (eval_deref(src,types,CPP_EvalParseTree)) goto RestartEval; 
+	if (eval_logical_NOT(src,types,CPP_EvalParseTree,is_CPP_logical_NOT_expression,CPP_literal_converts_to_bool)) goto RestartEval;
+	if (eval_unary_plus(src,types,CPP_EvalParseTree)) goto RestartEval;
+	if (eval_unary_minus(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_mult_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_div_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_mod_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_add_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_sub_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_shift(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_relation_expression(src,types,CPP_EvalParseTree,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_equality_expression(src,types,CPP_EvalParseTree,is_CPP_equality_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_AND(src,types,CPP_EvalParseTree,is_CPP_bitwise_AND_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_XOR(src,types,CPP_EvalParseTree,is_CPP_bitwise_XOR_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_OR(src,types,CPP_EvalParseTree,is_CPP_bitwise_OR_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_compl(src,types,CPP_EvalParseTree,is_CPP_bitwise_complement_expression,CPP_intlike_literal_to_VM)) goto RestartEval;
+	return starting_errors==zcc_errors.err_count();
+}
+
+void C99_PPHackTree(parse_tree& src,const type_system& types)
+{
+	if (parse_tree::INVALID & src.flags) return;
+	if (	is_C99_unary_operator_expression<'-'>(src)
+		&&	(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+		{	// compact - literal to literal to get past preprocessor
+		src.eval_to_arg<2>(0);
+		return;
+		};
+	const type_spec old_type = src.type_code;
+	const bool non_representable_int_min = virtual_machine::twos_complement==target_machine->C_signed_int_representation() && !bool_options[boolopt::int_traps];
+	//! \todo handle other instances of non-representable int min constant expressions
+	if (is_C99_add_operator_expression<'-'>(src))
+		{
+		bool is_equal = false;
+		if (C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal))
+			{
+			assert(!is_equal);	// should have intercepted equal-literal reduction earlier
+#ifndef NDEBUG
+			force_decimal_literal(src,"1",types);
+#else
+			force_decimal_literal(src,is_equal ? "0" : "1",types);
+#endif
+			src.type_code.set_type(C_TYPE::INT);
+			return;
+			};
+		if (non_representable_int_min)
+			{
+			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
+			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data<1>());
+			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data<2>());
+			if (lhs_converted && rhs_converted)
+				{	//! \todo deal with signed integer arithmetic
+				const promote_aux old(old_type.base_type_index);
+				assert(old.is_signed);
+				const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+				assert(old.bitcount>=lhs.bitcount);
+				const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+				assert(old.bitcount>=rhs.bitcount);
+
+				// handle sign-extension of lhs, rhs
+#ifndef NDEBUG
+				const bool lhs_negative = target_machine->C_promote_integer(res_int,lhs,old);
+				const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
+#else
+				target_machine->C_promote_integer(res_int,lhs,old);
+				target_machine->C_promote_integer(rhs_int,rhs,old);
+#endif
+				assert(lhs_negative && !rhs_negative);
+				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
+				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
+				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
+				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
+				ub += 1;
+				assert(ub>=lhs_test && ub>=rhs_test);
+				ub -= lhs_test;
+				assert(ub>=rhs_test);
+				lhs_test += rhs_test;
+				assert(target_machine->signed_max(old.machine_type)<lhs_test);
+				// ok...valid but won't reduce.  pick an argument and mock this up
+				src.eval_to_arg<2>(0);
+				return;
+				}
+			}
+		}
+}
+
+void CPP_PPHackTree(parse_tree& src,const type_system& types)
+{
+	if (parse_tree::INVALID & src.flags) return;
+	if (	is_C99_unary_operator_expression<'-'>(src)
+		&&	(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+		{	// compact - literal to literal to get past preprocessor
+		src.eval_to_arg<2>(0);
+		return;
+		};
+	const type_spec old_type = src.type_code;
+	const bool non_representable_int_min = virtual_machine::twos_complement==target_machine->C_signed_int_representation() && !bool_options[boolopt::int_traps];
+	//! \todo handle other instances of non-representable int min constant expressions
+	if (is_C99_add_operator_expression<'-'>(src))
+		{
+		bool is_equal = false;
+		if (C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal))
+			{
+			assert(!is_equal);	// should have intercepted equal-literal reduction earlier
+#ifndef NDEBUG
+			force_decimal_literal(src,"1",types);
+#else
+			force_decimal_literal(src,is_equal ? "0" : "1",types);
+#endif
+			src.type_code.set_type(C_TYPE::INT);
+			return;
+			};
+		if (non_representable_int_min)
+			{
+			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
+			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
+			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data<1>());
+			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data<2>());
+			if (lhs_converted && rhs_converted)
+				{	//! \todo deal with signed integer arithmetic
+				const promote_aux old(old_type.base_type_index);
+				assert(old.is_signed);
+				const promote_aux lhs(src.data<1>()->type_code.base_type_index);
+				assert(old.bitcount>=lhs.bitcount);
+				const promote_aux rhs(src.data<2>()->type_code.base_type_index);
+				assert(old.bitcount>=rhs.bitcount);
+
+				// handle sign-extension of lhs, rhs
+#ifndef NDEBUG
+				const bool lhs_negative = target_machine->C_promote_integer(res_int,lhs,old);
+				const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
+#else
+				target_machine->C_promote_integer(res_int,lhs,old);
+				target_machine->C_promote_integer(rhs_int,rhs,old);
+#endif
+				assert(lhs_negative && !rhs_negative);
+				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
+				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
+				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
+				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
+				ub += 1;
+				assert(ub>=lhs_test && ub>=rhs_test);
+				ub -= lhs_test;
+				assert(ub>=rhs_test);
+				lhs_test += rhs_test;
+				assert(target_machine->signed_max(old.machine_type)<lhs_test);
+				// ok...valid but won't reduce.  pick an argument and mock this up
+				src.eval_to_arg<2>(0);
+				return;
+				}
+			}
+		}
+}
+
 static void conserve_tokens(parse_tree& x)
 {
 	if (x.own_index_token<0>())
@@ -9463,7 +10077,92 @@
 				src.DeleteNSlotsAt<0>(j-i+1,i);
 				continue;
 				};
-			//! \todo actually use the static assertion correctly.
+			// actually use the static assertion correctly.
+			parse_tree_class parsetree;
+			{
+			const size_t k = src.data<0>()[i+1].size<0>()-2;
+			if (!parsetree.resize<0>(k))
+				{
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				_fatal("insufficient RAM to parse static assertion");
+				};
+			zaimoni::autotransform_n(parsetree.c_array<0>(),src.data<0>()[i+1].data<0>(),k,value_copy);
+			}
+			// init above correctly
+			// snip from Condense
+			const size_t starting_errors = zcc_errors.err_count();
+			C99_locate_expressions(parsetree,SIZE_MAX,types);
+			if (starting_errors==zcc_errors.err_count())
+				{
+				while(parsetree.is_raw_list() && 1==parsetree.size<0>()) parsetree.eval_to_arg<0>(0);
+				// end snip from Condense
+				// snip from CPreproc
+				if (!parsetree.is_atomic() && !C99_EvalParseTree(parsetree,types))
+					{
+					parsetree.destroy();	// efficiency
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM(" : control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)");
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt<0>(j-i+1,i);
+					continue;
+					}
+				C99_PPHackTree(parsetree,types);
+				// final, when above is working properly
+				if (!parsetree.is_atomic())
+					{
+					parsetree.destroy();	// efficiency
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM(" : control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)");
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt<0>(j-i+1,i);
+					continue;
+					}
+				// end snip from CPreproc
+				bool is_true = false;
+				if (!C99_literal_converts_to_bool(parsetree,is_true))
+					{
+					parsetree.destroy();	// efficiency
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM(" : control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)");
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt<0>(j-i+1,i);
+					continue;
+					};
+				parsetree.destroy();	// efficiency
+				if (!is_true)
+					{	// oops
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					// hmm...really should unescape string before emitting
+					const size_t tmp_size = LengthOfCStringLiteral(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.second);
+					if (1U>=tmp_size || 'L'== *src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first)
+						{	//! \todo handle wide-strings later
+						INFORM("(static assertion failure)");
+						zcc_errors.inc_error();
+						src.DeleteNSlotsAt<0>(j-i+1,i);
+						continue;
+						};
+					
+					char* tmp = _new_buffer<char>(tmp_size);
+					if (NULL==tmp)
+						{
+						INFORM("(static assertion failure)");
+						zcc_errors.inc_error();
+						src.DeleteNSlotsAt<0>(j-i+1,i);
+						continue;
+						}
+					UnescapeCString(tmp,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first+1,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.second-2);
+					INFORM(tmp);
+					free(tmp);
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt<0>(j-i+1,i);
+					continue;
+					};
+				}
 			src.DeleteNSlotsAt<0>(j-i+1,i);
 			continue;
 			};
@@ -9748,7 +10447,90 @@
 				src.DeleteNSlotsAt<0>(j-i+1,i);
 				continue;
 				};
-			//! \todo actually use the static assertion correctly.
+			// actually use the static assertion correctly.
+			parse_tree_class parsetree;
+			{	// work on a copy of the argument list
+			const size_t k = src.data<0>()[i+1].size<0>()-2;
+			if (!parsetree.resize<0>(k))
+				{
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				_fatal("insufficient RAM to parse static assertion");
+				};
+			zaimoni::autotransform_n(parsetree.c_array<0>(),src.data<0>()[i+1].data<0>(),k,value_copy);
+			}
+			// snip from Condense
+			const size_t starting_errors = zcc_errors.err_count();
+			CPP_locate_expressions(parsetree,SIZE_MAX,types);
+			if (starting_errors==zcc_errors.err_count())
+				{
+				while(parsetree.is_raw_list() && 1==parsetree.size<0>()) parsetree.eval_to_arg<0>(0);
+				// end snip from Condense
+				// snip from CPreproc
+				if (!parsetree.is_atomic() && !CPP_EvalParseTree(parsetree,types))
+					{
+					parsetree.destroy();	// efficiency
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM(" : control expression for static assertion must be a constant convertible to bool (C++0X 7p4)");
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt<0>(j-i+1,i);
+					continue;
+					}
+				CPP_PPHackTree(parsetree,types);
+				if (!parsetree.is_atomic())
+					{
+					parsetree.destroy();	// efficiency
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM(" : control expression for static assertion must be a constant convertible to bool (C++0X 7p4)");
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt<0>(j-i+1,i);
+					continue;
+					}
+				// end snip from CPreproc
+				bool is_true = false;
+				if (!CPP_literal_converts_to_bool(parsetree,is_true))
+					{
+					parsetree.destroy();	// efficiency
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM(" : control expression for static assertion must be a constant convertible to bool (C++0X 7p4)");
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt<0>(j-i+1,i);
+					continue;
+					};
+				parsetree.destroy();	// efficiency
+				if (!is_true)
+					{	// oops
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					// hmm...really should unescape string before emitting
+					const size_t tmp_size = LengthOfCStringLiteral(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.second);
+					if (1U>=tmp_size || 'L'== *src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first)
+						{	//! \todo handle wide-strings later
+						INFORM("(static assertion failure)");
+						zcc_errors.inc_error();
+						src.DeleteNSlotsAt<0>(j-i+1,i);
+						continue;
+						};
+					
+					char* tmp = _new_buffer<char>(tmp_size);
+					if (NULL==tmp)
+						{
+						INFORM("(static assertion failure)");
+						zcc_errors.inc_error();
+						src.DeleteNSlotsAt<0>(j-i+1,i);
+						continue;
+						}
+					UnescapeCString(tmp,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first+1,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.second-2);
+					INFORM(tmp);
+					free(tmp);
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt<0>(j-i+1,i);
+					continue;
+					};
+				}
 			src.DeleteNSlotsAt<0>(j-i+1,i);
 			continue;
 			};
@@ -10086,626 +10868,6 @@
 	CPP_ParseNamespace(src,types,NULL);
 }
 
-//! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
-bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
-{
-	assert(NULL!=x);
-	assert(0<x_len);
-	assert(C_TESTFLAG_PP_NUMERAL & flags);
-	assert(!(C_TESTFLAG_FLOAT & flags));
-	C_REALITY_CHECK_PP_NUMERAL_FLAGS(flags);
-	//! \todo need some way to signal legality for integer literals
-	switch(C_EXTRACT_BASE_CODE(flags))
-	{
-#ifndef NDEBUG
-	default: FATAL_CODE("unclassified integer literal",3);
-#endif
-	case C_BASE_OCTAL:
-		{	// all-zeros is zero, ok with leading 0 prefix
-		C_PPOctalInteger test_oct;
-#ifdef NDEBUG
-		C_PPOctalInteger::is(x,x_len,test_oct);
-#else
-		assert(C_PPOctalInteger::is(x,x_len,test_oct));
-#endif
-		return strspn(test_oct.ptr,"0") == test_oct.digit_span;
-		};
-	case C_BASE_DECIMAL:
-		{	// decimal is easy
-		C_PPDecimalInteger test_dec;
-#ifdef NDEBUG
-		C_PPDecimalInteger::is(x,x_len,test_dec);
-#else
-		assert(C_PPDecimalInteger::is(x,x_len,test_dec));
-#endif
-		return 1==test_dec.digit_span && '0'==test_dec.ptr[0];
-		};
-	case C_BASE_HEXADECIMAL:
-		{	// all-zeros is zero, but ignore the leading 0x prefix
-		C_PPHexInteger test_hex;
-#ifdef NDEBUG
-		C_PPHexInteger::is(x,x_len,test_hex);
-#else
-		assert(C_PPHexInteger::is(x,x_len,test_hex));
-#endif
-		return strspn(test_hex.ptr+2,"0")+2 == test_hex.digit_span;
-		};
-	}
-#ifdef NDEBUG
-	return false;
-#endif
-}
-
-static void eval_string_literal_deref(parse_tree& src,const type_system& types,const POD_pair<const char*,size_t>& str_lit,const unsigned_fixed_int<VM_MAX_BIT_PLATFORM>& tmp,bool is_negative,bool index_src_is_char)
-{
-	const size_t strict_ub = LengthOfCStringLiteral(str_lit.first,str_lit.second);
-	// C99 6.2.6.2p3 -0 is not actually allowed to generate the bitpattern -0, so no trapping
-	if (is_negative && tmp==0) is_negative = false;
-	if (is_negative)
-		{	//! \test default/Error_if_control66.hpp, default/Error_if_control66.h
-			//! \test default/Error_if_control67.hpp, default/Error_if_control67.h
-		if (!(src.flags & parse_tree::INVALID))
-			{
-			message_header(src.index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INC_INFORM("undefined behavior: ");
-			INC_INFORM(src);
-			INFORM(" dereferences string literal with negative index");
-			if (index_src_is_char)
-				INFORM("(does this source code want char to act like unsigned char?)");
-			src.flags |= parse_tree::INVALID;
-			zcc_errors.inc_error();
-			}
-		return;
-		}
-	else if (strict_ub <= tmp)
-		{	//! \test default/Error_if_control68.hpp, default/Error_if_control68.h
-			//! \test default/Error_if_control69.hpp, default/Error_if_control69.h
-		if (!(src.flags & parse_tree::INVALID))
-			{
-			message_header(src.index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INC_INFORM("undefined behavior: ");
-			INC_INFORM(src);
-			INFORM(" dereferences string literal past its end");
-			if (index_src_is_char && target_machine->signed_max<virtual_machine::std_int_char>()<tmp)
-				{
-				if (tmp.to_uint()-1==target_machine->signed_max<virtual_machine::std_int_char>())
-					{
-					INFORM("(does this source code want char to act like signed char, with integer representation sign-and-magnitude?)");
-					}
-				else if (tmp==target_machine->unsigned_max<virtual_machine::std_int_char>())
-					{
-					INFORM("(does this source code want char to act like signed char, with integer representation one's complement?)");
-					}
-				}
-			src.flags |= parse_tree::INVALID;
-			zcc_errors.inc_error();
-			}
-		return;
-		};
-	char* tmp2 = NULL;
-	assert(tmp.representable_as_uint());
-	GetCCharacterLiteralAt(str_lit.first,str_lit.second,tmp.to_uint(),tmp2);
-	assert(NULL!=tmp2);
-	src.destroy();	// str_lit goes invalid here, don't use again
-	src.grab_index_token_from<0>(tmp2,C_TESTFLAG_CHAR_LITERAL);
-	_label_one_literal(src,types);
-}
-
-static bool
-eval_array_deref(parse_tree& src,const type_system& types,
-				 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-				 func_traits<bool (*)(const parse_tree&)>::function_ref_type literal_converts_to_integer,
-				 func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
-	if (!is_array_deref(src)) return false;
-	// crunch __[...]
-	// canonical definition: *((__)+(...))
-	EvalParseTree(*src.c_array<0>(),types);
-	EvalParseTree(*src.c_array<1>(),types);
-	if (parse_tree::CONSTANT_EXPRESSION & src.flags)
-		{
-		const unsigned int str_index = 	(C_TESTFLAG_STRING_LITERAL==src.data<0>()->index_tokens[0].flags) ? 0 :
-										(C_TESTFLAG_STRING_LITERAL==src.data<1>()->index_tokens[0].flags) ? 1 : UINT_MAX;
-		if (UINT_MAX>str_index)
-			{
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp; 
-			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index))) return false;
-			const size_t promoted_type = default_promote_type(src.type_code.base_type_index);
-			const virtual_machine::std_int_enum machine_type = (virtual_machine::std_int_enum)((promoted_type-C_TYPE::INT)/2+virtual_machine::std_int_int);
-			eval_string_literal_deref(src,types,src.data(str_index)->index_tokens[0].token,tmp,tmp.test(target_machine->C_bit(machine_type)-1),C_TESTFLAG_CHAR_LITERAL==src.data(1-str_index)->index_tokens[0].flags);
-			return true;
-			}
-		}
-	return false;
-}
-
-static bool eval_deref(	parse_tree& src, const type_system& types,
-						func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
-{
-	//! \todo handle operator overloading (fork to handle C/C++?)
-	//! \todo catch *& cancellation
-	if (is_C99_unary_operator_expression<'*'>(src))
-		{
-		EvalParseTree(*src.c_array<2>(),types);
-		if (C_TESTFLAG_STRING_LITERAL==src.data<2>()->index_tokens[0].flags)
-			{
-			//! \test default/Pass_if_zero.hpp
-			//! \test default/Pass_if_zero.h
-			//! \test default/Pass_if_nonzero.hpp
-			//! \test default/Pass_if_nonzero.h
-			eval_string_literal_deref(src,types,src.data<2>()->index_tokens[0].token,unsigned_fixed_int<VM_MAX_BIT_PLATFORM>(0),false,false);
-			return true;
-			}
-		}
-	return false;
-}
-
-static bool eval_logical_NOT(parse_tree& src, const type_system& types,
-							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							 func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_NOT_expression,
-							 func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool)
-{
-	if (is_logical_NOT_expression(src))
-		{
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_logical_NOT(src,types,is_logical_NOT_expression,literal_converts_to_bool)) return true;
-		}
-	return false;
-}
-
-static bool eval_bitwise_compl(	parse_tree& src, const type_system& types,
-								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-								func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,
-								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
-	if (is_bitwise_complement_expression(src))
-		{
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_bitwise_compl(src,types,true,is_bitwise_complement_expression,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_unary_plus(parse_tree& src, const type_system& types,
-							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
-{
-	if (is_C99_unary_operator_expression<'+'>(src))
-		{
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_unary_plus(src,types)) return true;
-		}
-	return false;
-}
-
-static bool eval_unary_minus(parse_tree& src, const type_system& types,
-							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							 func_traits<bool (*)(const parse_tree&, bool&)>::function_ref_type literal_converts_to_bool,
-							 func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_unary_operator_expression<'-'>(src))
-		{
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_unary_minus(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_mult_expression(parse_tree& src,const type_system& types,
-								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_mult_operator_expression<'*'>(src))
-		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_mult_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_div_expression(parse_tree& src,const type_system& types,
-								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_mult_operator_expression<'/'>(src))
-		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_div_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_mod_expression(parse_tree& src,const type_system& types,
-								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-								func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-								func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_mult_operator_expression<'%'>(src))
-		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_mod_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_add_expression(parse_tree& src,const type_system& types,
-							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_add_operator_expression<'+'>(src))
-		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_add_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_sub_expression(parse_tree& src,const type_system& types,
-							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_add_operator_expression<'-'>(src))
-		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_sub_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_shift(parse_tree& src,const type_system& types,
-							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_shift_expression(src))
-		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_shift(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_relation_expression(parse_tree& src,const type_system& types,
-							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_relation_expression(src))
-		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_relation_expression(src,types,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_equality_expression(parse_tree& src,const type_system& types,
-							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_equality_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
-	if (is_equality_expression(src))
-		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_equality_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_bitwise_AND(parse_tree& src,const type_system& types,
-							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_AND_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
-	if (is_bitwise_AND_expression(src))
-		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_bitwise_AND(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_bitwise_XOR(parse_tree& src,const type_system& types,
-							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_XOR_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
-	if (is_bitwise_XOR_expression(src))
-		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_bitwise_XOR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_bitwise_OR(parse_tree& src,const type_system& types,
-							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_OR_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool,
-							func_traits<bool (*)(unsigned_fixed_int<VM_MAX_BIT_PLATFORM>&,const parse_tree&)>::function_ref_type intlike_literal_to_VM)
-{
-	if (is_bitwise_OR_expression(src))
-		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_bitwise_OR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_logical_AND(parse_tree& src,const type_system& types,
-							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_AND_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool)
-{
-	if (is_logical_AND_expression(src))
-		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_logical_AND(src,types,literal_converts_to_bool)) return true;
-		}
-	return false;
-}
-
-static bool eval_logical_OR(parse_tree& src,const type_system& types,
-							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_OR_expression,
-							func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool)
-{
-	if (is_logical_OR_expression(src))
-		{
-		EvalParseTree(*src.c_array<1>(),types);
-		EvalParseTree(*src.c_array<2>(),types);
-		if (eval_logical_OR(src,types,literal_converts_to_bool)) return true;
-		}
-	return false;
-}
-
-static bool eval_conditional_operator(parse_tree& src,const type_system& types,
-									  func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
-									  func_traits<bool (*)(const parse_tree&,bool&)>::function_ref_type literal_converts_to_bool)
-{
-	if (is_C99_conditional_operator_expression(src))
-		{	// prefix operator is boolean
-		EvalParseTree(*src.c_array<1>(),types);
-		if (eval_conditional_op(src,literal_converts_to_bool)) return true;
-		}
-	return false;
-}
-
-#if 0
-static bool cancel_addressof_deref_operators(parse_tree& src)
-{
-	assert(is_C99_unary_operator_expression(src));
-	if ('&'==*src.index_tokens[0].token.first)
-		{	// strip off &*, and remove lvalue-ness of target
-		if (is_C99_unary_operator_expression<'*'>(*src.data<2>()) && 0<src.data<2>()->data<2>()->type_code.pointer_power_after_array_decay())
-			{
-			parse_tree tmp = *src.data<2>()->data<2>();
-			tmp.type_code.traits &= ~type_spec::lvalue;
-			src.c_array<2>()->c_array<2>()->clear();
-			src.destroy();
-			src = tmp;
-			return true;
-			}
-#if 0
-		if (is_array_deref(*src.data<2>()))
-			{	//! \todo convert &(___[...]) to (__+...)
-			}
-#endif
-		};
-	return false;
-}
-#endif
-
-static bool C99_EvalParseTree(parse_tree& src,const type_system& types)
-{
-	const size_t starting_errors = zcc_errors.err_count();
-RestartEval:
-	if (src.is_atomic() || (parse_tree::INVALID & src.flags)) return starting_errors==zcc_errors.err_count();
-	if (eval_array_deref(src,types,C99_EvalParseTree,C99_literal_converts_to_integer,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_conditional_operator(src,types,C99_EvalParseTree,C99_literal_converts_to_bool)) goto RestartEval;
-	if (eval_logical_OR(src,types,C99_EvalParseTree,is_C99_logical_OR_expression,C99_literal_converts_to_bool)) goto RestartEval;
-	if (eval_logical_AND(src,types,C99_EvalParseTree,is_C99_logical_AND_expression,C99_literal_converts_to_bool)) goto RestartEval;
-	if (eval_deref(src,types,C99_EvalParseTree)) goto RestartEval; 
-	if (eval_logical_NOT(src,types,C99_EvalParseTree,is_C99_unary_operator_expression<'!'>,C99_literal_converts_to_bool)) goto RestartEval;
-	if (eval_unary_plus(src,types,C99_EvalParseTree)) goto RestartEval;
-	if (eval_unary_minus(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_mult_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_div_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_mod_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_add_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_sub_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_shift(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_relation_expression(src,types,C99_EvalParseTree,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_equality_expression(src,types,C99_EvalParseTree,is_C99_equality_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_AND(src,types,C99_EvalParseTree,is_C99_bitwise_AND_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_XOR(src,types,C99_EvalParseTree,is_C99_bitwise_XOR_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_OR(src,types,C99_EvalParseTree,is_C99_bitwise_OR_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_compl(src,types,C99_EvalParseTree,is_C99_unary_operator_expression<'~'>,C99_intlike_literal_to_VM)) goto RestartEval;
-	return starting_errors==zcc_errors.err_count();
-}
-
-static bool CPP_EvalParseTree(parse_tree& src,const type_system& types)
-{
-	const size_t starting_errors = zcc_errors.err_count();
-RestartEval:
-	if (src.is_atomic() || (parse_tree::INVALID & src.flags)) return starting_errors==zcc_errors.err_count();
-	if (eval_array_deref(src,types,CPP_EvalParseTree,CPP_literal_converts_to_integer,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_conditional_operator(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool)) goto RestartEval;
-	if (eval_logical_OR(src,types,CPP_EvalParseTree,is_CPP_logical_OR_expression,CPP_literal_converts_to_bool)) goto RestartEval;
-	if (eval_logical_AND(src,types,CPP_EvalParseTree,is_CPP_logical_AND_expression,CPP_literal_converts_to_bool)) goto RestartEval;
-	if (eval_deref(src,types,CPP_EvalParseTree)) goto RestartEval; 
-	if (eval_logical_NOT(src,types,CPP_EvalParseTree,is_CPP_logical_NOT_expression,CPP_literal_converts_to_bool)) goto RestartEval;
-	if (eval_unary_plus(src,types,CPP_EvalParseTree)) goto RestartEval;
-	if (eval_unary_minus(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_mult_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_div_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_mod_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_add_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_sub_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_shift(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_relation_expression(src,types,CPP_EvalParseTree,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_equality_expression(src,types,CPP_EvalParseTree,is_CPP_equality_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_AND(src,types,CPP_EvalParseTree,is_CPP_bitwise_AND_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_XOR(src,types,CPP_EvalParseTree,is_CPP_bitwise_XOR_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_OR(src,types,CPP_EvalParseTree,is_CPP_bitwise_OR_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_compl(src,types,CPP_EvalParseTree,is_CPP_bitwise_complement_expression,CPP_intlike_literal_to_VM)) goto RestartEval;
-	return starting_errors==zcc_errors.err_count();
-}
-
-void C99_PPHackTree(parse_tree& src,const type_system& types)
-{
-	if (parse_tree::INVALID & src.flags) return;
-	if (	is_C99_unary_operator_expression<'-'>(src)
-		&&	(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
-		{	// compact - literal to literal to get past preprocessor
-		src.eval_to_arg<2>(0);
-		return;
-		};
-	const type_spec old_type = src.type_code;
-	const bool non_representable_int_min = virtual_machine::twos_complement==target_machine->C_signed_int_representation() && !bool_options[boolopt::int_traps];
-	//! \todo handle other instances of non-representable int min constant expressions
-	if (is_C99_add_operator_expression<'-'>(src))
-		{
-		bool is_equal = false;
-		if (C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal))
-			{
-			assert(!is_equal);	// should have intercepted equal-literal reduction earlier
-#ifndef NDEBUG
-			force_decimal_literal(src,"1",types);
-#else
-			force_decimal_literal(src,is_equal ? "0" : "1",types);
-#endif
-			src.type_code.set_type(C_TYPE::INT);
-			return;
-			};
-		if (non_representable_int_min)
-			{
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data<1>());
-			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data<2>());
-			if (lhs_converted && rhs_converted)
-				{	//! \todo deal with signed integer arithmetic
-				const promote_aux old(old_type.base_type_index);
-				assert(old.is_signed);
-				const promote_aux lhs(src.data<1>()->type_code.base_type_index);
-				assert(old.bitcount>=lhs.bitcount);
-				const promote_aux rhs(src.data<2>()->type_code.base_type_index);
-				assert(old.bitcount>=rhs.bitcount);
-
-				// handle sign-extension of lhs, rhs
-#ifndef NDEBUG
-				const bool lhs_negative = target_machine->C_promote_integer(res_int,lhs,old);
-				const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
-#else
-				target_machine->C_promote_integer(res_int,lhs,old);
-				target_machine->C_promote_integer(rhs_int,rhs,old);
-#endif
-				assert(lhs_negative && !rhs_negative);
-				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
-				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
-				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
-				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
-				ub += 1;
-				assert(ub>=lhs_test && ub>=rhs_test);
-				ub -= lhs_test;
-				assert(ub>=rhs_test);
-				lhs_test += rhs_test;
-				assert(target_machine->signed_max(old.machine_type)<lhs_test);
-				// ok...valid but won't reduce.  pick an argument and mock this up
-				src.eval_to_arg<2>(0);
-				return;
-				}
-			}
-		}
-}
-
-void CPP_PPHackTree(parse_tree& src,const type_system& types)
-{
-	if (parse_tree::INVALID & src.flags) return;
-	if (	is_C99_unary_operator_expression<'-'>(src)
-		&&	(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
-		{	// compact - literal to literal to get past preprocessor
-		src.eval_to_arg<2>(0);
-		return;
-		};
-	const type_spec old_type = src.type_code;
-	const bool non_representable_int_min = virtual_machine::twos_complement==target_machine->C_signed_int_representation() && !bool_options[boolopt::int_traps];
-	//! \todo handle other instances of non-representable int min constant expressions
-	if (is_C99_add_operator_expression<'-'>(src))
-		{
-		bool is_equal = false;
-		if (C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal))
-			{
-			assert(!is_equal);	// should have intercepted equal-literal reduction earlier
-#ifndef NDEBUG
-			force_decimal_literal(src,"1",types);
-#else
-			force_decimal_literal(src,is_equal ? "0" : "1",types);
-#endif
-			src.type_code.set_type(C_TYPE::INT);
-			return;
-			};
-		if (non_representable_int_min)
-			{
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> res_int;
-			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_int;
-			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data<1>());
-			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data<2>());
-			if (lhs_converted && rhs_converted)
-				{	//! \todo deal with signed integer arithmetic
-				const promote_aux old(old_type.base_type_index);
-				assert(old.is_signed);
-				const promote_aux lhs(src.data<1>()->type_code.base_type_index);
-				assert(old.bitcount>=lhs.bitcount);
-				const promote_aux rhs(src.data<2>()->type_code.base_type_index);
-				assert(old.bitcount>=rhs.bitcount);
-
-				// handle sign-extension of lhs, rhs
-#ifndef NDEBUG
-				const bool lhs_negative = target_machine->C_promote_integer(res_int,lhs,old);
-				const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
-#else
-				target_machine->C_promote_integer(res_int,lhs,old);
-				target_machine->C_promote_integer(rhs_int,rhs,old);
-#endif
-				assert(lhs_negative && !rhs_negative);
-				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> lhs_test(res_int);
-				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> rhs_test(rhs_int);
-				unsigned_fixed_int<VM_MAX_BIT_PLATFORM> ub(target_machine->signed_max(old.machine_type));
-				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
-				ub += 1;
-				assert(ub>=lhs_test && ub>=rhs_test);
-				ub -= lhs_test;
-				assert(ub>=rhs_test);
-				lhs_test += rhs_test;
-				assert(target_machine->signed_max(old.machine_type)<lhs_test);
-				// ok...valid but won't reduce.  pick an argument and mock this up
-				src.eval_to_arg<2>(0);
-				return;
-				}
-			}
-		}
-}
-
 PP_auxfunc C99_aux
  = 	{
 	LengthOfCSystemHeader,

Modified: trunk/ZParser.cpp
===================================================================
--- trunk/ZParser.cpp	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/ZParser.cpp	2009-09-24 03:03:00 UTC (rev 256)
@@ -3,6 +3,7 @@
 #include "ZParser.hpp"
 
 #include "CSupport.hpp"
+#include "errors.hpp"
 #include "errcount.hpp"
 #include "langroute.hpp"
 #include "ParseTree.hpp"
@@ -55,7 +56,12 @@
 			i = pretokenized.size();
 			do	{
 				--i;
+				// XXX optimized for preprocessor -- should actually be its own hook
+				// disable pedantic warnings to avoid fake warnings about string literals
+				const bool pedantic_backup = bool_options[boolopt::pedantic];
+				bool_options[boolopt::pedantic] = false;
 				lang.pp_support->AddPostLexFlags(TokenList.front()->data()+pretokenized[i].first, pretokenized[i].second, pretokenized[i].third, TokenList.front()->src_filename, TokenList.front()->original_line.first);
+				bool_options[boolopt::pedantic] = pedantic_backup;
 				if (	(C_TESTFLAG_PP_OP_PUNC & pretokenized[i].third)
 					&& 	(C_DISALLOW_POSTPROCESSED_SOURCE & lang.pp_support->GetPPOpPuncFlags(C_PP_DECODE(pretokenized[i].third))))
 					{

Modified: trunk/tests/zcc/run_tests.bat
===================================================================
--- trunk/tests/zcc/run_tests.bat	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/tests/zcc/run_tests.bat	2009-09-24 03:03:00 UTC (rev 256)
@@ -37,6 +37,10 @@
 @for %%f in (Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
 @for %%f in (Pass*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
 @for %%f in (Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (staticassert.C1X\Pass*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (staticassert.C1X\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (staticassert.C1X\Pass*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (staticassert.C1X\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
 
 @echo %BAD_PASS% of %REJECT_TEST% rejection tests accepted
 @if not "%BAD_PASS_NAME%"=="LastAccepted:" @echo %BAD_PASS_NAME%

Modified: trunk/tests/zcc/run_tests.sh
===================================================================
--- trunk/tests/zcc/run_tests.sh	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/tests/zcc/run_tests.sh	2009-09-24 03:03:00 UTC (rev 256)
@@ -36,6 +36,8 @@
 	echo ====
 	for F in Pass*.h; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 	for F in Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in staticassert.C1X/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in staticassert.C1X/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
 
 	echo -E $BAD_PASS of $REJECT_TEST rejection tests accepted
 	if test -n "$BAD_PASS_NAME"; then echo -E $BAD_PASS_NAME; fi

Added: trunk/tests/zcc/staticassert.C1X/Error_autofail.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_autofail.h	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/tests/zcc/staticassert.C1X/Error_autofail.h	2009-09-24 03:03:00 UTC (rev 256)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_autofail.h
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+_Static_Assert(0,"automatic failure");
+

Added: trunk/tests/zcc/staticassert.C1X/Error_autofail.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_autofail.hpp	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/tests/zcc/staticassert.C1X/Error_autofail.hpp	2009-09-24 03:03:00 UTC (rev 256)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_autofail.hpp
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+static_assert(0,"automatic failure");
+

Added: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2009-09-24 03:03:00 UTC (rev 256)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_autosuccess.h
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+_Static_Assert(1,"automatic success");
+

Added: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2009-09-24 03:03:00 UTC (rev 256)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_autosuccess.hpp
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+static_assert(1,"automatic success");
+

Modified: trunk/tests/zcc.in/run_tests.in
===================================================================
--- trunk/tests/zcc.in/run_tests.in	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/tests/zcc.in/run_tests.in	2009-09-24 03:03:00 UTC (rev 256)
@@ -16,6 +16,7 @@
 
 ECHO Checking ISO acceptance requirements
 PASS CPP_ISO Pass*
+PASS CPP_ISO staticassert.C1X/Pass*
 
 EPILOG
 



From zaimoni at mail.berlios.de  Thu Sep 24 22:54:21 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 24 Sep 2009 22:54:21 +0200
Subject: [Zcplusplus-commits] r257 - in trunk: . Zaimoni.STL
Message-ID: <200909242054.n8OKsLj6014944@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-24 22:54:14 +0200 (Thu, 24 Sep 2009)
New Revision: 257

Modified:
   trunk/CSupport.cpp
   trunk/ParseTree.cpp
   trunk/ParseTree.hpp
   trunk/Zaimoni.STL/Logging.h
   trunk/type_spec.cpp
   trunk/type_spec.hpp
Log:
make a few functions ACID/strong exception guarantee

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-09-24 03:03:00 UTC (rev 256)
+++ trunk/CSupport.cpp	2009-09-24 20:54:14 UTC (rev 257)
@@ -8892,6 +8892,7 @@
 	return true;
 }
 
+//! \todo check that the fact all literals are already legal-form is used
 static void C99_ContextFreeParse(parse_tree& src,const type_system& types)
 {
 	assert(src.is_raw_list());
@@ -8901,6 +8902,7 @@
 	C99_notice_primary_type(src);
 }
 
+//! \todo check that the fact all literals are already legal-form is used
 static void CPP_ContextFreeParse(parse_tree& src,const type_system& types)
 {
 	assert(src.is_raw_list());
@@ -9539,6 +9541,7 @@
 		if (tmp)
 			{
 			assert(tmp!=x.index_tokens[0].token.first);
+			free(const_cast<char*>(x.index_tokens[0].token.first));
 			x.index_tokens[0].token.first = tmp;
 			x.control_index_token<0>(false);
 			}
@@ -9549,6 +9552,7 @@
 		if (tmp)
 			{
 			assert(tmp!=x.index_tokens[1].token.first);
+			free(const_cast<char*>(x.index_tokens[1].token.first));
 			x.index_tokens[1].token.first = tmp;
 			x.control_index_token<1>(false);
 			}
@@ -10011,6 +10015,7 @@
 // return: 1 typespec record (for now, other languages may have more demanding requirements)
 // incoming: n typespec records, flag for trailing ...
 // will need: typedef map: identifier |-> typespec record
+//! \todo check that the fact all literals are already legal-form is used
 static void C99_ContextParse(parse_tree& src,type_system& types)
 {
 	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle in type_spec, which is required to be POD to allow C memory management:
@@ -10111,7 +10116,7 @@
 				C99_PPHackTree(parsetree,types);
 				// final, when above is working properly
 				if (!parsetree.is_atomic())
-					{
+					{	//! \bug need test cases
 					parsetree.destroy();	// efficiency
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -10123,7 +10128,7 @@
 				// end snip from CPreproc
 				bool is_true = false;
 				if (!C99_literal_converts_to_bool(parsetree,is_true))
-					{
+					{	//! \bug need test cases
 					parsetree.destroy();	// efficiency
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -10133,8 +10138,9 @@
 					continue;
 					};
 				parsetree.destroy();	// efficiency
+				//! \test zcc/staticassert.C1X/Pass_autosucceed.h
 				if (!is_true)
-					{	// oops
+					{	//! \test zcc/staticassert.C1X/Error_autofail.h
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					// hmm...really should unescape string before emitting
@@ -10371,6 +10377,7 @@
 #endif
 
 // handle namespaces or else
+//! \todo check that the fact all literals are already legal-form is used
 static void CPP_ParseNamespace(parse_tree& src,type_system& types,const char* const active_namespace)
 {
 	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle
@@ -10479,7 +10486,7 @@
 					}
 				CPP_PPHackTree(parsetree,types);
 				if (!parsetree.is_atomic())
-					{
+					{	//! \bug need test cases
 					parsetree.destroy();	// efficiency
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -10491,7 +10498,7 @@
 				// end snip from CPreproc
 				bool is_true = false;
 				if (!CPP_literal_converts_to_bool(parsetree,is_true))
-					{
+					{	//! \bug need test cases
 					parsetree.destroy();	// efficiency
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
@@ -10501,8 +10508,9 @@
 					continue;
 					};
 				parsetree.destroy();	// efficiency
+				//! \test zcc/staticassert.C1X/Pass_autosucceed.hpp
 				if (!is_true)
-					{	// oops
+					{	//! \test zcc/staticassert.C1X/Error_autofail.hpp
 					message_header(src.data<0>()[i].index_tokens[0]);
 					INC_INFORM(ERR_STR);
 					// hmm...really should unescape string before emitting

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2009-09-24 03:03:00 UTC (rev 256)
+++ trunk/ParseTree.cpp	2009-09-24 20:54:14 UTC (rev 257)
@@ -186,6 +186,7 @@
 	return true;
 }
 
+// ACID; throws std::bad_alloc on failure
 void value_copy(parse_tree& dest, const parse_tree& src)
 {	// favor ACID
 	parse_tree_class tmp;

Modified: trunk/ParseTree.hpp
===================================================================
--- trunk/ParseTree.hpp	2009-09-24 03:03:00 UTC (rev 256)
+++ trunk/ParseTree.hpp	2009-09-24 20:54:14 UTC (rev 257)
@@ -356,7 +356,7 @@
 	void _eval_to_arg(size_t arg_idx, size_t i);
 };
 
-// wants to be ACID; throws std::bad_alloc on failure
+// ACID; throws std::bad_alloc on failure
 void value_copy(parse_tree& dest, const parse_tree& src);
 
 // non-virtual, intentionally

Modified: trunk/Zaimoni.STL/Logging.h
===================================================================
--- trunk/Zaimoni.STL/Logging.h	2009-09-24 03:03:00 UTC (rev 256)
+++ trunk/Zaimoni.STL/Logging.h	2009-09-24 20:54:14 UTC (rev 257)
@@ -15,9 +15,11 @@
 #undef assert
 #ifdef NDEBUG
 #	define assert(A)	((void)0)
+#	define ZAIMONI_PASSTHROUGH_ASSERT(A)	A
 #else
 /* Interoperate with Microsoft: return code 3 */
 #	define assert(A)	((A) ? (void)0 : FATAL_CODE(#A,3))
+#	define ZAIMONI_PASSTHROUGH_ASSERT(A)	((A) ? (void)0 : FATAL_CODE(#A,3))
 #endif
 
 /*!

Modified: trunk/type_spec.cpp
===================================================================
--- trunk/type_spec.cpp	2009-09-24 03:03:00 UTC (rev 256)
+++ trunk/type_spec.cpp	2009-09-24 20:54:14 UTC (rev 257)
@@ -20,11 +20,26 @@
 {
 	if (_size==pointer_power) return;
 	assert(0<_size);
-	if (!zaimoni::_resize(extent_vector,_size)) throw std::bad_alloc();
 	const bool shrinking = _size<pointer_power;
 	const size_t old_ptr_power = pointer_power_after_array_decay();
 	const size_t new_ptr_power = old_ptr_power+(_size-pointer_power);	// modulo arithmetic
-	if (!shrinking) memset(extent_vector+pointer_power,0,sizeof(uintmax_t)*(_size-pointer_power));
+	unsigned char* tmp_first = (shrinking || sizeof(unsigned char*)>new_ptr_power) ? NULL : zaimoni::_new_buffer_nonNULL_throws<unsigned char>(new_ptr_power+1);
+	if (!zaimoni::_resize(extent_vector,_size))
+		{
+		free(tmp_first);
+		throw std::bad_alloc();
+		};
+	if (!shrinking)
+		{
+		memset(extent_vector+pointer_power,0,sizeof(uintmax_t)*(_size-pointer_power));
+		if (NULL!=tmp_first)
+			{
+			memcpy(tmp_first,sizeof(unsigned char*)>old_ptr_power ? qualifier_vector.second : qualifier_vector.first,old_ptr_power+1);
+			size_t i = old_ptr_power;
+			while(i<new_ptr_power) qualifier_vector.first[i++] = lvalue;
+			qualifier_vector.first[new_ptr_power] = '\0';
+			}
+		};
 	if (sizeof(unsigned char*)>old_ptr_power)
 		{
 		if (sizeof(unsigned char*)>new_ptr_power)
@@ -37,15 +52,8 @@
 				qualifier_vector.second[new_ptr_power] = '\0';
 				}
 			}
-		else{
-			unsigned char tmp[sizeof(unsigned char*)];
-			memcpy(tmp,qualifier_vector.second,old_ptr_power+1);
-			qualifier_vector.first = zaimoni::_new_buffer_nonNULL_throws<unsigned char>(new_ptr_power+1);
-			memcpy(qualifier_vector.first,tmp,old_ptr_power+1);
-			size_t i = old_ptr_power;
-			while(i<new_ptr_power) qualifier_vector.first[i++] = lvalue;
-			qualifier_vector.first[new_ptr_power] = '\0';
-			}
+		else
+			qualifier_vector.first = tmp_first;
 		}
 	else if (sizeof(unsigned char*)>new_ptr_power)
 		{
@@ -56,27 +64,30 @@
 		memcpy(qualifier_vector.second,tmp,new_ptr_power+1);
 		}
 	else{
-		if (!zaimoni::_resize(qualifier_vector.first,new_ptr_power+1)) throw std::bad_alloc();
 		if (shrinking)
-			memset(qualifier_vector.first+new_ptr_power+1,0,old_ptr_power-new_ptr_power);
+			ZAIMONI_PASSTHROUGH_ASSERT(zaimoni::_resize(qualifier_vector.first,new_ptr_power+1));
 		else{
-			size_t i = old_ptr_power;
-			while(i<new_ptr_power) qualifier_vector.first[i++] = lvalue;
-			qualifier_vector.first[new_ptr_power] = '\0';
+			free(qualifier_vector.first);
+			qualifier_vector.first = tmp_first;
 			}
 		}
 	pointer_power = _size;
 }
 
 // XXX properly operator= in C++, but type_spec has to be POD
+// ACID, throws std::bad_alloc on failure
 void type_spec::value_copy(const type_spec& src)
 {
+	{
+	type_spec tmp;
+	tmp.clear();
+	tmp.base_type_index = src.base_type_index;
+	tmp.set_static_array_size(src.static_array_size);
+	tmp.set_pointer_power(src.pointer_power);
 	destroy();
-	base_type_index = src.base_type_index;
-	static_array_size = src.static_array_size;
-	if (0<src.static_array_size) qualifier_vector.second[0] |= lvalue;
+	*this = tmp;
+	}
 
-	set_pointer_power(src.pointer_power);
 	const size_t new_ptr_power = pointer_power_after_array_decay();
 	if (sizeof(unsigned char*)<=new_ptr_power)
 		memmove(qualifier_vector.first,src.qualifier_vector.first,new_ptr_power+1);

Modified: trunk/type_spec.hpp
===================================================================
--- trunk/type_spec.hpp	2009-09-24 03:03:00 UTC (rev 256)
+++ trunk/type_spec.hpp	2009-09-24 20:54:14 UTC (rev 257)
@@ -42,8 +42,9 @@
 	bool decays_to_nonnull_pointer() const {return 0==pointer_power && 0<static_array_size;};
 
 	void set_static_array_size(size_t _size);
-	void set_pointer_power(size_t _size);
+	void set_pointer_power(size_t _size);	// ACID, throws std::bad_alloc on failure
 	void value_copy(const type_spec& src);	// XXX properly operator= in C++, but type_spec has to be POD
+											// ACID, throws std::bad_alloc on failure
 	bool dereference();
 	unsigned char& qualifier(size_t i) {return sizeof(unsigned char*)>pointer_power_after_array_decay() ? qualifier_vector.second[i] : qualifier_vector.first[i];};
 	template<size_t i> unsigned char& qualifier() {return sizeof(unsigned char*)>pointer_power_after_array_decay() ? qualifier_vector.second[i] : qualifier_vector.first[i];}



From zaimoni at mail.berlios.de  Fri Sep 25 06:37:45 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 25 Sep 2009 06:37:45 +0200
Subject: [Zcplusplus-commits] r258 - trunk
Message-ID: <200909250437.n8P4bjD7026876@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-25 06:37:35 +0200 (Fri, 25 Sep 2009)
New Revision: 258

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.hpp
   trunk/type_system.cpp
   trunk/type_system.hpp
Log:
recover from V0.0.0 design error: type_system isn't using the zaimoni::lex_flags data at all

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-09-24 20:54:14 UTC (rev 257)
+++ trunk/CSupport.cpp	2009-09-25 04:37:35 UTC (rev 258)
@@ -877,55 +877,55 @@
 
 /* reference arrays for instantiating type_system class with */
 /* typenames starting with $ are internal, as $ is not a legal C-source character */
-const POD_triple<const char* const,size_t,lex_flags> C_atomic_types[]
+const POD_pair<const char* const,size_t> C_atomic_types[]
 	=	{
-		DICT2_STRUCT("void",0),
-		DICT2_STRUCT("$not-void",0),
-		DICT2_STRUCT("_Bool",0),
-		DICT2_STRUCT("char",0),
-		DICT2_STRUCT("signed char",0),
-		DICT2_STRUCT("unsigned char",0),
-		DICT2_STRUCT("short",0),
-		DICT2_STRUCT("unsigned short",0),
-		DICT2_STRUCT("int",0),
-		DICT2_STRUCT("unsigned int",0),
-		DICT2_STRUCT("long",0),
-		DICT2_STRUCT("unsigned long",0),
-		DICT2_STRUCT("long long",0),
-		DICT2_STRUCT("unsigned long long",0),
-		DICT2_STRUCT("$integer-like",0),
-		DICT2_STRUCT("float",0),
-		DICT2_STRUCT("double",0),
-		DICT2_STRUCT("long double",0),
-		DICT2_STRUCT("float _Complex",0),		/* start C++ extension support: C99 _Complex in C++ (we can do this as _Complex is reserved to the implementation) */
-		DICT2_STRUCT("double _Complex",0),
-		DICT2_STRUCT("long double _Complex",0)
+		DICT_STRUCT("void"),
+		DICT_STRUCT("$not-void"),
+		DICT_STRUCT("_Bool"),
+		DICT_STRUCT("char"),
+		DICT_STRUCT("signed char"),
+		DICT_STRUCT("unsigned char"),
+		DICT_STRUCT("short"),
+		DICT_STRUCT("unsigned short"),
+		DICT_STRUCT("int"),
+		DICT_STRUCT("unsigned int"),
+		DICT_STRUCT("long"),
+		DICT_STRUCT("unsigned long"),
+		DICT_STRUCT("long long"),
+		DICT_STRUCT("unsigned long long"),
+		DICT_STRUCT("$integer-like"),
+		DICT_STRUCT("float"),
+		DICT_STRUCT("double"),
+		DICT_STRUCT("long double"),
+		DICT_STRUCT("float _Complex"),		/* start C++ extension support: C99 _Complex in C++ (we can do this as _Complex is reserved to the implementation) */
+		DICT_STRUCT("double _Complex"),
+		DICT_STRUCT("long double _Complex")
 		};
 
-const POD_triple<const char* const,size_t,lex_flags> CPP_atomic_types[]
+const POD_pair<const char* const,size_t> CPP_atomic_types[]
 	=	{
-		DICT2_STRUCT("void",0),
-		DICT2_STRUCT("$not-void",0),
-		DICT2_STRUCT("bool",0),
-		DICT2_STRUCT("char",0),
-		DICT2_STRUCT("signed char",0),
-		DICT2_STRUCT("unsigned char",0),
-		DICT2_STRUCT("short",0),
-		DICT2_STRUCT("unsigned short",0),
-		DICT2_STRUCT("int",0),
-		DICT2_STRUCT("unsigned int",0),
-		DICT2_STRUCT("long",0),
-		DICT2_STRUCT("unsigned long",0),
-		DICT2_STRUCT("long long",0),
-		DICT2_STRUCT("unsigned long long",0),
-		DICT2_STRUCT("$integer-like",0),
-		DICT2_STRUCT("float",0),
-		DICT2_STRUCT("double",0),
-		DICT2_STRUCT("long double",0),
-		DICT2_STRUCT("float _Complex",0),		/* start C++ extension support: C99 _Complex in C++ (we can do this as _Complex is reserved to the implementation) */
-		DICT2_STRUCT("double _Complex",0),
-		DICT2_STRUCT("long double _Complex",0),
-		DICT2_STRUCT("wchar_t",0)
+		DICT_STRUCT("void"),
+		DICT_STRUCT("$not-void"),
+		DICT_STRUCT("bool"),
+		DICT_STRUCT("char"),
+		DICT_STRUCT("signed char"),
+		DICT_STRUCT("unsigned char"),
+		DICT_STRUCT("short"),
+		DICT_STRUCT("unsigned short"),
+		DICT_STRUCT("int"),
+		DICT_STRUCT("unsigned int"),
+		DICT_STRUCT("long"),
+		DICT_STRUCT("unsigned long"),
+		DICT_STRUCT("long long"),
+		DICT_STRUCT("unsigned long long"),
+		DICT_STRUCT("$integer-like"),
+		DICT_STRUCT("float"),
+		DICT_STRUCT("double"),
+		DICT_STRUCT("long double"),
+		DICT_STRUCT("float _Complex"),		/* start C++ extension support: C99 _Complex in C++ (we can do this as _Complex is reserved to the implementation) */
+		DICT_STRUCT("double _Complex"),
+		DICT_STRUCT("long double _Complex"),
+		DICT_STRUCT("wchar_t")
 		};
 
 BOOST_STATIC_ASSERT(STATIC_SIZE(C_atomic_types)==C_TYPE_MAX);
@@ -3892,13 +3892,8 @@
 
 	if (!(C_TESTFLAG_INTEGER & src.index_tokens[0].flags)) return false;
 	C_PPIntCore tmp;
-#ifdef NDEBUG
-	C_PPIntCore::is(src.index_tokens[0].token.first,src.index_tokens[0].token.second,tmp);
-	convert_to(dest,tmp);
-#else
-	assert(C_PPIntCore::is(src.index_tokens[0].token.first,src.index_tokens[0].token.second,tmp));
-	assert(convert_to(dest,tmp));
-#endif
+	ZAIMONI_PASSTHROUGH_ASSERT(C_PPIntCore::is(src.index_tokens[0].token.first,src.index_tokens[0].token.second,tmp));
+	ZAIMONI_PASSTHROUGH_ASSERT(convert_to(dest,tmp));
 	return true;
 }
 
@@ -4023,11 +4018,7 @@
 			{
 			src.type_code.set_type(C_TYPE::INTEGERLIKE);
 			C_PPIntCore parse_tmp;
-#ifdef NDEBUG
-			C_PPIntCore::is(src.index_tokens[0].token.first,src.index_tokens[0].token.second,parse_tmp);
-#else
-			assert(C_PPIntCore::is(src.index_tokens[0].token.first,src.index_tokens[0].token.second,parse_tmp));
-#endif
+			ZAIMONI_PASSTHROUGH_ASSERT(C_PPIntCore::is(src.index_tokens[0].token.first,src.index_tokens[0].token.second,parse_tmp));
 			unsigned_fixed_int<VM_MAX_BIT_PLATFORM> tmp;
 			const unsigned char type_hint = parse_tmp.hinted_type;
 			const bool no_signed = 1==type_hint%2;
@@ -4585,11 +4576,7 @@
 		else if (converts_to_integerlike(src.data<0>()->type_code.base_type_index))
 			{
 			src.type_code.value_copy(src.data<1>()->type_code);
-#ifndef NDEBUG
-			assert(src.type_code.dereference());
-#else
-			src.type_code.dereference();
-#endif
+			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
 			}
 		else{	// not testable from preprocessor yet (need floating-point literals as extension)
 			src.flags |= parse_tree::INVALID;
@@ -4607,11 +4594,7 @@
 		if (converts_to_integerlike(src.data<1>()->type_code.base_type_index))
 			{
 			src.type_code.value_copy(src.data<0>()->type_code);
-#ifndef NDEBUG
-			assert(src.type_code.dereference());
-#else
-			src.type_code.dereference();
-#endif
+			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
 			}
 		else{	// autofails in C
 				// not testable from preprocessor yet (need floating-point literals, would be extension regardless)
@@ -8930,31 +8913,19 @@
 	case C_BASE_OCTAL:
 		{	// all-zeros is zero, ok with leading 0 prefix
 		C_PPOctalInteger test_oct;
-#ifdef NDEBUG
-		C_PPOctalInteger::is(x,x_len,test_oct);
-#else
-		assert(C_PPOctalInteger::is(x,x_len,test_oct));
-#endif
+		ZAIMONI_PASSTHROUGH_ASSERT(C_PPOctalInteger::is(x,x_len,test_oct));
 		return strspn(test_oct.ptr,"0") == test_oct.digit_span;
 		};
 	case C_BASE_DECIMAL:
 		{	// decimal is easy
 		C_PPDecimalInteger test_dec;
-#ifdef NDEBUG
-		C_PPDecimalInteger::is(x,x_len,test_dec);
-#else
-		assert(C_PPDecimalInteger::is(x,x_len,test_dec));
-#endif
+		ZAIMONI_PASSTHROUGH_ASSERT(C_PPDecimalInteger::is(x,x_len,test_dec));
 		return 1==test_dec.digit_span && '0'==test_dec.ptr[0];
 		};
 	case C_BASE_HEXADECIMAL:
 		{	// all-zeros is zero, but ignore the leading 0x prefix
 		C_PPHexInteger test_hex;
-#ifdef NDEBUG
-		C_PPHexInteger::is(x,x_len,test_hex);
-#else
-		assert(C_PPHexInteger::is(x,x_len,test_hex));
-#endif
+		ZAIMONI_PASSTHROUGH_ASSERT(C_PPHexInteger::is(x,x_len,test_hex));
 		return strspn(test_hex.ptr+2,"0")+2 == test_hex.digit_span;
 		};
 	}

Modified: trunk/CSupport.hpp
===================================================================
--- trunk/CSupport.hpp	2009-09-24 20:54:14 UTC (rev 257)
+++ trunk/CSupport.hpp	2009-09-25 04:37:35 UTC (rev 258)
@@ -80,7 +80,7 @@
 namespace zaimoni {
 
 class LangConf;
-template<class T1,class T2,class T3> struct POD_triple;
+template<class T1,class T2> struct POD_pair;
 
 // C preprocessor class has to know about this type
 struct PP_auxfunc
@@ -138,8 +138,8 @@
 
 extern zaimoni::LangConf* CLexer;			// C99
 extern zaimoni::LangConf* CPlusPlusLexer;	// C++0x
-extern const zaimoni::POD_triple<const char* const,size_t,zaimoni::lex_flags> C_atomic_types[];	// to help out the preprocessor, etc.
-extern const zaimoni::POD_triple<const char* const,size_t,zaimoni::lex_flags> CPP_atomic_types[];	// to help out the preprocessor, etc.
+extern const zaimoni::POD_pair<const char* const,size_t> C_atomic_types[];	// to help out the preprocessor, etc.
+extern const zaimoni::POD_pair<const char* const,size_t> CPP_atomic_types[];	// to help out the preprocessor, etc.
 extern const size_t C_int_priority[];
 
 #define C_TYPE_MAX 21

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2009-09-24 20:54:14 UTC (rev 257)
+++ trunk/type_system.cpp	2009-09-25 04:37:35 UTC (rev 258)
@@ -17,16 +17,6 @@
 	return 0;
 }
 
-type_system::type_data type_system::_get_flags(size_t id) const
-{
-	if (0==id) return 0;
-	if (core_types_size> --id)
-		return core_types[id].third;
-	if (dynamic_types.size() > (id -= core_types_size))
-		return dynamic_types[id].third;
-	return 0;
-}
-
 const char* type_system::_name(size_t id) const
 {
 	if (0==id) return "(?)";

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2009-09-24 20:54:14 UTC (rev 257)
+++ trunk/type_system.hpp	2009-09-25 04:37:35 UTC (rev 258)
@@ -4,7 +4,6 @@
 #ifndef TYPE_SYSTEM_HPP
 #define TYPE_SYSTEM_HPP 1
 
-#include "Zaimoni.STL/LexParse/std.h"
 #include "Zaimoni.STL/POD.hpp"
 #include "Zaimoni.STL/AutoPtr.hpp"
 #include "type_spec.hpp"
@@ -12,21 +11,20 @@
 class type_system
 {
 public:
-	typedef zaimoni::lex_flags type_data;
 	typedef size_t type_index;
 
-	const zaimoni::POD_triple<const char* const,size_t,zaimoni::lex_flags>* const core_types;
+	const zaimoni::POD_pair<const char* const,size_t>* const core_types;
 	const type_index* const int_priority;
 	const size_t core_types_size;
 	const size_t int_priority_size;
 private:
-	zaimoni::autovalarray_ptr<zaimoni::POD_triple<char*,size_t,zaimoni::lex_flags> > dynamic_types;
+	zaimoni::autovalarray_ptr<zaimoni::POD_pair<char*,size_t> > dynamic_types;
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> > > typedef_registry;
 	// uncopyable
 	type_system(const type_system& src);
 	void operator=(const type_system& src);
 public:
-	type_system(const zaimoni::POD_triple<const char* const,size_t,zaimoni::lex_flags>* _core_types,size_t _core_types_size,const type_index* _int_priority,size_t _int_priority_size)
+	type_system(const zaimoni::POD_pair<const char* const,size_t>* _core_types,size_t _core_types_size,const type_index* _int_priority,size_t _int_priority_size)
 	:	core_types((assert(NULL!=_core_types),_core_types)),
 		int_priority((assert(NULL!=_int_priority),_int_priority)),
 		core_types_size((assert(0<_core_types_size),_core_types_size)),
@@ -44,11 +42,6 @@
 		assert(NULL!=x && '\0'!= *x);
 		return _get_id(x,strlen(x));
 		}
-	type_data get_flags(type_index id) const
-		{
-		assert(core_types_size+dynamic_types.size()>=id);
-		return _get_flags(id);
-		}
 	const char* name(type_index id) const
 		{
 		assert(core_types_size+dynamic_types.size()>=id);
@@ -59,10 +52,6 @@
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* get_typedef(const char* const alias) const;
 private:
 	type_index _get_id(const char* const x,size_t x_len) const;
-	type_data _get_flags(size_t id) const;
 	const char* _name(type_index id) const;
 };
-
-
-
 #endif



From zaimoni at mail.berlios.de  Fri Sep 25 20:42:13 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 25 Sep 2009 20:42:13 +0200
Subject: [Zcplusplus-commits] r259 - trunk/Zaimoni.STL
Message-ID: <200909251842.n8PIgDM3025833@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-25 20:42:09 +0200 (Fri, 25 Sep 2009)
New Revision: 259

Modified:
   trunk/Zaimoni.STL/AutoPtr.hpp
Log:
maintianability adjustments, new class autovalarray_ptr_throws

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2009-09-25 04:37:35 UTC (rev 258)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2009-09-25 18:42:09 UTC (rev 259)
@@ -63,7 +63,7 @@
 	const autodel_ptr& operator=(T* src) {_meta_auto_ptr<T>::operator=(src); return *this;};
 	const autodel_ptr& operator=(autodel_ptr& src) {reset(src._ptr); return *this;};
 
-	friend void zaimoni::swap(autodel_ptr& LHS, autodel_ptr& RHS) {std::swap(LHS._ptr,RHS._ptr);};
+	friend void zaimoni::swap(autodel_ptr& lhs, autodel_ptr& rhs) {std::swap(lhs._ptr,rhs._ptr);};
 };
 
 template<typename T>
@@ -83,7 +83,7 @@
 	const autoval_ptr& operator=(T* src) {_meta_auto_ptr<T>::operator=(src); return *this;};
 	const autoval_ptr& operator=(const autoval_ptr& src) {_meta_auto_ptr<T>::operator=(src); return *this;};
 
-	friend void zaimoni::swap(autoval_ptr& LHS, autoval_ptr& RHS) {std::swap(LHS._ptr,RHS._ptr);};
+	friend void zaimoni::swap(autoval_ptr& lhs, autoval_ptr& rhs) {std::swap(lhs._ptr,rhs._ptr);};
 };
 
 template<typename T>
@@ -91,10 +91,18 @@
 {
 };
 
+template<class Derived,class T> struct c_var_array_CRTP;
+
+template<class Derived,class T>
+bool
+operator==(const c_var_array_CRTP<Derived,T>& lhs, const c_var_array_CRTP<Derived,T>& rhs);
+
 // requires: _ptr
 template<class Derived,class T>
 struct c_var_array_CRTP : public c_array_CRTP<c_var_array_CRTP<Derived,T>, T>
 {
+	friend bool operator==<>(const c_var_array_CRTP& lhs, const c_var_array_CRTP& rhs);
+
 	// other support
 	void OverwriteAndNULL(T*& Target) {Target = static_cast<Derived*>(this)->_ptr; static_cast<Derived*>(this)->_ptr = NULL;}
 #ifndef ZAIMONI_FORCE_ISO
@@ -132,6 +140,13 @@
 	void rangecheck(size_t i) const { if (i>=size()) FATAL("out-of-bounds array access"); };
 
 	void swap(c_var_array_CRTP& RHS) {std::swap(static_cast<Derived*>(this)->_ptr,static_cast<Derived&>(RHS)._ptr);};
+
+	// Perl grep
+	template<typename U> void destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
+	template<typename U> void destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
+
+	// throwing resize
+	void resize(size_t n) {if (!static_cast<Derived*>(this)->Resize(n)) throw std::bad_alloc();};	
 };
 
 template<typename T>
@@ -154,8 +169,8 @@
 #else
 	explicit weakautoarray_ptr() : _ptr(NULL),_size(0) {};
 	explicit weakautoarray_ptr(T*& src,size_t src_size) : _ptr(src),_size(src_size) {src = NULL;};
-	explicit weakautoarray_ptr(size_t n) : _ptr(_new_buffer<T>(n)),_size(0) {};
-	explicit weakautoarray_ptr(weakautoarray_ptr& src) : _ptr(src._ptr),_size(0) {src._ptr=NULL; src._size=0;};
+	explicit weakautoarray_ptr(size_t n) : _ptr(_new_buffer<T>(n)),_size(n) {};
+	explicit weakautoarray_ptr(weakautoarray_ptr& src) : _ptr(src._ptr),_size(src._size) {src._ptr=NULL; src._size=0;};
 #endif
 	~weakautoarray_ptr() {_weak_flush(_ptr);};
 
@@ -163,8 +178,6 @@
 	const weakautoarray_ptr& operator=(T* src);
 #endif
 	const weakautoarray_ptr& operator=(weakautoarray_ptr& src);
-	bool operator==(const weakautoarray_ptr& src) const;
-	bool operator!=(const weakautoarray_ptr& src) const {return !((*this)==src);};
 	template<typename U> bool value_copy_of(const U& src);	// STL interfaces required of U: size(),data()
 	void reset() {_weak_flush(_ptr); this->NULLPtr();};
 
@@ -179,13 +192,10 @@
 	template<typename U,typename op> bool grep(const U& src,op Predicate);
 	template<typename U,typename op> bool invgrep(const U& src,op Predicate);
 
-	template<typename U> void destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
-	template<typename U> void destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
-
 	// erase all elements
 	void clear() {_weak_flush(_ptr); this->NULLPtr();};
 
-	friend void zaimoni::swap(weakautoarray_ptr& LHS, weakautoarray_ptr& RHS) {LHS.swap(RHS);};
+	friend void zaimoni::swap(weakautoarray_ptr& lhs, weakautoarray_ptr& rhs) {lhs.swap(rhs);};
 };
 
 template<typename T>
@@ -201,7 +211,8 @@
 #ifndef ZAIMONI_FORCE_ISO
 	explicit _meta_autoarray_ptr() : _ptr(NULL) {};
 	explicit _meta_autoarray_ptr(T*& src) : _ptr(src) {src = NULL;};
-	explicit _meta_autoarray_ptr(size_t n) : _ptr(_new_buffer<T>(n)) {};
+	explicit _meta_autoarray_ptr(size_t n) : _ptr(n ? _new_buffer_nonNULL_throws<T>(n) : NULL) {};
+	explicit _meta_autoarray_ptr(const std::nothrow_t& tracer, size_t n) : _ptr(_new_buffer<T>(n)) {};
 	explicit _meta_autoarray_ptr(const _meta_autoarray_ptr& src) : _ptr(NULL) {*this=src;};
 #else
 	explicit _meta_autoarray_ptr() : _ptr(NULL),_size(0) {};
@@ -215,7 +226,6 @@
 	void operator=(T* src);
 #endif
 	void operator=(const _meta_autoarray_ptr& src);
-	bool operator==(const _meta_autoarray_ptr& src) const;
 public:
 	typedef bool UnaryPredicate(const T&);
 
@@ -249,15 +259,7 @@
 	// these two assume T has valid * operator
 	template<typename U> bool grep(UnaryPredicate* Predicate,_meta_autoarray_ptr<U*>& Target) const;
 	template<typename U> bool invgrep(UnaryPredicate* Predicate,_meta_autoarray_ptr<U*>& Target) const;
-	template<typename U> void destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
-	template<typename U> void destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type));
 
-	// throwing resize
-#ifndef ZAIMONI_FORCE_ISO
-	void resize(size_type n) {if (!_resize(_ptr,n)) throw std::bad_alloc();};
-#else
-	void resize(size_type n) {if (!_resize(_ptr,_size,n)) throw std::bad_alloc();};
-#endif
 	// erase all elements
 	void clear() {_flush(_ptr); this->NULLPtr();};
 };
@@ -270,17 +272,15 @@
 
 	explicit autoarray_ptr() {};
 	explicit autoarray_ptr(T*& src) : _meta_autoarray_ptr<T>(src) {};
-	explicit autoarray_ptr(size_t n) : _meta_autoarray_ptr<T>(n) {};
+	explicit autoarray_ptr(size_t n) : _meta_autoarray_ptr<T>(std::nothrow,n) {};
 	explicit autoarray_ptr(autoarray_ptr& src) : _meta_autoarray_ptr<T>(src._ptr) {};
 //	~autoarray_ptr();	// default OK
 
 	const autoarray_ptr& operator=(T* src) {_meta_autoarray_ptr<T>::operator=(src); return *this;};
 	const autoarray_ptr& operator=(autoarray_ptr& src) {reset(src._ptr); return *this;};
-	bool operator==(const autoarray_ptr& src) const {return _meta_autoarray_ptr<T>::operator==(src);};
-	bool operator!=(const autoarray_ptr& src) const {return !((*this)==src);};
 
 	// swaps
-	friend void zaimoni::swap(autoarray_ptr<T>& LHS, autoarray_ptr<T>& RHS) {LHS.swap(RHS);};
+	friend void zaimoni::swap(autoarray_ptr<T>& lhs, autoarray_ptr<T>& rhs) {lhs.swap(rhs);};
 };
 
 template<typename T>
@@ -300,17 +300,15 @@
 #else
 	explicit autovalarray_ptr(T*& src,size_t src_size) : _meta_autoarray_ptr<T>(src,src_size) {};
 #endif
-	explicit autovalarray_ptr(size_t n) : _meta_autoarray_ptr<T>(n) {};
+	explicit autovalarray_ptr(size_t n) : _meta_autoarray_ptr<T>(std::nothrow,n) {};
 	autovalarray_ptr(const autovalarray_ptr& src) : _meta_autoarray_ptr<T>(src) {};
 //	~autovalarray_ptr();	// default OK
 
 	const autovalarray_ptr& operator=(T* src) {_meta_autoarray_ptr<T>::operator=(src); return *this;};
 	const autovalarray_ptr& operator=(const autovalarray_ptr& src) {_meta_autoarray_ptr<T>::operator=(src); return *this;};
-	bool operator==(const autovalarray_ptr& src) const {return _meta_autoarray_ptr<T>::operator==(src);};
-	bool operator!=(const autovalarray_ptr& src) const {return !((*this)==src);};
 
 	// swaps
-	friend void zaimoni::swap(autovalarray_ptr<T>& LHS, autovalarray_ptr<T>& RHS) {LHS.swap(RHS);};
+	friend void zaimoni::swap(autovalarray_ptr<T>& lhs, autovalarray_ptr<T>& rhs) {lhs.swap(rhs);};
 };
 
 template<typename T>
@@ -319,6 +317,34 @@
 };
 
 template<typename T>
+class autovalarray_ptr_throws : public _meta_autoarray_ptr<T>
+{
+public:
+	ZAIMONI_STL_TYPE_GLUE_ARRAY(T);
+
+	explicit autovalarray_ptr_throws() {};
+#ifndef ZAIMONI_FORCE_ISO
+	explicit autovalarray_ptr_throws(T*& src) : _meta_autoarray_ptr<T>(src) {};
+#else
+	explicit autovalarray_ptr_throws(T*& src,size_t src_size) : _meta_autoarray_ptr<T>(src,src_size) {};
+#endif
+	explicit autovalarray_ptr_throws(size_t n) : _meta_autoarray_ptr<T>(n) {};
+	autovalarray_ptr_throws(const autovalarray_ptr_throws& src) : _meta_autoarray_ptr<T>(src) {};
+//	~autovalarray_ptr_throw();	// default OK
+
+	const autovalarray_ptr_throws& operator=(T* src) {_meta_autoarray_ptr<T>::operator=(src); return *this;};
+	const autovalarray_ptr_throws& operator=(const autovalarray_ptr_throws& src) {_meta_autoarray_ptr<T>::operator=(src); return *this;};
+
+	// swaps
+	friend void zaimoni::swap(autovalarray_ptr_throws<T>& lhs, autovalarray_ptr_throws<T>& rhs) {lhs.swap(rhs);};
+};
+
+template<typename T>
+struct has_MoveInto<autovalarray_ptr_throws<T> > : public boost::true_type
+{
+};
+
+template<typename T>
 void
 _meta_auto_ptr<T>::operator=(T* src)
 {
@@ -392,25 +418,15 @@
 }
 
 template<typename T>
-bool
-weakautoarray_ptr<T>::operator==(const weakautoarray_ptr& src) const
-{
-	const size_t TargetSize = src.size();
-	if (TargetSize!=this->size()) return false;
-	if (0==TargetSize) return true;
-	return _value_vector_equal(_ptr,src._ptr,TargetSize);
-}
-
-template<typename T>
 template<typename U>
 bool
 weakautoarray_ptr<T>::value_copy_of(const U& src)
 {
-	const size_t TargetSize = src.size();
-	bool Result = Resize(TargetSize);
-	if (0<TargetSize && Result)
-		_copy_buffer(this->c_array(),src.data(),TargetSize);
-	return Result;
+	const size_t ub = src.size();
+	if (!Resize(ub)) return false;
+	if (0<ub)
+		_copy_buffer(this->c_array(),src.data(),ub);
+	return true;
 }
 
 // Perl grep
@@ -478,58 +494,21 @@
 	return true;
 }
 
-template<typename T>
-template<typename U>
-void
-weakautoarray_ptr<T>::destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type))
-{
-	size_t Idx = this->size();
-	do	if (!equivalence(x,_ptr[--Idx]))
-			{
-			size_t Idx2 = Idx;
-			while(0<Idx2 && !equivalence(x,_ptr[Idx2-1])) --Idx2;
-			if (Idx2<Idx)
-				{
-				DeleteNSlotsAt(Idx2,(Idx-Idx2)+1);
-				Idx = Idx2;
-				}
-			else
-				DeleteIdx(Idx);
-			}
-	while(0<Idx);
-}
-
-template<typename T>
-template<typename U>
-void
-weakautoarray_ptr<T>::destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type))
-{
-	size_t Idx = this->size();
-	do	if (equivalence(x,_ptr[--Idx]))
-			{
-			size_t Idx2 = Idx;
-			while(0<Idx2 && equivalence(x,_ptr[Idx2-1])) --Idx2;
-			if (Idx2<Idx)
-				{
-				DeleteNSlotsAt(Idx2,(Idx-Idx2)+1);
-				Idx = Idx2;
-				}
-			else
-				DeleteIdx(Idx);
-			}
-	while(0<Idx);
-}
-
-template<typename T>
+template<class Derived,class T>
 bool
-_meta_autoarray_ptr<T>::operator==(const _meta_autoarray_ptr& src) const
+operator==(const c_var_array_CRTP<Derived,T>& lhs, const c_var_array_CRTP<Derived,T>& rhs)
 {
-	const size_t TargetSize = src.size();
-	if (TargetSize!=this->size()) return false;
-	if (0==TargetSize) return true;
-	return _value_vector_equal(_ptr,src._ptr,TargetSize);
+	const size_t ub = rhs.size();
+	if (ub!=lhs.size()) return false;
+	if (0==ub) return true;
+	return _value_vector_equal(lhs._ptr,rhs._ptr,ub);
 }
 
+template<class Derived,class T>
+inline bool
+operator!=(const c_var_array_CRTP<Derived,T>& lhs, const c_var_array_CRTP<Derived,T>& rhs)
+{	return !(lhs==rhs); }
+
 #ifndef ZAIMONI_FORCE_ISO
 template<typename T>
 void
@@ -551,7 +530,7 @@
 	if (0>=TargetSize)
 		reset();
 	else{
-		resize(TargetSize);
+		this->resize(TargetSize);
 		_value_copy_buffer(this->c_array(),src.data(),TargetSize);
 		};
 }
@@ -561,17 +540,17 @@
 bool
 _meta_autoarray_ptr<T>::value_copy_of(const U& src)
 {
-	const size_t TargetSize = src.size();
-	bool Result = Resize(TargetSize);
-	if (0<TargetSize && Result)
+	const size_t ub = src.size();
+	if (!Resize(ub)) return false;
+	if (0<ub)
 		try	{
-			_value_copy_buffer(this->c_array(),src.data(),TargetSize);
+			_value_copy_buffer(this->c_array(),src.data(),ub);
 			}
 		catch(const std::bad_alloc&)
 			{
 			return false;
 			}
-	return Result;
+	return true;
 }
 
 template<typename T>
@@ -661,46 +640,46 @@
 	return true;
 }
 
-template<typename T>
+template<class Derived,class T>
 template<typename U>
 void
-_meta_autoarray_ptr<T>::destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type))
+c_var_array_CRTP<Derived,T>::destructive_grep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type))
 {
-	size_t Idx = this->size();
-	do	if (!equivalence(x,_ptr[--Idx]))
+	size_t i = this->size();
+	do	if (!equivalence(x,static_cast<Derived*>(this)->_ptr[--i]))
 			{
-			size_t Idx2 = Idx;
-			while(0<Idx2 && !equivalence(x,_ptr[Idx2-1])) --Idx2;
-			if (Idx2<Idx)
+			size_t j = i;
+			while(0<j && !equivalence(x,static_cast<Derived*>(this)->_ptr[j-1])) --j;
+			if (j<i)
 				{
-				DeleteNSlotsAt(Idx2,(Idx-Idx2)+1);
-				Idx = Idx2;
+				static_cast<Derived*>(this)->DeleteNSlotsAt(j,(i-j)+1);
+				i = j;
 				}
 			else
-				DeleteIdx(Idx);
+				static_cast<Derived*>(this)->DeleteIdx(i);
 			}
-	while(0<Idx);
+	while(0<i);
 }
 
-template<typename T>
+template<class Derived,class T>
 template<typename U>
 void
-_meta_autoarray_ptr<T>::destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type))
+c_var_array_CRTP<Derived,T>::destructive_invgrep(U& x,bool (&equivalence)(typename boost::call_traits<U>::param_type,typename boost::call_traits<T>::param_type))
 {
-	size_t Idx = this->size();
-	do	if (equivalence(x,_ptr[--Idx]))
+	size_t i = this->size();
+	do	if (equivalence(x,static_cast<Derived*>(this)->_ptr[--i]))
 			{
-			size_t Idx2 = Idx;
-			while(0<Idx2 && equivalence(x,_ptr[Idx2-1])) --Idx2;
-			if (Idx2<Idx)
+			size_t j = i;
+			while(0<j && equivalence(x,static_cast<Derived*>(this)->_ptr[j-1])) --j;
+			if (j<i)
 				{
-				DeleteNSlotsAt(Idx2,(Idx-Idx2)+1);
-				Idx = Idx2;
+				static_cast<Derived*>(this)->DeleteNSlotsAt(j,(i-j)+1);
+				i = j;
 				}
 			else
-				DeleteIdx(Idx);
+				static_cast<Derived*>(this)->DeleteIdx(i);
 			}
-	while(0<Idx);
+	while(0<i);
 }
 
 // Resize won't compile without this [CSVTable.cxx]



From zaimoni at mail.berlios.de  Sat Sep 26 02:39:02 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 26 Sep 2009 02:39:02 +0200
Subject: [Zcplusplus-commits] r260 - trunk/Zaimoni.STL
Message-ID: <200909260039.n8Q0d2ut016314@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-26 02:38:59 +0200 (Sat, 26 Sep 2009)
New Revision: 260

Modified:
   trunk/Zaimoni.STL/AutoPtr.hpp
Log:
full choice between value and std::auto_ptr semantics in AutoPtr.hpp

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2009-09-25 18:42:09 UTC (rev 259)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2009-09-26 00:38:59 UTC (rev 260)
@@ -150,34 +150,34 @@
 };
 
 template<typename T>
-class weakautoarray_ptr : public c_var_array_CRTP<weakautoarray_ptr<T>, T>
+class _meta_weakautoarray_ptr : public c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>
 {
 private:
-	friend class c_var_array_CRTP<weakautoarray_ptr<T>, T>;
+	friend class c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>;
 	T* _ptr;
 #ifdef ZAIMONI_FORCE_ISO
 	size_t _size;
 #endif
 public:
-	ZAIMONI_STL_TYPE_GLUE_ARRAY(T);
-
 #ifndef ZAIMONI_FORCE_ISO
-	explicit weakautoarray_ptr() : _ptr(NULL) {};
-	explicit weakautoarray_ptr(T*& src) : _ptr(src) {src = NULL;};
-	explicit weakautoarray_ptr(size_t n) : _ptr(_new_buffer<T>(n)) {};
-	explicit weakautoarray_ptr(weakautoarray_ptr& src) : _ptr(src._ptr) {src._ptr=NULL;};
+	explicit _meta_weakautoarray_ptr() : _ptr(NULL) {};
+	explicit _meta_weakautoarray_ptr(T*& src) : _ptr(src) {src = NULL;};
+	explicit _meta_weakautoarray_ptr(size_t n) : _ptr(n ? _new_buffer_nonNULL_throws<T>(n) : NULL) {};
+	explicit _meta_weakautoarray_ptr(const std::nothrow_t& tracer, size_t n) : _ptr(_new_buffer<T>(n)) {};
+	explicit _meta_weakautoarray_ptr(_meta_weakautoarray_ptr& src) : _ptr(src._ptr) {src._ptr=NULL;};
 #else
-	explicit weakautoarray_ptr() : _ptr(NULL),_size(0) {};
-	explicit weakautoarray_ptr(T*& src,size_t src_size) : _ptr(src),_size(src_size) {src = NULL;};
-	explicit weakautoarray_ptr(size_t n) : _ptr(_new_buffer<T>(n)),_size(n) {};
-	explicit weakautoarray_ptr(weakautoarray_ptr& src) : _ptr(src._ptr),_size(src._size) {src._ptr=NULL; src._size=0;};
+	explicit _meta_weakautoarray_ptr() : _ptr(NULL),_size(0) {};
+	explicit _meta_weakautoarray_ptr(T*& src,size_t src_size) : _ptr(src),_size(src_size) {src = NULL;};
+	explicit _meta_weakautoarray_ptr(size_t n) : _ptr(n ? _new_buffer_nonNULL_throws<T>(n) : NULL),_size(n) {};
+	explicit _meta_weakautoarray_ptr(const std::nothrow_t& tracer, size_t n) : _ptr(_new_buffer<T>(n)),_size(n) {};
+	explicit _meta_weakautoarray_ptr(_meta_weakautoarray_ptr& src) : _ptr(src._ptr),_size(src._size) {src._ptr=NULL; src._size=0;};
 #endif
-	~weakautoarray_ptr() {_weak_flush(_ptr);};
+	~_meta_weakautoarray_ptr() {_weak_flush(_ptr);};
 
 #ifndef ZAIMONI_FORCE_ISO
-	const weakautoarray_ptr& operator=(T* src);
+	void operator=(T* src);
 #endif
-	const weakautoarray_ptr& operator=(weakautoarray_ptr& src);
+	void operator=(const _meta_weakautoarray_ptr& src);
 	template<typename U> bool value_copy_of(const U& src);	// STL interfaces required of U: size(),data()
 	void reset() {_weak_flush(_ptr); this->NULLPtr();};
 
@@ -194,11 +194,49 @@
 
 	// erase all elements
 	void clear() {_weak_flush(_ptr); this->NULLPtr();};
+};
 
+template<typename T>
+class weakautoarray_ptr : public _meta_weakautoarray_ptr<T>
+{
+public:
+	ZAIMONI_STL_TYPE_GLUE_ARRAY(T);
+
+	explicit weakautoarray_ptr() {};
+	explicit weakautoarray_ptr(T*& src) : _meta_weakautoarray_ptr<T>(src) {};
+	explicit weakautoarray_ptr(size_t n) : _meta_weakautoarray_ptr<T>(std::nothrow,n) {};
+	explicit weakautoarray_ptr(weakautoarray_ptr& src) : _meta_weakautoarray_ptr<T>(src._ptr) {};
+//	~weakautoarray_ptr();	// default OK
+
+#ifndef ZAIMONI_FORCE_ISO
+	const weakautoarray_ptr& operator=(T* src) {_meta_weakautoarray_ptr<T>::operator=(src); return *this;};
+#endif
+	const weakautoarray_ptr& operator=(weakautoarray_ptr& src) {reset(src._ptr); return *this;};
+
 	friend void zaimoni::swap(weakautoarray_ptr& lhs, weakautoarray_ptr& rhs) {lhs.swap(rhs);};
 };
 
 template<typename T>
+class weakautoarray_ptr_throws : public _meta_weakautoarray_ptr<T>
+{
+public:
+	ZAIMONI_STL_TYPE_GLUE_ARRAY(T);
+
+	explicit weakautoarray_ptr_throws() {};
+	explicit weakautoarray_ptr_throws(T*& src) : _meta_weakautoarray_ptr<T>(src) {};
+	explicit weakautoarray_ptr_throws(size_t n) : _meta_weakautoarray_ptr<T>(n) {};
+	explicit weakautoarray_ptr_throws(weakautoarray_ptr_throws& src) : _meta_weakautoarray_ptr<T>(src._ptr) {};
+//	~weakautoarray_ptr_throws();	// default OK
+
+#ifndef ZAIMONI_FORCE_ISO
+	const weakautoarray_ptr_throws& operator=(T* src) {_meta_weakautoarray_ptr<T>::operator=(src); return *this;};
+#endif
+	const weakautoarray_ptr_throws& operator=(weakautoarray_ptr_throws& src) {_meta_weakautoarray_ptr<T>::operator=(src); return *this;};
+
+	friend void zaimoni::swap(weakautoarray_ptr_throws& lhs, weakautoarray_ptr_throws& rhs) {lhs.swap(rhs);};
+};
+
+template<typename T>
 class _meta_autoarray_ptr : public c_var_array_CRTP<_meta_autoarray_ptr<T>, T>
 {
 protected:
@@ -217,7 +255,8 @@
 #else
 	explicit _meta_autoarray_ptr() : _ptr(NULL),_size(0) {};
 	explicit _meta_autoarray_ptr(T*& src,size_t src_size) : _ptr(src),_size(src_size) {src = NULL;};
-	explicit _meta_autoarray_ptr(size_t n) : _ptr(_new_buffer<T>(n)),_size(n) {};
+	explicit _meta_autoarray_ptr(size_t n) : _ptr(_new_buffer<T>(n ? _new_buffer_nonNULL_throws<T>(n) : NULL)),_size(n) {};
+	explicit _meta_autoarray_ptr(const std::nothrow_t& tracer, size_t n) : _ptr(_new_buffer<T>(n)),_size(n) {};
 	explicit _meta_autoarray_ptr(const _meta_autoarray_ptr& src) : _ptr(NULL),_size(0) {*this=src;};
 #endif
 	~_meta_autoarray_ptr() {_flush(_ptr);};
@@ -384,43 +423,34 @@
 
 #ifndef ZAIMONI_FORCE_ISO
 template<typename T>
-const weakautoarray_ptr<T>&
-weakautoarray_ptr<T>::operator=(T* src)
+void
+_meta_weakautoarray_ptr<T>::operator=(T* src)
 {
 	if (_ptr!=src)
 		{
 		_weak_flush(_ptr);
 		_ptr = src;
 		}
-	return *this;
 }
 #endif
 
 template<typename T>
-const weakautoarray_ptr<T>&
-weakautoarray_ptr<T>::operator=(weakautoarray_ptr& src)
+void
+_meta_weakautoarray_ptr<T>::operator=(const _meta_weakautoarray_ptr<T>& src)
 {	// this convolution handles a recursion issue
-	if (_ptr!=src._ptr)
-		{
-		T* TmpPtr = src._ptr;
-#ifdef ZAIMONI_FORCE_ISO
-		_size = src._size;
-#endif
-		src.NULLPtr();
-		_weak_flush(_ptr);
-		_ptr = TmpPtr;
-		}
-	else if (&this->_ptr!=&src._ptr)
-		{
-		src.NULLPtr();
-		}
-	return *this;
+	const size_t ub = src.size();
+	if (0>=ub)
+		reset();
+	else{
+		this->resize(ub);
+		_copy_buffer(this->c_array(),src.data(),ub);
+		};
 }
 
 template<typename T>
 template<typename U>
 bool
-weakautoarray_ptr<T>::value_copy_of(const U& src)
+_meta_weakautoarray_ptr<T>::value_copy_of(const U& src)
 {
 	const size_t ub = src.size();
 	if (!Resize(ub)) return false;
@@ -433,7 +463,7 @@
 template<typename T>
 template<typename U,typename op>
 bool
-weakautoarray_ptr<T>::grep(const U& src,op Predicate)
+_meta_weakautoarray_ptr<T>::grep(const U& src,op Predicate)
 {
 	if (src.empty())
 		{
@@ -465,7 +495,7 @@
 template<typename T>
 template<typename U,typename op>
 bool
-weakautoarray_ptr<T>::invgrep(const U& src,op Predicate)
+_meta_weakautoarray_ptr<T>::invgrep(const U& src,op Predicate)
 {
 	if (src.empty())
 		{
@@ -526,12 +556,12 @@
 void
 _meta_autoarray_ptr<T>::operator=(const _meta_autoarray_ptr& src)
 {
-	const size_t TargetSize = src.size();
-	if (0>=TargetSize)
+	const size_t ub = src.size();
+	if (0>=ub)
 		reset();
 	else{
-		this->resize(TargetSize);
-		_value_copy_buffer(this->c_array(),src.data(),TargetSize);
+		this->resize(ub);
+		_value_copy_buffer(this->c_array(),src.data(),ub);
 		};
 }
 



From zaimoni at mail.berlios.de  Sun Sep 27 01:14:19 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 27 Sep 2009 01:14:19 +0200
Subject: [Zcplusplus-commits] r261 - in trunk: . Zaimoni.STL
Message-ID: <200909262314.n8QNEJAG023344@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-27 01:14:00 +0200 (Sun, 27 Sep 2009)
New Revision: 261

Modified:
   trunk/CSupport.cpp
   trunk/ParseTree.cpp
   trunk/Zaimoni.STL/flat_alg.h
   trunk/type_spec.cpp
   trunk/type_spec.hpp
Log:
convert type_spec::value_copy to a free function; adjust binary-operator autotransform_n template to allow compiling

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-09-26 00:38:59 UTC (rev 260)
+++ trunk/CSupport.cpp	2009-09-26 23:14:00 UTC (rev 261)
@@ -4438,7 +4438,7 @@
 				src.flags &= parse_tree::RESERVED_MASK;	// just in case
 				src.flags |= PARSE_PRIMARY_EXPRESSION;
 				src.flags |= (PARSE_PAREN_PRIMARY_PASSTHROUGH & src.data<0>()->flags);
-				src.type_code.value_copy(src.data<0>()->type_code);
+				value_copy(src.type_code,src.data<0>()->type_code);
 				return true;
 				}
 			};
@@ -4575,7 +4575,7 @@
 			}
 		else if (converts_to_integerlike(src.data<0>()->type_code.base_type_index))
 			{
-			src.type_code.value_copy(src.data<1>()->type_code);
+			value_copy(src.type_code,src.data<1>()->type_code);
 			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
 			}
 		else{	// not testable from preprocessor yet (need floating-point literals as extension)
@@ -4593,7 +4593,7 @@
 		{
 		if (converts_to_integerlike(src.data<1>()->type_code.base_type_index))
 			{
-			src.type_code.value_copy(src.data<0>()->type_code);
+			value_copy(src.type_code,src.data<0>()->type_code);
 			ZAIMONI_PASSTHROUGH_ASSERT(src.type_code.dereference());
 			}
 		else{	// autofails in C
@@ -5029,7 +5029,7 @@
 		if (0<src.data<2>()->type_code.pointer_power_after_array_decay())
 			// C++98 5.3.1p6: pointer type allowed for unary +, not for unary - (C99 errors)
 			//! \test default/Pass_if_control27.hpp
-			src.type_code.value_copy(src.data<2>()->type_code);
+			value_copy(src.type_code,src.data<2>()->type_code);
 
 		if 		(is_C99_unary_operator_expression<'+'>(*src.data<2>()))
 			eval_unary_plus(*src.c_array<2>(),types);
@@ -5113,7 +5113,7 @@
 	//! \todo: handle *& identity when we have &
 	//! \todo multidimensional array target
 	//! \todo cv-qualified pointer target
-	src.type_code.value_copy(src.data<2>()->type_code);
+	value_copy(src.type_code,src.data<2>()->type_code);
 	// handle lvalueness in indirection type building and/or the dereference stage
 	if (!src.type_code.dereference())
 		//! \test default/Error_if_control24.hpp, default/Error_if_control24.h
@@ -9552,7 +9552,7 @@
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(src);
 	if (NULL!=tmp)
 		{	//! \todo C++: check for access control if source ends up being a class or struct
-		dest.value_copy(tmp->first);
+		value_copy(dest,tmp->first);
 		return true;
 		}
 	return false;
@@ -9609,7 +9609,7 @@
 		if (base_type.base_type_index) return false;
 		if (PARSE_PRIMARY_TYPE & x.flags)
 			{
-			base_type.value_copy(x.type_code);
+			value_copy(base_type,x.type_code);
 			return true;
 			}
 		// handle typedefs
@@ -9677,7 +9677,7 @@
 		}
 	void fixup_type() { base_type.qualifier<0>() |= ((C99_CPP0X_DECLSPEC_CONST | C99_CPP0X_DECLSPEC_VOLATILE) & flags); };
 	uintmax_t get_flags() const {return flags;};
-	void value_copy_type(type_spec& dest) const {dest.value_copy(base_type);};
+	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
 };
 
 bool CPP_ok_for_toplevel_qualified_name(const parse_tree& x)
@@ -9789,7 +9789,7 @@
 		if (base_type.base_type_index) return false;
 		if (PARSE_PRIMARY_TYPE & x.data<0>()[i].flags)
 			{
-			base_type.value_copy(x.data<0>()[i].type_code);
+			value_copy(base_type,x.data<0>()[i].type_code);
 			return true;
 			}
 		{	// handle typedefs
@@ -9825,7 +9825,7 @@
 				if (NULL!=tmp)
 					{	//! \todo check for access-control if source is a class or struct
 					free(tmp2);
-					base_type.value_copy(tmp->first);
+					value_copy(base_type,tmp->first);
 					return true;
 					};
 				size_t namespace_break_stack_size = count_disjoint_substring_instances(active_namespace,"::");
@@ -9845,7 +9845,7 @@
 							{	//! \todo check for access-control if source is a class or struct
 							free(namespace_break_stack);
 							free(tmp2);
-							base_type.value_copy(tmp->first);
+							value_copy(base_type,tmp->first);
 							return true;
 							};
 						}
@@ -9955,7 +9955,7 @@
 		};
 	void fixup_type() { base_type.qualifier<0>() |= ((C99_CPP0X_DECLSPEC_CONST | C99_CPP0X_DECLSPEC_VOLATILE) & flags); };
 	uintmax_t get_flags() const {return flags;};
-	void value_copy_type(type_spec& dest) const {dest.value_copy(base_type);};
+	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
 };
 
 size_t C99_init_declarator_scanner(const parse_tree& x, size_t i,type_spec& target_type, size_t& initdecl_identifier_idx)
@@ -10063,7 +10063,7 @@
 				INC_INFORM(ERR_STR);
 				_fatal("insufficient RAM to parse static assertion");
 				};
-			zaimoni::autotransform_n(parsetree.c_array<0>(),src.data<0>()[i+1].data<0>(),k,value_copy);
+			zaimoni::autotransform_n<void (*)(parse_tree&,const parse_tree&)>(parsetree.c_array<0>(),src.data<0>()[i+1].data<0>(),k,value_copy);
 			}
 			// init above correctly
 			// snip from Condense
@@ -10435,7 +10435,7 @@
 				INC_INFORM(ERR_STR);
 				_fatal("insufficient RAM to parse static assertion");
 				};
-			zaimoni::autotransform_n(parsetree.c_array<0>(),src.data<0>()[i+1].data<0>(),k,value_copy);
+			zaimoni::autotransform_n<void (*)(parse_tree&,const parse_tree&)>(parsetree.c_array<0>(),src.data<0>()[i+1].data<0>(),k,value_copy);
 			}
 			// snip from Condense
 			const size_t starting_errors = zcc_errors.err_count();

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2009-09-26 00:38:59 UTC (rev 260)
+++ trunk/ParseTree.cpp	2009-09-26 23:14:00 UTC (rev 261)
@@ -191,24 +191,24 @@
 {	// favor ACID
 	parse_tree_class tmp;
 
-	tmp.type_code.value_copy(src.type_code);
+	value_copy(tmp.type_code,src.type_code);
 	if (!src.empty<0>())
 		{
 		size_t i = src.size<0>();
 		if (!tmp.resize<0>(i)) throw std::bad_alloc();
-		zaimoni::autotransform_n(tmp.c_array<0>(),src.data<0>(),i,value_copy);
+		zaimoni::autotransform_n<void (*)(parse_tree&,const parse_tree&)>(tmp.c_array<0>(),src.data<0>(),i,value_copy);
 		};
 	if (!src.empty<1>())
 		{
 		size_t i = src.size<1>();
 		if (!tmp.resize<1>(i)) throw std::bad_alloc();
-		zaimoni::autotransform_n(tmp.c_array<1>(),src.data<1>(),i,value_copy);
+		zaimoni::autotransform_n<void (*)(parse_tree&,const parse_tree&)>(tmp.c_array<1>(),src.data<1>(),i,value_copy);
 		}
 	if (!src.empty<2>())
 		{
 		size_t i = src.size<2>();
 		if (!tmp.resize<2>(i)) throw std::bad_alloc();
-		zaimoni::autotransform_n(tmp.c_array<2>(),src.data<2>(),i,value_copy);
+		zaimoni::autotransform_n<void (*)(parse_tree&,const parse_tree&)>(tmp.c_array<2>(),src.data<2>(),i,value_copy);
 		}
 	// would like a value_copy for weak_token
 	tmp.index_tokens[0] = src.index_tokens[0];

Modified: trunk/Zaimoni.STL/flat_alg.h
===================================================================
--- trunk/Zaimoni.STL/flat_alg.h	2009-09-26 00:38:59 UTC (rev 260)
+++ trunk/Zaimoni.STL/flat_alg.h	2009-09-26 23:14:00 UTC (rev 261)
@@ -76,7 +76,7 @@
 }
 
 /* forward-iterator version */
-template<class IO_Iterator,class IO_Iterator2,typename binary_op>
+template<typename binary_op,class IO_Iterator,class IO_Iterator2>
 inline void autotransform_n(IO_Iterator first,IO_Iterator2 first2,size_t N,binary_op op)
 {
 	while(0<N)

Modified: trunk/type_spec.cpp
===================================================================
--- trunk/type_spec.cpp	2009-09-26 00:38:59 UTC (rev 260)
+++ trunk/type_spec.cpp	2009-09-26 23:14:00 UTC (rev 261)
@@ -76,7 +76,7 @@
 
 // XXX properly operator= in C++, but type_spec has to be POD
 // ACID, throws std::bad_alloc on failure
-void type_spec::value_copy(const type_spec& src)
+void value_copy(type_spec& dest,const type_spec& src)
 {
 	{
 	type_spec tmp;
@@ -84,16 +84,16 @@
 	tmp.base_type_index = src.base_type_index;
 	tmp.set_static_array_size(src.static_array_size);
 	tmp.set_pointer_power(src.pointer_power);
-	destroy();
-	*this = tmp;
+	dest.destroy();
+	dest = tmp;
 	}
 
-	const size_t new_ptr_power = pointer_power_after_array_decay();
+	const size_t new_ptr_power = dest.pointer_power_after_array_decay();
 	if (sizeof(unsigned char*)<=new_ptr_power)
-		memmove(qualifier_vector.first,src.qualifier_vector.first,new_ptr_power+1);
+		memmove(dest.qualifier_vector.first,src.qualifier_vector.first,new_ptr_power+1);
 	else
-		memmove(qualifier_vector.second,src.qualifier_vector.second,new_ptr_power+1);
-	if (0<pointer_power) memmove(extent_vector,src.extent_vector,sizeof(uintmax_t)*pointer_power);
+		memmove(dest.qualifier_vector.second,src.qualifier_vector.second,new_ptr_power+1);
+	if (0<dest.pointer_power) memmove(dest.extent_vector,src.extent_vector,sizeof(uintmax_t)*dest.pointer_power);
 }
 
 

Modified: trunk/type_spec.hpp
===================================================================
--- trunk/type_spec.hpp	2009-09-26 00:38:59 UTC (rev 260)
+++ trunk/type_spec.hpp	2009-09-26 23:14:00 UTC (rev 261)
@@ -43,8 +43,6 @@
 
 	void set_static_array_size(size_t _size);
 	void set_pointer_power(size_t _size);	// ACID, throws std::bad_alloc on failure
-	void value_copy(const type_spec& src);	// XXX properly operator= in C++, but type_spec has to be POD
-											// ACID, throws std::bad_alloc on failure
 	bool dereference();
 	unsigned char& qualifier(size_t i) {return sizeof(unsigned char*)>pointer_power_after_array_decay() ? qualifier_vector.second[i] : qualifier_vector.first[i];};
 	template<size_t i> unsigned char& qualifier() {return sizeof(unsigned char*)>pointer_power_after_array_decay() ? qualifier_vector.second[i] : qualifier_vector.first[i];}
@@ -56,4 +54,7 @@
 	bool operator!=(const type_spec& rhs) const {return !(*this==rhs);};
 };
 
+// ACID; throws std::bad_alloc on failure
+void value_copy(type_spec& dest, const type_spec& src);
+
 #endif



From zaimoni at mail.berlios.de  Sun Sep 27 03:12:07 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 27 Sep 2009 03:12:07 +0200
Subject: [Zcplusplus-commits] r262 - in trunk: . Zaimoni.STL
Message-ID: <200909270112.n8R1C7NG018940@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-27 03:12:02 +0200 (Sun, 27 Sep 2009)
New Revision: 262

Modified:
   trunk/ParseTree.cpp
   trunk/ParseTree.hpp
   trunk/Zaimoni.STL/AutoPtr.hpp
Log:
Give parse_tree a MoveInto method; also, now have weakautovalarray_ptr and weakautovalarray_ptr_throws classes

Modified: trunk/ParseTree.cpp
===================================================================
--- trunk/ParseTree.cpp	2009-09-26 23:14:00 UTC (rev 261)
+++ trunk/ParseTree.cpp	2009-09-27 01:12:02 UTC (rev 262)
@@ -235,7 +235,18 @@
 	tmp.clear();
 }
 
+void parse_tree::MoveInto(parse_tree& dest)
+{
+	dest.destroy();
+	memmove(dest.index_tokens,index_tokens,2*sizeof(*index_tokens));
+	memmove(dest.args,args,3*sizeof(*args));
+	dest.flags = flags;
+	dest.subtype = subtype;
+	dest.type_code = type_code;
+	clear();
+}
 
+
 void parse_tree::_eval_to_arg(size_t arg_idx, size_t i)
 {
 	parse_tree tmp = data(arg_idx)[i];

Modified: trunk/ParseTree.hpp
===================================================================
--- trunk/ParseTree.hpp	2009-09-26 23:14:00 UTC (rev 261)
+++ trunk/ParseTree.hpp	2009-09-27 01:12:02 UTC (rev 262)
@@ -49,6 +49,8 @@
 	// XXX synchronized against type_system.hpp
     type_spec type_code;
 
+	void MoveInto(parse_tree& dest);
+
 	parse_tree* c_array(size_t arg_idx)
 		{
 		assert(STATIC_SIZE(args)>arg_idx);
@@ -364,7 +366,29 @@
 {
 public:
 	parse_tree_class() {this->clear();};
+	parse_tree_class(const parse_tree_class& src)
+		{
+		this->clear();
+		value_copy(*this,src);
+		};
+	parse_tree_class(const parse_tree& src)
+		{
+		this->clear();
+		value_copy(*this,src);
+		};
 	~parse_tree_class() {this->destroy();};
+	const parse_tree_class& operator=(const parse_tree_class& src)
+		{
+		this->destroy();
+		value_copy(*this,src);
+		return *this;
+		}
+	const parse_tree_class& operator=(const parse_tree& src)
+		{
+		this->destroy();
+		value_copy(*this,src);
+		return *this;
+		}
 };
 
 void INC_INFORM(const parse_tree& src);

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2009-09-26 23:14:00 UTC (rev 261)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2009-09-27 01:12:02 UTC (rev 262)
@@ -164,13 +164,13 @@
 	explicit _meta_weakautoarray_ptr(T*& src) : _ptr(src) {src = NULL;};
 	explicit _meta_weakautoarray_ptr(size_t n) : _ptr(n ? _new_buffer_nonNULL_throws<T>(n) : NULL) {};
 	explicit _meta_weakautoarray_ptr(const std::nothrow_t& tracer, size_t n) : _ptr(_new_buffer<T>(n)) {};
-	explicit _meta_weakautoarray_ptr(_meta_weakautoarray_ptr& src) : _ptr(src._ptr) {src._ptr=NULL;};
+	explicit _meta_weakautoarray_ptr(const _meta_weakautoarray_ptr& src) : _ptr(NULL) {*this=src;};
 #else
 	explicit _meta_weakautoarray_ptr() : _ptr(NULL),_size(0) {};
 	explicit _meta_weakautoarray_ptr(T*& src,size_t src_size) : _ptr(src),_size(src_size) {src = NULL;};
 	explicit _meta_weakautoarray_ptr(size_t n) : _ptr(n ? _new_buffer_nonNULL_throws<T>(n) : NULL),_size(n) {};
 	explicit _meta_weakautoarray_ptr(const std::nothrow_t& tracer, size_t n) : _ptr(_new_buffer<T>(n)),_size(n) {};
-	explicit _meta_weakautoarray_ptr(_meta_weakautoarray_ptr& src) : _ptr(src._ptr),_size(src._size) {src._ptr=NULL; src._size=0;};
+	explicit _meta_weakautoarray_ptr(_meta_weakautoarray_ptr& src) : _ptr(NULL),_size(0) {*this=src;};
 #endif
 	~_meta_weakautoarray_ptr() {_weak_flush(_ptr);};
 
@@ -180,6 +180,8 @@
 	void operator=(const _meta_weakautoarray_ptr& src);
 	template<typename U> bool value_copy_of(const U& src);	// STL interfaces required of U: size(),data()
 	void reset() {_weak_flush(_ptr); this->NULLPtr();};
+	void reset(T*& src);
+	void MoveInto(_meta_weakautoarray_ptr<T>& dest) {dest.reset(_ptr);};
 
 	void TransferOutAndNULL(T*& Target) {_weak_flush(Target); Target = _ptr; this->NULLPtr();}
 	bool Resize(size_t n) {return _weak_resize(_ptr,n);};
@@ -237,6 +239,47 @@
 };
 
 template<typename T>
+class weakautovalarray_ptr : public _meta_weakautoarray_ptr<T>
+{
+public:
+	ZAIMONI_STL_TYPE_GLUE_ARRAY(T);
+
+	explicit weakautovalarray_ptr() {};
+	explicit weakautovalarray_ptr(T*& src) : _meta_weakautoarray_ptr<T>(src) {};
+	explicit weakautovalarray_ptr(size_t n) : _meta_weakautoarray_ptr<T>(std::nothrow,n) {};
+	explicit weakautovalarray_ptr(const weakautovalarray_ptr& src) : _meta_weakautoarray_ptr<T>(src) {};
+	explicit weakautovalarray_ptr(const _meta_weakautoarray_ptr<T>& src) : _meta_weakautoarray_ptr<T>(src) {};
+//	~weakautoarray_ptr();	// default OK
+
+#ifndef ZAIMONI_FORCE_ISO
+	const weakautovalarray_ptr& operator=(T* src) {_meta_weakautoarray_ptr<T>::operator=(src); return *this;};
+#endif
+	const weakautovalarray_ptr& operator=(weakautovalarray_ptr& src) {reset(src._ptr); return *this;};
+
+	friend void zaimoni::swap(weakautovalarray_ptr& lhs, weakautovalarray_ptr& rhs) {lhs.swap(rhs);};
+};
+
+template<typename T>
+class weakautovalarray_ptr_throws : public _meta_weakautoarray_ptr<T>
+{
+public:
+	ZAIMONI_STL_TYPE_GLUE_ARRAY(T);
+
+	explicit weakautovalarray_ptr_throws() {};
+	explicit weakautovalarray_ptr_throws(T*& src) : _meta_weakautoarray_ptr<T>(src) {};
+	explicit weakautovalarray_ptr_throws(size_t n) : _meta_weakautoarray_ptr<T>(n) {};
+	explicit weakautovalarray_ptr_throws(const weakautovalarray_ptr_throws& src) : _meta_weakautoarray_ptr<T>(src) {};
+//	~weakautoarray_ptr_throws();	// default OK
+
+#ifndef ZAIMONI_FORCE_ISO
+	const weakautovalarray_ptr_throws& operator=(T* src) {_meta_weakautoarray_ptr<T>::operator=(src); return *this;};
+#endif
+	const weakautovalarray_ptr_throws& operator=(weakautovalarray_ptr_throws& src) {_meta_weakautoarray_ptr<T>::operator=(src); return *this;};
+
+	friend void zaimoni::swap(weakautovalarray_ptr_throws& lhs, weakautovalarray_ptr_throws& rhs) {lhs.swap(rhs);};
+};
+
+template<typename T>
 class _meta_autoarray_ptr : public c_var_array_CRTP<_meta_autoarray_ptr<T>, T>
 {
 protected:
@@ -597,6 +640,19 @@
 }
 
 template<typename T>
+void
+_meta_weakautoarray_ptr<T>::reset(T*& src)
+{	// this convolution handles a recursion issue
+	T* tmp = src;
+	src = NULL;
+	if (tmp!=_ptr)
+		{
+		if (NULL!=_ptr) _weak_flush(_ptr);
+		_ptr = tmp;
+		};
+}
+
+template<typename T>
 template<typename U>
 bool
 _meta_autoarray_ptr<T>::grep(UnaryPredicate* Predicate,_meta_autoarray_ptr<U*>& Target) const



From zaimoni at mail.berlios.de  Sun Sep 27 08:01:59 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 27 Sep 2009 08:01:59 +0200
Subject: [Zcplusplus-commits] r263 - in trunk: . Zaimoni.STL
	Zaimoni.STL/LexParse
Message-ID: <200909270601.n8R61xjn028280@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-27 08:01:41 +0200 (Sun, 27 Sep 2009)
New Revision: 263

Modified:
   trunk/Zaimoni.STL/LexParse/LangConf.cpp
   trunk/Zaimoni.STL/LexParse/MetaToken.hpp
   trunk/Zaimoni.STL/POD.hpp
   trunk/type_system.hpp
Log:
ISO-mode fixes; check that planned extension to type_system builds (new classes are coming)

Modified: trunk/Zaimoni.STL/LexParse/LangConf.cpp
===================================================================
--- trunk/Zaimoni.STL/LexParse/LangConf.cpp	2009-09-27 01:12:02 UTC (rev 262)
+++ trunk/Zaimoni.STL/LexParse/LangConf.cpp	2009-09-27 06:01:41 UTC (rev 263)
@@ -51,8 +51,7 @@
 	return 0;
 }
 
-void
-LangConf::ExtractLineFromTextBuffer(char*& Buffer, char*& NewLine) const
+void LangConf::ExtractLineFromTextBuffer(char*& Buffer, char*& NewLine) const
 {
 #ifdef ZAIMONI_FORCE_ISO
 	size_t BufferLength = _msize(Buffer);
@@ -106,14 +105,9 @@
 		}
 
 	size_t NewLineLength = (SweepIdx<=(BufferLength>>1)) ? SweepIdx : BufferLength-(SweepIdx+1);
-#ifdef ZAIMONI_FORCE_ISO
-	NewLine = (0<NewLineLength) ? REALLOC(NewLine,NewLineLength+1) : NULL;
+	NewLine = (0<NewLineLength) ? REALLOC(NewLine,ZAIMONI_LEN_WITH_NULL(NewLineLength)) : NULL;
 	if (NULL==NewLine) return;
-	NewLine[NewLineLength] = '\0';
-#else
-	NewLine = REALLOC(NewLine,NewLineLength);
-	if (NULL==NewLine) return;
-#endif
+	ZAIMONI_NULL_TERMINATE(NewLine[NewLineLength]);
 
 	Buffer[SweepIdx] = '\0';
 	if (SweepIdx<=(BufferLength>>1))
@@ -133,8 +127,7 @@
 		}	
 }
 
-bool
-LangConf::ApplyGlobalFilters(char*& Target) const
+bool LangConf::ApplyGlobalFilters(char*& Target) const
 {
 	if (NULL!=Target)
 		{	// legal char set is a global filter, but should be fairly late (after comment-stripping)
@@ -144,15 +137,13 @@
 	return true;
 }
 
-bool
-LangConf::ApplyTokenizingFilters(char*& Target) const
+bool LangConf::ApplyTokenizingFilters(char*& Target) const
 {
 	if (NULL==TokenizingFilters || NULL==Target) return true;
 	return _applyFilters(TokenizingFilters,TokenizingFilters.size(),Target);
 }
 
-size_t
-LangConf::TokenizeCore(const char* Target, lex_flags& Flags) const
+size_t LangConf::TokenizeCore(const char* Target, lex_flags& Flags) const
 {
 	if (IsAtomicSymbol(Target[0]))
 		{
@@ -191,12 +182,10 @@
 LangConf::UnfilteredNextToken(const char* Target, lex_flags& Flags) const
 {
 	if (NULL==Target) return 0;
-
 	return TokenizeCore(Target,Flags);
 }
 
-size_t
-LangConf::NextToken(char*& Target, lex_flags& Flags) const
+size_t LangConf::NextToken(char*& Target, lex_flags& Flags) const
 {
 	if (NULL==Target) return 0;
 	if (NULL!=TokenizingFilters && !_applyFilters(TokenizingFilters,TokenizingFilters.size(),Target))
@@ -205,8 +194,7 @@
 	return TokenizeCore(Target,Flags);
 }
 
-bool
-LangConf::InstallTokenizer(Tokenizer* Source,lex_flags SourceFlags)
+bool LangConf::InstallTokenizer(Tokenizer* Source,lex_flags SourceFlags)
 {
 	const size_t StackSize = Tokenizers.size();
 	if (!Tokenizers.InsertSlotAt(StackSize,Source)) return false;
@@ -270,15 +258,13 @@
 	free(target);
 }
 
-size_t
-LangConf::_len_SingleLineComment(const char* const Test) const
+size_t LangConf::_len_SingleLineComment(const char* const Test) const
 {
 	if (0!=strncmp(Test,SingleLineCommenter,len_SingleLineCommenter)) return 0;
 	return strcspn(Test,"\n");
 }
 
-size_t
-LangConf::_len_MultiLineComment(const char* const Test) const
+size_t LangConf::_len_MultiLineComment(const char* const Test) const
 {
 	if (0!=strncmp(Test,MultiLineCommentStart,len_MultiLineCommentStart)) return 0;
 	const char* const end_comment = strstr(Test+len_MultiLineCommentStart,MultiLineCommentEnd);
@@ -308,8 +294,7 @@
 	return SIZE_MAX;
 }
 
-void
-LangConf::_compactWSAtIdx(char*& Text,size_t Idx) const
+void LangConf::_compactWSAtIdx(char*& Text,size_t Idx) const
 {
 	size_t TextLength = strlen(Text);
 	Text[++Idx]=' ';
@@ -337,8 +322,7 @@
 	return false;
 }
 
-void
-LangConf::_flattenComments(char*& Text)
+void LangConf::_flattenComments(char*& Text)
 {	// note: have to be able to lex
 #ifdef ZAIMONI_FORCE_ISO
 	const size_t TextLength = strlen(Text);

Modified: trunk/Zaimoni.STL/LexParse/MetaToken.hpp
===================================================================
--- trunk/Zaimoni.STL/LexParse/MetaToken.hpp	2009-09-27 01:12:02 UTC (rev 262)
+++ trunk/Zaimoni.STL/LexParse/MetaToken.hpp	2009-09-27 06:01:41 UTC (rev 263)
@@ -14,7 +14,7 @@
 class MetaToken
 {
 protected:
-	autovalarray_ptr<T> _token;	
+	autovalarray_ptr_throws<T> _token;	
 public:
 	// pairs are: line number, origin (column number)
 	std::pair<size_t,size_t> logical_line;		// where the token actually is
@@ -106,21 +106,19 @@
 
 template<class T>
 MetaToken<T>::MetaToken(const MetaToken& src,size_t prefix)
-:	_token(prefix),
+:	_token((prefix ? ZAIMONI_LEN_WITH_NULL(prefix) : 0)),
 	logical_line(src.logical_line),
 	original_line(src.original_line),
 	src_filename(src.src_filename),
 	parent_dir(src.parent_dir)
 {
-	assert(prefix<=src._token.size());
 	DEBUG_FAIL_OR_LEAVE(0==prefix,return);
-	if (0==_token.size()) throw std::bad_alloc();	// didn't allocate space properly
 	_value_copy_buffer(_token.c_array(),src._token.data(),prefix);
 }
 
 template<class T>
 MetaToken<T>::MetaToken(const MetaToken& src,size_t offset,size_t token_len)
-:	_token(token_len),
+:	_token((token_len ? ZAIMONI_LEN_WITH_NULL(token_len) : 0)),
 	logical_line(src.logical_line.first,src.logical_line.second+offset),
 	original_line(src.original_line.first,src.original_line.second+offset),
 	src_filename(src.src_filename),
@@ -129,13 +127,12 @@
 	assert(offset<src._token.size());
 	assert(token_len<=src._token.size()-offset);
 	DEBUG_FAIL_OR_LEAVE(0==token_len,return);
-	if (0==_token.size()) throw std::bad_alloc();	// didn't allocate space properly
 	_value_copy_buffer(_token.c_array(),src._token.data()+offset,token_len);
 }
 
 template<class T>
 MetaToken<T>::MetaToken(const T* const src,size_t offset,size_t token_len)
-:	_token(token_len),
+:	_token((token_len ? ZAIMONI_LEN_WITH_NULL(token_len) : 0)),
 	logical_line(0,offset),
 	original_line(0,offset),
 	src_filename(NULL),
@@ -145,7 +142,6 @@
 	assert(offset<strlen(src));
 	assert(token_len<=strlen(src)-offset);
 	DEBUG_FAIL_OR_LEAVE(0==token_len,return);
-	if (0==_token.size()) throw std::bad_alloc();	// didn't allocate space properly
 	_value_copy_buffer(_token.c_array(),src+offset,token_len);
 }
 

Modified: trunk/Zaimoni.STL/POD.hpp
===================================================================
--- trunk/Zaimoni.STL/POD.hpp	2009-09-27 01:12:02 UTC (rev 262)
+++ trunk/Zaimoni.STL/POD.hpp	2009-09-27 06:01:41 UTC (rev 263)
@@ -104,6 +104,14 @@
 	T2 second;
 };
 
+template<class T1, class T2, class T3>
+union union_triple
+{
+	T1 first;
+	T2 second;
+	T3 third;
+};
+
 template<class T1, class T2, class T3, class T4>
 union union_quartet
 {
@@ -141,6 +149,18 @@
 #undef ZAIMONI_CLASS_SPEC
 #undef ZAIMONI_TEMPLATE_SPEC
 
+#define ZAIMONI_TEMPLATE_SPEC template<typename _T1,typename _T2>
+#define ZAIMONI_CLASS_SPEC zaimoni::union_pair<_T1,_T2>
+ZAIMONI_POD_STRUCT(ZAIMONI_TEMPLATE_SPEC,ZAIMONI_CLASS_SPEC,_T1)
+#undef ZAIMONI_CLASS_SPEC
+#undef ZAIMONI_TEMPLATE_SPEC
+
+#define ZAIMONI_TEMPLATE_SPEC template<typename _T1,typename _T2,typename _T3>
+#define ZAIMONI_CLASS_SPEC zaimoni::union_triple<_T1,_T2,_T3>
+ZAIMONI_POD_STRUCT(ZAIMONI_TEMPLATE_SPEC,ZAIMONI_CLASS_SPEC,_T1)
+#undef ZAIMONI_CLASS_SPEC
+#undef ZAIMONI_TEMPLATE_SPEC
+
 }
 
 

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2009-09-27 01:12:02 UTC (rev 262)
+++ trunk/type_system.hpp	2009-09-27 06:01:41 UTC (rev 263)
@@ -8,6 +8,10 @@
 #include "Zaimoni.STL/AutoPtr.hpp"
 #include "type_spec.hpp"
 
+class function_type;
+class union_struct_decl;
+class union_struct_def;
+
 class type_system
 {
 public:
@@ -18,7 +22,7 @@
 	const size_t core_types_size;
 	const size_t int_priority_size;
 private:
-	zaimoni::autovalarray_ptr<zaimoni::POD_pair<char*,size_t> > dynamic_types;
+	zaimoni::autovalarray_ptr<zaimoni::POD_triple<char*,size_t,zaimoni::POD_pair<zaimoni::union_triple<function_type*,union_struct_decl*,union_struct_def*>, unsigned char> > > dynamic_types;
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> > > typedef_registry;
 	// uncopyable
 	type_system(const type_system& src);



From zaimoni at mail.berlios.de  Wed Sep 30 02:37:46 2009
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 30 Sep 2009 02:37:46 +0200
Subject: [Zcplusplus-commits] r264 - trunk
Message-ID: <200909300037.n8U0bka5018134@sheep.berlios.de>

Author: zaimoni
Date: 2009-09-30 02:37:40 +0200 (Wed, 30 Sep 2009)
New Revision: 264

Modified:
   trunk/CSupport.cpp
   trunk/type_system.cpp
   trunk/type_system.hpp
Log:
minor cleanups; verify that planned infrastructure for functions and structs compiles

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-09-27 06:01:41 UTC (rev 263)
+++ trunk/CSupport.cpp	2009-09-30 00:37:40 UTC (rev 264)
@@ -1621,6 +1621,12 @@
 	return NULL!=x.first && detect_C_right_brace_op(x.first,x.second);
 }
 
+template<char c> inline bool robust_token_is_char(const parse_tree& x)
+{
+	return x.is_atomic()
+		&& robust_token_is_char<c>(x.index_tokens[0].token);
+}
+
 //! \todo if we have an asphyxiates_left_brace, suppress_naked_brackets_and_braces goes obsolete
 static bool asphyxiates_left_bracket(const weak_token& x)
 {
@@ -9982,6 +9988,15 @@
 	return 0;
 }
 
+static size_t span_to_semicolon(const parse_tree* const first,const parse_tree* const last)
+{
+	assert(first);
+	assert(last);
+	const parse_tree* iter = first;
+	while(iter!=last && !robust_token_is_char<';'>(*iter)) ++iter;
+	return iter-first;
+}
+
 // will need: "function-type vector"
 // return: 1 typespec record (for now, other languages may have more demanding requirements)
 // incoming: n typespec records, flag for trailing ...
@@ -10012,10 +10027,8 @@
 		if (robust_token_is_string<14>(src.data<0>()[i].index_tokens[0].token,"_Static_Assert"))
 			{	// _Static_Assert ( constant-expression , string-literal ) ;
 			// find the next ';'
-			size_t j = i;
-			while(src.size<0>()> ++j
-				  && (!src.data<0>()[j].is_atomic() || !robust_token_is_char<';'>(src.data<0>()[j].index_tokens[0].token)));
-			if (src.size<0>()==j)
+			const size_t j = i+span_to_semicolon(src.data<0>()+i,src.end<0>());
+			if (src.size<0>()<=j)
 				{	//! \test zcc/staticassert.C99/Error_scope1.h
 					//! \test zcc/staticassert.C99/Error_scope2.h
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -10027,9 +10040,8 @@
 				};
 			if (   !is_naked_parentheses_pair(src.data<0>()[i+1])
 				|| 3>src.data<0>()[i+1].size<0>()
-				|| !src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-2].is_atomic()
+				|| !robust_token_is_char<','>(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-2])
 				|| !src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].is_atomic()
-				|| !robust_token_is_char<','>(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-2].index_tokens[0].token)
 				|| C_TESTFLAG_STRING_LITERAL!=src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].flags)
 				{	//! \test zcc/staticassert.C99/Error_badarg1.h
 					//! \test zcc/staticassert.C99/Error_badarg2.h
@@ -10211,8 +10223,7 @@
 					INFORM("declarator missing (C99 6.7p1)");
 					zcc_errors.inc_error();
 					// find the next semicolon
-					size_t j = i+decl_count+decl_offset;
-					while((!src.data<0>()[j].is_atomic() || !token_is_char<';'>(src.data<0>()[j].index_tokens[0].token)) && src.size<0>()> ++j);
+					const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
 					if (have_we_parsed_yet)
 						src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
 					else
@@ -10226,15 +10237,14 @@
 					INFORM("declarator has no identifier to declare (C99 6.7p1)");
 					zcc_errors.inc_error();
 					// find the next semicolon, unless we have () immediately in which case we have nothing to look for
-					const bool unwind_to_compound_statement = robust_token_is_char<'('>(src.data<0>()[i+decl_count+decl_offset].index_tokens[0].token) && robust_token_is_char<')'>(src.data<0>()[i+decl_count+decl_offset].index_tokens[1].token);
+					const bool unwind_to_compound_statement = is_naked_parentheses_pair(src.data<0>()[i+decl_count+decl_offset]);
 					if (unwind_to_compound_statement)
 						{
 						assert(!have_we_parsed_yet);
 						src.DeleteNSlotsAt<0>(decl_count+decl_offset+initdecl_span,i);
 						}
 					else{
-						size_t j = i+decl_count+decl_offset;
-						while((!src.data<0>()[j].is_atomic() || !token_is_char<';'>(src.data<0>()[j].index_tokens[0].token)) && src.size<0>()> ++j);
+						const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
 						if (have_we_parsed_yet)
 							src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
 						else
@@ -10384,10 +10394,8 @@
 		if (robust_token_is_string<13>(src.data<0>()[i].index_tokens[0].token,"static_assert"))
 			{	// static_assert ( constant-expression , string-literal ) ;
 			// find the next ';'
-			size_t j = i;
-			while(src.size<0>()> ++j
-				  && (!src.data<0>()[j].is_atomic() || !robust_token_is_char<';'>(src.data<0>()[j].index_tokens[0].token)));
-			if (src.size<0>()==j)
+			const size_t j = i+span_to_semicolon(src.data<0>()+i,src.end<0>());
+			if (src.size<0>()<=j)
 				{	//! \test zcc/staticassert.C99/Error_scope1.hpp
 					//! \test zcc/staticassert.C99/Error_scope2.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -10399,9 +10407,8 @@
 				};
 			if (   !is_naked_parentheses_pair(src.data<0>()[i+1])
 				|| 3>src.data<0>()[i+1].size<0>()
-				|| !src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-2].is_atomic()
+				|| !robust_token_is_char<','>(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-2])
 				|| !src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].is_atomic()
-				|| !robust_token_is_char<','>(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-2].index_tokens[0].token)
 				|| C_TESTFLAG_STRING_LITERAL!=src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].flags)
 				{	//! \test zcc/staticassert.C99/Error_badarg1.hpp
 					//! \test zcc/staticassert.C99/Error_badarg2.hpp
@@ -10708,8 +10715,7 @@
 					INFORM("declarator missing (C++98 7p1)");
 					zcc_errors.inc_error();
 					// find the next semicolon
-					size_t j = i+decl_count+decl_offset;
-					while((!src.data<0>()[j].is_atomic() || !token_is_char<';'>(src.data<0>()[j].index_tokens[0].token)) && src.size<0>()> ++j);
+					const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
 					if (have_we_parsed_yet)
 						src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
 					else
@@ -10723,15 +10729,14 @@
 					INFORM("declarator has no name to declare (C++98 7p1)");
 					zcc_errors.inc_error();
 					// find the next semicolon, unless we have () immediately in which case we have nothing to look for
-					const bool unwind_to_compound_statement = robust_token_is_char<'('>(src.data<0>()[i+decl_count+decl_offset].index_tokens[0].token) && robust_token_is_char<')'>(src.data<0>()[i+decl_count+decl_offset].index_tokens[1].token);
+					const bool unwind_to_compound_statement = is_naked_parentheses_pair(src.data<0>()[i+decl_count+decl_offset]);
 					if (unwind_to_compound_statement)
 						{
 						assert(!have_we_parsed_yet);
 						src.DeleteNSlotsAt<0>(decl_count+decl_offset+initdecl_span,i);
 						}
 					else{
-						size_t j = i+decl_count+decl_offset;
-						while((!src.data<0>()[j].is_atomic() || !token_is_char<';'>(src.data<0>()[j].index_tokens[0].token)) && src.size<0>()> ++j);
+						const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
 						if (have_we_parsed_yet)
 							src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
 						else

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2009-09-27 06:01:41 UTC (rev 263)
+++ trunk/type_system.cpp	2009-09-30 00:37:40 UTC (rev 264)
@@ -4,14 +4,19 @@
 #include "type_system.hpp"
 #include "Zaimoni.STL/search.hpp"
 
+// macros to help out dynamic registration
+#define DYNAMIC_FUNCTYPE 1
+#define DYNAMIC_STRUCTDECL 2
+#define DYNAMIC_C_STRUCTDEF 3
+
 type_system::type_index
 type_system::_get_id(const char* const x,size_t x_len) const
 {
-	errr tmp = linear_find(x,x_len,core_types,core_types_size);
+	errr tmp = linear_find_lencached(x,x_len,core_types,core_types_size);
 	if (0<=tmp) return tmp+1;
 	if (!dynamic_types.empty())
 		{
-		tmp = binary_find(x,x_len,dynamic_types);
+		tmp = linear_find_lencached(x,x_len,dynamic_types);
 		if (0<=tmp) return tmp+1+core_types_size;
 		}
 	return 0;
@@ -20,8 +25,7 @@
 const char* type_system::_name(size_t id) const
 {
 	if (0==id) return "(?)";
-	if (core_types_size> --id)
-		return core_types[id].first;
+	if (core_types_size> --id) return core_types[id].first;
 	if (dynamic_types.size() > (id -= core_types_size))
 		return dynamic_types[id].first;
 	return "(?)";
@@ -30,8 +34,8 @@
 // implement C/C++ typedef system
 void type_system::set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec& src)
 {
-	assert(NULL!=alias && '0'!= *alias);
-	assert(NULL!=filename && '0'!= *alias);
+	assert(alias && *alias);
+	assert(filename && *filename);
 	//! \todo: strip off trailing inline namespaces
 	// <unknown> is the hack for anonymous namespaces taken from GCC, it's always inline
 	errr tmp = binary_find(alias,strlen(alias),typedef_registry.data(),typedef_registry.size());
@@ -47,7 +51,7 @@
 
 const zaimoni::POD_triple<type_spec,const char*,size_t>* type_system::get_typedef(const char* const alias) const
 {
-	assert(NULL!=alias);
+	assert(alias && *alias);
 	//! \todo: strip off trailing inline namespaces
 	// <unknown> is the hack for anonymous namespaces taken from GCC, it's always inline
 	errr tmp = binary_find(alias,strlen(alias),typedef_registry.data(),typedef_registry.size());
@@ -55,3 +59,93 @@
 	return NULL;
 }
 
+type_system::type_index type_system::register_functype(const char* const alias, function_type*& src)
+{
+	assert(alias && *alias);
+	assert(src);
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_FUNCTYPE}};
+	tmp.third.first.first = src;
+
+	type_index result = get_id(alias);
+	if (result) return result;
+
+	const size_t dynamic_types_size = dynamic_types.size();
+	const size_t dynamic_types_max_size = dynamic_types.max_size();
+	if (	dynamic_types_max_size<1+core_types_size
+		|| 	dynamic_types_max_size-(1+core_types_size)<dynamic_types_size)
+		FATAL("Host implementation limit exceeded: cannot record function type used in program");
+	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
+	src = NULL;
+	return dynamic_types_size+2+core_types_size;
+}
+
+type_system::type_index type_system::register_structdecl(const char* const alias, union_struct_decl*& src)
+{
+	assert(alias && *alias);
+	assert(src);
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_STRUCTDECL}};
+	tmp.third.first.second = src;
+
+	type_index result = get_id(alias);
+	if (result) return result;
+
+	const size_t dynamic_types_size = dynamic_types.size();
+	const size_t dynamic_types_max_size = dynamic_types.max_size();
+	if (	dynamic_types_max_size<2+core_types_size
+		|| 	dynamic_types_max_size-(2+core_types_size)<dynamic_types_size)
+		FATAL("Host implementation limit exceeded: cannot record union/struct type used in program");
+	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
+	src = NULL;
+	return dynamic_types_size+2+core_types_size;
+}
+
+type_system::type_index type_system::register_C_structdef(const char* const alias, C_union_struct_def*& src)
+{
+	assert(alias && *alias);
+	assert(src);
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_STRUCTDECL}};
+	tmp.third.first.third = src;
+
+	type_index result = get_id(alias);
+	if (result) return result;
+
+	const size_t dynamic_types_size = dynamic_types.size();
+	const size_t dynamic_types_max_size = dynamic_types.max_size();
+	if (	dynamic_types_max_size<2+core_types_size
+		|| 	dynamic_types_max_size-(2+core_types_size)<dynamic_types_size)
+		FATAL("Host implementation limit exceeded: cannot record union/struct type used in program");
+	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
+	src = NULL;
+	return dynamic_types_size+2+core_types_size;
+}
+
+const function_type* type_system::get_functype(type_system::type_index i)
+{
+	if (core_types_size>=i) return NULL;
+	i -= core_types_size;
+	if (dynamic_types.size()<=i) return NULL;
+	const dynamic_type_format& tmp = dynamic_types[i];
+	if (DYNAMIC_FUNCTYPE!=tmp.third.second) return NULL;
+	return tmp.third.first.first;
+}
+
+const union_struct_decl* type_system::get_structdecl(type_system::type_index i)
+{
+	if (core_types_size>=i) return NULL;
+	i -= core_types_size;
+	if (dynamic_types.size()<=i) return NULL;
+	const dynamic_type_format& tmp = dynamic_types[i];
+	if (DYNAMIC_STRUCTDECL!=tmp.third.second) return NULL;
+	return tmp.third.first.second;
+}
+
+const C_union_struct_def* type_system::get_C_structdef(type_system::type_index i)
+{
+	if (core_types_size>=i) return NULL;
+	i -= core_types_size;
+	if (dynamic_types.size()<=i) return NULL;
+	const dynamic_type_format& tmp = dynamic_types[i];
+	if (DYNAMIC_C_STRUCTDEF!=tmp.third.second) return NULL;
+	return tmp.third.first.third;
+}
+

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2009-09-27 06:01:41 UTC (rev 263)
+++ trunk/type_system.hpp	2009-09-30 00:37:40 UTC (rev 264)
@@ -10,7 +10,7 @@
 
 class function_type;
 class union_struct_decl;
-class union_struct_def;
+class C_union_struct_def;
 
 class type_system
 {
@@ -22,7 +22,8 @@
 	const size_t core_types_size;
 	const size_t int_priority_size;
 private:
-	zaimoni::autovalarray_ptr<zaimoni::POD_triple<char*,size_t,zaimoni::POD_pair<zaimoni::union_triple<function_type*,union_struct_decl*,union_struct_def*>, unsigned char> > > dynamic_types;
+	typedef zaimoni::POD_triple<const char*,size_t,zaimoni::POD_pair<zaimoni::union_triple<function_type*,union_struct_decl*,C_union_struct_def*>, unsigned char> > dynamic_type_format;
+	zaimoni::autovalarray_ptr<dynamic_type_format> dynamic_types;
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> > > typedef_registry;
 	// uncopyable
 	type_system(const type_system& src);
@@ -54,6 +55,13 @@
 
 	void set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec& src);	// invalidates src
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* get_typedef(const char* const alias) const;
+
+	type_index register_functype(const char* const alias, function_type*& src);
+	type_index register_structdecl(const char* const alias, union_struct_decl*& src);
+	type_index register_C_structdef(const char* const alias, C_union_struct_def*& src);
+	const function_type* get_functype(type_index i);
+	const union_struct_decl* get_structdecl(type_index i);
+	const C_union_struct_def* get_C_structdef(type_index i);
 private:
 	type_index _get_id(const char* const x,size_t x_len) const;
 	const char* _name(type_index id) const;



