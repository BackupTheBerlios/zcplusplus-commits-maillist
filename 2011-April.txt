From zaimoni at mail.berlios.de  Sat Apr  9 05:52:39 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat,  9 Apr 2011 05:52:39 +0200
Subject: [Zcplusplus-commits] r626 - trunk/tools
Message-ID: <20110409035239.C5AAA480F07@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-09 05:52:39 +0200 (Sat, 09 Apr 2011)
New Revision: 626

Modified:
   trunk/tools/POSIX.inc
   trunk/tools/decl_infile.py
Log:
update test case generation

Modified: trunk/tools/POSIX.inc
===================================================================
--- trunk/tools/POSIX.inc	2011-03-27 05:59:31 UTC (rev 625)
+++ trunk/tools/POSIX.inc	2011-04-09 03:52:39 UTC (rev 626)
@@ -98,7 +98,8 @@
 
 # test case support
 regenerate_tests: tests/zcc/decl.C99/Pass_class_def.hpp \
-	tests/zcc/decl.C99/Pass_class_def_decl.hpp
+	tests/zcc/decl.C99/Pass_class_def_decl.hpp \
+	tests/zcc/decl.C99/Pass_class_def2.hpp
 
 tests/zcc/decl.C99/Pass_class_def.hpp: tests/zcc/decl.C99/Pass_struct_def.hpp
 	$(SED) -e s/struct/class/ tests/zcc/decl.C99/Pass_struct_def.hpp > tests/zcc/decl.C99/Pass_class_def.hpp.alt 
@@ -107,4 +108,8 @@
 tests/zcc/decl.C99/Pass_class_def_decl.hpp: tests/zcc/decl.C99/Pass_struct_def_decl.hpp
 	$(SED) -e s/struct/class/ tests/zcc/decl.C99/Pass_struct_def_decl.hpp > tests/zcc/decl.C99/Pass_class_def_decl.hpp.alt 
 	if cmp -s tests/zcc/decl.C99/Pass_class_def_decl.hpp tests/zcc/decl.C99/Pass_class_def_decl.hpp.alt; then rm tests/zcc/decl.C99/Pass_class_def_decl.hpp.alt ; else mv tests/zcc/decl.C99/Pass_class_def_decl.hpp.alt tests/zcc/decl.C99/Pass_class_def_decl.hpp; fi
+
+tests/zcc/decl.C99/Pass_class_def2.hpp: tests/zcc/decl.C99/Pass_struct_def2.hpp
+	$(SED) -e s/struct/class/ tests/zcc/decl.C99/Pass_struct_def2.hpp > tests/zcc/decl.C99/Pass_class_def2.hpp.alt 
+	if cmp -s tests/zcc/decl.C99/Pass_class_def2.hpp tests/zcc/decl.C99/Pass_class_def2.hpp.alt; then rm tests/zcc/decl.C99/Pass_class_def2.hpp.alt ; else mv tests/zcc/decl.C99/Pass_class_def2.hpp.alt tests/zcc/decl.C99/Pass_class_def2.hpp; fi
 	

Modified: trunk/tools/decl_infile.py
===================================================================
--- trunk/tools/decl_infile.py	2011-03-27 05:59:31 UTC (rev 625)
+++ trunk/tools/decl_infile.py	2011-04-09 03:52:39 UTC (rev 626)
@@ -7,6 +7,7 @@
 # target files
 target_files = ['Pass_enum_def.in', 'Pass_struct_def.in', 'Pass_union_def.in']
 target_files2 = ['Pass_enum_def_decl.in', 'Pass_struct_def_decl.in', 'Pass_union_def_decl.in']
+target_files3 = ['Pass_enum_def2.hpp', 'Pass_struct_def2.hpp', 'Pass_union_def2.hpp']
 
 invariant_header_lines = [
 'SUFFIXES h hpp\n'
@@ -19,14 +20,20 @@
 			'Pass_union_def.in':'// using singly defined union\n',
 			'Pass_enum_def_decl.in':'// using singly defined enum\n',
 			'Pass_struct_def_decl.in':'// using singly defined struct\n',
-			'Pass_union_def_decl.in':'// using singly defined union\n'}
+			'Pass_union_def_decl.in':'// using singly defined union\n',
+			'Pass_enum_def2.hpp':'// using singly defined enum\n',
+			'Pass_struct_def2.hpp':'// using singly defined struct\n',
+			'Pass_union_def2.hpp':'// using singly defined union\n'}
 
 global_define = {	'Pass_enum_def.in':'\nenum good_test {\n\tx_factor = 1\n};\n\n',
 					'Pass_struct_def.in':'\nstruct good_test {\n\tint x_factor\n};\n\n',
 					'Pass_union_def.in':'\nunion good_test {\n\tint x_factor\n};\n\n',
 					'Pass_enum_def_decl.in':'\nenum good_test {\n\tx_factor = 1\n} y;\n\n',
 					'Pass_struct_def_decl.in':'\nstruct good_test {\n\tint x_factor\n} y;\n\n',
-					'Pass_union_def_decl.in':'\nunion good_test {\n\tint x_factor\n};\n\n'}
+					'Pass_union_def_decl.in':'\nunion good_test {\n\tint x_factor\n};\n\n',
+					'Pass_enum_def2.hpp':'\nenum good_test {\n\tx_factor = 1\n};\n\n',
+					'Pass_struct_def2.hpp':'\nstruct good_test {\n\tint x_factor\n};\n\n',
+					'Pass_union_def2.hpp':'\nunion good_test {\n\tint x_factor\n};\n\n'}
 
 section_comments = ['// ringing the changes on extern\n',
 "// ringing the changes on static\n// (don't test static const -- no chance to initialize before use)\n",
@@ -45,10 +52,24 @@
 def union_decl(i):
 	return "union good_test x"+i
 
+def enum_decl_terse(i):
+	return "good_test x"+i
+
+def struct_decl_terse(i):
+	return "good_test x"+i
+
+def union_decl_terse(i):
+	return "good_test x"+i
+
 var_decl = {'Pass_enum_def.in':enum_decl, 'Pass_struct_def.in':struct_decl,
 			'Pass_union_def.in':union_decl, 'Pass_enum_def_decl.in':enum_decl,
-			'Pass_struct_def_decl.in':struct_decl, 'Pass_union_def_decl.in':union_decl}
+			'Pass_struct_def_decl.in':struct_decl, 'Pass_union_def_decl.in':union_decl,
+			'Pass_enum_def2.hpp':enum_decl, 'Pass_struct_def2.hpp':struct_decl,
+			'Pass_union_def2.hpp':union_decl}
 
+var_decl_terse = {	'Pass_enum_def2.hpp':enum_decl_terse, 'Pass_struct_def2.hpp':struct_decl_terse,
+					'Pass_union_def2.hpp':union_decl_terse}
+
 def enum_def(i):
 	return 'enum good_test'+i+' { x_factor'+i+' = 1 } x_'+i
 
@@ -59,7 +80,8 @@
 	return 'union good_test'+i+' { int x_factor'+i+'; } x_'+i
 
 var_def = {	'Pass_enum_def.in':enum_def, 'Pass_struct_def.in':struct_def,
-			'Pass_union_def.in':union_def}
+			'Pass_union_def.in':union_def, 'Pass_enum_def2.hpp':enum_def,
+			'Pass_struct_def2.hpp':struct_def, 'Pass_union_def2.hpp':union_def}
 
 test_qualifiers = [
 'extern',
@@ -293,10 +315,175 @@
 	# no define-declares
 	TargetFile.close()
 
+def SpawnTestCase3(dest_file):
+	TargetFile = open(dest_file,'w')
+	TargetFile.write('// decl.C99/'+dest_file+'\n')
 
+	for line in invariant_header_lines[2:]:
+		TargetFile.write(line)
+	TargetFile.write(context[dest_file])
+	TargetFile.write(global_define[dest_file])
+
+	# restart
+	TargetFile.write('// this section checks that suppressing keyword works\n')
+	TargetFile.write(section_comments[0].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(5):
+		TargetFile.write(test_qualifiers[i].replace('THREAD_LOCAL','thread_local')+' '+var_decl_terse[dest_file](str(i+1))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[1].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(4):
+		TargetFile.write(test_qualifiers[i+5].replace('THREAD_LOCAL','thread_local')+' '+var_decl_terse[dest_file](str(i+6))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[2].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(11):
+		TargetFile.write(test_qualifiers[i+9].replace('THREAD_LOCAL','thread_local')+' '+var_decl_terse[dest_file](str(i+10))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[3].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(10):
+		TargetFile.write(test_qualifiers[i+20].replace('THREAD_LOCAL','thread_local')+' '+var_decl_terse[dest_file](str(i+21))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[4].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(10):
+		TargetFile.write(test_qualifiers[i+30].replace('THREAD_LOCAL','thread_local')+' '+var_decl_terse[dest_file](str(i+31))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[5].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(28):
+		TargetFile.write(test_qualifiers[i+40].replace('THREAD_LOCAL','thread_local')+' '+var_decl_terse[dest_file](str(i+41))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[6].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(28):
+		TargetFile.write(test_qualifiers[i+68].replace('THREAD_LOCAL','thread_local')+' '+var_decl_terse[dest_file](str(i+69))+';\n')
+	TargetFile.write('\n')
+
+	# need: normal decl, def_decl work in namespaces
+	TargetFile.write('// check that things work properly in namespaces\nnamespace test {\n')
+
+	TargetFile.write(global_define[dest_file])
+	TargetFile.write(section_comments[0].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(5):
+		TargetFile.write(test_qualifiers[i].replace('THREAD_LOCAL','thread_local')+' '+var_decl[dest_file](str(i+1))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[1].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(4):
+		TargetFile.write(test_qualifiers[i+5].replace('THREAD_LOCAL','thread_local')+' '+var_decl[dest_file](str(i+6))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[2].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(11):
+		TargetFile.write(test_qualifiers[i+9].replace('THREAD_LOCAL','thread_local')+' '+var_decl[dest_file](str(i+10))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[3].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(10):
+		TargetFile.write(test_qualifiers[i+20].replace('THREAD_LOCAL','thread_local')+' '+var_decl[dest_file](str(i+21))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[4].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(10):
+		TargetFile.write(test_qualifiers[i+30].replace('THREAD_LOCAL','thread_local')+' '+var_decl[dest_file](str(i+31))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[5].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(28):
+		TargetFile.write(test_qualifiers[i+40].replace('THREAD_LOCAL','thread_local')+' '+var_decl[dest_file](str(i+41))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[6].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(28):
+		TargetFile.write(test_qualifiers[i+68].replace('THREAD_LOCAL','thread_local')+' '+var_decl[dest_file](str(i+69))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write('// define-declares\n')
+	TargetFile.write(section_comments[0].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(5):
+		TargetFile.write(test_qualifiers[i].replace('THREAD_LOCAL','thread_local')+' '+var_def[dest_file](str(i+1))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[1].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(4):
+		TargetFile.write(test_qualifiers[i+5].replace('THREAD_LOCAL','thread_local')+' '+var_def[dest_file](str(i+6))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[2].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(11):
+		TargetFile.write(test_qualifiers[i+9].replace('THREAD_LOCAL','thread_local')+' '+var_def[dest_file](str(i+10))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[3].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(10):
+		TargetFile.write(test_qualifiers[i+20].replace('THREAD_LOCAL','thread_local')+' '+var_def[dest_file](str(i+21))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[4].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(10):
+		TargetFile.write(test_qualifiers[i+30].replace('THREAD_LOCAL','thread_local')+' '+var_def[dest_file](str(i+31))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[5].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(28):
+		TargetFile.write(test_qualifiers[i+40].replace('THREAD_LOCAL','thread_local')+' '+var_def[dest_file](str(i+41))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[6].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(28):
+		TargetFile.write(test_qualifiers[i+68].replace('THREAD_LOCAL','thread_local')+' '+var_def[dest_file](str(i+69))+';\n')
+	TargetFile.write('\n')
+
+	# need: keyword suppression works in namespaces
+	TargetFile.write('}	// end namespace test\n\n// check that keyword suppression works in namespaces\nnamespace test2 {\n')
+	TargetFile.write(global_define[dest_file])
+
+	TargetFile.write(section_comments[0].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(5):
+		TargetFile.write(test_qualifiers[i].replace('THREAD_LOCAL','thread_local')+' '+var_decl_terse[dest_file](str(i+1))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[1].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(4):
+		TargetFile.write(test_qualifiers[i+5].replace('THREAD_LOCAL','thread_local')+' '+var_decl_terse[dest_file](str(i+6))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[2].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(11):
+		TargetFile.write(test_qualifiers[i+9].replace('THREAD_LOCAL','thread_local')+' '+var_decl_terse[dest_file](str(i+10))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[3].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(10):
+		TargetFile.write(test_qualifiers[i+20].replace('THREAD_LOCAL','thread_local')+' '+var_decl_terse[dest_file](str(i+21))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[4].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(10):
+		TargetFile.write(test_qualifiers[i+30].replace('THREAD_LOCAL','thread_local')+' '+var_decl_terse[dest_file](str(i+31))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[5].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(28):
+		TargetFile.write(test_qualifiers[i+40].replace('THREAD_LOCAL','thread_local')+' '+var_decl_terse[dest_file](str(i+41))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write(section_comments[6].replace('THREAD_LOCAL','thread_local'))
+	for i in xrange(28):
+		TargetFile.write(test_qualifiers[i+68].replace('THREAD_LOCAL','thread_local')+' '+var_decl_terse[dest_file](str(i+69))+';\n')
+	TargetFile.write('\n')
+
+	TargetFile.write('}	// end namespace test2\n')
+
+	TargetFile.close()
+
 if __name__ == '__main__':
 	for filename in target_files:
 		SpawnTestCase(filename)
 	for filename in target_files2:
 		SpawnTestCase2(filename)
+	for filename in target_files3:
+		SpawnTestCase3(filename)
 



From zaimoni at mail.berlios.de  Sat Apr  9 05:54:20 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat,  9 Apr 2011 05:54:20 +0200
Subject: [Zcplusplus-commits] r627 - trunk/tests/zcc/decl.C99
Message-ID: <20110409035420.4DF13480EF5@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-09 05:54:20 +0200 (Sat, 09 Apr 2011)
New Revision: 627

Modified:
   trunk/tests/zcc/decl.C99/Pass_enum_def2.hpp
Log:
enumerations: thread_local parsing

Modified: trunk/tests/zcc/decl.C99/Pass_enum_def2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_enum_def2.hpp	2011-04-09 03:52:39 UTC (rev 626)
+++ trunk/tests/zcc/decl.C99/Pass_enum_def2.hpp	2011-04-09 03:54:20 UTC (rev 627)
@@ -1,12 +1,11 @@
-// decl.C99\Pass_enum_def2.hpp
+// decl.C99/Pass_enum_def2.hpp
 // using singly defined enum
-// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 enum good_test {
 	x_factor = 1
 };
 
-// this section checks that suppressing enum keyword works
+// this section checks that suppressing keyword works
 // ringing the changes on extern
 extern good_test x1;
 extern const good_test x2;
@@ -28,15 +27,99 @@
 const volatile extern good_test x13;
 volatile extern const good_test x14;
 volatile const extern good_test x15;
-
 volatile static good_test x16;
 const static volatile good_test x17;
 const volatile static good_test x18;
 volatile static const good_test x19;
 volatile const static good_test x20;
 
+// ringing the changes on thread_local extern
+extern thread_local good_test x21;
+extern thread_local const good_test x22;
+extern thread_local volatile good_test x23;
+extern thread_local const volatile good_test x24;
+extern thread_local volatile const good_test x25;
+thread_local extern good_test x26;
+thread_local extern const good_test x27;
+thread_local extern volatile good_test x28;
+thread_local extern const volatile good_test x29;
+thread_local extern volatile const good_test x30;
+
+// ringing the changes on thread_local static
+static thread_local good_test x31;
+static thread_local const good_test x32;
+static thread_local volatile good_test x33;
+static thread_local const volatile good_test x34;
+static thread_local volatile const good_test x35;
+thread_local static good_test x36;
+thread_local static const good_test x37;
+thread_local static volatile good_test x38;
+thread_local static const volatile good_test x39;
+thread_local static volatile const good_test x40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local good_test x41;
+const extern thread_local good_test x42;
+extern volatile thread_local good_test x43;
+volatile extern thread_local good_test x44;
+extern const thread_local volatile good_test x45;
+extern const volatile thread_local good_test x46;
+const extern thread_local volatile good_test x47;
+const extern volatile thread_local good_test x48;
+const volatile extern thread_local good_test x49;
+extern volatile thread_local const good_test x50;
+extern volatile const thread_local good_test x51;
+volatile extern thread_local const good_test x52;
+volatile extern const thread_local good_test x53;
+volatile const extern thread_local good_test x54;
+thread_local const extern good_test x55;
+const thread_local extern good_test x56;
+thread_local volatile extern good_test x57;
+volatile thread_local extern good_test x58;
+thread_local const extern volatile good_test x59;
+thread_local const volatile extern good_test x60;
+const thread_local extern volatile good_test x61;
+const thread_local volatile extern good_test x62;
+const volatile thread_local extern good_test x63;
+thread_local volatile extern const good_test x64;
+thread_local volatile const extern good_test x65;
+volatile thread_local extern const good_test x66;
+volatile thread_local const extern good_test x67;
+volatile const thread_local extern good_test x68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local good_test x69;
+const static thread_local good_test x70;
+static volatile thread_local good_test x71;
+volatile static thread_local good_test x72;
+static const thread_local volatile good_test x73;
+static const volatile thread_local good_test x74;
+const static thread_local volatile good_test x75;
+const static volatile thread_local good_test x76;
+const volatile static thread_local good_test x77;
+static volatile thread_local const good_test x78;
+static volatile const thread_local good_test x79;
+volatile static thread_local const good_test x80;
+volatile static const thread_local good_test x81;
+volatile const static thread_local good_test x82;
+thread_local const static good_test x83;
+const thread_local static good_test x84;
+thread_local volatile static good_test x85;
+volatile thread_local static good_test x86;
+thread_local const static volatile good_test x87;
+thread_local const volatile static good_test x88;
+const thread_local static volatile good_test x89;
+const thread_local volatile static good_test x90;
+const volatile thread_local static good_test x91;
+thread_local volatile static const good_test x92;
+thread_local volatile const static good_test x93;
+volatile thread_local static const good_test x94;
+volatile thread_local const static good_test x95;
+volatile const thread_local static good_test x96;
+
 // check that things work properly in namespaces
 namespace test {
+
 enum good_test {
 	x_factor = 1
 };
@@ -62,45 +145,213 @@
 const volatile extern enum good_test x13;
 volatile extern const enum good_test x14;
 volatile const extern enum good_test x15;
-
 volatile static enum good_test x16;
 const static volatile enum good_test x17;
 const volatile static enum good_test x18;
 volatile static const enum good_test x19;
 volatile const static enum good_test x20;
 
+// ringing the changes on thread_local extern
+extern thread_local enum good_test x21;
+extern thread_local const enum good_test x22;
+extern thread_local volatile enum good_test x23;
+extern thread_local const volatile enum good_test x24;
+extern thread_local volatile const enum good_test x25;
+thread_local extern enum good_test x26;
+thread_local extern const enum good_test x27;
+thread_local extern volatile enum good_test x28;
+thread_local extern const volatile enum good_test x29;
+thread_local extern volatile const enum good_test x30;
+
+// ringing the changes on thread_local static
+static thread_local enum good_test x31;
+static thread_local const enum good_test x32;
+static thread_local volatile enum good_test x33;
+static thread_local const volatile enum good_test x34;
+static thread_local volatile const enum good_test x35;
+thread_local static enum good_test x36;
+thread_local static const enum good_test x37;
+thread_local static volatile enum good_test x38;
+thread_local static const volatile enum good_test x39;
+thread_local static volatile const enum good_test x40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local enum good_test x41;
+const extern thread_local enum good_test x42;
+extern volatile thread_local enum good_test x43;
+volatile extern thread_local enum good_test x44;
+extern const thread_local volatile enum good_test x45;
+extern const volatile thread_local enum good_test x46;
+const extern thread_local volatile enum good_test x47;
+const extern volatile thread_local enum good_test x48;
+const volatile extern thread_local enum good_test x49;
+extern volatile thread_local const enum good_test x50;
+extern volatile const thread_local enum good_test x51;
+volatile extern thread_local const enum good_test x52;
+volatile extern const thread_local enum good_test x53;
+volatile const extern thread_local enum good_test x54;
+thread_local const extern enum good_test x55;
+const thread_local extern enum good_test x56;
+thread_local volatile extern enum good_test x57;
+volatile thread_local extern enum good_test x58;
+thread_local const extern volatile enum good_test x59;
+thread_local const volatile extern enum good_test x60;
+const thread_local extern volatile enum good_test x61;
+const thread_local volatile extern enum good_test x62;
+const volatile thread_local extern enum good_test x63;
+thread_local volatile extern const enum good_test x64;
+thread_local volatile const extern enum good_test x65;
+volatile thread_local extern const enum good_test x66;
+volatile thread_local const extern enum good_test x67;
+volatile const thread_local extern enum good_test x68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local enum good_test x69;
+const static thread_local enum good_test x70;
+static volatile thread_local enum good_test x71;
+volatile static thread_local enum good_test x72;
+static const thread_local volatile enum good_test x73;
+static const volatile thread_local enum good_test x74;
+const static thread_local volatile enum good_test x75;
+const static volatile thread_local enum good_test x76;
+const volatile static thread_local enum good_test x77;
+static volatile thread_local const enum good_test x78;
+static volatile const thread_local enum good_test x79;
+volatile static thread_local const enum good_test x80;
+volatile static const thread_local enum good_test x81;
+volatile const static thread_local enum good_test x82;
+thread_local const static enum good_test x83;
+const thread_local static enum good_test x84;
+thread_local volatile static enum good_test x85;
+volatile thread_local static enum good_test x86;
+thread_local const static volatile enum good_test x87;
+thread_local const volatile static enum good_test x88;
+const thread_local static volatile enum good_test x89;
+const thread_local volatile static enum good_test x90;
+const volatile thread_local static enum good_test x91;
+thread_local volatile static const enum good_test x92;
+thread_local volatile const static enum good_test x93;
+volatile thread_local static const enum good_test x94;
+volatile thread_local const static enum good_test x95;
+volatile const thread_local static enum good_test x96;
+
 // define-declares
 // ringing the changes on extern
-extern enum good_test2 { x_factor2 = 1 } x21;
-extern const enum good_test3 { x_factor3 = 1 } x22;
-extern volatile enum good_test4 { x_factor4 = 1 } x23;
-extern const volatile enum good_test5 { x_factor5 = 1 } x24;
-extern volatile const enum good_test6 { x_factor6 = 1 } x25;
+extern enum good_test1 { x_factor1 = 1 } x_1;
+extern const enum good_test2 { x_factor2 = 1 } x_2;
+extern volatile enum good_test3 { x_factor3 = 1 } x_3;
+extern const volatile enum good_test4 { x_factor4 = 1 } x_4;
+extern volatile const enum good_test5 { x_factor5 = 1 } x_5;
 
 // ringing the changes on static
 // (don't test static const -- no chance to initialize before use)
-static enum good_test7 { x_factor7 = 1 } x26;
-static volatile enum good_test8 { x_factor8 = 1 } x27;
-static const volatile enum good_test9 { x_factor9 = 1 } x28;
-static volatile const enum good_test10 { x_factor10 = 1 } x29;
+static enum good_test6 { x_factor6 = 1 } x_6;
+static volatile enum good_test7 { x_factor7 = 1 } x_7;
+static const volatile enum good_test8 { x_factor8 = 1 } x_8;
+static volatile const enum good_test9 { x_factor9 = 1 } x_9;
 
 // extern/static not in first postion is deprecated, but legal
-const extern enum good_test11 { x_factor11 = 1 } x30;
-volatile extern enum good_test12 { x_factor12 = 1 } x31;
-const extern volatile enum good_test13 { x_factor13 = 1 } x32;
-const volatile extern enum good_test14 { x_factor14 = 1 } x33;
-volatile extern const enum good_test15 { x_factor15 = 1 } x34;
-volatile const extern enum good_test16 { x_factor16 = 1 } x35;
+const extern enum good_test10 { x_factor10 = 1 } x_10;
+volatile extern enum good_test11 { x_factor11 = 1 } x_11;
+const extern volatile enum good_test12 { x_factor12 = 1 } x_12;
+const volatile extern enum good_test13 { x_factor13 = 1 } x_13;
+volatile extern const enum good_test14 { x_factor14 = 1 } x_14;
+volatile const extern enum good_test15 { x_factor15 = 1 } x_15;
+volatile static enum good_test16 { x_factor16 = 1 } x_16;
+const static volatile enum good_test17 { x_factor17 = 1 } x_17;
+const volatile static enum good_test18 { x_factor18 = 1 } x_18;
+volatile static const enum good_test19 { x_factor19 = 1 } x_19;
+volatile const static enum good_test20 { x_factor20 = 1 } x_20;
 
-volatile static enum good_test17 { x_factor17 = 1 } x16;
-const static volatile enum good_test18 { x_factor18 = 1 } x37;
-const volatile static enum good_test19 { x_factor19 = 1 } x38;
-volatile static const enum good_test20 { x_factor20 = 1 } x39;
-volatile const static enum good_test21 { x_factor21 = 1 } x40;
+// ringing the changes on thread_local extern
+extern thread_local enum good_test21 { x_factor21 = 1 } x_21;
+extern thread_local const enum good_test22 { x_factor22 = 1 } x_22;
+extern thread_local volatile enum good_test23 { x_factor23 = 1 } x_23;
+extern thread_local const volatile enum good_test24 { x_factor24 = 1 } x_24;
+extern thread_local volatile const enum good_test25 { x_factor25 = 1 } x_25;
+thread_local extern enum good_test26 { x_factor26 = 1 } x_26;
+thread_local extern const enum good_test27 { x_factor27 = 1 } x_27;
+thread_local extern volatile enum good_test28 { x_factor28 = 1 } x_28;
+thread_local extern const volatile enum good_test29 { x_factor29 = 1 } x_29;
+thread_local extern volatile const enum good_test30 { x_factor30 = 1 } x_30;
+
+// ringing the changes on thread_local static
+static thread_local enum good_test31 { x_factor31 = 1 } x_31;
+static thread_local const enum good_test32 { x_factor32 = 1 } x_32;
+static thread_local volatile enum good_test33 { x_factor33 = 1 } x_33;
+static thread_local const volatile enum good_test34 { x_factor34 = 1 } x_34;
+static thread_local volatile const enum good_test35 { x_factor35 = 1 } x_35;
+thread_local static enum good_test36 { x_factor36 = 1 } x_36;
+thread_local static const enum good_test37 { x_factor37 = 1 } x_37;
+thread_local static volatile enum good_test38 { x_factor38 = 1 } x_38;
+thread_local static const volatile enum good_test39 { x_factor39 = 1 } x_39;
+thread_local static volatile const enum good_test40 { x_factor40 = 1 } x_40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local enum good_test41 { x_factor41 = 1 } x_41;
+const extern thread_local enum good_test42 { x_factor42 = 1 } x_42;
+extern volatile thread_local enum good_test43 { x_factor43 = 1 } x_43;
+volatile extern thread_local enum good_test44 { x_factor44 = 1 } x_44;
+extern const thread_local volatile enum good_test45 { x_factor45 = 1 } x_45;
+extern const volatile thread_local enum good_test46 { x_factor46 = 1 } x_46;
+const extern thread_local volatile enum good_test47 { x_factor47 = 1 } x_47;
+const extern volatile thread_local enum good_test48 { x_factor48 = 1 } x_48;
+const volatile extern thread_local enum good_test49 { x_factor49 = 1 } x_49;
+extern volatile thread_local const enum good_test50 { x_factor50 = 1 } x_50;
+extern volatile const thread_local enum good_test51 { x_factor51 = 1 } x_51;
+volatile extern thread_local const enum good_test52 { x_factor52 = 1 } x_52;
+volatile extern const thread_local enum good_test53 { x_factor53 = 1 } x_53;
+volatile const extern thread_local enum good_test54 { x_factor54 = 1 } x_54;
+thread_local const extern enum good_test55 { x_factor55 = 1 } x_55;
+const thread_local extern enum good_test56 { x_factor56 = 1 } x_56;
+thread_local volatile extern enum good_test57 { x_factor57 = 1 } x_57;
+volatile thread_local extern enum good_test58 { x_factor58 = 1 } x_58;
+thread_local const extern volatile enum good_test59 { x_factor59 = 1 } x_59;
+thread_local const volatile extern enum good_test60 { x_factor60 = 1 } x_60;
+const thread_local extern volatile enum good_test61 { x_factor61 = 1 } x_61;
+const thread_local volatile extern enum good_test62 { x_factor62 = 1 } x_62;
+const volatile thread_local extern enum good_test63 { x_factor63 = 1 } x_63;
+thread_local volatile extern const enum good_test64 { x_factor64 = 1 } x_64;
+thread_local volatile const extern enum good_test65 { x_factor65 = 1 } x_65;
+volatile thread_local extern const enum good_test66 { x_factor66 = 1 } x_66;
+volatile thread_local const extern enum good_test67 { x_factor67 = 1 } x_67;
+volatile const thread_local extern enum good_test68 { x_factor68 = 1 } x_68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local enum good_test69 { x_factor69 = 1 } x_69;
+const static thread_local enum good_test70 { x_factor70 = 1 } x_70;
+static volatile thread_local enum good_test71 { x_factor71 = 1 } x_71;
+volatile static thread_local enum good_test72 { x_factor72 = 1 } x_72;
+static const thread_local volatile enum good_test73 { x_factor73 = 1 } x_73;
+static const volatile thread_local enum good_test74 { x_factor74 = 1 } x_74;
+const static thread_local volatile enum good_test75 { x_factor75 = 1 } x_75;
+const static volatile thread_local enum good_test76 { x_factor76 = 1 } x_76;
+const volatile static thread_local enum good_test77 { x_factor77 = 1 } x_77;
+static volatile thread_local const enum good_test78 { x_factor78 = 1 } x_78;
+static volatile const thread_local enum good_test79 { x_factor79 = 1 } x_79;
+volatile static thread_local const enum good_test80 { x_factor80 = 1 } x_80;
+volatile static const thread_local enum good_test81 { x_factor81 = 1 } x_81;
+volatile const static thread_local enum good_test82 { x_factor82 = 1 } x_82;
+thread_local const static enum good_test83 { x_factor83 = 1 } x_83;
+const thread_local static enum good_test84 { x_factor84 = 1 } x_84;
+thread_local volatile static enum good_test85 { x_factor85 = 1 } x_85;
+volatile thread_local static enum good_test86 { x_factor86 = 1 } x_86;
+thread_local const static volatile enum good_test87 { x_factor87 = 1 } x_87;
+thread_local const volatile static enum good_test88 { x_factor88 = 1 } x_88;
+const thread_local static volatile enum good_test89 { x_factor89 = 1 } x_89;
+const thread_local volatile static enum good_test90 { x_factor90 = 1 } x_90;
+const volatile thread_local static enum good_test91 { x_factor91 = 1 } x_91;
+thread_local volatile static const enum good_test92 { x_factor92 = 1 } x_92;
+thread_local volatile const static enum good_test93 { x_factor93 = 1 } x_93;
+volatile thread_local static const enum good_test94 { x_factor94 = 1 } x_94;
+volatile thread_local const static enum good_test95 { x_factor95 = 1 } x_95;
+volatile const thread_local static enum good_test96 { x_factor96 = 1 } x_96;
+
 }	// end namespace test
 
-// check that enum suppression works in namespaces
+// check that keyword suppression works in namespaces
 namespace test2 {
+
 enum good_test {
 	x_factor = 1
 };
@@ -126,11 +377,94 @@
 const volatile extern good_test x13;
 volatile extern const good_test x14;
 volatile const extern good_test x15;
-
 volatile static good_test x16;
 const static volatile good_test x17;
 const volatile static good_test x18;
 volatile static const good_test x19;
 volatile const static good_test x20;
 
+// ringing the changes on thread_local extern
+extern thread_local good_test x21;
+extern thread_local const good_test x22;
+extern thread_local volatile good_test x23;
+extern thread_local const volatile good_test x24;
+extern thread_local volatile const good_test x25;
+thread_local extern good_test x26;
+thread_local extern const good_test x27;
+thread_local extern volatile good_test x28;
+thread_local extern const volatile good_test x29;
+thread_local extern volatile const good_test x30;
+
+// ringing the changes on thread_local static
+static thread_local good_test x31;
+static thread_local const good_test x32;
+static thread_local volatile good_test x33;
+static thread_local const volatile good_test x34;
+static thread_local volatile const good_test x35;
+thread_local static good_test x36;
+thread_local static const good_test x37;
+thread_local static volatile good_test x38;
+thread_local static const volatile good_test x39;
+thread_local static volatile const good_test x40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local good_test x41;
+const extern thread_local good_test x42;
+extern volatile thread_local good_test x43;
+volatile extern thread_local good_test x44;
+extern const thread_local volatile good_test x45;
+extern const volatile thread_local good_test x46;
+const extern thread_local volatile good_test x47;
+const extern volatile thread_local good_test x48;
+const volatile extern thread_local good_test x49;
+extern volatile thread_local const good_test x50;
+extern volatile const thread_local good_test x51;
+volatile extern thread_local const good_test x52;
+volatile extern const thread_local good_test x53;
+volatile const extern thread_local good_test x54;
+thread_local const extern good_test x55;
+const thread_local extern good_test x56;
+thread_local volatile extern good_test x57;
+volatile thread_local extern good_test x58;
+thread_local const extern volatile good_test x59;
+thread_local const volatile extern good_test x60;
+const thread_local extern volatile good_test x61;
+const thread_local volatile extern good_test x62;
+const volatile thread_local extern good_test x63;
+thread_local volatile extern const good_test x64;
+thread_local volatile const extern good_test x65;
+volatile thread_local extern const good_test x66;
+volatile thread_local const extern good_test x67;
+volatile const thread_local extern good_test x68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local good_test x69;
+const static thread_local good_test x70;
+static volatile thread_local good_test x71;
+volatile static thread_local good_test x72;
+static const thread_local volatile good_test x73;
+static const volatile thread_local good_test x74;
+const static thread_local volatile good_test x75;
+const static volatile thread_local good_test x76;
+const volatile static thread_local good_test x77;
+static volatile thread_local const good_test x78;
+static volatile const thread_local good_test x79;
+volatile static thread_local const good_test x80;
+volatile static const thread_local good_test x81;
+volatile const static thread_local good_test x82;
+thread_local const static good_test x83;
+const thread_local static good_test x84;
+thread_local volatile static good_test x85;
+volatile thread_local static good_test x86;
+thread_local const static volatile good_test x87;
+thread_local const volatile static good_test x88;
+const thread_local static volatile good_test x89;
+const thread_local volatile static good_test x90;
+const volatile thread_local static good_test x91;
+thread_local volatile static const good_test x92;
+thread_local volatile const static good_test x93;
+volatile thread_local static const good_test x94;
+volatile thread_local const static good_test x95;
+volatile const thread_local static good_test x96;
+
 }	// end namespace test2



From zaimoni at mail.berlios.de  Sat Apr  9 05:54:40 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat,  9 Apr 2011 05:54:40 +0200
Subject: [Zcplusplus-commits] r628 - trunk/tests/zcc/decl.C99
Message-ID: <20110409035440.2BC06480EF5@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-09 05:54:39 +0200 (Sat, 09 Apr 2011)
New Revision: 628

Modified:
   trunk/tests/zcc/decl.C99/Pass_struct_def2.hpp
Log:
structs: thread_local parsing

Modified: trunk/tests/zcc/decl.C99/Pass_struct_def2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_struct_def2.hpp	2011-04-09 03:54:20 UTC (rev 627)
+++ trunk/tests/zcc/decl.C99/Pass_struct_def2.hpp	2011-04-09 03:54:39 UTC (rev 628)
@@ -1,12 +1,11 @@
-// decl.C99\Pass_struct_def2.hpp
+// decl.C99/Pass_struct_def2.hpp
 // using singly defined struct
-// (C)2011 Kenneth Boyd, license: MIT.txt
 
 struct good_test {
-	int x_factor;
+	int x_factor
 };
 
-// this section checks that suppressing struct keyword works
+// this section checks that suppressing keyword works
 // ringing the changes on extern
 extern good_test x1;
 extern const good_test x2;
@@ -28,17 +27,101 @@
 const volatile extern good_test x13;
 volatile extern const good_test x14;
 volatile const extern good_test x15;
-
 volatile static good_test x16;
 const static volatile good_test x17;
 const volatile static good_test x18;
 volatile static const good_test x19;
 volatile const static good_test x20;
 
+// ringing the changes on thread_local extern
+extern thread_local good_test x21;
+extern thread_local const good_test x22;
+extern thread_local volatile good_test x23;
+extern thread_local const volatile good_test x24;
+extern thread_local volatile const good_test x25;
+thread_local extern good_test x26;
+thread_local extern const good_test x27;
+thread_local extern volatile good_test x28;
+thread_local extern const volatile good_test x29;
+thread_local extern volatile const good_test x30;
+
+// ringing the changes on thread_local static
+static thread_local good_test x31;
+static thread_local const good_test x32;
+static thread_local volatile good_test x33;
+static thread_local const volatile good_test x34;
+static thread_local volatile const good_test x35;
+thread_local static good_test x36;
+thread_local static const good_test x37;
+thread_local static volatile good_test x38;
+thread_local static const volatile good_test x39;
+thread_local static volatile const good_test x40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local good_test x41;
+const extern thread_local good_test x42;
+extern volatile thread_local good_test x43;
+volatile extern thread_local good_test x44;
+extern const thread_local volatile good_test x45;
+extern const volatile thread_local good_test x46;
+const extern thread_local volatile good_test x47;
+const extern volatile thread_local good_test x48;
+const volatile extern thread_local good_test x49;
+extern volatile thread_local const good_test x50;
+extern volatile const thread_local good_test x51;
+volatile extern thread_local const good_test x52;
+volatile extern const thread_local good_test x53;
+volatile const extern thread_local good_test x54;
+thread_local const extern good_test x55;
+const thread_local extern good_test x56;
+thread_local volatile extern good_test x57;
+volatile thread_local extern good_test x58;
+thread_local const extern volatile good_test x59;
+thread_local const volatile extern good_test x60;
+const thread_local extern volatile good_test x61;
+const thread_local volatile extern good_test x62;
+const volatile thread_local extern good_test x63;
+thread_local volatile extern const good_test x64;
+thread_local volatile const extern good_test x65;
+volatile thread_local extern const good_test x66;
+volatile thread_local const extern good_test x67;
+volatile const thread_local extern good_test x68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local good_test x69;
+const static thread_local good_test x70;
+static volatile thread_local good_test x71;
+volatile static thread_local good_test x72;
+static const thread_local volatile good_test x73;
+static const volatile thread_local good_test x74;
+const static thread_local volatile good_test x75;
+const static volatile thread_local good_test x76;
+const volatile static thread_local good_test x77;
+static volatile thread_local const good_test x78;
+static volatile const thread_local good_test x79;
+volatile static thread_local const good_test x80;
+volatile static const thread_local good_test x81;
+volatile const static thread_local good_test x82;
+thread_local const static good_test x83;
+const thread_local static good_test x84;
+thread_local volatile static good_test x85;
+volatile thread_local static good_test x86;
+thread_local const static volatile good_test x87;
+thread_local const volatile static good_test x88;
+const thread_local static volatile good_test x89;
+const thread_local volatile static good_test x90;
+const volatile thread_local static good_test x91;
+thread_local volatile static const good_test x92;
+thread_local volatile const static good_test x93;
+volatile thread_local static const good_test x94;
+volatile thread_local const static good_test x95;
+volatile const thread_local static good_test x96;
+
 // check that things work properly in namespaces
 namespace test {
+
 struct good_test {
-	int x_factor;
+	int x_factor
 };
 
 // ringing the changes on extern
@@ -62,47 +145,215 @@
 const volatile extern struct good_test x13;
 volatile extern const struct good_test x14;
 volatile const extern struct good_test x15;
-
 volatile static struct good_test x16;
 const static volatile struct good_test x17;
 const volatile static struct good_test x18;
 volatile static const struct good_test x19;
 volatile const static struct good_test x20;
 
+// ringing the changes on thread_local extern
+extern thread_local struct good_test x21;
+extern thread_local const struct good_test x22;
+extern thread_local volatile struct good_test x23;
+extern thread_local const volatile struct good_test x24;
+extern thread_local volatile const struct good_test x25;
+thread_local extern struct good_test x26;
+thread_local extern const struct good_test x27;
+thread_local extern volatile struct good_test x28;
+thread_local extern const volatile struct good_test x29;
+thread_local extern volatile const struct good_test x30;
+
+// ringing the changes on thread_local static
+static thread_local struct good_test x31;
+static thread_local const struct good_test x32;
+static thread_local volatile struct good_test x33;
+static thread_local const volatile struct good_test x34;
+static thread_local volatile const struct good_test x35;
+thread_local static struct good_test x36;
+thread_local static const struct good_test x37;
+thread_local static volatile struct good_test x38;
+thread_local static const volatile struct good_test x39;
+thread_local static volatile const struct good_test x40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local struct good_test x41;
+const extern thread_local struct good_test x42;
+extern volatile thread_local struct good_test x43;
+volatile extern thread_local struct good_test x44;
+extern const thread_local volatile struct good_test x45;
+extern const volatile thread_local struct good_test x46;
+const extern thread_local volatile struct good_test x47;
+const extern volatile thread_local struct good_test x48;
+const volatile extern thread_local struct good_test x49;
+extern volatile thread_local const struct good_test x50;
+extern volatile const thread_local struct good_test x51;
+volatile extern thread_local const struct good_test x52;
+volatile extern const thread_local struct good_test x53;
+volatile const extern thread_local struct good_test x54;
+thread_local const extern struct good_test x55;
+const thread_local extern struct good_test x56;
+thread_local volatile extern struct good_test x57;
+volatile thread_local extern struct good_test x58;
+thread_local const extern volatile struct good_test x59;
+thread_local const volatile extern struct good_test x60;
+const thread_local extern volatile struct good_test x61;
+const thread_local volatile extern struct good_test x62;
+const volatile thread_local extern struct good_test x63;
+thread_local volatile extern const struct good_test x64;
+thread_local volatile const extern struct good_test x65;
+volatile thread_local extern const struct good_test x66;
+volatile thread_local const extern struct good_test x67;
+volatile const thread_local extern struct good_test x68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local struct good_test x69;
+const static thread_local struct good_test x70;
+static volatile thread_local struct good_test x71;
+volatile static thread_local struct good_test x72;
+static const thread_local volatile struct good_test x73;
+static const volatile thread_local struct good_test x74;
+const static thread_local volatile struct good_test x75;
+const static volatile thread_local struct good_test x76;
+const volatile static thread_local struct good_test x77;
+static volatile thread_local const struct good_test x78;
+static volatile const thread_local struct good_test x79;
+volatile static thread_local const struct good_test x80;
+volatile static const thread_local struct good_test x81;
+volatile const static thread_local struct good_test x82;
+thread_local const static struct good_test x83;
+const thread_local static struct good_test x84;
+thread_local volatile static struct good_test x85;
+volatile thread_local static struct good_test x86;
+thread_local const static volatile struct good_test x87;
+thread_local const volatile static struct good_test x88;
+const thread_local static volatile struct good_test x89;
+const thread_local volatile static struct good_test x90;
+const volatile thread_local static struct good_test x91;
+thread_local volatile static const struct good_test x92;
+thread_local volatile const static struct good_test x93;
+volatile thread_local static const struct good_test x94;
+volatile thread_local const static struct good_test x95;
+volatile const thread_local static struct good_test x96;
+
 // define-declares
 // ringing the changes on extern
-extern struct good_test2 { int x_factor2; } x21;
-extern const struct good_test3 { int x_factor3; } x22;
-extern volatile struct good_test4 { int x_factor4; } x23;
-extern const volatile struct good_test5 { int x_factor5; } x24;
-extern volatile const struct good_test6 { int x_factor6; } x25;
+extern struct good_test1 { int x_factor1; } x_1;
+extern const struct good_test2 { int x_factor2; } x_2;
+extern volatile struct good_test3 { int x_factor3; } x_3;
+extern const volatile struct good_test4 { int x_factor4; } x_4;
+extern volatile const struct good_test5 { int x_factor5; } x_5;
 
 // ringing the changes on static
 // (don't test static const -- no chance to initialize before use)
-static struct good_test7 { int x_factor7; } x26;
-static volatile struct good_test8 { int x_factor8; } x27;
-static const volatile struct good_test9 { int x_factor9; } x28;
-static volatile const struct good_test10 { int x_factor10; } x29;
+static struct good_test6 { int x_factor6; } x_6;
+static volatile struct good_test7 { int x_factor7; } x_7;
+static const volatile struct good_test8 { int x_factor8; } x_8;
+static volatile const struct good_test9 { int x_factor9; } x_9;
 
 // extern/static not in first postion is deprecated, but legal
-const extern struct good_test11 { int x_factor11; } x30;
-volatile extern struct good_test12 { int x_factor12; } x31;
-const extern volatile struct good_test13 { int x_factor13; } x32;
-const volatile extern struct good_test14 { int x_factor14; } x33;
-volatile extern const struct good_test15 { int x_factor15; } x34;
-volatile const extern struct good_test16 { int x_factor16; } x35;
+const extern struct good_test10 { int x_factor10; } x_10;
+volatile extern struct good_test11 { int x_factor11; } x_11;
+const extern volatile struct good_test12 { int x_factor12; } x_12;
+const volatile extern struct good_test13 { int x_factor13; } x_13;
+volatile extern const struct good_test14 { int x_factor14; } x_14;
+volatile const extern struct good_test15 { int x_factor15; } x_15;
+volatile static struct good_test16 { int x_factor16; } x_16;
+const static volatile struct good_test17 { int x_factor17; } x_17;
+const volatile static struct good_test18 { int x_factor18; } x_18;
+volatile static const struct good_test19 { int x_factor19; } x_19;
+volatile const static struct good_test20 { int x_factor20; } x_20;
 
-volatile static struct good_test17 { int x_factor17; } x16;
-const static volatile struct good_test18 { int x_factor18; } x37;
-const volatile static struct good_test19 { int x_factor19; } x38;
-volatile static const struct good_test20 { int x_factor20; } x39;
-volatile const static struct good_test21 { int x_factor21; } x40;
+// ringing the changes on thread_local extern
+extern thread_local struct good_test21 { int x_factor21; } x_21;
+extern thread_local const struct good_test22 { int x_factor22; } x_22;
+extern thread_local volatile struct good_test23 { int x_factor23; } x_23;
+extern thread_local const volatile struct good_test24 { int x_factor24; } x_24;
+extern thread_local volatile const struct good_test25 { int x_factor25; } x_25;
+thread_local extern struct good_test26 { int x_factor26; } x_26;
+thread_local extern const struct good_test27 { int x_factor27; } x_27;
+thread_local extern volatile struct good_test28 { int x_factor28; } x_28;
+thread_local extern const volatile struct good_test29 { int x_factor29; } x_29;
+thread_local extern volatile const struct good_test30 { int x_factor30; } x_30;
+
+// ringing the changes on thread_local static
+static thread_local struct good_test31 { int x_factor31; } x_31;
+static thread_local const struct good_test32 { int x_factor32; } x_32;
+static thread_local volatile struct good_test33 { int x_factor33; } x_33;
+static thread_local const volatile struct good_test34 { int x_factor34; } x_34;
+static thread_local volatile const struct good_test35 { int x_factor35; } x_35;
+thread_local static struct good_test36 { int x_factor36; } x_36;
+thread_local static const struct good_test37 { int x_factor37; } x_37;
+thread_local static volatile struct good_test38 { int x_factor38; } x_38;
+thread_local static const volatile struct good_test39 { int x_factor39; } x_39;
+thread_local static volatile const struct good_test40 { int x_factor40; } x_40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local struct good_test41 { int x_factor41; } x_41;
+const extern thread_local struct good_test42 { int x_factor42; } x_42;
+extern volatile thread_local struct good_test43 { int x_factor43; } x_43;
+volatile extern thread_local struct good_test44 { int x_factor44; } x_44;
+extern const thread_local volatile struct good_test45 { int x_factor45; } x_45;
+extern const volatile thread_local struct good_test46 { int x_factor46; } x_46;
+const extern thread_local volatile struct good_test47 { int x_factor47; } x_47;
+const extern volatile thread_local struct good_test48 { int x_factor48; } x_48;
+const volatile extern thread_local struct good_test49 { int x_factor49; } x_49;
+extern volatile thread_local const struct good_test50 { int x_factor50; } x_50;
+extern volatile const thread_local struct good_test51 { int x_factor51; } x_51;
+volatile extern thread_local const struct good_test52 { int x_factor52; } x_52;
+volatile extern const thread_local struct good_test53 { int x_factor53; } x_53;
+volatile const extern thread_local struct good_test54 { int x_factor54; } x_54;
+thread_local const extern struct good_test55 { int x_factor55; } x_55;
+const thread_local extern struct good_test56 { int x_factor56; } x_56;
+thread_local volatile extern struct good_test57 { int x_factor57; } x_57;
+volatile thread_local extern struct good_test58 { int x_factor58; } x_58;
+thread_local const extern volatile struct good_test59 { int x_factor59; } x_59;
+thread_local const volatile extern struct good_test60 { int x_factor60; } x_60;
+const thread_local extern volatile struct good_test61 { int x_factor61; } x_61;
+const thread_local volatile extern struct good_test62 { int x_factor62; } x_62;
+const volatile thread_local extern struct good_test63 { int x_factor63; } x_63;
+thread_local volatile extern const struct good_test64 { int x_factor64; } x_64;
+thread_local volatile const extern struct good_test65 { int x_factor65; } x_65;
+volatile thread_local extern const struct good_test66 { int x_factor66; } x_66;
+volatile thread_local const extern struct good_test67 { int x_factor67; } x_67;
+volatile const thread_local extern struct good_test68 { int x_factor68; } x_68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local struct good_test69 { int x_factor69; } x_69;
+const static thread_local struct good_test70 { int x_factor70; } x_70;
+static volatile thread_local struct good_test71 { int x_factor71; } x_71;
+volatile static thread_local struct good_test72 { int x_factor72; } x_72;
+static const thread_local volatile struct good_test73 { int x_factor73; } x_73;
+static const volatile thread_local struct good_test74 { int x_factor74; } x_74;
+const static thread_local volatile struct good_test75 { int x_factor75; } x_75;
+const static volatile thread_local struct good_test76 { int x_factor76; } x_76;
+const volatile static thread_local struct good_test77 { int x_factor77; } x_77;
+static volatile thread_local const struct good_test78 { int x_factor78; } x_78;
+static volatile const thread_local struct good_test79 { int x_factor79; } x_79;
+volatile static thread_local const struct good_test80 { int x_factor80; } x_80;
+volatile static const thread_local struct good_test81 { int x_factor81; } x_81;
+volatile const static thread_local struct good_test82 { int x_factor82; } x_82;
+thread_local const static struct good_test83 { int x_factor83; } x_83;
+const thread_local static struct good_test84 { int x_factor84; } x_84;
+thread_local volatile static struct good_test85 { int x_factor85; } x_85;
+volatile thread_local static struct good_test86 { int x_factor86; } x_86;
+thread_local const static volatile struct good_test87 { int x_factor87; } x_87;
+thread_local const volatile static struct good_test88 { int x_factor88; } x_88;
+const thread_local static volatile struct good_test89 { int x_factor89; } x_89;
+const thread_local volatile static struct good_test90 { int x_factor90; } x_90;
+const volatile thread_local static struct good_test91 { int x_factor91; } x_91;
+thread_local volatile static const struct good_test92 { int x_factor92; } x_92;
+thread_local volatile const static struct good_test93 { int x_factor93; } x_93;
+volatile thread_local static const struct good_test94 { int x_factor94; } x_94;
+volatile thread_local const static struct good_test95 { int x_factor95; } x_95;
+volatile const thread_local static struct good_test96 { int x_factor96; } x_96;
+
 }	// end namespace test
 
-// check that struct suppression works in namespaces
+// check that keyword suppression works in namespaces
 namespace test2 {
+
 struct good_test {
-	int x_factor;
+	int x_factor
 };
 
 // ringing the changes on extern
@@ -126,11 +377,94 @@
 const volatile extern good_test x13;
 volatile extern const good_test x14;
 volatile const extern good_test x15;
-
 volatile static good_test x16;
 const static volatile good_test x17;
 const volatile static good_test x18;
 volatile static const good_test x19;
 volatile const static good_test x20;
 
+// ringing the changes on thread_local extern
+extern thread_local good_test x21;
+extern thread_local const good_test x22;
+extern thread_local volatile good_test x23;
+extern thread_local const volatile good_test x24;
+extern thread_local volatile const good_test x25;
+thread_local extern good_test x26;
+thread_local extern const good_test x27;
+thread_local extern volatile good_test x28;
+thread_local extern const volatile good_test x29;
+thread_local extern volatile const good_test x30;
+
+// ringing the changes on thread_local static
+static thread_local good_test x31;
+static thread_local const good_test x32;
+static thread_local volatile good_test x33;
+static thread_local const volatile good_test x34;
+static thread_local volatile const good_test x35;
+thread_local static good_test x36;
+thread_local static const good_test x37;
+thread_local static volatile good_test x38;
+thread_local static const volatile good_test x39;
+thread_local static volatile const good_test x40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local good_test x41;
+const extern thread_local good_test x42;
+extern volatile thread_local good_test x43;
+volatile extern thread_local good_test x44;
+extern const thread_local volatile good_test x45;
+extern const volatile thread_local good_test x46;
+const extern thread_local volatile good_test x47;
+const extern volatile thread_local good_test x48;
+const volatile extern thread_local good_test x49;
+extern volatile thread_local const good_test x50;
+extern volatile const thread_local good_test x51;
+volatile extern thread_local const good_test x52;
+volatile extern const thread_local good_test x53;
+volatile const extern thread_local good_test x54;
+thread_local const extern good_test x55;
+const thread_local extern good_test x56;
+thread_local volatile extern good_test x57;
+volatile thread_local extern good_test x58;
+thread_local const extern volatile good_test x59;
+thread_local const volatile extern good_test x60;
+const thread_local extern volatile good_test x61;
+const thread_local volatile extern good_test x62;
+const volatile thread_local extern good_test x63;
+thread_local volatile extern const good_test x64;
+thread_local volatile const extern good_test x65;
+volatile thread_local extern const good_test x66;
+volatile thread_local const extern good_test x67;
+volatile const thread_local extern good_test x68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local good_test x69;
+const static thread_local good_test x70;
+static volatile thread_local good_test x71;
+volatile static thread_local good_test x72;
+static const thread_local volatile good_test x73;
+static const volatile thread_local good_test x74;
+const static thread_local volatile good_test x75;
+const static volatile thread_local good_test x76;
+const volatile static thread_local good_test x77;
+static volatile thread_local const good_test x78;
+static volatile const thread_local good_test x79;
+volatile static thread_local const good_test x80;
+volatile static const thread_local good_test x81;
+volatile const static thread_local good_test x82;
+thread_local const static good_test x83;
+const thread_local static good_test x84;
+thread_local volatile static good_test x85;
+volatile thread_local static good_test x86;
+thread_local const static volatile good_test x87;
+thread_local const volatile static good_test x88;
+const thread_local static volatile good_test x89;
+const thread_local volatile static good_test x90;
+const volatile thread_local static good_test x91;
+thread_local volatile static const good_test x92;
+thread_local volatile const static good_test x93;
+volatile thread_local static const good_test x94;
+volatile thread_local const static good_test x95;
+volatile const thread_local static good_test x96;
+
 }	// end namespace test2



From zaimoni at mail.berlios.de  Sat Apr  9 05:54:56 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat,  9 Apr 2011 05:54:56 +0200
Subject: [Zcplusplus-commits] r629 - trunk/tests/zcc/decl.C99
Message-ID: <20110409035456.298CA480EF5@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-09 05:54:55 +0200 (Sat, 09 Apr 2011)
New Revision: 629

Modified:
   trunk/tests/zcc/decl.C99/Pass_union_def2.hpp
Log:
unions: thread_local parsing

Modified: trunk/tests/zcc/decl.C99/Pass_union_def2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_union_def2.hpp	2011-04-09 03:54:39 UTC (rev 628)
+++ trunk/tests/zcc/decl.C99/Pass_union_def2.hpp	2011-04-09 03:54:55 UTC (rev 629)
@@ -1,12 +1,11 @@
-// decl.C99\Pass_union_def2.hpp
+// decl.C99/Pass_union_def2.hpp
 // using singly defined union
-// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 union good_test {
-	int x_factor;
+	int x_factor
 };
 
-// this section checks that suppressing union keyword works
+// this section checks that suppressing keyword works
 // ringing the changes on extern
 extern good_test x1;
 extern const good_test x2;
@@ -28,17 +27,101 @@
 const volatile extern good_test x13;
 volatile extern const good_test x14;
 volatile const extern good_test x15;
-
 volatile static good_test x16;
 const static volatile good_test x17;
 const volatile static good_test x18;
 volatile static const good_test x19;
 volatile const static good_test x20;
 
+// ringing the changes on thread_local extern
+extern thread_local good_test x21;
+extern thread_local const good_test x22;
+extern thread_local volatile good_test x23;
+extern thread_local const volatile good_test x24;
+extern thread_local volatile const good_test x25;
+thread_local extern good_test x26;
+thread_local extern const good_test x27;
+thread_local extern volatile good_test x28;
+thread_local extern const volatile good_test x29;
+thread_local extern volatile const good_test x30;
+
+// ringing the changes on thread_local static
+static thread_local good_test x31;
+static thread_local const good_test x32;
+static thread_local volatile good_test x33;
+static thread_local const volatile good_test x34;
+static thread_local volatile const good_test x35;
+thread_local static good_test x36;
+thread_local static const good_test x37;
+thread_local static volatile good_test x38;
+thread_local static const volatile good_test x39;
+thread_local static volatile const good_test x40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local good_test x41;
+const extern thread_local good_test x42;
+extern volatile thread_local good_test x43;
+volatile extern thread_local good_test x44;
+extern const thread_local volatile good_test x45;
+extern const volatile thread_local good_test x46;
+const extern thread_local volatile good_test x47;
+const extern volatile thread_local good_test x48;
+const volatile extern thread_local good_test x49;
+extern volatile thread_local const good_test x50;
+extern volatile const thread_local good_test x51;
+volatile extern thread_local const good_test x52;
+volatile extern const thread_local good_test x53;
+volatile const extern thread_local good_test x54;
+thread_local const extern good_test x55;
+const thread_local extern good_test x56;
+thread_local volatile extern good_test x57;
+volatile thread_local extern good_test x58;
+thread_local const extern volatile good_test x59;
+thread_local const volatile extern good_test x60;
+const thread_local extern volatile good_test x61;
+const thread_local volatile extern good_test x62;
+const volatile thread_local extern good_test x63;
+thread_local volatile extern const good_test x64;
+thread_local volatile const extern good_test x65;
+volatile thread_local extern const good_test x66;
+volatile thread_local const extern good_test x67;
+volatile const thread_local extern good_test x68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local good_test x69;
+const static thread_local good_test x70;
+static volatile thread_local good_test x71;
+volatile static thread_local good_test x72;
+static const thread_local volatile good_test x73;
+static const volatile thread_local good_test x74;
+const static thread_local volatile good_test x75;
+const static volatile thread_local good_test x76;
+const volatile static thread_local good_test x77;
+static volatile thread_local const good_test x78;
+static volatile const thread_local good_test x79;
+volatile static thread_local const good_test x80;
+volatile static const thread_local good_test x81;
+volatile const static thread_local good_test x82;
+thread_local const static good_test x83;
+const thread_local static good_test x84;
+thread_local volatile static good_test x85;
+volatile thread_local static good_test x86;
+thread_local const static volatile good_test x87;
+thread_local const volatile static good_test x88;
+const thread_local static volatile good_test x89;
+const thread_local volatile static good_test x90;
+const volatile thread_local static good_test x91;
+thread_local volatile static const good_test x92;
+thread_local volatile const static good_test x93;
+volatile thread_local static const good_test x94;
+volatile thread_local const static good_test x95;
+volatile const thread_local static good_test x96;
+
 // check that things work properly in namespaces
 namespace test {
+
 union good_test {
-	int x_factor;
+	int x_factor
 };
 
 // ringing the changes on extern
@@ -62,47 +145,215 @@
 const volatile extern union good_test x13;
 volatile extern const union good_test x14;
 volatile const extern union good_test x15;
-
 volatile static union good_test x16;
 const static volatile union good_test x17;
 const volatile static union good_test x18;
 volatile static const union good_test x19;
 volatile const static union good_test x20;
 
+// ringing the changes on thread_local extern
+extern thread_local union good_test x21;
+extern thread_local const union good_test x22;
+extern thread_local volatile union good_test x23;
+extern thread_local const volatile union good_test x24;
+extern thread_local volatile const union good_test x25;
+thread_local extern union good_test x26;
+thread_local extern const union good_test x27;
+thread_local extern volatile union good_test x28;
+thread_local extern const volatile union good_test x29;
+thread_local extern volatile const union good_test x30;
+
+// ringing the changes on thread_local static
+static thread_local union good_test x31;
+static thread_local const union good_test x32;
+static thread_local volatile union good_test x33;
+static thread_local const volatile union good_test x34;
+static thread_local volatile const union good_test x35;
+thread_local static union good_test x36;
+thread_local static const union good_test x37;
+thread_local static volatile union good_test x38;
+thread_local static const volatile union good_test x39;
+thread_local static volatile const union good_test x40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local union good_test x41;
+const extern thread_local union good_test x42;
+extern volatile thread_local union good_test x43;
+volatile extern thread_local union good_test x44;
+extern const thread_local volatile union good_test x45;
+extern const volatile thread_local union good_test x46;
+const extern thread_local volatile union good_test x47;
+const extern volatile thread_local union good_test x48;
+const volatile extern thread_local union good_test x49;
+extern volatile thread_local const union good_test x50;
+extern volatile const thread_local union good_test x51;
+volatile extern thread_local const union good_test x52;
+volatile extern const thread_local union good_test x53;
+volatile const extern thread_local union good_test x54;
+thread_local const extern union good_test x55;
+const thread_local extern union good_test x56;
+thread_local volatile extern union good_test x57;
+volatile thread_local extern union good_test x58;
+thread_local const extern volatile union good_test x59;
+thread_local const volatile extern union good_test x60;
+const thread_local extern volatile union good_test x61;
+const thread_local volatile extern union good_test x62;
+const volatile thread_local extern union good_test x63;
+thread_local volatile extern const union good_test x64;
+thread_local volatile const extern union good_test x65;
+volatile thread_local extern const union good_test x66;
+volatile thread_local const extern union good_test x67;
+volatile const thread_local extern union good_test x68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local union good_test x69;
+const static thread_local union good_test x70;
+static volatile thread_local union good_test x71;
+volatile static thread_local union good_test x72;
+static const thread_local volatile union good_test x73;
+static const volatile thread_local union good_test x74;
+const static thread_local volatile union good_test x75;
+const static volatile thread_local union good_test x76;
+const volatile static thread_local union good_test x77;
+static volatile thread_local const union good_test x78;
+static volatile const thread_local union good_test x79;
+volatile static thread_local const union good_test x80;
+volatile static const thread_local union good_test x81;
+volatile const static thread_local union good_test x82;
+thread_local const static union good_test x83;
+const thread_local static union good_test x84;
+thread_local volatile static union good_test x85;
+volatile thread_local static union good_test x86;
+thread_local const static volatile union good_test x87;
+thread_local const volatile static union good_test x88;
+const thread_local static volatile union good_test x89;
+const thread_local volatile static union good_test x90;
+const volatile thread_local static union good_test x91;
+thread_local volatile static const union good_test x92;
+thread_local volatile const static union good_test x93;
+volatile thread_local static const union good_test x94;
+volatile thread_local const static union good_test x95;
+volatile const thread_local static union good_test x96;
+
 // define-declares
 // ringing the changes on extern
-extern union good_test2 { int x_factor2; } x21;
-extern const union good_test3 { int x_factor3; } x22;
-extern volatile union good_test4 { int x_factor4; } x23;
-extern const volatile union good_test5 { int x_factor5; } x24;
-extern volatile const union good_test6 { int x_factor6; } x25;
+extern union good_test1 { int x_factor1; } x_1;
+extern const union good_test2 { int x_factor2; } x_2;
+extern volatile union good_test3 { int x_factor3; } x_3;
+extern const volatile union good_test4 { int x_factor4; } x_4;
+extern volatile const union good_test5 { int x_factor5; } x_5;
 
 // ringing the changes on static
 // (don't test static const -- no chance to initialize before use)
-static union good_test7 { int x_factor7; } x26;
-static volatile union good_test8 { int x_factor8; } x27;
-static const volatile union good_test9 { int x_factor9; } x28;
-static volatile const union good_test10 { int x_factor10; } x29;
+static union good_test6 { int x_factor6; } x_6;
+static volatile union good_test7 { int x_factor7; } x_7;
+static const volatile union good_test8 { int x_factor8; } x_8;
+static volatile const union good_test9 { int x_factor9; } x_9;
 
 // extern/static not in first postion is deprecated, but legal
-const extern union good_test11 { int x_factor11; } x30;
-volatile extern union good_test12 { int x_factor12; } x31;
-const extern volatile union good_test13 { int x_factor13; } x32;
-const volatile extern union good_test14 { int x_factor14; } x33;
-volatile extern const union good_test15 { int x_factor15; } x34;
-volatile const extern union good_test16 { int x_factor16; } x35;
+const extern union good_test10 { int x_factor10; } x_10;
+volatile extern union good_test11 { int x_factor11; } x_11;
+const extern volatile union good_test12 { int x_factor12; } x_12;
+const volatile extern union good_test13 { int x_factor13; } x_13;
+volatile extern const union good_test14 { int x_factor14; } x_14;
+volatile const extern union good_test15 { int x_factor15; } x_15;
+volatile static union good_test16 { int x_factor16; } x_16;
+const static volatile union good_test17 { int x_factor17; } x_17;
+const volatile static union good_test18 { int x_factor18; } x_18;
+volatile static const union good_test19 { int x_factor19; } x_19;
+volatile const static union good_test20 { int x_factor20; } x_20;
 
-volatile static union good_test17 { int x_factor17; } x16;
-const static volatile union good_test18 { int x_factor18; } x37;
-const volatile static union good_test19 { int x_factor19; } x38;
-volatile static const union good_test20 { int x_factor20; } x39;
-volatile const static union good_test21 { int x_factor21; } x40;
+// ringing the changes on thread_local extern
+extern thread_local union good_test21 { int x_factor21; } x_21;
+extern thread_local const union good_test22 { int x_factor22; } x_22;
+extern thread_local volatile union good_test23 { int x_factor23; } x_23;
+extern thread_local const volatile union good_test24 { int x_factor24; } x_24;
+extern thread_local volatile const union good_test25 { int x_factor25; } x_25;
+thread_local extern union good_test26 { int x_factor26; } x_26;
+thread_local extern const union good_test27 { int x_factor27; } x_27;
+thread_local extern volatile union good_test28 { int x_factor28; } x_28;
+thread_local extern const volatile union good_test29 { int x_factor29; } x_29;
+thread_local extern volatile const union good_test30 { int x_factor30; } x_30;
+
+// ringing the changes on thread_local static
+static thread_local union good_test31 { int x_factor31; } x_31;
+static thread_local const union good_test32 { int x_factor32; } x_32;
+static thread_local volatile union good_test33 { int x_factor33; } x_33;
+static thread_local const volatile union good_test34 { int x_factor34; } x_34;
+static thread_local volatile const union good_test35 { int x_factor35; } x_35;
+thread_local static union good_test36 { int x_factor36; } x_36;
+thread_local static const union good_test37 { int x_factor37; } x_37;
+thread_local static volatile union good_test38 { int x_factor38; } x_38;
+thread_local static const volatile union good_test39 { int x_factor39; } x_39;
+thread_local static volatile const union good_test40 { int x_factor40; } x_40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local union good_test41 { int x_factor41; } x_41;
+const extern thread_local union good_test42 { int x_factor42; } x_42;
+extern volatile thread_local union good_test43 { int x_factor43; } x_43;
+volatile extern thread_local union good_test44 { int x_factor44; } x_44;
+extern const thread_local volatile union good_test45 { int x_factor45; } x_45;
+extern const volatile thread_local union good_test46 { int x_factor46; } x_46;
+const extern thread_local volatile union good_test47 { int x_factor47; } x_47;
+const extern volatile thread_local union good_test48 { int x_factor48; } x_48;
+const volatile extern thread_local union good_test49 { int x_factor49; } x_49;
+extern volatile thread_local const union good_test50 { int x_factor50; } x_50;
+extern volatile const thread_local union good_test51 { int x_factor51; } x_51;
+volatile extern thread_local const union good_test52 { int x_factor52; } x_52;
+volatile extern const thread_local union good_test53 { int x_factor53; } x_53;
+volatile const extern thread_local union good_test54 { int x_factor54; } x_54;
+thread_local const extern union good_test55 { int x_factor55; } x_55;
+const thread_local extern union good_test56 { int x_factor56; } x_56;
+thread_local volatile extern union good_test57 { int x_factor57; } x_57;
+volatile thread_local extern union good_test58 { int x_factor58; } x_58;
+thread_local const extern volatile union good_test59 { int x_factor59; } x_59;
+thread_local const volatile extern union good_test60 { int x_factor60; } x_60;
+const thread_local extern volatile union good_test61 { int x_factor61; } x_61;
+const thread_local volatile extern union good_test62 { int x_factor62; } x_62;
+const volatile thread_local extern union good_test63 { int x_factor63; } x_63;
+thread_local volatile extern const union good_test64 { int x_factor64; } x_64;
+thread_local volatile const extern union good_test65 { int x_factor65; } x_65;
+volatile thread_local extern const union good_test66 { int x_factor66; } x_66;
+volatile thread_local const extern union good_test67 { int x_factor67; } x_67;
+volatile const thread_local extern union good_test68 { int x_factor68; } x_68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local union good_test69 { int x_factor69; } x_69;
+const static thread_local union good_test70 { int x_factor70; } x_70;
+static volatile thread_local union good_test71 { int x_factor71; } x_71;
+volatile static thread_local union good_test72 { int x_factor72; } x_72;
+static const thread_local volatile union good_test73 { int x_factor73; } x_73;
+static const volatile thread_local union good_test74 { int x_factor74; } x_74;
+const static thread_local volatile union good_test75 { int x_factor75; } x_75;
+const static volatile thread_local union good_test76 { int x_factor76; } x_76;
+const volatile static thread_local union good_test77 { int x_factor77; } x_77;
+static volatile thread_local const union good_test78 { int x_factor78; } x_78;
+static volatile const thread_local union good_test79 { int x_factor79; } x_79;
+volatile static thread_local const union good_test80 { int x_factor80; } x_80;
+volatile static const thread_local union good_test81 { int x_factor81; } x_81;
+volatile const static thread_local union good_test82 { int x_factor82; } x_82;
+thread_local const static union good_test83 { int x_factor83; } x_83;
+const thread_local static union good_test84 { int x_factor84; } x_84;
+thread_local volatile static union good_test85 { int x_factor85; } x_85;
+volatile thread_local static union good_test86 { int x_factor86; } x_86;
+thread_local const static volatile union good_test87 { int x_factor87; } x_87;
+thread_local const volatile static union good_test88 { int x_factor88; } x_88;
+const thread_local static volatile union good_test89 { int x_factor89; } x_89;
+const thread_local volatile static union good_test90 { int x_factor90; } x_90;
+const volatile thread_local static union good_test91 { int x_factor91; } x_91;
+thread_local volatile static const union good_test92 { int x_factor92; } x_92;
+thread_local volatile const static union good_test93 { int x_factor93; } x_93;
+volatile thread_local static const union good_test94 { int x_factor94; } x_94;
+volatile thread_local const static union good_test95 { int x_factor95; } x_95;
+volatile const thread_local static union good_test96 { int x_factor96; } x_96;
+
 }	// end namespace test
 
-// check that union suppression works in namespaces
+// check that keyword suppression works in namespaces
 namespace test2 {
+
 union good_test {
-	int x_factor;
+	int x_factor
 };
 
 // ringing the changes on extern
@@ -126,11 +377,94 @@
 const volatile extern good_test x13;
 volatile extern const good_test x14;
 volatile const extern good_test x15;
-
 volatile static good_test x16;
 const static volatile good_test x17;
 const volatile static good_test x18;
 volatile static const good_test x19;
 volatile const static good_test x20;
 
+// ringing the changes on thread_local extern
+extern thread_local good_test x21;
+extern thread_local const good_test x22;
+extern thread_local volatile good_test x23;
+extern thread_local const volatile good_test x24;
+extern thread_local volatile const good_test x25;
+thread_local extern good_test x26;
+thread_local extern const good_test x27;
+thread_local extern volatile good_test x28;
+thread_local extern const volatile good_test x29;
+thread_local extern volatile const good_test x30;
+
+// ringing the changes on thread_local static
+static thread_local good_test x31;
+static thread_local const good_test x32;
+static thread_local volatile good_test x33;
+static thread_local const volatile good_test x34;
+static thread_local volatile const good_test x35;
+thread_local static good_test x36;
+thread_local static const good_test x37;
+thread_local static volatile good_test x38;
+thread_local static const volatile good_test x39;
+thread_local static volatile const good_test x40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local good_test x41;
+const extern thread_local good_test x42;
+extern volatile thread_local good_test x43;
+volatile extern thread_local good_test x44;
+extern const thread_local volatile good_test x45;
+extern const volatile thread_local good_test x46;
+const extern thread_local volatile good_test x47;
+const extern volatile thread_local good_test x48;
+const volatile extern thread_local good_test x49;
+extern volatile thread_local const good_test x50;
+extern volatile const thread_local good_test x51;
+volatile extern thread_local const good_test x52;
+volatile extern const thread_local good_test x53;
+volatile const extern thread_local good_test x54;
+thread_local const extern good_test x55;
+const thread_local extern good_test x56;
+thread_local volatile extern good_test x57;
+volatile thread_local extern good_test x58;
+thread_local const extern volatile good_test x59;
+thread_local const volatile extern good_test x60;
+const thread_local extern volatile good_test x61;
+const thread_local volatile extern good_test x62;
+const volatile thread_local extern good_test x63;
+thread_local volatile extern const good_test x64;
+thread_local volatile const extern good_test x65;
+volatile thread_local extern const good_test x66;
+volatile thread_local const extern good_test x67;
+volatile const thread_local extern good_test x68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local good_test x69;
+const static thread_local good_test x70;
+static volatile thread_local good_test x71;
+volatile static thread_local good_test x72;
+static const thread_local volatile good_test x73;
+static const volatile thread_local good_test x74;
+const static thread_local volatile good_test x75;
+const static volatile thread_local good_test x76;
+const volatile static thread_local good_test x77;
+static volatile thread_local const good_test x78;
+static volatile const thread_local good_test x79;
+volatile static thread_local const good_test x80;
+volatile static const thread_local good_test x81;
+volatile const static thread_local good_test x82;
+thread_local const static good_test x83;
+const thread_local static good_test x84;
+thread_local volatile static good_test x85;
+volatile thread_local static good_test x86;
+thread_local const static volatile good_test x87;
+thread_local const volatile static good_test x88;
+const thread_local static volatile good_test x89;
+const thread_local volatile static good_test x90;
+const volatile thread_local static good_test x91;
+thread_local volatile static const good_test x92;
+thread_local volatile const static good_test x93;
+volatile thread_local static const good_test x94;
+volatile thread_local const static good_test x95;
+volatile const thread_local static good_test x96;
+
 }	// end namespace test2



From zaimoni at mail.berlios.de  Sat Apr  9 05:55:16 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat,  9 Apr 2011 05:55:16 +0200
Subject: [Zcplusplus-commits] r630 - trunk/tests/zcc/decl.C99
Message-ID: <20110409035516.62628480EF5@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-09 05:55:16 +0200 (Sat, 09 Apr 2011)
New Revision: 630

Modified:
   trunk/tests/zcc/decl.C99/Pass_class_def2.hpp
Log:
classes: thread_local parsing

Modified: trunk/tests/zcc/decl.C99/Pass_class_def2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Pass_class_def2.hpp	2011-04-09 03:54:55 UTC (rev 629)
+++ trunk/tests/zcc/decl.C99/Pass_class_def2.hpp	2011-04-09 03:55:16 UTC (rev 630)
@@ -1,136 +1,470 @@
-// decl.C99\Pass_class_def2.hpp
-// using singly defined class
-// (C)2011 Kenneth Boyd, license: MIT.txt
-
-class good_test {
-	int x_factor;
-};
-
-// this section checks that suppressing class keyword works
-// ringing the changes on extern
-extern good_test x1;
-extern const good_test x2;
-extern volatile good_test x3;
-extern const volatile good_test x4;
-extern volatile const good_test x5;
-
-// ringing the changes on static
-// (don't test static const -- no chance to initialize before use)
-static good_test x6;
-static volatile good_test x7;
-static const volatile good_test x8;
-static volatile const good_test x9;
-
-// extern/static not in first postion is deprecated, but legal
-const extern good_test x10;
-volatile extern good_test x11;
-const extern volatile good_test x12;
-const volatile extern good_test x13;
-volatile extern const good_test x14;
-volatile const extern good_test x15;
-
-volatile static good_test x16;
-const static volatile good_test x17;
-const volatile static good_test x18;
-volatile static const good_test x19;
-volatile const static good_test x20;
-
-// check that things work properly in namespaces
-namespace test {
-class good_test {
-	int x_factor;
-};
-
-// ringing the changes on extern
-extern class good_test x1;
-extern const class good_test x2;
-extern volatile class good_test x3;
-extern const volatile class good_test x4;
-extern volatile const class good_test x5;
-
-// ringing the changes on static
-// (don't test static const -- no chance to initialize before use)
-static class good_test x6;
-static volatile class good_test x7;
-static const volatile class good_test x8;
-static volatile const class good_test x9;
-
-// extern/static not in first postion is deprecated, but legal
-const extern class good_test x10;
-volatile extern class good_test x11;
-const extern volatile class good_test x12;
-const volatile extern class good_test x13;
-volatile extern const class good_test x14;
-volatile const extern class good_test x15;
-
-volatile static class good_test x16;
-const static volatile class good_test x17;
-const volatile static class good_test x18;
-volatile static const class good_test x19;
-volatile const static class good_test x20;
-
-// define-declares
-// ringing the changes on extern
-extern class good_test2 { int x_factor2; } x21;
-extern const class good_test3 { int x_factor3; } x22;
-extern volatile class good_test4 { int x_factor4; } x23;
-extern const volatile class good_test5 { int x_factor5; } x24;
-extern volatile const class good_test6 { int x_factor6; } x25;
-
-// ringing the changes on static
-// (don't test static const -- no chance to initialize before use)
-static class good_test7 { int x_factor7; } x26;
-static volatile class good_test8 { int x_factor8; } x27;
-static const volatile class good_test9 { int x_factor9; } x28;
-static volatile const class good_test10 { int x_factor10; } x29;
-
-// extern/static not in first postion is deprecated, but legal
-const extern class good_test11 { int x_factor11; } x30;
-volatile extern class good_test12 { int x_factor12; } x31;
-const extern volatile class good_test13 { int x_factor13; } x32;
-const volatile extern class good_test14 { int x_factor14; } x33;
-volatile extern const class good_test15 { int x_factor15; } x34;
-volatile const extern class good_test16 { int x_factor16; } x35;
-
-volatile static class good_test17 { int x_factor17; } x16;
-const static volatile class good_test18 { int x_factor18; } x37;
-const volatile static class good_test19 { int x_factor19; } x38;
-volatile static const class good_test20 { int x_factor20; } x39;
-volatile const static class good_test21 { int x_factor21; } x40;
-}	// end namespace test
-
-// check that class suppression works in namespaces
-namespace test2 {
-class good_test {
-	int x_factor;
-};
-
-// ringing the changes on extern
-extern good_test x1;
-extern const good_test x2;
-extern volatile good_test x3;
-extern const volatile good_test x4;
-extern volatile const good_test x5;
-
-// ringing the changes on static
-// (don't test static const -- no chance to initialize before use)
-static good_test x6;
-static volatile good_test x7;
-static const volatile good_test x8;
-static volatile const good_test x9;
-
-// extern/static not in first postion is deprecated, but legal
-const extern good_test x10;
-volatile extern good_test x11;
-const extern volatile good_test x12;
-const volatile extern good_test x13;
-volatile extern const good_test x14;
-volatile const extern good_test x15;
-
-volatile static good_test x16;
-const static volatile good_test x17;
-const volatile static good_test x18;
-volatile static const good_test x19;
-volatile const static good_test x20;
-
-}	// end namespace test2
+// decl.C99/Pass_class_def2.hpp
+// using singly defined class
+
+class good_test {
+	int x_factor
+};
+
+// this section checks that suppressing keyword works
+// ringing the changes on extern
+extern good_test x1;
+extern const good_test x2;
+extern volatile good_test x3;
+extern const volatile good_test x4;
+extern volatile const good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static good_test x6;
+static volatile good_test x7;
+static const volatile good_test x8;
+static volatile const good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern good_test x10;
+volatile extern good_test x11;
+const extern volatile good_test x12;
+const volatile extern good_test x13;
+volatile extern const good_test x14;
+volatile const extern good_test x15;
+volatile static good_test x16;
+const static volatile good_test x17;
+const volatile static good_test x18;
+volatile static const good_test x19;
+volatile const static good_test x20;
+
+// ringing the changes on thread_local extern
+extern thread_local good_test x21;
+extern thread_local const good_test x22;
+extern thread_local volatile good_test x23;
+extern thread_local const volatile good_test x24;
+extern thread_local volatile const good_test x25;
+thread_local extern good_test x26;
+thread_local extern const good_test x27;
+thread_local extern volatile good_test x28;
+thread_local extern const volatile good_test x29;
+thread_local extern volatile const good_test x30;
+
+// ringing the changes on thread_local static
+static thread_local good_test x31;
+static thread_local const good_test x32;
+static thread_local volatile good_test x33;
+static thread_local const volatile good_test x34;
+static thread_local volatile const good_test x35;
+thread_local static good_test x36;
+thread_local static const good_test x37;
+thread_local static volatile good_test x38;
+thread_local static const volatile good_test x39;
+thread_local static volatile const good_test x40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local good_test x41;
+const extern thread_local good_test x42;
+extern volatile thread_local good_test x43;
+volatile extern thread_local good_test x44;
+extern const thread_local volatile good_test x45;
+extern const volatile thread_local good_test x46;
+const extern thread_local volatile good_test x47;
+const extern volatile thread_local good_test x48;
+const volatile extern thread_local good_test x49;
+extern volatile thread_local const good_test x50;
+extern volatile const thread_local good_test x51;
+volatile extern thread_local const good_test x52;
+volatile extern const thread_local good_test x53;
+volatile const extern thread_local good_test x54;
+thread_local const extern good_test x55;
+const thread_local extern good_test x56;
+thread_local volatile extern good_test x57;
+volatile thread_local extern good_test x58;
+thread_local const extern volatile good_test x59;
+thread_local const volatile extern good_test x60;
+const thread_local extern volatile good_test x61;
+const thread_local volatile extern good_test x62;
+const volatile thread_local extern good_test x63;
+thread_local volatile extern const good_test x64;
+thread_local volatile const extern good_test x65;
+volatile thread_local extern const good_test x66;
+volatile thread_local const extern good_test x67;
+volatile const thread_local extern good_test x68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local good_test x69;
+const static thread_local good_test x70;
+static volatile thread_local good_test x71;
+volatile static thread_local good_test x72;
+static const thread_local volatile good_test x73;
+static const volatile thread_local good_test x74;
+const static thread_local volatile good_test x75;
+const static volatile thread_local good_test x76;
+const volatile static thread_local good_test x77;
+static volatile thread_local const good_test x78;
+static volatile const thread_local good_test x79;
+volatile static thread_local const good_test x80;
+volatile static const thread_local good_test x81;
+volatile const static thread_local good_test x82;
+thread_local const static good_test x83;
+const thread_local static good_test x84;
+thread_local volatile static good_test x85;
+volatile thread_local static good_test x86;
+thread_local const static volatile good_test x87;
+thread_local const volatile static good_test x88;
+const thread_local static volatile good_test x89;
+const thread_local volatile static good_test x90;
+const volatile thread_local static good_test x91;
+thread_local volatile static const good_test x92;
+thread_local volatile const static good_test x93;
+volatile thread_local static const good_test x94;
+volatile thread_local const static good_test x95;
+volatile const thread_local static good_test x96;
+
+// check that things work properly in namespaces
+namespace test {
+
+class good_test {
+	int x_factor
+};
+
+// ringing the changes on extern
+extern class good_test x1;
+extern const class good_test x2;
+extern volatile class good_test x3;
+extern const volatile class good_test x4;
+extern volatile const class good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static class good_test x6;
+static volatile class good_test x7;
+static const volatile class good_test x8;
+static volatile const class good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern class good_test x10;
+volatile extern class good_test x11;
+const extern volatile class good_test x12;
+const volatile extern class good_test x13;
+volatile extern const class good_test x14;
+volatile const extern class good_test x15;
+volatile static class good_test x16;
+const static volatile class good_test x17;
+const volatile static class good_test x18;
+volatile static const class good_test x19;
+volatile const static class good_test x20;
+
+// ringing the changes on thread_local extern
+extern thread_local class good_test x21;
+extern thread_local const class good_test x22;
+extern thread_local volatile class good_test x23;
+extern thread_local const volatile class good_test x24;
+extern thread_local volatile const class good_test x25;
+thread_local extern class good_test x26;
+thread_local extern const class good_test x27;
+thread_local extern volatile class good_test x28;
+thread_local extern const volatile class good_test x29;
+thread_local extern volatile const class good_test x30;
+
+// ringing the changes on thread_local static
+static thread_local class good_test x31;
+static thread_local const class good_test x32;
+static thread_local volatile class good_test x33;
+static thread_local const volatile class good_test x34;
+static thread_local volatile const class good_test x35;
+thread_local static class good_test x36;
+thread_local static const class good_test x37;
+thread_local static volatile class good_test x38;
+thread_local static const volatile class good_test x39;
+thread_local static volatile const class good_test x40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local class good_test x41;
+const extern thread_local class good_test x42;
+extern volatile thread_local class good_test x43;
+volatile extern thread_local class good_test x44;
+extern const thread_local volatile class good_test x45;
+extern const volatile thread_local class good_test x46;
+const extern thread_local volatile class good_test x47;
+const extern volatile thread_local class good_test x48;
+const volatile extern thread_local class good_test x49;
+extern volatile thread_local const class good_test x50;
+extern volatile const thread_local class good_test x51;
+volatile extern thread_local const class good_test x52;
+volatile extern const thread_local class good_test x53;
+volatile const extern thread_local class good_test x54;
+thread_local const extern class good_test x55;
+const thread_local extern class good_test x56;
+thread_local volatile extern class good_test x57;
+volatile thread_local extern class good_test x58;
+thread_local const extern volatile class good_test x59;
+thread_local const volatile extern class good_test x60;
+const thread_local extern volatile class good_test x61;
+const thread_local volatile extern class good_test x62;
+const volatile thread_local extern class good_test x63;
+thread_local volatile extern const class good_test x64;
+thread_local volatile const extern class good_test x65;
+volatile thread_local extern const class good_test x66;
+volatile thread_local const extern class good_test x67;
+volatile const thread_local extern class good_test x68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local class good_test x69;
+const static thread_local class good_test x70;
+static volatile thread_local class good_test x71;
+volatile static thread_local class good_test x72;
+static const thread_local volatile class good_test x73;
+static const volatile thread_local class good_test x74;
+const static thread_local volatile class good_test x75;
+const static volatile thread_local class good_test x76;
+const volatile static thread_local class good_test x77;
+static volatile thread_local const class good_test x78;
+static volatile const thread_local class good_test x79;
+volatile static thread_local const class good_test x80;
+volatile static const thread_local class good_test x81;
+volatile const static thread_local class good_test x82;
+thread_local const static class good_test x83;
+const thread_local static class good_test x84;
+thread_local volatile static class good_test x85;
+volatile thread_local static class good_test x86;
+thread_local const static volatile class good_test x87;
+thread_local const volatile static class good_test x88;
+const thread_local static volatile class good_test x89;
+const thread_local volatile static class good_test x90;
+const volatile thread_local static class good_test x91;
+thread_local volatile static const class good_test x92;
+thread_local volatile const static class good_test x93;
+volatile thread_local static const class good_test x94;
+volatile thread_local const static class good_test x95;
+volatile const thread_local static class good_test x96;
+
+// define-declares
+// ringing the changes on extern
+extern class good_test1 { int x_factor1; } x_1;
+extern const class good_test2 { int x_factor2; } x_2;
+extern volatile class good_test3 { int x_factor3; } x_3;
+extern const volatile class good_test4 { int x_factor4; } x_4;
+extern volatile const class good_test5 { int x_factor5; } x_5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static class good_test6 { int x_factor6; } x_6;
+static volatile class good_test7 { int x_factor7; } x_7;
+static const volatile class good_test8 { int x_factor8; } x_8;
+static volatile const class good_test9 { int x_factor9; } x_9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern class good_test10 { int x_factor10; } x_10;
+volatile extern class good_test11 { int x_factor11; } x_11;
+const extern volatile class good_test12 { int x_factor12; } x_12;
+const volatile extern class good_test13 { int x_factor13; } x_13;
+volatile extern const class good_test14 { int x_factor14; } x_14;
+volatile const extern class good_test15 { int x_factor15; } x_15;
+volatile static class good_test16 { int x_factor16; } x_16;
+const static volatile class good_test17 { int x_factor17; } x_17;
+const volatile static class good_test18 { int x_factor18; } x_18;
+volatile static const class good_test19 { int x_factor19; } x_19;
+volatile const static class good_test20 { int x_factor20; } x_20;
+
+// ringing the changes on thread_local extern
+extern thread_local class good_test21 { int x_factor21; } x_21;
+extern thread_local const class good_test22 { int x_factor22; } x_22;
+extern thread_local volatile class good_test23 { int x_factor23; } x_23;
+extern thread_local const volatile class good_test24 { int x_factor24; } x_24;
+extern thread_local volatile const class good_test25 { int x_factor25; } x_25;
+thread_local extern class good_test26 { int x_factor26; } x_26;
+thread_local extern const class good_test27 { int x_factor27; } x_27;
+thread_local extern volatile class good_test28 { int x_factor28; } x_28;
+thread_local extern const volatile class good_test29 { int x_factor29; } x_29;
+thread_local extern volatile const class good_test30 { int x_factor30; } x_30;
+
+// ringing the changes on thread_local static
+static thread_local class good_test31 { int x_factor31; } x_31;
+static thread_local const class good_test32 { int x_factor32; } x_32;
+static thread_local volatile class good_test33 { int x_factor33; } x_33;
+static thread_local const volatile class good_test34 { int x_factor34; } x_34;
+static thread_local volatile const class good_test35 { int x_factor35; } x_35;
+thread_local static class good_test36 { int x_factor36; } x_36;
+thread_local static const class good_test37 { int x_factor37; } x_37;
+thread_local static volatile class good_test38 { int x_factor38; } x_38;
+thread_local static const volatile class good_test39 { int x_factor39; } x_39;
+thread_local static volatile const class good_test40 { int x_factor40; } x_40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local class good_test41 { int x_factor41; } x_41;
+const extern thread_local class good_test42 { int x_factor42; } x_42;
+extern volatile thread_local class good_test43 { int x_factor43; } x_43;
+volatile extern thread_local class good_test44 { int x_factor44; } x_44;
+extern const thread_local volatile class good_test45 { int x_factor45; } x_45;
+extern const volatile thread_local class good_test46 { int x_factor46; } x_46;
+const extern thread_local volatile class good_test47 { int x_factor47; } x_47;
+const extern volatile thread_local class good_test48 { int x_factor48; } x_48;
+const volatile extern thread_local class good_test49 { int x_factor49; } x_49;
+extern volatile thread_local const class good_test50 { int x_factor50; } x_50;
+extern volatile const thread_local class good_test51 { int x_factor51; } x_51;
+volatile extern thread_local const class good_test52 { int x_factor52; } x_52;
+volatile extern const thread_local class good_test53 { int x_factor53; } x_53;
+volatile const extern thread_local class good_test54 { int x_factor54; } x_54;
+thread_local const extern class good_test55 { int x_factor55; } x_55;
+const thread_local extern class good_test56 { int x_factor56; } x_56;
+thread_local volatile extern class good_test57 { int x_factor57; } x_57;
+volatile thread_local extern class good_test58 { int x_factor58; } x_58;
+thread_local const extern volatile class good_test59 { int x_factor59; } x_59;
+thread_local const volatile extern class good_test60 { int x_factor60; } x_60;
+const thread_local extern volatile class good_test61 { int x_factor61; } x_61;
+const thread_local volatile extern class good_test62 { int x_factor62; } x_62;
+const volatile thread_local extern class good_test63 { int x_factor63; } x_63;
+thread_local volatile extern const class good_test64 { int x_factor64; } x_64;
+thread_local volatile const extern class good_test65 { int x_factor65; } x_65;
+volatile thread_local extern const class good_test66 { int x_factor66; } x_66;
+volatile thread_local const extern class good_test67 { int x_factor67; } x_67;
+volatile const thread_local extern class good_test68 { int x_factor68; } x_68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local class good_test69 { int x_factor69; } x_69;
+const static thread_local class good_test70 { int x_factor70; } x_70;
+static volatile thread_local class good_test71 { int x_factor71; } x_71;
+volatile static thread_local class good_test72 { int x_factor72; } x_72;
+static const thread_local volatile class good_test73 { int x_factor73; } x_73;
+static const volatile thread_local class good_test74 { int x_factor74; } x_74;
+const static thread_local volatile class good_test75 { int x_factor75; } x_75;
+const static volatile thread_local class good_test76 { int x_factor76; } x_76;
+const volatile static thread_local class good_test77 { int x_factor77; } x_77;
+static volatile thread_local const class good_test78 { int x_factor78; } x_78;
+static volatile const thread_local class good_test79 { int x_factor79; } x_79;
+volatile static thread_local const class good_test80 { int x_factor80; } x_80;
+volatile static const thread_local class good_test81 { int x_factor81; } x_81;
+volatile const static thread_local class good_test82 { int x_factor82; } x_82;
+thread_local const static class good_test83 { int x_factor83; } x_83;
+const thread_local static class good_test84 { int x_factor84; } x_84;
+thread_local volatile static class good_test85 { int x_factor85; } x_85;
+volatile thread_local static class good_test86 { int x_factor86; } x_86;
+thread_local const static volatile class good_test87 { int x_factor87; } x_87;
+thread_local const volatile static class good_test88 { int x_factor88; } x_88;
+const thread_local static volatile class good_test89 { int x_factor89; } x_89;
+const thread_local volatile static class good_test90 { int x_factor90; } x_90;
+const volatile thread_local static class good_test91 { int x_factor91; } x_91;
+thread_local volatile static const class good_test92 { int x_factor92; } x_92;
+thread_local volatile const static class good_test93 { int x_factor93; } x_93;
+volatile thread_local static const class good_test94 { int x_factor94; } x_94;
+volatile thread_local const static class good_test95 { int x_factor95; } x_95;
+volatile const thread_local static class good_test96 { int x_factor96; } x_96;
+
+}	// end namespace test
+
+// check that keyword suppression works in namespaces
+namespace test2 {
+
+class good_test {
+	int x_factor
+};
+
+// ringing the changes on extern
+extern good_test x1;
+extern const good_test x2;
+extern volatile good_test x3;
+extern const volatile good_test x4;
+extern volatile const good_test x5;
+
+// ringing the changes on static
+// (don't test static const -- no chance to initialize before use)
+static good_test x6;
+static volatile good_test x7;
+static const volatile good_test x8;
+static volatile const good_test x9;
+
+// extern/static not in first postion is deprecated, but legal
+const extern good_test x10;
+volatile extern good_test x11;
+const extern volatile good_test x12;
+const volatile extern good_test x13;
+volatile extern const good_test x14;
+volatile const extern good_test x15;
+volatile static good_test x16;
+const static volatile good_test x17;
+const volatile static good_test x18;
+volatile static const good_test x19;
+volatile const static good_test x20;
+
+// ringing the changes on thread_local extern
+extern thread_local good_test x21;
+extern thread_local const good_test x22;
+extern thread_local volatile good_test x23;
+extern thread_local const volatile good_test x24;
+extern thread_local volatile const good_test x25;
+thread_local extern good_test x26;
+thread_local extern const good_test x27;
+thread_local extern volatile good_test x28;
+thread_local extern const volatile good_test x29;
+thread_local extern volatile const good_test x30;
+
+// ringing the changes on thread_local static
+static thread_local good_test x31;
+static thread_local const good_test x32;
+static thread_local volatile good_test x33;
+static thread_local const volatile good_test x34;
+static thread_local volatile const good_test x35;
+thread_local static good_test x36;
+thread_local static const good_test x37;
+thread_local static volatile good_test x38;
+thread_local static const volatile good_test x39;
+thread_local static volatile const good_test x40;
+
+// thread_local extern not in first two postions is deprecated, but legal
+extern const thread_local good_test x41;
+const extern thread_local good_test x42;
+extern volatile thread_local good_test x43;
+volatile extern thread_local good_test x44;
+extern const thread_local volatile good_test x45;
+extern const volatile thread_local good_test x46;
+const extern thread_local volatile good_test x47;
+const extern volatile thread_local good_test x48;
+const volatile extern thread_local good_test x49;
+extern volatile thread_local const good_test x50;
+extern volatile const thread_local good_test x51;
+volatile extern thread_local const good_test x52;
+volatile extern const thread_local good_test x53;
+volatile const extern thread_local good_test x54;
+thread_local const extern good_test x55;
+const thread_local extern good_test x56;
+thread_local volatile extern good_test x57;
+volatile thread_local extern good_test x58;
+thread_local const extern volatile good_test x59;
+thread_local const volatile extern good_test x60;
+const thread_local extern volatile good_test x61;
+const thread_local volatile extern good_test x62;
+const volatile thread_local extern good_test x63;
+thread_local volatile extern const good_test x64;
+thread_local volatile const extern good_test x65;
+volatile thread_local extern const good_test x66;
+volatile thread_local const extern good_test x67;
+volatile const thread_local extern good_test x68;
+
+// thread_local static not in first two postions is deprecated, but legal
+static const thread_local good_test x69;
+const static thread_local good_test x70;
+static volatile thread_local good_test x71;
+volatile static thread_local good_test x72;
+static const thread_local volatile good_test x73;
+static const volatile thread_local good_test x74;
+const static thread_local volatile good_test x75;
+const static volatile thread_local good_test x76;
+const volatile static thread_local good_test x77;
+static volatile thread_local const good_test x78;
+static volatile const thread_local good_test x79;
+volatile static thread_local const good_test x80;
+volatile static const thread_local good_test x81;
+volatile const static thread_local good_test x82;
+thread_local const static good_test x83;
+const thread_local static good_test x84;
+thread_local volatile static good_test x85;
+volatile thread_local static good_test x86;
+thread_local const static volatile good_test x87;
+thread_local const volatile static good_test x88;
+const thread_local static volatile good_test x89;
+const thread_local volatile static good_test x90;
+const volatile thread_local static good_test x91;
+thread_local volatile static const good_test x92;
+thread_local volatile const static good_test x93;
+volatile thread_local static const good_test x94;
+volatile thread_local const static good_test x95;
+volatile const thread_local static good_test x96;
+
+}	// end namespace test2



From zaimoni at mail.berlios.de  Fri Apr 15 04:27:23 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 15 Apr 2011 04:27:23 +0200
Subject: [Zcplusplus-commits] r631 - in trunk: . tests/zcc/decl.C99
	tests/zcc.in/decl.C99
Message-ID: <20110415022723.81C044813B2@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-15 04:27:22 +0200 (Fri, 15 Apr 2011)
New Revision: 631

Added:
   trunk/tests/zcc.in/decl.C99/Error_extern_static_thread_local_typedef.in
   trunk/tests/zcc.in/decl.C99/Error_extern_thread_local_typedef.in
   trunk/tests/zcc.in/decl.C99/Error_static_thread_local_typedef.in
   trunk/tests/zcc.in/decl.C99/Error_thread_local_typedef.in
   trunk/tests/zcc/decl.C99/Error_extern_static_thread_local_typedef.h
   trunk/tests/zcc/decl.C99/Error_extern_static_thread_local_typedef.hpp
   trunk/tests/zcc/decl.C99/Error_extern_thread_local_typedef.h
   trunk/tests/zcc/decl.C99/Error_extern_thread_local_typedef.hpp
   trunk/tests/zcc/decl.C99/Error_static_thread_local_typedef.h
   trunk/tests/zcc/decl.C99/Error_static_thread_local_typedef.hpp
   trunk/tests/zcc/decl.C99/Error_thread_local_typedef.h
   trunk/tests/zcc/decl.C99/Error_thread_local_typedef.hpp
Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
wire in _Thread_Local/thread_local

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-04-09 03:55:16 UTC (rev 630)
+++ trunk/CSupport.cpp	2011-04-15 02:27:22 UTC (rev 631)
@@ -11660,22 +11660,25 @@
 		{
 		assert(x.size<0>()>i);
 		assert(x.size<0>()-i>=decl_count);
-		if ((C99_CPP0X_DECLSPEC_TYPEDEF | C99_CPP0X_DECLSPEC_REGISTER | C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN | C99_DECLSPEC_AUTO) & flags)
+		if ((C99_CPP0X_DECLSPEC_TYPEDEF | C99_CPP0X_DECLSPEC_REGISTER | C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN | C99_CPP0X_DECLSPEC_THREAD_LOCAL | C99_DECLSPEC_AUTO) & flags)
 			{	// storage class specifiers
 			const char* specs[5];
 			unsigned int storage_count = 0;
-			unsigned int erased_count = 0;
+			bool thread_local_compat = false;
 			if (C99_CPP0X_DECLSPEC_TYPEDEF & flags)
 				specs[storage_count++] = "typedef";
 			if (C99_CPP0X_DECLSPEC_STATIC & flags)
 				specs[storage_count++] = "static";
 			if (C99_CPP0X_DECLSPEC_EXTERN & flags)
 				specs[storage_count++] = "extern";
+			if (C99_CPP0X_DECLSPEC_THREAD_LOCAL & flags)
+				{
+				specs[storage_count++] = "_Thread_Local";
+				thread_local_compat = ((C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN) & flags);
+				}
 			if (C99_CPP0X_DECLSPEC_REGISTER & flags)
 				{	//! \test zcc/decl.C99/Error_register_global.h
 				//! \todo should be warning for --do-what-i-mean
-				specs[storage_count++] = "register";
-				++erased_count;
 				message_header(x.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("storage-class specifier register disallowed at translation-unit level (C99 6.9p2)");
@@ -11686,8 +11689,6 @@
 			if (C99_DECLSPEC_AUTO & flags)
 				{	//! \test zcc/decl.C99/Error_auto_global.h
 				//! \todo should be warning for --do-what-i-mean
-				specs[storage_count++] = "auto";
-				++erased_count;
 				message_header(x.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("storage-class specifier auto disallowed at translation-unit level (C99 6.9p2)");
@@ -11695,7 +11696,7 @@
 				decl_count -= flush_token(x,i,decl_count,"auto");
 				flags &= ~C99_DECLSPEC_AUTO;
 				};
-			if (1<storage_count)
+			if (1<storage_count-thread_local_compat)
 				{	//! \test zcc/decl.C99/Error_extern_static.h
 					//! \test zcc/decl.C99/Error_extern_typedef.h
 					//! \test zcc/decl.C99/Error_static_typedef.h
@@ -11707,7 +11708,6 @@
 				INFORM(" (C99 6.7.1p2)");
 				zcc_errors.inc_error();
 				};
-			storage_count -= erased_count;
 			// inline requires a function type
 			// typedef must have a function type to tolerate anything (but kills inline)
 			return 1>=storage_count;
@@ -11770,22 +11770,25 @@
 		{
 		assert(x.size<0>()>i);
 		assert(x.size<0>()-i>=decl_count);
-		if ((C99_CPP0X_DECLSPEC_TYPEDEF | C99_CPP0X_DECLSPEC_REGISTER | C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN | CPP_DECLSPEC_MUTABLE | CPP_DECLSPEC_VIRTUAL | CPP_DECLSPEC_EXPLICIT | CPP_DECLSPEC_FRIEND) & flags)
+		if ((C99_CPP0X_DECLSPEC_TYPEDEF | C99_CPP0X_DECLSPEC_REGISTER | C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN | C99_CPP0X_DECLSPEC_THREAD_LOCAL | CPP_DECLSPEC_MUTABLE | CPP_DECLSPEC_VIRTUAL | CPP_DECLSPEC_EXPLICIT | CPP_DECLSPEC_FRIEND) & flags)
 			{	// storage class specifiers
 			const char* specs[5];
 			unsigned int storage_count = 0;
-			unsigned int erased_count = 0;
+			bool thread_local_compat = false;
 			if (C99_CPP0X_DECLSPEC_TYPEDEF & flags)
 				specs[storage_count++] = "typedef";
 			if (C99_CPP0X_DECLSPEC_STATIC & flags)
 				specs[storage_count++] = "static";
 			if (C99_CPP0X_DECLSPEC_EXTERN & flags)
 				specs[storage_count++] = "extern";
+			if (C99_CPP0X_DECLSPEC_THREAD_LOCAL & flags)
+				{
+				specs[storage_count++] = "thread_local";
+				thread_local_compat = ((C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN) & flags);
+				}
 			if (C99_CPP0X_DECLSPEC_REGISTER & flags)
 				{	//! \test zcc/default/decl.C99/Error_register_global.hpp
 				//! \todo should be warning for --do-what-i-mean
-				specs[storage_count++] = "register";
-				++erased_count;
 				message_header(x.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("storage-class specifier register allowed only to objects named in a block, or function parameters (C++98 7.1.1p2)");
@@ -11796,8 +11799,6 @@
 			if (CPP_DECLSPEC_MUTABLE & flags)
 				{	//! \test zcc/default/decl.C99/Error_mutable_global.hpp
 				//! \todo should be warning for --do-what-i-mean
-				specs[storage_count++] = "mutable";
-				++erased_count;
 				message_header(x.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("storage-class specifier mutable only allowed for non-static non-const non-reference class data members (C++0X 7.1.1p10)");
@@ -11805,7 +11806,7 @@
 				decl_count -= flush_token(x,i,decl_count,"mutable");
 				flags &= ~CPP_DECLSPEC_MUTABLE;
 				};
-			if (1<storage_count)
+			if (1<storage_count-thread_local_compat)
 				{	//! \test zcc/decl.C99/Error_extern_static.hpp
 					//! \test zcc/decl.C99/Error_extern_typedef.hpp
 					//! \test zcc/decl.C99/Error_static_typedef.hpp
@@ -11818,7 +11819,6 @@
 				INFORM(" (C++0X 7.1.1p1)");
 				zcc_errors.inc_error();
 				}
-			storage_count -= erased_count;
 			// thread_local ok at namespace scope for objects/references
 			// inline dies if not a function type
 			// typedef must have a function type to tolerate anything (but kills inline)

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-04-09 03:55:16 UTC (rev 630)
+++ trunk/CSupport.cpp.in	2011-04-15 02:27:22 UTC (rev 631)
@@ -11804,22 +11804,25 @@
 		{
 		assert(x.size<0>()>i);
 		assert(x.size<0>()-i>=decl_count);
-		if ((C99_CPP0X_DECLSPEC_TYPEDEF | C99_CPP0X_DECLSPEC_REGISTER | C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN | C99_DECLSPEC_AUTO) & flags)
+		if ((C99_CPP0X_DECLSPEC_TYPEDEF | C99_CPP0X_DECLSPEC_REGISTER | C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN | C99_CPP0X_DECLSPEC_THREAD_LOCAL | C99_DECLSPEC_AUTO) & flags)
 			{	// storage class specifiers
 			const char* specs[5];
 			unsigned int storage_count = 0;
-			unsigned int erased_count = 0;
+			bool thread_local_compat = false;
 			if (C99_CPP0X_DECLSPEC_TYPEDEF & flags)
 				specs[storage_count++] = "typedef";
 			if (C99_CPP0X_DECLSPEC_STATIC & flags)
 				specs[storage_count++] = "static";
 			if (C99_CPP0X_DECLSPEC_EXTERN & flags)
 				specs[storage_count++] = "extern";
+			if (C99_CPP0X_DECLSPEC_THREAD_LOCAL & flags)
+				{
+				specs[storage_count++] = "_Thread_Local";
+				thread_local_compat = ((C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN) & flags);
+				}
 			if (C99_CPP0X_DECLSPEC_REGISTER & flags)
 				{	//! \test zcc/decl.C99/Error_register_global.h
 				//! \todo should be warning for --do-what-i-mean
-				specs[storage_count++] = "register";
-				++erased_count;
 				message_header(x.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("storage-class specifier register disallowed at translation-unit level (C99 6.9p2)");
@@ -11830,8 +11833,6 @@
 			if (C99_DECLSPEC_AUTO & flags)
 				{	//! \test zcc/decl.C99/Error_auto_global.h
 				//! \todo should be warning for --do-what-i-mean
-				specs[storage_count++] = "auto";
-				++erased_count;
 				message_header(x.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("storage-class specifier auto disallowed at translation-unit level (C99 6.9p2)");
@@ -11839,7 +11840,7 @@
 				decl_count -= flush_token(x,i,decl_count,"auto");
 				flags &= ~C99_DECLSPEC_AUTO;
 				};
-			if (1<storage_count)
+			if (1<storage_count-thread_local_compat)
 				{	//! \test zcc/decl.C99/Error_extern_static.h
 					//! \test zcc/decl.C99/Error_extern_typedef.h
 					//! \test zcc/decl.C99/Error_static_typedef.h
@@ -11851,7 +11852,6 @@
 				INFORM(" (C99 6.7.1p2)");
 				zcc_errors.inc_error();
 				};
-			storage_count -= erased_count;
 			// inline requires a function type
 			// typedef must have a function type to tolerate anything (but kills inline)
 			return 1>=storage_count;
@@ -11914,22 +11914,25 @@
 		{
 		assert(x.size<0>()>i);
 		assert(x.size<0>()-i>=decl_count);
-		if ((C99_CPP0X_DECLSPEC_TYPEDEF | C99_CPP0X_DECLSPEC_REGISTER | C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN | CPP_DECLSPEC_MUTABLE | CPP_DECLSPEC_VIRTUAL | CPP_DECLSPEC_EXPLICIT | CPP_DECLSPEC_FRIEND) & flags)
+		if ((C99_CPP0X_DECLSPEC_TYPEDEF | C99_CPP0X_DECLSPEC_REGISTER | C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN | C99_CPP0X_DECLSPEC_THREAD_LOCAL | CPP_DECLSPEC_MUTABLE | CPP_DECLSPEC_VIRTUAL | CPP_DECLSPEC_EXPLICIT | CPP_DECLSPEC_FRIEND) & flags)
 			{	// storage class specifiers
 			const char* specs[5];
 			unsigned int storage_count = 0;
-			unsigned int erased_count = 0;
+			bool thread_local_compat = false;
 			if (C99_CPP0X_DECLSPEC_TYPEDEF & flags)
 				specs[storage_count++] = "typedef";
 			if (C99_CPP0X_DECLSPEC_STATIC & flags)
 				specs[storage_count++] = "static";
 			if (C99_CPP0X_DECLSPEC_EXTERN & flags)
 				specs[storage_count++] = "extern";
+			if (C99_CPP0X_DECLSPEC_THREAD_LOCAL & flags)
+				{
+				specs[storage_count++] = "thread_local";
+				thread_local_compat = ((C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN) & flags);
+				}
 			if (C99_CPP0X_DECLSPEC_REGISTER & flags)
 				{	//! \test zcc/default/decl.C99/Error_register_global.hpp
 				//! \todo should be warning for --do-what-i-mean
-				specs[storage_count++] = "register";
-				++erased_count;
 				message_header(x.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("storage-class specifier register allowed only to objects named in a block, or function parameters (C++98 7.1.1p2)");
@@ -11940,8 +11943,6 @@
 			if (CPP_DECLSPEC_MUTABLE & flags)
 				{	//! \test zcc/default/decl.C99/Error_mutable_global.hpp
 				//! \todo should be warning for --do-what-i-mean
-				specs[storage_count++] = "mutable";
-				++erased_count;
 				message_header(x.data<0>()[i].index_tokens[0]);
 				INC_INFORM(ERR_STR);
 				INFORM("storage-class specifier mutable only allowed for non-static non-const non-reference class data members (C++0X 7.1.1p10)");
@@ -11949,7 +11950,7 @@
 				decl_count -= flush_token(x,i,decl_count,"mutable");
 				flags &= ~CPP_DECLSPEC_MUTABLE;
 				};
-			if (1<storage_count)
+			if (1<storage_count-thread_local_compat)
 				{	//! \test zcc/decl.C99/Error_extern_static.hpp
 					//! \test zcc/decl.C99/Error_extern_typedef.hpp
 					//! \test zcc/decl.C99/Error_static_typedef.hpp
@@ -11962,7 +11963,6 @@
 				INFORM(" (C++0X 7.1.1p1)");
 				zcc_errors.inc_error();
 				}
-			storage_count -= erased_count;
 			// thread_local ok at namespace scope for objects/references
 			// inline dies if not a function type
 			// typedef must have a function type to tolerate anything (but kills inline)

Added: trunk/tests/zcc/decl.C99/Error_extern_static_thread_local_typedef.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_extern_static_thread_local_typedef.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_extern_static_thread_local_typedef.h	2011-04-15 02:27:22 UTC (rev 631)
@@ -0,0 +1,5 @@
+// decl.C99\Error_extern_static_thread_local_typedef.h
+// declaration with too many storage qualifiers
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+extern static _Thread_Local typedef int i;

Added: trunk/tests/zcc/decl.C99/Error_extern_static_thread_local_typedef.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_extern_static_thread_local_typedef.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_extern_static_thread_local_typedef.hpp	2011-04-15 02:27:22 UTC (rev 631)
@@ -0,0 +1,5 @@
+// decl.C99\Error_extern_static_thread_local_typedef.hpp
+// declaration with too many storage qualifiers
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+extern static thread_local typedef int i;

Added: trunk/tests/zcc/decl.C99/Error_extern_thread_local_typedef.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_extern_thread_local_typedef.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_extern_thread_local_typedef.h	2011-04-15 02:27:22 UTC (rev 631)
@@ -0,0 +1,5 @@
+// decl.C99\Error_extern_thread_local_typedef.h
+// declaration with too many storage qualifiers
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+extern _Thread_Local typedef int i;

Added: trunk/tests/zcc/decl.C99/Error_extern_thread_local_typedef.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_extern_thread_local_typedef.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_extern_thread_local_typedef.hpp	2011-04-15 02:27:22 UTC (rev 631)
@@ -0,0 +1,5 @@
+// decl.C99\Error_extern_thread_local_typedef.hpp
+// declaration with too many storage qualifiers
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+extern thread_local typedef int i;

Added: trunk/tests/zcc/decl.C99/Error_static_thread_local_typedef.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_static_thread_local_typedef.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_static_thread_local_typedef.h	2011-04-15 02:27:22 UTC (rev 631)
@@ -0,0 +1,5 @@
+// decl.C99\Error_static_thread_local_typedef.h
+// declaration with too many storage qualifiers
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+static _Thread_Local typedef int i;

Added: trunk/tests/zcc/decl.C99/Error_static_thread_local_typedef.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_static_thread_local_typedef.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_static_thread_local_typedef.hpp	2011-04-15 02:27:22 UTC (rev 631)
@@ -0,0 +1,5 @@
+// decl.C99\Error_static_thread_local_typedef.hpp
+// declaration with too many storage qualifiers
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+static thread_local typedef int i;

Added: trunk/tests/zcc/decl.C99/Error_thread_local_typedef.h
===================================================================
--- trunk/tests/zcc/decl.C99/Error_thread_local_typedef.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_thread_local_typedef.h	2011-04-15 02:27:22 UTC (rev 631)
@@ -0,0 +1,5 @@
+// decl.C99\Error_thread_local_typedef.h
+// declaration with too many storage qualifiers
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+_Thread_Local typedef int i;

Added: trunk/tests/zcc/decl.C99/Error_thread_local_typedef.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_thread_local_typedef.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_thread_local_typedef.hpp	2011-04-15 02:27:22 UTC (rev 631)
@@ -0,0 +1,5 @@
+// decl.C99\Error_thread_local_typedef.hpp
+// declaration with too many storage qualifiers
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+thread_local typedef int i;

Added: trunk/tests/zcc.in/decl.C99/Error_extern_static_thread_local_typedef.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_extern_static_thread_local_typedef.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_extern_static_thread_local_typedef.in	2011-04-15 02:27:22 UTC (rev 631)
@@ -0,0 +1,6 @@
+SUFFIXES h hpp
+OBJECTLIKE_MACRO THREAD_LOCAL _Thread_Local thread_local
+// declaration with too many storage qualifiers
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+extern static THREAD_LOCAL typedef int i;

Added: trunk/tests/zcc.in/decl.C99/Error_extern_thread_local_typedef.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_extern_thread_local_typedef.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_extern_thread_local_typedef.in	2011-04-15 02:27:22 UTC (rev 631)
@@ -0,0 +1,6 @@
+SUFFIXES h hpp
+OBJECTLIKE_MACRO THREAD_LOCAL _Thread_Local thread_local
+// declaration with too many storage qualifiers
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+extern THREAD_LOCAL typedef int i;

Added: trunk/tests/zcc.in/decl.C99/Error_static_thread_local_typedef.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_static_thread_local_typedef.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_static_thread_local_typedef.in	2011-04-15 02:27:22 UTC (rev 631)
@@ -0,0 +1,6 @@
+SUFFIXES h hpp
+OBJECTLIKE_MACRO THREAD_LOCAL _Thread_Local thread_local
+// declaration with too many storage qualifiers
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+static THREAD_LOCAL typedef int i;

Added: trunk/tests/zcc.in/decl.C99/Error_thread_local_typedef.in
===================================================================
--- trunk/tests/zcc.in/decl.C99/Error_thread_local_typedef.in	                        (rev 0)
+++ trunk/tests/zcc.in/decl.C99/Error_thread_local_typedef.in	2011-04-15 02:27:22 UTC (rev 631)
@@ -0,0 +1,6 @@
+SUFFIXES h hpp
+OBJECTLIKE_MACRO THREAD_LOCAL _Thread_Local thread_local
+// declaration with too many storage qualifiers
+// (C)2011 Kenneth Boyd, license: MIT.txt
+
+THREAD_LOCAL typedef int i;



From zaimoni at mail.berlios.de  Fri Apr 15 09:08:31 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 15 Apr 2011 09:08:31 +0200
Subject: [Zcplusplus-commits] r632 - trunk
Message-ID: <20110415070831.81CEA4813C3@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-15 09:08:30 +0200 (Fri, 15 Apr 2011)
New Revision: 632

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
reduce asserts from attempting to remove normal-form code

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-04-15 02:27:22 UTC (rev 631)
+++ trunk/CSupport.cpp	2011-04-15 07:08:30 UTC (rev 632)
@@ -10539,8 +10539,9 @@
 			//! \test decl.C99/Warn_dup_const2.h
 			//! \test decl.C99/Warn_dup_const2.hpp
 			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
-			src.DeleteIdx<0>(i-- +offset);
+			src.DeleteIdx<0>(i+offset);
 			invariant_decl_scanner.DeleteIdx(offset);
+			if (0<i) --i;
 			if (invariant_decl_scanner.size()<=k) return;
 			INVARIANT();
 			continue;
@@ -10550,8 +10551,9 @@
 			//! \test decl.C99/Warn_dup_volatile2.h
 			//! \test decl.C99/Warn_dup_volatile2.hpp
 			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
-			src.DeleteIdx<0>(i-- +offset);
+			src.DeleteIdx<0>(i+offset);
 			invariant_decl_scanner.DeleteIdx(offset);
+			if (0<i) --i;
 			if (invariant_decl_scanner.size()<=k) return;
 			INVARIANT();
 			continue;
@@ -10566,8 +10568,9 @@
 					zcc_errors.inc_error();
 					have_warned_too_many_types = true;
 					}
-				src.DeleteIdx<0>(i-- +offset);
+				src.DeleteIdx<0>(i+offset);
 				invariant_decl_scanner.DeleteIdx(offset);
+				if (0<i) --i;
 				if (invariant_decl_scanner.size()<=k) return;
 				INVARIANT();
 				continue;

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-04-15 02:27:22 UTC (rev 631)
+++ trunk/CSupport.cpp.in	2011-04-15 07:08:30 UTC (rev 632)
@@ -10675,8 +10675,9 @@
 			//! \test decl.C99/Warn_dup_const2.h
 			//! \test decl.C99/Warn_dup_const2.hpp
 			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
-			src.DeleteIdx<0>(i-- +offset);
+			src.DeleteIdx<0>(i+offset);
 			invariant_decl_scanner.DeleteIdx(offset);
+			if (0<i) --i;
 			if (invariant_decl_scanner.size()<=k) return;
 			INVARIANT();
 			continue;
@@ -10686,8 +10687,9 @@
 			//! \test decl.C99/Warn_dup_volatile2.h
 			//! \test decl.C99/Warn_dup_volatile2.hpp
 			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
-			src.DeleteIdx<0>(i-- +offset);
+			src.DeleteIdx<0>(i+offset);
 			invariant_decl_scanner.DeleteIdx(offset);
+			if (0<i) --i;
 			if (invariant_decl_scanner.size()<=k) return;
 			INVARIANT();
 			continue;
@@ -10702,8 +10704,9 @@
 					zcc_errors.inc_error();
 					have_warned_too_many_types = true;
 					}
-				src.DeleteIdx<0>(i-- +offset);
+				src.DeleteIdx<0>(i+offset);
 				invariant_decl_scanner.DeleteIdx(offset);
+				if (0<i) --i;
 				if (invariant_decl_scanner.size()<=k) return;
 				INVARIANT();
 				continue;



From zaimoni at mail.berlios.de  Sat Apr 16 19:11:22 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 16 Apr 2011 19:11:22 +0200
Subject: [Zcplusplus-commits] r633 - trunk
Message-ID: <20110416171123.26134481455@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-16 19:11:22 +0200 (Sat, 16 Apr 2011)
New Revision: 633

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
fix bug requiring normal-form enforcer on const, volatile

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2011-04-15 07:08:30 UTC (rev 632)
+++ trunk/CSupport.cpp	2011-04-16 17:11:22 UTC (rev 633)
@@ -4453,13 +4453,6 @@
 				src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
 				offset += 1;
 				assert(is_C99_anonymous_specifier(src.data<0>()[i],tmp2));
-				// parser is having normal-form issues.  Shove named specifier definitions ahead of any const/volatile type qualifiers
-				size_t j = i;
-				while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
-					{
-					std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
-					--j;
-					};
 				continue;
 				};
 			if (!C99_looks_like_identifier(src.data<0>()[i+1]))
@@ -4484,13 +4477,6 @@
 				src.DestroyNAtAndRotateTo<0>(2,i+1,src.size<0>()-offset);
 				offset += 2;
 				assert(is_C99_named_specifier_definition(src.data<0>()[i],tmp2));
-				// parser is having normal-form issues.  Shove named specifier definitions ahead of any const/volatile type qualifiers
-				size_t j = i;
-				while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
-					{
-					std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
-					--j;
-					};
 				continue;
 				};
 			src.c_array<0>()[i].grab_index_token_from<1,0>(src.c_array<0>()[i+1]);
@@ -4499,13 +4485,6 @@
 			src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
 			offset += 1;
 			assert(is_C99_named_specifier(src.data<0>()[i],tmp2));
-			// parser is having normal-form issues.  Shove named specifiers ahead of any const/volatile type qualifiers
-			size_t j = i;
-			while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
-				{
-				std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
-				--j;
-				};
 			continue;
 			}
 		++i;
@@ -4548,13 +4527,6 @@
 				src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
 				offset += 1;
 				assert(is_C99_anonymous_specifier(src.data<0>()[i],tmp2));
-				// parser is having normal-form issues.  Shove named specifiers ahead of any const/volatile type qualifiers
-				size_t j = i;
-				while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
-					{
-					std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
-					--j;
-					};
 				continue;
 				};
 			if (!CPP_looks_like_identifier(src.data<0>()[i+1]))
@@ -4579,13 +4551,6 @@
 				src.DestroyNAtAndRotateTo<0>(2,i+1,src.size<0>()-offset);
 				offset += 2;
 				assert(is_C99_named_specifier_definition(src.data<0>()[i],tmp2));
-				// parser is having normal-form issues.  Shove named specifier definitions ahead of any const/volatile type qualifiers
-				size_t j = i;
-				while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
-					{
-					std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
-					--j;
-					};
 				continue;
 				};
 			src.c_array<0>()[i].grab_index_token_from<1,0>(src.c_array<0>()[i+1]);
@@ -4594,13 +4559,6 @@
 			src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
 			offset += 1;
 			assert(is_C99_named_specifier(src.data<0>()[i],tmp2));
-			// parser is having normal-form issues.  Shove named specifiers ahead of any const/volatile type qualifiers
-			size_t j = i;
-			while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
-				{
-				std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
-				--j;
-				};
 			continue;
 			}
 		++i;
@@ -10541,7 +10499,7 @@
 			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
 			src.DeleteIdx<0>(i+offset);
 			invariant_decl_scanner.DeleteIdx(offset);
-			if (0<i) --i;
+			if (0<i) --i; else --k;
 			if (invariant_decl_scanner.size()<=k) return;
 			INVARIANT();
 			continue;
@@ -10553,7 +10511,7 @@
 			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
 			src.DeleteIdx<0>(i+offset);
 			invariant_decl_scanner.DeleteIdx(offset);
-			if (0<i) --i;
+			if (0<i) --i; else --k;
 			if (invariant_decl_scanner.size()<=k) return;
 			INVARIANT();
 			continue;
@@ -10570,7 +10528,7 @@
 					}
 				src.DeleteIdx<0>(i+offset);
 				invariant_decl_scanner.DeleteIdx(offset);
-				if (0<i) --i;
+				if (0<i) --i; else --k;
 				if (invariant_decl_scanner.size()<=k) return;
 				INVARIANT();
 				continue;
@@ -10613,7 +10571,7 @@
 					zcc_errors.inc_error();
 					have_warned_too_many_types = true;
 					}
-				src.DeleteIdx<0>(i-- +offset);
+				src.DeleteIdx<0>(i+offset);
 				invariant_decl_scanner.DeleteIdx(offset);
 				INVARIANT();
 				continue;

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2011-04-15 07:08:30 UTC (rev 632)
+++ trunk/CSupport.cpp.in	2011-04-16 17:11:22 UTC (rev 633)
@@ -4515,13 +4515,6 @@
 				src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
 				offset += 1;
 				assert(is_C99_anonymous_specifier(src.data<0>()[i],tmp2));
-				// parser is having normal-form issues.  Shove named specifier definitions ahead of any const/volatile type qualifiers
-				size_t j = i;
-				while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
-					{
-					std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
-					--j;
-					};
 				continue;
 				};
 			if (!C99_looks_like_identifier(src.data<0>()[i+1]))
@@ -4546,13 +4539,6 @@
 				src.DestroyNAtAndRotateTo<0>(2,i+1,src.size<0>()-offset);
 				offset += 2;
 				assert(is_C99_named_specifier_definition(src.data<0>()[i],tmp2));
-				// parser is having normal-form issues.  Shove named specifier definitions ahead of any const/volatile type qualifiers
-				size_t j = i;
-				while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
-					{
-					std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
-					--j;
-					};
 				continue;
 				};
 			src.c_array<0>()[i].grab_index_token_from<1,0>(src.c_array<0>()[i+1]);
@@ -4561,13 +4547,6 @@
 			src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
 			offset += 1;
 			assert(is_C99_named_specifier(src.data<0>()[i],tmp2));
-			// parser is having normal-form issues.  Shove named specifiers ahead of any const/volatile type qualifiers
-			size_t j = i;
-			while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
-				{
-				std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
-				--j;
-				};
 			continue;
 			}
 		++i;
@@ -4610,13 +4589,6 @@
 				src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
 				offset += 1;
 				assert(is_C99_anonymous_specifier(src.data<0>()[i],tmp2));
-				// parser is having normal-form issues.  Shove named specifiers ahead of any const/volatile type qualifiers
-				size_t j = i;
-				while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
-					{
-					std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
-					--j;
-					};
 				continue;
 				};
 			if (!CPP_looks_like_identifier(src.data<0>()[i+1]))
@@ -4641,13 +4613,6 @@
 				src.DestroyNAtAndRotateTo<0>(2,i+1,src.size<0>()-offset);
 				offset += 2;
 				assert(is_C99_named_specifier_definition(src.data<0>()[i],tmp2));
-				// parser is having normal-form issues.  Shove named specifier definitions ahead of any const/volatile type qualifiers
-				size_t j = i;
-				while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
-					{
-					std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
-					--j;
-					};
 				continue;
 				};
 			src.c_array<0>()[i].grab_index_token_from<1,0>(src.c_array<0>()[i+1]);
@@ -4656,13 +4621,6 @@
 			src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
 			offset += 1;
 			assert(is_C99_named_specifier(src.data<0>()[i],tmp2));
-			// parser is having normal-form issues.  Shove named specifiers ahead of any const/volatile type qualifiers
-			size_t j = i;
-			while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
-				{
-				std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
-				--j;
-				};
 			continue;
 			}
 		++i;
@@ -10677,7 +10635,7 @@
 			record_qualifier_or_warn(src,type_spec::_const,i+k,i+offset,have_warned_about_const,warn_const);
 			src.DeleteIdx<0>(i+offset);
 			invariant_decl_scanner.DeleteIdx(offset);
-			if (0<i) --i;
+			if (0<i) --i; else --k;
 			if (invariant_decl_scanner.size()<=k) return;
 			INVARIANT();
 			continue;
@@ -10689,7 +10647,7 @@
 			record_qualifier_or_warn(src,type_spec::_volatile,i+k,i+offset,have_warned_about_volatile,warn_volatile);
 			src.DeleteIdx<0>(i+offset);
 			invariant_decl_scanner.DeleteIdx(offset);
-			if (0<i) --i;
+			if (0<i) --i; else --k;
 			if (invariant_decl_scanner.size()<=k) return;
 			INVARIANT();
 			continue;
@@ -10706,7 +10664,7 @@
 					}
 				src.DeleteIdx<0>(i+offset);
 				invariant_decl_scanner.DeleteIdx(offset);
-				if (0<i) --i;
+				if (0<i) --i; else --k;
 				if (invariant_decl_scanner.size()<=k) return;
 				INVARIANT();
 				continue;
@@ -10749,7 +10707,7 @@
 					zcc_errors.inc_error();
 					have_warned_too_many_types = true;
 					}
-				src.DeleteIdx<0>(i-- +offset);
+				src.DeleteIdx<0>(i+offset);
 				invariant_decl_scanner.DeleteIdx(offset);
 				INVARIANT();
 				continue;



From zaimoni at mail.berlios.de  Thu Apr 21 19:55:23 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 21 Apr 2011 19:55:23 +0200
Subject: [Zcplusplus-commits] r634 - in trunk: . tests/cpp
Message-ID: <20110421175523.753BE48144E@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-21 19:55:23 +0200 (Thu, 21 Apr 2011)
New Revision: 634

Modified:
   trunk/errors.cpp
   trunk/errors.hpp
   trunk/tests/cpp/run_tests.bat
   trunk/tests/cpp/run_tests.sh
   trunk/tests/cpp/run_tests_C99.bat
   trunk/tests/cpp/run_tests_C99.sh
   trunk/z_cpp.cpp
   trunk/zcc.cpp
Log:
new options --src-stdout, -E; fix test drivers for z_cpp

Modified: trunk/errors.cpp
===================================================================
--- trunk/errors.cpp	2011-04-16 17:11:22 UTC (rev 633)
+++ trunk/errors.cpp	2011-04-21 17:55:23 UTC (rev 634)
@@ -20,7 +20,8 @@
 			default_option(boolean_option(8)),
 			default_option(boolean_option(9)),
 			default_option(boolean_option(10)),
-			default_option(boolean_option(11))
+			default_option(boolean_option(11)),
+			default_option(boolean_option(12))
 		};
 
 bool bool_options[MAX_OPT_BOOL]
@@ -35,6 +36,7 @@
 			default_option(boolean_option(8)),
 			default_option(boolean_option(9)),
 			default_option(boolean_option(10)),
+			default_option(boolean_option(12)),
 			default_option(boolean_option(11))
 		};
 
@@ -238,5 +240,8 @@
 		unreal_config = true;
 		}
 	if (unreal_config) _fatal("Cannot target an unreal machine.");
+	// (silent) internal consistency fixups
+	// preprocess-only implies source-to-stdout
+	if (bool_options[boolopt::preprocess_only]) bool_options[boolopt::source_to_stdout] = true;
 }
 

Modified: trunk/errors.hpp
===================================================================
--- trunk/errors.hpp	2011-04-16 17:11:22 UTC (rev 633)
+++ trunk/errors.hpp	2011-04-21 17:55:23 UTC (rev 634)
@@ -68,14 +68,22 @@
 #define boolean_option_10 warn_crosslang_compatibility
 #define boolean_option_warn_crosslang_compatibility 10
 #define DEFAULT_warn_crosslang_compatibility false
-	warn_backport
+	warn_backport,
 #define boolean_option_11 warn_backport
 #define boolean_option_warn_backport 11
 #define DEFAULT_warn_backport false
+	source_to_stdout,
+#define boolean_option_12 source_to_stdout
+#define boolean_option_source_to_stdout 12
+#define DEFAULT_source_to_stdout false
+	preprocess_only
+#define boolean_option_13 preprocess_only
+#define boolean_option_preprocess_only 13
+#define DEFAULT_preprocess_only false
 };
 
 #define boolean_option(A) boolean_option_##A
-#define MAX_OPT_BOOL (boolopt::warn_backport+1)
+#define MAX_OPT_BOOL (boolopt::preprocess_only+1)
 
 }
 

Modified: trunk/tests/cpp/run_tests.bat
===================================================================
--- trunk/tests/cpp/run_tests.bat	2011-04-16 17:11:22 UTC (rev 633)
+++ trunk/tests/cpp/run_tests.bat	2011-04-21 17:55:23 UTC (rev 634)
@@ -20,8 +20,6 @@
 
 @echo Checking ISO error requirements
 @echo ====
- at for %%f in (Error*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
- at for %%f in (Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
 @for %%f in (Error*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
 @for %%f in (Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
 @for %%f in (UNICODE.C99\Error*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)

Modified: trunk/tests/cpp/run_tests.sh
===================================================================
--- trunk/tests/cpp/run_tests.sh	2011-04-16 17:11:22 UTC (rev 633)
+++ trunk/tests/cpp/run_tests.sh	2011-04-21 17:55:23 UTC (rev 634)
@@ -27,7 +27,6 @@
 
 	echo Checking ISO error requirements
 	echo ====
-	for F in Error*.h; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
 	for F in Error*.hpp; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
 	for F in UNICODE.C99/Error*.h; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
 	for F in UNICODE.C99/Error*.hpp; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;

Modified: trunk/tests/cpp/run_tests_C99.bat
===================================================================
--- trunk/tests/cpp/run_tests_C99.bat	2011-04-16 17:11:22 UTC (rev 633)
+++ trunk/tests/cpp/run_tests_C99.bat	2011-04-21 17:55:23 UTC (rev 634)
@@ -12,8 +12,6 @@
 
 @echo Checking ISO error requirements
 @echo ====
- at for %%f in (Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
- at for %%f in (Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
 @for %%f in (UNICODE.C99\Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
 @for %%f in (UNICODE.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
 @for %%f in (define.C99\Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)

Modified: trunk/tests/cpp/run_tests_C99.sh
===================================================================
--- trunk/tests/cpp/run_tests_C99.sh	2011-04-16 17:11:22 UTC (rev 633)
+++ trunk/tests/cpp/run_tests_C99.sh	2011-04-21 17:55:23 UTC (rev 634)
@@ -19,7 +19,6 @@
 
 	echo Checking ISO error requirements
 	echo ====
-	for F in Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
 	for F in UNICODE.C99/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
 	for F in define.C99/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
 	for F in defined.C99/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;

Modified: trunk/z_cpp.cpp
===================================================================
--- trunk/z_cpp.cpp	2011-04-16 17:11:22 UTC (rev 633)
+++ trunk/z_cpp.cpp	2011-04-21 17:55:23 UTC (rev 634)
@@ -192,6 +192,10 @@
 	if (!last_arg_used_in_option) guess_lang_from_filename(argv[argc-1]);
 	enforce_mutually_exclusive_exhaustive_options();
 
+	// preprocess-only is superfluous for a standalone preprocessor
+	// standalone preprocessor is useless if it doesn't send the result to stdout
+	bool_options[boolopt::source_to_stdout] = true;
+	
 	// error count enforcement
 	zcc_errors.set_error_ub(int_options[intopt::error_ub]);
 

Modified: trunk/zcc.cpp
===================================================================
--- trunk/zcc.cpp	2011-04-16 17:11:22 UTC (rev 633)
+++ trunk/zcc.cpp	2011-04-21 17:55:23 UTC (rev 634)
@@ -37,7 +37,9 @@
 		{ "-funsigned-char",	boolopt::char_is_unsigned, 	"char acts like unsigned char (default)\n"},	// GCC compatibility
 		{ "--int-neg-div-rounds-away-from-zero",	boolopt::int_neg_div_rounds_away_from_zero, 	"make -3/-2==-2 contrary to C99 recommendation\n"},
 		{ "-Wc-c++-compat",	boolopt::warn_crosslang_compatibility,	"Warn when something legal in C/C++ would be an error in C++/C for C/C++\n"},
-		{ "-Wbackport",	boolopt::warn_backport,	"Warn when something legal would be an error under an older standard\n"}
+		{ "-Wbackport",	boolopt::warn_backport,	"Warn when something legal would be an error under an older standard\n"},
+		{ "--src-stdout",	boolopt::source_to_stdout,	"Modified source to stdout\n"},
+		{ "-E",	boolopt::preprocess_only,	"Only preprocess (should be equivalent to calling z_cpp).  Implies --src-stdout\n"}	// POSIX compatibility
 	};
 
 static const POD_triple<const char*, size_t, const char*> option_map_string[]
@@ -263,15 +265,30 @@
 		if (last_arg_used_in_option) FATAL("file not last argument provided");
 		if (!load_sourcefile(TokenList,register_string(argv[argc-1]),lexer_from_string(string_options[stringopt::lang]))) FATAL("target file not loaded");
 		cpp.preprocess(TokenList);
+		if (bool_options[boolopt::preprocess_only])
+			{
+			const size_t list_size = TokenList.size();
+			size_t i = 0;
+			while(list_size>i)
+				{
+				assert(NULL!=TokenList[i]);
+				STL_PTR_STRING_TO_STDOUT(TokenList[i]);
+				if (list_size<=i+1 || TokenList[i]->logical_line.first!=TokenList[i+1]->logical_line.first || strcmp(TokenList[i]->src_filename,TokenList[i+1]->src_filename))
+					STRING_LITERAL_TO_STDOUT("\n");
+				else if (cpp.require_padding(TokenList[i]->back(),TokenList[i+1]->front()))
+					STRING_LITERAL_TO_STDOUT(" ");
+				++i;
+				};
+			return EXIT_SUCCESS;
+			}
 		}
 
 		//! \todo parse the resulting TokenList...
 		ZParser parser(target_machine,string_options[stringopt::lang]);
 		if (bool_options[boolopt::test]) parser.set_debug(true);
 		const bool export_to_object_ok = parser.parse(TokenList,ParsedList);
-		if (export_to_object_ok)
-			{
-			// export to source code
+		if (export_to_object_ok && bool_options[boolopt::source_to_stdout])
+			{	// export to source code
 			const size_t ParsedList_size = ParsedList.size();
 			size_t i = 0;
 			while(i<ParsedList_size) INFORM(*ParsedList[i++]);



From zaimoni at mail.berlios.de  Sun Apr 24 17:26:41 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 24 Apr 2011 17:26:41 +0200
Subject: [Zcplusplus-commits] r635 - trunk/Zaimoni.STL
Message-ID: <20110424152641.A0AD54814C8@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-24 17:26:41 +0200 (Sun, 24 Apr 2011)
New Revision: 635

Modified:
   trunk/Zaimoni.STL/AutoPtr.hpp
Log:
fix operator== for the autovalarray family (another project hit this)

Modified: trunk/Zaimoni.STL/AutoPtr.hpp
===================================================================
--- trunk/Zaimoni.STL/AutoPtr.hpp	2011-04-21 17:55:23 UTC (rev 634)
+++ trunk/Zaimoni.STL/AutoPtr.hpp	2011-04-24 15:26:41 UTC (rev 635)
@@ -101,8 +101,6 @@
 template<class Derived,class T>
 struct c_var_array_CRTP : public c_array_CRTP<c_var_array_CRTP<Derived,T>, T>
 {
-	friend bool operator==<>(const c_var_array_CRTP& lhs, const c_var_array_CRTP& rhs);
-
 	// other support
 #ifndef ZAIMONI_FORCE_ISO
 	void NULLPtr() {static_cast<Derived*>(this)->_ptr = NULL;};
@@ -160,6 +158,7 @@
 {
 private:
 	friend class c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>;
+	friend bool operator==<>(const c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>& lhs, const c_var_array_CRTP<_meta_weakautoarray_ptr<T>, T>& rhs);
 	T* _ptr;
 #ifdef ZAIMONI_FORCE_ISO
 	size_t _size;
@@ -298,6 +297,7 @@
 {
 protected:
 	friend class c_var_array_CRTP<_meta_autoarray_ptr<T>, T>;
+	friend bool operator==<>(const c_var_array_CRTP<_meta_autoarray_ptr<T>, T>& lhs, const c_var_array_CRTP<_meta_autoarray_ptr<T>, T>& rhs);
 	T* _ptr;
 #ifdef ZAIMONI_FORCE_ISO
 	size_t _size;
@@ -569,7 +569,7 @@
 	const size_t ub = rhs.size();
 	if (ub!=lhs.size()) return false;
 	if (0==ub) return true;
-	return _value_vector_equal(lhs._ptr,rhs._ptr,ub);
+	return _value_vector_equal(static_cast<const Derived&>(lhs)._ptr,static_cast<const Derived&>(rhs)._ptr,ub);
 }
 
 template<class Derived,class T>



From zaimoni at mail.berlios.de  Mon Apr 25 20:34:42 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 25 Apr 2011 20:34:42 +0200
Subject: [Zcplusplus-commits] r636 - trunk/Zaimoni.STL/metatype
Message-ID: <20110425183442.BBD974814FF@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-25 20:34:42 +0200 (Mon, 25 Apr 2011)
New Revision: 636

Modified:
   trunk/Zaimoni.STL/metatype/c_array.hpp
   trunk/Zaimoni.STL/metatype/operator.hpp
Log:
technical cleanup

Modified: trunk/Zaimoni.STL/metatype/c_array.hpp
===================================================================
--- trunk/Zaimoni.STL/metatype/c_array.hpp	2011-04-24 15:26:41 UTC (rev 635)
+++ trunk/Zaimoni.STL/metatype/c_array.hpp	2011-04-25 18:34:42 UTC (rev 636)
@@ -1,5 +1,5 @@
 // c_array.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 // base types to signal that a class type is meant to be used like a C array.
 
@@ -133,14 +133,6 @@
 			return *this;
 		}
 
-	template<class T2>
-	bool operator==(const static_c_array<T2,N>& rhs) const
-		{	return _vector_equal(this->begin(),rhs.begin(),N);	}
-
-#define ZAIMONI_CROSS_STATIC_C_ARRAY static_c_array<T2,N>
-	ZAIMONI_CROSSSUBTYPE_NOT_EQUAL(template<class T2>,ZAIMONI_CROSS_STATIC_C_ARRAY)
-#undef ZAIMONI_CROSS_STATIC_C_ARRAY
-
 	void swap(static_c_array& y)
 	{	std::swap_ranges(this->begin(),this->end(),y.begin());	};
 
@@ -160,6 +152,14 @@
 	template<size_t Idx> void resize() const {BOOST_STATIC_ASSERT(N==Idx);}
 };
 
+template<class T,size_t N,class U>
+bool operator==(const static_c_array<T,N>& lhs,const static_c_array<U,N>& rhs)
+{return _vector_equal(lhs.begin(),rhs.begin(),N);}
+
+template<class T,size_t N,class U>
+bool operator!=(const static_c_array<T,N>& lhs,const static_c_array<U,N>& rhs)
+{return !(lhs==rhs);}
+
 // optional comparisons
 template<class T, class U, size_t N>
 inline bool

Modified: trunk/Zaimoni.STL/metatype/operator.hpp
===================================================================
--- trunk/Zaimoni.STL/metatype/operator.hpp	2011-04-24 15:26:41 UTC (rev 635)
+++ trunk/Zaimoni.STL/metatype/operator.hpp	2011-04-25 18:34:42 UTC (rev 636)
@@ -1,5 +1,5 @@
 // operator.hpp
-// (C)2009 Kenneth Boyd, license: MIT.txt
+// (C)2009,2011 Kenneth Boyd, license: MIT.txt
 
 // some macros to assist in extension of operators
 // modeled on <boost/operator.hpp>, this is a backup header
@@ -7,11 +7,6 @@
 #ifndef ZAIMONI_STL_METATYPE_OPERATOR_HPP
 #define ZAIMONI_STL_METATYPE_OPERATOR_HPP 1
 
-// this is a member function for operator!=
-// use Boost when cross-subtype not needed
-#define ZAIMONI_CROSSSUBTYPE_NOT_EQUAL(TEMPLATE_SPEC,CLASS_SPEC)	\
-	TEMPLATE_SPEC bool operator!=(const CLASS_SPEC& RHS) const {return !(*this==RHS);}
-
 // this defines non-member operators >, <=, >=
 // use Boost when cross-subtype not needed
 #define ZAIMONI_CROSSSUBTYPE_TOTAL_ORDERING(TEMPLATE_SPEC,CLASS_SPEC,CLASS_SPEC2)	\



From zaimoni at mail.berlios.de  Tue Apr 26 21:45:13 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 26 Apr 2011 21:45:13 +0200
Subject: [Zcplusplus-commits] r637 - trunk
Message-ID: <20110426194513.AA5424814FD@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-26 21:45:13 +0200 (Tue, 26 Apr 2011)
New Revision: 637

Modified:
   trunk/str_aux.cpp
Log:
fix C_make_string

Modified: trunk/str_aux.cpp
===================================================================
--- trunk/str_aux.cpp	2011-04-25 18:34:42 UTC (rev 636)
+++ trunk/str_aux.cpp	2011-04-26 19:45:13 UTC (rev 637)
@@ -60,5 +60,6 @@
 	if (!tmp) _fatal("FATAL: RAM exhaustion");
 #endif
 	memmove(tmp,src,src_len);
+	return tmp;
 }
 



From zaimoni at mail.berlios.de  Wed Apr 27 15:28:06 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 27 Apr 2011 15:28:06 +0200
Subject: [Zcplusplus-commits] r638 - trunk
Message-ID: <20110427132807.0DC144813D7@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-27 15:28:06 +0200 (Wed, 27 Apr 2011)
New Revision: 638

Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc.cpp.in
   trunk/CPreproc_pp.cpp
Log:
object file size reduction for MingW32 4.3.3

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2011-04-26 19:45:13 UTC (rev 637)
+++ trunk/CPreproc.cpp	2011-04-27 13:28:06 UTC (rev 638)
@@ -4239,8 +4239,7 @@
 	return 0<=linear_find_lencached(x,x_len,macro_locked_default,macro_locked_default_count);
 }
 
-size_t
-CPreprocessor::function_macro_argument_span(const char* const x) const
+size_t CPreprocessor::function_macro_argument_span(const char* const x) const
 {
 	assert(!is_empty_string(x));
 	if ('('!=x[0]) return 0;
@@ -4533,23 +4532,23 @@
 	return false;
 }
 
-void
-CPreprocessor::object_macro_concatenate(Token<char>& x)
+void CPreprocessor::object_macro_concatenate(Token<char>& x)
 {	//! \pre: x is normalized
 	//! \test cpp/default/Preprocess_macro_novar_concatenate.hpp, cpp/default/Preprocess_macro_novar_concatenate.h
 	if (4>x.size()) return;
 	assert(!strpbrk(x.data(),lang.WhiteSpace+2));	// check for normalization
 	assert(!strchr(x.data(),'\n'));					// check for normalization
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
-	if (lang.line_lex_find(x.data(),x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
+	const char* const x_data = x.data();
+	if (lang.line_lex_find(x_data,x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x_data,x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
 		{
 		assert(!pretokenized.empty());
-		assert(!detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second));
-		assert(!detect_C_concatenation_op(x.data()+pretokenized.back().first, pretokenized.back().second));
+		assert(!detect_C_concatenation_op(x_data+pretokenized.front().first,pretokenized.front().second));
+		assert(!detect_C_concatenation_op(x_data+pretokenized.back().first, pretokenized.back().second));
 		size_t i = pretokenized.size();
 		do	{
 			--i;
-			if (detect_C_concatenation_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+			if (detect_C_concatenation_op(x_data+pretokenized[i].first,pretokenized[i].second))
 				{
 				assert(0<i && pretokenized.size()-1>i);
 				if (_concatenate_single(x,pretokenized.data()+(i-1),lang)) --i;
@@ -4566,29 +4565,31 @@
 	if (4>x.size()) return;
 	assert(!strpbrk(x.data(),lang.WhiteSpace+2));	// check for normalization
 	assert(!strchr(x.data(),'\n'));	// check for normalization
+	const char* const x_data = x.data();
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
-	if (lang.line_lex_find(x.data(),x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
+	if (lang.line_lex_find(x_data,x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x_data,x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
 		{
 		assert(!pretokenized.empty());
-		assert(!detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second));
-		assert(!detect_C_concatenation_op(x.data()+pretokenized.back().first, pretokenized.back().second));
+		assert(!detect_C_concatenation_op(x_data+pretokenized.front().first,pretokenized.front().second));
+		assert(!detect_C_concatenation_op(x_data+pretokenized.back().first, pretokenized.back().second));
 		size_t i = pretokenized.size();
 		do	{
 			--i;
-			if (detect_C_concatenation_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+			if (detect_C_concatenation_op(x_data+pretokenized[i].first,pretokenized[i].second))
 				{
 				assert(0<i && pretokenized.size()-1>i);
-				const bool before_token_is_parameter = (C_TESTFLAG_IDENTIFIER==pretokenized[i-1].third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x.data()+pretokenized[i-1].first,pretokenized[i-1].second) : false;
+				const POD_triple<size_t,size_t,lex_flags>& tmp = pretokenized[i-1];
+				const bool before_token_is_parameter = (C_TESTFLAG_IDENTIFIER==tmp.third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x_data+tmp.first,tmp.second) : false;
 
-				if (detect_C_stringize_op(x.data()+pretokenized[i+1].first,pretokenized[i+1].second))
+				if (detect_C_stringize_op(x_data+pretokenized[i+1].first,pretokenized[i+1].second))
 					{
 					message_header(x);
 					INFORM("warning: order of evaluation of # and ## operators is undefined; evaluating # first (C99 6.10.3.2p2/C++98 16.3.2p2)");
 					message_header(x);
 					// would like these to be errors, but C99 requires accepting
 					if (   !before_token_is_parameter						// not a parameter at all
-						|| (1U<=pretokenized[i-1].first && '#'==x.data()[pretokenized[i-1].first-1])
-						|| (2U<=pretokenized[i-1].first && '%'==x.data()[pretokenized[i-1].first-2] && ':'==x.data()[pretokenized[i-1].first-1]))	// stringized parameter
+						|| (1U<=tmp.first && '#'==x_data[tmp.first-1])
+						|| (2U<=tmp.first && '%'==x_data[tmp.first-2] && ':'==x_data[tmp.first-1]))	// stringized parameter
 						{	//! \test Warn_autofail_concatenation1.hpp
 							//! \test default.nonconforming/Error_autofail_concatenation1.hpp
 							//! \test Warn_autofail_concatenation2.hpp
@@ -4600,7 +4601,7 @@
 							//! \test default.nonconforming/Error_empty_parameter_concatenation1.hpp
 						INC_INFORM((bool_options[boolopt::pedantic]) ? WARN_STR : ERR_STR);
 						INC_INFORM("concatenation fails at macro invocation if parameter ");
-						INC_INFORM(x.data()+pretokenized[i-1].first,pretokenized[i-1].second);
+						INC_INFORM(x_data+tmp.first,tmp.second);
 						INC_INFORM(" is not empty.");
 						}
 					INFORM((bool_options[boolopt::pedantic]) ? "" : " (ZCPP nonconforming pragmatism)");
@@ -4612,13 +4613,13 @@
 
 				// will not be be able to complete concatenation against a parameter, bail
 				// accept some inefficiency in a weird case to avoid code duplication
-				const bool after_token_is_parameter = (C_TESTFLAG_IDENTIFIER==pretokenized[i+1].third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x.data()+pretokenized[i+1].first,pretokenized[i+1].second) : false;
+				const bool after_token_is_parameter = (C_TESTFLAG_IDENTIFIER==pretokenized[i+1].third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x_data+pretokenized[i+1].first,pretokenized[i+1].second) : false;
 
 				// Of course, C/C++ can't concatenate a string with anything except an empty parameter.
 				if (before_token_is_parameter)
 					{
-					if (	(1U<=pretokenized[i-1].first && '#'==x.data()[pretokenized[i-1].first-1])
-						|| 	(2U<=pretokenized[i-1].first && '%'==x.data()[pretokenized[i-1].first-2] && ':'==x.data()[pretokenized[i-1].first-1]))
+					if (	(1U<=tmp.first && '#'==x_data[tmp.first-1])
+						|| 	(2U<=tmp.first && '%'==x_data[tmp.first-2] && ':'==x_data[tmp.first-1]))
 						{	// stringized parameter
 						message_header(x);
 						INFORM("warning: order of evaluation of # and ## operators is undefined; evaluating # first (C99 6.10.3.2p2/C++98 16.3.2p2)");
@@ -4628,7 +4629,7 @@
 							{	//! \test Warn_autofail_concatenation3.hpp
 								//! \test default.nonconforming/Error_autofail_concatenation3.hpp
 							INC_INFORM("concatenation fails at macro invocation if parameter ");
-							INC_INFORM(x.data()+pretokenized[i+1].first,pretokenized[i+1].second);
+							INC_INFORM(x_data+pretokenized[i+1].first,pretokenized[i+1].second);
 							INC_INFORM(" is not empty.");
 							}
 						else	//! \test Warn_empty_parameter_concatenation2.hpp

Modified: trunk/CPreproc.cpp.in
===================================================================
--- trunk/CPreproc.cpp.in	2011-04-26 19:45:13 UTC (rev 637)
+++ trunk/CPreproc.cpp.in	2011-04-27 13:28:06 UTC (rev 638)
@@ -4292,8 +4292,7 @@
 	return 0<=linear_find_lencached(x,x_len,macro_locked_default,macro_locked_default_count);
 }
 
-size_t
-CPreprocessor::function_macro_argument_span(const char* const x) const
+size_t CPreprocessor::function_macro_argument_span(const char* const x) const
 {
 	assert(!is_empty_string(x));
 	if ('('!=x[0]) return 0;
@@ -4586,23 +4585,23 @@
 	return false;
 }
 
-void
-CPreprocessor::object_macro_concatenate(Token<char>& x)
+void CPreprocessor::object_macro_concatenate(Token<char>& x)
 {	//! \pre: x is normalized
 	//! \test cpp/default/Preprocess_macro_novar_concatenate.hpp, cpp/default/Preprocess_macro_novar_concatenate.h
 	if (4>x.size()) return;
 	assert(!strpbrk(x.data(),lang.WhiteSpace+2));	// check for normalization
 	assert(!strchr(x.data(),'\n'));					// check for normalization
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
-	if (lang.line_lex_find(x.data(),x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
+	const char* const x_data = x.data();
+	if (lang.line_lex_find(x_data,x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x_data,x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
 		{
 		assert(!pretokenized.empty());
-		assert(!detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second));
-		assert(!detect_C_concatenation_op(x.data()+pretokenized.back().first, pretokenized.back().second));
+		assert(!detect_C_concatenation_op(x_data+pretokenized.front().first,pretokenized.front().second));
+		assert(!detect_C_concatenation_op(x_data+pretokenized.back().first, pretokenized.back().second));
 		size_t i = pretokenized.size();
 		do	{
 			--i;
-			if (detect_C_concatenation_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+			if (detect_C_concatenation_op(x_data+pretokenized[i].first,pretokenized[i].second))
 				{
 				assert(0<i && pretokenized.size()-1>i);
 				if (_concatenate_single(x,pretokenized.data()+(i-1),lang)) --i;
@@ -4619,29 +4618,31 @@
 	if (4>x.size()) return;
 	assert(!strpbrk(x.data(),lang.WhiteSpace+2));	// check for normalization
 	assert(!strchr(x.data(),'\n'));	// check for normalization
+	const char* const x_data = x.data();
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
-	if (lang.line_lex_find(x.data(),x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
+	if (lang.line_lex_find(x_data,x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x_data,x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
 		{
 		assert(!pretokenized.empty());
-		assert(!detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second));
-		assert(!detect_C_concatenation_op(x.data()+pretokenized.back().first, pretokenized.back().second));
+		assert(!detect_C_concatenation_op(x_data+pretokenized.front().first,pretokenized.front().second));
+		assert(!detect_C_concatenation_op(x_data+pretokenized.back().first, pretokenized.back().second));
 		size_t i = pretokenized.size();
 		do	{
 			--i;
-			if (detect_C_concatenation_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+			if (detect_C_concatenation_op(x_data+pretokenized[i].first,pretokenized[i].second))
 				{
 				assert(0<i && pretokenized.size()-1>i);
-				const bool before_token_is_parameter = (C_TESTFLAG_IDENTIFIER==pretokenized[i-1].third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x.data()+pretokenized[i-1].first,pretokenized[i-1].second) : false;
+				const POD_triple<size_t,size_t,lex_flags>& tmp = pretokenized[i-1];
+				const bool before_token_is_parameter = (C_TESTFLAG_IDENTIFIER==tmp.third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x_data+tmp.first,tmp.second) : false;
 
-				if (detect_C_stringize_op(x.data()+pretokenized[i+1].first,pretokenized[i+1].second))
+				if (detect_C_stringize_op(x_data+pretokenized[i+1].first,pretokenized[i+1].second))
 					{
 					message_header(x);
 					INFORM("warning: order of evaluation of # and ## operators is undefined; evaluating # first (C99 6.10.3.2p2/C++98 16.3.2p2)");
 					message_header(x);
 					// would like these to be errors, but C99 requires accepting
 					if (   !before_token_is_parameter						// not a parameter at all
-						|| (1U<=pretokenized[i-1].first && '#'==x.data()[pretokenized[i-1].first-1])
-						|| (2U<=pretokenized[i-1].first && '%'==x.data()[pretokenized[i-1].first-2] && ':'==x.data()[pretokenized[i-1].first-1]))	// stringized parameter
+						|| (1U<=tmp.first && '#'==x_data[tmp.first-1])
+						|| (2U<=tmp.first && '%'==x_data[tmp.first-2] && ':'==x_data[tmp.first-1]))	// stringized parameter
 						{	//! \test Warn_autofail_concatenation1.hpp
 							//! \test default.nonconforming/Error_autofail_concatenation1.hpp
 							//! \test Warn_autofail_concatenation2.hpp
@@ -4653,7 +4654,7 @@
 							//! \test default.nonconforming/Error_empty_parameter_concatenation1.hpp
 						INC_INFORM((bool_options[boolopt::pedantic]) ? WARN_STR : ERR_STR);
 						INC_INFORM("concatenation fails at macro invocation if parameter ");
-						INC_INFORM(x.data()+pretokenized[i-1].first,pretokenized[i-1].second);
+						INC_INFORM(x_data+tmp.first,tmp.second);
 						INC_INFORM(" is not empty.");
 						}
 					INFORM((bool_options[boolopt::pedantic]) ? "" : " (ZCPP nonconforming pragmatism)");
@@ -4665,13 +4666,13 @@
 
 				// will not be be able to complete concatenation against a parameter, bail
 				// accept some inefficiency in a weird case to avoid code duplication
-				const bool after_token_is_parameter = (C_TESTFLAG_IDENTIFIER==pretokenized[i+1].third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x.data()+pretokenized[i+1].first,pretokenized[i+1].second) : false;
+				const bool after_token_is_parameter = (C_TESTFLAG_IDENTIFIER==pretokenized[i+1].third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x_data+pretokenized[i+1].first,pretokenized[i+1].second) : false;
 
 				// Of course, C/C++ can't concatenate a string with anything except an empty parameter.
 				if (before_token_is_parameter)
 					{
-					if (	(1U<=pretokenized[i-1].first && '#'==x.data()[pretokenized[i-1].first-1])
-						|| 	(2U<=pretokenized[i-1].first && '%'==x.data()[pretokenized[i-1].first-2] && ':'==x.data()[pretokenized[i-1].first-1]))
+					if (	(1U<=tmp.first && '#'==x_data[tmp.first-1])
+						|| 	(2U<=tmp.first && '%'==x_data[tmp.first-2] && ':'==x_data[tmp.first-1]))
 						{	// stringized parameter
 						message_header(x);
 						INFORM("warning: order of evaluation of # and ## operators is undefined; evaluating # first (C99 6.10.3.2p2/C++98 16.3.2p2)");
@@ -4681,7 +4682,7 @@
 							{	//! \test Warn_autofail_concatenation3.hpp
 								//! \test default.nonconforming/Error_autofail_concatenation3.hpp
 							INC_INFORM("concatenation fails at macro invocation if parameter ");
-							INC_INFORM(x.data()+pretokenized[i+1].first,pretokenized[i+1].second);
+							INC_INFORM(x_data+pretokenized[i+1].first,pretokenized[i+1].second);
 							INC_INFORM(" is not empty.");
 							}
 						else	//! \test Warn_empty_parameter_concatenation2.hpp

Modified: trunk/CPreproc_pp.cpp
===================================================================
--- trunk/CPreproc_pp.cpp	2011-04-26 19:45:13 UTC (rev 637)
+++ trunk/CPreproc_pp.cpp	2011-04-27 13:28:06 UTC (rev 638)
@@ -4197,8 +4197,7 @@
 	return 0<=linear_find_lencached(x,x_len,macro_locked_default,macro_locked_default_count);
 }
 
-size_t
-CPreprocessor::function_macro_argument_span(const char* const x) const
+size_t CPreprocessor::function_macro_argument_span(const char* const x) const
 {
 	assert(!is_empty_string(x));
 	if ('('!=x[0]) return 0;
@@ -4491,23 +4490,23 @@
 	return false;
 }
 
-void
-CPreprocessor::object_macro_concatenate(Token<char>& x)
+void CPreprocessor::object_macro_concatenate(Token<char>& x)
 {	//! \pre: x is normalized
 	//! \test cpp/default/Preprocess_macro_novar_concatenate.hpp, cpp/default/Preprocess_macro_novar_concatenate.h
 	if (4>x.size()) return;
 	assert(!strpbrk(x.data(),lang.WhiteSpace+2));	// check for normalization
 	assert(!strchr(x.data(),'\n'));					// check for normalization
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
-	if (lang.line_lex_find(x.data(),x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
+	const char* const x_data = x.data();
+	if (lang.line_lex_find(x_data,x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x_data,x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
 		{
 		assert(!pretokenized.empty());
-		assert(!detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second));
-		assert(!detect_C_concatenation_op(x.data()+pretokenized.back().first, pretokenized.back().second));
+		assert(!detect_C_concatenation_op(x_data+pretokenized.front().first,pretokenized.front().second));
+		assert(!detect_C_concatenation_op(x_data+pretokenized.back().first, pretokenized.back().second));
 		size_t i = pretokenized.size();
 		do	{
 			--i;
-			if (detect_C_concatenation_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+			if (detect_C_concatenation_op(x_data+pretokenized[i].first,pretokenized[i].second))
 				{
 				assert(0<i && pretokenized.size()-1>i);
 				if (_concatenate_single(x,pretokenized.data()+(i-1),lang)) --i;
@@ -4524,29 +4523,31 @@
 	if (4>x.size()) return;
 	assert(!strpbrk(x.data(),lang.WhiteSpace+2));	// check for normalization
 	assert(!strchr(x.data(),'\n'));	// check for normalization
+	const char* const x_data = x.data();
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
-	if (lang.line_lex_find(x.data(),x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
+	if (lang.line_lex_find(x_data,x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x_data,x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
 		{
 		assert(!pretokenized.empty());
-		assert(!detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second));
-		assert(!detect_C_concatenation_op(x.data()+pretokenized.back().first, pretokenized.back().second));
+		assert(!detect_C_concatenation_op(x_data+pretokenized.front().first,pretokenized.front().second));
+		assert(!detect_C_concatenation_op(x_data+pretokenized.back().first, pretokenized.back().second));
 		size_t i = pretokenized.size();
 		do	{
 			--i;
-			if (detect_C_concatenation_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+			if (detect_C_concatenation_op(x_data+pretokenized[i].first,pretokenized[i].second))
 				{
 				assert(0<i && pretokenized.size()-1>i);
-				const bool before_token_is_parameter = (C_TESTFLAG_IDENTIFIER==pretokenized[i-1].third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x.data()+pretokenized[i-1].first,pretokenized[i-1].second) : false;
+				const POD_triple<size_t,size_t,lex_flags>& tmp = pretokenized[i-1];
+				const bool before_token_is_parameter = (C_TESTFLAG_IDENTIFIER==tmp.third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x_data+tmp.first,tmp.second) : false;
 
-				if (detect_C_stringize_op(x.data()+pretokenized[i+1].first,pretokenized[i+1].second))
+				if (detect_C_stringize_op(x_data+pretokenized[i+1].first,pretokenized[i+1].second))
 					{
 					message_header(x);
 					INFORM("warning: order of evaluation of # and ## operators is undefined; evaluating # first (C99 6.10.3.2p2/C++98 16.3.2p2)");
 					message_header(x);
 					// would like these to be errors, but C99 requires accepting
 					if (   !before_token_is_parameter						// not a parameter at all
-						|| (1U<=pretokenized[i-1].first && '#'==x.data()[pretokenized[i-1].first-1])
-						|| (2U<=pretokenized[i-1].first && '%'==x.data()[pretokenized[i-1].first-2] && ':'==x.data()[pretokenized[i-1].first-1]))	// stringized parameter
+						|| (1U<=tmp.first && '#'==x_data[tmp.first-1])
+						|| (2U<=tmp.first && '%'==x_data[tmp.first-2] && ':'==x_data[tmp.first-1]))	// stringized parameter
 						{	//! \test Warn_autofail_concatenation1.hpp
 							//! \test default.nonconforming/Error_autofail_concatenation1.hpp
 							//! \test Warn_autofail_concatenation2.hpp
@@ -4558,7 +4559,7 @@
 							//! \test default.nonconforming/Error_empty_parameter_concatenation1.hpp
 						INC_INFORM((bool_options[boolopt::pedantic]) ? WARN_STR : ERR_STR);
 						INC_INFORM("concatenation fails at macro invocation if parameter ");
-						INC_INFORM(x.data()+pretokenized[i-1].first,pretokenized[i-1].second);
+						INC_INFORM(x_data+tmp.first,tmp.second);
 						INC_INFORM(" is not empty.");
 						}
 					INFORM((bool_options[boolopt::pedantic]) ? "" : " (ZCPP nonconforming pragmatism)");
@@ -4570,13 +4571,13 @@
 
 				// will not be be able to complete concatenation against a parameter, bail
 				// accept some inefficiency in a weird case to avoid code duplication
-				const bool after_token_is_parameter = (C_TESTFLAG_IDENTIFIER==pretokenized[i+1].third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x.data()+pretokenized[i+1].first,pretokenized[i+1].second) : false;
+				const bool after_token_is_parameter = (C_TESTFLAG_IDENTIFIER==pretokenized[i+1].third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x_data+pretokenized[i+1].first,pretokenized[i+1].second) : false;
 
 				// Of course, C/C++ can't concatenate a string with anything except an empty parameter.
 				if (before_token_is_parameter)
 					{
-					if (	(1U<=pretokenized[i-1].first && '#'==x.data()[pretokenized[i-1].first-1])
-						|| 	(2U<=pretokenized[i-1].first && '%'==x.data()[pretokenized[i-1].first-2] && ':'==x.data()[pretokenized[i-1].first-1]))
+					if (	(1U<=tmp.first && '#'==x_data[tmp.first-1])
+						|| 	(2U<=tmp.first && '%'==x_data[tmp.first-2] && ':'==x_data[tmp.first-1]))
 						{	// stringized parameter
 						message_header(x);
 						INFORM("warning: order of evaluation of # and ## operators is undefined; evaluating # first (C99 6.10.3.2p2/C++98 16.3.2p2)");
@@ -4586,7 +4587,7 @@
 							{	//! \test Warn_autofail_concatenation3.hpp
 								//! \test default.nonconforming/Error_autofail_concatenation3.hpp
 							INC_INFORM("concatenation fails at macro invocation if parameter ");
-							INC_INFORM(x.data()+pretokenized[i+1].first,pretokenized[i+1].second);
+							INC_INFORM(x_data+pretokenized[i+1].first,pretokenized[i+1].second);
 							INC_INFORM(" is not empty.");
 							}
 						else	//! \test Warn_empty_parameter_concatenation2.hpp



From zaimoni at mail.berlios.de  Thu Apr 28 12:42:25 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 28 Apr 2011 12:42:25 +0200
Subject: [Zcplusplus-commits] r639 - trunk
Message-ID: <20110428104225.A2C3448082F@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-28 12:42:25 +0200 (Thu, 28 Apr 2011)
New Revision: 639

Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc.cpp.in
   trunk/CPreproc_pp.cpp
Log:
object size reduction, MingW32 4.3.3 release mode

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2011-04-27 13:28:06 UTC (rev 638)
+++ trunk/CPreproc.cpp	2011-04-28 10:42:25 UTC (rev 639)
@@ -3703,25 +3703,26 @@
 void
 CPreprocessor::dynamic_function_macro_prereplace_once(const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<Token<char>*>& macros_object_expansion, const autovalarray_ptr<char*>& macros_function, const autovalarray_ptr<Token<char>*>& macros_function_arglist, const autovalarray_ptr<Token<char>*>& macros_function_expansion,autovalarray_ptr<char*>* const used_macro_stack, const autovalarray_ptr<Token<char>*>& formal_arguments, const autovalarray_ptr<Token<char>*>& actual_arguments, Token<char>& x)
 {
+	assert(!actual_arguments.empty());
 	// deal with # operators before macro-replacing arguments
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
 	if (lang.line_lex_find(x.data(),x.size(),"#",sizeof("#")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:",sizeof("%:")-1,pretokenized))
 		{
 		size_t i = pretokenized.size();
 		do	{
-			--i;
-			if (detect_C_stringize_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+			const POD_triple<size_t,size_t,lex_flags>* const origin = pretokenized.data() + --i; 
+			if (detect_C_stringize_op(x.data()+origin[0].first,origin[0].second))
 				{
 				assert(pretokenized.size()>i+1);
-				assert(pretokenized[i].first+pretokenized[i].second==pretokenized[i+1].first);
-				const errr j = (C_TESTFLAG_IDENTIFIER==pretokenized[i].third) ? linear_find_STL_deref2(x.data()+pretokenized[i+1].first,pretokenized[i+1].second,formal_arguments) : -1;
+				assert(origin[0].first+origin[0].second==origin[1].first);
+				const errr j = (C_TESTFLAG_IDENTIFIER==origin[0].third) ? linear_find_STL_deref2(x.data()+origin[1].first,origin[1].second,formal_arguments) : -1;
 				assert(0<=j);
 
 				{
 				autovalarray_ptr<char> stringized_actual;	//! \todo inefficient, should stringize any parameter only once and reuse
 				stringize(stringized_actual,actual_arguments[j]);
 				// safe because narrow string
-				x.replace_once(pretokenized[i].first,pretokenized[i+1].second+pretokenized[i].second,stringized_actual.data());
+				x.replace_once(origin[0].first,origin[1].second+origin[0].second,stringized_actual.data());
 				// XXX leave behind garbage in pretokenized
 				}
 				}
@@ -3740,36 +3741,40 @@
 				size_t k = pretokenized.size();
 				if (3<=k)
 					{
-					do	if (C_TESTFLAG_NONATOMIC_PP_OP_PUNC==pretokenized[--k].third && detect_C_concatenation_op(x.data()+pretokenized[k].first,pretokenized[k].second))
+					do	{
+						const POD_triple<size_t,size_t,lex_flags>* const origin = pretokenized.data() + --k; 
+						const char* const x_data = x.data();
+						if (C_TESTFLAG_NONATOMIC_PP_OP_PUNC==origin[0].third && detect_C_concatenation_op(x_data+origin[0].first,origin[0].second))
 							{
-							if (C_TESTFLAG_IDENTIFIER==pretokenized[k+1].third)
+							if (C_TESTFLAG_IDENTIFIER==origin[1].third)
 								{
-								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k+1].first,pretokenized[k+1].second,formal_arguments);
+								const errr j2 = linear_find_STL_deref2(x_data+origin[1].first,origin[1].second,formal_arguments);
 								if (0<=j2 && !actual_arguments[j2])
 									{	// we matched an empty parameter (concatenation identity)
-									const size_t replace_start = pretokenized[k-1].first+pretokenized[k-1].second;
-									size_t replace_len = (pretokenized[k+1].first-replace_start)+pretokenized[k+1].second;
+									const size_t replace_start = origin[-1].first+origin[-1].second;
+									size_t replace_len = (origin[1].first-replace_start)+origin[1].second;
 									if (x.size()>replace_start+replace_len)
-										replace_len += strspn(x.data()+replace_start+replace_len,lang.WhiteSpace+1);
+										replace_len += strspn(x_data+replace_start+replace_len,lang.WhiteSpace+1);
 									x.replace_once(replace_start,replace_len,' ');
 									continue;
 									}
 								};
-							if (C_TESTFLAG_IDENTIFIER==pretokenized[k-1].third)
+							if (C_TESTFLAG_IDENTIFIER==origin[-1].third)
 								{	// don't need should_continue bypass for last check
-								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k-1].first,pretokenized[k-1].second,formal_arguments);
+								const errr j2 = linear_find_STL_deref2(x_data+origin[-1].first,origin[-1].second,formal_arguments);
 								if (0<=j2 && !actual_arguments[j2])
 									{
-									const size_t replace_start = (0<k) ? pretokenized[k-2].first+pretokenized[k-2].second : 0U;
-									size_t replace_len = (pretokenized[k].first-replace_start)+pretokenized[k].second;
+									const size_t replace_start = (0<k) ? origin[-2].first+origin[-2].second : 0U;
+									size_t replace_len = (origin[0].first-replace_start)+origin[0].second;
 									if (x.size()>replace_start+replace_len)
-										replace_len += strspn(x.data()+replace_start+replace_len,lang.WhiteSpace+1);
+										replace_len += strspn(x_data+replace_start+replace_len,lang.WhiteSpace+1);
 	
-									x.replace_once(pretokenized[k-1].first,(pretokenized[k].first-pretokenized[k-1].first)+pretokenized[k].second,' ');
+									x.replace_once(origin[-1].first,(origin[0].first-origin[-1].first)+origin[0].second,' ');
 //									continue;
 									}
 								};
 							}
+						}
 					while(0<k);
 					};
 				}
@@ -3778,10 +3783,13 @@
 	while(0<j);
 
 	// macro-replace all arguments
-	j = actual_arguments.size();
-	do	if (actual_arguments[--j])
-			intradirective_preprocess(*actual_arguments[j],0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack);
-	while(0<j);
+	{
+	Token<char>* const * const actual_begin = actual_arguments.begin();
+	Token<char>* const * iter = actual_arguments.end();
+	do	if (*(--iter))
+			intradirective_preprocess(**iter,0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack);
+	while(actual_begin!=iter);
+	}
 
 	lang.line_lex(x.data(),x.size(),pretokenized);
 	assert(!pretokenized.empty());

Modified: trunk/CPreproc.cpp.in
===================================================================
--- trunk/CPreproc.cpp.in	2011-04-27 13:28:06 UTC (rev 638)
+++ trunk/CPreproc.cpp.in	2011-04-28 10:42:25 UTC (rev 639)
@@ -3749,25 +3749,26 @@
 void
 CPreprocessor::dynamic_function_macro_prereplace_once(const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<Token<char>*>& macros_object_expansion, const autovalarray_ptr<char*>& macros_function, const autovalarray_ptr<Token<char>*>& macros_function_arglist, const autovalarray_ptr<Token<char>*>& macros_function_expansion,autovalarray_ptr<char*>* const used_macro_stack, const autovalarray_ptr<Token<char>*>& formal_arguments, const autovalarray_ptr<Token<char>*>& actual_arguments, Token<char>& x)
 {
+	assert(!actual_arguments.empty());
 	// deal with # operators before macro-replacing arguments
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
 	if (lang.line_lex_find(x.data(),x.size(),"#",sizeof("#")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:",sizeof("%:")-1,pretokenized))
 		{
 		size_t i = pretokenized.size();
 		do	{
-			--i;
-			if (detect_C_stringize_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+			const POD_triple<size_t,size_t,lex_flags>* const origin = pretokenized.data() + --i; 
+			if (detect_C_stringize_op(x.data()+origin[0].first,origin[0].second))
 				{
 				assert(pretokenized.size()>i+1);
-				assert(pretokenized[i].first+pretokenized[i].second==pretokenized[i+1].first);
-				const errr j = (C_TESTFLAG_IDENTIFIER==pretokenized[i].third) ? linear_find_STL_deref2(x.data()+pretokenized[i+1].first,pretokenized[i+1].second,formal_arguments) : -1;
+				assert(origin[0].first+origin[0].second==origin[1].first);
+				const errr j = (C_TESTFLAG_IDENTIFIER==origin[0].third) ? linear_find_STL_deref2(x.data()+origin[1].first,origin[1].second,formal_arguments) : -1;
 				assert(0<=j);
 
 				{
 				autovalarray_ptr<char> stringized_actual;	//! \todo inefficient, should stringize any parameter only once and reuse
 				stringize(stringized_actual,actual_arguments[j]);
 				// safe because narrow string
-				x.replace_once(pretokenized[i].first,pretokenized[i+1].second+pretokenized[i].second,stringized_actual.data());
+				x.replace_once(origin[0].first,origin[1].second+origin[0].second,stringized_actual.data());
 				// XXX leave behind garbage in pretokenized
 				}
 				}
@@ -3786,36 +3787,40 @@
 				size_t k = pretokenized.size();
 				if (3<=k)
 					{
-					do	if (C_TESTFLAG_NONATOMIC_PP_OP_PUNC==pretokenized[--k].third && detect_C_concatenation_op(x.data()+pretokenized[k].first,pretokenized[k].second))
+					do	{
+						const POD_triple<size_t,size_t,lex_flags>* const origin = pretokenized.data() + --k; 
+						const char* const x_data = x.data();
+						if (C_TESTFLAG_NONATOMIC_PP_OP_PUNC==origin[0].third && detect_C_concatenation_op(x_data+origin[0].first,origin[0].second))
 							{
-							if (C_TESTFLAG_IDENTIFIER==pretokenized[k+1].third)
+							if (C_TESTFLAG_IDENTIFIER==origin[1].third)
 								{
-								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k+1].first,pretokenized[k+1].second,formal_arguments);
+								const errr j2 = linear_find_STL_deref2(x_data+origin[1].first,origin[1].second,formal_arguments);
 								if (0<=j2 && !actual_arguments[j2])
 									{	// we matched an empty parameter (concatenation identity)
-									const size_t replace_start = pretokenized[k-1].first+pretokenized[k-1].second;
-									size_t replace_len = (pretokenized[k+1].first-replace_start)+pretokenized[k+1].second;
+									const size_t replace_start = origin[-1].first+origin[-1].second;
+									size_t replace_len = (origin[1].first-replace_start)+origin[1].second;
 									if (x.size()>replace_start+replace_len)
-										replace_len += strspn(x.data()+replace_start+replace_len,lang.WhiteSpace+1);
+										replace_len += strspn(x_data+replace_start+replace_len,lang.WhiteSpace+1);
 									x.replace_once(replace_start,replace_len,' ');
 									continue;
 									}
 								};
-							if (C_TESTFLAG_IDENTIFIER==pretokenized[k-1].third)
+							if (C_TESTFLAG_IDENTIFIER==origin[-1].third)
 								{	// don't need should_continue bypass for last check
-								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k-1].first,pretokenized[k-1].second,formal_arguments);
+								const errr j2 = linear_find_STL_deref2(x_data+origin[-1].first,origin[-1].second,formal_arguments);
 								if (0<=j2 && !actual_arguments[j2])
 									{
-									const size_t replace_start = (0<k) ? pretokenized[k-2].first+pretokenized[k-2].second : 0U;
-									size_t replace_len = (pretokenized[k].first-replace_start)+pretokenized[k].second;
+									const size_t replace_start = (0<k) ? origin[-2].first+origin[-2].second : 0U;
+									size_t replace_len = (origin[0].first-replace_start)+origin[0].second;
 									if (x.size()>replace_start+replace_len)
-										replace_len += strspn(x.data()+replace_start+replace_len,lang.WhiteSpace+1);
+										replace_len += strspn(x_data+replace_start+replace_len,lang.WhiteSpace+1);
 	
-									x.replace_once(pretokenized[k-1].first,(pretokenized[k].first-pretokenized[k-1].first)+pretokenized[k].second,' ');
+									x.replace_once(origin[-1].first,(origin[0].first-origin[-1].first)+origin[0].second,' ');
 //									continue;
 									}
 								};
 							}
+						}
 					while(0<k);
 					};
 				}
@@ -3824,10 +3829,13 @@
 	while(0<j);
 
 	// macro-replace all arguments
-	j = actual_arguments.size();
-	do	if (actual_arguments[--j])
-			intradirective_preprocess(*actual_arguments[j],0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack);
-	while(0<j);
+	{
+	Token<char>* const * const actual_begin = actual_arguments.begin();
+	Token<char>* const * iter = actual_arguments.end();
+	do	if (*(--iter))
+			intradirective_preprocess(**iter,0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack);
+	while(actual_begin!=iter);
+	}
 
 	lang.line_lex(x.data(),x.size(),pretokenized);
 	assert(!pretokenized.empty());

Modified: trunk/CPreproc_pp.cpp
===================================================================
--- trunk/CPreproc_pp.cpp	2011-04-27 13:28:06 UTC (rev 638)
+++ trunk/CPreproc_pp.cpp	2011-04-28 10:42:25 UTC (rev 639)
@@ -3663,25 +3663,26 @@
 void
 CPreprocessor::dynamic_function_macro_prereplace_once(const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<Token<char>*>& macros_object_expansion, const autovalarray_ptr<char*>& macros_function, const autovalarray_ptr<Token<char>*>& macros_function_arglist, const autovalarray_ptr<Token<char>*>& macros_function_expansion,autovalarray_ptr<char*>* const used_macro_stack, const autovalarray_ptr<Token<char>*>& formal_arguments, const autovalarray_ptr<Token<char>*>& actual_arguments, Token<char>& x)
 {
+	assert(!actual_arguments.empty());
 	// deal with # operators before macro-replacing arguments
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
 	if (lang.line_lex_find(x.data(),x.size(),"#",sizeof("#")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:",sizeof("%:")-1,pretokenized))
 		{
 		size_t i = pretokenized.size();
 		do	{
-			--i;
-			if (detect_C_stringize_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+			const POD_triple<size_t,size_t,lex_flags>* const origin = pretokenized.data() + --i; 
+			if (detect_C_stringize_op(x.data()+origin[0].first,origin[0].second))
 				{
 				assert(pretokenized.size()>i+1);
-				assert(pretokenized[i].first+pretokenized[i].second==pretokenized[i+1].first);
-				const errr j = (C_TESTFLAG_IDENTIFIER==pretokenized[i].third) ? linear_find_STL_deref2(x.data()+pretokenized[i+1].first,pretokenized[i+1].second,formal_arguments) : -1;
+				assert(origin[0].first+origin[0].second==origin[1].first);
+				const errr j = (C_TESTFLAG_IDENTIFIER==origin[0].third) ? linear_find_STL_deref2(x.data()+origin[1].first,origin[1].second,formal_arguments) : -1;
 				assert(0<=j);
 
 				{
 				autovalarray_ptr<char> stringized_actual;	//! \todo inefficient, should stringize any parameter only once and reuse
 				stringize(stringized_actual,actual_arguments[j]);
 				// safe because narrow string
-				x.replace_once(pretokenized[i].first,pretokenized[i+1].second+pretokenized[i].second,stringized_actual.data());
+				x.replace_once(origin[0].first,origin[1].second+origin[0].second,stringized_actual.data());
 				// XXX leave behind garbage in pretokenized
 				}
 				}
@@ -3700,36 +3701,40 @@
 				size_t k = pretokenized.size();
 				if (3<=k)
 					{
-					do	if (C_TESTFLAG_NONATOMIC_PP_OP_PUNC==pretokenized[--k].third && detect_C_concatenation_op(x.data()+pretokenized[k].first,pretokenized[k].second))
+					do	{
+						const POD_triple<size_t,size_t,lex_flags>* const origin = pretokenized.data() + --k; 
+						const char* const x_data = x.data();
+						if (C_TESTFLAG_NONATOMIC_PP_OP_PUNC==origin[0].third && detect_C_concatenation_op(x_data+origin[0].first,origin[0].second))
 							{
-							if (C_TESTFLAG_IDENTIFIER==pretokenized[k+1].third)
+							if (C_TESTFLAG_IDENTIFIER==origin[1].third)
 								{
-								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k+1].first,pretokenized[k+1].second,formal_arguments);
+								const errr j2 = linear_find_STL_deref2(x_data+origin[1].first,origin[1].second,formal_arguments);
 								if (0<=j2 && !actual_arguments[j2])
 									{	// we matched an empty parameter (concatenation identity)
-									const size_t replace_start = pretokenized[k-1].first+pretokenized[k-1].second;
-									size_t replace_len = (pretokenized[k+1].first-replace_start)+pretokenized[k+1].second;
+									const size_t replace_start = origin[-1].first+origin[-1].second;
+									size_t replace_len = (origin[1].first-replace_start)+origin[1].second;
 									if (x.size()>replace_start+replace_len)
-										replace_len += strspn(x.data()+replace_start+replace_len,lang.WhiteSpace+1);
+										replace_len += strspn(x_data+replace_start+replace_len,lang.WhiteSpace+1);
 									x.replace_once(replace_start,replace_len,' ');
 									continue;
 									}
 								};
-							if (C_TESTFLAG_IDENTIFIER==pretokenized[k-1].third)
+							if (C_TESTFLAG_IDENTIFIER==origin[-1].third)
 								{	// don't need should_continue bypass for last check
-								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k-1].first,pretokenized[k-1].second,formal_arguments);
+								const errr j2 = linear_find_STL_deref2(x_data+origin[-1].first,origin[-1].second,formal_arguments);
 								if (0<=j2 && !actual_arguments[j2])
 									{
-									const size_t replace_start = (0<k) ? pretokenized[k-2].first+pretokenized[k-2].second : 0U;
-									size_t replace_len = (pretokenized[k].first-replace_start)+pretokenized[k].second;
+									const size_t replace_start = (0<k) ? origin[-2].first+origin[-2].second : 0U;
+									size_t replace_len = (origin[0].first-replace_start)+origin[0].second;
 									if (x.size()>replace_start+replace_len)
-										replace_len += strspn(x.data()+replace_start+replace_len,lang.WhiteSpace+1);
+										replace_len += strspn(x_data+replace_start+replace_len,lang.WhiteSpace+1);
 	
-									x.replace_once(pretokenized[k-1].first,(pretokenized[k].first-pretokenized[k-1].first)+pretokenized[k].second,' ');
+									x.replace_once(origin[-1].first,(origin[0].first-origin[-1].first)+origin[0].second,' ');
 //									continue;
 									}
 								};
 							}
+						}
 					while(0<k);
 					};
 				}
@@ -3738,10 +3743,13 @@
 	while(0<j);
 
 	// macro-replace all arguments
-	j = actual_arguments.size();
-	do	if (actual_arguments[--j])
-			intradirective_preprocess(*actual_arguments[j],0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack);
-	while(0<j);
+	{
+	Token<char>* const * const actual_begin = actual_arguments.begin();
+	Token<char>* const * iter = actual_arguments.end();
+	do	if (*(--iter))
+			intradirective_preprocess(**iter,0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack);
+	while(actual_begin!=iter);
+	}
 
 	lang.line_lex(x.data(),x.size(),pretokenized);
 	assert(!pretokenized.empty());



From zaimoni at mail.berlios.de  Thu Apr 28 12:56:21 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 28 Apr 2011 12:56:21 +0200
Subject: [Zcplusplus-commits] r640 - trunk
Message-ID: <20110428105621.6384448085B@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-28 12:56:20 +0200 (Thu, 28 Apr 2011)
New Revision: 640

Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc.cpp.in
   trunk/CPreproc_pp.cpp
Log:
fix theoretical memory leak triggered by throwing std::bad_alloc

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2011-04-28 10:42:25 UTC (rev 639)
+++ trunk/CPreproc.cpp	2011-04-28 10:56:20 UTC (rev 640)
@@ -1801,21 +1801,22 @@
 								}
 							assert(!macros_function_expansion_pre_eval[function_macro_index]->empty());
 							{	//! \test default/Preprocess_*.h/hpp 
-							Token<char>* Tmp = new Token<char>(*macros_function_expansion_pre_eval[function_macro_index]);
+							autoval_ptr<Token<char> > Tmp;
+							Tmp = new Token<char>(*macros_function_expansion_pre_eval[function_macro_index]);
 							Tmp->logical_line = TokenList[i]->logical_line;
 							if (!nonrecursive_macro_replacement_list(Tmp->data()))
 								{	// XXX trashes line information to reuse intrapreprocessing stuff
 								size_t discard = i;
-								Token<char>* Tmp2 = new Token<char>(*TokenList[i]);
+								autoval_ptr<Token<char> > Tmp2;
+								Tmp2 = new Token<char>(*TokenList[i]);
 								while(++discard <= j) Tmp2->append(TokenList[discard]->data());
 								discard = 0;
 								dynamic_macro_replace_once(*Tmp2,discard,TokenList[i]->size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
-								delete Tmp;
-								Tmp = Tmp2;
+								Tmp2.MoveInto(Tmp);
 								}
 							TokenList.DeleteNSlotsAt(j-i,i+1);
 							delete TokenList[i];
-							TokenList[i] = Tmp;
+							TokenList[i] = Tmp.release();
 							}
 							size_t actual_tokens = tokenize_line(TokenList,i);
 							assert(0<actual_tokens);

Modified: trunk/CPreproc.cpp.in
===================================================================
--- trunk/CPreproc.cpp.in	2011-04-28 10:42:25 UTC (rev 639)
+++ trunk/CPreproc.cpp.in	2011-04-28 10:56:20 UTC (rev 640)
@@ -1838,21 +1838,22 @@
 								}
 							assert(!macros_function_expansion_pre_eval[function_macro_index]->empty());
 							{	//! \test default/Preprocess_*.h/hpp 
-							Token<char>* Tmp = new Token<char>(*macros_function_expansion_pre_eval[function_macro_index]);
+							autoval_ptr<Token<char> > Tmp;
+							Tmp = new Token<char>(*macros_function_expansion_pre_eval[function_macro_index]);
 							Tmp->logical_line = TokenList[i]->logical_line;
 							if (!nonrecursive_macro_replacement_list(Tmp->data()))
 								{	// XXX trashes line information to reuse intrapreprocessing stuff
 								size_t discard = i;
-								Token<char>* Tmp2 = new Token<char>(*TokenList[i]);
+								autoval_ptr<Token<char> > Tmp2;
+								Tmp2 = new Token<char>(*TokenList[i]);
 								while(++discard <= j) Tmp2->append(TokenList[discard]->data());
 								discard = 0;
 								dynamic_macro_replace_once(*Tmp2,discard,TokenList[i]->size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
-								delete Tmp;
-								Tmp = Tmp2;
+								Tmp2.MoveInto(Tmp);
 								}
 							TokenList.DeleteNSlotsAt(j-i,i+1);
 							delete TokenList[i];
-							TokenList[i] = Tmp;
+							TokenList[i] = Tmp.release();
 							}
 							size_t actual_tokens = tokenize_line(TokenList,i);
 							assert(0<actual_tokens);

Modified: trunk/CPreproc_pp.cpp
===================================================================
--- trunk/CPreproc_pp.cpp	2011-04-28 10:42:25 UTC (rev 639)
+++ trunk/CPreproc_pp.cpp	2011-04-28 10:56:20 UTC (rev 640)
@@ -1769,21 +1769,22 @@
 								}
 							assert(!macros_function_expansion_pre_eval[function_macro_index]->empty());
 							{	//! \test default/Preprocess_*.h/hpp 
-							Token<char>* Tmp = new Token<char>(*macros_function_expansion_pre_eval[function_macro_index]);
+							autoval_ptr<Token<char> > Tmp;
+							Tmp = new Token<char>(*macros_function_expansion_pre_eval[function_macro_index]);
 							Tmp->logical_line = TokenList[i]->logical_line;
 							if (!nonrecursive_macro_replacement_list(Tmp->data()))
 								{	// XXX trashes line information to reuse intrapreprocessing stuff
 								size_t discard = i;
-								Token<char>* Tmp2 = new Token<char>(*TokenList[i]);
+								autoval_ptr<Token<char> > Tmp2;
+								Tmp2 = new Token<char>(*TokenList[i]);
 								while(++discard <= j) Tmp2->append(TokenList[discard]->data());
 								discard = 0;
 								dynamic_macro_replace_once(*Tmp2,discard,TokenList[i]->size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
-								delete Tmp;
-								Tmp = Tmp2;
+								Tmp2.MoveInto(Tmp);
 								}
 							TokenList.DeleteNSlotsAt(j-i,i+1);
 							delete TokenList[i];
-							TokenList[i] = Tmp;
+							TokenList[i] = Tmp.release();
 							}
 							size_t actual_tokens = tokenize_line(TokenList,i);
 							assert(0<actual_tokens);



From zaimoni at mail.berlios.de  Thu Apr 28 16:23:04 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 28 Apr 2011 16:23:04 +0200
Subject: [Zcplusplus-commits] r641 - trunk
Message-ID: <20110428142305.2D654480D07@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-28 16:23:04 +0200 (Thu, 28 Apr 2011)
New Revision: 641

Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc.cpp.in
   trunk/CPreproc_pp.cpp
Log:
object size reduction, MingW32 4.3.3 release mode

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2011-04-28 10:56:20 UTC (rev 640)
+++ trunk/CPreproc.cpp	2011-04-28 14:23:04 UTC (rev 641)
@@ -534,9 +534,9 @@
 	assert(!is_empty_string(Text));
 	size_t i = STATIC_SIZE(valid_directives);
 	do	{
-		--i;
-		if (!strncmp(valid_directives[i].first,Text,valid_directives[i].second)
-			&& (valid_directives[i].second==strlen(Text) || lang.IsWS(Text[valid_directives[i].second])))
+		const POD_pair<const char*,size_t>& x = valid_directives[--i]; 
+		if (!strncmp(x.first,Text,x.second)
+			&& (x.second==strlen(Text) || lang.IsWS(Text[x.second])))
 			return i;
 		}
 	while(0<i);

Modified: trunk/CPreproc.cpp.in
===================================================================
--- trunk/CPreproc.cpp.in	2011-04-28 10:56:20 UTC (rev 640)
+++ trunk/CPreproc.cpp.in	2011-04-28 14:23:04 UTC (rev 641)
@@ -556,9 +556,9 @@
 	assert(!is_empty_string(Text));
 	size_t i = STATIC_SIZE(valid_directives);
 	do	{
-		--i;
-		if (!strncmp(valid_directives[i].first,Text,valid_directives[i].second)
-			&& (valid_directives[i].second==strlen(Text) || lang.IsWS(Text[valid_directives[i].second])))
+		const POD_pair<const char*,size_t>& x = valid_directives[--i]; 
+		if (!strncmp(x.first,Text,x.second)
+			&& (x.second==strlen(Text) || lang.IsWS(Text[x.second])))
 			return i;
 		}
 	while(0<i);

Modified: trunk/CPreproc_pp.cpp
===================================================================
--- trunk/CPreproc_pp.cpp	2011-04-28 10:56:20 UTC (rev 640)
+++ trunk/CPreproc_pp.cpp	2011-04-28 14:23:04 UTC (rev 641)
@@ -518,9 +518,9 @@
 	assert(!is_empty_string(Text));
 	size_t i = STATIC_SIZE(valid_directives);
 	do	{
-		--i;
-		if (!strncmp(valid_directives[i].first,Text,valid_directives[i].second)
-			&& (valid_directives[i].second==strlen(Text) || lang.IsWS(Text[valid_directives[i].second])))
+		const POD_pair<const char*,size_t>& x = valid_directives[--i]; 
+		if (!strncmp(x.first,Text,x.second)
+			&& (x.second==strlen(Text) || lang.IsWS(Text[x.second])))
 			return i;
 		}
 	while(0<i);



From zaimoni at mail.berlios.de  Thu Apr 28 16:46:45 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 28 Apr 2011 16:46:45 +0200
Subject: [Zcplusplus-commits] r642 - trunk/tests/cpp
Message-ID: <20110428144645.7544D480D07@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-28 16:46:45 +0200 (Thu, 28 Apr 2011)
New Revision: 642

Added:
   trunk/tests/cpp/run_tests_2.bat
   trunk/tests/cpp/run_tests_2.sh
   trunk/tests/cpp/run_tests_C99_2.bat
   trunk/tests/cpp/run_tests_C99_2.sh
Log:
test drivers for zcc -E

Added: trunk/tests/cpp/run_tests_2.bat
===================================================================
--- trunk/tests/cpp/run_tests_2.bat	                        (rev 0)
+++ trunk/tests/cpp/run_tests_2.bat	2011-04-28 14:46:45 UTC (rev 642)
@@ -0,0 +1,159 @@
+ at REM not sure how far below WinXP this will run
+ at REM runs regression tests for zcc.exe -E
+ at REM (C)2009,2011 Kenneth Boyd, license: MIT.txt
+
+ at setlocal
+ at set BAD_PASS=0
+ at set BAD_PASS_NAME=LastAccepted:
+ at set REJECT_TEST=0
+ at set FAILED=0
+ at set BAD_FAIL_NAME=LastRejected:
+ at set ACCEPT_TEST=0
+ at set CPP=..\..\bin\zcc -E
+ at set CPP_ISO=..\..\bin\zcc -E --pedantic
+ at set CPP_SIGNMAG_NOTRAP=..\..\bin\zcc -E --int-sign-magnitude
+ at set CPP_SIGNMAG_TRAP=..\..\bin\zcc -E --int-sign-magnitude --int-traps
+ at set CPP_ONESCOMP_NOTRAP=..\..\bin\zcc -E --int-ones-complement
+ at set CPP_ONESCOMP_TRAP=..\..\bin\zcc -E --int-ones-complement --int-traps
+ at set CPP_TWOSCOMP_NOTRAP=..\..\bin\zcc -E --int-twos-complement
+ at set CPP_TWOSCOMP_TRAP=..\..\bin\zcc -E --int-twos-complement --int-traps
+
+ at echo Checking ISO error requirements
+ at echo ====
+ at for %%f in (Error*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (UNICODE.C99\Error*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (UNICODE.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (UNICODE.C99\Error*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (UNICODE.C99\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (define.C99\Error*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (define.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (define.C99\Error*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (define.C99\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (defined.C99\Error*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (defined.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (defined.C99\Error*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (defined.C99\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (ifdef.C99\Error*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (ifdef.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (ifdef.C99\Error*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (ifdef.C99\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (if.C99\Error*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (if.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (if.C99\Error*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (if.C99\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (line.C99\Error*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (line.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (line.C99\Error*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (line.C99\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (pragma.C99\Error*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (pragma.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (pragma.C99\Error*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (pragma.C99\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+
+ at echo Checking ZCC warnings on ISO-accepted code
+ at echo ====
+ at for %%f in (Warn*.h) do @echo %CPP_ISO% -Werror %%f & @%CPP_ISO% -Werror %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (Warn*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (Warn*.h) do @(set /a ACCEPT_TEST=ACCEPT_TEST+1 & set /a REJECT_TEST=REJECT_TEST+1)
+ at for %%f in (Warn*.hpp) do @echo %CPP_ISO% -Werror %%f & @%CPP_ISO% -Werror %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (Warn*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (Warn*.hpp) do @(set /a ACCEPT_TEST=ACCEPT_TEST+1 & set /a REJECT_TEST=REJECT_TEST+1)
+
+ at echo Checking ISO acceptance requirements
+ at echo ====
+ at for %%f in (Pass*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (Pass*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (define.C99\Pass*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (define.C99\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (define.C99\Pass*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (define.C99\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (if.C99\Pass*.h) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (if.C99\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (if.C99\Pass*.hpp) do @echo %CPP_ISO% %%f & @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (if.C99\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+
+ at echo Checking ZCC implementation-defined errors and features
+ at echo ====
+ at for %%f in (default\Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (default\Error*.hpp) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (default\keywords\Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default\keywords\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (default\keywords\Error*.hpp) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default\keywords\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (default\has_include\Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default\has_include\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (default\has_include\Error*.hpp) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default\has_include\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (default\has_include\Pass*.h) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\has_include\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\has_include\Pass*.hpp) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\has_include\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\Pass*.h) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\Pass*.hpp) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\signmag.core\Pass*.h) do @echo %CPP_SIGNMAG_NOTRAP% %%f & @%CPP_SIGNMAG_NOTRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\signmag.core\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\signmag.core\Pass*.hpp) do @echo %CPP_SIGNMAG_NOTRAP% %%f & @%CPP_SIGNMAG_NOTRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\signmag.core\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\signmag.notrap\Pass*.h) do @echo %CPP_SIGNMAG_NOTRAP% %%f & @%CPP_SIGNMAG_NOTRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\signmag.notrap\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\signmag.notrap\Pass*.hpp) do @echo %CPP_SIGNMAG_NOTRAP% %%f & @%CPP_SIGNMAG_NOTRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\signmag.notrap\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\signmag.core\Pass*.h) do @echo %CPP_SIGNMAG_TRAP% %%f & @%CPP_SIGNMAG_TRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\signmag.core\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\signmag.core\Pass*.hpp) do @echo %CPP_SIGNMAG_TRAP% %%f & @%CPP_SIGNMAG_TRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\signmag.core\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\signmag.trap\Error*.h) do @echo %CPP_SIGNMAG_TRAP% %%f & @%CPP_SIGNMAG_TRAP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default\signmag.trap\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (default\signmag.trap\Error*.hpp) do @echo %CPP_SIGNMAG_TRAP% %%f & @%CPP_SIGNMAG_TRAP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default\signmag.trap\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (default\onescomp.core\Pass*.h) do @echo %CPP_ONESCOMP_NOTRAP% %%f & @%CPP_ONESCOMP_NOTRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\onescomp.core\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\onescomp.core\Pass*.hpp) do @echo %CPP_ONESCOMP_NOTRAP% %%f & @%CPP_ONESCOMP_NOTRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\onescomp.core\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\onescomp.notrap\Pass*.h) do @echo %CPP_ONESCOMP_NOTRAP% %%f & @%CPP_ONESCOMP_NOTRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\onescomp.notrap\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\onescomp.notrap\Pass*.hpp) do @echo %CPP_ONESCOMP_NOTRAP% %%f & @%CPP_ONESCOMP_NOTRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\onescomp.notrap\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\onescomp.core\Pass*.h) do @echo %CPP_ONESCOMP_TRAP% %%f & @%CPP_ONESCOMP_TRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\onescomp.core\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\onescomp.core\Pass*.hpp) do @echo %CPP_ONESCOMP_TRAP% %%f & @%CPP_ONESCOMP_TRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\onescomp.core\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\onescomp.trap\Error*.h) do @echo %CPP_ONESCOMP_TRAP% %%f & @%CPP_ONESCOMP_TRAP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default\onescomp.trap\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (default\onescomp.trap\Error*.hpp) do @echo %CPP_ONESCOMP_TRAP% %%f & @%CPP_ONESCOMP_TRAP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default\onescomp.trap\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (default\twoscomp.notrap\Pass*.h) do @echo %CPP_TWOSCOMP_NOTRAP% %%f & @%CPP_TWOSCOMP_NOTRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\twoscomp.notrap\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\twoscomp.notrap\Pass*.hpp) do @echo %CPP_TWOSCOMP_NOTRAP% %%f & @%CPP_TWOSCOMP_NOTRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\twoscomp.notrap\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\twoscomp.trap\Pass*.h) do @echo %CPP_TWOSCOMP_TRAP% %%f & @%CPP_TWOSCOMP_TRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\twoscomp.trap\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\twoscomp.trap\Pass*.hpp) do @echo %CPP_TWOSCOMP_TRAP% %%f & @%CPP_TWOSCOMP_TRAP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (default\twoscomp.trap\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (default\twoscomp.trap\Error*.h) do @echo %CPP_TWOSCOMP_TRAP% %%f & @%CPP_TWOSCOMP_TRAP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default\twoscomp.trap\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (default\twoscomp.trap\Error*.hpp) do @echo %CPP_TWOSCOMP_TRAP% %%f & @%CPP_TWOSCOMP_TRAP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default\twoscomp.trap\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+
+ at echo Checking ZCC nonconforming errors
+ at echo ====
+ at for %%f in (default.nonconforming\Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default.nonconforming\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (default.nonconforming\Error*.hpp) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (default.nonconforming\Error*.hpp) do @set /a REJECT_TEST=REJECT_TEST+1
+
+ at echo Checking ZCC content transforms
+ at echo ====
+
+ at echo %BAD_PASS% of %REJECT_TEST% rejection tests accepted
+ at if not "%BAD_PASS_NAME%"=="LastAccepted:" @echo %BAD_PASS_NAME%
+ at echo %FAILED% of %ACCEPT_TEST% acceptance tests rejected
+ at if not "%BAD_FAIL_NAME%"=="LastRejected:" @echo %BAD_FAIL_NAME%
+

Added: trunk/tests/cpp/run_tests_2.sh
===================================================================
--- trunk/tests/cpp/run_tests_2.sh	                        (rev 0)
+++ trunk/tests/cpp/run_tests_2.sh	2011-04-28 14:46:45 UTC (rev 642)
@@ -0,0 +1,118 @@
+#!/bin/sh
+# runs regression tests for zcc.exe -E
+# (C)2009,2011 Kenneth Boyd, license: MIT.txt
+
+ASSERT_FAILED=0
+ASSERT_FAIL_NAME=
+
+function code_screen {
+	if test ${1} -eq 3; then let ++ASSERT_FAILED; ASSERT_FAIL_NAME="$ASSERT_FAIL_NAME ${2}"; fi;
+}
+
+function run_tests {
+	local BAD_PASS=0
+	local BAD_PASS_NAME=
+	local REJECT_TEST=0
+	local FAILED=0
+	local BAD_FAIL_NAME=
+	local ACCEPT_TEST=0
+	local CPP="../../bin/zcc -E"
+	local CPP_ISO="../../bin/zcc -E --pedantic"
+	local CPP_SIGNMAG_NOTRAP="../../bin/zcc -E --int-sign-magnitude"
+	local CPP_SIGNMAG_TRAP="../../bin/zcc -E --int-sign-magnitude --int-traps"
+	local CPP_ONESCOMP_NOTRAP="../../bin/zcc -E --int-ones-complement"
+	local CPP_ONESCOMP_TRAP="../../bin/zcc -E --int-ones-complement --int-traps"
+	local CPP_TWOSCOMP_NOTRAP="../../bin/zcc -E --int-twos-complement"
+	local CPP_TWOSCOMP_TRAP="../../bin/zcc -E --int-twos-complement --int-traps"
+
+	echo Checking ISO error requirements
+	echo ====
+	for F in Error*.hpp; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in UNICODE.C99/Error*.h; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in UNICODE.C99/Error*.hpp; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in define.C99/Error*.h; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in define.C99/Error*.hpp; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in defined.C99/Error*.h; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in defined.C99/Error*.hpp; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in ifdef.C99/Error*.h; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in ifdef.C99/Error*.hpp; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in if.C99/Error*.h; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in if.C99/Error*.hpp; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in line.C99/Error*.h; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in line.C99/Error*.hpp; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in pragma.C99/Error*.h; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in pragma.C99/Error*.hpp; do let ++REJECT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+
+	echo Checking ZCC warnings on ISO-accepted code
+	echo ====
+	for F in Warn*.h; do let ++REJECT_TEST; echo $CPP_ISO -Werror $F; if $CPP_ISO -Werror $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in Warn*.h; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in Warn*.hpp; do let ++REJECT_TEST; echo $CPP_ISO -Werror $F; if $CPP_ISO -Werror $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in Warn*.hpp; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+
+	echo Checking ISO acceptance requirements
+	echo ====
+	for F in Pass*.h; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in define.C99/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in define.C99/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in if.C99/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in if.C99/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+
+	echo Checking ZCC implementation-defined errors and features
+	echo ====
+	for F in default/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in default/Error*.hpp; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in default/keywords/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in default/keywords/Error*.hpp; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in default/has_include/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in default/has_include/Error*.hpp; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in default/has_include/Pass*.h; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/has_include/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/Pass*.h; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/signmag.core/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_SIGNMAG_NOTRAP $F; if $CPP_SIGNMAG_NOTRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/signmag.core/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_SIGNMAG_NOTRAP $F; if $CPP_SIGNMAG_NOTRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/signmag.notrap/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_SIGNMAG_NOTRAP $F; if $CPP_SIGNMAG_NOTRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/signmag.notrap/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_SIGNMAG_NOTRAP $F; if $CPP_SIGNMAG_NOTRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/signmag.core/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_SIGNMAG_TRAP $F; if $CPP_SIGNMAG_TRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/signmag.core/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_SIGNMAG_TRAP $F; if $CPP_SIGNMAG_TRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/signmag.trap/Error*.h; do let ++REJECT_TEST; echo $CPP_SIGNMAG_TRAP $F; if $CPP_SIGNMAG_TRAP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in default/signmag.trap/Error*.hpp; do let ++REJECT_TEST; echo $CPP_SIGNMAG_TRAP $F; if $CPP_SIGNMAG_TRAP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in default/onescomp.core/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_ONESCOMP_NOTRAP $F; if $CPP_ONESCOMP_NOTRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/onescomp.core/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_ONESCOMP_NOTRAP $F; if $CPP_ONESCOMP_NOTRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/onescomp.notrap/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_ONESCOMP_NOTRAP $F; if $CPP_ONESCOMP_NOTRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/onescomp.notrap/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_ONESCOMP_NOTRAP $F; if $CPP_ONESCOMP_NOTRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/onescomp.core/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_ONESCOMP_TRAP $F; if $CPP_ONESCOMP_TRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/onescomp.core/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_ONESCOMP_TRAP $F; if $CPP_ONESCOMP_TRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/onescomp.trap/Error*.h; do let ++REJECT_TEST; echo $CPP_ONESCOMP_TRAP $F; if $CPP_ONESCOMP_TRAP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in default/onescomp.trap/Error*.hpp; do let ++REJECT_TEST; echo $CPP_ONESCOMP_TRAP $F; if $CPP_ONESCOMP_TRAP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in default/twoscomp.notrap/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_TWOSCOMP_NOTRAP $F; if $CPP_TWOSCOMP_NOTRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/twoscomp.notrap/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_TWOSCOMP_NOTRAP $F; if $CPP_TWOSCOMP_NOTRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/twoscomp.trap/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_TWOSCOMP_TRAP $F; if $CPP_TWOSCOMP_TRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/twoscomp.trap/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_TWOSCOMP_TRAP $F; if $CPP_TWOSCOMP_TRAP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/twoscomp.trap/Error*.h; do let ++REJECT_TEST; echo $CPP_TWOSCOMP_TRAP $F; if $CPP_TWOSCOMP_TRAP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in default/twoscomp.trap/Error*.hpp; do let ++REJECT_TEST; echo $CPP_TWOSCOMP_TRAP $F; if $CPP_TWOSCOMP_TRAP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+
+	echo Checking ZCC nonconforming errors
+	echo ====
+	for F in default.nonconforming/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in default.nonconforming/Error*.hpp; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+
+	echo Checking ZCC content transforms
+	echo ====
+	for F in default/Preprocess*.h; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F | cmp - $F.txt; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in default/Preprocess*.hpp; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F | cmp - $F.txt; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in line.C99/Preprocess*.h; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F | cmp - $F.txt; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in line.C99/Preprocess*.hpp; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F | cmp - $F.txt; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+
+	echo -E $BAD_PASS of $REJECT_TEST rejection tests accepted
+	if test -n "$BAD_PASS_NAME"; then echo -E $BAD_PASS_NAME; fi
+	echo -E $FAILED of $ACCEPT_TEST acceptance tests rejected
+	if test -n "$BAD_FAIL_NAME"; then echo -E $BAD_FAIL_NAME; fi
+	echo -E $ASSERT_FAILED tests failed by critical bugs
+	if test -n "$ASSERT_FAIL_NAME"; then echo -E $ASSERT_FAIL_NAME; fi
+}
+
+run_tests
+

Added: trunk/tests/cpp/run_tests_C99_2.bat
===================================================================
--- trunk/tests/cpp/run_tests_C99_2.bat	                        (rev 0)
+++ trunk/tests/cpp/run_tests_C99_2.bat	2011-04-28 14:46:45 UTC (rev 642)
@@ -0,0 +1,44 @@
+ at REM not sure how far below WinXP this will run
+ at REM runs only C99 regression tests for zcc.exe -E
+ at REM (C)2009,2011 Kenneth Boyd, license: MIT.txt
+ at setlocal
+ at set BAD_PASS=0
+ at set BAD_PASS_NAME=LastAccepted:
+ at set REJECT_TEST=0
+ at set FAILED=0
+ at set BAD_FAIL_NAME=LastRejected:
+ at set ACCEPT_TEST=0
+ at set CPP=..\..\bin\zcc -E --pedantic
+
+ at echo Checking ISO error requirements
+ at echo ====
+ at for %%f in (UNICODE.C99\Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (UNICODE.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (define.C99\Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (define.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (defined.C99\Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (defined.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (ifdef.C99\Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (ifdef.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (if.C99\Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (if.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (line.C99\Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (line.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+ at for %%f in (pragma.C99\Error*.h) do @echo %CPP% %%f & @%CPP% %%f && (set /a BAD_PASS=BAD_PASS+1 & set BAD_PASS_NAME=%BAD_PASS_NAME% %%f)
+ at for %%f in (pragma.C99\Error*.h) do @set /a REJECT_TEST=REJECT_TEST+1
+
+ at echo Checking ISO acceptance requirements
+ at echo ====
+ at for %%f in (Warn*.h) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (Warn*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (Pass*.h) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (define.C99\Pass*.h) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (define.C99\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+ at for %%f in (if.C99\Pass*.h) do @echo %CPP% %%f & @%CPP% %%f || (set /a FAILED=FAILED+1 & set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
+ at for %%f in (if.C99\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
+
+ at echo %BAD_PASS% of %REJECT_TEST% rejection tests accepted
+ at if not "%BAD_PASS_NAME%"=="LastAccepted:" @echo %BAD_PASS_NAME%
+ at echo %FAILED% of %ACCEPT_TEST% acceptance tests rejected
+ at if not "%BAD_FAIL_NAME%"=="LastRejected:" @echo %BAD_FAIL_NAME%

Added: trunk/tests/cpp/run_tests_C99_2.sh
===================================================================
--- trunk/tests/cpp/run_tests_C99_2.sh	                        (rev 0)
+++ trunk/tests/cpp/run_tests_C99_2.sh	2011-04-28 14:46:45 UTC (rev 642)
@@ -0,0 +1,45 @@
+#!/bin/sh
+# runs only C99 regression tests for zcc.exe -E
+# (C)2009,2011 Kenneth Boyd, license: MIT.txt
+ASSERT_FAILED=0
+ASSERT_FAIL_NAME=
+
+function code_screen {
+	if test ${1} -eq 3; then let ++ASSERT_FAILED; ASSERT_FAIL_NAME="$ASSERT_FAIL_NAME ${2}"; fi;
+}
+
+function run_tests {
+	local BAD_PASS=0
+	local BAD_PASS_NAME=
+	local REJECT_TEST=0
+	local FAILED=0
+	local BAD_FAIL_NAME=
+	local ACCEPT_TEST=0
+	local CPP="../../bin/zcc -E --pedantic"
+
+	echo Checking ISO error requirements
+	echo ====
+	for F in UNICODE.C99/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in define.C99/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in defined.C99/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in ifdef.C99/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in if.C99/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in line.C99/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+	for F in pragma.C99/Error*.h; do let ++REJECT_TEST; echo $CPP $F; if $CPP $F; then let ++BAD_PASS; BAD_PASS_NAME="$BAD_PASS_NAME $F"; else code_screen $? $F; fi; done;
+
+	echo Checking ISO acceptance requirements
+	echo ====
+	for F in Warn*.h; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in Pass*.h; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in define.C99/Pass*.h; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+	for F in if.C99/Pass*.h; do let ++ACCEPT_TEST; echo $CPP $F; if $CPP $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME="$BAD_FAIL_NAME $F"; fi; done;
+
+	echo -E $BAD_PASS of $REJECT_TEST rejection tests accepted
+	if test -n "$BAD_PASS_NAME"; then echo -E $BAD_PASS_NAME; fi
+	echo -E $FAILED of $ACCEPT_TEST acceptance tests rejected
+	if test -n "$BAD_FAIL_NAME"; then echo -E $BAD_FAIL_NAME; fi
+	echo -E $ASSERT_FAILED tests failed by critical bugs
+	if test -n "$ASSERT_FAIL_NAME"; then echo -E $ASSERT_FAIL_NAME; fi
+}
+
+run_tests



From zaimoni at mail.berlios.de  Thu Apr 28 23:30:37 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 28 Apr 2011 23:30:37 +0200
Subject: [Zcplusplus-commits] r643 - in trunk: . Zaimoni.STL/LexParse
Message-ID: <20110428213037.77F60480F93@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-28 23:30:37 +0200 (Thu, 28 Apr 2011)
New Revision: 643

Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc.cpp.in
   trunk/CPreproc.hpp
   trunk/CPreproc_pp.cpp
   trunk/CPreproc_pp.hpp
   trunk/Zaimoni.STL/LexParse/LangConf.cpp
   trunk/Zaimoni.STL/LexParse/LangConf.hpp
   trunk/z_cpp.cpp
   trunk/zcc.cpp
Log:
Law of Demeter change: require_padding now a member of LangConf, not CPreprocessor

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2011-04-28 14:46:45 UTC (rev 642)
+++ trunk/CPreproc.cpp	2011-04-28 21:30:37 UTC (rev 643)
@@ -2868,10 +2868,10 @@
 
 	size_t buffer_used = 0;
 	char Buffer[4] = "";
-	if (0<pretokenized[i].first && require_padding(x.data()[pretokenized[i].first-1],src))
+	if (0<pretokenized[i].first && lang.require_padding(x.data()[pretokenized[i].first-1],src))
 		Buffer[buffer_used++] = ' ';
 	Buffer[buffer_used++] = src;
-	if (x.size()>pretokenized[i+delta].first+pretokenized[i+delta].second && require_padding(src,x.data()[pretokenized[i+delta].first+pretokenized[i+delta].second]))
+	if (x.size()>pretokenized[i+delta].first+pretokenized[i+delta].second && lang.require_padding(src,x.data()[pretokenized[i+delta].first+pretokenized[i+delta].second]))
 		Buffer[buffer_used++] = ' ';
 
 	x.replace_once(std::nothrow,pretokenized[i].first,(pretokenized[i+delta].first-pretokenized[i].first)+pretokenized[i+delta].second,Buffer);
@@ -3409,15 +3409,15 @@
 			x.rtrim(token_len);
 		else if (0==critical_offset)
 			x.ltrim(token_len);
-		else if (require_padding(x.data()[critical_offset-1],x.data()[critical_offset+token_len]))
+		else if (lang.require_padding(x.data()[critical_offset-1],x.data()[critical_offset+token_len]))
 			x.replace_once(std::nothrow,critical_offset,token_len,' ');
 		else
 			x.intradelete(critical_offset,token_len);
 		return;
 		}
 
-	const bool pad_left = 0<critical_offset && require_padding(x.data()[critical_offset-1],macro_value[0]);
-	const bool pad_right = x.size()>critical_offset+token_len && require_padding(macro_value[strlen(macro_value)-1],x.data()[critical_offset+token_len]);
+	const bool pad_left = 0<critical_offset && lang.require_padding(x.data()[critical_offset-1],macro_value[0]);
+	const bool pad_right = x.size()>critical_offset+token_len && lang.require_padding(macro_value[strlen(macro_value)-1],x.data()[critical_offset+token_len]);
 
 	if (pad_right) x.replace_once(critical_offset+token_len,0,' ');
 	x.replace_once(critical_offset,token_len,macro_value);
@@ -3964,7 +3964,7 @@
 		size_t i = 0;
 		while(i<list_size)
 			{
-			if (0<i && TokenList[i-1]->logical_line.first==TokenList[i]->logical_line.first && !strcmp(TokenList[i-1]->src_filename,TokenList[i]->src_filename) && require_padding(TokenList[i-1]->back(),TokenList[i]->front()))
+			if (0<i && TokenList[i-1]->logical_line.first==TokenList[i]->logical_line.first && !strcmp(TokenList[i-1]->src_filename,TokenList[i]->src_filename) && lang.require_padding(TokenList[i-1]->back(),TokenList[i]->front()))
 				INC_INFORM(' ');
 
 			if (list_size<=i+1 || TokenList[i]->logical_line.first!=TokenList[i+1]->logical_line.first || strcmp(TokenList[i]->src_filename,TokenList[i+1]->src_filename))
@@ -4364,31 +4364,6 @@
 }
 
 /*! 
- * test whether two characters will glue two non-whitespace preprocessing tokens into one.
- * This can tolerate false positives, but not false negatives.
- * 
- * \param lhs: left-hand character
- * \param rhs: right-hand character
- * 
- * \return bool true iff they will glue tokens
- */
-bool CPreprocessor::require_padding(char lhs, char rhs) const
-{
-	if (strchr(lang.WhiteSpace+1,lhs)) return false;	// whitespace is fine
-	if (strchr(lang.WhiteSpace+1,rhs)) return false;
-	if (strchr(lang.AtomicSymbols,lhs)) return false;	// atomic characters are fine
-	if (strchr(lang.AtomicSymbols,rhs)) return false;
-	if ('\''==lhs || '"'==lhs) return false;	// string/character literals are fine
-	if ('\''==rhs || '"'==rhs) return false;
-	// word-chars glue to word-chars
-	// symbol-chars glue to symbol-chars
-	// universal-char-names will glue as well as normal word-chars
-	const bool rhs_word_char = lang.IsWordChar(rhs);
-	if (lang.IsWordChar(lhs)) return '\\'==rhs || rhs_word_char;
-	return !rhs_word_char;
-}
-
-/*! 
  * Checks that a string has no identifiers within it.  That means no macro replacement can happen within it.
  *
  * \pre lang uses C_TESTFLAG_IDENTIFIER to indicate an identifier was lexed

Modified: trunk/CPreproc.cpp.in
===================================================================
--- trunk/CPreproc.cpp.in	2011-04-28 14:46:45 UTC (rev 642)
+++ trunk/CPreproc.cpp.in	2011-04-28 21:30:37 UTC (rev 643)
@@ -2909,10 +2909,10 @@
 
 	size_t buffer_used = 0;
 	char Buffer[4] = "";
-	if (0<pretokenized[i].first && require_padding(x.data()[pretokenized[i].first-1],src))
+	if (0<pretokenized[i].first && lang.require_padding(x.data()[pretokenized[i].first-1],src))
 		Buffer[buffer_used++] = ' ';
 	Buffer[buffer_used++] = src;
-	if (x.size()>pretokenized[i+delta].first+pretokenized[i+delta].second && require_padding(src,x.data()[pretokenized[i+delta].first+pretokenized[i+delta].second]))
+	if (x.size()>pretokenized[i+delta].first+pretokenized[i+delta].second && lang.require_padding(src,x.data()[pretokenized[i+delta].first+pretokenized[i+delta].second]))
 		Buffer[buffer_used++] = ' ';
 
 	x.replace_once(std::nothrow,pretokenized[i].first,(pretokenized[i+delta].first-pretokenized[i].first)+pretokenized[i+delta].second,Buffer);
@@ -3455,15 +3455,15 @@
 			x.rtrim(token_len);
 		else if (0==critical_offset)
 			x.ltrim(token_len);
-		else if (require_padding(x.data()[critical_offset-1],x.data()[critical_offset+token_len]))
+		else if (lang.require_padding(x.data()[critical_offset-1],x.data()[critical_offset+token_len]))
 			x.replace_once(std::nothrow,critical_offset,token_len,' ');
 		else
 			x.intradelete(critical_offset,token_len);
 		return;
 		}
 
-	const bool pad_left = 0<critical_offset && require_padding(x.data()[critical_offset-1],macro_value[0]);
-	const bool pad_right = x.size()>critical_offset+token_len && require_padding(macro_value[strlen(macro_value)-1],x.data()[critical_offset+token_len]);
+	const bool pad_left = 0<critical_offset && lang.require_padding(x.data()[critical_offset-1],macro_value[0]);
+	const bool pad_right = x.size()>critical_offset+token_len && lang.require_padding(macro_value[strlen(macro_value)-1],x.data()[critical_offset+token_len]);
 
 	if (pad_right) x.replace_once(critical_offset+token_len,0,' ');
 	x.replace_once(critical_offset,token_len,macro_value);
@@ -4010,7 +4010,7 @@
 		size_t i = 0;
 		while(i<list_size)
 			{
-			if (0<i && TokenList[i-1]->logical_line.first==TokenList[i]->logical_line.first && !strcmp(TokenList[i-1]->src_filename,TokenList[i]->src_filename) && require_padding(TokenList[i-1]->back(),TokenList[i]->front()))
+			if (0<i && TokenList[i-1]->logical_line.first==TokenList[i]->logical_line.first && !strcmp(TokenList[i-1]->src_filename,TokenList[i]->src_filename) && lang.require_padding(TokenList[i-1]->back(),TokenList[i]->front()))
 				INC_INFORM(' ');
 
 			if (list_size<=i+1 || TokenList[i]->logical_line.first!=TokenList[i+1]->logical_line.first || strcmp(TokenList[i]->src_filename,TokenList[i+1]->src_filename))
@@ -4417,31 +4417,6 @@
 }
 
 /*! 
- * test whether two characters will glue two non-whitespace preprocessing tokens into one.
- * This can tolerate false positives, but not false negatives.
- * 
- * \param lhs: left-hand character
- * \param rhs: right-hand character
- * 
- * \return bool true iff they will glue tokens
- */
-bool CPreprocessor::require_padding(char lhs, char rhs) const
-{
-	if (strchr(lang.WhiteSpace+1,lhs)) return false;	// whitespace is fine
-	if (strchr(lang.WhiteSpace+1,rhs)) return false;
-	if (strchr(lang.AtomicSymbols,lhs)) return false;	// atomic characters are fine
-	if (strchr(lang.AtomicSymbols,rhs)) return false;
-	if ('\''==lhs || '"'==lhs) return false;	// string/character literals are fine
-	if ('\''==rhs || '"'==rhs) return false;
-	// word-chars glue to word-chars
-	// symbol-chars glue to symbol-chars
-	// universal-char-names will glue as well as normal word-chars
-	const bool rhs_word_char = lang.IsWordChar(rhs);
-	if (lang.IsWordChar(lhs)) return '\\'==rhs || rhs_word_char;
-	return !rhs_word_char;
-}
-
-/*! 
  * Checks that a string has no identifiers within it.  That means no macro replacement can happen within it.
  *
  * \pre lang uses C_TESTFLAG_IDENTIFIER to indicate an identifier was lexed

Modified: trunk/CPreproc.hpp
===================================================================
--- trunk/CPreproc.hpp	2011-04-28 14:46:45 UTC (rev 642)
+++ trunk/CPreproc.hpp	2011-04-28 21:30:37 UTC (rev 643)
@@ -37,12 +37,12 @@
 	bool raw_system_include(const char* const look_for, zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& IncludeTokenList) const;
 
 	void set_debug(bool _debug_mode) {debug_mode = _debug_mode;};
-	bool require_padding(char lhs, char rhs) const;
+	const zaimoni::LangConf& lexer() {return lang;};
 private:
 	uintmax_t counter_macro;
 	uintmax_t include_level;
 	size_t lang_code;
-	zaimoni::LangConf& lang;					//!< lexer corresponding to the language being preprocessed
+	zaimoni::LangConf& lang;	//!< lexer corresponding to the language being preprocessed
 	const virtual_machine::CPUInfo& target_machine;	//!< target machine information
 	const zaimoni::POD_pair<const char*,const char*>* macro_identifier_default;
 	const zaimoni::POD_pair<const char*,size_t>* macro_locked_default; 

Modified: trunk/CPreproc_pp.cpp
===================================================================
--- trunk/CPreproc_pp.cpp	2011-04-28 14:46:45 UTC (rev 642)
+++ trunk/CPreproc_pp.cpp	2011-04-28 21:30:37 UTC (rev 643)
@@ -2828,10 +2828,10 @@
 
 	size_t buffer_used = 0;
 	char Buffer[4] = "";
-	if (0<pretokenized[i].first && require_padding(x.data()[pretokenized[i].first-1],src))
+	if (0<pretokenized[i].first && lang.require_padding(x.data()[pretokenized[i].first-1],src))
 		Buffer[buffer_used++] = ' ';
 	Buffer[buffer_used++] = src;
-	if (x.size()>pretokenized[i+delta].first+pretokenized[i+delta].second && require_padding(src,x.data()[pretokenized[i+delta].first+pretokenized[i+delta].second]))
+	if (x.size()>pretokenized[i+delta].first+pretokenized[i+delta].second && lang.require_padding(src,x.data()[pretokenized[i+delta].first+pretokenized[i+delta].second]))
 		Buffer[buffer_used++] = ' ';
 
 	x.replace_once(std::nothrow,pretokenized[i].first,(pretokenized[i+delta].first-pretokenized[i].first)+pretokenized[i+delta].second,Buffer);
@@ -3369,15 +3369,15 @@
 			x.rtrim(token_len);
 		else if (0==critical_offset)
 			x.ltrim(token_len);
-		else if (require_padding(x.data()[critical_offset-1],x.data()[critical_offset+token_len]))
+		else if (lang.require_padding(x.data()[critical_offset-1],x.data()[critical_offset+token_len]))
 			x.replace_once(std::nothrow,critical_offset,token_len,' ');
 		else
 			x.intradelete(critical_offset,token_len);
 		return;
 		}
 
-	const bool pad_left = 0<critical_offset && require_padding(x.data()[critical_offset-1],macro_value[0]);
-	const bool pad_right = x.size()>critical_offset+token_len && require_padding(macro_value[strlen(macro_value)-1],x.data()[critical_offset+token_len]);
+	const bool pad_left = 0<critical_offset && lang.require_padding(x.data()[critical_offset-1],macro_value[0]);
+	const bool pad_right = x.size()>critical_offset+token_len && lang.require_padding(macro_value[strlen(macro_value)-1],x.data()[critical_offset+token_len]);
 
 	if (pad_right) x.replace_once(critical_offset+token_len,0,' ');
 	x.replace_once(critical_offset,token_len,macro_value);
@@ -3924,7 +3924,7 @@
 		size_t i = 0;
 		while(i<list_size)
 			{
-			if (0<i && TokenList[i-1]->logical_line.first==TokenList[i]->logical_line.first && !strcmp(TokenList[i-1]->src_filename,TokenList[i]->src_filename) && require_padding(TokenList[i-1]->back(),TokenList[i]->front()))
+			if (0<i && TokenList[i-1]->logical_line.first==TokenList[i]->logical_line.first && !strcmp(TokenList[i-1]->src_filename,TokenList[i]->src_filename) && lang.require_padding(TokenList[i-1]->back(),TokenList[i]->front()))
 				INC_INFORM(' ');
 
 			if (list_size<=i+1 || TokenList[i]->logical_line.first!=TokenList[i+1]->logical_line.first || strcmp(TokenList[i]->src_filename,TokenList[i+1]->src_filename))
@@ -4322,31 +4322,6 @@
 }
 
 /*! 
- * test whether two characters will glue two non-whitespace preprocessing tokens into one.
- * This can tolerate false positives, but not false negatives.
- * 
- * \param lhs: left-hand character
- * \param rhs: right-hand character
- * 
- * \return bool true iff they will glue tokens
- */
-bool CPreprocessor::require_padding(char lhs, char rhs) const
-{
-	if (strchr(lang.WhiteSpace+1,lhs)) return false;	// whitespace is fine
-	if (strchr(lang.WhiteSpace+1,rhs)) return false;
-	if (strchr(lang.AtomicSymbols,lhs)) return false;	// atomic characters are fine
-	if (strchr(lang.AtomicSymbols,rhs)) return false;
-	if ('\''==lhs || '"'==lhs) return false;	// string/character literals are fine
-	if ('\''==rhs || '"'==rhs) return false;
-	// word-chars glue to word-chars
-	// symbol-chars glue to symbol-chars
-	// universal-char-names will glue as well as normal word-chars
-	const bool rhs_word_char = lang.IsWordChar(rhs);
-	if (lang.IsWordChar(lhs)) return '\\'==rhs || rhs_word_char;
-	return !rhs_word_char;
-}
-
-/*! 
  * Checks that a string has no identifiers within it.  That means no macro replacement can happen within it.
  *
  * \pre lang uses C_TESTFLAG_IDENTIFIER to indicate an identifier was lexed

Modified: trunk/CPreproc_pp.hpp
===================================================================
--- trunk/CPreproc_pp.hpp	2011-04-28 14:46:45 UTC (rev 642)
+++ trunk/CPreproc_pp.hpp	2011-04-28 21:30:37 UTC (rev 643)
@@ -37,12 +37,12 @@
 	bool raw_system_include(const char* const look_for, zaimoni::autovalarray_ptr<zaimoni::Token<char>* >& IncludeTokenList) const;
 
 	void set_debug(bool _debug_mode) {debug_mode = _debug_mode;};
-	bool require_padding(char lhs, char rhs) const;
+	const zaimoni::LangConf& lexer() {return lang;};
 private:
 	uintmax_t counter_macro;
 	uintmax_t include_level;
 	size_t lang_code;
-	zaimoni::LangConf& lang;					//!< lexer corresponding to the language being preprocessed
+	zaimoni::LangConf& lang;	//!< lexer corresponding to the language being preprocessed
 	const virtual_machine::CPUInfo& target_machine;	//!< target machine information
 	const zaimoni::POD_pair<const char*,const char*>* macro_identifier_default;
 	const zaimoni::POD_pair<const char*,size_t>* macro_locked_default; 

Modified: trunk/Zaimoni.STL/LexParse/LangConf.cpp
===================================================================
--- trunk/Zaimoni.STL/LexParse/LangConf.cpp	2011-04-28 14:46:45 UTC (rev 642)
+++ trunk/Zaimoni.STL/LexParse/LangConf.cpp	2011-04-28 21:30:37 UTC (rev 643)
@@ -505,3 +505,28 @@
 	return true;
 }
 
+/*! 
+ * test whether two characters will glue two non-whitespace preprocessing tokens into one.
+ * This can tolerate false positives, but not false negatives.
+ * 
+ * \param lhs: left-hand character
+ * \param rhs: right-hand character
+ * 
+ * \return bool true iff they will glue tokens
+ */
+bool LangConf::_require_padding(char lhs, char rhs) const
+{
+	if (strchr(WhiteSpace+1,lhs)) return false;	// whitespace is fine
+	if (strchr(WhiteSpace+1,rhs)) return false;
+	if (strchr(AtomicSymbols,lhs)) return false;	// atomic characters are fine
+	if (strchr(AtomicSymbols,rhs)) return false;
+	if ('\''==lhs || '"'==lhs) return false;	// string/character literals are fine
+	if ('\''==rhs || '"'==rhs) return false;
+	// word-chars glue to word-chars
+	// symbol-chars glue to symbol-chars
+	// universal-char-names will glue as well as normal word-chars
+	const bool rhs_word_char = IsWordChar(rhs);
+	if (IsWordChar(lhs)) return '\\'==rhs || rhs_word_char;
+	return !rhs_word_char;
+}
+

Modified: trunk/Zaimoni.STL/LexParse/LangConf.hpp
===================================================================
--- trunk/Zaimoni.STL/LexParse/LangConf.hpp	2011-04-28 14:46:45 UTC (rev 642)
+++ trunk/Zaimoni.STL/LexParse/LangConf.hpp	2011-04-28 21:30:37 UTC (rev 643)
@@ -311,7 +311,14 @@
 		assert(target_len<=strlen(target));
 		return _line_lex_find(x,x_len,target,target_len,pretokenized);
 		};
-
+	bool require_padding(char lhs, char rhs) const
+		{
+		assert(WhiteSpace);
+		assert(AtomicSymbols);
+		assert(IsWordChar);
+		return _require_padding(lhs,rhs);
+		};
+		
 	void NewContext(const char* _filename)	// no clients
 		{
 		error_count = 0;
@@ -350,6 +357,7 @@
 #endif
 	void _line_lex(const char* const x, const size_t x_len, autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized) const;
 	bool _line_lex_find(const char* const x, const size_t x_len, const char* const target, size_t target_len, autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized) const;
+	bool _require_padding(char lhs, char rhs) const;
 };
 
 }	// namespace zaimoni

Modified: trunk/z_cpp.cpp
===================================================================
--- trunk/z_cpp.cpp	2011-04-28 14:46:45 UTC (rev 642)
+++ trunk/z_cpp.cpp	2011-04-28 21:30:37 UTC (rev 643)
@@ -16,6 +16,7 @@
 #include "_version.h"
 
 #include "Zaimoni.STL/POD.hpp"
+#include "Zaimoni.STL/LexParse/LangConf.hpp"
 #include <stdio.h>
 
 error_counter<size_t> zcc_errors(100,"FATAL: too many preprocessing errors");
@@ -258,7 +259,7 @@
 			STL_PTR_STRING_TO_STDOUT(TokenList[i]);
 			if (list_size<=i+1 || TokenList[i]->logical_line.first!=TokenList[i+1]->logical_line.first || strcmp(TokenList[i]->src_filename,TokenList[i+1]->src_filename))
 				STRING_LITERAL_TO_STDOUT("\n");
-			else if (cpp.require_padding(TokenList[i]->back(),TokenList[i+1]->front()))
+			else if (cpp.lexer().require_padding(TokenList[i]->back(),TokenList[i+1]->front()))
 				STRING_LITERAL_TO_STDOUT(" ");
 			++i;
 			};

Modified: trunk/zcc.cpp
===================================================================
--- trunk/zcc.cpp	2011-04-28 14:46:45 UTC (rev 642)
+++ trunk/zcc.cpp	2011-04-28 21:30:37 UTC (rev 643)
@@ -18,6 +18,7 @@
 #include "_version.h"
 
 #include "Zaimoni.STL/POD.hpp"
+#include "Zaimoni.STL/LexParse/LangConf.hpp"
 
 #include <stdio.h>
 
@@ -256,7 +257,7 @@
 				STL_PTR_STRING_TO_STDOUT(TokenList[i]);
 				if (list_size<=i+1 || TokenList[i]->logical_line.first!=TokenList[i+1]->logical_line.first || strcmp(TokenList[i]->src_filename,TokenList[i+1]->src_filename))
 					STRING_LITERAL_TO_STDOUT("\n");
-				else if (cpp.require_padding(TokenList[i]->back(),TokenList[i+1]->front()))
+				else if (cpp.lexer().require_padding(TokenList[i]->back(),TokenList[i+1]->front()))
 					STRING_LITERAL_TO_STDOUT(" ");
 				++i;
 				};
@@ -275,7 +276,7 @@
 				STL_PTR_STRING_TO_STDOUT(TokenList[i]);
 				if (list_size<=i+1 || TokenList[i]->logical_line.first!=TokenList[i+1]->logical_line.first || strcmp(TokenList[i]->src_filename,TokenList[i+1]->src_filename))
 					STRING_LITERAL_TO_STDOUT("\n");
-				else if (cpp.require_padding(TokenList[i]->back(),TokenList[i+1]->front()))
+				else if (cpp.lexer().require_padding(TokenList[i]->back(),TokenList[i+1]->front()))
 					STRING_LITERAL_TO_STDOUT(" ");
 				++i;
 				};



From zaimoni at mail.berlios.de  Fri Apr 29 01:21:03 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 29 Apr 2011 01:21:03 +0200
Subject: [Zcplusplus-commits] r644 - in trunk: . doc lib
Message-ID: <20110428232103.DA9E9480F93@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-29 01:21:03 +0200 (Fri, 29 Apr 2011)
New Revision: 644

Added:
   trunk/lib/zc++-0.0.8/
Removed:
   trunk/lib/zc++-0.0.7/
Modified:
   trunk/_version.h
   trunk/doc/OPTIONS.txt
Log:
adjust version to 0.0.8

Modified: trunk/_version.h
===================================================================
--- trunk/_version.h	2011-04-28 21:30:37 UTC (rev 643)
+++ trunk/_version.h	2011-04-28 23:21:03 UTC (rev 644)
@@ -3,9 +3,9 @@
 /* (C)2010,2011 Kenneth Boyd, license: MIT.txt */
 
 #ifndef ZCC_VERSION
-#define ZCC_VERSION "0.0.7"
+#define ZCC_VERSION "0.0.8"
 #define ZCC_VERSION_MAJOR 0
 #define ZCC_VERSION_MINOR 0
-#define ZCC_VERSION_PATCH 7
+#define ZCC_VERSION_PATCH 8
 #endif
 

Modified: trunk/doc/OPTIONS.txt
===================================================================
--- trunk/doc/OPTIONS.txt	2011-04-28 21:30:37 UTC (rev 643)
+++ trunk/doc/OPTIONS.txt	2011-04-28 23:21:03 UTC (rev 644)
@@ -1,4 +1,4 @@
-Z.C++ 0.0.7 zcc
+Z.C++ 0.0.8 zcc
 usage: zcc [options] infile
 boolean options
  --test: final internal state to stderr
@@ -13,7 +13,8 @@
  --int-neg-div-rounds-away-from-zero: make -3/-2==-2 contrary to C99 recommendation
  -Wc-c++-compat: Warn when something legal in C/C++ would be an error in C++/C for C/C++
  -Wbackport: Warn when something legal would be an error under an older standard
-
+ --src-stdout: Modified source to stdout
+ -E: Only preprocess (should be equivalent to calling z_cpp).  Implies --src-stdout
 override-default options
  -x: language override
  --system-include: unpreprocessed #include<...> to stdout
@@ -25,7 +26,7 @@
  --target-sizeof-long: target sizeof(long), sizeof(unsigned long)
  --target-sizeof-long-long: target sizeof(long long), sizeof(unsigned long long)
 
-Z.C++ 0.0.7 z_cpp
+Z.C++ 0.0.8 z_cpp
 usage: z_cpp [options] infile
 boolean options
  --test: final internal state to stderr
@@ -38,7 +39,6 @@
  -fsigned-char: char acts like signed char
  -funsigned-char: char acts like unsigned char (default)
  --int-neg-div-rounds-away-from-zero: make -3/-2==-2 contrary to C99 recommendation
-
 override-default options
  -x: language override
  --system-include: unpreprocessed #include<...> to stdout



From zaimoni at mail.berlios.de  Sat Apr 30 01:11:29 2011
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 30 Apr 2011 01:11:29 +0200
Subject: [Zcplusplus-commits] r645 - trunk
Message-ID: <20110429231130.6644B481393@sheep.berlios.de>

Author: zaimoni
Date: 2011-04-30 01:11:29 +0200 (Sat, 30 Apr 2011)
New Revision: 645

Added:
   trunk/to_stdout.cpp
   trunk/to_stdout.hpp
Modified:
   trunk/MakeMake.cfg
   trunk/POSIX.dep
   trunk/z_cpp.cpp
   trunk/zcc.cpp
Log:
refactor sending TokenList to stdout

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2011-04-28 23:21:03 UTC (rev 644)
+++ trunk/MakeMake.cfg	2011-04-29 23:11:29 UTC (rev 645)
@@ -1,6 +1,6 @@
 ########
-ProgObjects = {	'bin/z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','type_system_pp','ParseTree','type_spec_pp','CSupport_pp','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','end_nl','load_src','CPreproc_pp','CPreproc_autogen_pp'),
-				'bin/zcc':('zcc','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','end_nl','load_src','CPreproc','CPreproc_autogen','ZParser')}
+ProgObjects = {	'bin/z_cpp':('z_cpp','to_stdout','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','type_system_pp','ParseTree','type_spec_pp','CSupport_pp','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','end_nl','load_src','CPreproc_pp','CPreproc_autogen_pp'),
+				'bin/zcc':('zcc','to_stdout','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','end_nl','load_src','CPreproc','CPreproc_autogen','ZParser')}
 MainPrograms = ['bin/z_cpp','bin/zcc']
 
 # process control

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2011-04-28 23:21:03 UTC (rev 644)
+++ trunk/POSIX.dep	2011-04-29 23:11:29 UTC (rev 645)
@@ -1,11 +1,12 @@
-OBJECTS_BIN/ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_BIN/ZCC_LINK_PRIORITY = ZParser.o CSupport.o ParseTree.o type_system.o zcc.o struct_type.o type_spec.o CPreproc.o CPreproc_autogen.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o uchar_blob.o CPUInfo.o unsigned_var_int.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
+OBJECTS_BIN/ZCC = zcc.o to_stdout.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
+OBJECTS_BIN/ZCC_LINK_PRIORITY = zcc.o to_stdout.o CPreproc.o str_aux.o errors.o CSupport.o ZParser.o ParseTree.o type_system.o struct_type.o type_spec.o CPreproc_autogen.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o uchar_blob.o CPUInfo.o unsigned_var_int.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
 
-OBJECTS_BIN/Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o type_system_pp.o ParseTree.o type_spec_pp.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
-OBJECTS_BIN/Z_CPP_LINK_PRIORITY = CSupport_pp.o ParseTree.o z_cpp.o type_spec_pp.o CPreproc_pp.o type_system_pp.o CPreproc_autogen_pp.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o uchar_blob.o CPUInfo.o unsigned_var_int.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
+OBJECTS_BIN/Z_CPP = z_cpp.o to_stdout.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o type_system_pp.o ParseTree.o type_spec_pp.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
+OBJECTS_BIN/Z_CPP_LINK_PRIORITY = to_stdout.o z_cpp.o CPreproc_pp.o str_aux.o errors.o ParseTree.o CSupport_pp.o type_spec_pp.o type_system_pp.o CPreproc_autogen_pp.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o uchar_blob.o CPUInfo.o unsigned_var_int.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
 
 # dependencies
-zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h type_system.hpp Zaimoni.STL/Perl_localize.hpp
+zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp to_stdout.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h type_system.hpp Zaimoni.STL/Perl_localize.hpp
+to_stdout.o: to_stdout.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 errors.o: errors.hpp langroute.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 langroute.o: langroute.hpp _CSupport1.hpp Zaimoni.STL/Logging.h Zaimoni.STL/POD.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp
 AtomicString.o: AtomicString.h Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -35,7 +36,7 @@
 CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp _CSupport3.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp str_aux.h type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/Perl_localize.hpp DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimon
 i.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 ZParser.o: ZParser.hpp CSupport.hpp _CSupport3.hpp _CSupport4.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp str_aux.h type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/search.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/Perl_localize.hpp Zaimoni.STL/POD.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h weak_token.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/LexParse/MetaToken.hpp
-z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc_pp.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
+z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc_pp.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp to_stdout.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
 type_system_pp.o: type_system_pp.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 type_spec_pp.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system_pp.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uc
 har_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp

Added: trunk/to_stdout.cpp
===================================================================
--- trunk/to_stdout.cpp	                        (rev 0)
+++ trunk/to_stdout.cpp	2011-04-29 23:11:29 UTC (rev 645)
@@ -0,0 +1,21 @@
+#include "to_stdout.hpp"
+#include "Zaimoni.STL/LexParse/LangConf.hpp"
+#include "Zaimoni.STL/LexParse/Token.hpp"
+
+void tokens_to_stdout(const zaimoni::autovalarray_ptr<zaimoni::Token<char>*>& TokenList, const zaimoni::LangConf& lexer) 
+{
+	const size_t list_size = TokenList.size();
+	size_t i = 0;
+	assert(0==list_size || TokenList[0]);
+	while(list_size>i)
+		{
+		STL_PTR_STRING_TO_STDOUT(TokenList[i]);
+		assert(list_size<=i+1 || TokenList[i+1]);
+		if (list_size<=i+1 || TokenList[i]->logical_line.first!=TokenList[i+1]->logical_line.first || strcmp(TokenList[i]->src_filename,TokenList[i+1]->src_filename))
+			STRING_LITERAL_TO_STDOUT("\n");
+		else if (lexer.require_padding(TokenList[i]->back(),TokenList[i+1]->front()))
+			STRING_LITERAL_TO_STDOUT(" ");
+		++i;
+		};
+}
+

Added: trunk/to_stdout.hpp
===================================================================
--- trunk/to_stdout.hpp	                        (rev 0)
+++ trunk/to_stdout.hpp	2011-04-29 23:11:29 UTC (rev 645)
@@ -0,0 +1,12 @@
+#ifndef TO_STDOUT_HPP
+#define TO_STDOUT_HPP 1
+
+namespace zaimoni {
+class LangConf;
+template<class T> class Token;
+template<class T> class autovalarray_ptr;
+}
+
+void tokens_to_stdout(const zaimoni::autovalarray_ptr<zaimoni::Token<char>*>& TokenList, const zaimoni::LangConf& lexer);
+
+#endif

Modified: trunk/z_cpp.cpp
===================================================================
--- trunk/z_cpp.cpp	2011-04-28 23:21:03 UTC (rev 644)
+++ trunk/z_cpp.cpp	2011-04-29 23:11:29 UTC (rev 645)
@@ -13,6 +13,7 @@
 #include "errors.hpp"
 #include "CPUInfo.hpp"
 #include "errcount.hpp"
+#include "to_stdout.hpp"
 #include "_version.h"
 
 #include "Zaimoni.STL/POD.hpp"
@@ -251,18 +252,7 @@
 			}
 
 		// go to stdout as this is the standalone one
-		const size_t list_size = TokenList.size();
-		size_t i = 0;
-		while(list_size>i)
-			{
-			assert(NULL!=TokenList[i]);
-			STL_PTR_STRING_TO_STDOUT(TokenList[i]);
-			if (list_size<=i+1 || TokenList[i]->logical_line.first!=TokenList[i+1]->logical_line.first || strcmp(TokenList[i]->src_filename,TokenList[i+1]->src_filename))
-				STRING_LITERAL_TO_STDOUT("\n");
-			else if (cpp.lexer().require_padding(TokenList[i]->back(),TokenList[i+1]->front()))
-				STRING_LITERAL_TO_STDOUT(" ");
-			++i;
-			};
+		tokens_to_stdout(TokenList,cpp.lexer());
 		}
 	catch(const std::bad_alloc&)
 		{

Modified: trunk/zcc.cpp
===================================================================
--- trunk/zcc.cpp	2011-04-28 23:21:03 UTC (rev 644)
+++ trunk/zcc.cpp	2011-04-29 23:11:29 UTC (rev 645)
@@ -15,6 +15,7 @@
 #include "errcount.hpp"
 #include "ParseTree.hpp"
 #include "ZParser.hpp"
+#include "to_stdout.hpp"
 #include "_version.h"
 
 #include "Zaimoni.STL/POD.hpp"
@@ -248,19 +249,7 @@
 				INFORM(">");
 				return EXIT_FAILURE;
 				}
-			// go to stdout as this is the standalone one
-			const size_t list_size = TokenList.size();
-			size_t i = 0;
-			while(list_size>i)
-				{
-				assert(NULL!=TokenList[i]);
-				STL_PTR_STRING_TO_STDOUT(TokenList[i]);
-				if (list_size<=i+1 || TokenList[i]->logical_line.first!=TokenList[i+1]->logical_line.first || strcmp(TokenList[i]->src_filename,TokenList[i+1]->src_filename))
-					STRING_LITERAL_TO_STDOUT("\n");
-				else if (cpp.lexer().require_padding(TokenList[i]->back(),TokenList[i+1]->front()))
-					STRING_LITERAL_TO_STDOUT(" ");
-				++i;
-				};
+			tokens_to_stdout(TokenList,cpp.lexer());
 			return EXIT_SUCCESS;
 			};
 		if (last_arg_used_in_option) FATAL("file not last argument provided");
@@ -268,18 +257,7 @@
 		cpp.preprocess(TokenList);
 		if (bool_options[boolopt::preprocess_only])
 			{
-			const size_t list_size = TokenList.size();
-			size_t i = 0;
-			while(list_size>i)
-				{
-				assert(NULL!=TokenList[i]);
-				STL_PTR_STRING_TO_STDOUT(TokenList[i]);
-				if (list_size<=i+1 || TokenList[i]->logical_line.first!=TokenList[i+1]->logical_line.first || strcmp(TokenList[i]->src_filename,TokenList[i+1]->src_filename))
-					STRING_LITERAL_TO_STDOUT("\n");
-				else if (cpp.lexer().require_padding(TokenList[i]->back(),TokenList[i+1]->front()))
-					STRING_LITERAL_TO_STDOUT(" ");
-				++i;
-				};
+			tokens_to_stdout(TokenList,cpp.lexer());
 			return EXIT_SUCCESS;
 			}
 		}



