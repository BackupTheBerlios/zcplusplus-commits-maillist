From zaimoni at mail.berlios.de  Mon Oct  4 22:42:23 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon,  4 Oct 2010 22:42:23 +0200
Subject: [Zcplusplus-commits] r490 - trunk
Message-ID: <20101004204223.79A844810E7@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-04 22:42:23 +0200 (Mon, 04 Oct 2010)
New Revision: 490

Modified:
   trunk/CSupport.cpp
Log:
declaration recognizer no longer plans to spot type definitions as well

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-09-12 04:57:14 UTC (rev 489)
+++ trunk/CSupport.cpp	2010-10-04 20:42:23 UTC (rev 490)
@@ -11794,29 +11794,13 @@
 			};
 		// not a decl-specifier; bail out if we already have a type
 		if (base_type.base_type_index) return false;
-		if (PARSE_PRIMARY_TYPE & x.flags)
+		if (PARSE_TYPE & x.flags)
 			{
 			value_copy(base_type,x.type_code);
 			return true;
 			}
 		// handle typedefs
 		if (check_for_typedef(base_type,x.index_tokens[0].token.first,types)) return true;
-		//! \todo handle other known types
-#if 0
-		// we must accept any specifier here: C99 6.7.2p1
-		if (   is_C99_anonymous_specifier(x,"enum")
-			|| is_C99_named_specifier(x,"enum")
-			|| is_C99_named_specifier_definition(x,"enum"))
-			return true;
-		if (   is_C99_anonymous_specifier(x,"struct")
-			|| is_C99_named_specifier(x,"struct")
-			|| is_C99_named_specifier_definition(x,"struct"))
-			return true;
-		if (   is_C99_anonymous_specifier(x,"union")
-			|| is_C99_named_specifier(x,"union")
-			|| is_C99_named_specifier_definition(x,"union"))
-			return true;
-#endif
 		return false;
 		};
 	bool analyze_flags_global(parse_tree& x, size_t i, size_t& decl_count)
@@ -11914,7 +11898,7 @@
 			};
 		// not a decl-specifier; bail out if we already have a type
 		if (base_type.base_type_index) return false;
-		if (PARSE_PRIMARY_TYPE & x.data<0>()[i].flags)
+		if (PARSE_TYPE & x.data<0>()[i].flags)
 			{
 			value_copy(base_type,x.data<0>()[i].type_code);
 			return true;
@@ -11925,37 +11909,9 @@
 			&& !(PARSE_TYPE & x.data<0>()[i].flags)
 			&& !CPP_echo_reserved_keyword(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second)
 			&& (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags))
-			{	// shove Koenig lookup into type_system
-#if 0
-			if (check_for_typedef(base_type,x.data<0>()[i].index_tokens[0].token.first+2,active_namespace,types)) return true;
-			if (check_for_enum(base_type,x.data<0>()[i].index_tokens[0].token.first+2,active_namespace,types)) return true;
-			if (check_for_class_struct_union(base_type,x.data<0>()[i].index_tokens[0].token.first+2,active_namespace,types)) return true;
-			return false;
-#else
+			// shove Koenig lookup into type_system
 			return check_for_typedef(base_type,x.data<0>()[i].index_tokens[0].token.first,active_namespace,types);
-#endif
-			}
 		}
-		//! \todo handle other known types
-#if 0
-		// we must accept any specifier here: C++0X 7.1.6.2p1
-		if (   is_C99_anonymous_specifier(x,"enum")
-			|| is_C99_named_specifier(x,"enum")
-			|| is_C99_named_specifier_definition(x,"enum"))
-			return true;
-		if (   is_C99_anonymous_specifier(x,"struct")
-			|| is_C99_named_specifier(x,"struct")
-			|| is_C99_named_specifier_definition(x,"struct"))
-			return true;
-		if (   is_C99_anonymous_specifier(x,"union")
-			|| is_C99_named_specifier(x,"union")
-			|| is_C99_named_specifier_definition(x,"union"))
-			return true;
-		if (   is_C99_anonymous_specifier(x,"class")
-			|| is_C99_named_specifier(x,"class")
-			|| is_C99_named_specifier_definition(x,"class"))
-			return true;
-#endif
 		return false;
 		};
 	bool analyze_flags_global(parse_tree& x, size_t i, size_t& decl_count)



From zaimoni at mail.berlios.de  Thu Oct  7 11:18:12 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu,  7 Oct 2010 11:18:12 +0200
Subject: [Zcplusplus-commits] r491 - trunk
Message-ID: <20101007091812.5E66E480B1A@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-07 11:18:12 +0200 (Thu, 07 Oct 2010)
New Revision: 491

Modified:
   trunk/MakeMake.cfg
   trunk/POSIX.dep
   trunk/type_system.cpp
   trunk/type_system.hpp
   trunk/type_system_pp.cpp
   trunk/type_system_pp.hpp
Log:
C/C++ preprocessor doesn't have a use for the dynamic_types member of type_system.  Remove and adjust build system.

Modified: trunk/MakeMake.cfg
===================================================================
--- trunk/MakeMake.cfg	2010-10-04 20:42:23 UTC (rev 490)
+++ trunk/MakeMake.cfg	2010-10-07 09:18:12 UTC (rev 491)
@@ -1,5 +1,5 @@
 ########
-ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport_pp','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','end_nl','load_src','CPreproc_pp','CPreproc_autogen_pp'),
+ProgObjects = {	'z_cpp':('z_cpp','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system_pp','ParseTree','type_spec','CSupport_pp','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','end_nl','load_src','CPreproc_pp','CPreproc_autogen_pp'),
 				'zcc':('zcc','errors','langroute','AtomicString','str_aux','lex_core','filesystem','uchar_blob','unsigned_var_int','CPUInfo','struct_type','type_system','ParseTree','type_spec','CSupport','C_PPNumCore','C_PPDecimalInteger','C_PPOctalInteger','C_PPHexInteger','C_PPDecimalFloat','C_PPHexFloat','unsigned_aux','Trigraph','Flat_UNI','end_lc','end_nl','load_src','CPreproc','CPreproc_autogen','ZParser')}
 MainPrograms = ['z_cpp','zcc']
 

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-10-04 20:42:23 UTC (rev 490)
+++ trunk/POSIX.dep	2010-10-07 09:18:12 UTC (rev 491)
@@ -1,8 +1,8 @@
-OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
-OBJECTS_Z_CPP_LINK_PRIORITY = CPreproc_pp.o CSupport_pp.o CPreproc_autogen_pp.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o ParseTree.o type_spec.o uchar_blob.o CPUInfo.o type_system.o unsigned_var_int.o z_cpp.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
+OBJECTS_Z_CPP = z_cpp.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system_pp.o ParseTree.o type_spec.o CSupport_pp.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc_pp.o CPreproc_autogen_pp.o
+OBJECTS_Z_CPP_LINK_PRIORITY = type_system_pp.o CSupport_pp.o CPreproc_pp.o CPreproc_autogen_pp.o ParseTree.o type_spec.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o uchar_blob.o CPUInfo.o unsigned_var_int.o z_cpp.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
 
 OBJECTS_ZCC = zcc.o errors.o langroute.o AtomicString.o str_aux.o lex_core.o filesystem.o uchar_blob.o unsigned_var_int.o CPUInfo.o struct_type.o type_system.o ParseTree.o type_spec.o CSupport.o C_PPNumCore.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPHexInteger.o C_PPDecimalFloat.o C_PPHexFloat.o unsigned_aux.o Trigraph.o Flat_UNI.o end_lc.o end_nl.o load_src.o CPreproc.o CPreproc_autogen.o ZParser.o
-OBJECTS_ZCC_LINK_PRIORITY = CPreproc.o CSupport.o ZParser.o CPreproc_autogen.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o ParseTree.o type_spec.o uchar_blob.o CPUInfo.o type_system.o unsigned_var_int.o zcc.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
+OBJECTS_ZCC_LINK_PRIORITY = type_system.o CSupport.o CPreproc.o CPreproc_autogen.o ZParser.o ParseTree.o type_spec.o load_src.o end_nl.o end_lc.o Trigraph.o Flat_UNI.o errors.o uchar_blob.o CPUInfo.o unsigned_var_int.o zcc.o unsigned_aux.o langroute.o lex_core.o C_PPHexInteger.o AtomicString.o struct_type.o str_aux.o C_PPDecimalInteger.o C_PPOctalInteger.o C_PPDecimalFloat.o C_PPHexFloat.o C_PPNumCore.o filesystem.o
 
 # dependencies
 z_cpp.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc_pp.hpp load_src.hpp AtomicString.h filesystem.h langroute.hpp errors.hpp CPUInfo.hpp errcount.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp
@@ -16,7 +16,7 @@
 unsigned_var_int.o: unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp
 CPUInfo.o: CPUInfo.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/POD.hpp Zaimoni.STL/boost_core.hpp
 struct_type.o: struct_type.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp
-type_system.o: type_system.hpp type_system_pp.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
+type_system_pp.o: type_system_pp.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar
 _blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
@@ -35,6 +35,7 @@
 CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operat
 or.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h type_system.hpp Zaimoni.STL/Perl_localize.hpp
+type_system.o: type_system.hpp type_system_pp.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/Logging.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 CSupport.o: CSupport.hpp _CSupport3.hpp _CSupport4.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp kleene_star.hpp cond_act.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zai
 moni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp _CSupport3.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/lo
 gic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2010-10-04 20:42:23 UTC (rev 490)
+++ trunk/type_system.cpp	2010-10-07 09:18:12 UTC (rev 491)
@@ -5,6 +5,7 @@
 #include "type_system.hpp"
 #/*cut-cpp*/
 #include "type_system_pp.hpp"
+#/*cut-cpp*/
 #include "enum_type.hpp"
 #include "struct_type.hpp"
 #include "Zaimoni.STL/search.hpp"
@@ -17,7 +18,6 @@
 #define DYNAMIC_STRUCTDECL 2
 #define DYNAMIC_C_STRUCTDEF 3
 #define DYNAMIC_ENUMDEF 4
-#/*cut-cpp*/
 
 type_system::type_index type_system::_get_id_union(const char* const x) const
 {
@@ -271,8 +271,10 @@
 {
 	if (0==id) return "(?)";
 	if (core_types_size> --id) return core_types[id].first;
+#/*cut-cpp*/
 	if (dynamic_types.size() > (id -= core_types_size))
 		return dynamic_types[id].first;
+#/*cut-cpp*/
 	return "(?)";
 }
 #/*cut-cpp*/

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2010-10-04 20:42:23 UTC (rev 490)
+++ trunk/type_system.hpp	2010-10-07 09:18:12 UTC (rev 491)
@@ -5,6 +5,7 @@
 #define TYPE_SYSTEM_HPP 1
 
 #include "Zaimoni.STL/POD.hpp"
+#/*cut-cpp*/
 #include "Zaimoni.STL/AutoPtr.hpp"
 #include "type_spec.hpp"
 
@@ -12,23 +13,29 @@
 class union_struct_decl;
 class C_union_struct_def;
 class enum_def;
+#/*cut-cpp*/
+#ifndef assert
+#include "Zaimoni.STL/Logging.h"
+#endif
 
 class type_system
 {
 public:
 	typedef size_t type_index;
+#/*cut-cpp*/
 	// { {type, representation, value}, {filename, location }}
 	// uchar_blob is a POD backing store for unsigned_var_int here
 	typedef zaimoni::POD_pair<const char*,zaimoni::POD_pair<zaimoni::POD_triple<type_index,unsigned char,uchar_blob>, zaimoni::POD_pair<const char*,zaimoni::POD_pair<size_t,size_t> > > > enumerator_info;
+#/*cut-cpp*/
 
 	const zaimoni::POD_pair<const char* const,size_t>* const core_types;
 	const type_index* const int_priority;
 	const size_t core_types_size;
 	const size_t int_priority_size;
 private:
+#/*cut-cpp*/
 	typedef zaimoni::POD_triple<const char*,size_t,zaimoni::POD_pair<zaimoni::union_quartet<function_type*,union_struct_decl*,C_union_struct_def*,enum_def*>, unsigned char> > dynamic_type_format;
 	zaimoni::autovalarray_ptr<dynamic_type_format> dynamic_types;
-#/*cut-cpp*/
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> > > typedef_registry;
 	zaimoni::weakautovalarray_ptr<const char*> inline_namespace_alias_targets;
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,const char*> > inline_namespace_alias_map;
@@ -66,7 +73,14 @@
 #/*cut-cpp*/
 	const char* name(type_index id) const
 		{
+#/*cut-cpp*/
 		assert(core_types_size+dynamic_types.size()>=id);
+#define ZCC_CPP_SCREEN 1
+#/*cut-cpp*/
+#ifndef ZCC_CPP_SCREEN
+		assert(core_types_size>=id);
+#endif
+#undef ZCC_CPP_SCREEN
 		return _name(id);
 		}
 #/*cut-cpp*/

Modified: trunk/type_system_pp.cpp
===================================================================
--- trunk/type_system_pp.cpp	2010-10-04 20:42:23 UTC (rev 490)
+++ trunk/type_system_pp.cpp	2010-10-07 09:18:12 UTC (rev 491)
@@ -2,25 +2,11 @@
 // (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #include "type_system_pp.hpp"
-#include "enum_type.hpp"
-#include "struct_type.hpp"
-#include "Zaimoni.STL/search.hpp"
-#include "Zaimoni.STL/Pure.C/auto_int.h"
-#include "AtomicString.h"
-#include "str_aux.h"
 
-// macros to help out dynamic registration
-#define DYNAMIC_FUNCTYPE 1
-#define DYNAMIC_STRUCTDECL 2
-#define DYNAMIC_C_STRUCTDEF 3
-#define DYNAMIC_ENUMDEF 4
-
 const char* type_system::_name(size_t id) const
 {
 	if (0==id) return "(?)";
 	if (core_types_size> --id) return core_types[id].first;
-	if (dynamic_types.size() > (id -= core_types_size))
-		return dynamic_types[id].first;
 	return "(?)";
 }
 

Modified: trunk/type_system_pp.hpp
===================================================================
--- trunk/type_system_pp.hpp	2010-10-04 20:42:23 UTC (rev 490)
+++ trunk/type_system_pp.hpp	2010-10-07 09:18:12 UTC (rev 491)
@@ -5,29 +5,20 @@
 #define TYPE_SYSTEM_HPP 1
 
 #include "Zaimoni.STL/POD.hpp"
-#include "Zaimoni.STL/AutoPtr.hpp"
-#include "type_spec.hpp"
+#ifndef assert
+#include "Zaimoni.STL/Logging.h"
+#endif
 
-class function_type;
-class union_struct_decl;
-class C_union_struct_def;
-class enum_def;
-
 class type_system
 {
 public:
 	typedef size_t type_index;
-	// { {type, representation, value}, {filename, location }}
-	// uchar_blob is a POD backing store for unsigned_var_int here
-	typedef zaimoni::POD_pair<const char*,zaimoni::POD_pair<zaimoni::POD_triple<type_index,unsigned char,uchar_blob>, zaimoni::POD_pair<const char*,zaimoni::POD_pair<size_t,size_t> > > > enumerator_info;
 
 	const zaimoni::POD_pair<const char* const,size_t>* const core_types;
 	const type_index* const int_priority;
 	const size_t core_types_size;
 	const size_t int_priority_size;
 private:
-	typedef zaimoni::POD_triple<const char*,size_t,zaimoni::POD_pair<zaimoni::union_quartet<function_type*,union_struct_decl*,C_union_struct_def*,enum_def*>, unsigned char> > dynamic_type_format;
-	zaimoni::autovalarray_ptr<dynamic_type_format> dynamic_types;
 	// uncopyable
 	type_system(const type_system& src);
 	void operator=(const type_system& src);
@@ -40,7 +31,10 @@
 
 	const char* name(type_index id) const
 		{
-		assert(core_types_size+dynamic_types.size()>=id);
+#ifndef ZCC_CPP_SCREEN
+		assert(core_types_size>=id);
+#endif
+#undef ZCC_CPP_SCREEN
 		return _name(id);
 		}
 private:



From zaimoni at mail.berlios.de  Fri Oct  8 21:10:36 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri,  8 Oct 2010 21:10:36 +0200
Subject: [Zcplusplus-commits] r492 - trunk/Zaimoni.STL
Message-ID: <20101008191036.0EB55480B02@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-08 21:10:35 +0200 (Fri, 08 Oct 2010)
New Revision: 492

Modified:
   trunk/Zaimoni.STL/POD.hpp
Log:
Planning on using a POD_quartet; clean up POD.hpp while setting this up.

Modified: trunk/Zaimoni.STL/POD.hpp
===================================================================
--- trunk/Zaimoni.STL/POD.hpp	2010-10-07 09:18:12 UTC (rev 491)
+++ trunk/Zaimoni.STL/POD.hpp	2010-10-08 19:10:35 UTC (rev 492)
@@ -6,7 +6,7 @@
 #define ZAIMONI_STL_POD_HPP 1
 
 #include "boost_core.hpp"
-#include <cstring>
+#include <string.h>
 
 // ==, != operators a bit too sophisticated for templating, even with infrastructure to detect padding or lack thereof
 
@@ -17,17 +17,17 @@
 template<typename T>
 inline typename boost::enable_if<boost::has_trivial_assign<T>, void>::type
 clear(T& x)
-{	std::memset(&x,0,sizeof(T));}
+{	memset(&x,0,sizeof(T));}
 
 template<typename T>
 typename boost::enable_if<boost::has_trivial_assign<T>, void>::type
 clear(T* x,size_t n)
-{	if (NULL!=x) std::memset(x,0,n*sizeof(T));}
+{	if (x) memset(x,0,n*sizeof(T));}
 
 template<size_t n, typename T>
 typename boost::enable_if<boost::has_trivial_assign<T>, void>::type
 clear(T* x)
-{	if (NULL!=x) std::memset(x,0,n*sizeof(T));}
+{	if (x) memset(x,0,n*sizeof(T));}
 
 // handle POD-struct pairs, etc. here as well
 
@@ -47,15 +47,15 @@
 	// POD-struct has no constructors or destructors
 };
 
-template<class T1, class T2, class T3, class T4>
+template<class T1, class T2, class U1, class U2>
 inline bool
-operator==(const POD_pair<T1, T2>& x, const POD_pair<T3, T4>& y)
+operator==(const POD_pair<T1, T2>& x, const POD_pair<U1, U2>& y)
 {	return x.first==y.first && x.second==y.second;	}
 
 // dictionary ordering
-template<class T1, class T2, class T3, class T4>
+template<class T1, class T2, class U1, class U2>
 inline bool
-operator<(const POD_pair<T1, T2>& x, const POD_pair<T3, T4>& y)
+operator<(const POD_pair<T1, T2>& x, const POD_pair<U1, U2>& y)
 {
 	if (x.first<y.first) return true;
 	if (y.first<x.first) return false;
@@ -80,15 +80,15 @@
 	// POD-struct has no constructors or destructors
 };
 
-template<class T1, class T2, class T3, class T4, class T5, class T6>
+template<class T1, class T2, class T3, class U1, class U2, class U3>
 inline bool
-operator==(const POD_triple<T1, T2, T3>& x, const POD_triple<T4, T5, T6>& y)
+operator==(const POD_triple<T1, T2, T3>& x, const POD_triple<U1, U2, U3>& y)
 {	return x.first==y.first && x.second==y.second && x.third==y.third;	}
 
 // dictionary ordering
-template<class T1, class T2, class T3, class T4, class T5, class T6>
+template<class T1, class T2, class T3, class U1, class U2, class U3>
 inline bool
-operator<(const POD_triple<T1, T2, T3>& x, const POD_triple<T4, T5, T6>& y)
+operator<(const POD_triple<T1, T2, T3>& x, const POD_triple<U1, U2, U3>& y)
 {
 	if (x.first<y.first) return true;
 	if (y.first<x.first) return false;
@@ -97,6 +97,47 @@
 	return x.third<y.third;
 }
 
+template<class T1, class T2, class T3, class T4>
+struct POD_quartet
+{
+	BOOST_STATIC_ASSERT(boost::is_pod<T1>::value);
+	BOOST_STATIC_ASSERT(boost::is_pod<T2>::value);
+	BOOST_STATIC_ASSERT(boost::is_pod<T3>::value);
+	BOOST_STATIC_ASSERT(boost::is_pod<T4>::value);
+
+	typedef T1 first_type;
+	typedef T2 second_type;
+	typedef T3 third_type;
+	typedef T4 fourth_type;
+
+	T1 first;
+	T2 second;
+	T3 third;
+	T4 fourth;
+
+	// POD-struct has no constructors or destructors
+};
+
+template<class T1, class T2, class T3, class T4, class U1, class U2, class U3, class U4>
+inline bool
+operator==(const POD_quartet<T1, T2, T3, T4>& x, const POD_quartet<U1, U2, U3, U4>& y)
+{	return x.first==y.first && x.second==y.second && x.third==y.third && x.fourth==y.fourth;	}
+
+// dictionary ordering
+template<class T1, class T2, class T3, class T4, class U1, class U2, class U3, class U4>
+inline bool
+operator<(const POD_quartet<T1, T2, T3, T4>& x, const POD_quartet<U1, U2, U3, U4>& y)
+{
+	if (x.first<y.first) return true;
+	if (y.first<x.first) return false;
+	if (x.second<y.second) return true;
+	if (y.second<x.second) return false;
+	if (x.third<y.third) return true;
+	if (y.third<x.third) return false;
+	return x.fourth<y.fourth;
+}
+
+
 template<class T1, class T2>
 union union_pair
 {



From zaimoni at mail.berlios.de  Tue Oct 12 22:28:47 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 12 Oct 2010 22:28:47 +0200
Subject: [Zcplusplus-commits] r493 - trunk
Message-ID: <20101012202847.2DC3E481142@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-12 22:28:46 +0200 (Tue, 12 Oct 2010)
New Revision: 493

Modified:
   trunk/type_system.hpp
   trunk/type_system_pp.hpp
Log:
adjust in a field for use counts

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2010-10-08 19:10:35 UTC (rev 492)
+++ trunk/type_system.hpp	2010-10-12 20:28:46 UTC (rev 493)
@@ -34,7 +34,7 @@
 	const size_t int_priority_size;
 private:
 #/*cut-cpp*/
-	typedef zaimoni::POD_triple<const char*,size_t,zaimoni::POD_pair<zaimoni::union_quartet<function_type*,union_struct_decl*,C_union_struct_def*,enum_def*>, unsigned char> > dynamic_type_format;
+	typedef zaimoni::POD_quartet<const char*,size_t,zaimoni::POD_pair<zaimoni::union_quartet<function_type*,union_struct_decl*,C_union_struct_def*,enum_def*>, unsigned char>, size_t> dynamic_type_format;
 	zaimoni::autovalarray_ptr<dynamic_type_format> dynamic_types;
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> > > typedef_registry;
 	zaimoni::weakautovalarray_ptr<const char*> inline_namespace_alias_targets;
@@ -46,8 +46,8 @@
 	void operator=(const type_system& src);
 public:
 	type_system(const zaimoni::POD_pair<const char* const,size_t>* _core_types,size_t _core_types_size,const type_index* _int_priority,size_t _int_priority_size)
-	:	core_types((assert(NULL!=_core_types),_core_types)),
-		int_priority((assert(NULL!=_int_priority),_int_priority)),
+	:	core_types((assert(_core_types),_core_types)),
+		int_priority((assert(_int_priority),_int_priority)),
 		core_types_size((assert(0<_core_types_size),_core_types_size)),
 		int_priority_size((assert(0<_int_priority_size),_int_priority_size)) {};
 
@@ -139,6 +139,7 @@
 	void upgrade_decl_to_def(type_index i,C_union_struct_def*& src);
 #/*cut-cpp*/
 private:
+	const char* _name(type_index id) const;
 #/*cut-cpp*/
 	type_index _get_id_union(const char* x) const;
 	type_index _get_id_union_CPP(const char* x) const;
@@ -148,9 +149,6 @@
 	type_index _get_id_struct_class_CPP(const char* x) const;
 	enum_def* _get_enum_def(type_index i) const;
 	
-#/*cut-cpp*/
-	const char* _name(type_index id) const;
-#/*cut-cpp*/
 	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> dealias_inline_namespace_index(const char* alias) const;
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* _get_typedef_CPP(const char* alias) const;
 	const enumerator_info* _get_enumerator_CPP(const char* alias) const;

Modified: trunk/type_system_pp.hpp
===================================================================
--- trunk/type_system_pp.hpp	2010-10-08 19:10:35 UTC (rev 492)
+++ trunk/type_system_pp.hpp	2010-10-12 20:28:46 UTC (rev 493)
@@ -24,8 +24,8 @@
 	void operator=(const type_system& src);
 public:
 	type_system(const zaimoni::POD_pair<const char* const,size_t>* _core_types,size_t _core_types_size,const type_index* _int_priority,size_t _int_priority_size)
-	:	core_types((assert(NULL!=_core_types),_core_types)),
-		int_priority((assert(NULL!=_int_priority),_int_priority)),
+	:	core_types((assert(_core_types),_core_types)),
+		int_priority((assert(_int_priority),_int_priority)),
 		core_types_size((assert(0<_core_types_size),_core_types_size)),
 		int_priority_size((assert(0<_int_priority_size),_int_priority_size)) {};
 



From zaimoni at mail.berlios.de  Wed Oct 13 00:24:23 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 13 Oct 2010 00:24:23 +0200
Subject: [Zcplusplus-commits] r494 - trunk
Message-ID: <20101012222423.3F3E4481142@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-13 00:24:23 +0200 (Wed, 13 Oct 2010)
New Revision: 494

Added:
   trunk/type_system.hpp.in
Modified:
   trunk/type_system.hpp
   trunk/type_system_pp.hpp
Log:
adjust build system for type_system.hpp, etc.

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2010-10-12 20:28:46 UTC (rev 493)
+++ trunk/type_system.hpp	2010-10-12 22:24:23 UTC (rev 494)
@@ -5,7 +5,6 @@
 #define TYPE_SYSTEM_HPP 1
 
 #include "Zaimoni.STL/POD.hpp"
-#/*cut-cpp*/
 #include "Zaimoni.STL/AutoPtr.hpp"
 #include "type_spec.hpp"
 
@@ -13,34 +12,26 @@
 class union_struct_decl;
 class C_union_struct_def;
 class enum_def;
-#/*cut-cpp*/
-#ifndef assert
-#include "Zaimoni.STL/Logging.h"
-#endif
 
 class type_system
 {
 public:
 	typedef size_t type_index;
-#/*cut-cpp*/
 	// { {type, representation, value}, {filename, location }}
 	// uchar_blob is a POD backing store for unsigned_var_int here
 	typedef zaimoni::POD_pair<const char*,zaimoni::POD_pair<zaimoni::POD_triple<type_index,unsigned char,uchar_blob>, zaimoni::POD_pair<const char*,zaimoni::POD_pair<size_t,size_t> > > > enumerator_info;
-#/*cut-cpp*/
 
 	const zaimoni::POD_pair<const char* const,size_t>* const core_types;
 	const type_index* const int_priority;
 	const size_t core_types_size;
 	const size_t int_priority_size;
 private:
-#/*cut-cpp*/
 	typedef zaimoni::POD_quartet<const char*,size_t,zaimoni::POD_pair<zaimoni::union_quartet<function_type*,union_struct_decl*,C_union_struct_def*,enum_def*>, unsigned char>, size_t> dynamic_type_format;
 	zaimoni::autovalarray_ptr<dynamic_type_format> dynamic_types;
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> > > typedef_registry;
 	zaimoni::weakautovalarray_ptr<const char*> inline_namespace_alias_targets;
 	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,const char*> > inline_namespace_alias_map;
 	zaimoni::autovalarray_ptr<enumerator_info> enumerator_registry;
-#/*cut-cpp*/
 	// uncopyable
 	type_system(const type_system& src);
 	void operator=(const type_system& src);
@@ -51,7 +42,6 @@
 		core_types_size((assert(0<_core_types_size),_core_types_size)),
 		int_priority_size((assert(0<_int_priority_size),_int_priority_size)) {};
 
-#/*cut-cpp*/
 	type_index get_id_union(const char* x) const
 		{
 		assert(x && *x);
@@ -70,20 +60,11 @@
 		return _get_id_enum(x);
 		}
 	type_index get_id_enum_CPP(const char* alias,const char* active_namespace) const;
-#/*cut-cpp*/
 	const char* name(type_index id) const
 		{
-#/*cut-cpp*/
 		assert(core_types_size+dynamic_types.size()>=id);
-#define ZCC_CPP_SCREEN 1
-#/*cut-cpp*/
-#ifndef ZCC_CPP_SCREEN
-		assert(core_types_size>=id);
-#endif
-#undef ZCC_CPP_SCREEN
 		return _name(id);
 		}
-#/*cut-cpp*/
 
 	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
 	// defer five other variants for now (YAGNI)
@@ -137,10 +118,8 @@
 	const enum_def* get_enum_def(type_index i) const {return _get_enum_def(i);};
 	void set_enum_underlying_type(type_index i,size_t new_type);
 	void upgrade_decl_to_def(type_index i,C_union_struct_def*& src);
-#/*cut-cpp*/
 private:
 	const char* _name(type_index id) const;
-#/*cut-cpp*/
 	type_index _get_id_union(const char* x) const;
 	type_index _get_id_union_CPP(const char* x) const;
 	type_index _get_id_enum(const char* x) const;
@@ -159,6 +138,5 @@
 	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
 	static char* _namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
 	static void _namespace_concatenate(char* buf, const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
-#/*cut-cpp*/
 };
 #endif

Added: trunk/type_system.hpp.in
===================================================================
--- trunk/type_system.hpp.in	                        (rev 0)
+++ trunk/type_system.hpp.in	2010-10-12 22:24:23 UTC (rev 494)
@@ -0,0 +1,162 @@
+// type_system.hpp
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+
+#ifndef TYPE_SYSTEM_HPP
+#define TYPE_SYSTEM_HPP 1
+
+#include "Zaimoni.STL/POD.hpp"
+#/*cut-cpp*/
+#include "Zaimoni.STL/AutoPtr.hpp"
+#include "type_spec.hpp"
+
+class function_type;
+class union_struct_decl;
+class C_union_struct_def;
+class enum_def;
+#/*cut-cpp*/
+#/*cut-nocpp*/
+#include "Zaimoni.STL/Logging.h"
+#/*cut-nocpp*/
+
+class type_system
+{
+public:
+	typedef size_t type_index;
+#/*cut-cpp*/
+	// { {type, representation, value}, {filename, location }}
+	// uchar_blob is a POD backing store for unsigned_var_int here
+	typedef zaimoni::POD_pair<const char*,zaimoni::POD_pair<zaimoni::POD_triple<type_index,unsigned char,uchar_blob>, zaimoni::POD_pair<const char*,zaimoni::POD_pair<size_t,size_t> > > > enumerator_info;
+#/*cut-cpp*/
+
+	const zaimoni::POD_pair<const char* const,size_t>* const core_types;
+	const type_index* const int_priority;
+	const size_t core_types_size;
+	const size_t int_priority_size;
+private:
+#/*cut-cpp*/
+	typedef zaimoni::POD_quartet<const char*,size_t,zaimoni::POD_pair<zaimoni::union_quartet<function_type*,union_struct_decl*,C_union_struct_def*,enum_def*>, unsigned char>, size_t> dynamic_type_format;
+	zaimoni::autovalarray_ptr<dynamic_type_format> dynamic_types;
+	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> > > typedef_registry;
+	zaimoni::weakautovalarray_ptr<const char*> inline_namespace_alias_targets;
+	zaimoni::autovalarray_ptr<zaimoni::POD_pair<const char*,const char*> > inline_namespace_alias_map;
+	zaimoni::autovalarray_ptr<enumerator_info> enumerator_registry;
+#/*cut-cpp*/
+	// uncopyable
+	type_system(const type_system& src);
+	void operator=(const type_system& src);
+public:
+	type_system(const zaimoni::POD_pair<const char* const,size_t>* _core_types,size_t _core_types_size,const type_index* _int_priority,size_t _int_priority_size)
+	:	core_types((assert(_core_types),_core_types)),
+		int_priority((assert(_int_priority),_int_priority)),
+		core_types_size((assert(0<_core_types_size),_core_types_size)),
+		int_priority_size((assert(0<_int_priority_size),_int_priority_size)) {};
+
+#/*cut-cpp*/
+	type_index get_id_union(const char* x) const
+		{
+		assert(x && *x);
+		return _get_id_union(x);
+		}
+	type_index get_id_union_CPP(const char* alias,const char* active_namespace) const;
+	type_index get_id_struct_class(const char* x) const
+		{
+		assert(x && *x);
+		return _get_id_struct_class(x);
+		}
+	type_index get_id_struct_class_CPP(const char* alias,const char* active_namespace) const;
+	type_index get_id_enum(const char* x) const
+		{
+		assert(x && *x);
+		return _get_id_enum(x);
+		}
+	type_index get_id_enum_CPP(const char* alias,const char* active_namespace) const;
+#/*cut-cpp*/
+	const char* name(type_index id) const
+		{
+#/*cut-cpp*/
+		assert(core_types_size+dynamic_types.size()>=id);
+#/*cut-cpp*/
+#/*cut-nocpp*/
+		assert(core_types_size>=id);
+#/*cut-nocpp*/
+		return _name(id);
+		}
+#/*cut-cpp*/
+
+	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
+	// defer five other variants for now (YAGNI)
+	static char* namespace_concatenate(const char* const name, const char* const active_namespace,const char* namespace_separator)
+		{
+		assert(name && *name);
+		assert(active_namespace && *active_namespace);
+		assert(namespace_separator && *namespace_separator);
+		return _namespace_concatenate(name,strlen(name),active_namespace,strlen(active_namespace),namespace_separator,strlen(namespace_separator));
+		};
+	static void namespace_concatenate(char* buf, const char* const name, const char* const active_namespace,const char* namespace_separator)
+		{
+		assert(buf);
+		assert(name && *name);
+		assert(active_namespace && *active_namespace);
+		assert(namespace_separator && *namespace_separator);
+		_namespace_concatenate(buf,name,strlen(name),active_namespace,strlen(active_namespace),namespace_separator,strlen(namespace_separator));
+		};
+	static void namespace_concatenate(char* buf, const char* const name, const char* const active_namespace,size_t active_namespace_len,const char* namespace_separator)
+		{
+		assert(buf);
+		assert(name && *name);
+		assert(active_namespace && *active_namespace);
+		assert(0<active_namespace_len && active_namespace_len<=strlen(active_namespace));
+		assert(namespace_separator && *namespace_separator);
+		_namespace_concatenate(buf,name,strlen(name),active_namespace,active_namespace_len,namespace_separator,strlen(namespace_separator));
+		};
+
+	void set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec& src);	// invalidates src
+	void set_typedef_CPP(const char* const name, const char* const active_namespace, const char* filename, const size_t lineno, type_spec& src);	// invalidates src
+	const zaimoni::POD_triple<type_spec,const char*,size_t>* get_typedef(const char* const alias) const;
+	const zaimoni::POD_triple<type_spec,const char*,size_t>* get_typedef_CPP(const char* alias,const char* active_namespace) const;
+
+	void set_enumerator_def(const char* alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename,unsigned char representation,const uchar_blob& src,type_index type);
+	void set_enumerator_def_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename,unsigned char representation,const uchar_blob& src,type_index type);
+	const enumerator_info* get_enumerator(const char* alias) const;
+	const enumerator_info* get_enumerator_CPP(const char* alias,const char* active_namespace) const;
+
+	type_index register_functype(const char* const alias, function_type*& src);
+	type_index register_functype_CPP(const char* name, const char* active_namespace, function_type*& src);
+//	keyword actually should be type union_struct_decl::keywords, but that increases coupling unacceptably
+	type_index register_structdecl(const char* alias, int keyword);
+	type_index register_structdecl_CPP(const char* name, const char* active_namespace, int keyword);
+	type_index register_C_structdef(const char* alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename, int keyword);
+	type_index register_C_structdef_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename, int keyword);
+	type_index register_enum_def(const char* alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename);
+	type_index register_enum_def_CPP(const char* name, const char* active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* src_filename);
+	const function_type* get_functype(type_index i) const;
+	const union_struct_decl* get_structdecl(type_index i) const;
+	const C_union_struct_def* get_C_structdef(type_index i) const;
+	const enum_def* get_enum_def(type_index i) const {return _get_enum_def(i);};
+	void set_enum_underlying_type(type_index i,size_t new_type);
+	void upgrade_decl_to_def(type_index i,C_union_struct_def*& src);
+#/*cut-cpp*/
+private:
+	const char* _name(type_index id) const;
+#/*cut-cpp*/
+	type_index _get_id_union(const char* x) const;
+	type_index _get_id_union_CPP(const char* x) const;
+	type_index _get_id_enum(const char* x) const;
+	type_index _get_id_enum_CPP(const char* x) const;
+	type_index _get_id_struct_class(const char* x) const;
+	type_index _get_id_struct_class_CPP(const char* x) const;
+	enum_def* _get_enum_def(type_index i) const;
+	
+	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> dealias_inline_namespace_index(const char* alias) const;
+	const zaimoni::POD_triple<type_spec,const char*,size_t>* _get_typedef_CPP(const char* alias) const;
+	const enumerator_info* _get_enumerator_CPP(const char* alias) const;
+	bool is_inline_namespace_CPP(const char* active_namespace, size_t active_namespace_len) const;
+	const char* canonical_name_is_inline_namespace_alias_target(const char* name, size_t name_len, const char* active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len) const;
+	const char* construct_canonical_name_and_aliasing_CPP(const char* name, size_t name_len, const char* active_namespace, size_t active_namespace_len);
+
+	// can throw std::bad_alloc; returned string is owned by the caller (use free to deallocate)
+	static char* _namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
+	static void _namespace_concatenate(char* buf, const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len);
+#/*cut-cpp*/
+};
+#endif

Modified: trunk/type_system_pp.hpp
===================================================================
--- trunk/type_system_pp.hpp	2010-10-12 20:28:46 UTC (rev 493)
+++ trunk/type_system_pp.hpp	2010-10-12 22:24:23 UTC (rev 494)
@@ -5,9 +5,7 @@
 #define TYPE_SYSTEM_HPP 1
 
 #include "Zaimoni.STL/POD.hpp"
-#ifndef assert
 #include "Zaimoni.STL/Logging.h"
-#endif
 
 class type_system
 {
@@ -31,10 +29,7 @@
 
 	const char* name(type_index id) const
 		{
-#ifndef ZCC_CPP_SCREEN
 		assert(core_types_size>=id);
-#endif
-#undef ZCC_CPP_SCREEN
 		return _name(id);
 		}
 private:



From zaimoni at mail.berlios.de  Wed Oct 20 19:54:21 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 20 Oct 2010 19:54:21 +0200
Subject: [Zcplusplus-commits] r495 - trunk
Message-ID: <20101020175422.20C91480811@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-20 19:54:21 +0200 (Wed, 20 Oct 2010)
New Revision: 495

Modified:
   trunk/type_system.hpp
   trunk/type_system.hpp.in
Log:
preliminary use-counting support for types

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2010-10-12 22:24:23 UTC (rev 494)
+++ trunk/type_system.hpp	2010-10-20 17:54:21 UTC (rev 495)
@@ -60,6 +60,20 @@
 		return _get_id_enum(x);
 		}
 	type_index get_id_enum_CPP(const char* alias,const char* active_namespace) const;
+	void use_type(type_index id)
+		{
+		assert(core_types_size+dynamic_types.size()>=id);
+		if (core_types_size>=id) return;
+		if (SIZE_MAX==dynamic_types[id-=core_types_size].fourth) return;
+		++dynamic_types[id].fourth;
+		};
+	void unuse_type(type_index id)
+		{
+		assert(core_types_size+dynamic_types.size()>=id);
+		if (core_types_size>=id) return;
+		if (SIZE_MAX==dynamic_types[id-=core_types_size].fourth) return;
+		--dynamic_types[id].fourth;
+		};
 	const char* name(type_index id) const
 		{
 		assert(core_types_size+dynamic_types.size()>=id);

Modified: trunk/type_system.hpp.in
===================================================================
--- trunk/type_system.hpp.in	2010-10-12 22:24:23 UTC (rev 494)
+++ trunk/type_system.hpp.in	2010-10-20 17:54:21 UTC (rev 495)
@@ -70,6 +70,20 @@
 		return _get_id_enum(x);
 		}
 	type_index get_id_enum_CPP(const char* alias,const char* active_namespace) const;
+	void use_type(type_index id)
+		{
+		assert(core_types_size+dynamic_types.size()>=id);
+		if (core_types_size>=id) return;
+		if (SIZE_MAX==dynamic_types[id-=core_types_size].fourth) return;
+		++dynamic_types[id].fourth;
+		};
+	void unuse_type(type_index id)
+		{
+		assert(core_types_size+dynamic_types.size()>=id);
+		if (core_types_size>=id) return;
+		if (SIZE_MAX==dynamic_types[id-=core_types_size].fourth) return;
+		--dynamic_types[id].fourth;
+		};
 #/*cut-cpp*/
 	const char* name(type_index id) const
 		{



From zaimoni at mail.berlios.de  Wed Oct 20 20:40:08 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 20 Oct 2010 20:40:08 +0200
Subject: [Zcplusplus-commits] r496 - trunk
Message-ID: <20101020184009.45FD7480819@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-20 20:40:08 +0200 (Wed, 20 Oct 2010)
New Revision: 496

Modified:
   trunk/CSupport.cpp
   trunk/CSupport_pp.cpp
   trunk/POSIX.dep
Log:
build system tweak #1

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-20 17:54:21 UTC (rev 495)
+++ trunk/CSupport.cpp	2010-10-20 18:40:08 UTC (rev 496)
@@ -2,12 +2,9 @@
 // support for C/C++ parsing
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
-#/*cut-cpp*/
 #include "CSupport.hpp"
 #include "_CSupport3.hpp"
 #include "_CSupport4.hpp"
-#/*cut-cpp*/
-#include "CSupport_pp.hpp"
 #include "_CSupport1.hpp"
 #include "_CSupport2.hpp"
 
@@ -34,20 +31,12 @@
 #include "C_PPOctalInteger.hpp"
 #include "C_PPDecimalFloat.hpp"
 #include "C_PPHexFloat.hpp"
-#/*cut-cpp*/
 #include "enum_type.hpp"
 #include "struct_type.hpp"
 #include "kleene_star.hpp"
 #include "cond_act.hpp"
-#/*cut-cpp*/
 #include "CheckReturn.hpp"
 
-#ifdef ZCC_NOT_BUILDING_CPP
-#error internal macro ZCC_NOT_BUILDING_CPP already defined 
-#endif
-#/*cut-cpp*/
-#define ZCC_NOT_BUILDING_CPP 1
-#/*cut-cpp*/
 // handle function signature differences between z_cpp and other users
 #ifdef SIG_CONST_TYPES
 #error internal macro SIG_CONST_TYPES already defined 
@@ -55,13 +44,8 @@
 #ifdef ARG_TYPES
 #error internal macro ARG_TYPES already defined 
 #endif
-#ifdef ZCC_NOT_BUILDING_CPP
 #define SIG_CONST_TYPES ,const type_system& types 
 #define ARG_TYPES ,types 
-#else
-#define SIG_CONST_TYPES 
-#define ARG_TYPES 
-#endif
 
 using namespace zaimoni;
 using virtual_machine::umaxint;
@@ -541,7 +525,6 @@
 
 BOOST_STATIC_ASSERT(C_KEYWORD_NONSTRICT_LB<C_KEYWORD_STRICT_UB);
 BOOST_STATIC_ASSERT(CPP_KEYWORD_NONSTRICT_LB<C_KEYWORD_STRICT_UB);
-#/*cut-cpp*/
 
 static const char* C99_echo_reserved_keyword(const char* x,size_t x_len)
 {
@@ -586,7 +569,6 @@
 	while(0<i);
 	return NULL;
 }
-#/*cut-cpp*/
 
 namespace C_TYPE {
 
@@ -623,13 +605,11 @@
 	assert(C_TYPE::INT<=base_type_index && C_TYPE::ULLONG>=base_type_index);
 	return (virtual_machine::std_int_enum)((base_type_index-C_TYPE::INT)/2+virtual_machine::std_int_int);
 }
-#/*cut-cpp*/
 
 static inline size_t unsigned_type_from_machine_type(virtual_machine::std_int_enum x)
 {
 	return C_TYPE::SCHAR+2*(x-virtual_machine::std_int_char)+1;
 }
-#/*cut-cpp*/
 
 #if 0
 static bool is_innate_type(size_t base_type_index)
@@ -660,12 +640,8 @@
 
 static bool converts_to_integerlike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-#ifdef ZCC_NOT_BUILDING_CPP
 	if (C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index) return true;
 	return types.get_enum_def(base_type_index);
-#else
-	return C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index;
-#endif
 }
 
 static bool converts_to_integerlike(const type_spec& type_code SIG_CONST_TYPES)
@@ -677,32 +653,20 @@
 static bool converts_to_integer(const type_spec& type_code SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
 	if (0<type_code.pointer_power) return false;	// pointers do not have a standard conversion to integers
-#ifdef ZCC_NOT_BUILDING_CPP
 	if (C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index) return true;
 	return types.get_enum_def(type_code.base_type_index);
-#else
-	return C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index;
-#endif
 }
 
 static bool converts_to_reallike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-#ifdef ZCC_NOT_BUILDING_CPP
 	if (C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index) return true;
 	return types.get_enum_def(base_type_index);
-#else
-	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index;
-#endif
 }
 
 static bool converts_to_arithmeticlike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-#ifdef ZCC_NOT_BUILDING_CPP
 	if (C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index) return true;
 	return types.get_enum_def(base_type_index);
-#else
-	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
-#endif
 }
 
 static bool converts_to_arithmeticlike(const type_spec& type_code SIG_CONST_TYPES)
@@ -722,14 +686,12 @@
 // the integer promotions rely on low-level weirdness, so test that here
 static size_t arithmetic_reconcile(size_t base_type_index1, size_t base_type_index2 SIG_CONST_TYPES)
 {
-#/*cut-cpp*/
 	{
 	const enum_def* tmp = types.get_enum_def(base_type_index1);
 	if (tmp) base_type_index1 = tmp->represent_as;
 	tmp = types.get_enum_def(base_type_index2);
 	if (tmp) base_type_index2 = tmp->represent_as;	
 	}
-#/*cut-cpp*/
 	assert(is_innate_definite_type(base_type_index1));
 	assert(is_innate_definite_type(base_type_index2));
 	// identity, do not do anything
@@ -843,12 +805,10 @@
 
 static size_t default_promote_type(size_t i SIG_CONST_TYPES)
 {
-#/*cut-cpp*/
 	{
 	const enum_def* tmp = types.get_enum_def(i);
 	if (tmp) i = tmp->represent_as;
 	}
-#/*cut-cpp*/
 	switch(i)
 	{
 	case C_TYPE::BOOL: return C_TYPE::INT;
@@ -987,7 +947,6 @@
 
 BOOST_STATIC_ASSERT(STATIC_SIZE(C_atomic_types)==C_TYPE_MAX);
 BOOST_STATIC_ASSERT(STATIC_SIZE(CPP_atomic_types)==CPP_TYPE_MAX);
-#/*cut-cpp*/
 
 static const POD_pair<const char*,size_t> C99_decl_specifiers[] =
 	{	DICT_STRUCT("typedef"),
@@ -1127,7 +1086,6 @@
 	if (STATIC_SIZE(CPP0X_decl_specifier_list)>i) return i;
 	return SIZE_MAX;
 }	
-#/*cut-cpp*/
 
 const size_t C_int_priority[]
 	=	{
@@ -1243,7 +1201,6 @@
 	message_header(src.src_filename,src.logical_line.first);
 }
 
-#/*cut-cpp*/
 /* XXX this may belong with enum_type XXX */
 static void message_header(const enum_def& src)
 {
@@ -1257,7 +1214,6 @@
 	assert(src.filename() && *src.filename());
 	message_header(src.filename(),src.loc().first);
 }
-#/*cut-cpp*/
 
 // balanced character count
 static POD_pair<size_t,size_t>
@@ -3226,7 +3182,6 @@
 		zcc_errors.inc_error();
 		};
 }
-#/*cut-cpp*/
 
 /* deal with following type catalog
 atomic:
@@ -4005,7 +3960,6 @@
 		}
 	while(src.size<0>()> ++i);
 }
-#/*cut-cpp*/
 
 //! \todo generalize -- function pointer parameter target, functor target
 static size_t _count_identifiers(const parse_tree& src)
@@ -4031,7 +3985,6 @@
 #endif
 			&&	src.empty<1>() && src.empty<2>();
 }
-#/*cut-cpp*/
 
 static bool is_naked_brace_pair(const parse_tree& src)
 {
@@ -4059,7 +4012,6 @@
 		|| is_naked_brace_pair(src)
 		|| is_naked_bracket_pair(src));
 }
-#/*cut-cpp*/
 
 #ifndef NDEBUG
 static bool is_array_deref_strict(const parse_tree& src)
@@ -4131,7 +4083,6 @@
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 //			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
 }
-#/*cut-cpp*/
 
 static bool is_CPP0X_typeid_expression(const parse_tree& src)
 {
@@ -4162,7 +4113,6 @@
 //			&&	1==src.size<2>() && ((PARSE_UNARY_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
 }
 #endif
-#/*cut-cpp*/
 
 #define C99_MULT_SUBTYPE_DIV 1
 #define C99_MULT_SUBTYPE_MOD 2
@@ -4462,7 +4412,6 @@
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<2>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 }
-#/*cut-cpp*/
 
 static bool is_C99_anonymous_specifier(const parse_tree& src,const char* const spec_name)
 {
@@ -4738,7 +4687,6 @@
 	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
 	std::for_each(src.begin<0>(),src.end<0>(),conditional_action<bool (*)(const parse_tree&),void (*)(parse_tree&)>(is_nonempty_naked_pair,CPP_notice_class_struct_union_enum));
 }
-#/*cut-cpp*/
 
 bool convert_to(umaxint& dest,const C_PPIntCore& src)
 {
@@ -4775,7 +4723,6 @@
 		};
 	return true;
 }
-#/*cut-cpp*/
 
 static const enum_def* is_noticed_enumerator(const parse_tree& x,const type_system& types)
 {
@@ -4784,7 +4731,6 @@
 		tmp = types.get_enum_def(x.type_code.base_type_index);
 	return tmp;
 }
-#/*cut-cpp*/
 
 // forward-declare to handle recursion
 static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src SIG_CONST_TYPES);
@@ -4838,7 +4784,6 @@
 		dest.set_bitcount(VM_MAX_BIT_PLATFORM);
 		return true;
 		}	
-#/*cut-cpp*/
 
 	// creative interpretation: enumerators as integer-like literals
 	if (is_noticed_enumerator(src,types))
@@ -4848,7 +4793,6 @@
 		dest = tmp2->second.first.third;
 		return true;
 		}
-#/*cut-cpp*/
 		
 	if (!(C_TESTFLAG_INTEGER & src.index_tokens[0].flags)) return false;
 	C_PPIntCore tmp;
@@ -5169,7 +5113,6 @@
 		}
 }
 
-#/*cut-cpp*/
 // returns true if and only if no errors
 static bool _this_vaguely_where_it_could_be_cplusplus(const parse_tree& src)
 {
@@ -5204,7 +5147,6 @@
 	while(0<j);
 	return starting_errors==zcc_errors.err_count();
 }
-#/*cut-cpp*/
 
 // this handles: ( ), [ ], { }
 // the content of ( ), [ ], { } fills the zeroth argument array
@@ -5410,7 +5352,6 @@
 				src.flags |= (PARSE_PAREN_PRIMARY_PASSTHROUGH & src.data<0>()->flags);
 				return true;
 				}
-#/*cut-cpp*/
 			else if (PARSE_TYPE & src.data<0>()->flags)
 				{	// abuse: handle parenthesized type-specifiers here
 				value_copy(src.type_code,src.data<0>()->type_code);
@@ -5418,7 +5359,6 @@
 				src.flags |= (PARSE_TYPE & src.data<0>()->flags);
 				return false;	// not an expression 
 				}
-#/*cut-cpp*/
 			};
 		}
 	return false;
@@ -5671,7 +5611,6 @@
 		}
 }
 
-#/*cut-cpp*/
 
 // if #include <typeinfo> hasn't happened, context-free error stops this
 //! \throw std::bad_alloc
@@ -5722,7 +5661,6 @@
 		return true;
 	return false;
 }
-#/*cut-cpp*/
 /*postfixexpression:
 	primaryexpression
 	postfixexpression [ expression ]
@@ -5764,13 +5702,11 @@
 				{
 				}
 			}
-#/*cut-cpp*/
 #endif
 		}
 	else{	// if (NULL==src.data<0>()[i].index_tokens[1].token.first)
 		if (locate_CPP0X_typeid(src,i,types)) return;
 #if 0
-#/*cut-cpp*/
 		if (token_is_char<'.'>(src.data<0>()[i].index_tokens[0].token))
 			{
 			if (1<=i && 1<src.size<0>()-i)
@@ -5836,7 +5772,6 @@
 		is_true = !CCharLiteralIsFalse(src.index_tokens[0].token.first,src.index_tokens[0].token.second);
 		return true;
 		};
-#/*cut-cpp*/
 	if (is_noticed_enumerator(src,types))
 		{	// misintepret enumerators as literals (avoid dynamic memory thrashing)
 		const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.index_tokens[0].token.first);
@@ -5845,7 +5780,6 @@
 		is_true = !target_machine->is_zero(tmp2->second.first.third.data(),tmp2->second.first.third.size(),dest_type);
 		return true;
 		}
-#/*cut-cpp*/
 	if (!(C_TESTFLAG_PP_NUMERAL & src.index_tokens[0].flags)) return false;
 	C_REALITY_CHECK_PP_NUMERAL_FLAGS(src.index_tokens[0].flags);
 	if (C_TESTFLAG_FLOAT & src.index_tokens[0].flags) return false;	//! \todo handle floats as well (underflow to zero is target-sensitive)
@@ -5929,7 +5863,6 @@
 	_label_one_literal(dest,types);
 	assert(PARSE_EXPRESSION & dest.flags);
 }
-#/*cut-cpp*/
 
 // can't do much syntax-checking or immediate-evaluation here because of binary +/-
 // unary +/- syntax checking out out of place as it's needed by all of the unary operators
@@ -5962,7 +5895,6 @@
 	_label_one_literal(dest,types);
 	assert(PARSE_EXPRESSION & dest.flags);
 }
-#/*cut-cpp*/
 
 static void force_decimal_literal(parse_tree& dest,const char* src,const type_system& types)
 {
@@ -6046,7 +5978,6 @@
 		}
 	else VM_to_literal(x,src_int,src,types);
 }
-#/*cut-cpp*/
 
 //! \throw std::bad_alloc()
 static void enumerator_to_integer_representation(parse_tree& x,const type_system& types)
@@ -6074,16 +6005,13 @@
 	}
 	tmp3.MoveInto(x);
 }
-#/*cut-cpp*/
 
 static bool is_integerlike_literal(const parse_tree& x SIG_CONST_TYPES)
 {
 	return converts_to_integerlike(x.type_code ARG_TYPES) && (PARSE_PRIMARY_EXPRESSION & x.flags);
 }
 
-#/*cut-cpp*/
 //! \throw std::bad_alloc()
-#/*cut-cpp*/
 static bool eval_unary_plus(parse_tree& src, const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'+'>(src));
@@ -6098,7 +6026,6 @@
 			}
 		return false;
 		};
-#/*cut-cpp*/
 	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
 		enumerator_to_integer_representation(*src.c_array<2>(),types);
@@ -6108,7 +6035,6 @@
 			return true;
 			}
 		}
-#/*cut-cpp*/
  	// handle integer-like literals like a real integer literal
 	if (is_integerlike_literal(*src.data<2>() ARG_TYPES))
 		{
@@ -6133,7 +6059,6 @@
 		tmp.MoveInto(src.type_code);
 		return true;
 		};
-#/*cut-cpp*/
 	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
 		enumerator_to_integer_representation(*src.c_array<2>(),types);
@@ -6144,7 +6069,6 @@
 			}
 		value_copy(src.type_code,src.data<2>()->type_code);
 		}
-#/*cut-cpp*/
 	if (is_integerlike_literal(*src.data<2>() ARG_TYPES) && 1==(src.type_code.base_type_index-C_TYPE::INT)%2)
 		{	// unsigned...we're fine
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
@@ -6184,7 +6108,6 @@
 		simple_error(src,(C99_UNARY_SUBTYPE_PLUS==src.subtype) ? " applies unary + to a pointer (C99 6.5.3.3p1)" : " applies unary - to a pointer (C99 6.5.3.3p1)");
 		return;
 		}
-#/*cut-cpp*/
 	// can type if an (C++0X unscoped) enumerator
 	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
@@ -6193,7 +6116,6 @@
 		src.type_code.set_type(tmp2->second.first.first);
 		}
 	else
-#/*cut-cpp*/
 	// can type if result is a primitive arithmetic type
 	if (converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
 		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES));
@@ -6226,7 +6148,6 @@
 	assert((C99_UNARY_SUBTYPE_PLUS==src.subtype) ? is_C99_unary_operator_expression<'+'>(src) : is_C99_unary_operator_expression<'-'>(src));
 	
 	// can type if result is a primitive arithmetic type
-#/*cut-cpp*/
 	// can type if an (C++0X unscoped) enumerator
 	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
@@ -6235,7 +6156,6 @@
 		src.type_code.set_type(tmp2->second.first.first);
 		}
 	else
-#/*cut-cpp*/
 	if (converts_to_arithmeticlike(src.data<2>()->type_code ARG_TYPES))
 		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES));
 
@@ -6615,13 +6535,11 @@
 {
 	assert(is_bitwise_complement_expression(src));
 	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
-#/*cut-cpp*/
 	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
 		enumerator_to_integer_representation(*src.c_array<2>(),types);
 		value_copy(src.type_code,src.data<2>()->type_code);
 		}
-#/*cut-cpp*/
 	umaxint res_int;
 	if (intlike_literal_to_VM(res_int,*src.data<2>() ARG_TYPES)) 
 		{
@@ -6814,7 +6732,6 @@
 
 	return terse_locate_CPP_unary_plusminus(src,i,types);
 }
-#/*cut-cpp*/
 
 // handle C++0X sizeof... elsewhere (context-free syntax checks should be fixed first, possibly consider sizeof... a psuedo-identifier)
 //! \throw std::bad_alloc
@@ -7078,7 +6995,6 @@
 		}
 	return false;
 }
-#/*cut-cpp*/
 
 /* Scan for unary operators and cast expressions
 unary-expression:
@@ -7110,9 +7026,7 @@
 	if (locate_C99_logical_NOT(src,i,types)) return;
 	if (locate_C99_bitwise_complement(src,i,types)) return;
 	if (locate_C99_unary_plusminus(src,i,types)) return;
-#/*cut-cpp*/
 	if (locate_C99_sizeof(src,i,types)) return;
-#/*cut-cpp*/
 
 #if 0
 	if (terse_locate_unary_operator(src,i))
@@ -7190,9 +7104,7 @@
 	if (locate_CPP_logical_NOT(src,i,types)) return;
 	if (locate_CPP_bitwise_complement(src,i,types)) return;
 	if (locate_CPP_unary_plusminus(src,i,types)) return;
-#/*cut-cpp*/
 	if (locate_CPP_sizeof(src,i,types)) return;
-#/*cut-cpp*/
 
 #if 0
 	if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"++"))
@@ -7675,9 +7587,7 @@
 BOOST_STATIC_ASSERT(1==C99_MULT_SUBTYPE_MOD-C99_MULT_SUBTYPE_DIV);
 BOOST_STATIC_ASSERT(1==C99_MULT_SUBTYPE_MULT-C99_MULT_SUBTYPE_MOD);
 
-#/*cut-cpp*/
 //! \throw std::bad_alloc
-#/*cut-cpp*/
 static bool _mod_expression_typecheck(parse_tree& src SIG_CONST_TYPES)
 {
 	assert(C99_MULT_SUBTYPE_MOD==src.subtype && is_C99_mult_operator_expression<'%'>(src));
@@ -7694,7 +7604,6 @@
 		simple_error(src," has nonintegral RHS (C99 6.5.5p2, C++98 5.6p2)");
 		return false;
 		};
-#/*cut-cpp*/
 	if (is_noticed_enumerator(*src.data<1>(),types))
 		{
 		enumerator_to_integer_representation(*src.c_array<1>(),types);
@@ -7707,14 +7616,11 @@
 		rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
 		assert(rhs.second);
 		}
-#/*cut-cpp*/
 	src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 	return true;
 }
 
-#/*cut-cpp*/
 //! \throw std::bad_alloc
-#/*cut-cpp*/
 static bool _mult_div_expression_typecheck(parse_tree& src SIG_CONST_TYPES)
 {
 	assert(C99_MULT_SUBTYPE_DIV==src.subtype || C99_MULT_SUBTYPE_MULT==src.subtype);
@@ -7736,7 +7642,6 @@
 		return false;
 		};
 
-#/*cut-cpp*/
 	// arithmeticlike subsumes integerlike so this is fine
 	if (is_noticed_enumerator(*src.data<1>(),types))
 		{
@@ -7750,7 +7655,6 @@
 		rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
 		assert(rhs.second);
 		}
-#/*cut-cpp*/
 	src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 	return true;
 }
@@ -8305,7 +8209,6 @@
 				return;
 				}
 
-#/*cut-cpp*/
 			// arithmeticlike subsumes integerlike so this is fine
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				{
@@ -8319,7 +8222,6 @@
 				rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
 				assert(rhs.second);
 				}
-#/*cut-cpp*/
 			src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
 			eval_add_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
@@ -8368,7 +8270,6 @@
 				return;
 				}
 
-#/*cut-cpp*/
 			// arithmeticlike subsumes integerlike so this is fine
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				{
@@ -8382,7 +8283,6 @@
 				rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
 				assert(rhs.second);
 				}
-#/*cut-cpp*/
 			src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
 			eval_sub_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
@@ -8570,11 +8470,9 @@
 		{
 		if (!is_true)
 			{	// __ << 0 or __ >> 0: lift
-#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
-#/*cut-cpp*/
 			src.type_code.MoveInto(src.c_array<1>()->type_code);
 			src.eval_to_arg<1>(0);
 			return true;
@@ -8975,7 +8873,6 @@
 	return false;
 }
 
-#/*cut-cpp*/
 static bool typeid_equal_content(const parse_tree& lhs, const parse_tree& rhs,bool& is_equal)
 {
 	if (   is_CPP0X_typeid_expression(lhs) && is_CPP0X_typeid_expression(rhs)
@@ -8988,7 +8885,6 @@
 	return false;
 }
 
-#/*cut-cpp*/
 static bool eval_equality_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {	
 	BOOST_STATIC_ASSERT(1==C99_EQUALITY_SUBTYPE_NEQ-C99_EQUALITY_SUBTYPE_EQ);
@@ -9006,9 +8902,7 @@
 				//! \test default/Pass_if_zero.hpp, default/Pass_if_zero.h, 
 			bool is_equal = false;
 			if (   C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal)
-#/*cut-cpp*/
 				|| typeid_equal_content(*src.data<1>(),*src.data<2>(),is_equal)
-#/*cut-cpp*/
 				)
 				{
 				force_decimal_literal(src,is_equal_op==is_equal ? "1" : "0",types);
@@ -9271,22 +9165,18 @@
 		if 		(res_int==lhs_int)
 			// lhs & rhs = lhs; conserve type
 			{
-#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
-#/*cut-cpp*/
 			src.type_code.MoveInto(src.c_array<1>()->type_code);
 			src.eval_to_arg<1>(0);
 			}
 		else if (res_int==rhs_int)
 			// lhs & rhs = rhs; conserve type
 			{
-#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<2>(),types))
 				enumerator_to_integer_representation(*src.c_array<2>(),types);
-#/*cut-cpp*/
 			src.type_code.MoveInto(src.c_array<2>()->type_code);
 			src.eval_to_arg<2>(0);
 			}
@@ -9439,11 +9329,9 @@
 		{
 		if (!is_true)
 			{	// 0 ^ __
-#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<2>(),types))
 				enumerator_to_integer_representation(*src.c_array<2>(),types);
-#/*cut-cpp*/
 			src.eval_to_arg<2>(0);
 			//! \bug convert char literal to appropriate integer
 			return true;
@@ -9453,11 +9341,9 @@
 		{
 		if (!is_true)
 			{	// __ ^ 0
-#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
-#/*cut-cpp*/
 			src.eval_to_arg<1>(0);
 			//! \bug convert char literal to appropriate integer
 			return true;
@@ -9621,11 +9507,9 @@
 		{
 		if (!is_true)
 			{	// 0 | __
-#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<2>(),types))
 				enumerator_to_integer_representation(*src.c_array<2>(),types);
-#/*cut-cpp*/
 			src.eval_to_arg<2>(0);
 			//! \bug convert char literal to appropriate integer
 			return true;
@@ -9635,11 +9519,9 @@
 		{
 		if (!is_true)
 			{	// __ | 0
-#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
-#/*cut-cpp*/
 			src.eval_to_arg<1>(0);
 			//! \bug convert char literal to appropriate integer
 			return true;
@@ -9657,22 +9539,18 @@
 		if 		(res_int==lhs_int)
 			// lhs | rhs = lhs; conserve type
 			{
-#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
-#/*cut-cpp*/
 			src.type_code.MoveInto(src.c_array<1>()->type_code);
 			src.eval_to_arg<1>(0);
 			}
 		else if (res_int==rhs_int)
 			// lhs | rhs = rhs; conserve type
 			{
-#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
-#/*cut-cpp*/
 			src.type_code.MoveInto(src.c_array<2>()->type_code);
 			src.eval_to_arg<2>(0);
 			}
@@ -10652,10 +10530,8 @@
 	_label_literals(src,types);
 	std::for_each(src.begin<0>(),src.end<0>(),_label_CPP_literal);	// intercepts: true, false, this
 	if (!_match_pairs(src)) return false;
-#/*cut-cpp*/
 	// check that this is at least within a brace pair or a parentheses pair (it is actually required to be in a non-static member function, or constructor mem-initializer
 	if (!_this_vaguely_where_it_could_be_cplusplus(src)) return false;
-#/*cut-cpp*/	
 	try {
 		CPP_locate_expressions(src,SIZE_MAX,types);
 		}
@@ -10669,7 +10545,6 @@
 	return true;
 }
 
-#/*cut-cpp*/
 static const POD_pair<const char*,size_t> C99_nontype_decl_specifier_list[] =
 	{	DICT_STRUCT("typedef"),
 		DICT_STRUCT("const"),
@@ -11025,7 +10900,6 @@
 	// class/struct/union/enum specifiers can occur in all sorts of strange places
 	CPP_notice_class_struct_union_enum(src);
 }
-#/*cut-cpp*/
 
 //! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
 bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
@@ -11586,14 +11460,12 @@
 				}
 			}
 		}
-#/*cut-cpp*/
 	if (src.type_code.decays_to_nonnull_pointer())
 		{
 		force_decimal_literal(src,"1",types);
 		src.type_code.set_type(C_TYPE::INT);
 		return;
 		}
-#/*cut-cpp*/
 }
 
 //! \throw std::bad_alloc
@@ -11663,17 +11535,14 @@
 				}
 			}
 		}
-#/*cut-cpp*/
 	if (src.type_code.decays_to_nonnull_pointer())
 		{
 		force_decimal_literal(src,"1",types);
 		src.type_code.set_type(C_TYPE::INT);
 		return;
 		}
-#/*cut-cpp*/
 }
 
-#/*cut-cpp*/
 static void conserve_tokens(parse_tree& x)
 {
 	if (x.own_index_token<0>())
@@ -11699,7 +11568,6 @@
 			}
 		}
 }
-#/*cut-cpp*/
 
 //! \todo really should be somewhere in natural-language output
 void INFORM_separated_list(const char* const* x,size_t x_len, const char* const sep)
@@ -11716,7 +11584,6 @@
 			}
 		};
 }
-#/*cut-cpp*/
 
 //! \todo should this be a type_system member?
 //! \throw std::bad_alloc
@@ -14796,7 +14663,6 @@
 {
 	CPP_ParseNamespace(src,types,NULL);
 }
-#/*cut-cpp*/
 
 PP_auxfunc C99_aux
  = 	{
@@ -14810,14 +14676,12 @@
 	C99_PPHackTree,
 	ConcatenateCStringLiterals,
 	C99_bad_syntax_tokenized,
-#/*cut-cpp*/
 	C99_echo_reserved_keyword,
 	C99_echo_reserved_symbol,
 	C99_ContextFreeParse,
 	C99_ContextParse,
 	C99_locate_expressions,
 	C99_literal_converts_to_bool
-#/*cut-cpp*/
 	};
 
 PP_auxfunc CPlusPlus_aux
@@ -14832,14 +14696,12 @@
 	CPP_PPHackTree,
 	ConcatenateCStringLiterals,
 	CPP_bad_syntax_tokenized,
-#/*cut-cpp*/
 	CPP_echo_reserved_keyword,
 	CPP_echo_reserved_symbol,
 	CPP_ContextFreeParse,
 	CPP_ContextParse,
 	CPP_locate_expressions,
 	CPP_literal_converts_to_bool
-#/*cut-cpp*/
 	};
 
 #if 0
@@ -14964,7 +14826,6 @@
 	assert(C_TYPE::DOUBLE__COMPLEX==linear_find("double _Complex",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::LDOUBLE__COMPLEX==linear_find("long double _Complex",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::WCHAR_T==linear_find("wchar_t",CPP_atomic_types,CPP_TYPE_MAX)+1);
-#/*cut-cpp*/
 
 	assert(C99_CPP_TYPEDEF_IDX==linear_find("typedef",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
 	assert(C99_CPP_TYPEDEF_IDX==linear_find("typedef",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
@@ -15008,7 +14869,6 @@
 	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("_Thread_Local",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
 	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("thread_local",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
 	assert(CPP_MUTABLE_IDX==linear_find("mutable",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
-#/*cut-cpp*/
 
 	/* does bool converts_to_integerlike(size_t base_type_index) work */
 	BOOST_STATIC_ASSERT(!(C_TYPE::BOOL<=C_TYPE::NOT_VOID && C_TYPE::NOT_VOID<=C_TYPE::INTEGERLIKE));

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-10-20 17:54:21 UTC (rev 495)
+++ trunk/CSupport_pp.cpp	2010-10-20 18:40:08 UTC (rev 496)
@@ -21,7 +21,7 @@
 #include "errcount.hpp"
 #include "CPUInfo.hpp"
 #include "ParseTree.hpp"
-#include "type_system.hpp"
+#include "type_system_pp.hpp"
 #include "type_algebra.hpp"
 #include "weak_token.hpp"
 #include "C_PPDecimalInteger.hpp"
@@ -31,9 +31,6 @@
 #include "C_PPHexFloat.hpp"
 #include "CheckReturn.hpp"
 
-#ifdef ZCC_NOT_BUILDING_CPP
-#error internal macro ZCC_NOT_BUILDING_CPP already defined 
-#endif
 // handle function signature differences between z_cpp and other users
 #ifdef SIG_CONST_TYPES
 #error internal macro SIG_CONST_TYPES already defined 
@@ -41,13 +38,8 @@
 #ifdef ARG_TYPES
 #error internal macro ARG_TYPES already defined 
 #endif
-#ifdef ZCC_NOT_BUILDING_CPP
-#define SIG_CONST_TYPES ,const type_system& types 
-#define ARG_TYPES ,types 
-#else
 #define SIG_CONST_TYPES 
 #define ARG_TYPES 
-#endif
 
 using namespace zaimoni;
 using virtual_machine::umaxint;
@@ -593,12 +585,7 @@
 
 static bool converts_to_integerlike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-#ifdef ZCC_NOT_BUILDING_CPP
-	if (C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index) return true;
-	return types.get_enum_def(base_type_index);
-#else
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index;
-#endif
 }
 
 static bool converts_to_integerlike(const type_spec& type_code SIG_CONST_TYPES)
@@ -610,32 +597,17 @@
 static bool converts_to_integer(const type_spec& type_code SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
 	if (0<type_code.pointer_power) return false;	// pointers do not have a standard conversion to integers
-#ifdef ZCC_NOT_BUILDING_CPP
-	if (C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index) return true;
-	return types.get_enum_def(type_code.base_type_index);
-#else
 	return C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index;
-#endif
 }
 
 static bool converts_to_reallike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-#ifdef ZCC_NOT_BUILDING_CPP
-	if (C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index) return true;
-	return types.get_enum_def(base_type_index);
-#else
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index;
-#endif
 }
 
 static bool converts_to_arithmeticlike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
-#ifdef ZCC_NOT_BUILDING_CPP
-	if (C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index) return true;
-	return types.get_enum_def(base_type_index);
-#else
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
-#endif
 }
 
 static bool converts_to_arithmeticlike(const type_spec& type_code SIG_CONST_TYPES)
@@ -2943,6 +2915,7 @@
 /* strict type categories of parsing */
 #define PARSE_PRIMARY_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-19))
 #define PARSE_UNION_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-20))
+#define PARSE_CLASS_STRUCT_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-21))
 
 // check for collision with lowest three bits
 BOOST_STATIC_ASSERT(sizeof(lex_flags)*CHAR_BIT-parse_tree::PREDEFINED_STRICT_UB>=20);
@@ -2967,7 +2940,7 @@
 #define PARSE_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION | PARSE_STRICT_SHIFT_EXPRESSION | PARSE_STRICT_RELATIONAL_EXPRESSION | PARSE_STRICT_EQUALITY_EXPRESSION | PARSE_STRICT_BITAND_EXPRESSION | PARSE_STRICT_BITXOR_EXPRESSION | PARSE_STRICT_BITOR_EXPRESSION | PARSE_STRICT_LOGICAND_EXPRESSION | PARSE_STRICT_LOGICOR_EXPRESSION | PARSE_STRICT_CONDITIONAL_EXPRESSION | PARSE_STRICT_ASSIGNMENT_EXPRESSION | PARSE_STRICT_COMMA_EXPRESSION)
 
 /* nonstrict type categories */
-#define PARSE_TYPE (PARSE_PRIMARY_TYPE | PARSE_UNION_TYPE)
+#define PARSE_TYPE (PARSE_PRIMARY_TYPE | PARSE_UNION_TYPE | PARSE_CLASS_STRUCT_TYPE)
 
 /* already-parsed */
 #define PARSE_OBVIOUS (PARSE_EXPRESSION | PARSE_TYPE | parse_tree::INVALID)

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-10-20 17:54:21 UTC (rev 495)
+++ trunk/POSIX.dep	2010-10-20 18:40:08 UTC (rev 496)
@@ -19,7 +19,7 @@
 type_system_pp.o: type_system_pp.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/Logging.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 ParseTree.o: ParseTree.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
 type_spec.o: type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/POD.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h
-CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar
 _blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+CSupport_pp.o: CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system_pp.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uc
 har_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 C_PPNumCore.o: C_PPNumCore.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPDecimalInteger.o: C_PPDecimalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
 C_PPOctalInteger.o: C_PPOctalInteger.hpp unsigned_aux.hpp Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h
@@ -35,8 +35,8 @@
 CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operat
 or.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h type_system.hpp Zaimoni.STL/Perl_localize.hpp
-type_system.o: type_system.hpp type_system_pp.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/Logging.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
-CSupport.o: CSupport.hpp _CSupport3.hpp _CSupport4.hpp CSupport_pp.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp kleene_star.hpp cond_act.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zai
 moni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
+type_system.o: type_system.hpp type_system_pp.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
+CSupport.o: CSupport.hpp _CSupport3.hpp _CSupport4.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp kleene_star.hpp cond_act.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_l
 t.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp _CSupport3.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/lo
 gic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 ZParser.o: ZParser.hpp CSupport.hpp _CSupport3.hpp _CSupport4.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/search.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/Perl_localize.hpp Zaimoni.STL/POD.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h weak_token.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/LexParse/MetaToken.hpp



From zaimoni at mail.berlios.de  Wed Oct 20 20:44:52 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 20 Oct 2010 20:44:52 +0200
Subject: [Zcplusplus-commits] r498 - trunk
Message-ID: <20101020184453.2A90D480819@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-20 20:44:52 +0200 (Wed, 20 Oct 2010)
New Revision: 498

Modified:
   trunk/CSupport.cpp.in
Log:
build system tweak #3

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-20 18:43:33 UTC (rev 497)
+++ trunk/CSupport.cpp.in	2010-10-20 18:44:52 UTC (rev 498)
@@ -2,9 +2,14 @@
 // support for C/C++ parsing
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
+#/*cut-cpp*/
 #include "CSupport.hpp"
 #include "_CSupport3.hpp"
 #include "_CSupport4.hpp"
+#/*cut-cpp*/
+#/*cut-nocpp*/
+#include "CSupport_pp.hpp"
+#/*cut-nocpp*/
 #include "_CSupport1.hpp"
 #include "_CSupport2.hpp"
 
@@ -23,7 +28,12 @@
 #include "errcount.hpp"
 #include "CPUInfo.hpp"
 #include "ParseTree.hpp"
+#/*cut-cpp*/
 #include "type_system.hpp"
+#/*cut-cpp*/
+#/*cut-nocpp*/
+#include "type_system_pp.hpp"
+#/*cut-nocpp*/
 #include "type_algebra.hpp"
 #include "weak_token.hpp"
 #include "C_PPDecimalInteger.hpp"
@@ -31,10 +41,12 @@
 #include "C_PPOctalInteger.hpp"
 #include "C_PPDecimalFloat.hpp"
 #include "C_PPHexFloat.hpp"
+#/*cut-cpp*/
 #include "enum_type.hpp"
 #include "struct_type.hpp"
 #include "kleene_star.hpp"
 #include "cond_act.hpp"
+#/*cut-cpp*/
 #include "CheckReturn.hpp"
 
 // handle function signature differences between z_cpp and other users
@@ -44,8 +56,14 @@
 #ifdef ARG_TYPES
 #error internal macro ARG_TYPES already defined 
 #endif
+#/*cut-cpp*/
 #define SIG_CONST_TYPES ,const type_system& types 
 #define ARG_TYPES ,types 
+#/*cut-cpp*/
+#/*cut-nocpp*/
+#define SIG_CONST_TYPES 
+#define ARG_TYPES 
+#/*cut-nocpp*/
 
 using namespace zaimoni;
 using virtual_machine::umaxint;
@@ -525,6 +543,7 @@
 
 BOOST_STATIC_ASSERT(C_KEYWORD_NONSTRICT_LB<C_KEYWORD_STRICT_UB);
 BOOST_STATIC_ASSERT(CPP_KEYWORD_NONSTRICT_LB<C_KEYWORD_STRICT_UB);
+#/*cut-cpp*/
 
 static const char* C99_echo_reserved_keyword(const char* x,size_t x_len)
 {
@@ -569,6 +588,7 @@
 	while(0<i);
 	return NULL;
 }
+#/*cut-cpp*/
 
 namespace C_TYPE {
 
@@ -605,11 +625,13 @@
 	assert(C_TYPE::INT<=base_type_index && C_TYPE::ULLONG>=base_type_index);
 	return (virtual_machine::std_int_enum)((base_type_index-C_TYPE::INT)/2+virtual_machine::std_int_int);
 }
+#/*cut-cpp*/
 
 static inline size_t unsigned_type_from_machine_type(virtual_machine::std_int_enum x)
 {
 	return C_TYPE::SCHAR+2*(x-virtual_machine::std_int_char)+1;
 }
+#/*cut-cpp*/
 
 #if 0
 static bool is_innate_type(size_t base_type_index)
@@ -640,8 +662,13 @@
 
 static bool converts_to_integerlike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
+#/*cut-cpp*/
 	if (C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index) return true;
 	return types.get_enum_def(base_type_index);
+#/*cut-cpp*/
+#/*cut-nocpp*/
+	return C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index;
+#/*cut-nocpp*/
 }
 
 static bool converts_to_integerlike(const type_spec& type_code SIG_CONST_TYPES)
@@ -653,20 +680,35 @@
 static bool converts_to_integer(const type_spec& type_code SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
 	if (0<type_code.pointer_power) return false;	// pointers do not have a standard conversion to integers
+#/*cut-cpp*/
 	if (C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index) return true;
 	return types.get_enum_def(type_code.base_type_index);
+#/*cut-cpp*/
+#/*cut-nocpp*/
+	return C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index;
+#/*cut-nocpp*/
 }
 
 static bool converts_to_reallike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
+#/*cut-cpp*/
 	if (C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index) return true;
 	return types.get_enum_def(base_type_index);
+#/*cut-cpp*/
+#/*cut-nocpp*/
+	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index;
+#/*cut-nocpp*/
 }
 
 static bool converts_to_arithmeticlike(size_t base_type_index SIG_CONST_TYPES)
 {	//! \todo handle cast operator overloading
+#/*cut-cpp*/
 	if (C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index) return true;
 	return types.get_enum_def(base_type_index);
+#/*cut-cpp*/
+#/*cut-nocpp*/
+	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
+#/*cut-nocpp*/
 }
 
 static bool converts_to_arithmeticlike(const type_spec& type_code SIG_CONST_TYPES)
@@ -686,12 +728,14 @@
 // the integer promotions rely on low-level weirdness, so test that here
 static size_t arithmetic_reconcile(size_t base_type_index1, size_t base_type_index2 SIG_CONST_TYPES)
 {
+#/*cut-cpp*/
 	{
 	const enum_def* tmp = types.get_enum_def(base_type_index1);
 	if (tmp) base_type_index1 = tmp->represent_as;
 	tmp = types.get_enum_def(base_type_index2);
 	if (tmp) base_type_index2 = tmp->represent_as;	
 	}
+#/*cut-cpp*/
 	assert(is_innate_definite_type(base_type_index1));
 	assert(is_innate_definite_type(base_type_index2));
 	// identity, do not do anything
@@ -805,10 +849,12 @@
 
 static size_t default_promote_type(size_t i SIG_CONST_TYPES)
 {
+#/*cut-cpp*/
 	{
 	const enum_def* tmp = types.get_enum_def(i);
 	if (tmp) i = tmp->represent_as;
 	}
+#/*cut-cpp*/
 	switch(i)
 	{
 	case C_TYPE::BOOL: return C_TYPE::INT;
@@ -947,6 +993,7 @@
 
 BOOST_STATIC_ASSERT(STATIC_SIZE(C_atomic_types)==C_TYPE_MAX);
 BOOST_STATIC_ASSERT(STATIC_SIZE(CPP_atomic_types)==CPP_TYPE_MAX);
+#/*cut-cpp*/
 
 static const POD_pair<const char*,size_t> C99_decl_specifiers[] =
 	{	DICT_STRUCT("typedef"),
@@ -1086,6 +1133,7 @@
 	if (STATIC_SIZE(CPP0X_decl_specifier_list)>i) return i;
 	return SIZE_MAX;
 }	
+#/*cut-cpp*/
 
 const size_t C_int_priority[]
 	=	{
@@ -1201,6 +1249,7 @@
 	message_header(src.src_filename,src.logical_line.first);
 }
 
+#/*cut-cpp*/
 /* XXX this may belong with enum_type XXX */
 static void message_header(const enum_def& src)
 {
@@ -1214,6 +1263,7 @@
 	assert(src.filename() && *src.filename());
 	message_header(src.filename(),src.loc().first);
 }
+#/*cut-cpp*/
 
 // balanced character count
 static POD_pair<size_t,size_t>
@@ -3182,6 +3232,7 @@
 		zcc_errors.inc_error();
 		};
 }
+#/*cut-cpp*/
 
 /* deal with following type catalog
 atomic:
@@ -3960,6 +4011,7 @@
 		}
 	while(src.size<0>()> ++i);
 }
+#/*cut-cpp*/
 
 //! \todo generalize -- function pointer parameter target, functor target
 static size_t _count_identifiers(const parse_tree& src)
@@ -3985,6 +4037,7 @@
 #endif
 			&&	src.empty<1>() && src.empty<2>();
 }
+#/*cut-cpp*/
 
 static bool is_naked_brace_pair(const parse_tree& src)
 {
@@ -4012,6 +4065,7 @@
 		|| is_naked_brace_pair(src)
 		|| is_naked_bracket_pair(src));
 }
+#/*cut-cpp*/
 
 #ifndef NDEBUG
 static bool is_array_deref_strict(const parse_tree& src)
@@ -4083,6 +4137,7 @@
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 //			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
 }
+#/*cut-cpp*/
 
 static bool is_CPP0X_typeid_expression(const parse_tree& src)
 {
@@ -4113,6 +4168,7 @@
 //			&&	1==src.size<2>() && ((PARSE_UNARY_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
 }
 #endif
+#/*cut-cpp*/
 
 #define C99_MULT_SUBTYPE_DIV 1
 #define C99_MULT_SUBTYPE_MOD 2
@@ -4412,6 +4468,7 @@
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<2>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 }
+#/*cut-cpp*/
 
 static bool is_C99_anonymous_specifier(const parse_tree& src,const char* const spec_name)
 {
@@ -4687,6 +4744,7 @@
 	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
 	std::for_each(src.begin<0>(),src.end<0>(),conditional_action<bool (*)(const parse_tree&),void (*)(parse_tree&)>(is_nonempty_naked_pair,CPP_notice_class_struct_union_enum));
 }
+#/*cut-cpp*/
 
 bool convert_to(umaxint& dest,const C_PPIntCore& src)
 {
@@ -4723,6 +4781,7 @@
 		};
 	return true;
 }
+#/*cut-cpp*/
 
 static const enum_def* is_noticed_enumerator(const parse_tree& x,const type_system& types)
 {
@@ -4731,6 +4790,7 @@
 		tmp = types.get_enum_def(x.type_code.base_type_index);
 	return tmp;
 }
+#/*cut-cpp*/
 
 // forward-declare to handle recursion
 static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src SIG_CONST_TYPES);
@@ -4784,6 +4844,7 @@
 		dest.set_bitcount(VM_MAX_BIT_PLATFORM);
 		return true;
 		}	
+#/*cut-cpp*/
 
 	// creative interpretation: enumerators as integer-like literals
 	if (is_noticed_enumerator(src,types))
@@ -4793,6 +4854,7 @@
 		dest = tmp2->second.first.third;
 		return true;
 		}
+#/*cut-cpp*/
 		
 	if (!(C_TESTFLAG_INTEGER & src.index_tokens[0].flags)) return false;
 	C_PPIntCore tmp;
@@ -5113,6 +5175,7 @@
 		}
 }
 
+#/*cut-cpp*/
 // returns true if and only if no errors
 static bool _this_vaguely_where_it_could_be_cplusplus(const parse_tree& src)
 {
@@ -5147,6 +5210,7 @@
 	while(0<j);
 	return starting_errors==zcc_errors.err_count();
 }
+#/*cut-cpp*/
 
 // this handles: ( ), [ ], { }
 // the content of ( ), [ ], { } fills the zeroth argument array
@@ -5352,6 +5416,7 @@
 				src.flags |= (PARSE_PAREN_PRIMARY_PASSTHROUGH & src.data<0>()->flags);
 				return true;
 				}
+#/*cut-cpp*/
 			else if (PARSE_TYPE & src.data<0>()->flags)
 				{	// abuse: handle parenthesized type-specifiers here
 				value_copy(src.type_code,src.data<0>()->type_code);
@@ -5359,6 +5424,7 @@
 				src.flags |= (PARSE_TYPE & src.data<0>()->flags);
 				return false;	// not an expression 
 				}
+#/*cut-cpp*/
 			};
 		}
 	return false;
@@ -5611,6 +5677,7 @@
 		}
 }
 
+#/*cut-cpp*/
 
 // if #include <typeinfo> hasn't happened, context-free error stops this
 //! \throw std::bad_alloc
@@ -5661,6 +5728,7 @@
 		return true;
 	return false;
 }
+#/*cut-cpp*/
 /*postfixexpression:
 	primaryexpression
 	postfixexpression [ expression ]
@@ -5702,11 +5770,13 @@
 				{
 				}
 			}
+#/*cut-cpp*/
 #endif
 		}
 	else{	// if (NULL==src.data<0>()[i].index_tokens[1].token.first)
 		if (locate_CPP0X_typeid(src,i,types)) return;
 #if 0
+#/*cut-cpp*/
 		if (token_is_char<'.'>(src.data<0>()[i].index_tokens[0].token))
 			{
 			if (1<=i && 1<src.size<0>()-i)
@@ -5772,6 +5842,7 @@
 		is_true = !CCharLiteralIsFalse(src.index_tokens[0].token.first,src.index_tokens[0].token.second);
 		return true;
 		};
+#/*cut-cpp*/
 	if (is_noticed_enumerator(src,types))
 		{	// misintepret enumerators as literals (avoid dynamic memory thrashing)
 		const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.index_tokens[0].token.first);
@@ -5780,6 +5851,7 @@
 		is_true = !target_machine->is_zero(tmp2->second.first.third.data(),tmp2->second.first.third.size(),dest_type);
 		return true;
 		}
+#/*cut-cpp*/
 	if (!(C_TESTFLAG_PP_NUMERAL & src.index_tokens[0].flags)) return false;
 	C_REALITY_CHECK_PP_NUMERAL_FLAGS(src.index_tokens[0].flags);
 	if (C_TESTFLAG_FLOAT & src.index_tokens[0].flags) return false;	//! \todo handle floats as well (underflow to zero is target-sensitive)
@@ -5863,6 +5935,7 @@
 	_label_one_literal(dest,types);
 	assert(PARSE_EXPRESSION & dest.flags);
 }
+#/*cut-cpp*/
 
 // can't do much syntax-checking or immediate-evaluation here because of binary +/-
 // unary +/- syntax checking out out of place as it's needed by all of the unary operators
@@ -5895,6 +5968,7 @@
 	_label_one_literal(dest,types);
 	assert(PARSE_EXPRESSION & dest.flags);
 }
+#/*cut-cpp*/
 
 static void force_decimal_literal(parse_tree& dest,const char* src,const type_system& types)
 {
@@ -5978,6 +6052,7 @@
 		}
 	else VM_to_literal(x,src_int,src,types);
 }
+#/*cut-cpp*/
 
 //! \throw std::bad_alloc()
 static void enumerator_to_integer_representation(parse_tree& x,const type_system& types)
@@ -6005,13 +6080,16 @@
 	}
 	tmp3.MoveInto(x);
 }
+#/*cut-cpp*/
 
 static bool is_integerlike_literal(const parse_tree& x SIG_CONST_TYPES)
 {
 	return converts_to_integerlike(x.type_code ARG_TYPES) && (PARSE_PRIMARY_EXPRESSION & x.flags);
 }
 
+#/*cut-cpp*/
 //! \throw std::bad_alloc()
+#/*cut-cpp*/
 static bool eval_unary_plus(parse_tree& src, const type_system& types)
 {
 	assert(is_C99_unary_operator_expression<'+'>(src));
@@ -6026,6 +6104,7 @@
 			}
 		return false;
 		};
+#/*cut-cpp*/
 	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
 		enumerator_to_integer_representation(*src.c_array<2>(),types);
@@ -6035,6 +6114,7 @@
 			return true;
 			}
 		}
+#/*cut-cpp*/
  	// handle integer-like literals like a real integer literal
 	if (is_integerlike_literal(*src.data<2>() ARG_TYPES))
 		{
@@ -6059,6 +6139,7 @@
 		tmp.MoveInto(src.type_code);
 		return true;
 		};
+#/*cut-cpp*/
 	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
 		enumerator_to_integer_representation(*src.c_array<2>(),types);
@@ -6069,6 +6150,7 @@
 			}
 		value_copy(src.type_code,src.data<2>()->type_code);
 		}
+#/*cut-cpp*/
 	if (is_integerlike_literal(*src.data<2>() ARG_TYPES) && 1==(src.type_code.base_type_index-C_TYPE::INT)%2)
 		{	// unsigned...we're fine
 		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
@@ -6108,6 +6190,7 @@
 		simple_error(src,(C99_UNARY_SUBTYPE_PLUS==src.subtype) ? " applies unary + to a pointer (C99 6.5.3.3p1)" : " applies unary - to a pointer (C99 6.5.3.3p1)");
 		return;
 		}
+#/*cut-cpp*/
 	// can type if an (C++0X unscoped) enumerator
 	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
@@ -6116,6 +6199,7 @@
 		src.type_code.set_type(tmp2->second.first.first);
 		}
 	else
+#/*cut-cpp*/
 	// can type if result is a primitive arithmetic type
 	if (converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
 		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES));
@@ -6148,6 +6232,7 @@
 	assert((C99_UNARY_SUBTYPE_PLUS==src.subtype) ? is_C99_unary_operator_expression<'+'>(src) : is_C99_unary_operator_expression<'-'>(src));
 	
 	// can type if result is a primitive arithmetic type
+#/*cut-cpp*/
 	// can type if an (C++0X unscoped) enumerator
 	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
@@ -6156,6 +6241,7 @@
 		src.type_code.set_type(tmp2->second.first.first);
 		}
 	else
+#/*cut-cpp*/
 	if (converts_to_arithmeticlike(src.data<2>()->type_code ARG_TYPES))
 		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES));
 
@@ -6535,11 +6621,13 @@
 {
 	assert(is_bitwise_complement_expression(src));
 	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
+#/*cut-cpp*/
 	if (is_noticed_enumerator(*src.data<2>(),types))
 		{
 		enumerator_to_integer_representation(*src.c_array<2>(),types);
 		value_copy(src.type_code,src.data<2>()->type_code);
 		}
+#/*cut-cpp*/
 	umaxint res_int;
 	if (intlike_literal_to_VM(res_int,*src.data<2>() ARG_TYPES)) 
 		{
@@ -6732,6 +6820,7 @@
 
 	return terse_locate_CPP_unary_plusminus(src,i,types);
 }
+#/*cut-cpp*/
 
 // handle C++0X sizeof... elsewhere (context-free syntax checks should be fixed first, possibly consider sizeof... a psuedo-identifier)
 //! \throw std::bad_alloc
@@ -6995,6 +7084,7 @@
 		}
 	return false;
 }
+#/*cut-cpp*/
 
 /* Scan for unary operators and cast expressions
 unary-expression:
@@ -7026,7 +7116,9 @@
 	if (locate_C99_logical_NOT(src,i,types)) return;
 	if (locate_C99_bitwise_complement(src,i,types)) return;
 	if (locate_C99_unary_plusminus(src,i,types)) return;
+#/*cut-cpp*/
 	if (locate_C99_sizeof(src,i,types)) return;
+#/*cut-cpp*/
 
 #if 0
 	if (terse_locate_unary_operator(src,i))
@@ -7104,7 +7196,9 @@
 	if (locate_CPP_logical_NOT(src,i,types)) return;
 	if (locate_CPP_bitwise_complement(src,i,types)) return;
 	if (locate_CPP_unary_plusminus(src,i,types)) return;
+#/*cut-cpp*/
 	if (locate_CPP_sizeof(src,i,types)) return;
+#/*cut-cpp*/
 
 #if 0
 	if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"++"))
@@ -7587,7 +7681,9 @@
 BOOST_STATIC_ASSERT(1==C99_MULT_SUBTYPE_MOD-C99_MULT_SUBTYPE_DIV);
 BOOST_STATIC_ASSERT(1==C99_MULT_SUBTYPE_MULT-C99_MULT_SUBTYPE_MOD);
 
+#/*cut-cpp*/
 //! \throw std::bad_alloc
+#/*cut-cpp*/
 static bool _mod_expression_typecheck(parse_tree& src SIG_CONST_TYPES)
 {
 	assert(C99_MULT_SUBTYPE_MOD==src.subtype && is_C99_mult_operator_expression<'%'>(src));
@@ -7604,6 +7700,7 @@
 		simple_error(src," has nonintegral RHS (C99 6.5.5p2, C++98 5.6p2)");
 		return false;
 		};
+#/*cut-cpp*/
 	if (is_noticed_enumerator(*src.data<1>(),types))
 		{
 		enumerator_to_integer_representation(*src.c_array<1>(),types);
@@ -7616,11 +7713,14 @@
 		rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
 		assert(rhs.second);
 		}
+#/*cut-cpp*/
 	src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 	return true;
 }
 
+#/*cut-cpp*/
 //! \throw std::bad_alloc
+#/*cut-cpp*/
 static bool _mult_div_expression_typecheck(parse_tree& src SIG_CONST_TYPES)
 {
 	assert(C99_MULT_SUBTYPE_DIV==src.subtype || C99_MULT_SUBTYPE_MULT==src.subtype);
@@ -7642,6 +7742,7 @@
 		return false;
 		};
 
+#/*cut-cpp*/
 	// arithmeticlike subsumes integerlike so this is fine
 	if (is_noticed_enumerator(*src.data<1>(),types))
 		{
@@ -7655,6 +7756,7 @@
 		rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
 		assert(rhs.second);
 		}
+#/*cut-cpp*/
 	src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 	return true;
 }
@@ -8209,6 +8311,7 @@
 				return;
 				}
 
+#/*cut-cpp*/
 			// arithmeticlike subsumes integerlike so this is fine
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				{
@@ -8222,6 +8325,7 @@
 				rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
 				assert(rhs.second);
 				}
+#/*cut-cpp*/
 			src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
 			eval_add_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
@@ -8270,6 +8374,7 @@
 				return;
 				}
 
+#/*cut-cpp*/
 			// arithmeticlike subsumes integerlike so this is fine
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				{
@@ -8283,6 +8388,7 @@
 				rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
 				assert(rhs.second);
 				}
+#/*cut-cpp*/
 			src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
 			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
 			eval_sub_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
@@ -8470,9 +8576,11 @@
 		{
 		if (!is_true)
 			{	// __ << 0 or __ >> 0: lift
+#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
+#/*cut-cpp*/
 			src.type_code.MoveInto(src.c_array<1>()->type_code);
 			src.eval_to_arg<1>(0);
 			return true;
@@ -8873,6 +8981,7 @@
 	return false;
 }
 
+#/*cut-cpp*/
 static bool typeid_equal_content(const parse_tree& lhs, const parse_tree& rhs,bool& is_equal)
 {
 	if (   is_CPP0X_typeid_expression(lhs) && is_CPP0X_typeid_expression(rhs)
@@ -8885,6 +8994,7 @@
 	return false;
 }
 
+#/*cut-cpp*/
 static bool eval_equality_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
 {	
 	BOOST_STATIC_ASSERT(1==C99_EQUALITY_SUBTYPE_NEQ-C99_EQUALITY_SUBTYPE_EQ);
@@ -8902,7 +9012,9 @@
 				//! \test default/Pass_if_zero.hpp, default/Pass_if_zero.h, 
 			bool is_equal = false;
 			if (   C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal)
+#/*cut-cpp*/
 				|| typeid_equal_content(*src.data<1>(),*src.data<2>(),is_equal)
+#/*cut-cpp*/
 				)
 				{
 				force_decimal_literal(src,is_equal_op==is_equal ? "1" : "0",types);
@@ -9165,18 +9277,22 @@
 		if 		(res_int==lhs_int)
 			// lhs & rhs = lhs; conserve type
 			{
+#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
+#/*cut-cpp*/
 			src.type_code.MoveInto(src.c_array<1>()->type_code);
 			src.eval_to_arg<1>(0);
 			}
 		else if (res_int==rhs_int)
 			// lhs & rhs = rhs; conserve type
 			{
+#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<2>(),types))
 				enumerator_to_integer_representation(*src.c_array<2>(),types);
+#/*cut-cpp*/
 			src.type_code.MoveInto(src.c_array<2>()->type_code);
 			src.eval_to_arg<2>(0);
 			}
@@ -9329,9 +9445,11 @@
 		{
 		if (!is_true)
 			{	// 0 ^ __
+#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<2>(),types))
 				enumerator_to_integer_representation(*src.c_array<2>(),types);
+#/*cut-cpp*/
 			src.eval_to_arg<2>(0);
 			//! \bug convert char literal to appropriate integer
 			return true;
@@ -9341,9 +9459,11 @@
 		{
 		if (!is_true)
 			{	// __ ^ 0
+#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
+#/*cut-cpp*/
 			src.eval_to_arg<1>(0);
 			//! \bug convert char literal to appropriate integer
 			return true;
@@ -9507,9 +9627,11 @@
 		{
 		if (!is_true)
 			{	// 0 | __
+#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<2>(),types))
 				enumerator_to_integer_representation(*src.c_array<2>(),types);
+#/*cut-cpp*/
 			src.eval_to_arg<2>(0);
 			//! \bug convert char literal to appropriate integer
 			return true;
@@ -9519,9 +9641,11 @@
 		{
 		if (!is_true)
 			{	// __ | 0
+#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
+#/*cut-cpp*/
 			src.eval_to_arg<1>(0);
 			//! \bug convert char literal to appropriate integer
 			return true;
@@ -9539,18 +9663,22 @@
 		if 		(res_int==lhs_int)
 			// lhs | rhs = lhs; conserve type
 			{
+#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
+#/*cut-cpp*/
 			src.type_code.MoveInto(src.c_array<1>()->type_code);
 			src.eval_to_arg<1>(0);
 			}
 		else if (res_int==rhs_int)
 			// lhs | rhs = rhs; conserve type
 			{
+#/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
+#/*cut-cpp*/
 			src.type_code.MoveInto(src.c_array<2>()->type_code);
 			src.eval_to_arg<2>(0);
 			}
@@ -10530,8 +10658,10 @@
 	_label_literals(src,types);
 	std::for_each(src.begin<0>(),src.end<0>(),_label_CPP_literal);	// intercepts: true, false, this
 	if (!_match_pairs(src)) return false;
+#/*cut-cpp*/
 	// check that this is at least within a brace pair or a parentheses pair (it is actually required to be in a non-static member function, or constructor mem-initializer
 	if (!_this_vaguely_where_it_could_be_cplusplus(src)) return false;
+#/*cut-cpp*/	
 	try {
 		CPP_locate_expressions(src,SIZE_MAX,types);
 		}
@@ -10545,6 +10675,7 @@
 	return true;
 }
 
+#/*cut-cpp*/
 static const POD_pair<const char*,size_t> C99_nontype_decl_specifier_list[] =
 	{	DICT_STRUCT("typedef"),
 		DICT_STRUCT("const"),
@@ -10900,6 +11031,7 @@
 	// class/struct/union/enum specifiers can occur in all sorts of strange places
 	CPP_notice_class_struct_union_enum(src);
 }
+#/*cut-cpp*/
 
 //! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
 bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
@@ -11460,12 +11592,14 @@
 				}
 			}
 		}
+#/*cut-cpp*/
 	if (src.type_code.decays_to_nonnull_pointer())
 		{
 		force_decimal_literal(src,"1",types);
 		src.type_code.set_type(C_TYPE::INT);
 		return;
 		}
+#/*cut-cpp*/
 }
 
 //! \throw std::bad_alloc
@@ -11535,14 +11669,17 @@
 				}
 			}
 		}
+#/*cut-cpp*/
 	if (src.type_code.decays_to_nonnull_pointer())
 		{
 		force_decimal_literal(src,"1",types);
 		src.type_code.set_type(C_TYPE::INT);
 		return;
 		}
+#/*cut-cpp*/
 }
 
+#/*cut-cpp*/
 static void conserve_tokens(parse_tree& x)
 {
 	if (x.own_index_token<0>())
@@ -11568,6 +11705,7 @@
 			}
 		}
 }
+#/*cut-cpp*/
 
 //! \todo really should be somewhere in natural-language output
 void INFORM_separated_list(const char* const* x,size_t x_len, const char* const sep)
@@ -11584,6 +11722,7 @@
 			}
 		};
 }
+#/*cut-cpp*/
 
 //! \todo should this be a type_system member?
 //! \throw std::bad_alloc
@@ -14663,6 +14802,7 @@
 {
 	CPP_ParseNamespace(src,types,NULL);
 }
+#/*cut-cpp*/
 
 PP_auxfunc C99_aux
  = 	{
@@ -14676,12 +14816,14 @@
 	C99_PPHackTree,
 	ConcatenateCStringLiterals,
 	C99_bad_syntax_tokenized,
+#/*cut-cpp*/
 	C99_echo_reserved_keyword,
 	C99_echo_reserved_symbol,
 	C99_ContextFreeParse,
 	C99_ContextParse,
 	C99_locate_expressions,
 	C99_literal_converts_to_bool
+#/*cut-cpp*/
 	};
 
 PP_auxfunc CPlusPlus_aux
@@ -14696,12 +14838,14 @@
 	CPP_PPHackTree,
 	ConcatenateCStringLiterals,
 	CPP_bad_syntax_tokenized,
+#/*cut-cpp*/
 	CPP_echo_reserved_keyword,
 	CPP_echo_reserved_symbol,
 	CPP_ContextFreeParse,
 	CPP_ContextParse,
 	CPP_locate_expressions,
 	CPP_literal_converts_to_bool
+#/*cut-cpp*/
 	};
 
 #if 0
@@ -14826,6 +14970,7 @@
 	assert(C_TYPE::DOUBLE__COMPLEX==linear_find("double _Complex",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::LDOUBLE__COMPLEX==linear_find("long double _Complex",CPP_atomic_types,CPP_TYPE_MAX)+1);
 	assert(C_TYPE::WCHAR_T==linear_find("wchar_t",CPP_atomic_types,CPP_TYPE_MAX)+1);
+#/*cut-cpp*/
 
 	assert(C99_CPP_TYPEDEF_IDX==linear_find("typedef",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
 	assert(C99_CPP_TYPEDEF_IDX==linear_find("typedef",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
@@ -14869,6 +15014,7 @@
 	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("_Thread_Local",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
 	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("thread_local",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
 	assert(CPP_MUTABLE_IDX==linear_find("mutable",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+#/*cut-cpp*/
 
 	/* does bool converts_to_integerlike(size_t base_type_index) work */
 	BOOST_STATIC_ASSERT(!(C_TYPE::BOOL<=C_TYPE::NOT_VOID && C_TYPE::NOT_VOID<=C_TYPE::INTEGERLIKE));



From zaimoni at mail.berlios.de  Wed Oct 20 20:43:33 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 20 Oct 2010 20:43:33 +0200
Subject: [Zcplusplus-commits] r497 - trunk
Message-ID: <20101020184334.66776480819@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-20 20:43:33 +0200 (Wed, 20 Oct 2010)
New Revision: 497

Added:
   trunk/CSupport.cpp.in
Log:
build system tweak #2

Copied: trunk/CSupport.cpp.in (from rev 496, trunk/CSupport.cpp)
===================================================================
--- trunk/CSupport.cpp.in	                        (rev 0)
+++ trunk/CSupport.cpp.in	2010-10-20 18:43:33 UTC (rev 497)
@@ -0,0 +1,14896 @@
+// CSupport.cpp
+// support for C/C++ parsing
+// (C)2009, 2010 Kenneth Boyd, license: MIT.txt
+
+#include "CSupport.hpp"
+#include "_CSupport3.hpp"
+#include "_CSupport4.hpp"
+#include "_CSupport1.hpp"
+#include "_CSupport2.hpp"
+
+#include "Zaimoni.STL/MetaRAM2.hpp"
+#include "Zaimoni.STL/lite_alg.hpp"
+#include "Zaimoni.STL/LexParse/LangConf.hpp"
+#include "Zaimoni.STL/search.hpp"
+#include "Zaimoni.STL/simple_lock.hpp"
+#include "AtomicString.h"
+#include "str_aux.h"
+#include "Trigraph.hpp"
+#include "Flat_UNI.hpp"
+#include "end_lc.hpp"
+#include "end_nl.hpp"
+#include "errors.hpp"
+#include "errcount.hpp"
+#include "CPUInfo.hpp"
+#include "ParseTree.hpp"
+#include "type_system.hpp"
+#include "type_algebra.hpp"
+#include "weak_token.hpp"
+#include "C_PPDecimalInteger.hpp"
+#include "C_PPHexInteger.hpp"
+#include "C_PPOctalInteger.hpp"
+#include "C_PPDecimalFloat.hpp"
+#include "C_PPHexFloat.hpp"
+#include "enum_type.hpp"
+#include "struct_type.hpp"
+#include "kleene_star.hpp"
+#include "cond_act.hpp"
+#include "CheckReturn.hpp"
+
+// handle function signature differences between z_cpp and other users
+#ifdef SIG_CONST_TYPES
+#error internal macro SIG_CONST_TYPES already defined 
+#endif
+#ifdef ARG_TYPES
+#error internal macro ARG_TYPES already defined 
+#endif
+#define SIG_CONST_TYPES ,const type_system& types 
+#define ARG_TYPES ,types 
+
+using namespace zaimoni;
+using virtual_machine::umaxint;
+
+const char* const list_hexadecimal_digits = C_HEXADECIMAL_DIGITS;
+
+LangConf* CLexer = NULL;
+LangConf* CPlusPlusLexer = NULL;
+static const virtual_machine::CPUInfo* target_machine = NULL;
+
+/* fundamental type */
+/* all atomic charcters are preprocessing punctuation */
+#define CPP_FLAG_CHAR_LITERAL Flag1_LC
+#define CPP_FLAG_STRING_LITERAL Flag2_LC
+#define CPP_FLAG_PP_OP_PUNC Flag3_LC
+#define CPP_FLAG_IDENTIFIER Flag4_LC
+#define CPP_FLAG_PP_NUMERAL Flag5_LC
+
+/* general traits */
+// wide character/string literals use this
+#define CPP_WIDE_LITERAL Flag13_LC
+// simplify macro preprocessing
+#define CPP_FLAG_PAST_MACROS Flag14_LC
+
+#define C_WHITESPACE_NO_NEWLINE " \t\r\v\f"
+#define C_WHITESPACE "\n \t\r\v\f"
+#define C_ATOMIC_CHAR "()[]{};~,?"
+
+// beginning of multilingual support
+#define ERR_STR "error: "
+#define WARN_STR "warning: "
+
+// would have been in ParseTree.hpp, except that we don't have AtomicString.h there
+template<size_t i> void register_token(parse_tree& x)
+{
+	BOOST_STATIC_ASSERT(STATIC_SIZE(x.index_tokens)>i);
+	if (!x.own_index_token<i>()) return;
+	const char* const tmp = register_substring(x.index_tokens[i].token.first,x.index_tokens[i].token.second);
+	assert(tmp!=x.index_tokens[i].token.first);
+	free(const_cast<char*>(x.index_tokens[i].token.first));
+	x.index_tokens[i].token.first = tmp;
+	x.control_index_token<i>(false);
+}
+
+/* need for compiler implementation */
+/* remember to review pragma definitions from GCC, MSVC++, etc. */
+/*
+Another way to prevent a header file from being included more than once is with the `#pragma once' directive. If `#pragma once' is seen when scanning a header file, that file will never be read again, no matter what. 
+
+`#pragma once' does not have the problems that `#import' does, but it is not recognized by all preprocessors, so you cannot rely on it in a portable program.
+
+#pragma GCC diagnostic kind option
+Modifies the disposition of a diagnostic. Note that not all diagnostics are modifiable; at the moment only warnings (normally controlled by `-W...') can be controlled, and not all of them. Use -fdiagnostics-show-option to determine which diagnostics are controllable and which option controls them. 
+
+kind is `error' to treat this diagnostic as an error, `warning' to treat it like a warning (even if -Werror is in effect), or `ignored' if the diagnostic is to be ignored. option is a double quoted string which matches the command line option. 
+          #pragma GCC diagnostic warning "-Wformat"
+          #pragma GCC diagnostic error "-Wformat"
+          #pragma GCC diagnostic ignored "-Wformat"
+     
+
+Note that these pragmas override any command line options. Also, while it is syntactically valid to put these pragmas anywhere in your sources, the only supported location for them is before any data or functions are defined. Doing otherwise may result in unpredictable results depending on how the optimizer manages your sources. If the same option is listed multiple times, the last one specified is the one that is in effect. This pragma is not intended to be a general purpose replacement for command line options, but for implementing strict control over project policies.
+
+Preprocessor
+#pragma GCC dependency
+#pragma GCC dependency allows you to check the relative dates of the current file and another file. If the other file is more recent than the current file, a warning is issued. This is useful if the current file is derived from the other file, and should be regenerated. The other file is searched for using the normal include search path. Optional trailing text can be used to give more information in the warning message. 
+          #pragma GCC dependency "parse.y"
+          #pragma GCC dependency "/usr/include/time.h" rerun fixincludes
+     
+
+#pragma GCC poison
+Sometimes, there is an identifier that you want to remove completely from your program, and make sure that it never creeps back in. To enforce this, you can poison the identifier with this pragma. #pragma GCC poison is followed by a list of identifiers to poison. If any of those identifiers appears anywhere in the source after the directive, it is a hard error. For example, 
+          #pragma GCC poison printf sprintf fprintf
+          sprintf(some_string, "hello");
+     
+will produce an error. 
+
+If a poisoned identifier appears as part of the expansion of a macro which was defined before the identifier was poisoned, it will not cause an error. This lets you poison an identifier without worrying about system headers defining macros that use it. 
+
+For example, 
+          #define strrchr rindex
+          #pragma GCC poison rindex
+          strrchr(some_string, 'h');
+     
+
+will not produce an error. 
+#pragma GCC system_header
+This pragma takes no arguments. It causes the rest of the code in the current file to be treated as if it came from a system header.
+
+C99
+#pragma STDC FP_CONTRACT on-off-switch
+#pragma STDC FENV_ACCESS on-off-switch
+#pragma STDC CX_LIMITED_RANGE on-off-switch
+
+2 The usual mathematical formulas for complex multiply, divide, and absolute value are
+problematic because of their treatment of infinities and because of undue overflow and
+underflow. The CX_LIMITED_RANGE pragma can be used to inform the
+implementation that (where the state is defined) the usual mathematical formulas are
+acceptable.165) The pragma can occur either outside external declarations or preceding all
+explicit declarations and statements inside a compound statement. When outside external
+declarations, the pragma takes effect from its occurrence until another
+CX_LIMITED_RANGE pragma is encountered, or until the end of the translation unit.
+When inside a compound statement, the pragma takes effect from its occurrence until
+another CX_LIMITED_RANGE pragma is encountered (including within a nested
+165) The purpose of the pragma is to allow the implementation to use the formulas:
+(x + iy) * (u + iv) = (xu . yv) + i(yu + xv)
+(x + iy) / (u + iv) = [(xu + yv) + i(yu . xv)]/(u2 + v2)
+| x + iy | = *. .... x2 + y2
+where the programmer can determine they are safe.
+
+The FENV_ACCESS pragma provides a means to inform the implementation when a
+program might access the floating-point environment to test floating-point status flags or
+run under non-default floating-point control modes.178) The pragma shall occur either
+outside external declarations or preceding all explicit declarations and statements inside a
+compound statement. When outside external declarations, the pragma takes effect from
+its occurrence until another FENV_ACCESS pragma is encountered, or until the end of
+the translation unit. When inside a compound statement, the pragma takes effect from its
+occurrence until another FENV_ACCESS pragma is encountered (including within a
+nested compound statement), or until the end of the compound statement; at the end of a
+compound statement the state for the pragma is restored to its condition just before the
+compound statement. If this pragma is used in any other context, the behavior is
+undefined. If part of a program tests floating-point status flags, sets floating-point control
+modes, or runs under non-default mode settings, but was translated with the state for the
+FENV_ACCESS pragma ??off??, the behavior is undefined. The default state (??on?? or
+??off??) for the pragma is implementation-defined. (When execution passes from a part of
+the program translated with FENV_ACCESS ??off?? to a part translated with
+FENV_ACCESS ??on??, the state of the floating-point status flags is unspecified and the
+floating-point control modes have their default settings.)
+178) The purpose of the FENV_ACCESS pragma is to allow certain optimizations that could subvert flag
+tests and mode changes (e.g., global common subexpression elimination, code motion, and constant
+folding). In general, if the state of FENV_ACCESS is ??off??, the translator can assume that default
+modes are in effect and the flags are not tested.
+
+The FP_CONTRACT pragma can be used to allow (if the state is ??on??) or disallow (if the
+state is ??off??) the implementation to contract expressions (6.5). Each pragma can occur
+either outside external declarations or preceding all explicit declarations and statements
+inside a compound statement. When outside external declarations, the pragma takes
+effect from its occurrence until another FP_CONTRACT pragma is encountered, or until
+the end of the translation unit. When inside a compound statement, the pragma takes
+effect from its occurrence until another FP_CONTRACT pragma is encountered
+(including within a nested compound statement), or until the end of the compound
+statement; at the end of a compound statement the state for the pragma is restored to its
+condition just before the compound statement. If this pragma is used in any other
+context, the behavior is undefined. The default state (??on?? or ??off??) for the pragma is
+implementation-defined.
+198) The term underflow here is intended to encompass both ??gradual underflow?? as in IEC 60559 and
+also ??flush-to-zero?? underflow.
+
+*/
+
+bool IsUnaccentedAlphabeticChar(unsigned char x)
+{	// FORMALLY CORRECT: Kenneth Boyd, 7/29/2001
+	if (   in_range<'A','Z'>(x)
+		|| in_range<'a','z'>(x))
+		return true;
+	return false;
+}
+
+bool IsAlphabeticChar(unsigned char x)
+{	// FORMALLY CORRECT: Kenneth Boyd, 7/27/2001
+	// META: uses ASCII/default ISO web encoding implicitly
+	// NOTE: lower-case eth (240) will pass as partial differential operator!
+	if (   IsUnaccentedAlphabeticChar(x)
+//		|| (unsigned char)('\x8c')==x				// OE ligature
+//		|| (unsigned char)('\x9c')==x				// oe ligature
+//		|| (unsigned char)('\x9f')==x				// Y umlaut
+		|| ((unsigned char)('\xc0')<=x && (unsigned char)('\xd6')>=x)	// various accented characters
+		|| ((unsigned char)('\xd8')<=x && (unsigned char)('\xf6')>=x)	// various accented characters
+		|| ((unsigned char)('\xf8')<=x /* && (unsigned char)('\xff')>=x */))	// various accented characters
+		return true;
+	return false;
+}
+
+bool C_IsLegalSourceChar(char x)
+{
+	if (   IsAlphabeticChar(x)
+		|| in_range<'0','9'>(x)
+		|| strchr(C_WHITESPACE,x)
+		|| strchr(C_ATOMIC_CHAR,x)
+		|| strchr("_#<>%:.*+?/^&|!=\\",x))
+		return true;
+	return false;
+}
+
+static bool C_IsPrintableChar(unsigned char x)
+{
+	return in_range<' ','~'>(x);	//! \todo fix; assumes ASCII
+}
+
+#if 0
+static bool C_ExtendedSource(unsigned char x)
+{
+	return in_range<'\xA0','\xFF'>(x);	//! \todo fix: assumes CHAR_BIT 8, UNICODE
+}
+#endif
+
+#if 0
+	identifier
+		nondigit
+		identifier nondigit
+		identifier digit
+		nondigit: one of
+			universal-character-name
+			_ a b c d e f g h i j k l m
+			  n o p q r s t u v w x y z
+			  A B C D E F G H I J K L M
+			  N O P Q R S T U V W X Y Z
+		digit: one of
+			0 1 2 3 4 5 6 7 8 9
+#endif
+
+size_t LengthOfCIdentifier(const char* const x)
+{	//! \todo should handle universal character names
+	assert(NULL!=x);
+	const char* x2 = x;
+	if (IsAlphabeticChar(*x2) || '_'==*x2)
+		while(IsCIdentifierChar(*++x2));
+	return x2-x;
+}
+
+#if 0
+	pp-number
+		digit
+		. digit
+		pp-number digit
+		pp-number nondigit
+		pp-number e sign
+		pp-number E sign
+		pp-number .
+#endif
+size_t LengthOfCPreprocessingNumber(const char* const x)
+{
+	assert(NULL!=x);
+	size_t i = 0;	// Length
+	if (IsNumericChar(*x)) i = 1;
+	else if ('.'==*x && IsNumericChar(x[1])) i = 2;
+	if (0<i)
+		{
+		do	if ('.'==x[i] || IsNumericChar(x[i]))
+				++i;
+			else if (IsAlphabeticChar(x[i]))
+				{
+				if (   ('+'==x[i+1] || '-'==x[i+1])
+					&& ('E'==x[i] || 'e'==x[i] || 'P'==x[i] || 'p'==x[i]))
+					i += 2;
+				else
+					i += 1;
+				}
+			else
+				return i;
+		while(1);
+		};
+	return 0;
+}
+
+size_t LengthOfCCharLiteral(const char* const x)
+{	// FORMALLY CORRECT: Kenneth Boyd, 10/17/2004
+	size_t Length = 0;
+	if ('\''==*x)
+		Length = 1;
+	else if ('L'==x[0] && '\''==x[1])
+		Length = 2;
+	if (0==Length) return 0;
+
+	const char* base = x+Length;
+	const char* find_end = strpbrk(base,"\\'\n");
+	while(NULL!=find_end)
+		{
+		Length = find_end-x+1;
+		if ('\''==find_end[0]) return Length;
+		if ('\n'==find_end[0]) return Length-1;
+		if ('\0'==find_end[1]) return Length;
+		base = find_end+2;
+		find_end = ('\0'==base[0]) ? NULL : strpbrk(base,"\\'\n");
+		};
+	return strlen(x);
+}
+
+size_t LengthOfCStringLiteral(const char* const x)
+{	// FORMALLY CORRECT: Kenneth Boyd, 10/17/2004
+	size_t Length = 0;
+	if ('"'==*x)
+		Length = 1;
+	else if ('L'==x[0] && '"'==x[1])
+		Length = 2;
+	if (0==Length) return 0;
+
+	const char* base = x+Length;
+	const char* find_end = strpbrk(base,"\\\"\n");
+	while(NULL!=find_end)
+		{
+		Length = find_end-x+1;
+		if ('"'==find_end[0]) return Length;
+		if ('\n'==find_end[0]) return Length-1;
+		if ('\0'==find_end[1]) return Length;
+		base = find_end+2;
+		find_end = ('\0'==base[0]) ? NULL : strpbrk(base,"\\\"\n");
+		};
+	return strlen(x);
+}
+
+#if 0
+          preprocessing-op-or-punc: one of
+          {    }       [       ]      #      ##    (       )
+          <:   :>      <%      %>     %:     %:%:  ;       :    ...
+          new  delete  ?       ::     .      .*
+          +    -       *       /      %      ^     &       |    ~
+          !    =       <       >      +=     -=    *=      /=   %=
+          ^=   &=      |=      <<     >>     >>=   <<=     ==   !=
+          <=   >=      &&      ||     ++     --    ,       ->*  ->
+          and  and_eq  bitand  bitor  compl  not   not_eq  or   or_eq 
+          xor  xor_eq
+#endif
+
+#define ATOMIC_PREPROC_PUNC "()[]{};~,?"
+
+static const POD_triple<const char*,size_t,unsigned int> valid_pure_preprocessing_op_punc[]
+	=	{	DICT2_STRUCT("{",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("}",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("[",0),
+			DICT2_STRUCT("]",0),
+			DICT2_STRUCT("(",0),
+			DICT2_STRUCT(")",0),
+			DICT2_STRUCT(";",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("~",0),
+			DICT2_STRUCT(",",C_DISALLOW_CONSTANT_EXPR),	// double-check this
+			DICT2_STRUCT("?",0),	// atomic
+
+			DICT2_STRUCT(".",C_DISALLOW_IF_ELIF_CONTROL),
+			DICT2_STRUCT("&",0),
+			DICT2_STRUCT("+",0),
+			DICT2_STRUCT("-",0),
+			DICT2_STRUCT("*",0),
+			DICT2_STRUCT("/",0),
+			DICT2_STRUCT("%",0),
+			DICT2_STRUCT("!",0),
+			DICT2_STRUCT(":",0),
+			DICT2_STRUCT("=",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("<",0),
+			DICT2_STRUCT(">",0),
+			DICT2_STRUCT("^",0),
+			DICT2_STRUCT("|",0),
+			DICT2_STRUCT("#",C_DISALLOW_POSTPROCESSED_SOURCE),
+			DICT2_STRUCT("##",C_DISALLOW_POSTPROCESSED_SOURCE),
+			DICT2_STRUCT("->",C_DISALLOW_IF_ELIF_CONTROL),
+			DICT2_STRUCT("++",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("--",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("<:",0),
+			DICT2_STRUCT(":>",0),
+			DICT2_STRUCT("<%",C_DISALLOW_CONSTANT_EXPR),	// }
+			DICT2_STRUCT("%>",C_DISALLOW_CONSTANT_EXPR),	// {
+			DICT2_STRUCT("%:",C_DISALLOW_POSTPROCESSED_SOURCE),	// #
+			DICT2_STRUCT("+=",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("-=",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("*=",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("/=",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("%=",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("&=",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("|=",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("^=",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("<<",0),
+			DICT2_STRUCT(">>",0),
+			DICT2_STRUCT("==",0),
+			DICT2_STRUCT("!=",0),
+			DICT2_STRUCT("<=",0),
+			DICT2_STRUCT(">=",0),
+			DICT2_STRUCT("&&",0),
+			DICT2_STRUCT("||",0),
+			DICT2_STRUCT("...",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("<<=",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT(">>=",C_DISALLOW_CONSTANT_EXPR),
+			DICT2_STRUCT("%:%:",C_DISALLOW_POSTPROCESSED_SOURCE),	// ##	// C99
+
+			DICT2_STRUCT("::",C_DISALLOW_IF_ELIF_CONTROL),
+			DICT2_STRUCT(".*",C_DISALLOW_IF_ELIF_CONTROL),
+			DICT2_STRUCT("->*",C_DISALLOW_IF_ELIF_CONTROL)		// C++0x
+		};
+
+
+#define CPP_PREPROC_OP_STRICT_UB STATIC_SIZE(valid_pure_preprocessing_op_punc)
+#define C_PREPROC_OP_STRICT_UB (CPP_PREPROC_OP_STRICT_UB-3)
+#define NONATOMIC_PREPROC_OP_LB 10
+
+BOOST_STATIC_ASSERT(NONATOMIC_PREPROC_OP_LB<C_PREPROC_OP_STRICT_UB);
+
+static const POD_pair<const char*,size_t> valid_keyword[]
+	=	{	DICT_STRUCT("__asm"),		// reserved to the implementation, so OK to make a keyword for C only
+			DICT_STRUCT("_Static_Assert"),	// C1X keywords not in C++0X
+			DICT_STRUCT("_Thread_Local"),
+			DICT_STRUCT("restrict"),	// C99 keywords not in C++98
+			DICT_STRUCT("_Bool"),
+			DICT_STRUCT("_Complex"),
+			DICT_STRUCT("_Imaginary"),
+			DICT_STRUCT("auto"),		// joint keywords in C99 and C++98
+			DICT_STRUCT("break"),
+			DICT_STRUCT("case"),
+			DICT_STRUCT("char"),
+			DICT_STRUCT("const"),
+			DICT_STRUCT("continue"),
+			DICT_STRUCT("default"),
+			DICT_STRUCT("do"),
+			DICT_STRUCT("double"),
+			DICT_STRUCT("else"),
+			DICT_STRUCT("enum"),
+			DICT_STRUCT("extern"),
+			DICT_STRUCT("float"),
+			DICT_STRUCT("for"),
+			DICT_STRUCT("goto"),
+			DICT_STRUCT("if"),
+			DICT_STRUCT("inline"),
+			DICT_STRUCT("int"),
+			DICT_STRUCT("long"),
+			DICT_STRUCT("register"),
+			DICT_STRUCT("return"),
+			DICT_STRUCT("short"),
+			DICT_STRUCT("signed"),
+			DICT_STRUCT("sizeof"),
+			DICT_STRUCT("static"),
+			DICT_STRUCT("struct"),
+			DICT_STRUCT("switch"),
+			DICT_STRUCT("typedef"),
+			DICT_STRUCT("union"),
+			DICT_STRUCT("unsigned"),
+			DICT_STRUCT("void"),
+			DICT_STRUCT("volatile"),
+			DICT_STRUCT("while"),		// C99 keywords
+			DICT_STRUCT("asm"),			// common non-conforming extension to C99, C++98 keyword
+			DICT_STRUCT("bool"),		// start C++98 keywords
+			DICT_STRUCT("catch"),
+			DICT_STRUCT("class"),
+			DICT_STRUCT("const_cast"),
+			DICT_STRUCT("delete"),
+			DICT_STRUCT("dynamic_cast"),
+			DICT_STRUCT("explicit"),
+			DICT_STRUCT("false"),
+			DICT_STRUCT("friend"),
+			DICT_STRUCT("mutable"),
+			DICT_STRUCT("namespace"),
+			DICT_STRUCT("new"),
+			DICT_STRUCT("operator"),
+			DICT_STRUCT("private"),
+			DICT_STRUCT("protected"),
+			DICT_STRUCT("public"),
+			DICT_STRUCT("reinterpret_cast"),
+			DICT_STRUCT("static_cast"),
+			DICT_STRUCT("template"),
+			DICT_STRUCT("this"),
+			DICT_STRUCT("throw"),
+			DICT_STRUCT("true"),
+			DICT_STRUCT("try"),
+			DICT_STRUCT("typeid"),
+			DICT_STRUCT("typename"),
+			DICT_STRUCT("using"),
+			DICT_STRUCT("virtual"),
+			DICT_STRUCT("wchar_t"),		// end C++98 keywords
+			DICT_STRUCT("and"),			// C++98 alternate-operators
+			DICT_STRUCT("and_eq"),
+			DICT_STRUCT("bitand"),
+			DICT_STRUCT("bitor"),
+			DICT_STRUCT("compl"),
+			DICT_STRUCT("not"),
+			DICT_STRUCT("not_eq"),
+			DICT_STRUCT("or"),
+			DICT_STRUCT("or_eq"),
+			DICT_STRUCT("xor"),
+			DICT_STRUCT("xor_eq"),		// end C++98 alternate-operators
+			DICT_STRUCT("constexpr"),	// C++0X keywords we pay attention to
+			DICT_STRUCT("noexcept"),	// C++0X n3090
+			DICT_STRUCT("static_assert"),
+			DICT_STRUCT("thread_local")
+		};
+
+// think about C++0x keywords later.
+#define C_KEYWORD_NONSTRICT_LB 0
+#define CPP_KEYWORD_NONSTRICT_LB 7
+#define C_KEYWORD_STRICT_UB 40
+#define CPP_KEYWORD_STRICT_UB STATIC_SIZE(valid_keyword)
+
+BOOST_STATIC_ASSERT(C_KEYWORD_NONSTRICT_LB<C_KEYWORD_STRICT_UB);
+BOOST_STATIC_ASSERT(CPP_KEYWORD_NONSTRICT_LB<C_KEYWORD_STRICT_UB);
+
+static const char* C99_echo_reserved_keyword(const char* x,size_t x_len)
+{
+	assert(NULL!=x);
+	assert(x_len<=strlen(x));
+	size_t i = C_KEYWORD_STRICT_UB-C_KEYWORD_NONSTRICT_LB;
+	do	if (x_len==valid_keyword[C_KEYWORD_NONSTRICT_LB + --i].second && !strncmp(valid_keyword[C_KEYWORD_NONSTRICT_LB + i].first,x,x_len))
+			return valid_keyword[C_KEYWORD_NONSTRICT_LB + i].first;
+	while(0<i);
+	return NULL;
+}
+
+static const char* CPP_echo_reserved_keyword(const char* x,size_t x_len)
+{
+	assert(NULL!=x);
+	assert(x_len<=strlen(x));
+	size_t i = CPP_KEYWORD_STRICT_UB-CPP_KEYWORD_NONSTRICT_LB;
+	do	if (x_len==valid_keyword[CPP_KEYWORD_NONSTRICT_LB + --i].second && !strncmp(valid_keyword[CPP_KEYWORD_NONSTRICT_LB + i].first,x,x_len))
+			return valid_keyword[CPP_KEYWORD_NONSTRICT_LB + i].first;
+	while(0<i);
+	return NULL;
+}
+
+static const char* C99_echo_reserved_symbol(const char* x,size_t x_len)
+{
+	assert(NULL!=x);
+	assert(x_len<=strlen(x));
+	size_t i = C_PREPROC_OP_STRICT_UB;
+	do	if (x_len==valid_pure_preprocessing_op_punc[--i].second && !strncmp(valid_pure_preprocessing_op_punc[i].first,x,x_len))
+			return valid_pure_preprocessing_op_punc[i].first;
+	while(0<i);
+	return NULL;
+}
+
+static const char* CPP_echo_reserved_symbol(const char* x,size_t x_len)
+{
+	assert(NULL!=x);
+	assert(x_len<=strlen(x));
+	size_t i = CPP_PREPROC_OP_STRICT_UB;
+	do	if (x_len==valid_pure_preprocessing_op_punc[--i].second && !strncmp(valid_pure_preprocessing_op_punc[i].first,x,x_len))
+			return valid_pure_preprocessing_op_punc[i].first;
+	while(0<i);
+	return NULL;
+}
+
+namespace C_TYPE {
+
+enum hard_type_indexes {
+	VOID = 1,
+	NOT_VOID,	// needs to be omnicompatible early on
+	BOOL,
+	CHAR,
+	SCHAR,
+	UCHAR,
+	SHRT,
+	USHRT,
+	INT,
+	UINT,
+	LONG,
+	ULONG,
+	LLONG,
+	ULLONG,
+	INTEGERLIKE,
+	FLOAT,
+	DOUBLE,
+	LDOUBLE,
+	FLOAT__COMPLEX,
+	DOUBLE__COMPLEX,
+	LDOUBLE__COMPLEX,
+	WCHAR_T,	// C++-specific
+	TYPEINFO	// C++-specific
+};
+
+}
+
+static inline virtual_machine::std_int_enum machine_type_from_type_index(size_t base_type_index)
+{
+	assert(C_TYPE::INT<=base_type_index && C_TYPE::ULLONG>=base_type_index);
+	return (virtual_machine::std_int_enum)((base_type_index-C_TYPE::INT)/2+virtual_machine::std_int_int);
+}
+
+static inline size_t unsigned_type_from_machine_type(virtual_machine::std_int_enum x)
+{
+	return C_TYPE::SCHAR+2*(x-virtual_machine::std_int_char)+1;
+}
+
+#if 0
+static bool is_innate_type(size_t base_type_index)
+{
+	return C_TYPE::VOID<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
+}
+
+static bool is_innate_nonvoid_type(size_t base_type_index)
+{
+	return C_TYPE::NOT_VOID<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
+}
+
+static bool is_innate_integerlike(size_t base_type_index)
+{	// intentionally does not handle enum types
+	return C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index;
+}
+
+static bool is_innate_floatcomplexlike(size_t base_type_index)
+{
+	return C_TYPE::FLOAT<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
+}
+#endif
+
+static bool is_innate_definite_type(size_t base_type_index)
+{
+	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
+}
+
+static bool converts_to_integerlike(size_t base_type_index SIG_CONST_TYPES)
+{	//! \todo handle cast operator overloading
+	if (C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index) return true;
+	return types.get_enum_def(base_type_index);
+}
+
+static bool converts_to_integerlike(const type_spec& type_code SIG_CONST_TYPES)
+{	//! \todo handle cast operator overloading
+	if (0<type_code.pointer_power) return false;	// pointers do not have a standard conversion to integers
+	return converts_to_integerlike(type_code.base_type_index ARG_TYPES);
+}
+
+static bool converts_to_integer(const type_spec& type_code SIG_CONST_TYPES)
+{	//! \todo handle cast operator overloading
+	if (0<type_code.pointer_power) return false;	// pointers do not have a standard conversion to integers
+	if (C_TYPE::BOOL<=type_code.base_type_index && C_TYPE::INTEGERLIKE>type_code.base_type_index) return true;
+	return types.get_enum_def(type_code.base_type_index);
+}
+
+static bool converts_to_reallike(size_t base_type_index SIG_CONST_TYPES)
+{	//! \todo handle cast operator overloading
+	if (C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE>=base_type_index) return true;
+	return types.get_enum_def(base_type_index);
+}
+
+static bool converts_to_arithmeticlike(size_t base_type_index SIG_CONST_TYPES)
+{	//! \todo handle cast operator overloading
+	if (C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index) return true;
+	return types.get_enum_def(base_type_index);
+}
+
+static bool converts_to_arithmeticlike(const type_spec& type_code SIG_CONST_TYPES)
+{	//! \todo handle cast operator overloading
+	if (0<type_code.pointer_power) return false;	// pointers do not have a standard conversion to integers/floats/complex
+	return converts_to_arithmeticlike(type_code.base_type_index ARG_TYPES);
+}
+
+static bool converts_to_bool(const type_spec& type_code SIG_CONST_TYPES)
+{
+	if (0<type_code.pointer_power) return true;	// pointers are comparable to NULL
+	if (converts_to_arithmeticlike(type_code.base_type_index ARG_TYPES)) return true;	// arithmetic types are comparable to zero, and include bool
+	// C++: run through type conversion weirdness
+	return false;
+}
+
+// the integer promotions rely on low-level weirdness, so test that here
+static size_t arithmetic_reconcile(size_t base_type_index1, size_t base_type_index2 SIG_CONST_TYPES)
+{
+	{
+	const enum_def* tmp = types.get_enum_def(base_type_index1);
+	if (tmp) base_type_index1 = tmp->represent_as;
+	tmp = types.get_enum_def(base_type_index2);
+	if (tmp) base_type_index2 = tmp->represent_as;	
+	}
+	assert(is_innate_definite_type(base_type_index1));
+	assert(is_innate_definite_type(base_type_index2));
+	// identity, do not do anything
+	if (base_type_index1==base_type_index2) return base_type_index1;
+
+	//! \todo --do-what-i-mean will try to value-preserve integers when promoting to a float type (use global target_machine)
+
+	// long double _Complex
+	if (C_TYPE::LDOUBLE__COMPLEX==base_type_index1) return C_TYPE::LDOUBLE__COMPLEX;
+	if (C_TYPE::LDOUBLE__COMPLEX==base_type_index2) return C_TYPE::LDOUBLE__COMPLEX;
+	if (C_TYPE::LDOUBLE==base_type_index1 && C_TYPE::FLOAT__COMPLEX<=base_type_index2) return C_TYPE::LDOUBLE__COMPLEX;
+	if (C_TYPE::LDOUBLE==base_type_index2 && C_TYPE::FLOAT__COMPLEX<=base_type_index1) return C_TYPE::LDOUBLE__COMPLEX;
+
+	// double _Complex
+	if (C_TYPE::DOUBLE__COMPLEX==base_type_index1) return C_TYPE::DOUBLE__COMPLEX;
+	if (C_TYPE::DOUBLE__COMPLEX==base_type_index2) return C_TYPE::DOUBLE__COMPLEX;
+	if (C_TYPE::DOUBLE==base_type_index1 && C_TYPE::FLOAT__COMPLEX<=base_type_index2) return C_TYPE::DOUBLE__COMPLEX;
+	if (C_TYPE::DOUBLE==base_type_index2 && C_TYPE::FLOAT__COMPLEX<=base_type_index1) return C_TYPE::DOUBLE__COMPLEX;
+
+	// float _Complex
+	if (C_TYPE::FLOAT__COMPLEX==base_type_index1) return C_TYPE::FLOAT__COMPLEX;
+	if (C_TYPE::FLOAT__COMPLEX==base_type_index2) return C_TYPE::FLOAT__COMPLEX;
+
+	// long double
+	if (C_TYPE::LDOUBLE==base_type_index1) return C_TYPE::LDOUBLE;
+	if (C_TYPE::LDOUBLE==base_type_index2) return C_TYPE::LDOUBLE;
+
+	// double
+	if (C_TYPE::DOUBLE==base_type_index1) return C_TYPE::DOUBLE;
+	if (C_TYPE::DOUBLE==base_type_index2) return C_TYPE::DOUBLE;
+
+	// float
+	if (C_TYPE::FLOAT==base_type_index1) return C_TYPE::FLOAT;
+	if (C_TYPE::FLOAT==base_type_index2) return C_TYPE::FLOAT;
+
+	// bool fits in any integer type
+	if (C_TYPE::BOOL==base_type_index1) return base_type_index2;
+	if (C_TYPE::BOOL==base_type_index2) return base_type_index1;
+
+	// any integer type fits in integerlike
+	if (C_TYPE::INTEGERLIKE==base_type_index1) return C_TYPE::INTEGERLIKE;
+	if (C_TYPE::INTEGERLIKE==base_type_index2) return C_TYPE::INTEGERLIKE;
+
+	// handle indeterminacy of char now
+	BOOST_STATIC_ASSERT(C_TYPE::SCHAR+1==C_TYPE::UCHAR);
+	if (C_TYPE::CHAR==base_type_index1)
+		{
+		base_type_index1 = C_TYPE::SCHAR + bool_options[boolopt::char_is_unsigned];
+		// identity, do not do anything
+		if (base_type_index1==base_type_index2) return base_type_index1;
+		}
+	if (C_TYPE::CHAR==base_type_index2)
+		{
+		base_type_index2 = C_TYPE::SCHAR + bool_options[boolopt::char_is_unsigned];
+		// identity, do not do anything
+		if (base_type_index1==base_type_index2) return base_type_index1;
+		}
+
+	// types of the same sign should have a difference divisible by 2
+	BOOST_STATIC_ASSERT(0==(C_TYPE::SHRT-C_TYPE::SCHAR)%2);
+	BOOST_STATIC_ASSERT(0==(C_TYPE::INT-C_TYPE::SHRT)%2);
+	BOOST_STATIC_ASSERT(0==(C_TYPE::LONG-C_TYPE::INT)%2);
+	BOOST_STATIC_ASSERT(0==(C_TYPE::LLONG-C_TYPE::LONG)%2);
+
+	BOOST_STATIC_ASSERT(0==(C_TYPE::USHRT-C_TYPE::UCHAR)%2);
+	BOOST_STATIC_ASSERT(0==(C_TYPE::UINT-C_TYPE::USHRT)%2);
+	BOOST_STATIC_ASSERT(0==(C_TYPE::ULONG-C_TYPE::UINT)%2);
+	BOOST_STATIC_ASSERT(0==(C_TYPE::ULLONG-C_TYPE::ULONG)%2);
+	if (0==(base_type_index2-base_type_index1)%2) return (base_type_index1<base_type_index1) ? base_type_index1 : base_type_index1;
+
+	// types of the same rank should calculate as having the same rank
+	BOOST_STATIC_ASSERT((C_TYPE::SCHAR-1)/2==(C_TYPE::UCHAR-1)/2);
+	BOOST_STATIC_ASSERT((C_TYPE::SHRT-1)/2==(C_TYPE::USHRT-1)/2);
+	BOOST_STATIC_ASSERT((C_TYPE::INT-1)/2==(C_TYPE::UINT-1)/2);
+	BOOST_STATIC_ASSERT((C_TYPE::LONG-1)/2==(C_TYPE::ULONG-1)/2);
+	BOOST_STATIC_ASSERT((C_TYPE::LLONG-1)/2==(C_TYPE::ULLONG-1)/2);
+
+	// signed types should be odd, unsigned types should be even
+	BOOST_STATIC_ASSERT(0!=C_TYPE::SCHAR%2);
+	BOOST_STATIC_ASSERT(0==C_TYPE::UCHAR%2);
+	BOOST_STATIC_ASSERT(0!=C_TYPE::SHRT%2);
+	BOOST_STATIC_ASSERT(0==C_TYPE::USHRT%2);
+	BOOST_STATIC_ASSERT(0!=C_TYPE::INT%2);
+	BOOST_STATIC_ASSERT(0==C_TYPE::UINT%2);
+	BOOST_STATIC_ASSERT(0!=C_TYPE::LONG%2);
+	BOOST_STATIC_ASSERT(0==C_TYPE::ULONG%2);
+	BOOST_STATIC_ASSERT(0!=C_TYPE::LLONG%2);
+	BOOST_STATIC_ASSERT(0==C_TYPE::ULLONG%2);
+
+	//! \todo --do-what-i-mean is a bit more careful about signed/unsigned of the same rank; it promotes an equal-rank mismatch to the next larger signed integer type
+	if (0==base_type_index1%2)
+		{	// first is unsigned
+		if ((base_type_index1-1)/2>=(base_type_index2-1)/2)
+			{
+			return base_type_index1;
+			}
+		else{
+			return base_type_index2;
+			}
+		}
+	else{	// second is unsigned
+		if ((base_type_index1-1)/2<=(base_type_index2-1)/2)
+			{
+			return base_type_index2;
+			}
+		else{
+			return base_type_index1;
+			}
+		}
+}
+
+static size_t default_promote_type(size_t i SIG_CONST_TYPES)
+{
+	{
+	const enum_def* tmp = types.get_enum_def(i);
+	if (tmp) i = tmp->represent_as;
+	}
+	switch(i)
+	{
+	case C_TYPE::BOOL: return C_TYPE::INT;
+	case C_TYPE::SCHAR: return C_TYPE::INT;
+	case C_TYPE::SHRT: return C_TYPE::INT;
+	case C_TYPE::UCHAR: return (1<target_machine->C_sizeof_int()) ? C_TYPE::INT : C_TYPE::UINT;
+	case C_TYPE::CHAR: return (1<target_machine->C_sizeof_int() || target_machine->char_is_signed_char()) ? C_TYPE::INT : C_TYPE::UINT;
+	case C_TYPE::USHRT: return (target_machine->C_sizeof_short()<target_machine->C_sizeof_int()) ? C_TYPE::INT : C_TYPE::UINT;
+	case C_TYPE::FLOAT: return C_TYPE::DOUBLE;
+	};
+	return i;
+}
+
+static POD_pair<size_t,bool> default_promotion_is_integerlike(const type_spec& type_code SIG_CONST_TYPES)
+{	// uses NRVO
+	POD_pair<size_t,bool> tmp = {0,false};
+	if (0==type_code.pointer_power)	// pointers do not have a standard conversion to integers
+		{
+		tmp.first = default_promote_type(type_code.base_type_index ARG_TYPES);
+		tmp.second = (C_TYPE::BOOL<=tmp.first && C_TYPE::INTEGERLIKE>=tmp.first);
+		}
+	return tmp;
+}
+
+static POD_pair<size_t,bool> default_promotion_is_arithmeticlike(const type_spec& type_code SIG_CONST_TYPES)
+{	// uses NRVO
+	POD_pair<size_t,bool> tmp = {0,false};
+	if (0==type_code.pointer_power)	// pointers do not have a standard conversion to integers
+		{
+		tmp.first = default_promote_type(type_code.base_type_index ARG_TYPES);
+		tmp.second = (C_TYPE::BOOL<=tmp.first && C_TYPE::LDOUBLE__COMPLEX>=tmp.first);
+		}
+	return tmp;
+}
+
+// auxilliary structure to aggregate useful information for type promotions
+// this will malfunction badly for anything other than an integer type
+class promote_aux : public virtual_machine::promotion_info
+{
+public:
+	promote_aux(size_t base_type_index SIG_CONST_TYPES)
+	{
+		const size_t promoted_type = default_promote_type(base_type_index ARG_TYPES);
+		machine_type = machine_type_from_type_index(promoted_type);
+		bitcount = target_machine->C_bit(machine_type);
+		is_signed = !((promoted_type-C_TYPE::INT)%2);
+	};
+};
+
+static const char* literal_suffix(size_t i)
+{
+	switch(i)
+	{
+	case C_TYPE::UINT: return "U";
+	case C_TYPE::LDOUBLE:
+	case C_TYPE::LONG: return "L";
+	case C_TYPE::ULONG: return "UL";
+	case C_TYPE::LLONG: return "LL";
+	case C_TYPE::ULLONG: return "ULL";
+	case C_TYPE::FLOAT: return "F";
+	}
+	return NULL;
+}
+
+static lex_flags literal_flags(size_t i)
+{
+	switch(i)
+	{
+	case C_TYPE::CHAR:		return C_TESTFLAG_CHAR_LITERAL;
+	case C_TYPE::INT:		return C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_INTEGER;
+	case C_TYPE::UINT:		return C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_INTEGER | C_TESTFLAG_U;
+	case C_TYPE::LONG:		return C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_INTEGER | C_TESTFLAG_L;
+	case C_TYPE::ULONG:		return C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_INTEGER | C_TESTFLAG_U | C_TESTFLAG_L;
+	case C_TYPE::LLONG:		return C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_INTEGER | C_TESTFLAG_LL;
+	case C_TYPE::ULLONG:	return C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_INTEGER | C_TESTFLAG_U | C_TESTFLAG_LL;
+	case C_TYPE::FLOAT:		return C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_FLOAT | C_TESTFLAG_F;
+	case C_TYPE::DOUBLE:	return C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_FLOAT;
+	case C_TYPE::LDOUBLE:	return C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_FLOAT | C_TESTFLAG_L;
+	}
+	return 0;
+}
+
+/* reference arrays for instantiating type_system class with */
+/* typenames starting with $ are internal, as $ is not a legal C-source character */
+const POD_pair<const char* const,size_t> C_atomic_types[]
+	=	{
+		DICT_STRUCT("void"),
+		DICT_STRUCT("$not-void"),
+		DICT_STRUCT("_Bool"),
+		DICT_STRUCT("char"),
+		DICT_STRUCT("signed char"),
+		DICT_STRUCT("unsigned char"),
+		DICT_STRUCT("short"),
+		DICT_STRUCT("unsigned short"),
+		DICT_STRUCT("int"),
+		DICT_STRUCT("unsigned"),
+		DICT_STRUCT("long"),
+		DICT_STRUCT("unsigned long"),
+		DICT_STRUCT("long long"),
+		DICT_STRUCT("unsigned long long"),
+		DICT_STRUCT("$integer-like"),
+		DICT_STRUCT("float"),
+		DICT_STRUCT("double"),
+		DICT_STRUCT("long double"),
+		DICT_STRUCT("float _Complex"),		/* start C++ extension support: C99 _Complex in C++ (we can do this as _Complex is reserved to the implementation) */
+		DICT_STRUCT("double _Complex"),
+		DICT_STRUCT("long double _Complex")
+		};
+
+const POD_pair<const char* const,size_t> CPP_atomic_types[]
+	=	{
+		DICT_STRUCT("void"),
+		DICT_STRUCT("$not-void"),
+		DICT_STRUCT("bool"),
+		DICT_STRUCT("char"),
+		DICT_STRUCT("signed char"),
+		DICT_STRUCT("unsigned char"),
+		DICT_STRUCT("short"),
+		DICT_STRUCT("unsigned short"),
+		DICT_STRUCT("int"),
+		DICT_STRUCT("unsigned"),
+		DICT_STRUCT("long"),
+		DICT_STRUCT("unsigned long"),
+		DICT_STRUCT("long long"),
+		DICT_STRUCT("unsigned long long"),
+		DICT_STRUCT("$integer-like"),
+		DICT_STRUCT("float"),
+		DICT_STRUCT("double"),
+		DICT_STRUCT("long double"),
+		DICT_STRUCT("float _Complex"),		/* start C++ extension support: C99 _Complex in C++ (we can do this as _Complex is reserved to the implementation) */
+		DICT_STRUCT("double _Complex"),
+		DICT_STRUCT("long double _Complex"),
+		DICT_STRUCT("wchar_t"),			// C++-specific
+		DICT_STRUCT("std::typeinfo")	// C++-specific
+		};
+
+BOOST_STATIC_ASSERT(STATIC_SIZE(C_atomic_types)==C_TYPE_MAX);
+BOOST_STATIC_ASSERT(STATIC_SIZE(CPP_atomic_types)==CPP_TYPE_MAX);
+
+static const POD_pair<const char*,size_t> C99_decl_specifiers[] =
+	{	DICT_STRUCT("typedef"),
+		DICT_STRUCT("const"),
+		DICT_STRUCT("volatile"),
+		DICT_STRUCT("restrict"),
+		DICT_STRUCT("register"),
+		DICT_STRUCT("static"),
+		DICT_STRUCT("extern"),
+		DICT_STRUCT("inline"),
+		DICT_STRUCT("auto")
+	};
+
+// we implement C++0X, not C++98.  auto as storage specifier is pretty much a waste of source code anyway.
+// may have to invoke weirdness to deal with C headers that use restrict (and link with C standard library functions!)
+static const POD_pair<const char*,size_t> CPP0X_decl_specifiers[] =
+	{	DICT_STRUCT("typedef"),
+		DICT_STRUCT("const"),
+		DICT_STRUCT("volatile"),
+		DICT_STRUCT("thread_local"),
+		DICT_STRUCT("register"),
+		DICT_STRUCT("static"),
+		DICT_STRUCT("extern"),
+		DICT_STRUCT("inline"),
+		DICT_STRUCT("constexpr"),
+		DICT_STRUCT("mutable"),
+		DICT_STRUCT("virtual"),
+		DICT_STRUCT("explicit"),
+		DICT_STRUCT("friend")
+	};
+
+#define C99_CPP0X_DECLSPEC_TYPEDEF (1ULL<<0)
+#define C99_CPP0X_DECLSPEC_CONST (1ULL<<1)
+#define C99_CPP0X_DECLSPEC_VOLATILE (1ULL<<2)
+#define C99_CPP0X_DECLSPEC_REGISTER (1ULL<<4)
+#define C99_CPP0X_DECLSPEC_STATIC (1ULL<<5)
+#define C99_CPP0X_DECLSPEC_EXTERN (1ULL<<6)
+#define C99_CPP0X_DECLSPEC_INLINE (1ULL<<7)
+#define C99_DECLSPEC_AUTO (1ULL<<8)
+#define CPP_DECLSPEC_MUTABLE (1ULL<<9)
+#define CPP_DECLSPEC_VIRTUAL (1ULL<<10)
+#define CPP_DECLSPEC_EXPLICIT (1ULL<<11)
+#define CPP_DECLSPEC_FRIEND (1ULL<<12)
+
+BOOST_STATIC_ASSERT(C99_CPP0X_DECLSPEC_CONST==type_spec::_const);
+BOOST_STATIC_ASSERT(C99_CPP0X_DECLSPEC_VOLATILE==type_spec::_volatile);
+
+// todo: rewrite of decl-specifiers that actually can handle the reordering requirements.  
+// decl-specifier-seq is mostly context-free, so first-pass should be in 
+// the context-free section, if not integrated preprocessor
+static const POD_pair<const char*,size_t> C99_decl_specifier_list[] =
+	{	DICT_STRUCT("typedef"),
+		DICT_STRUCT("const"),
+		DICT_STRUCT("volatile"),
+		DICT_STRUCT("restrict"),	// C99-specific
+		DICT_STRUCT("register"),
+		DICT_STRUCT("static"),
+		DICT_STRUCT("extern"),
+		DICT_STRUCT("inline"),
+		DICT_STRUCT("auto"),
+		DICT_STRUCT("void"),
+		DICT_STRUCT("char"),
+		DICT_STRUCT("short"),
+		DICT_STRUCT("int"),
+		DICT_STRUCT("long"),
+		DICT_STRUCT("float"),
+		DICT_STRUCT("double"),
+		DICT_STRUCT("signed"),
+		DICT_STRUCT("unsigned"),
+		DICT_STRUCT("_Complex"),
+		DICT_STRUCT("_Bool"),
+		DICT_STRUCT("_Thread_Local"),	// C1X, actually
+	};
+
+// we implement C++0X, not C++98.  auto as storage specifier is pretty much a waste of source code anyway.
+// may have to invoke weirdness to deal with C headers that use restrict (and link with C standard library functions!)
+// we don't handle char16_t and char32_t yet
+static const POD_pair<const char*,size_t> CPP0X_decl_specifier_list[] =
+	{	DICT_STRUCT("typedef"),
+		DICT_STRUCT("const"),
+		DICT_STRUCT("volatile"),
+		DICT_STRUCT("wchar_t"),	// C++-specific
+		DICT_STRUCT("register"),
+		DICT_STRUCT("static"),
+		DICT_STRUCT("extern"),
+		DICT_STRUCT("inline"),
+		DICT_STRUCT("auto"),	// storage-class in C, type-specifier in C++
+		DICT_STRUCT("void"),
+		DICT_STRUCT("char"),
+		DICT_STRUCT("short"),
+		DICT_STRUCT("int"),
+		DICT_STRUCT("long"),
+		DICT_STRUCT("float"),
+		DICT_STRUCT("double"),
+		DICT_STRUCT("signed"),
+		DICT_STRUCT("unsigned"),
+		DICT_STRUCT("_Complex"),	// extension
+		DICT_STRUCT("bool"),	// _Bool in C
+		DICT_STRUCT("thread_local"),	// C1X _Thread_Local
+		DICT_STRUCT("constexpr"),
+		DICT_STRUCT("mutable"),
+		DICT_STRUCT("virtual"),
+		DICT_STRUCT("explicit"),
+		DICT_STRUCT("friend")
+	};
+
+#define C99_CPP_TYPEDEF_IDX 0
+#define C99_CPP_CONST_IDX 1
+#define C99_CPP_VOLATILE_IDX 2
+#define C99_RESTRICT_IDX 3
+#define C99_CPP_REGISTER_IDX 4
+#define C99_CPP_STATIC_IDX 5
+#define C99_CPP_EXTERN_IDX 6
+#define C99_CPP_AUTO_IDX 8
+#define C99_CPP_CHAR_IDX 10
+#define C99_CPP_SHORT_IDX 11
+#define C99_CPP_INT_IDX 12
+#define C99_CPP_LONG_IDX 13
+#define C99_CPP_FLOAT_IDX 14
+#define C99_CPP_DOUBLE_IDX 15
+#define C99_CPP_SIGNED_IDX 16
+#define C99_CPP_UNSIGNED_IDX 17
+#define C99_CPP_COMPLEX_IDX 18
+#define C1X_CPP0X_THREAD_LOCAL_IDX 20
+#define CPP_MUTABLE_IDX 22
+
+size_t C99_invariant_decl_specifier(const char* const x)
+{
+	const errr i = linear_find(x,C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list));
+	if (STATIC_SIZE(C99_decl_specifier_list)>i) return i;
+	return SIZE_MAX;
+}
+
+size_t CPP0X_invariant_decl_specifier(const char* const x)
+{
+	const errr i = linear_find(x,CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list));
+	if (STATIC_SIZE(CPP0X_decl_specifier_list)>i) return i;
+	return SIZE_MAX;
+}	
+
+const size_t C_int_priority[]
+	=	{
+		C_TYPE::INT,
+		C_TYPE::UINT,
+		C_TYPE::LONG,
+		C_TYPE::ULONG,
+		C_TYPE::LLONG,
+		C_TYPE::ULLONG,
+		C_TYPE::INTEGERLIKE
+		};
+
+BOOST_STATIC_ASSERT(C_INT_PRIORITY_SIZE==STATIC_SIZE(C_int_priority));
+
+// this only has to work on full strings, not embedded substrings
+const char* const system_headers[]
+	=	{	"assert.h",		// C99 headers
+			"complex.h",
+			"ctype.h",
+			"errno.h",
+			"float.h",
+			"inttypes.h",
+			"iso646.h",
+			"limits.h",
+			"locale.h",
+			"math.h",
+			"setjmp.h",
+			"signal.h",
+			"stdarg.h",
+			"stdbool.h",
+			"stddef.h",
+			"stdint.h",
+			"stdio.h",
+			"stdlib.h",
+			"string.h",
+			"tgmath.h",
+			"time.h",
+			"wchar.h",
+			"wctype.h",	// end C99 headers
+			"cassert",	// C++98 C-functionality headers
+			"cctype",
+			"cerrno",
+			"cfloat",
+			"ciso646",
+			"climits",
+			"clocale",
+			"cmath",
+			"csetjmp",
+			"csignal",
+			"cstdarg",
+			"cstddef",
+			"cstdio",
+			"cstdlib",
+			"cstring",
+			"ctime",
+			"cwchar",
+			"cwctype",	// end C++98 C-functionality headers
+			"algorithm",	// C++98 headers proper
+			"bitset",
+			"complex",
+			"deque",
+			"exception",
+			"fstream",
+			"functional",
+			"iomanip",
+			"ios",
+			"iosfwd",
+			"iostream",
+			"istream",
+			"iterator",
+			"limits",
+			"list",
+			"locale",
+			"map",
+			"memory",
+			"new",
+			"numeric",
+			"ostream",
+			"queue",
+			"set",
+			"sstream",
+			"stack",
+			"stdexcept",
+			"streambuf",
+			"string",
+			"typeinfo",
+			"utility",
+			"valarray",
+			"vector"	// end C++98 headers proper
+		};
+
+#define CPP_SYS_HEADER_STRICT_UB STATIC_SIZE(system_headers)
+#define C_SYS_HEADER_STRICT_UB 23
+
+static size_t LengthOfCSystemHeader(const char* src)
+{
+	const errr i = linear_find(src,system_headers,C_SYS_HEADER_STRICT_UB);
+	if (0<=i) return strlen(system_headers[i]);
+	return 0;
+}
+
+static size_t LengthOfCPPSystemHeader(const char* src)
+{
+	const errr i = linear_find(src,system_headers,CPP_SYS_HEADER_STRICT_UB);
+	if (0<=i) return strlen(system_headers[i]);
+	return 0;
+}
+
+/* XXX this may belong with weak_token XXX */
+static void message_header(const weak_token& src)
+{
+	assert(src.src_filename && *src.src_filename);
+	message_header(src.src_filename,src.logical_line.first);
+}
+
+/* XXX this may belong with enum_type XXX */
+static void message_header(const enum_def& src)
+{
+	assert(src.filename() && *src.filename());
+	message_header(src.filename(),src.loc().first);
+}
+
+/* XXX this may belong with C_union_struct_def XXX */
+static void message_header(const C_union_struct_def& src)
+{
+	assert(src.filename() && *src.filename());
+	message_header(src.filename(),src.loc().first);
+}
+
+// balanced character count
+static POD_pair<size_t,size_t>
+_balanced_character_count(const weak_token* tokenlist,size_t tokenlist_len,const char l_match,const char r_match)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	POD_pair<size_t,size_t> depth = {0,0};
+	const weak_token* const iter_end = tokenlist+tokenlist_len;
+	const weak_token* iter = tokenlist;
+	do	if (1==iter->token.second)
+			{
+			if 		(l_match==iter->token.first[0]) ++depth.first;
+			else if (r_match==iter->token.first[0]) ++depth.second;
+			}
+	while(++iter!=iter_end);
+	return depth;
+}
+
+template<char l_match,char r_match>
+inline static POD_pair<size_t,size_t> balanced_character_count(const weak_token* tokenlist,size_t tokenlist_len)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	return _balanced_character_count(tokenlist,tokenlist_len,l_match,r_match);
+}
+
+template<>
+POD_pair<size_t,size_t> balanced_character_count<'[',']'>(const weak_token* tokenlist,size_t tokenlist_len)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	POD_pair<size_t,size_t> depth = {0, 0};
+	const weak_token* const iter_end = tokenlist+tokenlist_len;
+	const weak_token* iter = tokenlist;
+	do	if 		(detect_C_left_bracket_op(iter->token.first,iter->token.second)) ++depth.first;
+		else if (detect_C_right_bracket_op(iter->token.first,iter->token.second)) ++depth.second;
+	while(++iter!=iter_end);
+	return depth;
+}
+
+template<>
+POD_pair<size_t,size_t> balanced_character_count<'{','}'>(const weak_token* tokenlist,size_t tokenlist_len)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	POD_pair<size_t,size_t> depth = {0, 0};
+	const weak_token* const iter_end = tokenlist+tokenlist_len;
+	const weak_token* iter = tokenlist;
+	do	if 		(detect_C_left_brace_op(iter->token.first,iter->token.second)) ++depth.first;
+		else if (detect_C_right_brace_op(iter->token.first,iter->token.second)) ++depth.second;
+	while(++iter!=iter_end);
+	return depth;
+}
+
+static POD_pair<size_t,size_t>
+_balanced_character_count(const parse_tree* tokenlist,size_t tokenlist_len,const char l_match,const char r_match)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	POD_pair<size_t,size_t> depth = {0, 0};
+	const parse_tree* const iter_end = tokenlist+tokenlist_len;
+	const parse_tree* iter = tokenlist;
+	do	if (1==iter->index_tokens[0].token.second && NULL==iter->index_tokens[1].token.first)
+			{
+			if 		(l_match==iter->index_tokens[0].token.first[0]) ++depth.first;
+			else if (r_match==iter->index_tokens[0].token.first[0]) ++depth.second;
+			}
+	while(++iter!=iter_end);
+	return depth;
+}
+
+template<char l_match,char r_match>
+inline static POD_pair<size_t,size_t> balanced_character_count(const parse_tree* tokenlist,size_t tokenlist_len)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	return _balanced_character_count(tokenlist,tokenlist_len,l_match,r_match);
+}
+
+template<>
+POD_pair<size_t,size_t> balanced_character_count<'[',']'>(const parse_tree* tokenlist,size_t tokenlist_len)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	POD_pair<size_t,size_t> depth = {0, 0};
+	const parse_tree* const iter_end = tokenlist+tokenlist_len;
+	const parse_tree* iter = tokenlist;
+	do	if (NULL==iter->index_tokens[1].token.first)
+			{
+			if 		(detect_C_left_bracket_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.first;
+			else if (detect_C_right_bracket_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.second;
+			}
+	while(++iter!=iter_end);
+	return depth;
+}
+
+template<>
+POD_pair<size_t,size_t> balanced_character_count<'{','}'>(const parse_tree* tokenlist,size_t tokenlist_len)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	POD_pair<size_t,size_t> depth = {0, 0};
+	const parse_tree* const iter_end = tokenlist+tokenlist_len;
+	const parse_tree* iter = tokenlist;
+	do	if (NULL==iter->index_tokens[1].token.first)
+			{
+			if 		(detect_C_left_brace_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.first;
+			else if (detect_C_right_brace_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.second;
+			}
+	while(++iter!=iter_end);
+	return depth;
+}
+
+static void unbalanced_error(const weak_token& src,size_t count, char match)
+{
+	assert(0<count);
+	message_header(src);
+	INC_INFORM(ERR_STR);
+	INC_INFORM(count);
+	INC_INFORM(" unbalanced '");
+	INC_INFORM(match);
+	INFORM('\'');
+	zcc_errors.inc_error();
+}
+
+static void _construct_matched_pairs(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1,const char l_match,const char r_match)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	POD_pair<size_t,size_t> depth = _balanced_character_count(tokenlist,tokenlist_len,l_match,r_match);	// pre-scan
+	std::pair<size_t,size_t> unbalanced_loc(0,0);
+	const size_t starting_errors = zcc_errors.err_count();
+
+	if (0<depth.first && 0<depth.second)
+		{
+		// reality-check: balanced parentheses
+		autovalarray_ptr_throws<size_t> fixedstack(depth.first);
+		autovalarray_ptr_throws<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
+
+		depth.first = 0;
+		depth.second = 0;
+		size_t balanced_paren = 0;
+		size_t i = 0;
+		do	if (1==tokenlist[i].token.second)
+				{
+				assert(NULL!=tokenlist[i].token.first);
+				if 		(l_match==tokenlist[i].token.first[0])
+					{	// soft-left: not an error
+					if (0<depth.second)
+						{
+						unbalanced_error(tokenlist[i],depth.second,r_match);
+						depth.second = 0;
+						}
+					if (0==depth.first) unbalanced_loc.first = i;
+					fixedstack[depth.first++] = i;
+					}
+				else if (r_match==tokenlist[i].token.first[0])
+					{
+					if (0<depth.first)
+						{
+						pair_fixedstack[balanced_paren].first = fixedstack[--depth.first];
+						pair_fixedstack[balanced_paren++].second = i;
+						}
+					else{
+						++depth.second;
+						unbalanced_loc.second = i;
+						}
+					};
+				}
+		while(tokenlist_len > ++i);
+		if (0==depth.first && 0==depth.second && starting_errors==zcc_errors.err_count())	// need to be more flexible here as well
+			{
+			assert(pair_fixedstack.size()==balanced_paren);	// only for hard-left hard-right
+			pair_fixedstack.MoveInto(stack1);
+			}
+		};
+
+	assert(0==depth.first || 0==depth.second);
+	if (0<depth.second)
+		// soft-left: not an error
+		unbalanced_error(tokenlist[unbalanced_loc.second],depth.second,r_match);
+	if (0<depth.first)
+		// soft-right: not an error
+		unbalanced_error(tokenlist[unbalanced_loc.first],depth.first,l_match);
+}
+
+template<char l_match,char r_match>
+static void construct_matched_pairs(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	_construct_matched_pairs(tokenlist,tokenlist_len,stack1,l_match,r_match);
+}
+
+template<>
+void construct_matched_pairs<'[',']'>(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	POD_pair<size_t,size_t> depth = balanced_character_count<'[',']'>(tokenlist,tokenlist_len);	// pre-scan
+	std::pair<size_t,size_t> unbalanced_loc(0,0);
+	const size_t starting_errors = zcc_errors.err_count();
+
+	if (0<depth.first && 0<depth.second)
+		{
+		// reality-check: balanced parentheses
+		autovalarray_ptr_throws<size_t> fixedstack(depth.first);
+		autovalarray_ptr_throws<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
+
+		depth.first = 0;
+		depth.second = 0;
+		size_t balanced_paren = 0;
+		size_t i = 0;
+		do	if (1==tokenlist[i].token.second)
+				{
+				assert(NULL!=tokenlist[i].token.first);
+				if 		(detect_C_left_bracket_op(tokenlist[i].token.first,tokenlist[i].token.second))
+					{
+					if (0<depth.second)
+						{
+						unbalanced_error(tokenlist[i],depth.second,']');
+						depth.second = 0;
+						}
+					if (0==depth.first) unbalanced_loc.first = i;
+					fixedstack[depth.first++] = i;
+					}
+				else if (detect_C_right_bracket_op(tokenlist[i].token.first,tokenlist[i].token.second))
+					{
+					if (0<depth.first)
+						{
+						pair_fixedstack[balanced_paren].first = fixedstack[--depth.first];
+						pair_fixedstack[balanced_paren++].second = i;
+						}
+					else{
+						++depth.second;
+						unbalanced_loc.second = i;
+						}
+					};
+				}
+		while(tokenlist_len > ++i);
+		if (0==depth.first && 0==depth.second && starting_errors==zcc_errors.err_count())
+			{
+			assert(pair_fixedstack.size()==balanced_paren);
+			pair_fixedstack.MoveInto(stack1);
+			}
+		};
+
+	assert(0==depth.first || 0==depth.second);
+	if (0<depth.second)
+		unbalanced_error(tokenlist[unbalanced_loc.second],depth.second,']');
+	if (0<depth.first)
+		unbalanced_error(tokenlist[unbalanced_loc.first],depth.first,'[');
+}
+
+template<>
+void construct_matched_pairs<'{','}'>(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	POD_pair<size_t,size_t> depth = balanced_character_count<'{','}'>(tokenlist,tokenlist_len);	// pre-scan
+	std::pair<size_t,size_t> unbalanced_loc(0,0);
+	const size_t starting_errors = zcc_errors.err_count();
+
+	if (0<depth.first && 0<depth.second)
+		{
+		// reality-check: balanced parentheses
+		autovalarray_ptr_throws<size_t> fixedstack(depth.first);
+		autovalarray_ptr_throws<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
+
+		depth.first = 0;
+		depth.second = 0;
+		size_t balanced_paren = 0;
+		size_t i = 0;
+		do	if (1==tokenlist[i].token.second)
+				{
+				assert(NULL!=tokenlist[i].token.first);
+				if 		(detect_C_left_brace_op(tokenlist[i].token.first,tokenlist[i].token.second))
+					{
+					if (0<depth.second)
+						{
+						unbalanced_error(tokenlist[i],depth.second,'}');
+						depth.second = 0;
+						}
+					if (0==depth.first) unbalanced_loc.first = i;
+					fixedstack[depth.first++] = i;
+					}
+				else if (detect_C_right_brace_op(tokenlist[i].token.first,tokenlist[i].token.second))
+					{
+					if (0<depth.first)
+						{
+						pair_fixedstack[balanced_paren].first = fixedstack[--depth.first];
+						pair_fixedstack[balanced_paren++].second = i;
+						}
+					else{
+						++depth.second;
+						unbalanced_loc.second = i;
+						}
+					};
+				}
+		while(tokenlist_len > ++i);
+		if (0==depth.first && 0==depth.second && starting_errors==zcc_errors.err_count())
+			{
+			assert(pair_fixedstack.size()==balanced_paren);
+			pair_fixedstack.MoveInto(stack1);
+			}
+		};
+
+	assert(0==depth.first || 0==depth.second);
+	if (0<depth.second)
+		unbalanced_error(tokenlist[unbalanced_loc.second],depth.second,'}');
+	if (0<depth.first)
+		unbalanced_error(tokenlist[unbalanced_loc.first],depth.first,'{');
+}
+
+
+static void
+_slice_error(const weak_token& src,size_t slice_count,const char cut,const std::pair<char,char>& knife)
+{
+	message_header(src);
+	INC_INFORM(ERR_STR);
+	INC_INFORM(slice_count);
+	INC_INFORM(' ');
+	INC_INFORM(cut);
+	INC_INFORM(" are unbalanced by improper grouping within ");
+	INC_INFORM(knife.first);
+	INC_INFORM(' ');
+	INFORM(knife.second);
+	zcc_errors.inc_error();
+}
+
+static void
+find_sliced_pairs(const weak_token* tokenlist, const autovalarray_ptr<POD_pair<size_t,size_t> >& stack1, const autovalarray_ptr<POD_pair<size_t,size_t> >& stack2,const std::pair<char,char>& pair1,const std::pair<char,char>& pair2)
+{
+	assert(NULL!=tokenlist);
+	if (stack1.empty()) return;
+	if (stack2.empty()) return;
+	size_t i = 0;
+	size_t j = 0;
+	do	{
+		if (stack1[i].second<stack2[j].first)
+			{	// ok (disjoint)
+			++i;
+			continue;
+			};
+		if (stack2[j].second<stack1[i].first)
+			{	// ok (disjoint)
+			++j;
+			continue;
+			};
+		if (stack1[i].first<stack2[j].first)
+			{
+			if (stack2[j].second<stack1[i].second)
+				{	// ok (proper nesting)
+				++i;
+				continue;
+				}
+			size_t slice_count = 1;
+			while(++i < stack1.size() && stack1[i].first<stack2[j].first && stack2[j].second>=stack1[i].second) ++slice_count;
+			_slice_error(tokenlist[stack1[i-1].first],slice_count,pair1.second,pair2);
+			continue;
+			}
+		if (stack2[j].first<stack1[i].first)
+			{
+			if (stack1[i].second<stack2[j].second)
+				{	// ok (proper nesting)
+				++j;
+				continue;
+				}
+			size_t slice_count = 1;
+			while(++j < stack2.size() && stack2[j].first<stack1[i].first && stack1[i].second>=stack2[j].second) ++slice_count;
+			_slice_error(tokenlist[stack2[j-1].first],slice_count,pair2.second,pair1);
+			continue;
+			}
+		}
+	while(i<stack1.size() && j<stack2.size());
+}
+
+static bool C_like_BalancingCheck(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	autovalarray_ptr<POD_pair<size_t,size_t> > parenpair_stack;
+	autovalarray_ptr<POD_pair<size_t,size_t> > bracketpair_stack;
+	autovalarray_ptr<POD_pair<size_t,size_t> > bracepair_stack;
+	const size_t starting_errors = zcc_errors.err_count();
+
+	// responsible for context-free error checking	
+	if (hard_start && hard_end)
+		{	// other test cases cannot be done from preprocessor
+		construct_matched_pairs<'(',')'>(tokenlist,tokenlist_len,parenpair_stack);
+		construct_matched_pairs<'[',']'>(tokenlist,tokenlist_len,bracketpair_stack);
+		construct_matched_pairs<'{','}'>(tokenlist,tokenlist_len,bracepair_stack);
+		if (starting_errors==zcc_errors.err_count())
+			{	/* check for slicing */
+			const int test_these = (!parenpair_stack.empty())+2*(!bracketpair_stack.empty())+4*(!bracepair_stack.empty());
+			switch(test_these)
+			{
+			default:	break;
+			case 7:		{	// all three
+						find_sliced_pairs(tokenlist,bracketpair_stack,bracepair_stack,std::pair<char,char>('[',']'),std::pair<char,char>('{','}'));
+						find_sliced_pairs(tokenlist,parenpair_stack,bracepair_stack,std::pair<char,char>('(',')'),std::pair<char,char>('{','}'));
+						find_sliced_pairs(tokenlist,parenpair_stack,bracketpair_stack,std::pair<char,char>('(',')'),std::pair<char,char>('[',']'));
+						break;
+						}
+			case 6:		{	// bracket and brace
+						find_sliced_pairs(tokenlist,bracketpair_stack,bracepair_stack,std::pair<char,char>('[',']'),std::pair<char,char>('{','}'));
+						break;
+						}
+			case 5:		{	// paren and brace
+						find_sliced_pairs(tokenlist,parenpair_stack,bracepair_stack,std::pair<char,char>('(',')'),std::pair<char,char>('{','}'));
+						break;
+						}
+			case 3:		{	// paren and bracket
+							//! \test cpp/default/Error_if_control70.hpp, cpp/default/Error_if_control70.h
+							//! \test cpp/default/Error_if_control71.hpp, cpp/default/Error_if_control71.h
+						find_sliced_pairs(tokenlist,parenpair_stack,bracketpair_stack,std::pair<char,char>('(',')'),std::pair<char,char>('[',']'));
+						break;
+						}
+			}
+			}
+		};
+	return starting_errors!=zcc_errors.err_count();
+}
+
+template<size_t targ_len>
+static inline bool
+robust_token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
+{
+	assert(NULL!=target);
+	assert(targ_len==strlen(target));
+	return NULL!=x.first && targ_len==x.second
+		&& !strncmp(x.first,target,targ_len);
+}
+
+static inline bool
+robust_token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
+{
+	assert(NULL!=target);
+	const size_t targ_len = strlen(target);
+	return NULL!=x.first && targ_len==x.second
+		&& !strncmp(x.first,target,targ_len);
+}
+
+template<size_t targ_len>
+static inline bool
+token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
+{
+	assert(NULL!=target);
+	assert(targ_len==strlen(target));
+	assert(NULL!=x.first);
+	return targ_len==x.second && !strncmp(x.first,target,targ_len);
+}
+
+static inline bool
+token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
+{
+	assert(NULL!=target);
+	assert(NULL!=x.first);
+	const size_t targ_len = strlen(target);
+	return targ_len==x.second && !strncmp(x.first,target,targ_len);
+}
+
+template<size_t targ_len>
+static inline bool
+robust_token_is_string(const parse_tree& x,const char* const target)
+{
+	return x.is_atomic() && token_is_string<targ_len>(x.index_tokens[0].token,target);
+}
+
+static inline bool
+robust_token_is_string(const parse_tree& x,const char* const target)
+{
+	return x.is_atomic() && token_is_string(x.index_tokens[0].token,target);
+}
+
+template<char c>
+static inline bool
+token_is_char(const POD_pair<const char*,size_t>& x)
+{
+	assert(NULL!=x.first);
+	return 1==x.second && c== *x.first;
+}
+
+template<>
+inline bool token_is_char<'#'>(const POD_pair<const char*,size_t>& x)
+{
+	assert(NULL!=x.first);
+	return detect_C_stringize_op(x.first,x.second);
+}
+
+template<>
+inline bool token_is_char<'['>(const POD_pair<const char*,size_t>& x)
+{
+	assert(NULL!=x.first);
+	return detect_C_left_bracket_op(x.first,x.second);
+}
+
+template<>
+inline bool token_is_char<']'>(const POD_pair<const char*,size_t>& x)
+{
+	assert(NULL!=x.first);
+	return detect_C_right_bracket_op(x.first,x.second);
+}
+
+template<>
+inline bool token_is_char<'{'>(const POD_pair<const char*,size_t>& x)
+{
+	assert(NULL!=x.first);
+	return detect_C_left_brace_op(x.first,x.second);
+}
+
+template<>
+inline bool token_is_char<'}'>(const POD_pair<const char*,size_t>& x)
+{
+	assert(NULL!=x.first);
+	return detect_C_right_brace_op(x.first,x.second);
+}
+
+template<char c>
+inline bool robust_token_is_char(const POD_pair<const char*,size_t>& x)
+{
+	return NULL!=x.first && 1==x.second && c== *x.first;
+}
+
+template<>
+inline bool robust_token_is_char<'#'>(const POD_pair<const char*,size_t>& x)
+{
+	return NULL!=x.first && detect_C_stringize_op(x.first,x.second);
+}
+
+template<>
+inline bool robust_token_is_char<'['>(const POD_pair<const char*,size_t>& x)
+{
+	return NULL!=x.first && detect_C_left_bracket_op(x.first,x.second);
+}
+
+template<>
+inline bool robust_token_is_char<']'>(const POD_pair<const char*,size_t>& x)
+{
+	return NULL!=x.first && detect_C_right_bracket_op(x.first,x.second);
+}
+
+template<>
+inline bool robust_token_is_char<'{'>(const POD_pair<const char*,size_t>& x)
+{
+	return NULL!=x.first && detect_C_left_brace_op(x.first,x.second);
+}
+
+template<>
+inline bool robust_token_is_char<'}'>(const POD_pair<const char*,size_t>& x)
+{
+	return NULL!=x.first && detect_C_right_brace_op(x.first,x.second);
+}
+
+template<char c> inline bool robust_token_is_char(const parse_tree& x)
+{
+	return x.is_atomic() && token_is_char<c>(x.index_tokens[0].token);
+}
+
+//! \todo if we have an asphyxiates_left_brace, suppress_naked_brackets_and_braces goes obsolete
+static bool asphyxiates_left_bracket(const weak_token& x)
+{
+	if ((C_TESTFLAG_IDENTIFIER | C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_STRING_LITERAL | C_TESTFLAG_PP_NUMERAL) & x.flags) return false;
+	if (token_is_char<')'>(x.token)) return false;
+	if (token_is_char<']'>(x.token)) return false;
+	return true;
+}
+
+//! \todo this forks when distinctions between C, C++ are supported
+// balancing errors are handled earlier
+static bool right_paren_asphyxiates(const weak_token& token)
+{
+	if (   token_is_char<'&'>(token.token)	// potentially unary operators
+		|| token_is_char<'*'>(token.token)
+		|| token_is_char<'+'>(token.token)
+		|| token_is_char<'-'>(token.token)
+		|| token_is_char<'~'>(token.token)
+		|| token_is_char<'!'>(token.token)
+	    || token_is_char<'/'>(token.token)	// proper multiplicative operators
+	    || token_is_char<'%'>(token.token)
+//		|| token_is_string<2>(token.token,"<<")	// shift operators -- watch out for parsing problems with templates, this really is C only
+//		|| token_is_string<2>(token.token,">>")
+//		|| token_is_char<'<'>(token.token)	// relational operators -- watch out for parsing problems with templates
+//	    || token_is_char<'>'>(token.token)
+		|| token_is_string<2>(token.token,"<=")
+		|| token_is_string<2>(token.token,">=")
+		|| token_is_string<2>(token.token,"==")	// equality operators
+		|| token_is_string<2>(token.token,"!=")
+	    || token_is_char<'^'>(token.token)		// bitwise XOR
+		|| token_is_char<'|'>(token.token)		// bitwise OR
+		|| token_is_string<2>(token.token,"&&")	// logical AND
+		|| token_is_string<2>(token.token,"||")	// logical OR
+		|| token_is_char<'?'>(token.token))	// operator ? :
+		return true;
+	return false;
+}
+
+//! \todo this forks when distinctions between C, C++ are supported
+static bool left_paren_asphyxiates(const weak_token& token)
+{
+	if (	token_is_char<'/'>(token.token)	// proper multiplicative operators
+	    ||	token_is_char<'%'>(token.token)
+//		|| token_is_string<2>(token.token,"<<")	// shift operators -- watch out for parsing problems with templates, this really is C only
+//		|| token_is_string<2>(token.token,">>")
+//		|| token_is_char<'<'>(token.token)	// relational operators -- watch out for parsing problems with templates
+//	    || token_is_char<'>'>(token.token)
+		|| token_is_string<2>(token.token,"<=")
+		|| token_is_string<2>(token.token,">=")
+		|| token_is_string<2>(token.token,"==")	// equality operators
+		|| token_is_string<2>(token.token,"!=")
+	    || token_is_char<'^'>(token.token)		// bitwise XOR
+		|| token_is_char<'|'>(token.token)		// bitwise OR
+		|| token_is_string<2>(token.token,"&&")	// logical AND
+		|| token_is_string<2>(token.token,"||")	// logical OR
+		||	token_is_char<'?'>(token.token)		// operator ? : 
+		||	token_is_char<':'>(token.token))	// one of operator ? :, or a label
+		return true;
+	return false;
+}
+
+static bool paren_is_bad_news(const weak_token& lhs, const weak_token& rhs)
+{
+	if (token_is_char<'['>(rhs.token) && asphyxiates_left_bracket(lhs))
+		{
+		message_header(rhs);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(lhs.token.first,lhs.token.second);
+		INFORM(" denies [ ] its left argument (C99 6.5.2p1/C++98 5.2p1)");
+		zcc_errors.inc_error();
+		};
+	if (token_is_char<')'>(rhs.token) || token_is_char<']'>(rhs.token))
+		{
+		if (right_paren_asphyxiates(lhs))
+			{
+			message_header(rhs);
+			INC_INFORM(ERR_STR);
+			INC_INFORM(rhs.token.first,rhs.token.second);
+			INC_INFORM(" denies ");
+			INC_INFORM(lhs.token.first,lhs.token.second);
+			INFORM(" its right argument (C99 6.5.3p1/C++98 5.3p1)");
+			zcc_errors.inc_error();
+			}
+		}
+	if (token_is_char<'('>(lhs.token) || token_is_char<'['>(lhs.token))
+		{
+		if (left_paren_asphyxiates(rhs))
+			{
+			message_header(lhs);
+			INC_INFORM(ERR_STR);
+			INC_INFORM(lhs.token.first,lhs.token.second);
+			INC_INFORM(" denies ");
+			INC_INFORM(rhs.token.first,rhs.token.second);
+			INFORM(" its left argument");
+			zcc_errors.inc_error();
+			}
+		}
+	return false;	//! \todo don't abuse std::adjacent_find
+}
+
+static bool C99_CoreControlExpressionContextFreeErrorCount(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	const size_t starting_errors = zcc_errors.err_count();
+	bool already_errored = false;
+
+	if (hard_start && token_is_char<'['>(tokenlist[0].token))
+		{	//! \test if.C99/Error_control3.h, if.C99/Error_control3.hpp
+		message_header(tokenlist[0]);
+		INC_INFORM(ERR_STR);
+		INFORM("[ at start of expression denies [ ] its left argument (C99 6.5.2p1/C++98 5.2p1)");
+		zcc_errors.inc_error();
+		};
+	if (hard_start && left_paren_asphyxiates(tokenlist[0]))
+		{	//! \test if.C99/Error_control4.h, if.C99/Error_control4.hpp
+			//! \test if.C99/Error_control11.h, if.C99/Error_control11.hpp
+			//! \test if.C99/Error_control12.h, if.C99/Error_control12.hpp
+			//! \test if.C99/Error_control13.h, if.C99/Error_control13.hpp
+			//! \test if.C99/Error_control14.h, if.C99/Error_control14.hpp
+			//! \test if.C99/Error_control15.h, if.C99/Error_control15.hpp
+			//! \test if.C99/Error_control16.h, if.C99/Error_control16.hpp
+			//! \test if.C99/Error_control17.h, if.C99/Error_control17.hpp
+			//! \test if.C99/Error_control18.h, if.C99/Error_control18.hpp
+			//! \test if.C99/Error_control19.h, if.C99/Error_control19.hpp
+			//! \test if.C99/Error_control20.h, if.C99/Error_control20.hpp
+			//! \test if.C99/Error_control21.h, if.C99/Error_control21.hpp
+		message_header(tokenlist[0]);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(tokenlist[0].token.first,tokenlist[0].token.second);
+		INFORM((1==tokenlist_len && hard_end && right_paren_asphyxiates(tokenlist[0])) ? " as only token doesn't have either of its arguments (C99 6.5.3p1/C++98 5.3p1)"
+				: " as first token doesn't have its left argument (C99 6.5.3p1/C++98 5.3p1)");
+		zcc_errors.inc_error();
+		already_errored = 1==tokenlist_len;
+		};
+	std::adjacent_find(tokenlist,tokenlist+tokenlist_len,paren_is_bad_news);
+	if (hard_end && !already_errored && right_paren_asphyxiates(tokenlist[tokenlist_len-1]))
+		{	//! \test if.C99/Error_control5.h, if.C99/Error_control5.hpp
+			//! \test if.C99/Error_control6.h, if.C99/Error_control6.hpp
+			//! \test if.C99/Error_control7.h, if.C99/Error_control7.hpp
+			//! \test if.C99/Error_control8.h, if.C99/Error_control8.hpp
+			//! \test if.C99/Error_control9.h, if.C99/Error_control9.hpp
+			//! \test if.C99/Error_control10.h, if.C99/Error_control10.hpp
+		message_header(tokenlist[tokenlist_len-1]);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(tokenlist[tokenlist_len-1].token.first,tokenlist[tokenlist_len-1].token.second);
+		INFORM(" as last token doesn't have its right argument (C99 6.5.3p1/C++98 5.3p1)");
+		zcc_errors.inc_error();
+		}
+
+	return starting_errors!=zcc_errors.err_count();
+}
+
+static bool C99_ControlExpressionContextFreeErrorCount(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	return C99_CoreControlExpressionContextFreeErrorCount(tokenlist,tokenlist_len,hard_start,hard_end);
+}
+
+static bool CPP_ControlExpressionContextFreeErrorCount(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
+{
+	assert(NULL!=tokenlist);
+	assert(0<tokenlist_len);
+	return C99_CoreControlExpressionContextFreeErrorCount(tokenlist,tokenlist_len,hard_start,hard_end);
+}
+
+size_t LengthOfCPurePreprocessingOperatorPunctuation(const char* const x)
+{
+	assert(x && *x);
+	if (strchr(ATOMIC_PREPROC_PUNC,*x)) return 1;
+	const errr i = linear_reverse_find_prefix_in_lencached(x,valid_pure_preprocessing_op_punc+NONATOMIC_PREPROC_OP_LB,C_PREPROC_OP_STRICT_UB-NONATOMIC_PREPROC_OP_LB);
+	if (0<=i) return valid_pure_preprocessing_op_punc[i+NONATOMIC_PREPROC_OP_LB].second;
+	return 0;
+}
+
+size_t LengthOfCPPPurePreprocessingOperatorPunctuation(const char* const x)
+{
+	assert(x && *x);
+	if (strchr(ATOMIC_PREPROC_PUNC,*x)) return 1;
+	const errr i = linear_reverse_find_prefix_in_lencached(x,valid_pure_preprocessing_op_punc+NONATOMIC_PREPROC_OP_LB,CPP_PREPROC_OP_STRICT_UB-NONATOMIC_PREPROC_OP_LB);
+	if (0<=i) return valid_pure_preprocessing_op_punc[i+NONATOMIC_PREPROC_OP_LB].second;
+	return 0;
+}
+
+static unsigned int CPurePreprocessingOperatorPunctuationFlags(signed int i)
+{
+	assert(0<i && C_PREPROC_OP_STRICT_UB>=(unsigned int)i);
+	return valid_pure_preprocessing_op_punc[i-1].third;
+}
+
+static unsigned int CPPPurePreprocessingOperatorPunctuationFlags(signed int i)
+{
+	assert(0<i && CPP_PREPROC_OP_STRICT_UB>=(unsigned int)i);
+	return valid_pure_preprocessing_op_punc[i-1].third;
+}
+
+// encoding reality checks
+BOOST_STATIC_ASSERT(PP_CODE_MASK>CPP_PREPROC_OP_STRICT_UB);
+BOOST_STATIC_ASSERT((PP_CODE_MASK>>1)<=CPP_PREPROC_OP_STRICT_UB);
+static signed int
+CPurePreprocessingOperatorPunctuationCode(const char* const x, size_t x_len)
+{
+	BOOST_STATIC_ASSERT(INT_MAX-1>=C_PREPROC_OP_STRICT_UB);
+	return 1+linear_reverse_find_lencached(x,x_len,valid_pure_preprocessing_op_punc,C_PREPROC_OP_STRICT_UB);
+}
+
+static signed int
+CPPPurePreprocessingOperatorPunctuationCode(const char* const x, size_t x_len)
+{
+	BOOST_STATIC_ASSERT(INT_MAX-1>=CPP_PREPROC_OP_STRICT_UB);
+	return 1+linear_reverse_find_lencached(x,x_len,valid_pure_preprocessing_op_punc,CPP_PREPROC_OP_STRICT_UB);
+}
+
+static void _bad_syntax_tokenized(const char* const x, size_t x_len, lex_flags& flags, const char* const src_filename, size_t line_no, func_traits<signed int (*)(const char* const, size_t)>::function_type find_pp_code)
+{
+	assert(x);
+	assert(src_filename && *src_filename);
+	assert(x_len<=strlen(x));
+	assert((C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_PP_OP_PUNC | C_TESTFLAG_STRING_LITERAL | C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_IDENTIFIER) & flags);
+
+	// reality checks on relation between flag constants and enums
+	BOOST_STATIC_ASSERT((C_PPFloatCore::F<<10)==C_TESTFLAG_F);
+	BOOST_STATIC_ASSERT((C_PPFloatCore::L<<10)==C_TESTFLAG_L);
+
+	BOOST_STATIC_ASSERT((C_PPIntCore::U<<10)==C_TESTFLAG_U);
+	BOOST_STATIC_ASSERT((C_PPIntCore::L<<10)==C_TESTFLAG_L);
+	BOOST_STATIC_ASSERT((C_PPIntCore::UL<<10)==(C_TESTFLAG_L | C_TESTFLAG_U));
+	BOOST_STATIC_ASSERT((C_PPIntCore::LL<<10)==C_TESTFLAG_LL);
+	BOOST_STATIC_ASSERT((C_PPIntCore::ULL<<10)==(C_TESTFLAG_LL | C_TESTFLAG_U));
+
+	if (C_TESTFLAG_PP_NUMERAL==flags)
+		{
+		union_quartet<C_PPIntCore,C_PPFloatCore,C_PPDecimalFloat,C_PPHexFloat> test;
+		if 		(C_PPDecimalFloat::is(x,x_len,test.third))
+			flags |= C_TESTFLAG_FLOAT | C_TESTFLAG_DECIMAL;
+		else if	(C_PPHexFloat::is(x,x_len,test.fourth))
+			flags |= C_TESTFLAG_FLOAT | C_TESTFLAG_HEXADECIMAL;
+		else if (C_PPIntCore::is(x,x_len,test.first))
+			{
+			assert(C_PPIntCore::ULL>=test.first.hinted_type);
+			flags |= (((lex_flags)(test.first.hinted_type))<<10);
+			assert(8==test.first.radix || 10==test.first.radix || 16==test.first.radix);
+			switch(test.first.radix)
+			{
+			case 8:		{
+						flags |= C_TESTFLAG_INTEGER | C_TESTFLAG_OCTAL;
+						break;
+						}
+			case 10:	{
+						flags |= C_TESTFLAG_INTEGER | C_TESTFLAG_DECIMAL;
+						break;
+						}
+			case 16:	{
+						flags |= C_TESTFLAG_INTEGER | C_TESTFLAG_HEXADECIMAL;
+						break;
+						}
+			};
+			}
+		if 		(flags & C_TESTFLAG_FLOAT)
+			{
+			assert(C_PPFloatCore::L>=test.second.hinted_type);
+			flags |= (((lex_flags)(test.second.hinted_type))<<10);
+			};
+		if (C_TESTFLAG_PP_NUMERAL==flags)
+			{
+			INC_INFORM(src_filename);
+			INC_INFORM(':');
+			INC_INFORM(line_no);
+			INC_INFORM(": ");
+			INC_INFORM(ERR_STR);
+			INC_INFORM("invalid preprocessing number");
+			INC_INFORM(x,x_len);
+			INFORM(" (C99 6.4.4.1p1,6.4.4.2p1/C++98 2.13.1,2.13.3)");
+			zcc_errors.inc_error();
+			return;
+			}
+		}
+	else if (C_TESTFLAG_PP_OP_PUNC & flags)
+		{	// language-sensitive token blacklisting
+		const signed int pp_code = find_pp_code(x,x_len);
+		assert(0<pp_code);
+		C_PP_ENCODE(flags,pp_code);
+		}
+	else if (C_TESTFLAG_STRING_LITERAL==flags)
+		{	// This gets in by C99 6.6p10, as 6.6p6 doesn't list string literals as legitimate
+		if (!IsLegalCString(x,x_len))
+			{
+			INC_INFORM(src_filename);
+			INC_INFORM(':');
+			INC_INFORM(line_no);
+			INC_INFORM(": ");
+			INC_INFORM(ERR_STR);
+			INC_INFORM(x,x_len);
+			INFORM(" : invalid string (C99 6.4.5p1/C++98 2.13.4)");
+			zcc_errors.inc_error();
+			return;
+			}
+		else if (bool_options[boolopt::pedantic])
+			{
+			INC_INFORM(src_filename);
+			INC_INFORM(':');
+			INC_INFORM(line_no);
+			INC_INFORM(": ");
+			INC_INFORM(WARN_STR);
+			INC_INFORM(x,x_len);
+			INFORM(" : string literals in integer constant expressions are only permitted, not required (C99 6.6p10)");
+			if (bool_options[boolopt::warnings_are_errors])
+				{
+				zcc_errors.inc_error();
+				return;
+				}
+			}
+		}
+	else if (C_TESTFLAG_CHAR_LITERAL==flags)
+		{
+		if (!IsLegalCCharacterLiteral(x,x_len))
+			{
+			INC_INFORM(src_filename);
+			INC_INFORM(':');
+			INC_INFORM(line_no);
+			INC_INFORM(": ");
+			INC_INFORM(ERR_STR);
+			INC_INFORM("invalid character literal ");
+			INC_INFORM(x,x_len);
+			INFORM(" (C99 6.4.4.4p1/C++98 2.13.2)");
+			zcc_errors.inc_error();
+			return;
+			}
+		}
+}
+
+static void C99_bad_syntax_tokenized(const char* const x, size_t x_len, lex_flags& flags, const char* const src_filename, size_t line_no)
+{
+	_bad_syntax_tokenized(x,x_len,flags,src_filename,line_no,CPurePreprocessingOperatorPunctuationCode);
+}
+
+static void CPP_bad_syntax_tokenized(const char* const x, size_t x_len, lex_flags& flags, const char* const src_filename, size_t line_no)
+{
+	_bad_syntax_tokenized(x,x_len,flags,src_filename,line_no,CPPPurePreprocessingOperatorPunctuationCode);
+}
+
+//! \todo fix these to not assume perfect matching character sets
+#define C99_SYMBOLIC_ESCAPED_ESCAPES "\a\b\f\n\r\t\v"
+#define C99_SYMBOLIC_ESCAPES "abfnrtv"
+#define C99_COPY_ESCAPES "\"'?\\"
+static const char* const c99_symbolic_escaped_escapes = C99_SYMBOLIC_ESCAPED_ESCAPES;
+static const char* const c99_symbolic_escapes = C99_SYMBOLIC_ESCAPES;
+
+static size_t LengthOfEscapedCString(const char* src, size_t src_len)
+{
+	assert(NULL!=src);
+	assert(0<src_len);
+	size_t actual_size = src_len;
+	size_t i = 0;
+	do	{
+		if ('\0'!=src[i])
+			{	// deal with the symbolic escapes
+			if (   strchr(c99_symbolic_escaped_escapes,src[i])
+				|| strchr("\"\\?",src[i]))
+				{
+				++actual_size;
+				continue;
+				};
+			if (!C_IsPrintableChar(src[i]))
+				{
+				// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
+				unsigned char tmp = src[i];
+				bool must_escape = (1<src_len-i && strchr(list_hexadecimal_digits,src[i+1]));
+				//! \todo fix to handle target CHAR_BIT different than ours
+#if 9>=CHAR_BIT
+				if (7U>=tmp || must_escape)
+#else
+				if (7U>=tmp || (must_escape && 511U>=tmp))
+#endif
+					{	// octal-escape if it's readable, or if it prevents escaping the next printable character
+					if (must_escape)
+						{
+						actual_size += 3;
+						continue;
+						}
+					do	{
+						++actual_size;
+						tmp /= 8U;
+						}
+					while(0<tmp);
+					continue;
+					}
+#if 9<CHAR_BIT
+#	if 16>=CHAR_BIT
+				if (must_escape)
+					{	// hexadecimal breaks; try universal-char-encoding
+					actual_size += 5;
+					continue;
+					}
+#	elif 32>=CHAR_BIT
+				if (must_escape)
+					{	// hexadecimal breaks; try universal-char-encoding
+					actual_size += 5;
+					if (65536<=tmp) actual_size += 4;
+					continue;
+					}
+#	else
+				if (must_escape && 65536*65536>tmp)
+					{	// hexadecimal breaks; try universal-char-encoding
+					actual_size += 5;
+					if (65536<=tmp) actual_size += 4;
+					continue;
+					}
+#	endif
+#endif
+				// hex-escape for legibility
+				while(16<=tmp)
+					{
+					++actual_size;
+					tmp /= 16;
+					};
+				actual_size += 2;
+				continue;
+				}
+			};
+		}
+	while(src_len > ++i);
+	return actual_size;
+}
+
+static size_t LengthOfEscapedCString(const my_UNICODE* src, size_t src_len)
+{	//! \todo synchronize with EscapeCString
+	assert(NULL!=src);
+	assert(0<src_len);
+	size_t actual_size = src_len;
+	size_t i = 0;
+	do	{
+		if ('\0'!=src[i])
+			{	// deal with the symbolic escapes
+			if (   strchr(c99_symbolic_escaped_escapes,src[i])
+				|| strchr("\"\\?",src[i]))
+				{
+				++actual_size;
+				continue;
+				};
+			if (!C_IsPrintableChar(src[i]))
+				{
+				// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
+				my_UNICODE tmp = src[i];
+				bool must_escape = (1<src_len-i && strchr(list_hexadecimal_digits,src[i+1]));
+				//! \todo fix to handle target CHAR_BIT different than ours
+#if 9>=CHAR_BIT*C_UNICODE_SIZE
+				if (7U>=tmp || must_escape)
+#else
+				if (7U>=tmp || (must_escape && 511U>=tmp))
+#endif
+					{	// octal-escape if it's readable, or if it prevents escaping the next printable character
+					if (must_escape)
+						{
+						actual_size += 3;
+						continue;
+						}
+					do	{
+						++actual_size;
+						tmp /= 8;
+						}
+					while(0<tmp);
+					continue;
+					}
+#if 9<CHAR_BIT*C_UNICODE_SIZE
+#	if 16>=CHAR_BIT*C_UNICODE_SIZE
+				if (must_escape)
+					{	// hexadecimal breaks; try universal-char-encoding
+					actual_size += 5;
+					continue;
+					}
+#	elif 32>=CHAR_BIT*C_UNICODE_SIZE
+				if (must_escape)
+					{	// hexadecimal breaks; try universal-char-encoding
+					actual_size += 5;
+					if (65536U<=tmp) actual_size += 4;
+					continue;
+					}
+#	else
+				if (must_escape && 65536ULL*65536ULL>tmp)
+					{	// hexadecimal breaks; try universal-char-encoding
+					actual_size += 5;
+					if (65536U<=tmp) actual_size += 4;
+					continue;
+					}
+#	endif
+#endif
+				// hex-escape for legibility
+				while(16<=tmp)
+					{
+					++actual_size;
+					tmp /= 16;
+					};
+				actual_size += 2;
+				continue;
+				}
+			};
+		}
+	while(src_len > ++i);
+	return actual_size;
+}
+
+static void EscapeCString(char* dest, const char* src, size_t src_len)
+{	// \todo fix ASCII dependency.
+	assert(NULL!=src);
+	assert(0<src_len);
+	size_t i = 0;
+	do	{
+		if ('\0'!=src[i])
+			{	// deal with the symbolic escapes
+			const char* const symbolic_escaped_escape = strchr(c99_symbolic_escaped_escapes,src[i]);
+			if (symbolic_escaped_escape)
+				{
+				*(dest++) = '\\';
+				*(dest++) = c99_symbolic_escapes[symbolic_escaped_escape-c99_symbolic_escaped_escapes];
+				continue;
+				};
+			//! \todo probably too cautious; we need to escape ? only if a ? immediately precedes it (break trigraph sequences)
+			if (strchr("\"\\?",src[i]))
+				{
+				*(dest++) = '\\';
+				*(dest++) = src[i];
+				continue;
+				}
+			};
+		// Note that hex escape sequence requires at least 2 bytes, so octal is just-as-cheap through decimal 63 (which takes 3 bytes in hex)
+		// however, octal isn't that user friendly; we clearly want to octal-escape only through 7
+		// \bug need test cases
+		if (!C_IsPrintableChar(src[i]))
+			{
+			// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
+			unsigned char tmp = src[i];
+			bool must_escape = (1<src_len-i && strchr(list_hexadecimal_digits,src[i+1]));
+			*(dest++) = '\\';
+			//! \todo fix to handle target CHAR_BIT different than ours
+#if 9>=CHAR_BIT
+			if (7U>=tmp || must_escape)
+#else
+			if (7U>=tmp || (must_escape && 511U>=tmp))
+#endif
+				{	// octal-escape if it's readable, or if it prevents escaping the next printable character
+				if (must_escape && 64U>tmp)
+					{
+					*(dest++) = '0';
+					if (8U>tmp) *(dest++) = '0';
+					};
+				do	{
+					*(dest++) = (tmp%8U)+(unsigned char)('0');
+					tmp /= 8U;
+					}
+				while(0<tmp);
+				continue;
+				}
+#if 9<CHAR_BIT
+#	if 16>=CHAR_BIT
+			if (must_escape)
+				{
+				*(dest++) = 'u';
+#		if 12<CHAR_BIT
+				*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/4096U)%16];
+#		else
+				*(dest++) = '0';
+#		endif
+				*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/256U)%16];
+				*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/16U)%16];
+				*(dest++) = C_HEXADECIMAL_DIGITS[tmp%16U];
+				continue;
+				}
+#	elif 32>=CHAR_BIT
+			if (must_escape)
+				{
+				if (65536U<=tmp)
+					{
+					*(dest++) = 'U';
+#		if 28<CHAR_BIT
+					*(dest++) = C_HEXADECIMAL_DIGITS[tmp/(65536ULL*4096ULL)];
+#		else
+					*(dest++) = '0';
+#		endif
+#		if 24<CHAR_BIT
+					*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/(65536ULL*256ULL))%16];
+#		else
+					*(dest++) = '0';
+#		endif
+#		if 20<CHAR_BIT
+					*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/(65536ULL*16ULL))%16];
+#		else
+					*(dest++) = '0';
+#		endif
+					*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/(65536ULL))%16];
+					}
+				else{
+					*(dest++) = 'u';
+					}
+				*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/4096U)%16];
+				*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/256U)%16];
+				*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/16U)%16];
+				*(dest++) = C_HEXADECIMAL_DIGITS[tmp%16];
+				continue;
+				}
+#	else
+			if (must_escape && 65536ULL*65536ULL>tmp)
+				{
+				if (65536U<=tmp)
+					{
+					*(dest++) = 'U';
+					*(dest++) = C_HEXADECIMAL_DIGITS[tmp/(65536ULL*4096ULL)];
+					*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/(65536ULL*256ULL))%16];
+					*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/(65536ULL*16ULL))%16];
+					*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/(65536ULL))%16];
+					}
+				else{
+					*(dest++) = 'u';
+					}
+				*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/4096U)%16];
+				*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/256U)%16];
+				*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/16U)%16];
+				*(dest++) = C_HEXADECIMAL_DIGITS[tmp%16];
+				continue;
+				}
+			if (must_escape) _fatal("unescapable string: escaping code points above 2^32-1 followed by a hexadecimal digit disallowed by C99; bug for C++ (should be escaping the hexadecimal digit as well)");
+#	endif
+#endif
+			// hex-escape for legibility
+			*(dest++) = 'x';
+			unsigned char power = 1;
+			while(power<=tmp/16) power *= 16;
+			do	{
+				*(dest++) = list_hexadecimal_digits[tmp/power];
+				tmp %= power;
+				power /= 16;
+				}
+			while(0<power);
+			continue;
+			}
+		*(dest++) = src[i];
+		}
+	while(src_len > ++i);
+}
+
+static void EscapeCString(char* dest, const my_UNICODE* src, size_t src_len)
+{	// \todo fix ASCII dependency.
+	assert(NULL!=src);
+	assert(0<src_len);
+	size_t i = 0;
+	do	{
+		if (0!=src[i] && UCHAR_MAX>=src[i])
+			{	// deal with the symbolic escapes
+			const char* const symbolic_escaped_escape = strchr(c99_symbolic_escaped_escapes,src[i]);
+			if (symbolic_escaped_escape)
+				{
+				*(dest++) = '\\';
+				*(dest++) = c99_symbolic_escapes[symbolic_escaped_escape-c99_symbolic_escaped_escapes];
+				continue;
+				};
+			//! \todo probably too cautious; we need to escape ? only if a ? immediately precedes it (break trigraph sequences)
+			if (strchr("\"\\?",src[i]))
+				{
+				*(dest++) = '\\';
+				*(dest++) = src[i];
+				continue;
+				}
+			};
+		// Note that hex escape sequence requires at least 2 bytes, so octal is just-as-cheap through decimal 63 (which takes 3 bytes in hex)
+		// however, octal isn't that user friendly; we clearly want to octal-escape only through 7
+		// \bug need test cases
+		if (!C_IsPrintableChar(src[i]))
+			{
+			// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
+			my_UNICODE tmp = src[i];
+			bool must_escape = (1<src_len-i && UCHAR_MAX>=src[i] && strchr(list_hexadecimal_digits,src[i+1]));
+			*(dest++) = '\\';
+			//! \todo fix to handle target CHAR_BIT different than ours
+#if 9>=CHAR_BIT*C_UNICODE_SIZE
+			if (7U>=tmp || must_escape)
+#else
+			if (7U>=tmp || (must_escape && 511U>=tmp))
+#endif
+				{	// octal-escape if it's readable, or if it prevents escaping the next printable character
+				if (must_escape && 64U>tmp)
+					{
+					*(dest++) = '0';
+					if (8U>tmp) *(dest++) = '0';
+					};
+				do	{
+					*(dest++) = (tmp%8U)+(unsigned char)('0');
+					tmp /= 8U;
+					}
+				while(0<tmp);
+				continue;
+				}
+#if 32>=CHAR_BIT*C_UNICODE_SIZE
+			if (must_escape)
+				{
+				if (65536U<=tmp)
+					{
+					*(dest++) = 'U';
+#	if 28<CHAR_BIT*C_UNICODE_SIZE
+					*(dest++) = C_HEXADECIMAL_DIGITS[tmp/(65536ULL*4096ULL)];
+#	else
+					*(dest++) = '0';
+#	endif
+#	if 24<CHAR_BIT*C_UNICODE_SIZE
+					*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/(65536ULL*256ULL))%16];
+#	else
+					*(dest++) = '0';
+#	endif
+#	if 20<CHAR_BIT*C_UNICODE_SIZE
+					*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/(65536ULL*16ULL))%16];
+#	else
+					*(dest++) = '0';
+#	endif
+					*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/(65536ULL))%16];
+					}
+				else{
+					*(dest++) = 'u';
+					}
+				*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/4096U)%16];
+				*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/256U)%16];
+				*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/16U)%16];
+				*(dest++) = C_HEXADECIMAL_DIGITS[tmp%16];
+				continue;
+				}
+#else
+			if (must_escape && 65536ULL*65536ULL>tmp)
+				{
+				if (65536U<=tmp)
+					{
+					*(dest++) = 'U';
+					*(dest++) = C_HEXADECIMAL_DIGITS[tmp/(65536ULL*4096ULL)];
+					*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/(65536ULL*256ULL))%16];
+					*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/(65536ULL*16ULL))%16];
+					*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/(65536ULL))%16];
+					}
+				else{
+					*(dest++) = 'u';
+					}
+				*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/4096U)%16];
+				*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/256U)%16];
+				*(dest++) = C_HEXADECIMAL_DIGITS[(tmp/16U)%16];
+				*(dest++) = C_HEXADECIMAL_DIGITS[tmp%16];
+				continue;
+				}
+			if (must_escape) _fatal("unescapable string: escaping code points above 2^32-1 followed by a hexadecimal digit disallowed by C99; bug for C++ (should be escaping the hexadecimal digit as well)");
+#endif
+			// hex-escape for legibility
+			*(dest++) = 'x';
+			unsigned char power = 1;
+			while(power<=tmp/16) power *= 16;
+			do	{
+				*(dest++) = list_hexadecimal_digits[tmp/power];
+				tmp %= power;
+				power /= 16;
+				}
+			while(0<power);
+			continue;
+			}
+		*(dest++) = src[i];
+		}
+	while(src_len > ++i);
+}
+
+static size_t octal_escape_length(const char* const src, const size_t ub)
+{
+	assert(NULL!=src);
+	const size_t oct_len = strspn(src,C_OCTAL_DIGITS);
+	return (ub<oct_len) ? ub : oct_len;
+}
+
+static unsigned int eval_octal_escape(const char* src, size_t src_len)
+{
+	assert(NULL!=src);
+	assert(0<src_len && src_len<=3);
+	unsigned int tmp = 0;
+	do	{
+		const unsigned char tmp2 = *(src++);
+		assert((in_range<'0','7'>(tmp2)));
+		tmp *= 8;
+		tmp += (tmp2-'0');
+		}
+	while(0< --src_len);
+	return tmp;
+}
+
+static size_t hex_escape_length(const char* const src, const size_t ub)
+{
+	assert(NULL!=src);
+	const size_t hex_len = strspn(src,C_HEXADECIMAL_DIGITS);
+	return (ub<hex_len) ? ub : hex_len;
+}
+
+static umaxint eval_hex_escape(const char* src, size_t src_len)
+{
+	assert(NULL!=src);
+	assert(0<src_len);
+	unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
+#ifndef NDEBUG
+	umaxint uchar_max(target_machine->unsigned_max<virtual_machine::std_int_long_long>());
+	uchar_max >>= 4;
+#endif
+	do	{
+		const unsigned char tmp2 = *(src++);
+		assert(strchr(C_HEXADECIMAL_DIGITS,tmp2));
+		assert(uchar_max>=tmp);
+		tmp <<= 4;
+		tmp += InterpretHexadecimalDigit(tmp2);
+		}
+	while(0< --src_len);
+	return tmp;
+}
+
+// must remain synchronized with RobustEscapedCharLength_C
+static size_t EscapedCharLength_C(const char* src, size_t src_len)
+{
+	assert(NULL!=src);
+	assert(0<src_len);
+	if ('\\' != *src) return 1;
+	assert(1<src_len && '\0'!=src[1]);
+	if (   strchr(C99_SYMBOLIC_ESCAPES,src[1])
+		|| strchr(C99_COPY_ESCAPES,src[1]))
+		return 2;
+	if ('U'==src[1] || 'u'==src[1] || 'x'==src[1])
+		{
+		assert(3<=src_len);
+		const size_t hex_len = hex_escape_length(src+2,src_len-2U);
+		switch(src[1])
+		{
+		case 'u':	{	// UNICODE escape
+					assert(4<=hex_len);
+					return 6;
+					}
+		case 'U':	{	// astral UNICODE escape
+					assert(8<=hex_len);
+					return 10;
+					}
+		case 'x':	{	// hexadecimal escape
+					assert(0<hex_len);
+					return hex_len+2;
+					}
+		}
+		};
+	const size_t oct_len = octal_escape_length(src+1,(3U>src_len-1U) ? 3U : src_len-1U);
+	assert(0<oct_len);
+	return oct_len+1;
+}
+
+// must remain synchronized with EscapedCharLength_C
+static size_t RobustEscapedCharLength_C(const char* src, size_t src_len)
+{
+	assert(NULL!=src);
+	assert(0<src_len);
+	if ('\\' != *src) return 1;
+	if (1>=src_len || '\0'==src[1]) return 0;
+	if (   strchr(C99_SYMBOLIC_ESCAPES,src[1])
+		|| strchr(C99_COPY_ESCAPES,src[1]))
+		return 2;
+	if ('U'==src[1] || 'u'==src[1] || 'x'==src[1])
+		{
+		if (2>=src_len) return 0;
+		const size_t hex_len = hex_escape_length(src+2,src_len-2U);
+		switch(src[1])
+		{
+		case 'u':	{	// UNICODE escape
+					if (4>hex_len) return 0;
+					return 6;
+					}
+		case 'U':	{	// astral UNICODE escape
+					if (8>hex_len) return 0;
+					return 10;
+					}
+		case 'x':	{	// hexadecimal escape
+					if (0>=hex_len) return 0;
+					return hex_len+2;
+					}
+		}
+		};
+	const size_t oct_len = octal_escape_length(src+1,(3U>src_len-1U) ? 3U : src_len-1U);
+	if (0>=oct_len) return 0;
+	return oct_len+1;
+}
+
+static size_t LengthOfUnescapedCString(const char* src, size_t src_len)
+{
+	assert(NULL!=src);
+	assert(0<src_len);
+
+	size_t analyze_length = 0;
+	size_t i = 0;
+	do	{
+		++analyze_length;
+		i += EscapedCharLength_C(src+i,src_len-i);
+		}
+	while(src_len > i);
+	return analyze_length;
+}
+
+static uintmax_t _eval_character(const char* src, size_t src_len)
+{
+	assert(NULL!=src);
+	assert(0<src_len);
+	if (1==src_len) return (unsigned char)(*src);
+	const char* tmp_escape = strchr(C_OCTAL_DIGITS,src[1]);
+	if (NULL!=tmp_escape)
+		{
+		const size_t oct_len = octal_escape_length(src+1,(3U>src_len-1U) ? 3U : src_len-1U);
+		assert(0<oct_len);
+		return eval_octal_escape(src+1,oct_len);
+		};
+	if (2==src_len)
+		{
+		tmp_escape = strchr(c99_symbolic_escapes,src[1]);
+		if (tmp_escape) return (unsigned char)(c99_symbolic_escaped_escapes[tmp_escape-c99_symbolic_escapes]);
+
+		assert(strchr(C99_COPY_ESCAPES,src[1]));
+		return (unsigned char)(src[1]);
+		}
+	assert((strchr("uUx",src[1])));
+	assert(3<=src_len);
+	return eval_hex_escape(src+2,src_len-2).to_uint();
+}
+
+static void UnescapeCString(char* dest, const char* src, size_t src_len)
+{	//! \todo cross-compiler augmentation target, dest needs to be able represent target strings
+	assert(NULL!=src);
+	assert(0<src_len);
+	assert(CHAR_BIT>=target_machine->C_char_bit());
+
+	size_t i = 0;
+	do	{
+		const size_t step = EscapedCharLength_C(src+i,src_len-i);
+		assert(UCHAR_MAX>=_eval_character(src+i,step));
+		*(dest++) = _eval_character(src+i,step);
+		i += step;
+		}
+	while(src_len > i);
+}
+
+static void UnescapeCWideString(my_UNICODE* dest, const char* src, size_t src_len)
+{	//! \todo cross-compiler change target, dest needs to be able represent target strings
+	assert(NULL!=src);
+	assert(0<src_len);
+	assert(C_UNICODE_MAX>=target_machine->unsigned_max(target_machine->UNICODE_wchar_t()));
+
+	size_t i = 0;
+	do	{
+		const size_t step = EscapedCharLength_C(src+i,src_len-i);
+		assert(C_UNICODE_MAX>=_eval_character(src+i,step));
+		*(dest++) = _eval_character(src+i,step);
+		i += step;
+		}
+	while(src_len > i);
+}
+
+bool IsLegalCString(const char* x, size_t x_len)
+{
+	assert(NULL!=x);
+	assert(0<x_len);
+	if ('"' != x[x_len-1]) return false;
+	if (0 == --x_len) return false;
+	const bool wide_string = 'L' == *x;
+	if (wide_string)
+		{
+		if (0 == --x_len) return false;	
+		++x;
+		}
+	if ('"' != *(x++)) return false;
+	if (0 == --x_len) return true;	// empty string is legal
+	const umaxint& uchar_max = target_machine->unsigned_max((wide_string) ? target_machine->UNICODE_wchar_t() : virtual_machine::std_int_char);
+
+	size_t i = 0;
+	do	{
+		const size_t step = RobustEscapedCharLength_C(x+i,x_len-i);
+		if (0==step) return false;
+		if (uchar_max<_eval_character(x+i,step)) return false;
+		i += step;
+		}
+	while(x_len > i);
+	return true;
+}
+
+bool IsLegalCCharacterLiteral(const char* x, size_t x_len)
+{
+	assert(NULL!=x);
+	assert(0<x_len);
+	if ('\'' != x[x_len-1]) return false;
+	if (0 == --x_len) return false;
+	const bool wide_string = 'L' == *x;
+	if (wide_string)
+		{
+		if (0 == --x_len) return false;	
+		++x;
+		}
+	if ('\'' != *(x++)) return false;
+	if (0 == --x_len) return false;	// empty character literal is illegal
+	const umaxint& uchar_max = target_machine->unsigned_max((wide_string) ? target_machine->UNICODE_wchar_t() : virtual_machine::std_int_char);
+
+	size_t i = 0;
+	do	{
+		const size_t step = RobustEscapedCharLength_C(x+i,x_len-i);
+		if (0==step) return false;
+		if (uchar_max<_eval_character(x+i,step)) return false;
+		i += step;
+		}
+	while(x_len > i);
+	return true;
+}
+
+static size_t LengthOfCStringLiteral(const char* src, size_t src_len)
+{
+	assert(NULL!=src);
+	assert(2<=src_len);
+	const bool wide_str = ('L'==src[0]);
+	if (wide_str)
+		{
+		++src;
+		if (2 > --src_len) return 0;
+		}
+	if ('"'!=src[--src_len]) return 0;
+	if ('"'!=*(src++)) return 0;
+	if (0 == --src_len) return 1;
+	return LengthOfUnescapedCString(src,src_len)+1;
+}
+
+static size_t LengthOfCCharLiteral(const char* src, size_t src_len)
+{
+	assert(NULL!=src);
+	assert(2<=src_len);
+	const bool wide_char = ('L'==src[0]);
+	if (wide_char)
+		{
+		++src;
+		if (2 > --src_len) return 0;
+		}
+	if ('\''!=src[--src_len]) return 0;
+	if ('\''!=*(src++)) return 0;
+	if (0 == --src_len) return 1;
+	return LengthOfUnescapedCString(src,src_len);
+}
+
+/*! 
+ * Locates the character in a character literal as a substring.  Use this as preparation for "collapsing in place".
+ * 
+ * \param src string to locate character in
+ * \param src_len length of string
+ * \param target_idx index we actually want
+ * \param char_offset offset of character literal body
+ * \param char_len length of character literal body
+ * 
+ * \return bool true iff located as-is
+ */
+bool LocateCCharacterLiteralAt(const char* const src, size_t src_len, size_t target_idx, size_t& char_offset, size_t& char_len)
+{
+	assert(NULL!=src);
+	assert(2<=src_len);
+	assert(IsLegalCString(src,src_len));
+	const char* src2 = src;
+	const size_t C_str_len = LengthOfCStringLiteral(src,src_len);
+	assert(C_str_len>target_idx);
+	// NUL; using <= to be failsafed in release mode
+	if (target_idx+1<=C_str_len) return false;
+	const bool wide_str = ('L'==src[0]);
+	if (wide_str)
+		{
+		++src2;
+		--src_len;
+		assert(2<=src_len);
+		}
+	++src2;
+	src_len -= 2;
+
+	size_t i = 0;
+	size_t j = 0;
+	do	{
+		const size_t step = EscapedCharLength_C(src2+i,src_len-i);
+		if (j==target_idx)
+			{
+			char_offset = i+(src2-src);
+			char_len = step;
+			return true;
+			}
+		i += step;
+		++j;
+		}
+	while(src_len > i);
+	return false;
+}
+
+void GetCCharacterLiteralAt(const char* src, size_t src_len, size_t target_idx, char*& tmp)
+{
+	assert(NULL!=src);
+	assert(2<=src_len);
+	assert(NULL==tmp);
+	assert(IsLegalCString(src,src_len));
+	const size_t C_str_len = LengthOfCStringLiteral(src,src_len);
+	assert(C_str_len>target_idx);
+	const bool wide_str = ('L'==src[0]);
+	if (wide_str)
+		{
+		++src;
+		--src_len;
+		assert(2<=src_len);
+		}
+	++src;
+	src_len -= 2;
+	if (target_idx+1==C_str_len)
+		{
+		char* tmp2 = _new_buffer_nonNULL_throws<char>((wide_str) ? 6 : 5);
+		tmp = tmp2;
+		if (wide_str) *(tmp2++) = 'L';
+		strcpy(tmp2,"'\\0'");
+		return;
+		};
+
+	size_t i = 0;
+	size_t j = 0;
+	do	{
+		const size_t step = EscapedCharLength_C(src+i,src_len-i);
+		if (j==target_idx)
+			{
+			char* tmp2 = _new_buffer_nonNULL_throws<char>(((wide_str) ? 3 : 2)+step);
+			tmp = tmp2;
+			if (wide_str) *(tmp2++) = 'L';
+			*(tmp2++) = '\'';
+			strncpy(tmp2,src+i,step);
+			*(tmp2 += step) = '\'';
+			return;
+			}
+		i += step;
+		++j;
+		}
+	while(src_len > i);
+}
+
+/*! 
+ * concatenates two string literals into a string literal.
+ * 
+ * \param src		C string literal 1, escaped
+ * \param src_len	length of C string literal 1
+ * \param src2		C string literal 2, escaped
+ * \param src2_len	length of C string literal 2
+ * \param target	where to put a dynamically created string literal, escaped
+ * 
+ * \return 1: success, new token in target
+ * \return 0: failure
+ * \return -1: use first string as concatenation
+ * \return -2: use second string as concatenation
+ * \return -3: use first string as content, but wide-string header from second string
+ * \return -4: use second string as content, but wide-string header from first string
+ * \return -5: failed to allocate memory
+ *
+ * \post return value is between -5 and 1 inclusive
+ * \post returns 1 iff NULL!=target
+ * \post if NULL!=target, target points to a valid string literal
+ */
+static int ConcatenateCStringLiterals(const char* src, size_t src_len, const char* src2, size_t src2_len, char*& target)
+{
+	assert(NULL!=src);
+	assert(NULL!=src2);
+	assert(2<=src_len);
+	assert(2<=src2_len);
+	assert(IsLegalCString(src,src_len));
+	assert(IsLegalCString(src2,src2_len));
+	assert(NULL==target);
+
+	const char* str1 = src;
+	const char* str2 = src2;
+	size_t str1_len = src_len;
+	size_t str2_len = src2_len;
+	const bool str1_wide = ('L'==src[0]);
+	const bool str2_wide = ('L'==src2[0]);
+	const bool str_target_wide = str1_wide || str2_wide;
+
+	if (str1_wide)
+		{
+		++str1;
+		--str1_len;
+		}
+	if (str2_wide)
+		{
+		++str2;
+		--str2_len;
+		}
+	++str1;
+	++str2;
+	str1_len -= 2;
+	str2_len -= 2;
+
+	if (0==str1_len)
+		{
+		if (str2_wide==str_target_wide) return -2;
+		return -4;
+		}
+	if (0==str2_len)
+		{
+		if (str1_wide==str_target_wide) return -1;
+		return -3;
+		}
+
+	const size_t str1_un_len = LengthOfUnescapedCString(src,src_len);
+
+	/* will simple algorithm work? */
+	bool simple_paste_ok = !strchr(C_HEXADECIMAL_DIGITS,*str2);
+	if (!simple_paste_ok)
+		{
+		POD_pair<size_t,size_t> loc;
+#ifndef NDEBUG
+		assert(LocateCCharacterLiteralAt(src,src_len,str1_un_len-1,loc.first,loc.second));
+#else
+		if (!LocateCCharacterLiteralAt(src,src_len,str1_un_len-1,loc.first,loc.second)) return 0;
+#endif
+		// octal and hexadecimal are bad for simple pasting
+		if (1==loc.second || !strchr("x01234567",src[loc.first+1]))
+			simple_paste_ok = true;
+		// but a 3-digit octal escape isn't
+		else if ('x'!=src[loc.first+1] && 4==loc.second)
+			simple_paste_ok = true;
+		if (!simple_paste_ok)
+			{	// a hex escape of more than 8 effective digits will force a hexadecimal digit to be escaped, pretty much requires hex-escaping in C99 (charset weirdness)
+				// C++ will let us off because it allows escaping printable characters, but this still is not good (charset weirdness) so we don't handle it yet
+				// fail immediately because we haven't implemented cross-charset preprocessing yet
+			if ('x'==src[loc.first+1] && 8<(loc.second-2)-strspn(src+loc.first+2,"0")) return 0;
+			}
+		}
+
+	if (simple_paste_ok)
+		{
+		const size_t new_start = (str_target_wide) ? 2 : 1;
+		const size_t new_width = str1_len+str2_len+new_start+1U;
+		target = reinterpret_cast<char*>(calloc(new_width,1));
+		if (NULL==target) return -5;
+		target[new_width-1] = '"';
+		target[new_start-1] = '"';
+		if (str_target_wide) target[0] = 'L';
+		strncpy(target+new_start,str1,str1_len);
+		strncpy(target+new_start+str1_len,str2,str2_len);
+		assert(IsLegalCString(target,new_width));
+		return 1;
+		};
+
+	// working buffer
+	const size_t str2_un_len = LengthOfUnescapedCString(src2,src2_len);
+	const size_t buf_len = str1_un_len+str2_un_len;
+	union_pair<char*,my_UNICODE*> buf;
+	if (str_target_wide)
+		{
+		buf.second = zaimoni::_new_buffer<my_UNICODE>(buf_len);
+		if (NULL==buf.second) return -5;
+		UnescapeCWideString(buf.second,str1,str1_len);
+		UnescapeCWideString(buf.second+str1_un_len,str2,str2_len);
+		//! \todo C vs C++
+		const size_t target_len = LengthOfEscapedCString(buf.second,buf_len);
+		target = zaimoni::_new_buffer<char>(target_len);
+		if (NULL==target)
+			{
+			free(buf.second);
+			return -5;
+			}
+		EscapeCString(target,buf.second,buf_len);
+		free(buf.second);
+		assert(IsLegalCString(target,target_len));
+		return 1;
+		}
+	else{
+		buf.first = zaimoni::_new_buffer<char>(buf_len);
+		if (NULL==buf.first) return -5;
+		UnescapeCString(buf.first,str1,str1_len);
+		UnescapeCString(buf.first+str1_un_len,str2,str2_len);
+		const size_t target_len = LengthOfEscapedCString(buf.first,buf_len);
+		target = zaimoni::_new_buffer<char>(target_len);
+		if (NULL==target)
+			{
+			free(buf.first);
+			return -5;
+			}
+		EscapeCString(target,buf.first,buf_len);
+		free(buf.first);
+		assert(IsLegalCString(target,target_len));
+		return 1;
+		}
+
+}
+
+static uintmax_t EvalCharacterLiteral(const char* src, size_t src_len)
+{
+	assert(NULL!=src);
+	assert(3<=src_len);
+	assert(IsLegalCCharacterLiteral(src,src_len));
+	const bool is_wide = 'L'== *src;
+	if (is_wide)
+		{
+		++src;
+		--src_len;
+		};
+	++src;
+	src_len -= 2;
+
+	const unsigned int target_char_bit = (is_wide ? target_machine->C_bit(target_machine->UNICODE_wchar_t()) : target_machine->C_char_bit());
+	assert(sizeof(uintmax_t)*CHAR_BIT >= target_char_bit);
+	const uintmax_t safe_limit = (UINTMAX_MAX>>target_char_bit);
+	uintmax_t tmp = 0;
+
+	size_t i = 0;
+	do	{
+		tmp <<= target_char_bit;
+		const size_t step = EscapedCharLength_C(src+i,src_len-i);
+		tmp += _eval_character(src+i,step);
+		i += step;
+		}
+	while(src_len > i && safe_limit>=tmp);
+	return tmp;
+}
+
+bool CCharLiteralIsFalse(const char* x,size_t x_len)
+{
+	assert(NULL!=x);
+	assert(0<x_len);
+	assert(IsLegalCCharacterLiteral(x,x_len));
+	const uintmax_t result = EvalCharacterLiteral(x,x_len);
+	if (0==result) return true;
+	if (bool_options[boolopt::char_is_unsigned]) return false;
+	switch(target_machine->C_signed_int_representation())
+	{
+	default: return false;
+	case virtual_machine::ones_complement:		{
+												unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
+												if (VM_MAX_BIT_PLATFORM>target_machine->C_char_bit()) tmp.set(target_machine->C_char_bit());
+												tmp -= 1;
+												return tmp==result;
+												}
+	case virtual_machine::sign_and_magnitude:	{
+												unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
+												tmp.set(target_machine->C_char_bit()-1);
+												return tmp==result;
+												}
+	};
+}
+
+// not sure if we need this bit, but it matches the standards
+// PM expression is C++ only
+#define PARSE_PRIMARY_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-1))
+#define PARSE_STRICT_POSTFIX_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-2))
+#define PARSE_STRICT_UNARY_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-3))
+#define PARSE_STRICT_CAST_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-4))
+#define PARSE_STRICT_PM_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-5))
+#define PARSE_STRICT_MULT_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-6))
+#define PARSE_STRICT_ADD_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-7))
+#define PARSE_STRICT_SHIFT_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-8))
+#define PARSE_STRICT_RELATIONAL_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-9))
+#define PARSE_STRICT_EQUALITY_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-10))
+#define PARSE_STRICT_BITAND_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-11))
+#define PARSE_STRICT_BITXOR_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-12))
+#define PARSE_STRICT_BITOR_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-13))
+#define PARSE_STRICT_LOGICAND_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-14))
+#define PARSE_STRICT_LOGICOR_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-15))
+#define PARSE_STRICT_CONDITIONAL_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-16))
+#define PARSE_STRICT_ASSIGNMENT_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-17))
+#define PARSE_STRICT_COMMA_EXPRESSION ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-18))
+
+/* strict type categories of parsing */
+#define PARSE_PRIMARY_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-19))
+#define PARSE_UNION_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-20))
+#define PARSE_CLASS_STRUCT_TYPE ((lex_flags)(1)<<(sizeof(lex_flags)*CHAR_BIT-21))
+
+// check for collision with lowest three bits
+BOOST_STATIC_ASSERT(sizeof(lex_flags)*CHAR_BIT-parse_tree::PREDEFINED_STRICT_UB>=20);
+
+/* nonstrict expression types */
+#define PARSE_POSTFIX_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION)
+#define PARSE_UNARY_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION)
+#define PARSE_CAST_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION)
+#define PARSE_PM_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION)
+#define PARSE_MULT_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION)
+#define PARSE_ADD_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION)
+#define PARSE_SHIFT_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION | PARSE_STRICT_SHIFT_EXPRESSION)
+#define PARSE_RELATIONAL_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION | PARSE_STRICT_SHIFT_EXPRESSION | PARSE_STRICT_RELATIONAL_EXPRESSION)
+#define PARSE_EQUALITY_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION | PARSE_STRICT_SHIFT_EXPRESSION | PARSE_STRICT_RELATIONAL_EXPRESSION | PARSE_STRICT_EQUALITY_EXPRESSION)
+#define PARSE_BITAND_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION | PARSE_STRICT_SHIFT_EXPRESSION | PARSE_STRICT_RELATIONAL_EXPRESSION | PARSE_STRICT_EQUALITY_EXPRESSION | PARSE_STRICT_BITAND_EXPRESSION)
+#define PARSE_BITXOR_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION | PARSE_STRICT_SHIFT_EXPRESSION | PARSE_STRICT_RELATIONAL_EXPRESSION | PARSE_STRICT_EQUALITY_EXPRESSION | PARSE_STRICT_BITAND_EXPRESSION | PARSE_STRICT_BITXOR_EXPRESSION)
+#define PARSE_BITOR_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION | PARSE_STRICT_SHIFT_EXPRESSION | PARSE_STRICT_RELATIONAL_EXPRESSION | PARSE_STRICT_EQUALITY_EXPRESSION | PARSE_STRICT_BITAND_EXPRESSION | PARSE_STRICT_BITXOR_EXPRESSION | PARSE_STRICT_BITOR_EXPRESSION)
+#define PARSE_LOGICAND_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION | PARSE_STRICT_SHIFT_EXPRESSION | PARSE_STRICT_RELATIONAL_EXPRESSION | PARSE_STRICT_EQUALITY_EXPRESSION | PARSE_STRICT_BITAND_EXPRESSION | PARSE_STRICT_BITXOR_EXPRESSION | PARSE_STRICT_BITOR_EXPRESSION | PARSE_STRICT_LOGICAND_EXPRESSION)
+#define PARSE_LOGICOR_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION | PARSE_STRICT_SHIFT_EXPRESSION | PARSE_STRICT_RELATIONAL_EXPRESSION | PARSE_STRICT_EQUALITY_EXPRESSION | PARSE_STRICT_BITAND_EXPRESSION | PARSE_STRICT_BITXOR_EXPRESSION | PARSE_STRICT_BITOR_EXPRESSION | PARSE_STRICT_LOGICAND_EXPRESSION | PARSE_STRICT_LOGICOR_EXPRESSION)
+#define PARSE_CONDITIONAL_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION | PARSE_STRICT_SHIFT_EXPRESSION | PARSE_STRICT_RELATIONAL_EXPRESSION | PARSE_STRICT_EQUALITY_EXPRESSION | PARSE_STRICT_BITAND_EXPRESSION | PARSE_STRICT_BITXOR_EXPRESSION | PARSE_STRICT_BITOR_EXPRESSION | PARSE_STRICT_LOGICAND_EXPRESSION | PARSE_STRICT_LOGICOR_EXPRESSION | PARSE_STRICT_CONDITIONAL_EXPRESSION)
+#define PARSE_ASSIGNMENT_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION | PARSE_STRICT_SHIFT_EXPRESSION | PARSE_STRICT_RELATIONAL_EXPRESSION | PARSE_STRICT_EQUALITY_EXPRESSION | PARSE_STRICT_BITAND_EXPRESSION | PARSE_STRICT_BITXOR_EXPRESSION | PARSE_STRICT_BITOR_EXPRESSION | PARSE_STRICT_LOGICAND_EXPRESSION | PARSE_STRICT_LOGICOR_EXPRESSION | PARSE_STRICT_CONDITIONAL_EXPRESSION | PARSE_STRICT_ASSIGNMENT_EXPRESSION)
+#define PARSE_EXPRESSION (PARSE_PRIMARY_EXPRESSION | PARSE_STRICT_POSTFIX_EXPRESSION | PARSE_STRICT_UNARY_EXPRESSION | PARSE_STRICT_CAST_EXPRESSION | PARSE_STRICT_PM_EXPRESSION | PARSE_STRICT_MULT_EXPRESSION | PARSE_STRICT_ADD_EXPRESSION | PARSE_STRICT_SHIFT_EXPRESSION | PARSE_STRICT_RELATIONAL_EXPRESSION | PARSE_STRICT_EQUALITY_EXPRESSION | PARSE_STRICT_BITAND_EXPRESSION | PARSE_STRICT_BITXOR_EXPRESSION | PARSE_STRICT_BITOR_EXPRESSION | PARSE_STRICT_LOGICAND_EXPRESSION | PARSE_STRICT_LOGICOR_EXPRESSION | PARSE_STRICT_CONDITIONAL_EXPRESSION | PARSE_STRICT_ASSIGNMENT_EXPRESSION | PARSE_STRICT_COMMA_EXPRESSION)
+
+/* nonstrict type categories */
+#define PARSE_TYPE (PARSE_PRIMARY_TYPE | PARSE_UNION_TYPE | PARSE_CLASS_STRUCT_TYPE)
+
+/* already-parsed */
+#define PARSE_OBVIOUS (PARSE_EXPRESSION | PARSE_TYPE | parse_tree::INVALID)
+
+#define PARSE_PAREN_PRIMARY_PASSTHROUGH (parse_tree::CONSTANT_EXPRESSION)
+
+/* XXX this may belong with parse_tree XXX */
+static void simple_error(parse_tree& src, const char* const err_str)
+{
+	assert(err_str && *err_str);
+	if (!(parse_tree::INVALID & src.flags))
+		{
+		src.flags |= parse_tree::INVALID;
+		message_header(src.index_tokens[0]);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(src);
+		INFORM(err_str);
+		zcc_errors.inc_error();
+		};
+}
+
+/* deal with following type catalog
+atomic:
+bool ?bool?	(_Bool for C)
+char16_t ?char16_t? (C++0x, don't worry about this yet)
+char32_t ?char32_t? (C++0x, don't worry about this yet)
+wchar_t ?wchar_t? (C++ only)
+void ?void?
+
+participates in composite:
+char ?char?
+unsigned char ?unsigned char?
+signed char ?signed char?
+
+unsigned ?unsigned int?
+unsigned int ?unsigned int?
+
+signed ?int?
+signed int ?int?
+int ?int?
+
+unsigned short int ?unsigned short int?
+unsigned short ?unsigned short int?
+
+unsigned long int ?unsigned long int?
+unsigned long ?unsigned long int?
+
+unsigned long long int ?unsigned long long int?
+unsigned long long ?unsigned long long int?
+
+signed long int ?long int?
+signed long ?long int?
+
+signed long long int ?long long int?
+signed long long ?long long int?
+long long int ?long long int?
+long long ?long long int?
+
+long int ?long int?
+long ?long int?
+
+signed short int ?short int?
+signed short ?short int?
+short int ?short int?
+short ?short int?
+
+float ?float?
+double ?double?
+long double ?long double?
+float _Complex "float"
+double _Complex "double"
+long double _Complex "long double"
+
+in any case, use up a flag to track "positively typename" status
+*/
+void set_C_canonical_type_representation(parse_tree& src,size_t i,size_t target_type)
+{	// range-restrict
+	assert(C_TYPE::VOID<=target_type && C_TYPE::LDOUBLE__COMPLEX>=target_type);
+	assert(C_TYPE::NOT_VOID!=target_type);	// not-void isn't a real type
+	assert(C_TYPE::BOOL!=target_type);	// this breaks in C++
+	assert(C_TYPE::INTEGERLIKE!=target_type);	// integerlike isn't a real type
+#define C_ATOMIC_TYPE_IDENTIFIER_BITFLAG ((1ULL<<C_TYPE::VOID) \
+	| (1ULL<<C_TYPE::BOOL) \
+	| (1ULL<<C_TYPE::CHAR) \
+	| (1ULL<<C_TYPE::SHRT) \
+	| (1ULL<<C_TYPE::INT) \
+	| (1ULL<<C_TYPE::UINT) \
+	| (1ULL<<C_TYPE::LONG) \
+	| (1ULL<<C_TYPE::FLOAT) \
+	| (1ULL<<C_TYPE::DOUBLE))
+
+	parse_tree& tmp = src.c_array<0>()[i];
+	tmp.type_code.set_type(target_type);
+	//! \todo should use something informative in place of 0; identifier not fine
+	tmp.grab_index_token_from_str_literal<0>(C_atomic_types[target_type-1].first,C_ATOMIC_TYPE_IDENTIFIER_BITFLAG & (1ULL<<target_type) ? C_TESTFLAG_IDENTIFIER : 0);
+	tmp.flags |= PARSE_PRIMARY_TYPE;
+#undef C_ATOMIC_TYPE_IDENTIFIER_BITFLAG
+}
+
+zaimoni::Loki::CheckReturnRequireRange<0,2,int>::value_type optional_keyword_choice(parse_tree& src,size_t i,kleene_star_core<size_t (*)(const char*)>& invariant_decl_scanner,size_t idx1,size_t idx2)
+{
+	size_t offset[2];
+	int tmp = 0;
+	assert(!invariant_decl_scanner.empty());
+	assert(src.size<0>()>i);
+	assert(src.size<0>()-i>=invariant_decl_scanner.size());
+	assert(invariant_decl_scanner.strict_ub()>idx1);
+	assert(invariant_decl_scanner.strict_ub()>idx2);
+	if ((idx1==invariant_decl_scanner[0])<invariant_decl_scanner.count(idx1))
+		{
+		++tmp;
+		offset[0] = invariant_decl_scanner.scan_nofail(idx1,1);
+		}
+	if ((idx2==invariant_decl_scanner[0])<invariant_decl_scanner.count(idx2))
+		{
+		tmp+=2;
+		offset[1] = invariant_decl_scanner.scan_nofail(idx2,1);
+		}
+	// if ambiguous, use the one whose completion is sooner
+	if (3==tmp) tmp -= offset[0]<offset[1] ? 2 : 1;
+	if (0<tmp)
+		{
+		src.DeleteIdx<0>(i+ ++offset[tmp-1]);
+		invariant_decl_scanner.DeleteIdx(offset[tmp-1]);
+		}
+	return tmp;
+}
+
+template<size_t ub> typename zaimoni::Loki::CheckReturnRequireRange<0,ub,size_t>::value_type optional_keyword_limit(parse_tree& src,size_t i,kleene_star_core<size_t (*)(const char*)>& invariant_decl_scanner,size_t idx1)
+{
+	size_t tmp = 0;
+	assert(!invariant_decl_scanner.empty());
+	assert(src.size<0>()>i);
+	assert(src.size<0>()-i>=invariant_decl_scanner.size());
+	assert(invariant_decl_scanner.strict_ub()>idx1);
+	while(ub>tmp && (idx1==invariant_decl_scanner[0])<invariant_decl_scanner.count(idx1))
+		{
+		size_t tmp2 = invariant_decl_scanner.scan_nofail(idx1,1);
+		src.DeleteIdx<0>(i+ ++tmp2);
+		invariant_decl_scanner.DeleteIdx(tmp2);
+		++tmp;
+		}
+	return tmp;
+}
+
+bool optional_keyword(parse_tree& src,size_t i,kleene_star_core<size_t (*)(const char*)>& invariant_decl_scanner,size_t idx1)
+{
+	assert(!invariant_decl_scanner.empty());
+	assert(src.size<0>()>i);
+	assert(src.size<0>()-i>=invariant_decl_scanner.size());
+	assert(invariant_decl_scanner.strict_ub()>idx1);
+	if ((idx1==invariant_decl_scanner[0])<invariant_decl_scanner.count(idx1))
+		{
+		size_t tmp = invariant_decl_scanner.scan_nofail(idx1,1);
+		src.DeleteIdx<0>(i+ ++tmp);
+		invariant_decl_scanner.DeleteIdx(tmp);
+		return true;
+		}
+	return false;
+}
+
+static void C99_notice_primary_type_atomic(parse_tree& src)
+{
+	if (src.is_atomic())
+		{
+		if (token_is_string<5>(src.index_tokens[0].token,"_Bool"))
+			{
+			src.type_code.set_type(C_TYPE::BOOL);
+			src.flags |= PARSE_PRIMARY_TYPE;
+			return;
+			};
+		if (token_is_string<4>(src.index_tokens[0].token,"void"))
+			{
+			src.type_code.set_type(C_TYPE::VOID);
+			src.flags |= PARSE_PRIMARY_TYPE;
+			return;
+			}
+		}
+}
+
+static void C99_notice_primary_type(parse_tree& src)
+{
+	assert(src.is_raw_list());
+	std::for_each(src.begin<0>(),src.end<0>(),C99_notice_primary_type_atomic);
+
+	size_t i = 0;
+	kleene_star<STATIC_SIZE(C99_decl_specifier_list),size_t (*)(const char*)> invariant_decl_scanner(C99_invariant_decl_specifier);
+	do	{
+		if (src.data<0>()[i].is_atomic() && invariant_decl_scanner(src.data<0>()[i].index_tokens[0].token.first))
+			{
+			bool have_warned_about_register = false;
+			bool have_warned_about_static = false;
+			bool have_warned_about_extern = false;
+			bool have_warned_about_thread_local = false;
+			bool have_warned_about_auto = false;
+			bool have_warned_about_typedef = false;
+			bool have_warned_about_const = false;
+			bool have_warned_about_volatile = false;
+			bool have_warned_about_restrict = false;
+
+			size_t offset = 0;
+			while(src.size<0>()>i+ ++offset && invariant_decl_scanner(src.data<0>()[i+offset].index_tokens[0].token.first))
+				{	// C1X 6.7.1p2: at most one storage-class specifier, except _Thread_Local may stack with static or extern
+				if (1<invariant_decl_scanner.count(C99_CPP_REGISTER_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_register)
+						{	//! \todo --do-what-i-mean should warn
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("removing prohibited duplicated register storage class and continuing (C99 6.7.1p2)");
+						zcc_errors.inc_error();
+						have_warned_about_register = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				else if (1<invariant_decl_scanner.count(C99_CPP_STATIC_IDX))
+					{	//! \test decl.C99/Error_dup_static.h
+					if (!have_warned_about_static)
+						{	//! \todo --do-what-i-mean should warn
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("removing prohibited duplicated static storage class and continuing (C99 6.7.1p2)");
+						zcc_errors.inc_error();
+						have_warned_about_static = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				else if (1<invariant_decl_scanner.count(C99_CPP_EXTERN_IDX))
+					{	//! \test decl.C99/Error_dup_extern.h
+					if (!have_warned_about_extern)
+						{	//! \todo --do-what-i-mean should warn
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("removing prohibited duplicated extern storage class and continuing (C99 6.7.1p2)");
+						zcc_errors.inc_error();
+						have_warned_about_extern = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				else if (1<invariant_decl_scanner.count(C1X_CPP0X_THREAD_LOCAL_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_thread_local)
+						{	//! \todo --do-what-i-mean should warn
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("removing prohibited duplicated _Thread_Local storage class and continuing (C1X 6.7.1p2)");
+						zcc_errors.inc_error();
+						have_warned_about_thread_local = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				else if (1<invariant_decl_scanner.count(C99_CPP_AUTO_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_auto)
+						{	//! \todo --do-what-i-mean should warn
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("removing prohibited duplicated auto storage class and continuing (C99 6.7.1p2)");
+						zcc_errors.inc_error();
+						have_warned_about_auto = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				else if (1<invariant_decl_scanner.count(C99_CPP_TYPEDEF_IDX))
+					{	//! \test decl.C99/Error_dup_typedef.h
+					if (!have_warned_about_typedef)
+						{	//! \todo --do-what-i-mean should warn
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("removing prohibited duplicated typedef storage class and continuing (C99 6.7.1p2)");
+						zcc_errors.inc_error();
+						have_warned_about_typedef = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				// C1X 6.7.3p3: duplicate type-qualifiers should be cleaned (warn unless -Wno-OAOO or -Wno-DRY)
+				else if (1<invariant_decl_scanner.count(C99_CPP_CONST_IDX))
+					{	//! \test decl.C99/Warn_dup_const.h
+					if (!have_warned_about_const)
+						{
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing redundant const type qualifier (C99 6.7.3p4)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_const = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				else if (1<invariant_decl_scanner.count(C99_CPP_VOLATILE_IDX))
+					{	//! \test decl.C99/Warn_dup_volatile.h
+					if (!have_warned_about_volatile)
+						{
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing redundant volatile type qualifier (C99 6.7.3p4)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_volatile = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				else if (1<invariant_decl_scanner.count(C99_RESTRICT_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_restrict)
+						{
+						message_header(src.data<0>()[i+offset].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing redundant restrict type qualifier (C99 6.7.3p4)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_restrict = true;
+						}
+					src.DeleteIdx<0>(i+offset);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				};
+
+			// handle allowed sequences of type-qualifiers (do need second pass later)
+			bool have_warned_about_Complex = false;
+			do	{
+				switch(invariant_decl_scanner[0])
+				{
+				case C99_CPP_CHAR_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					BOOST_STATIC_ASSERT(1==C_TYPE::SCHAR-C_TYPE::CHAR);
+					BOOST_STATIC_ASSERT(2==C_TYPE::UCHAR-C_TYPE::CHAR);
+					set_C_canonical_type_representation(src,i,C_TYPE::CHAR+optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX));
+					break;
+				case C99_CPP_SHORT_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					// short and signed short are the same type
+					BOOST_STATIC_ASSERT(1==C_TYPE::USHRT-C_TYPE::SHRT);
+					set_C_canonical_type_representation(src,i,C_TYPE::SHRT+(2==optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX)));
+					// short int is the same as short
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_INT_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					{
+					int tmp = optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX);
+					// XXX have to account for short
+					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX,C99_CPP_LONG_IDX))
+					{
+					case 0:
+						{
+						BOOST_STATIC_ASSERT(1==C_TYPE::UINT-C_TYPE::INT);
+						set_C_canonical_type_representation(src,i,C_TYPE::INT+(2==tmp));
+						break;
+						}
+					case 1:
+						{
+						BOOST_STATIC_ASSERT(1==C_TYPE::USHRT-C_TYPE::SHRT);
+						set_C_canonical_type_representation(src,i,C_TYPE::SHRT+(2==tmp));
+						break;
+						}
+					default:
+						{
+						BOOST_STATIC_ASSERT(3==C_TYPE::ULLONG-C_TYPE::LONG);
+						BOOST_STATIC_ASSERT(2==C_TYPE::LLONG-C_TYPE::LONG);
+						BOOST_STATIC_ASSERT(1==C_TYPE::ULONG-C_TYPE::LONG);
+						set_C_canonical_type_representation(src,i,C_TYPE::LONG+(2==tmp)+2*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+//						break;
+						}
+					}
+					}
+					break;
+				case C99_CPP_LONG_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_DOUBLE_IDX))
+						{
+						BOOST_STATIC_ASSERT(3==C_TYPE::LDOUBLE__COMPLEX-C_TYPE::LDOUBLE);
+						set_C_canonical_type_representation(src,i,C_TYPE::LDOUBLE+3*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_COMPLEX_IDX));
+						break;
+						}
+					BOOST_STATIC_ASSERT(3==C_TYPE::ULLONG-C_TYPE::LONG);
+					BOOST_STATIC_ASSERT(2==C_TYPE::LLONG-C_TYPE::LONG);
+					BOOST_STATIC_ASSERT(1==C_TYPE::ULONG-C_TYPE::LONG);
+					set_C_canonical_type_representation(src,i,C_TYPE::LONG+(2==optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX))+2*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+					// long int is the same as long
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_FLOAT_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					BOOST_STATIC_ASSERT(3==C_TYPE::FLOAT__COMPLEX-C_TYPE::FLOAT);
+					set_C_canonical_type_representation(src,i,C_TYPE::FLOAT+3*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_COMPLEX_IDX));
+					break;
+				case C99_CPP_DOUBLE_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					BOOST_STATIC_ASSERT(1==C_TYPE::LDOUBLE-C_TYPE::DOUBLE);
+					BOOST_STATIC_ASSERT(3==C_TYPE::DOUBLE__COMPLEX-C_TYPE::DOUBLE);
+					BOOST_STATIC_ASSERT(4==C_TYPE::LDOUBLE__COMPLEX-C_TYPE::DOUBLE);
+					set_C_canonical_type_representation(src,i,C_TYPE::DOUBLE+optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX)+3*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_COMPLEX_IDX));
+					break;
+				case C99_CPP_SIGNED_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_CHAR_IDX))
+						{
+						set_C_canonical_type_representation(src,i,C_TYPE::SCHAR);
+						break;
+						}
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX))
+						set_C_canonical_type_representation(src,i,C_TYPE::SHRT);
+					else{
+						BOOST_STATIC_ASSERT(2==C_TYPE::LONG-C_TYPE::INT);
+						BOOST_STATIC_ASSERT(4==C_TYPE::LLONG-C_TYPE::INT);
+						set_C_canonical_type_representation(src,i,C_TYPE::INT+2*optional_keyword_limit<2>(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+						}
+					// signed int is the same as signed
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_UNSIGNED_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_CHAR_IDX))
+						{
+						set_C_canonical_type_representation(src,i,C_TYPE::UCHAR);
+						break;
+						}
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX))
+						set_C_canonical_type_representation(src,i,C_TYPE::USHRT);
+					else{
+						BOOST_STATIC_ASSERT(2==C_TYPE::ULONG-C_TYPE::UINT);
+						BOOST_STATIC_ASSERT(4==C_TYPE::ULLONG-C_TYPE::UINT);
+						set_C_canonical_type_representation(src,i,C_TYPE::UINT+2*optional_keyword_limit<2>(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+						}
+					// unsigned int is the same as unsigned
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_COMPLEX_IDX:
+					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_FLOAT_IDX,C99_CPP_DOUBLE_IDX))
+					{
+					case 0:
+						{
+						if (!have_warned_about_Complex)
+							{
+							message_header(src.data<0>()[i].index_tokens[0]);
+							INC_INFORM(ERR_STR);
+							INFORM("type-specifier-sequence has _Complex without either float or double (C99 6.7.3p4)");
+							zcc_errors.inc_error();
+							have_warned_about_Complex = true;
+							}
+						// remove the unusable token
+						src.DeleteIdx<0>(i--);
+						break;
+						}
+					case 1:
+						src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+						set_C_canonical_type_representation(src,i,C_TYPE::FLOAT__COMPLEX);
+						break;
+					case 2:
+						src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+						BOOST_STATIC_ASSERT(1==C_TYPE::LDOUBLE__COMPLEX-C_TYPE::DOUBLE__COMPLEX);
+						set_C_canonical_type_representation(src,i,C_TYPE::DOUBLE__COMPLEX+optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+//						break;						
+					}
+//					break;					
+				}
+				invariant_decl_scanner.DeleteIdx(0);
+				++i;
+				}
+			while(!invariant_decl_scanner.empty());
+
+			// defer handling: _Thread_Local, typedef, other storage class issues
+			}
+		}
+	while(src.size<0>()> ++i);
+}
+
+static void CPP_notice_primary_type_atomic(parse_tree& src)
+{
+	if (src.is_atomic())
+		{
+		if (token_is_string<4>(src.index_tokens[0].token,"bool"))
+			{
+			src.type_code.set_type(C_TYPE::BOOL);
+			src.flags |= PARSE_PRIMARY_TYPE;
+			return;
+			};
+		if (token_is_string<7>(src.index_tokens[0].token,"wchar_t"))
+			{
+			src.type_code.set_type(C_TYPE::WCHAR_T);
+			src.flags |= PARSE_PRIMARY_TYPE;
+			return;
+			}
+		if (token_is_string<4>(src.index_tokens[0].token,"void"))
+			{
+			src.type_code.set_type(C_TYPE::VOID);
+			src.flags |= PARSE_PRIMARY_TYPE;
+			return;
+			}
+		}
+}
+
+static void CPP_notice_primary_type(parse_tree& src)
+{
+	assert(src.is_raw_list());
+	std::for_each(src.begin<0>(),src.end<0>(),CPP_notice_primary_type_atomic);
+
+	size_t i = 0;
+	kleene_star<STATIC_SIZE(CPP0X_decl_specifier_list),size_t (*)(const char*)> invariant_decl_scanner(CPP0X_invariant_decl_specifier);
+	do	{
+		if (src.data<0>()[i].is_atomic() && invariant_decl_scanner(src.data<0>()[i].index_tokens[0].token.first))
+			{
+			bool have_warned_about_register = false;
+			bool have_warned_about_static = false;
+			bool have_warned_about_extern = false;
+			bool have_warned_about_thread_local = false;
+			bool have_warned_about_mutable = false;
+			bool have_warned_about_typedef = false;
+			bool have_warned_about_const = false;
+			bool have_warned_about_volatile = false;
+			bool using_linkage = false;
+			size_t offset = 0;
+
+			// C++0X 7.5: intercept linkage specifications here, warn if discarding (must accept "C" and "C++")
+			if (C99_CPP_EXTERN_IDX==invariant_decl_scanner[0] && 1<src.size<0>()-i && (C_TESTFLAG_STRING_LITERAL & src.data<0>()[i+1].flags))
+				{	//! \todo should accept escape codes here as well
+				if (strcmp(src.data<0>()[i+1].index_tokens[0].token.first,"\"C\"") && strcmp(src.data<0>()[i+1].index_tokens[0].token.first,"\"C++\""))
+					{	//! \bug need test case
+					message_header(src.data<0>()[i+1].index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("discarding unrecognized linkage (only C, C++ required: C++0X 7.5p2)");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					src.DeleteIdx<0>(i+1);
+					}
+				else
+					using_linkage = true;
+				}
+			
+			while(src.size<0>()>i+ ++offset+using_linkage && invariant_decl_scanner(src.data<0>()[i+offset+using_linkage].index_tokens[0].token.first))
+				{	// C++0X 7.1.1p1: at most one storage-class specifier, except thread_local may stack with static or extern
+				if (1<invariant_decl_scanner.count(C99_CPP_REGISTER_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_register)
+						{	//! \todo --do-what-i-mean should warn
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("removing prohibited duplicated register storage class and continuing (C++0X 7.1.1p1)");
+						zcc_errors.inc_error();
+						have_warned_about_register = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				if (1<invariant_decl_scanner.count(C99_CPP_STATIC_IDX))
+					{	//! \test decl.C99/Error_dup_static.hpp
+					if (!have_warned_about_static)
+						{	//! \todo --do-what-i-mean should warn
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("removing prohibited duplicated static storage class and continuing (C++0X 7.1.1p1)");
+						zcc_errors.inc_error();
+						have_warned_about_static = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				else if (1<invariant_decl_scanner.count(C99_CPP_EXTERN_IDX))
+					{	//! \test decl.C99/Error_dup_extern.hpp
+					if (!have_warned_about_extern)
+						{	//! \todo --do-what-i-mean should warn
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("removing prohibited duplicated extern storage class and continuing (C++0X 7.1.1p1)");
+						zcc_errors.inc_error();
+						have_warned_about_extern = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				else if (1<invariant_decl_scanner.count(C1X_CPP0X_THREAD_LOCAL_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_thread_local)
+						{	//! \todo --do-what-i-mean should warn
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("removing prohibited duplicated thread_local storage class and continuing (C++0X 7.1.1p1)");
+						zcc_errors.inc_error();
+						have_warned_about_thread_local = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				else if (1<invariant_decl_scanner.count(CPP_MUTABLE_IDX))
+					{	//! \bug need test case
+					if (!have_warned_about_mutable)
+						{	//! \todo --do-what-i-mean should warn
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("removing prohibited duplicated mutable storage class and continuing (C++0X 7.1.1p1)");
+						zcc_errors.inc_error();
+						have_warned_about_mutable = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				else if (1<invariant_decl_scanner.count(C99_CPP_TYPEDEF_IDX))
+					{	//! \test decl.C99/Error_dup_typedef.h
+					if (!have_warned_about_typedef)
+						{	//! \todo --do-what-i-mean should warn
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("removing prohibited duplicated typedef specifier and continuing (C++0X 7.1.3p1)");
+						zcc_errors.inc_error();
+						have_warned_about_typedef = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				// C++0X 7.1.6.1: duplicate cv-qualifiers should be cleaned (warn unless -Wno-OAOO or -Wno-DRY)
+				else if (1<invariant_decl_scanner.count(C99_CPP_CONST_IDX))
+					{	//! \test decl.C99/Warn_dup_const.hpp
+					if (!have_warned_about_const)
+						{
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing redundant const cv-qualifier (C++0X 7.1.6.1p1)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_const = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				else if (1<invariant_decl_scanner.count(C99_CPP_VOLATILE_IDX))
+					{	//! \test decl.C99/Warn_dup_volatile.hpp
+					if (!have_warned_about_volatile)
+						{
+						message_header(src.data<0>()[i+offset+using_linkage].index_tokens[0]);
+						INC_INFORM(WARN_STR);
+						INFORM("removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+						if (bool_options[boolopt::warnings_are_errors])
+							zcc_errors.inc_error();
+						have_warned_about_volatile = true;
+						}
+					src.DeleteIdx<0>(i+offset+using_linkage);
+					invariant_decl_scanner.DeleteIdx(offset--);					
+					}
+				};
+
+			// handle allowed sequences of type-qualifiers (do need second pass later)
+			bool have_warned_about_Complex = false;
+			do	{
+				switch(invariant_decl_scanner[0])
+				{
+				case C99_CPP_CHAR_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					BOOST_STATIC_ASSERT(1==C_TYPE::SCHAR-C_TYPE::CHAR);
+					BOOST_STATIC_ASSERT(2==C_TYPE::UCHAR-C_TYPE::CHAR);
+					set_C_canonical_type_representation(src,i,C_TYPE::CHAR+optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX));
+					break;
+				case C99_CPP_SHORT_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					// short and signed short are the same type
+					BOOST_STATIC_ASSERT(1==C_TYPE::USHRT-C_TYPE::SHRT);
+					set_C_canonical_type_representation(src,i,C_TYPE::SHRT+(2==optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX)));
+					// short int is the same as short
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_INT_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					{
+					int tmp = optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX);
+					// XXX have to account for short
+					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX,C99_CPP_LONG_IDX))
+					{
+					case 0:
+						{
+						BOOST_STATIC_ASSERT(1==C_TYPE::UINT-C_TYPE::INT);
+						set_C_canonical_type_representation(src,i,C_TYPE::INT+(2==tmp));
+						break;
+						}
+					case 1:
+						{
+						BOOST_STATIC_ASSERT(1==C_TYPE::USHRT-C_TYPE::SHRT);
+						set_C_canonical_type_representation(src,i,C_TYPE::SHRT+(2==tmp));
+						break;
+						}
+					default:
+						{
+						BOOST_STATIC_ASSERT(3==C_TYPE::ULLONG-C_TYPE::LONG);
+						BOOST_STATIC_ASSERT(2==C_TYPE::LLONG-C_TYPE::LONG);
+						BOOST_STATIC_ASSERT(1==C_TYPE::ULONG-C_TYPE::LONG);
+						set_C_canonical_type_representation(src,i,C_TYPE::LONG+(2==tmp)+2*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+//						break;
+						}
+					}
+					}
+					break;
+				case C99_CPP_LONG_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_DOUBLE_IDX))
+						{
+						BOOST_STATIC_ASSERT(3==C_TYPE::LDOUBLE__COMPLEX-C_TYPE::LDOUBLE);
+						set_C_canonical_type_representation(src,i,C_TYPE::LDOUBLE+3*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_COMPLEX_IDX));
+						break;
+						}
+					BOOST_STATIC_ASSERT(3==C_TYPE::ULLONG-C_TYPE::LONG);
+					BOOST_STATIC_ASSERT(2==C_TYPE::LLONG-C_TYPE::LONG);
+					BOOST_STATIC_ASSERT(1==C_TYPE::ULONG-C_TYPE::LONG);
+					set_C_canonical_type_representation(src,i,C_TYPE::LONG+(2==optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SIGNED_IDX,C99_CPP_UNSIGNED_IDX))+2*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+					// long int is the same as long
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_FLOAT_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					BOOST_STATIC_ASSERT(3==C_TYPE::FLOAT__COMPLEX-C_TYPE::FLOAT);
+					set_C_canonical_type_representation(src,i,C_TYPE::FLOAT+3*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_COMPLEX_IDX));
+					break;
+				case C99_CPP_DOUBLE_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					BOOST_STATIC_ASSERT(1==C_TYPE::LDOUBLE-C_TYPE::DOUBLE);
+					BOOST_STATIC_ASSERT(3==C_TYPE::DOUBLE__COMPLEX-C_TYPE::DOUBLE);
+					BOOST_STATIC_ASSERT(4==C_TYPE::LDOUBLE__COMPLEX-C_TYPE::DOUBLE);
+					set_C_canonical_type_representation(src,i,C_TYPE::DOUBLE+optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX)+3*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_COMPLEX_IDX));
+					break;
+				case C99_CPP_SIGNED_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_CHAR_IDX))
+						{
+						set_C_canonical_type_representation(src,i,C_TYPE::SCHAR);
+						break;
+						}
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX))
+						set_C_canonical_type_representation(src,i,C_TYPE::SHRT);
+					else{
+						BOOST_STATIC_ASSERT(2==C_TYPE::LONG-C_TYPE::INT);
+						BOOST_STATIC_ASSERT(4==C_TYPE::LLONG-C_TYPE::INT);
+						set_C_canonical_type_representation(src,i,C_TYPE::INT+2*optional_keyword_limit<2>(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+						}
+					// signed int is the same as signed
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_UNSIGNED_IDX:
+					src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_CHAR_IDX))
+						{
+						set_C_canonical_type_representation(src,i,C_TYPE::UCHAR);
+						break;
+						}
+					if (optional_keyword(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX))
+						set_C_canonical_type_representation(src,i,C_TYPE::USHRT);
+					else{
+						BOOST_STATIC_ASSERT(2==C_TYPE::ULONG-C_TYPE::UINT);
+						BOOST_STATIC_ASSERT(4==C_TYPE::ULLONG-C_TYPE::UINT);
+						set_C_canonical_type_representation(src,i,C_TYPE::UINT+2*optional_keyword_limit<2>(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+						}
+					// unsigned int is the same as unsigned
+					optional_keyword(src,i,invariant_decl_scanner,C99_CPP_INT_IDX);
+					break;
+				case C99_CPP_COMPLEX_IDX:
+					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_FLOAT_IDX,C99_CPP_DOUBLE_IDX))
+					{
+					case 0:
+						{
+						if (!have_warned_about_Complex)
+							{
+							message_header(src.data<0>()[i].index_tokens[0]);
+							INC_INFORM(ERR_STR);
+							INFORM("type-specifier-sequence has _Complex without either float or double (C99 6.7.3p4)");
+							zcc_errors.inc_error();
+							have_warned_about_Complex = true;
+							}
+						// remove the unusable token
+						src.DeleteIdx<0>(i--);
+						break;
+						}
+					case 1:
+						src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+						set_C_canonical_type_representation(src,i,C_TYPE::FLOAT__COMPLEX);
+						break;
+					case 2:
+						src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
+						BOOST_STATIC_ASSERT(1==C_TYPE::LDOUBLE__COMPLEX-C_TYPE::DOUBLE__COMPLEX);
+						set_C_canonical_type_representation(src,i,C_TYPE::DOUBLE__COMPLEX+optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
+//						break;						
+					}
+//					break;					
+				}
+				invariant_decl_scanner.DeleteIdx(0);
+				++i;
+				}
+			while(!invariant_decl_scanner.empty());
+
+			// defer handling thread_local, typedef restrictions 
+			}
+		}
+	while(src.size<0>()> ++i);
+}
+
+//! \todo generalize -- function pointer parameter target, functor target
+static size_t _count_identifiers(const parse_tree& src)
+{
+	size_t count_id = 0;
+	if (NULL!=src.index_tokens[0].token.first && C_TESTFLAG_IDENTIFIER==src.index_tokens[0].flags) ++count_id;
+	if (NULL!=src.index_tokens[1].token.first && C_TESTFLAG_IDENTIFIER==src.index_tokens[1].flags) ++count_id;
+	size_t i = src.size<0>();
+	while(0<i) count_id += _count_identifiers(src.data<0>()[--i]);
+	i = src.size<1>();
+	while(0<i) count_id += _count_identifiers(src.data<1>()[--i]);
+	i = src.size<2>();
+	while(0<i) count_id += _count_identifiers(src.data<2>()[--i]);
+	return count_id;
+}
+
+static bool is_naked_parentheses_pair(const parse_tree& src)
+{
+	return		robust_token_is_char<'('>(src.index_tokens[0].token)
+			&&	robust_token_is_char<')'>(src.index_tokens[1].token)
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+#endif
+			&&	src.empty<1>() && src.empty<2>();
+}
+
+static bool is_naked_brace_pair(const parse_tree& src)
+{
+	return		robust_token_is_char<'{'>(src.index_tokens[0].token)
+			&&	robust_token_is_char<'}'>(src.index_tokens[1].token)
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+#endif
+			&&	src.empty<1>() && src.empty<2>();
+}
+
+static bool is_naked_bracket_pair(const parse_tree& src)
+{
+	return		robust_token_is_char<'['>(src.index_tokens[0].token)
+			&&	robust_token_is_char<']'>(src.index_tokens[1].token)
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+#endif
+			&&	src.empty<1>() && src.empty<2>();
+}
+
+static bool is_nonempty_naked_pair(const parse_tree& src)
+{
+	return !src.empty<0>()  && (is_naked_parentheses_pair(src) 
+		|| is_naked_brace_pair(src)
+		|| is_naked_bracket_pair(src));
+}
+
+#ifndef NDEBUG
+static bool is_array_deref_strict(const parse_tree& src)
+{
+	return		robust_token_is_char<'['>(src.index_tokens[0].token)
+			&&	robust_token_is_char<']'>(src.index_tokens[1].token)
+			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<0>()->flags)			// content of [ ]
+			&&	1==src.size<1>() && (PARSE_POSTFIX_EXPRESSION & src.data<1>()->flags)	// prefix arg of [ ]
+			&&	src.empty<2>();
+}
+#endif
+
+static bool is_array_deref(const parse_tree& src)
+{
+	return		robust_token_is_char<'['>(src.index_tokens[0].token)
+			&&	robust_token_is_char<']'>(src.index_tokens[1].token)
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+#endif
+			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<0>()->flags)			// content of [ ]
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)	// prefix arg of [ ]
+			&&	src.empty<2>();
+}
+
+#define C99_UNARY_SUBTYPE_PLUS 1
+#define C99_UNARY_SUBTYPE_NEG 2
+#define C99_UNARY_SUBTYPE_DEREF 3
+#define C99_UNARY_SUBTYPE_ADDRESSOF 4
+#define C99_UNARY_SUBTYPE_NOT 5
+#define C99_UNARY_SUBTYPE_COMPL 6
+#define C99_UNARY_SUBTYPE_SIZEOF 7
+
+template<char c> static bool is_C99_unary_operator_expression(const parse_tree& src)
+{
+	return		robust_token_is_char<c>(src.index_tokens[0].token)
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	src.empty<1>()
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
+//			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
+}
+
+static bool is_CPP_logical_NOT_expression(const parse_tree& src)
+{
+	return		(robust_token_is_char<'!'>(src.index_tokens[0].token) || robust_token_is_string<3>(src.index_tokens[0].token,"not"))
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	src.empty<1>()
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
+//			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
+}
+
+static bool is_CPP_bitwise_complement_expression(const parse_tree& src)
+{
+	return		(robust_token_is_char<'~'>(src.index_tokens[0].token) || robust_token_is_string<5>(src.index_tokens[0].token,"compl"))
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	src.empty<1>()
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
+//			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
+}
+
+static bool is_CPP0X_typeid_expression(const parse_tree& src)
+{
+	return		(robust_token_is_string<6>(src.index_tokens[0].token,"typeid"))
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	src.empty<1>()
+			&&	1==src.size<2>() && ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags)
+			&&	C_TYPE::TYPEINFO==src.type_code.base_type_index
+			&&	0==src.type_code.pointer_power
+			&&	(src.type_code.qualifier<0>() & (type_spec::lvalue | type_spec::_const))==(type_spec::lvalue | type_spec::_const);
+}
+
+#ifndef NDEBUG
+static bool is_C99_CPP_sizeof_expression(const parse_tree& src)
+{
+	return		(robust_token_is_string<6>(src.index_tokens[0].token,"sizeof"))
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	src.empty<1>()
+			&&	1==src.size<2>() && ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
+//			&&	1==src.size<2>() && ((PARSE_UNARY_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
+}
+#endif
+
+#define C99_MULT_SUBTYPE_DIV 1
+#define C99_MULT_SUBTYPE_MOD 2
+#define C99_MULT_SUBTYPE_MULT 3
+
+BOOST_STATIC_ASSERT(C99_UNARY_SUBTYPE_DEREF==C99_MULT_SUBTYPE_MULT);
+
+#ifndef NDEBUG
+static bool is_C99_mult_operator_expression(const parse_tree& src)
+{
+	return		(robust_token_is_char<'/'>(src.index_tokens[0].token) || robust_token_is_char<'%'>(src.index_tokens[0].token) || robust_token_is_char<'*'>(src.index_tokens[0].token))
+			&&	NULL!=src.index_tokens[0].src_filename
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
+//			&&	1==src.size<1>() && (PARSE_MULT_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_PM_EXPRESSION & src.data<2>()->flags);
+}
+#endif
+
+template<char c> static bool is_C99_mult_operator_expression(const parse_tree& src)
+{
+	return		robust_token_is_char<c>(src.index_tokens[0].token)
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
+//			&&	1==src.size<1>() && (PARSE_MULT_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_PM_EXPRESSION & src.data<2>()->flags);
+}
+
+#define C99_ADD_SUBTYPE_PLUS 1
+#define C99_ADD_SUBTYPE_MINUS 2
+
+BOOST_STATIC_ASSERT(C99_UNARY_SUBTYPE_PLUS==C99_ADD_SUBTYPE_PLUS);
+BOOST_STATIC_ASSERT(C99_UNARY_SUBTYPE_NEG==C99_ADD_SUBTYPE_MINUS);
+
+#ifndef NDEBUG
+static bool is_C99_add_operator_expression(const parse_tree& src)
+{
+	return		(robust_token_is_char<'+'>(src.index_tokens[0].token) || robust_token_is_char<'-'>(src.index_tokens[0].token))
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
+//			&&	1==src.size<1>() && (PARSE_ADD_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_MULT_EXPRESSION & src.data<2>()->flags);
+}
+#endif
+
+template<char c> static bool is_C99_add_operator_expression(const parse_tree& src)
+{
+	return		robust_token_is_char<c>(src.index_tokens[0].token)
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
+//			&&	1==src.size<1>() && (PARSE_ADD_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_MULT_EXPRESSION & src.data<2>()->flags);
+}
+
+#define C99_SHIFT_SUBTYPE_LEFT 1
+#define C99_SHIFT_SUBTYPE_RIGHT 2
+static bool is_C99_shift_expression(const parse_tree& src)
+{
+	return		(robust_token_is_string<2>(src.index_tokens[0].token,"<<") || robust_token_is_string<2>(src.index_tokens[0].token,">>"))
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
+//			&&	1==src.size<1>() && (PARSE_SHIFT_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_ADD_EXPRESSION & src.data<2>()->flags);
+}
+
+#define C99_RELATION_SUBTYPE_LT 1
+#define C99_RELATION_SUBTYPE_GT 2
+#define C99_RELATION_SUBTYPE_LTE 3
+#define C99_RELATION_SUBTYPE_GTE 4
+
+static bool is_C99_relation_expression(const parse_tree& src)
+{
+	return		(robust_token_is_char<'<'>(src.index_tokens[0].token) || robust_token_is_char<'>'>(src.index_tokens[0].token) || robust_token_is_string<2>(src.index_tokens[0].token,"<=") || robust_token_is_string<2>(src.index_tokens[0].token,">="))
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
+//			&&	1==src.size<1>() && (PARSE_RELATIONAL_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_SHIFT_EXPRESSION & src.data<2>()->flags);
+}
+
+#define C99_EQUALITY_SUBTYPE_EQ 1
+#define C99_EQUALITY_SUBTYPE_NEQ 2
+static bool is_C99_equality_expression(const parse_tree& src)
+{
+	return		(robust_token_is_string<2>(src.index_tokens[0].token,"==") || robust_token_is_string<2>(src.index_tokens[0].token,"!="))
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
+//			&&	1==src.size<1>() && (PARSE_EQUALITY_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_RELATIONAL_EXPRESSION & src.data<2>()->flags);
+}
+
+static bool is_CPP_equality_expression(const parse_tree& src)
+{
+	return		(robust_token_is_string<2>(src.index_tokens[0].token,"==") || robust_token_is_string<2>(src.index_tokens[0].token,"!=") || robust_token_is_string<6>(src.index_tokens[0].token,"not_eq"))
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
+//			&&	1==src.size<1>() && (PARSE_EQUALITY_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_RELATIONAL_EXPRESSION & src.data<2>()->flags);
+}
+
+static bool is_C99_bitwise_AND_expression(const parse_tree& src)
+{
+	return (	robust_token_is_char<'&'>(src.index_tokens[0].token)
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
+//			&&	1==src.size<1>() && (PARSE_BITAND_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_EQUALITY_EXPRESSION & src.data<2>()->flags));
+}
+
+static bool is_CPP_bitwise_AND_expression(const parse_tree& src)
+{
+	return (	(robust_token_is_char<'&'>(src.index_tokens[0].token) || robust_token_is_string<6>(src.index_tokens[0].token,"bitand"))
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
+//			&&	1==src.size<1>() && (PARSE_BITAND_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_EQUALITY_EXPRESSION & src.data<2>()->flags));
+}
+
+static bool is_C99_bitwise_XOR_expression(const parse_tree& src)
+{
+	return (	robust_token_is_char<'^'>(src.index_tokens[0].token)
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
+//			&&	1==src.size<1>() && (PARSE_BITXOR_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_BITAND_EXPRESSION & src.data<2>()->flags));
+}
+
+static bool is_CPP_bitwise_XOR_expression(const parse_tree& src)
+{
+	return (	(robust_token_is_char<'^'>(src.index_tokens[0].token) || robust_token_is_string<3>(src.index_tokens[0].token,"xor"))
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
+//			&&	1==src.size<1>() && (PARSE_BITXOR_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_BITAND_EXPRESSION & src.data<2>()->flags));
+}
+
+static bool is_C99_bitwise_OR_expression(const parse_tree& src)
+{
+	return (	robust_token_is_char<'|'>(src.index_tokens[0].token)
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
+//			&&	1==src.size<1>() && (PARSE_BITOR_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_BITXOR_EXPRESSION & src.data<2>()->flags));
+}
+
+static bool is_CPP_bitwise_OR_expression(const parse_tree& src)
+{
+	return (	(robust_token_is_char<'|'>(src.index_tokens[0].token) || robust_token_is_string<5>(src.index_tokens[0].token,"bitor"))
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
+//			&&	1==src.size<1>() && (PARSE_BITOR_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_BITXOR_EXPRESSION & src.data<2>()->flags));
+}
+
+static bool is_C99_logical_AND_expression(const parse_tree& src)
+{
+	return (	robust_token_is_string<2>(src.index_tokens[0].token,"&&")
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
+//			&&	1==src.size<1>() && (PARSE_LOGICAND_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_BITOR_EXPRESSION & src.data<2>()->flags));
+}
+
+static bool is_CPP_logical_AND_expression(const parse_tree& src)
+{
+	return (	(robust_token_is_string<2>(src.index_tokens[0].token,"&&") || robust_token_is_string<3>(src.index_tokens[0].token,"and"))
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
+//			&&	1==src.size<1>() && (PARSE_LOGICAND_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_BITOR_EXPRESSION & src.data<2>()->flags));
+}
+
+static bool is_C99_logical_OR_expression(const parse_tree& src)
+{
+	return (	robust_token_is_string<2>(src.index_tokens[0].token,"||")
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
+//			&&	1==src.size<1>() && (PARSE_LOGICOR_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_LOGICAND_EXPRESSION & src.data<2>()->flags));
+}
+
+static bool is_CPP_logical_OR_expression(const parse_tree& src)
+{
+	return (	(robust_token_is_string<2>(src.index_tokens[0].token,"||") || robust_token_is_string<2>(src.index_tokens[0].token,"or"))
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
+//			&&	1==src.size<1>() && (PARSE_LOGICOR_EXPRESSION & src.data<1>()->flags)
+//			&&	1==src.size<2>() && (PARSE_LOGICAND_EXPRESSION & src.data<2>()->flags));
+}
+
+#ifndef NDEBUG
+static bool is_C99_conditional_operator_expression_strict(const parse_tree& src)
+{
+	return		robust_token_is_char<'?'>(src.index_tokens[0].token)
+			&&	robust_token_is_char<':'>(src.index_tokens[1].token)
+			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<2>()->flags)
+			&&	1==src.size<1>() && (PARSE_LOGICOR_EXPRESSION & src.data<2>()->flags)
+			&&	1==src.size<2>() && (PARSE_CONDITIONAL_EXPRESSION & src.data<2>()->flags);		
+}
+#endif
+
+static bool is_C99_conditional_operator_expression(const parse_tree& src)
+{
+	return		robust_token_is_char<'?'>(src.index_tokens[0].token)
+			&&	robust_token_is_char<':'>(src.index_tokens[1].token)
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+#endif
+			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<2>()->flags)
+			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<2>()->flags)
+			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
+}
+
+static bool is_C99_anonymous_specifier(const parse_tree& src,const char* const spec_name)
+{
+	if (	robust_token_is_string(src.index_tokens[0].token,spec_name)
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL==src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	src.empty<1>()
+			&&	1==src.size<2>() && is_naked_brace_pair(*src.data<2>()))
+		return true;
+	return false;
+}
+
+static bool is_C99_named_specifier(const parse_tree& src,const char* const spec_name)
+{
+	if (	robust_token_is_string(src.index_tokens[0].token,spec_name)
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL!=src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	src.empty<1>()
+			&&	src.empty<2>())
+		return true;
+	return false;
+}
+
+static bool is_C99_named_specifier_definition(const parse_tree& src,const char* const spec_name)
+{
+	if (	robust_token_is_string(src.index_tokens[0].token,spec_name)
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL!=src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	src.empty<1>()
+			&&	1==src.size<2>() && is_naked_brace_pair(*src.data<2>()))
+		return true;
+	return false;
+}
+
+static bool is_C99_named_specifier_definitionlike(const parse_tree& src)
+{
+	if (	NULL!=src.index_tokens[0].token.first
+#ifndef NDEBUG
+			&&	NULL!=src.index_tokens[0].src_filename
+#endif
+			&&	NULL!=src.index_tokens[1].token.first
+			&&	src.empty<0>()
+			&&	src.empty<1>()
+			&&	1==src.size<2>() && is_naked_brace_pair(*src.data<2>()))
+		return true;
+	return false;
+}
+
+static bool C99_looks_like_identifier(const parse_tree& x)
+{
+	if (!x.is_atomic()) return false;
+	if (PARSE_TYPE & x.flags) return false;
+	if (C99_echo_reserved_keyword(x.index_tokens[0].token.first,x.index_tokens[0].token.second)) return false;
+	return C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags;
+}
+
+static bool CPP_looks_like_identifier(const parse_tree& x)
+{
+	if (!x.is_atomic()) return false;
+	if (PARSE_TYPE & x.flags) return false;
+	if (CPP_echo_reserved_keyword(x.index_tokens[0].token.first,x.index_tokens[0].token.second)) return false;
+	return C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags;
+}
+
+//! \throw std::bad_alloc()
+static void make_target_postfix_arg(parse_tree& src,size_t& offset,const size_t i,const size_t j)
+{
+	parse_tree* tmp = (0==offset ? _new_buffer_nonNULL_throws<parse_tree>(1) :  _new_buffer<parse_tree>(1));
+	if (NULL==tmp)
+		{	// need that slack space now
+		src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
+		offset = 0;
+		tmp = _new_buffer_nonNULL_throws<parse_tree>(1);
+		}
+	src.c_array<0>()[j].OverwriteInto(*tmp);
+	src.c_array<0>()[i].fast_set_arg<2>(tmp);
+}
+
+//! \throw std::bad_alloc()
+static void C99_notice_struct_union_enum(parse_tree& src)
+{
+	assert(!src.empty<0>());
+	size_t i = 0;
+	size_t offset = 0;
+	while(i+offset<src.size<0>())
+		{
+		const char* const tmp2 = robust_token_is_string<4>(src.data<0>()[i],"enum") ? "enum"
+							: robust_token_is_string<6>(src.data<0>()[i],"struct") ? "struct"
+							: robust_token_is_string<5>(src.data<0>()[i],"union") ? "union" : 0;
+		if (tmp2)
+			{
+			if (1>=src.size<0>()-(i+offset))
+				{	// unterminated declaration
+					//! \test zcc/decl.C99/Error_enum_truncate1.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM(tmp2);
+				INC_INFORM(" specifier cut off by end of scope (");
+				INFORM(strcmp(tmp2,"enum") ? "C99 6.7.2.1p1)" : "C99 6.7.2.2p1)");
+				zcc_errors.inc_error();
+				// remove from parse
+				src.DestroyNAtAndRotateTo<0>(1,i,src.size<0>()-offset);
+				offset += 1;
+				continue;
+				};
+			if (is_naked_brace_pair(src.data<0>()[i+1]))
+				{	// anonymous: postfix arg {...}
+				make_target_postfix_arg(src,offset,i,i+1);
+				src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
+				offset += 1;
+				assert(is_C99_anonymous_specifier(src.data<0>()[i],tmp2));
+				// parser is having normal-form issues.  Shove named specifier definitions ahead of any const/volatile type qualifiers
+				size_t j = i;
+				while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
+					{
+					std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
+					--j;
+					};
+				continue;
+				};
+			if (!C99_looks_like_identifier(src.data<0>()[i+1]))
+				{	//! \test zcc/decl.C99/Error_enum_truncate2.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM(tmp2);
+				INC_INFORM(" neither specifier nor definition (");
+				INFORM(strcmp(tmp2,"enum") ? "C99 6.7.2.1p1)" : "C99 6.7.2.2p1)");
+				zcc_errors.inc_error();
+				// remove from parse
+				src.DestroyNAtAndRotateTo<0>(1,i,src.size<0>()-offset);
+				offset += 1;
+				continue;
+				};
+			if (2<src.size<0>()-(i+offset) && is_naked_brace_pair(src.data<0>()[i+2]))
+				{
+				make_target_postfix_arg(src,offset,i,i+2);
+				src.c_array<0>()[i].grab_index_token_from<1,0>(src.c_array<0>()[i+1]);
+				src.c_array<0>()[i].grab_index_token_location_from<1,0>(src.data<0>()[i+1]);
+				src.c_array<0>()[i+1].clear();
+				src.DestroyNAtAndRotateTo<0>(2,i+1,src.size<0>()-offset);
+				offset += 2;
+				assert(is_C99_named_specifier_definition(src.data<0>()[i],tmp2));
+				// parser is having normal-form issues.  Shove named specifier definitions ahead of any const/volatile type qualifiers
+				size_t j = i;
+				while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
+					{
+					std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
+					--j;
+					};
+				continue;
+				};
+			src.c_array<0>()[i].grab_index_token_from<1,0>(src.c_array<0>()[i+1]);
+			src.c_array<0>()[i].grab_index_token_location_from<1,0>(src.data<0>()[i+1]);
+			src.c_array<0>()[i+1].clear();
+			src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
+			offset += 1;
+			assert(is_C99_named_specifier(src.data<0>()[i],tmp2));
+			// parser is having normal-form issues.  Shove named specifiers ahead of any const/volatile type qualifiers
+			size_t j = i;
+			while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
+				{
+				std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
+				--j;
+				};
+			continue;
+			}
+		++i;
+		};
+	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
+	std::for_each(src.begin<0>(),src.end<0>(),conditional_action<bool (*)(const parse_tree&),void (*)(parse_tree&)>(is_nonempty_naked_pair,C99_notice_struct_union_enum));
+}
+
+//! \throw std::bad_alloc()
+static void CPP_notice_class_struct_union_enum(parse_tree& src)
+{
+	assert(!src.empty<0>());
+	size_t i = 0;
+	size_t offset = 0;
+	while(i+offset<src.size<0>())
+		{
+		const char* const tmp2 = robust_token_is_string<4>(src.data<0>()[i],"enum") ? "enum"
+							: robust_token_is_string<6>(src.data<0>()[i],"struct") ? "struct"
+							: robust_token_is_string<5>(src.data<0>()[i],"union") ? "union"
+							: robust_token_is_string<5>(src.data<0>()[i],"class") ? "class" : 0;
+		if (tmp2)
+			{
+			if (1>=src.size<0>()-(i+offset))
+				{	// unterminated declaration
+					//! \test zcc/decl.C99/Error_enum_truncate1.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM(tmp2);
+				INC_INFORM(" specifier cut off by end of scope (");
+				INFORM(strcmp(tmp2,"enum") ? "C++98 9p1)" : "C++98 7.2p1)");
+				zcc_errors.inc_error();
+				// remove from parse
+				src.DestroyNAtAndRotateTo<0>(1,i,src.size<0>()-offset);
+				offset += 1;
+				continue;
+				};
+			if (is_naked_brace_pair(src.data<0>()[i+1]))
+				{	// anonymous: postfix arg {...}
+				make_target_postfix_arg(src,offset,i,i+1);
+				src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
+				offset += 1;
+				assert(is_C99_anonymous_specifier(src.data<0>()[i],tmp2));
+				// parser is having normal-form issues.  Shove named specifiers ahead of any const/volatile type qualifiers
+				size_t j = i;
+				while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
+					{
+					std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
+					--j;
+					};
+				continue;
+				};
+			if (!CPP_looks_like_identifier(src.data<0>()[i+1]))
+				{	//! \test zcc/decl.C99/Error_enum_truncate2.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM(tmp2);
+				INC_INFORM(" neither specifier nor definition (");
+				INFORM(strcmp(tmp2,"enum") ? "C++98 9p1)" : "C++98 7.2p1)");
+				zcc_errors.inc_error();
+				// remove from parse
+				src.DestroyNAtAndRotateTo<0>(1,i,src.size<0>()-offset);
+				offset += 1;
+				continue;
+				};
+			if (2<src.size<0>()-(i+offset) && is_naked_brace_pair(src.data<0>()[i+2]))
+				{
+				make_target_postfix_arg(src,offset,i,i+2);
+				src.c_array<0>()[i].grab_index_token_from<1,0>(src.c_array<0>()[i+1]);
+				src.c_array<0>()[i].grab_index_token_location_from<1,0>(src.data<0>()[i+1]);
+				src.c_array<0>()[i+1].clear();
+				src.DestroyNAtAndRotateTo<0>(2,i+1,src.size<0>()-offset);
+				offset += 2;
+				assert(is_C99_named_specifier_definition(src.data<0>()[i],tmp2));
+				// parser is having normal-form issues.  Shove named specifier definitions ahead of any const/volatile type qualifiers
+				size_t j = i;
+				while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
+					{
+					std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
+					--j;
+					};
+				continue;
+				};
+			src.c_array<0>()[i].grab_index_token_from<1,0>(src.c_array<0>()[i+1]);
+			src.c_array<0>()[i].grab_index_token_location_from<1,0>(src.data<0>()[i+1]);
+			src.c_array<0>()[i+1].clear();
+			src.DestroyNAtAndRotateTo<0>(1,i+1,src.size<0>()-offset);
+			offset += 1;
+			assert(is_C99_named_specifier(src.data<0>()[i],tmp2));
+			// parser is having normal-form issues.  Shove named specifiers ahead of any const/volatile type qualifiers
+			size_t j = i;
+			while(0<j && (robust_token_is_string<5>(src.data<0>()[j-1],"const") || robust_token_is_string<8>(src.data<0>()[j-1],"volatile")))
+				{
+				std::swap(src.c_array<0>()[j],src.c_array<0>()[j-1]);
+				--j;
+				};
+			continue;
+			}
+		++i;
+		};
+	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
+	std::for_each(src.begin<0>(),src.end<0>(),conditional_action<bool (*)(const parse_tree&),void (*)(parse_tree&)>(is_nonempty_naked_pair,CPP_notice_class_struct_union_enum));
+}
+
+bool convert_to(umaxint& dest,const C_PPIntCore& src)
+{
+	assert(8==src.radix || 10==src.radix || 16==src.radix);
+	assert(NULL!=src.ptr && 0<src.digit_span);
+
+	const unsigned_var_int alt_radix(src.radix,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
+	unsigned_var_int strict_ub(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
+	const char* target = src.ptr;
+	size_t target_len = src.digit_span;
+
+	strict_ub.set_max();
+	strict_ub /= alt_radix;
+
+	// internally zero could be generated as a decimal rather than an octal integer literal
+	if (1<target_len)
+		{	// Duff's device
+		switch(src.radix)
+		{
+		case 16:	++target;	if (0== --target_len) return false;	// leading 0x
+		case 8:		++target;	if (0== --target_len) return false;	// leading 0
+		}
+		}
+
+	const char* const end = target+target_len;
+	dest.set_bitcount(VM_MAX_BIT_PLATFORM);
+	dest.clear();
+	dest += InterpretHexadecimalDigit(*target);
+	while(++target!=end)
+		{
+		if (dest>strict_ub) return false;
+		dest *= alt_radix;
+		dest += InterpretHexadecimalDigit(*target);
+		};
+	return true;
+}
+
+static const enum_def* is_noticed_enumerator(const parse_tree& x,const type_system& types)
+{
+	const enum_def* tmp = NULL;
+	if (x.is_atomic() && (C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags))
+		tmp = types.get_enum_def(x.type_code.base_type_index);
+	return tmp;
+}
+
+// forward-declare to handle recursion
+static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src SIG_CONST_TYPES);
+
+static bool _C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src SIG_CONST_TYPES)
+{
+	assert(C_TYPE::INTEGERLIKE!=src.type_code.base_type_index);
+
+	if (	virtual_machine::twos_complement==target_machine->C_signed_int_representation()
+		&&  !bool_options[boolopt::int_traps]
+		&&	is_C99_add_operator_expression<'-'>(src))
+		{
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
+		if (old.is_signed)
+			{
+			const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
+			assert(old.bitcount>=lhs.bitcount);
+			if (lhs.is_signed)
+				{
+				umaxint lhs_int;
+				umaxint rhs_int;
+				if (	C99_intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES)
+					&&	C99_intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
+					{
+					const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
+					assert(old.bitcount>=rhs.bitcount);
+					assert(old.bitcount>rhs.bitcount || rhs.is_signed);
+					if (lhs_int.test(lhs.bitcount-1) && (!rhs.is_signed || !rhs_int.test(rhs.bitcount-1)))
+						{	// lhs -, rhs +: could land exactly on INT_MIN/LONG_MIN/LLONG_MIN
+						target_machine->signed_additive_inverse(lhs_int,lhs.machine_type);
+						lhs_int += rhs_int;
+						lhs_int -= 1;
+						if (lhs_int==target_machine->signed_max(old.machine_type))
+							{
+							lhs_int += 1;
+							dest = lhs_int;
+							return true;	// signed additive inverse on twos-complement nontrapping machines has INT_MIN/LONG_MIN/LLONG_MIN as a fixed point
+							}
+						}
+					}
+				}
+			}
+		}
+
+	if (!src.is_atomic() || !(PARSE_PRIMARY_EXPRESSION & src.flags))
+		return false;
+
+	if (C_TESTFLAG_CHAR_LITERAL & src.index_tokens[0].flags)
+		{
+		dest = EvalCharacterLiteral(src.index_tokens[0].token.first,src.index_tokens[0].token.second);
+		dest.set_bitcount(VM_MAX_BIT_PLATFORM);
+		return true;
+		}	
+
+	// creative interpretation: enumerators as integer-like literals
+	if (is_noticed_enumerator(src,types))
+		{
+		const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.index_tokens[0].token.first);
+		assert(tmp2);
+		dest = tmp2->second.first.third;
+		return true;
+		}
+		
+	if (!(C_TESTFLAG_INTEGER & src.index_tokens[0].flags)) return false;
+	C_PPIntCore tmp;
+	ZAIMONI_PASSTHROUGH_ASSERT(C_PPIntCore::is(src.index_tokens[0].token.first,src.index_tokens[0].token.second,tmp));
+	ZAIMONI_PASSTHROUGH_ASSERT(convert_to(dest,tmp));
+	return true;
+}
+
+static bool _CPP_intlike_literal_to_VM(umaxint& dest, const parse_tree& src)
+{
+	//! \todo: similar code for handling LLONG_MIN as above.  Need that only for zcc; can't test in preprocessor as the true reserved word won't make it this far.
+	if (!src.is_atomic()) return false;
+	// intercept true, false
+	if 		(token_is_string<4>(src.index_tokens[0].token,"true"))
+		{
+		dest.set_bitcount(VM_MAX_BIT_PLATFORM);
+		dest = 1;
+		return true;
+		}
+	else if (token_is_string<5>(src.index_tokens[0].token,"false"))
+		{
+		dest.set_bitcount(VM_MAX_BIT_PLATFORM);
+		dest.clear();
+		return true;
+		};
+	return false;
+}
+
+// return value: literal to parse, whether additive inverse applies
+static POD_pair<const parse_tree*,bool>
+_find_intlike_literal(const parse_tree* src SIG_CONST_TYPES)
+{
+	assert(NULL!=src);
+	POD_pair<const parse_tree*,bool> ret = {src,false};
+	while(converts_to_integer(ret.first->type_code ARG_TYPES))
+		{
+		if 		(is_C99_unary_operator_expression<'-'>(*ret.first))
+			{
+			ret.second = !ret.second;
+			ret.first = ret.first->data<2>();
+			assert(NULL!=ret.first);
+			}
+		else if (is_C99_unary_operator_expression<'+'>(*ret.first))
+			{
+			ret.first = ret.first->data<2>();
+			assert(NULL!=ret.first);
+			}
+		else
+			break;
+		};
+	return ret;
+}
+
+// use this typedef to cope with signature varying by build
+typedef bool (intlike_literal_to_VM_func)(umaxint& dest, const parse_tree& src SIG_CONST_TYPES);
+
+static bool C99_intlike_literal_to_VM(umaxint& dest, const parse_tree& src SIG_CONST_TYPES)
+{
+	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src ARG_TYPES);
+
+	if (C_TYPE::INTEGERLIKE==actual.first->type_code.base_type_index)
+		return false;	
+
+	if (!_C99_intlike_literal_to_VM(dest,*actual.first ARG_TYPES)) return false;
+	if (actual.second)
+		{
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
+		if (old.is_signed)
+			target_machine->signed_additive_inverse(dest,old.machine_type);
+		else
+			target_machine->unsigned_additive_inverse(dest,old.machine_type);
+		};
+	return true;
+}
+
+static bool CPP_intlike_literal_to_VM(umaxint& dest, const parse_tree& src SIG_CONST_TYPES)
+{
+	const POD_pair<const parse_tree*,bool> actual = _find_intlike_literal(&src ARG_TYPES);
+
+	if (!_CPP_intlike_literal_to_VM(dest,*actual.first))
+		{
+		if (C_TYPE::INTEGERLIKE==actual.first->type_code.base_type_index)
+			return false;	
+
+		if (!_C99_intlike_literal_to_VM(dest,*actual.first ARG_TYPES)) return false;
+		};
+	if (actual.second)
+		{
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
+		if (old.is_signed)
+			target_machine->signed_additive_inverse(dest,old.machine_type);
+		else
+			target_machine->unsigned_additive_inverse(dest,old.machine_type);
+		};
+	return true;
+}
+
+/** decides whether the given entry is a null pointer constant
+ * \return 1 : yes, null pointer constant 
+ * \return 0 : no, not null pointer constant 
+ * \return -1 : can't decide quickly whether this is a null 
+ *         pointer constant
+ */
+static int is_null_pointer_constant(const parse_tree& src,intlike_literal_to_VM_func& intlike_literal_to_VM SIG_CONST_TYPES)
+{
+	if (!converts_to_integerlike(src.type_code ARG_TYPES)) return 0;
+	umaxint tmp;
+	if (intlike_literal_to_VM(tmp,src ARG_TYPES)) return tmp==0;
+	return -1;
+}
+
+static void _label_one_literal(parse_tree& src,const type_system& types)
+{
+	assert(src.is_atomic());
+	if ((C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_STRING_LITERAL | C_TESTFLAG_PP_NUMERAL) & src.index_tokens[0].flags)
+		{
+		src.flags |= (PARSE_PRIMARY_EXPRESSION | parse_tree::CONSTANT_EXPRESSION);
+		if (C_TESTFLAG_STRING_LITERAL==src.index_tokens[0].flags)
+			{
+			src.type_code.set_type(C_TYPE::CHAR);
+			src.type_code.make_C_array(LengthOfCStringLiteral(src.index_tokens[0].token.first,src.index_tokens[0].token.second));
+			return;
+			}
+		else if (C_TESTFLAG_CHAR_LITERAL==src.index_tokens[0].flags)
+			{	// C99 6.4.4.4p10: the type of a character literal is int
+				// C++0X 2.13.4p1: the type of a single character literal is char 
+				// but the type of a multiple-character literal is int
+				// unfortunately, we don't have the language here.  Go with
+				// C++ rules, and patch up C elsewhere
+			src.type_code.set_type(LengthOfCCharLiteral(src.index_tokens[0].token.first,src.index_tokens[0].token.second) ? C_TYPE::CHAR : C_TYPE::INT);
+			return;
+			};
+		assert(C_TESTFLAG_PP_NUMERAL & src.index_tokens[0].flags);
+		C_REALITY_CHECK_PP_NUMERAL_FLAGS(src.index_tokens[0].flags);
+		if (C_TESTFLAG_INTEGER & src.index_tokens[0].flags)
+			{
+			src.type_code.set_type(C_TYPE::INTEGERLIKE);
+			C_PPIntCore parse_tmp;
+			ZAIMONI_PASSTHROUGH_ASSERT(C_PPIntCore::is(src.index_tokens[0].token.first,src.index_tokens[0].token.second,parse_tmp));
+			umaxint tmp;
+			const unsigned char type_hint = parse_tmp.hinted_type;
+			const bool no_signed = 1==type_hint%2;
+			const bool no_unsigned = !no_signed && 10==parse_tmp.radix;
+			if (convert_to(tmp,parse_tmp))
+				{	// failover to IntegerLike if won't convert
+				size_t i = 0;
+				do	switch(types.int_priority[i])
+					{
+					case C_TYPE::INT:	{
+										if (no_signed || C_PPIntCore::L<=type_hint) continue;
+										if (tmp>target_machine->signed_max<virtual_machine::std_int_int>()) continue;
+										src.type_code.base_type_index = C_TYPE::INT;
+										return;
+										}
+					case C_TYPE::UINT:	{
+										if (no_unsigned || C_PPIntCore::L<=type_hint) continue;
+										if (tmp>target_machine->unsigned_max<virtual_machine::std_int_int>()) continue;
+										src.type_code.base_type_index = C_TYPE::UINT;
+										return;
+										}
+					case C_TYPE::LONG:	{
+										if (no_signed || C_PPIntCore::LL<=type_hint) continue;
+										if (tmp>target_machine->signed_max<virtual_machine::std_int_long>()) continue;
+										src.type_code.base_type_index = C_TYPE::LONG;
+										return;
+										}
+					case C_TYPE::ULONG:	{
+										if (no_unsigned || C_PPIntCore::LL<=type_hint) continue;
+										if (tmp>target_machine->unsigned_max<virtual_machine::std_int_long>()) continue;
+										src.type_code.base_type_index = C_TYPE::ULONG;
+										return;
+										}
+					case C_TYPE::LLONG:	{
+										if (no_signed) continue;
+										if (tmp>target_machine->signed_max<virtual_machine::std_int_long_long>()) continue;
+										src.type_code.base_type_index = C_TYPE::LLONG;
+										return;
+										}
+					case C_TYPE::ULLONG:{
+										if (no_unsigned) continue;
+										if (tmp>target_machine->unsigned_max<virtual_machine::std_int_long_long>()) continue;
+										src.type_code.base_type_index = C_TYPE::ULLONG;
+										return;
+										}
+					}
+				while(types.int_priority_size > ++i);
+				};
+			assert(C_TYPE::INTEGERLIKE==src.type_code.base_type_index);
+			// integer literal has no useful type to represent it
+			//! \test if.C99/Error_control22.hpp, if.C99/Error_control22.h
+			//! \test if.C99/Error_control23.hpp, if.C99/Error_control23.h
+			src.flags |= parse_tree::INVALID;
+			message_header(src.index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INC_INFORM(src);
+			INC_INFORM(" cannot be represented as ");
+			INC_INFORM(no_unsigned ? "signed long long" : "unsigned long long");
+			INFORM(" (C99 6.4.4.1p5/C++0x 2.13.1p3)");
+			zcc_errors.inc_error();
+			}
+		else{
+			//! \todo --do-what-i-mean should check for floating-point numerals that convert exactly to integers
+			src.type_code.set_type(	(C_TESTFLAG_L & src.index_tokens[0].flags) ? C_TYPE::LDOUBLE : 
+									(C_TESTFLAG_F & src.index_tokens[0].flags) ? C_TYPE::FLOAT : C_TYPE::DOUBLE);
+			}
+		}
+}
+
+void C99_literal_is_legal(const char* const x,const size_t x_len,const lex_flags flags,const char* src_filename,size_t lineno,const type_system& types)
+{
+	parse_tree tmp;
+	tmp.clear();
+	tmp.index_tokens[0].token.first = x;
+	tmp.index_tokens[0].token.second = x_len;
+	tmp.index_tokens[0].flags = flags;
+	tmp.index_tokens[0].src_filename = src_filename;
+	tmp.index_tokens[0].logical_line.first = lineno;
+	_label_one_literal(tmp,types);
+}
+
+// C and C++ agree that literals are constant primary expressions
+// note that on some huge-char platforms not all strings can be concatenated safely in C
+// we almost certainly have have memory problems if there are non-concatenated strings around
+// a psuedo-concatenated string literal has string literals for both of its indexes
+static void _label_literals(parse_tree& src,const type_system& types)
+{
+	std::pair<size_t,size_t> str_span(SIZE_MAX,SIZE_MAX);
+	size_t str_count = 0;
+	size_t i = src.size<0>();
+	while(0<i)
+		{
+		if (!src.data<0>()[--i].is_atomic()) continue;
+		_label_one_literal(src.c_array<0>()[i],types);
+		if (C_TESTFLAG_STRING_LITERAL==src.data<0>()[i].index_tokens[0].flags)
+			{
+			if (SIZE_MAX==str_span.first) str_span.second = i;
+			str_span.first = i;
+			++str_count;
+			}
+		};
+	while((assert(str_count<=(str_span.second-str_span.first)+1),2<=str_count) && (2<str_count || 1==str_span.second-str_span.first))
+		{
+		bool want_first_slideup = false;
+		bool want_second_slidedown = false;
+		bool RAMfail = false;
+		if (C_TESTFLAG_STRING_LITERAL==src.data<0>()[str_span.first+1].index_tokens[0].flags)
+			{
+			if (src.size<0>()<=str_span.second+2 || C_TESTFLAG_STRING_LITERAL!=src.data<0>()[str_span.first+2].index_tokens[0].flags)
+				{	// psuedo-concatenate
+					// that this is still a constant primary expression, as we are just pretending that the string concatenation went through
+				src.c_array<0>()[str_span.first].grab_index_token_from<1,0>(src.c_array<0>()[str_span.first+1]);
+				src.DeleteIdx<0>(str_span.first+1);
+				if (1>=(str_count -= 2)) break;
+				str_span.first += 2;
+				want_first_slideup = true;
+				}
+			else{
+				// more than two strings to psuedo-concatenate
+				POD_pair<size_t,size_t> scan = {str_span.first,str_span.first+2};
+				while(src.size<0>()>scan.second+1 && C_TESTFLAG_STRING_LITERAL==src.data<0>()[scan.second+1].index_tokens[0].flags) ++scan.second;
+				if (parse_tree::collapse_matched_pair(src,scan))
+					src.c_array<0>()[scan.first].flags |= (PARSE_PRIMARY_EXPRESSION | parse_tree::CONSTANT_EXPRESSION);
+				else
+					RAMfail = true;
+				}
+			}
+		else{
+			want_first_slideup = true;
+			++str_span.first;
+			--str_count;
+			};
+		if (C_TESTFLAG_STRING_LITERAL==src.data<0>()[str_span.second-1].index_tokens[0].flags)
+			{
+			if (2<=str_span.second || C_TESTFLAG_STRING_LITERAL!=src.data<0>()[str_span.second-2].index_tokens[0].flags)
+				{	// psuedo-concatenate
+					// this is still a constant primary expression, as we are just pretending that the string concatenation went through
+				src.c_array<0>()[str_span.second-1].grab_index_token_from<1,0>(src.c_array<0>()[str_span.second]);
+				src.DeleteIdx<0>(str_span.second);
+				if (1>=(str_count -= 2)) break;
+				str_span.second -= 2;
+				want_second_slidedown = true;
+				}
+			else{	// more than two strings to psuedo-concatenate
+				POD_pair<size_t,size_t> scan = {str_span.second-2,str_span.second};
+				while(0<scan.first && C_TESTFLAG_STRING_LITERAL==src.data<0>()[scan.first-1].index_tokens[0].flags) --scan.first;
+				if (parse_tree::collapse_matched_pair(src,scan))
+					src.c_array<0>()[scan.first].flags |= (PARSE_PRIMARY_EXPRESSION | parse_tree::CONSTANT_EXPRESSION);
+					// note: as current item was already typed properly, do not need to update
+				else
+					RAMfail = true;
+				}
+			}
+		else{
+			if (1>=(--str_count)) break;
+			want_second_slidedown = true;
+			--str_span.second;
+			}
+
+		if (want_first_slideup)
+			{
+			while(C_TESTFLAG_STRING_LITERAL!=src.data<0>()[str_span.first].index_tokens[0].flags)
+				{
+				++str_span.first;
+				assert(str_span.second > str_span.first);
+				};
+			RAMfail = false;
+			}
+		if (want_second_slidedown)
+			{
+			while(C_TESTFLAG_STRING_LITERAL!=src.data<0>()[str_span.second].index_tokens[0].flags)
+				{
+				--str_span.second;
+				assert(str_span.first < str_span.second);
+				};
+			RAMfail = false;
+			}		
+		if (RAMfail) throw std::bad_alloc();	// couldn't do anything at all: stalled
+		}
+}
+
+// returns true if and only if no errors
+static bool _this_vaguely_where_it_could_be_cplusplus(const parse_tree& src)
+{
+	const size_t starting_errors = zcc_errors.err_count();
+	if (robust_token_is_string<4>(src.index_tokens[0].token,"this"))
+		{
+		message_header(src.index_tokens[0]);
+		INC_INFORM(ERR_STR);
+		INFORM("keyword this is allowed only within a non-static member function body or a constructor memory initializer (C++98 5.1p3)");
+		zcc_errors.inc_error();
+		};
+
+	size_t j = STATIC_SIZE(src.args);
+	do	{
+		if (0== --j && NULL!=src.index_tokens[0].token.first && NULL!=src.index_tokens[1].token.first)
+			{
+			if (token_is_char<'('>(src.index_tokens[0].token) && token_is_char<')'>(src.index_tokens[1].token)) break;	// need to parse to rule out constructor memory initializer
+			if (token_is_char<'{'>(src.index_tokens[0].token) && token_is_char<'}'>(src.index_tokens[1].token)) break;	// need to parse to rule out non-static member function
+			}
+		size_t i = src.size(j);
+		while(0<i)
+			{
+			if (robust_token_is_string<4>(src.data(j)[--i].index_tokens[0].token,"this"))
+				{
+				message_header(src.data(j)[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("keyword this is allowed only within a non-static member function body or a constructor memory initializer (C++98 5.1p3)");
+				zcc_errors.inc_error();
+				};
+			}
+		}
+	while(0<j);
+	return starting_errors==zcc_errors.err_count();
+}
+
+// this handles: ( ), [ ], { }
+// the content of ( ), [ ], { } fills the zeroth argument array
+// C++ *sometimes* wants to match < > as well, but its approaches are...painful.  Do that elsewhere
+// returns true if successful
+static bool _match_pairs(parse_tree& src)
+{
+	assert(!src.empty<0>());
+	POD_pair<size_t,size_t> depth_parens = balanced_character_count<'(',')'>(src.data<0>(),src.size<0>());	// pre-scan
+	POD_pair<size_t,size_t> depth_brackets = balanced_character_count<'[',']'>(src.data<0>(),src.size<0>());	// pre-scan
+	POD_pair<size_t,size_t> depth_braces = balanced_character_count<'{','}'>(src.data<0>(),src.size<0>());	// pre-scan
+	assert(depth_parens.first==depth_parens.second);
+	assert(depth_brackets.first==depth_brackets.second);
+	assert(depth_braces.first==depth_braces.second);
+	if (0==depth_parens.first && 0==depth_brackets.first && 0==depth_braces.first) return true;
+	autovalarray_ptr_throws<size_t> paren_stack(depth_parens.first);
+	autovalarray_ptr_throws<size_t> bracket_stack(depth_brackets.first);
+	autovalarray_ptr_throws<size_t> brace_stack(depth_braces.first);
+
+	const size_t starting_errors = zcc_errors.err_count();
+	size_t paren_idx = 0;
+	size_t bracket_idx = 0;
+	size_t brace_idx = 0;
+	size_t i = 0;
+	//! \todo optimize this loop
+	do	{
+		if (NULL!=src.data<0>()[i].index_tokens[1].token.first) continue;
+		if 		(token_is_char<')'>(src.data<0>()[i].index_tokens[0].token))
+			{
+			assert(0<paren_idx);
+			assert(0==bracket_idx || bracket_stack[bracket_idx-1]<paren_stack[paren_idx-1]);
+			assert(0==brace_idx || brace_stack[brace_idx-1]<paren_stack[paren_idx-1]);
+			const POD_pair<size_t,size_t> target = {paren_stack[--paren_idx],i};
+			if (!parse_tree::collapse_matched_pair(src,target)) throw std::bad_alloc();
+			i = paren_stack[paren_idx];
+			// do not suppress inner parentheses here, this only works for known expressions
+			if (0==paren_idx && 1<src.size<0>()-i)
+				{
+				depth_parens = balanced_character_count<'(',')'>(src.data<0>()+i+1,src.size<0>()-(i+1));
+				assert(depth_parens.first==depth_parens.second);
+				if (0==depth_parens.first && 0==depth_brackets.first && 0==depth_braces.first) return starting_errors==zcc_errors.err_count();
+				paren_stack.Shrink(depth_parens.first);
+				}
+			}
+		else if (token_is_char<']'>(src.data<0>()[i].index_tokens[0].token))
+			{
+			assert(0<bracket_idx);
+			assert(0==paren_idx || paren_stack[paren_idx-1]<bracket_stack[bracket_idx-1]);
+			assert(0==brace_idx || brace_stack[brace_idx-1]<bracket_stack[bracket_idx-1]);
+			const POD_pair<size_t,size_t> target = {bracket_stack[--bracket_idx],i};
+			if (!parse_tree::collapse_matched_pair(src,target)) throw std::bad_alloc();
+			i = bracket_stack[bracket_idx];
+			// do not suppress inner parentheses here, this only works for known expressions
+			if (0==bracket_idx && 1<src.size<0>()-i)
+				{
+				depth_brackets = balanced_character_count<'[',']'>(src.data<0>()+i+1,src.size<0>()-(i+1));
+				assert(depth_brackets.first==depth_brackets.second);
+				if (0==depth_parens.first && 0==depth_brackets.first && 0==depth_braces.first) return starting_errors==zcc_errors.err_count();
+				bracket_stack.Shrink(depth_brackets.first);
+				}
+			}
+		else if (token_is_char<'}'>(src.data<0>()[i].index_tokens[0].token))
+			{
+			assert(0<brace_idx);
+			assert(0==paren_idx || paren_stack[paren_idx-1]<brace_stack[brace_idx-1]);
+			assert(0==bracket_idx || bracket_stack[bracket_idx-1]<brace_stack[brace_idx-1]);
+			const POD_pair<size_t,size_t> target = {brace_stack[--brace_idx],i};
+			if (!parse_tree::collapse_matched_pair(src,target)) throw std::bad_alloc();
+			i = brace_stack[brace_idx];
+			if (0==brace_idx && 1<src.size<0>()-i)
+				{
+				depth_braces = balanced_character_count<'{','}'>(src.data<0>()+i+1,src.size<0>()-(i+1));
+				assert(depth_braces.first==depth_braces.second);
+				if (0==depth_parens.first && 0==depth_brackets.first && 0==depth_braces.first) return starting_errors==zcc_errors.err_count();
+				brace_stack.Shrink(depth_braces.first);
+				}
+			}
+		else if (token_is_char<'('>(src.data<0>()[i].index_tokens[0].token))
+			{
+			assert(paren_stack.size()>paren_idx);
+			paren_stack[paren_idx++] = i;
+			}
+		else if (token_is_char<'['>(src.data<0>()[i].index_tokens[0].token))
+			{
+			assert(bracket_stack.size()>bracket_idx);
+			bracket_stack[bracket_idx++] = i;
+			}
+		else if (token_is_char<'{'>(src.data<0>()[i].index_tokens[0].token))
+			{
+			assert(brace_stack.size()>brace_idx);
+			brace_stack[brace_idx++] = i;
+			}
+		// introduces sequence points; this causes errors if caught in brackets or parentheses
+		// cannot test within preprocessor expression (trigger is intercepted earlier)
+		else if (token_is_char<';'>(src.data<0>()[i].index_tokens[0].token))
+			{
+			if (0<paren_idx || 0<bracket_idx)
+				{
+				const size_t nearest_break = (paren_idx<bracket_idx) ? bracket_idx : paren_idx;
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM(" ; breaks intended balancing of ");
+				INFORM(src.data<0>()[nearest_break].index_tokens[0].token.first[0]);
+				zcc_errors.inc_error();
+				}
+			};
+		}
+	while(src.size<0>() > ++i);
+	return starting_errors==zcc_errors.err_count();
+}
+
+static bool C99_literal_converts_to_integer(const parse_tree& src)
+{
+	if (!src.is_atomic()) return false;
+	return ((C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_INTEGER) & src.index_tokens[0].flags);
+	//! \todo --do-what-i-mean should try to identify floats that are really integers
+}
+
+static bool CPP_literal_converts_to_integer(const parse_tree& src)
+{
+	if (!src.is_atomic()) return false;
+	if (token_is_string<4>(src.index_tokens[0].token,"true") || token_is_string<5>(src.index_tokens[0].token,"false")) return true;
+	return ((C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_INTEGER) & src.index_tokens[0].flags);
+	//! \todo --do-what-i-mean should try to identify floats that are really integers
+}
+
+//! the returned parse_tree struct has no content; safe to use OvewriteInto on
+//! \throw std::bad_alloc()
+static zaimoni::Loki::CheckReturnDisallow<NULL,parse_tree*>::value_type repurpose_inner_parentheses(parse_tree& src)
+{
+	if (1==src.size<0>() && is_naked_parentheses_pair(*src.data<0>()))
+		{
+		parse_tree::arglist_array tmp = src.c_array<0>()->args[0];
+#ifdef ZAIMONI_FORCE_ISO
+		src.c_array<0>()->args[0].first = NULL;				 
+#else
+		src.c_array<0>()->args[0] = NULL;
+#endif
+		src.c_array<0>()->destroy();
+		parse_tree* const tmp2 = src.c_array<0>();
+		src.args[0] = tmp;
+		return tmp2;
+		};
+	return _new_buffer_nonNULL_throws<parse_tree>(1);
+}
+
+static void cancel_inner_parentheses(parse_tree& src)
+{
+	while(1==src.size<0>() && is_naked_parentheses_pair(*src.data<0>()))
+		{
+		parse_tree::arglist_array tmp = src.c_array<0>()->args[0];
+#ifdef ZAIMONI_FORCE_ISO
+		src.c_array<0>()->args[0].first = NULL;				 
+#else
+		src.c_array<0>()->args[0] = NULL;
+#endif
+		src.c_array<0>()->destroy();
+		free(src.c_array<0>());
+		src.args[0] = tmp;
+		}
+}
+
+static void cancel_outermost_parentheses(parse_tree& src)
+{
+	while(1==src.size<0>() && is_naked_parentheses_pair(src))
+		src.eval_to_arg<0>(0);
+}
+
+/*! 
+ * determines whether a context-driven primary expression is obviously one
+ * 
+ * \param src target to inspect
+ * 
+ * \return true iff ( ... ) expression was recognized
+ * \throw std::bad_alloc only if 1==src.size<0>() and src.type_code.pointer_power<src.data<0>()->type_code.pointer_power
+ */
+static bool inspect_potential_paren_primary_expression(parse_tree& src)
+{
+	if (!(PARSE_OBVIOUS & src.flags) && is_naked_parentheses_pair(src))
+		{	// we're a naked parentheses pair
+		cancel_inner_parentheses(src);
+		const size_t content_length = src.size<0>();
+		if (0==content_length)
+			{	// ahem...invalid
+				// untestable as a preprocessor expression, balanced-kill gets this first
+			src.flags &= parse_tree::RESERVED_MASK;	// just in case
+			src.flags |= (PARSE_PRIMARY_EXPRESSION | parse_tree::CONSTANT_EXPRESSION);
+			simple_error(src," cannot be an expression (C99 6.5.2p1/C++98 5.2p1)");
+			return true;
+			};
+		if (1==content_length)
+			{
+			if (PARSE_PRIMARY_EXPRESSION & src.data<0>()->flags)
+				{	// primary expression that got parenthesized
+				src.eval_to_arg<0>(0);
+				return true;
+				}
+			else if (PARSE_EXPRESSION & src.data<0>()->flags)
+				{	// normal expression that got parenthesized
+				value_copy(src.type_code,src.data<0>()->type_code);
+				src.flags &= parse_tree::RESERVED_MASK;	// just in case
+				src.flags |= PARSE_PRIMARY_EXPRESSION;
+				src.flags |= (PARSE_PAREN_PRIMARY_PASSTHROUGH & src.data<0>()->flags);
+				return true;
+				}
+			else if (PARSE_TYPE & src.data<0>()->flags)
+				{	// abuse: handle parenthesized type-specifiers here
+				value_copy(src.type_code,src.data<0>()->type_code);
+				src.flags &= parse_tree::RESERVED_MASK;	// just in case
+				src.flags |= (PARSE_TYPE & src.data<0>()->flags);
+				return false;	// not an expression 
+				}
+			};
+		}
+	return false;
+}
+
+static bool suppress_naked_brackets_and_braces(parse_tree& src,const char* const err_prefix,size_t err_len)
+{
+	if (!(PARSE_OBVIOUS & src.flags) && src.empty<1>() && src.empty<2>())
+		{
+		// top-level [ ] dies regardless of contents
+		// not testable with preprocessor expression (not sure whether reachable with full source code)
+		if 		(robust_token_is_char<'['>(src.index_tokens[0].token))
+			{
+			if (robust_token_is_char<']'>(src.index_tokens[1].token))
+				{
+				src.flags &= parse_tree::RESERVED_MASK;	// just in case
+				src.flags |= parse_tree::INVALID;
+				message_header(src.index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM(err_prefix,err_len);
+				INFORM(" [ ... ] has no context to interpret (C99 6.5.2p1/C++98 5.2p1)");
+				zcc_errors.inc_error();
+				return true;
+				}
+			}
+		// top-level { } dies regardless of contents
+		// not testable with preprocessor expression
+		else if	(robust_token_is_char<'{'>(src.index_tokens[0].token))
+			{
+			if (robust_token_is_char<'}'>(src.index_tokens[1].token))
+				{
+				src.flags &= parse_tree::RESERVED_MASK;	// just in case
+				src.flags |= parse_tree::INVALID;
+				message_header(src.index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM(err_prefix,err_len);
+				INFORM(" { ... } has no context to interpret (C99 6.5.2p1/C++98 5.2p1)");
+				zcc_errors.inc_error();
+				return true;
+				}
+			}
+		}
+	return false;
+}
+
+// \throw std::bad_alloc only if src.data<0>()[i-1].type_code.pointer_power<src.data<0>()[i-1].data<0>()->type_code.pointer_power
+static bool terse_locate_array_deref(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(src.data<0>()[i].empty<1>());
+	assert(src.data<0>()[i].empty<2>());
+	assert(src.data<0>()[i].index_tokens[0].token.first);
+	assert(src.data<0>()[i].index_tokens[1].token.first);
+
+	if (	!token_is_char<'['>(src.data<0>()[i].index_tokens[0].token)
+		|| 	!token_is_char<']'>(src.data<0>()[i].index_tokens[1].token))
+		return false;
+
+	assert(1<=i);
+	if (   1==src.data<0>()[i].size<0>()
+		&& (PARSE_EXPRESSION & src.data<0>()[i].data<0>()->flags))
+		{	// array dereference operator; put preceding argument src.data<0>()[i-1] in src.data<0>()[i].data<1>()[0]
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
+		if (PARSE_POSTFIX_EXPRESSION & src.data<0>()[i-1].flags)
+			{
+			parse_tree* const tmp = repurpose_inner_parentheses(src.c_array<0>()[i]);	// RAM conservation
+			src.c_array<0>()[i-1].OverwriteInto(*tmp);
+			src.c_array<0>()[i].fast_set_arg<1>(tmp);
+			src.c_array<0>()[i].core_flag_update();
+			src.c_array<0>()[i].flags |= PARSE_STRICT_POSTFIX_EXPRESSION;
+			src.DeleteIdx<0>(--i);
+			assert(is_array_deref_strict(src.data<0>()[i]));
+			cancel_outermost_parentheses(src.c_array<0>()[i].c_array<1>()[0]);
+			cancel_outermost_parentheses(src.c_array<0>()[i].c_array<0>()[0]);
+			src.type_code.set_type(C_TYPE::NOT_VOID);
+			src.c_array<0>()[i].type_code.q_vector.front() |= type_spec::lvalue;
+			assert(is_array_deref(src.data<0>()[i]));
+			return true;
+			};
+		if (!(parse_tree::INVALID & src.flags))
+			{	//! \test default/Error_if_control3.hpp, default/Error_if_control3.h
+				//! \test default/Error_if_control4.hpp, default/Error_if_control4.h
+				//! \test default/Error_if_control5.hpp, default/Error_if_control5.h
+				//! \test default/Error_if_control6.hpp, default/Error_if_control6.h
+				//! \test default/Error_if_control7.hpp, default/Error_if_control7.h
+				//! \test default/Error_if_control8.hpp, default/Error_if_control8.h
+				//! \test default/Error_if_control9.hpp, default/Error_if_control9.h
+				//! \test default/Error_if_control10.hpp, default/Error_if_control10.h
+				//! \test default/Error_if_control11.hpp, default/Error_if_control11.h
+				//! \test default/Error_if_control12.hpp, default/Error_if_control12.h
+				//! \test default/Error_if_control13.hpp, default/Error_if_control13.h
+				//! \test default/Error_if_control14.hpp, default/Error_if_control14.h
+				//! \test default/Error_if_control15.hpp, default/Error_if_control15.h
+				//! \test default/Error_if_control16.hpp, default/Error_if_control16.h
+				//! \test default/Error_if_control17.hpp, default/Error_if_control17.h
+				//! \test default/Error_if_control18.hpp, default/Error_if_control18.h
+				//! \test default/Error_if_control19.hpp, default/Error_if_control19.h
+				//! \test default/Error_if_control20.hpp, default/Error_if_control20.h
+				//! \test default/Error_if_control21.hpp, default/Error_if_control21.h
+				//! \test default/Error_if_control22.hpp, default/Error_if_control22.h
+				//! \test default/Error_if_control23.hpp, default/Error_if_control23.h
+			src.flags |= parse_tree::INVALID;
+			src.c_array<0>()[i].flags |= PARSE_STRICT_POSTFIX_EXPRESSION;
+			src.type_code.set_type(0);
+			message_header(src.index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INC_INFORM("array dereference ");
+			INC_INFORM(src);
+			INC_INFORM(" has invalid postfix expression ");
+			INC_INFORM(src.data<0>()[i-1]);
+			INFORM(" to dereference (C99 6.5.2.1p1)");
+			zcc_errors.inc_error();
+			};
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static void C_array_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	if (parse_tree::INVALID & src.flags) return;	// cannot optimize to valid
+
+	const size_t effective_pointer_power_prefix = src.data<1>()->type_code.pointer_power;
+	const size_t effective_pointer_power_infix = src.data<0>()->type_code.pointer_power;
+	if (0<effective_pointer_power_prefix)
+		{
+		if (0<effective_pointer_power_infix)
+			{	// uses extension to test in preprocessor
+				//! \test default/Error_if_control1.h
+			simple_error(src,"array dereference of pointer by pointer (C99 6.5.2.1p1; C++98 5.2.1p1,13.3.1.2p1)");
+			return;
+			}
+		else if (converts_to_integerlike(src.data<0>()->type_code.base_type_index ARG_TYPES))
+			ZAIMONI_PASSTHROUGH_ASSERT(src.data<1>()->type_code.dereference(src.type_code));
+		else{	// not testable from preprocessor yet (need floating-point literals as extension)
+			src.flags |= parse_tree::INVALID;
+			message_header(src.index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INC_INFORM("array dereference of pointer by ");
+			INFORM(types.name(src.data<0>()->type_code.base_type_index));
+			INFORM(" (C99 6.5.2.1p1; C++98 5.2.1p1,13.5.5p1)");
+			zcc_errors.inc_error();
+			return;
+			}
+		}
+	else if (0<effective_pointer_power_infix)
+		{
+		if (converts_to_integerlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
+			ZAIMONI_PASSTHROUGH_ASSERT(src.data<0>()->type_code.dereference(src.type_code));
+		else{	// autofails in C
+				// not testable from preprocessor yet (need floating-point literals, would be extension regardless)
+			src.flags |= parse_tree::INVALID;
+			message_header(src.index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INC_INFORM("array dereference of pointer by ");
+			INFORM(types.name(src.data<1>()->type_code.base_type_index));
+			INFORM(" (C99 6.5.2.1p1; C++98 5.2.1p1,13.5.5p1)");
+			zcc_errors.inc_error();
+			return;
+			}
+		}
+	else{	// autofails in C; uses extension to test in preprocessor
+			//! \test default/Error_if_control2.h
+		src.flags |= parse_tree::INVALID;
+		if (!(parse_tree::INVALID & src.data<0>()->flags) && !(parse_tree::INVALID & src.data<1>()->flags))
+			{
+			message_header(src.index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INC_INFORM("array dereference of ");
+			INC_INFORM(types.name(src.data<1>()->type_code.base_type_index));
+			INC_INFORM(" by ");
+			INFORM(types.name(src.data<0>()->type_code.base_type_index));
+			INFORM(" (C99 6.5.2.1p1; C++98 5.2.1p1,13.5.5p1)");
+			zcc_errors.inc_error();
+			}
+		return;
+		}
+}
+
+/*(6.5.2) postfix-expression:
+	primary-expression
+	postfix-expression [ expression ]
+	postfix-expression ( argument-expression-listopt )
+	postfix-expression . identifier
+	postfix-expression -> identifier
+	postfix-expression ++
+	postfix-expression --
+	( type-name ) { initializer-list }
+	( type-name ) { initializer-list , }
+*/
+static void locate_C99_postfix_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].empty<1>()
+		|| !src.data<0>()[i].empty<2>()
+		|| !src.data<0>()[i].index_tokens[0].token.first) return;
+	
+	if (src.data<0>()[i].index_tokens[1].token.first)
+		{
+		if (terse_locate_array_deref(src,i))
+			{
+			C_array_easy_syntax_check(src.c_array<0>()[i],types);
+			return;
+			}
+#if 0
+		else if (   token_is_char<'('>(src.data<0>()[i].index_tokens[0].token)
+				 && token_is_char<')'>(src.data<0>()[i].index_tokens[1].token))
+			{
+			if (1<=i)
+				{
+				}
+			else if (1<src.size<0>()-i)
+				{
+				}
+			}
+		}
+	else{	// if (NULL==src.data<0>()[i].index_tokens[1].token.first)
+		if (token_is_char<'.'>(src.data<0>()[i].index_tokens[0].token))
+			{
+			if (1<=i && 1<src.size<0>()-i)
+				{
+				}
+			else{
+				}
+			}
+		else if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"->"))
+			{
+			if (1<=i && 1<src.size<0>()-i)
+				{
+				}
+			else{
+				}
+			}
+		else if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"++"))
+			{
+			if (1<=i)
+				{
+				}
+			}
+		else if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"--"))
+			{
+			if (1<=i)
+				{
+				}
+			}
+#endif
+		}
+}
+
+
+// if #include <typeinfo> hasn't happened, context-free error stops this
+//! \throw std::bad_alloc
+static bool terse_locate_CPP0X_typeid(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"typeid")
+		&& 1<src.size<0>()-i
+		&& is_naked_parentheses_pair(src.data<0>()[i+1]))
+		{
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<0>()[i+1].flags)
+			{
+			{
+			parse_tree* const tmp = repurpose_inner_parentheses(src.c_array<0>()[i+1]);	// RAM conservation
+			src.c_array<0>()[i+1].OverwriteInto(*tmp);
+			src.c_array<0>()[i].fast_set_arg<2>(tmp);
+			src.c_array<0>()[i].core_flag_update();
+			src.c_array<0>()[i].flags |= PARSE_STRICT_POSTFIX_EXPRESSION;
+			src.DeleteIdx<0>(i+1);
+			cancel_outermost_parentheses(src.c_array<0>()[i].c_array<2>()[0]);
+			}
+			src.c_array<0>()[i].type_code.set_type(C_TYPE::TYPEINFO);
+			src.c_array<0>()[i].type_code.qualifier<0>() |= (type_spec::lvalue | type_spec::_const);
+			assert(is_CPP0X_typeid_expression(src.c_array<0>()[i]));
+			return true;			
+			}
+		}
+	return false;
+}
+
+// We can't eval typeid itself at compile-time, but we *can* eval == and != of
+// typeid.  Most other operators should error, through.
+
+//! \throw std::bad_alloc()
+static bool locate_CPP0X_typeid(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+
+	if (	!(PARSE_OBVIOUS & src.data<0>()[i].flags)
+		&&	src.data<0>()[i].is_atomic()
+		&&	terse_locate_CPP0X_typeid(src,i,types))
+		return true;
+	return false;
+}
+/*postfixexpression:
+	primaryexpression
+	postfixexpression [ expression ]
+	postfixexpression ( expressionlistopt )
+	simpletypespecifier ( expressionlistopt )
+	postfixexpression . templateopt ::opt idexpression
+	postfixexpression -> templateopt ::opt idexpression
+	postfixexpression . pseudodestructorname
+	postfixexpression -> pseudodestructorname
+	postfixexpression ++
+	postfixexpression --
+	dynamic_cast < typeid > ( expression )
+	static_cast < typeid > ( expression )
+	reinterpret_cast < typeid > ( expression )
+	const_cast < typeid > ( expression )
+	typeid ( expression )
+	typeid ( typeid ) */
+/* returns error count */
+static void locate_CPP_postfix_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].empty<1>()
+		|| !src.data<0>()[i].empty<2>()) return;
+
+	if (src.data<0>()[i].index_tokens[1].token.first)
+		{
+		if (terse_locate_array_deref(src,i))
+			{	//! \todo handle operator [] overloading
+			C_array_easy_syntax_check(src.c_array<0>()[i],types);
+			return;
+			}
+#if 0
+		else if (   token_is_char<'('>(src.data<0>()[i].index_tokens[0].token)
+				 && token_is_char<')'>(src.data<0>()[i].index_tokens[1].token))
+			{
+			if (1<=i)
+				{
+				}
+			}
+#endif
+		}
+	else{	// if (NULL==src.data<0>()[i].index_tokens[1].token.first)
+		if (locate_CPP0X_typeid(src,i,types)) return;
+#if 0
+		if (token_is_char<'.'>(src.data<0>()[i].index_tokens[0].token))
+			{
+			if (1<=i && 1<src.size<0>()-i)
+				{
+				}
+			else{
+				}
+			}
+		else if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"->"))
+			{
+			if (1<=i && 1<src.size<0>()-i)
+				{
+				}
+			else{
+				}
+			}
+		else if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"++"))
+			{
+			if (1<=i)
+				{
+				}
+			}
+		else if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"--"))
+			{
+			if (1<=i)
+				{
+				}
+			}
+		else if (token_is_string<12>(src.data<0>()[i].index_tokens[0].token,"dynamic_cast"))
+			{
+			}
+		else if (token_is_string<11>(src.data<0>()[i].index_tokens[0].token,"static_cast"))
+			{
+			}
+		else if (token_is_string<16>(src.data<0>()[i].index_tokens[0].token,"reinterpret_cast"))
+			{
+			}
+		else if (token_is_string<10>(src.data<0>()[i].index_tokens[0].token,"const_cast"))
+			{
+			}
+		else if (token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"typeid"))
+			{
+			}
+#endif
+		}
+}
+
+// typedef to simplify compatibility changes
+typedef bool literal_converts_to_bool_func(const parse_tree& src, bool& is_true SIG_CONST_TYPES);
+
+// Closely related to if_elif_control_is_zero/CPreproc.cpp
+static bool _C99_literal_converts_to_bool(const parse_tree& src, bool& is_true SIG_CONST_TYPES)
+{
+	assert(src.is_atomic());
+	// string literals always test true (decay to non-NULL pointer)
+	if (C_TESTFLAG_STRING_LITERAL==src.index_tokens[0].flags)
+		{
+		is_true = true;
+		return true;
+		}
+	if (C_TESTFLAG_CHAR_LITERAL==src.index_tokens[0].flags)
+		{
+		is_true = !CCharLiteralIsFalse(src.index_tokens[0].token.first,src.index_tokens[0].token.second);
+		return true;
+		};
+	if (is_noticed_enumerator(src,types))
+		{	// misintepret enumerators as literals (avoid dynamic memory thrashing)
+		const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.index_tokens[0].token.first);
+		assert(tmp2);
+		const promote_aux dest_type(tmp2->second.first.second,types);
+		is_true = !target_machine->is_zero(tmp2->second.first.third.data(),tmp2->second.first.third.size(),dest_type);
+		return true;
+		}
+	if (!(C_TESTFLAG_PP_NUMERAL & src.index_tokens[0].flags)) return false;
+	C_REALITY_CHECK_PP_NUMERAL_FLAGS(src.index_tokens[0].flags);
+	if (C_TESTFLAG_FLOAT & src.index_tokens[0].flags) return false;	//! \todo handle floats as well (underflow to zero is target-sensitive)
+	// zeros go to zero, everything else canonicalizes to one
+	is_true = !C99_integer_literal_is_zero(src.index_tokens[0].token.first,src.index_tokens[0].token.second,src.index_tokens[0].flags);
+	return true;
+}
+
+static bool C99_literal_converts_to_bool(const parse_tree& src, bool& is_true SIG_CONST_TYPES)
+{	// deal with -1 et. al.
+	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return _C99_literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES);
+
+	if (!src.is_atomic()) return false;
+	return _C99_literal_converts_to_bool(src,is_true ARG_TYPES);
+}
+
+static bool CPP_literal_converts_to_bool(const parse_tree& src, bool& is_true SIG_CONST_TYPES)
+{
+	// deal with -1 et. al.
+	if (is_C99_unary_operator_expression<'-'>(src) && src.data<2>()->is_atomic()) return CPP_literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES);
+
+	if (!src.is_atomic()) return false;
+	if (_C99_literal_converts_to_bool(src,is_true ARG_TYPES)) return true;
+	// deal with: this, true, false
+	if (token_is_string<5>(src.index_tokens[0].token,"false"))
+		{
+		is_true = false;
+		return true;
+		}
+	else if (	token_is_string<4>(src.index_tokens[0].token,"true")
+			 ||	token_is_string<4>(src.index_tokens[0].token,"this"))
+		{
+		is_true = true;
+		return true;
+		};
+	return false;
+}
+
+//! \throw std::bad_alloc
+static void assemble_unary_postfix_arguments(parse_tree& src, size_t& i, const size_t _subtype)
+{
+	assert(1<src.size<0>()-i);
+	parse_tree* const tmp = repurpose_inner_parentheses(src.c_array<0>()[i+1]);	// RAM conservation
+	src.c_array<0>()[i+1].OverwriteInto(*tmp);
+	src.c_array<0>()[i].fast_set_arg<2>(tmp);
+	src.c_array<0>()[i].core_flag_update();
+	src.c_array<0>()[i].flags |= PARSE_STRICT_UNARY_EXPRESSION;
+	src.c_array<0>()[i].subtype = _subtype;
+	src.DeleteIdx<0>(i+1);
+	cancel_outermost_parentheses(src.c_array<0>()[i].c_array<2>()[0]);
+}
+
+// can't do much syntax-checking or immediate-evaluation here because of binary +/-
+// unary +/- syntax checking out out of place as it's needed by all of the unary operators
+//! \throw std::bad_alloc()
+static void VM_to_token(const umaxint& src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
+{
+	assert(C_TYPE::INT<=base_type_index && C_TYPE::ULLONG>=base_type_index);
+	const char* const suffix = literal_suffix(base_type_index);
+	char* buf = _new_buffer_nonNULL_throws<char>((VM_MAX_BIT_PLATFORM/3)+4);
+	dest.second = literal_flags(base_type_index);
+	dest.second |= C_TESTFLAG_DECIMAL;
+	z_ucharint_toa(src_int,buf,10);
+	assert(!suffix || 3>=strlen(suffix));
+	assert(dest.second);
+	if (suffix) strcat(buf,suffix);
+
+	// shrinking realloc should be no-fail
+	dest.first = REALLOC(buf,ZAIMONI_LEN_WITH_NULL(strlen(buf)));
+}
+
+//! \throw std::bad_alloc()
+static void VM_to_literal(parse_tree& dest, const umaxint& src_int,const parse_tree& src,const type_system& types)
+{
+	POD_pair<char*,lex_flags> new_token;
+	VM_to_token(src_int,src.type_code.base_type_index,new_token);
+	dest.clear();
+	dest.grab_index_token_from<0>(new_token.first,new_token.second);
+	dest.grab_index_token_location_from<0,0>(src);
+	assert((C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_STRING_LITERAL | C_TESTFLAG_PP_NUMERAL) & dest.index_tokens[0].flags);
+	_label_one_literal(dest,types);
+	assert(PARSE_EXPRESSION & dest.flags);
+}
+
+// can't do much syntax-checking or immediate-evaluation here because of binary +/-
+// unary +/- syntax checking out out of place as it's needed by all of the unary operators
+//! \throw std::bad_alloc()
+static void uint_to_token(uintmax_t src_int,const size_t base_type_index,POD_pair<char*,lex_flags>& dest)
+{
+	assert(C_TYPE::INT<=base_type_index && C_TYPE::ULLONG>=base_type_index);
+	const char* const suffix = literal_suffix(base_type_index);
+	char* buf = _new_buffer_nonNULL_throws<char>((VM_MAX_BIT_PLATFORM/3)+4);
+	dest.second = literal_flags(base_type_index);
+	dest.second |= C_TESTFLAG_DECIMAL;
+	z_umaxtoa(src_int,buf,10);
+	assert(!suffix || 3>=strlen(suffix));
+	assert(dest.second);
+	if (suffix) strcat(buf,suffix);
+
+	// shrinking realloc should be no-fail
+	dest.first = REALLOC(buf,ZAIMONI_LEN_WITH_NULL(strlen(buf)));
+}
+
+//! \throw std::bad_alloc()
+static void uint_to_literal(parse_tree& dest, uintmax_t src_int,const parse_tree& src,const type_system& types)
+{
+	POD_pair<char*,lex_flags> new_token;
+	uint_to_token(src_int,src.type_code.base_type_index,new_token);
+	dest.clear();
+	dest.grab_index_token_from<0>(new_token.first,new_token.second);
+	dest.grab_index_token_location_from<0,0>(src);
+	assert((C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_STRING_LITERAL | C_TESTFLAG_PP_NUMERAL) & dest.index_tokens[0].flags);
+	_label_one_literal(dest,types);
+	assert(PARSE_EXPRESSION & dest.flags);
+}
+
+static void force_decimal_literal(parse_tree& dest,const char* src,const type_system& types)
+{
+	assert(src && *src);
+	dest.destroy();
+	assert(dest.index_tokens[0].src_filename && *dest.index_tokens[0].src_filename);
+	dest.index_tokens[0].token.first = src;
+	dest.index_tokens[0].token.second = strlen(src);
+	dest.index_tokens[0].flags = (C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_INTEGER | C_TESTFLAG_DECIMAL);
+	_label_one_literal(dest,types);
+}
+
+static parse_tree decimal_literal(const char* src,const parse_tree& loc_src,const type_system& types)
+{
+	assert(src && *src);
+	parse_tree dest;
+	dest.clear();
+	dest.index_tokens[0].token.first = src;
+	dest.index_tokens[0].token.second = strlen(src);
+	dest.index_tokens[0].flags = (C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_INTEGER | C_TESTFLAG_DECIMAL);
+	dest.grab_index_token_location_from<0,0>(loc_src);
+	_label_one_literal(dest,types);
+	return dest;
+}
+
+//! usually want to use value_copy rather than MoveInto before this (easier to be ACID)
+//! \throw std::bad_alloc only if dest.type_code.pointer_power<dest.data<2>()->type_code.pointer_power 
+static void force_unary_positive_literal(parse_tree& dest,const parse_tree& src SIG_CONST_TYPES)
+{
+	assert(0==dest.size<0>());
+	assert(0==dest.size<1>());
+	assert(1==dest.size<2>());
+	assert(!dest.index_tokens[1].token.first);
+	dest.grab_index_token_from_str_literal<0>("+",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
+	*dest.c_array<2>() = src;
+	dest.core_flag_update();
+	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
+	dest.subtype = C99_UNARY_SUBTYPE_PLUS;
+	if (converts_to_arithmeticlike(dest.data<2>()->type_code ARG_TYPES))
+		value_copy(dest.type_code,dest.data<2>()->type_code);	//! \bug doesn't work for enumerators
+	assert(dest.index_tokens[0].src_filename);
+	assert(is_C99_unary_operator_expression<'+'>(dest));
+}
+
+static void force_unary_negative_token(parse_tree& dest,parse_tree* src,const parse_tree& loc_src SIG_CONST_TYPES)
+{
+	assert(src);
+	assert(PARSE_EXPRESSION & src->flags);
+	dest.clear();
+	dest.grab_index_token_from_str_literal<0>("-",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
+	dest.grab_index_token_location_from<0,0>(loc_src);
+	dest.fast_set_arg<2>(src);
+	dest.core_flag_update();
+	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
+	dest.subtype = C99_UNARY_SUBTYPE_NEG;
+	if (converts_to_arithmeticlike(dest.data<2>()->type_code ARG_TYPES))
+		value_copy(dest.type_code,dest.data<2>()->type_code);	//! \bug doesn't work for enumerators
+	// do not handle type here: C++ operator overloading risk
+	assert(dest.index_tokens[0].src_filename);
+	assert(is_C99_unary_operator_expression<'-'>(dest));
+}
+
+// this one hides a slight inefficiency: negative literals take 2 dynamic memory allocations, positive literals take one
+// return code is true for success, false for memory failure
+//! \throw std::bad_alloc()
+static void VM_to_signed_literal(parse_tree& x,const bool is_negative, const umaxint& src_int,const parse_tree& src,const type_system& types)
+{
+	if (is_negative)
+		{
+		parse_tree* tmp = _new_buffer_nonNULL_throws<parse_tree>(1);
+		try {
+			VM_to_literal(*tmp,src_int,src,types);
+			}
+		catch(const std::bad_alloc&)
+			{
+			_flush(tmp);
+			throw;
+			}
+		assert(PARSE_EXPRESSION & tmp->flags);
+		force_unary_negative_token(x,tmp,*tmp ARG_TYPES);
+		}
+	else VM_to_literal(x,src_int,src,types);
+}
+
+//! \throw std::bad_alloc()
+static void enumerator_to_integer_representation(parse_tree& x,const type_system& types)
+{
+	parse_tree tmp3;
+	const type_system::enumerator_info* const tmp2 = types.get_enumerator(x.index_tokens[0].token.first);
+	assert(tmp2);
+	const promote_aux dest_type(tmp2->second.first.second ARG_TYPES);
+	{
+	umaxint res_int(tmp2->second.first.third);
+	const bool tmp_negative = dest_type.is_signed && res_int.test(dest_type.bitcount-1);
+	if (tmp_negative) target_machine->signed_additive_inverse(res_int,dest_type.machine_type);
+	{	// pretend x is the type of the enumerator.
+	const type_system::type_index backup = x.type_code.base_type_index;
+	x.type_code.base_type_index = tmp2->second.first.second;
+	try {
+		VM_to_signed_literal(tmp3,tmp_negative,res_int,x,types);
+		}
+	catch(const std::bad_alloc&)
+		{
+		x.type_code.base_type_index = backup;
+		throw;
+		}
+	}
+	}
+	tmp3.MoveInto(x);
+}
+
+static bool is_integerlike_literal(const parse_tree& x SIG_CONST_TYPES)
+{
+	return converts_to_integerlike(x.type_code ARG_TYPES) && (PARSE_PRIMARY_EXPRESSION & x.flags);
+}
+
+//! \throw std::bad_alloc()
+static bool eval_unary_plus(parse_tree& src, const type_system& types)
+{
+	assert(is_C99_unary_operator_expression<'+'>(src));
+	if (0<src.data<2>()->type_code.pointer_power)
+		{	// assume C++98 interpretation, as this is illegal in C99
+		//! \test cpp/default/Pass_if_control27.hpp
+		if (!(parse_tree::INVALID & src.flags))
+			{
+			assert(src.type_code==src.data<2>()->type_code);
+			src.eval_to_arg<2>(0);
+			return true;
+			}
+		return false;
+		};
+	if (is_noticed_enumerator(*src.data<2>(),types))
+		{
+		enumerator_to_integer_representation(*src.c_array<2>(),types);
+		if (is_C99_unary_operator_expression<'-'>(*src.data<2>()))
+			{	// enumerator went negative: handle
+			src.eval_to_arg<2>(0);
+			return true;
+			}
+		}
+ 	// handle integer-like literals like a real integer literal
+	if (is_integerlike_literal(*src.data<2>() ARG_TYPES))
+		{
+		src.type_code.MoveInto(src.c_array<2>()->type_code);
+		src.eval_to_arg<2>(0);
+		return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool eval_unary_minus(parse_tree& src, const type_system& types,literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	assert(is_C99_unary_operator_expression<'-'>(src));
+	bool is_true = false;
+	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true && (1==(src.type_code.base_type_index-C_TYPE::INT)%2 || virtual_machine::twos_complement==target_machine->C_signed_int_representation() || bool_options[boolopt::int_traps]))
+		{	// -0==0
+			// deal with unary - not being allowed to actually return -0 on these machines later
+		type_spec tmp;
+		src.type_code.OverwriteInto(tmp);
+		force_decimal_literal(src,"0",types);
+		tmp.MoveInto(src.type_code);
+		return true;
+		};
+	if (is_noticed_enumerator(*src.data<2>(),types))
+		{
+		enumerator_to_integer_representation(*src.c_array<2>(),types);
+		if (is_C99_unary_operator_expression<'-'>(*src.data<2>()))
+			{	// enumerator went negative: handle
+			src.eval_to_arg<2>(0);
+			return true;
+			}
+		value_copy(src.type_code,src.data<2>()->type_code);
+		}
+	if (is_integerlike_literal(*src.data<2>() ARG_TYPES) && 1==(src.type_code.base_type_index-C_TYPE::INT)%2)
+		{	// unsigned...we're fine
+		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
+		umaxint res_int;
+		intlike_literal_to_VM(res_int,*src.data<2>() ARG_TYPES);
+		target_machine->unsigned_additive_inverse(res_int,machine_type);
+
+		//! \todo flag failures to reduce as RAM-stalled
+		POD_pair<char*,lex_flags> new_token;
+		VM_to_token(res_int,src.type_code.base_type_index,new_token);
+		src.c_array<2>()->grab_index_token_from<0>(new_token.first,new_token.second);
+		src.type_code.MoveInto(src.c_array<2>()->type_code);
+		src.eval_to_arg<2>(0);
+		return true;
+		};
+	if (converts_to_integerlike(src.data<2>()->type_code ARG_TYPES) && is_C99_unary_operator_expression<'-'>(*src.data<2>()))
+		{	// - - __ |-> __, trap-int machines fine as -0=0 for sign/magnitude and one's complement, and the offending literal for two's complement is an unsigned int
+		assert(converts_to_integerlike(src.data<2>()->data<2>()->type_code ARG_TYPES));
+		parse_tree tmp;
+		src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
+		src.type_code.MoveInto(tmp.type_code);
+		tmp.MoveInto(src);
+		return true;		
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static void C_unary_plusminus_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(C99_UNARY_SUBTYPE_NEG==src.subtype || C99_UNARY_SUBTYPE_PLUS==src.subtype);
+	assert((C99_UNARY_SUBTYPE_PLUS==src.subtype) ? is_C99_unary_operator_expression<'+'>(src) : is_C99_unary_operator_expression<'-'>(src));
+	// return immediately if applied to a pointer type (C++98 would type here)
+	if (0<src.data<2>()->type_code.pointer_power)
+		{
+		src.type_code.set_type(0);
+		simple_error(src,(C99_UNARY_SUBTYPE_PLUS==src.subtype) ? " applies unary + to a pointer (C99 6.5.3.3p1)" : " applies unary - to a pointer (C99 6.5.3.3p1)");
+		return;
+		}
+	// can type if an (C++0X unscoped) enumerator
+	if (is_noticed_enumerator(*src.data<2>(),types))
+		{
+		const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.data<2>()->index_tokens[0].token.first);
+		assert(tmp2);
+		src.type_code.set_type(tmp2->second.first.first);
+		}
+	else
+	// can type if result is a primitive arithmetic type
+	if (converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
+		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES));
+
+	const size_t arg_unary_subtype 	= (is_C99_unary_operator_expression<'-'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_NEG
+									: (is_C99_unary_operator_expression<'+'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_PLUS : 0;
+	if (!arg_unary_subtype) return;
+	// two deep:
+	// 2) if inner +/- is applied to a raw pointer, error out and change type to 0
+	// 1) if inner +/- is applied to an arithmetic literal, try to crunch it (but handle - signed carefully)
+	if (C99_UNARY_SUBTYPE_PLUS==src.subtype)
+		{
+		if 		(C99_UNARY_SUBTYPE_PLUS==arg_unary_subtype)
+			eval_unary_plus(*src.c_array<2>(),types);
+		else	// if (C99_UNARY_SUBTYPE_NEG==arg_unary_subtype)
+			eval_unary_minus(*src.c_array<2>(),types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+		}
+	else{	// if (C99_UNARY_SUBTYPE_NEG==src.subtype)
+		if 		(C99_UNARY_SUBTYPE_PLUS==arg_unary_subtype)
+			eval_unary_plus(*src.c_array<2>(),types);
+		else	// if (C99_UNARY_SUBTYPE_NEG==arg_unary_subtype)
+			eval_unary_minus(*src.c_array<2>(),types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+		}
+}
+
+//! \throw std::bad_alloc()
+static void CPP_unary_plusminus_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(C99_UNARY_SUBTYPE_NEG==src.subtype || C99_UNARY_SUBTYPE_PLUS==src.subtype);
+	assert((C99_UNARY_SUBTYPE_PLUS==src.subtype) ? is_C99_unary_operator_expression<'+'>(src) : is_C99_unary_operator_expression<'-'>(src));
+	
+	// can type if result is a primitive arithmetic type
+	// can type if an (C++0X unscoped) enumerator
+	if (is_noticed_enumerator(*src.data<2>(),types))
+		{
+		const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.data<2>()->index_tokens[0].token.first);
+		assert(tmp2);
+		src.type_code.set_type(tmp2->second.first.first);
+		}
+	else
+	if (converts_to_arithmeticlike(src.data<2>()->type_code ARG_TYPES))
+		src.type_code.set_type(default_promote_type(src.data<2>()->type_code.base_type_index ARG_TYPES));
+
+	// two deep:
+	// 1) if inner +/- is applied to an arithmetic literal, try to crunch it (but leave - signed alone)
+	// 2) if inner +/- is applied to a raw pointer, error out and change type to 0
+	if (C99_UNARY_SUBTYPE_PLUS==src.subtype)
+		{
+		if (0<src.data<2>()->type_code.pointer_power)
+			// C++98 5.3.1p6: pointer type allowed for unary +, not for unary - (C99 errors)
+			//! \test default/Pass_if_control27.hpp
+			value_copy(src.type_code,src.data<2>()->type_code);
+
+		if 		(is_C99_unary_operator_expression<'+'>(*src.data<2>()))
+			eval_unary_plus(*src.c_array<2>(),types);
+		else if (is_C99_unary_operator_expression<'-'>(*src.data<2>()))
+			eval_unary_minus(*src.c_array<2>(),types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
+		}
+	else{	// if (C99_UNARY_SUBTYPE_NEG==src.subtype)
+		// return immediately if result is a pointer type; nested application to a pointer type dies
+		if (0<src.data<2>()->type_code.pointer_power)
+			{
+			src.type_code.set_type(0);
+			simple_error(src," applies unary - to a pointer (C++98 5.3.1p7)");
+			return;
+			}
+
+		const size_t arg_unary_subtype 	= (is_C99_unary_operator_expression<'-'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_NEG
+										: (is_C99_unary_operator_expression<'+'>(*src.data<2>())) ? C99_UNARY_SUBTYPE_PLUS : 0;
+		if (arg_unary_subtype)
+			{
+			if 		(C99_UNARY_SUBTYPE_PLUS==arg_unary_subtype)
+				eval_unary_plus(*src.c_array<2>(),types);
+			else	// if (C99_UNARY_SUBTYPE_NEG==arg_unary_subtype)
+				eval_unary_minus(*src.c_array<2>(),types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
+			}
+		}
+}
+
+// this is going to have to be forked eventually; the CPP variant has to be more
+// careful with the *& identity as both deference * and reference & are 
+// overloadable operators
+//! \throw std::bad_alloc()
+static void C_deref_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_unary_operator_expression<'*'>(src));
+	//! \todo: handle *& identity when we have &
+	// multi-dimensional arrays and cv-qualified pointers should be automatically handled
+	value_copy(src.type_code,src.data<2>()->type_code);
+	// handle lvalueness in indirection type building and/or the dereference stage
+	if (!src.type_code.dereference())
+		//! \test default/Error_if_control24.hpp, default/Error_if_control24.h
+		simple_error(src," is not dereferencing a pointer (C99 6.5.3.2p2; C++98 5.3.1p1)");
+}
+
+// no eval_deref because of &* cancellation
+// defer syntax check to after resolution of multiply-*, so no C/C++ fork
+//! \throw std::bad_alloc()
+static bool terse_locate_C99_deref(parse_tree& src, size_t& i,const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_char<'*'>(src.data<0>()[i].index_tokens[0].token))
+		{
+		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
+			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
+		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
+			{
+			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_DEREF);
+			assert(is_C99_unary_operator_expression<'*'>(src.data<0>()[i]));
+			return true;
+			};
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool terse_locate_CPP_deref(parse_tree& src, size_t& i,const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_char<'*'>(src.data<0>()[i].index_tokens[0].token))
+		{
+		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
+			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
+		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
+			{
+			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_DEREF);
+			assert(is_C99_unary_operator_expression<'*'>(src.data<0>()[i]));
+			return true;
+			};
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool terse_locate_C_logical_NOT(parse_tree& src, size_t& i,const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_char<'!'>(src.data<0>()[i].index_tokens[0].token))
+		{
+		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
+			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
+		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
+			{
+			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_NOT);
+			assert(is_C99_unary_operator_expression<'!'>(src.data<0>()[i]));
+			return true;
+			};
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool terse_locate_CPP_logical_NOT(parse_tree& src, size_t& i,const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_char<'!'>(src.data<0>()[i].index_tokens[0].token) || token_is_string<3>(src.data<0>()[i].index_tokens[0].token,"not"))
+		{
+		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
+			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
+		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
+			{
+			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_NOT);
+			assert(is_CPP_logical_NOT_expression(src.data<0>()[i]));
+			return true;
+			};
+		}
+	return false;
+}
+
+static bool eval_logical_NOT(parse_tree& src, const type_system& types, func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_NOT, literal_converts_to_bool_func& literal_converts_to_bool)
+{
+	assert(is_logical_NOT(src));
+	{	// deal with literals that convert to bool here
+	bool is_true = false;
+	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES))
+		{
+		src.destroy();
+		src.index_tokens[0].token.first = (is_true) ? "0" : "1";
+		src.index_tokens[0].token.second = 1;
+		src.index_tokens[0].flags = (C_TESTFLAG_PP_NUMERAL | C_TESTFLAG_INTEGER | C_TESTFLAG_DECIMAL);
+		_label_one_literal(src,types);
+		return true;
+		}
+	}
+	// logical NOT has period 2, but the first application converts the target to bool; can only cancel 3-deep in general, 2-deep against type bool expressions
+	if (is_logical_NOT(*src.data<2>()))
+		{
+		if (	is_logical_NOT(*src.data<2>()->data<2>())
+			||	(C_TYPE::BOOL==src.data<2>()->type_code.base_type_index && 0==src.data<2>()->type_code.pointer_power))
+			{
+			parse_tree tmp;
+			src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
+			tmp.MoveInto(src);
+			return true;
+			}
+		};
+	return false;
+}
+
+static void C_logical_NOT_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_unary_operator_expression<'!'>(src));
+	src.type_code.set_type(C_TYPE::BOOL);	// technically wrong for C, but the range is restricted to _Bool's range
+	if (eval_logical_NOT(src,types,is_C99_unary_operator_expression<'!'>,C99_literal_converts_to_bool)) return;
+
+	if (!converts_to_bool(src.data<2>()->type_code ARG_TYPES))
+		{	// can't test this from preprocessor or static assertion
+		simple_error(src," applies ! to a nonscalar type (C99 6.5.3.3p1)");
+		return;
+		}
+}
+
+static void CPP_logical_NOT_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_CPP_logical_NOT_expression(src));
+	src.type_code.set_type(C_TYPE::BOOL);	// technically wrong for C, but the range is restricted to _Bool's range
+	if (eval_logical_NOT(src,types,is_CPP_logical_NOT_expression,CPP_literal_converts_to_bool)) return;
+
+	if (!converts_to_bool(src.data<2>()->type_code ARG_TYPES))
+		{	// can't test this from preprocessor or static assertion
+		simple_error(src," applies ! to a type not convertible to bool (C++98 5.3.1p8)");
+		return;
+		}
+}
+
+//! \throw std::bad_alloc()
+static bool locate_C99_logical_NOT(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (terse_locate_C_logical_NOT(src,i,types))
+		{
+		C_logical_NOT_easy_syntax_check(src.c_array<0>()[i],types);
+		return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool locate_CPP_logical_NOT(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (terse_locate_CPP_logical_NOT(src,i,types))
+		{	//! \todo handle operator overloading
+		CPP_logical_NOT_easy_syntax_check(src.c_array<0>()[i],types);
+		return true;
+		}
+	return false;
+}
+
+static bool int_has_trapped(parse_tree& src,const umaxint& src_int)
+{
+	assert(C_TYPE::INT<=src.type_code.base_type_index && C_TYPE::INTEGERLIKE>src.type_code.base_type_index);
+	// check for trap representation for signed types
+	const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
+	if (bool_options[boolopt::int_traps] && 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && target_machine->trap_int(src_int,machine_type))
+		{
+		if (!no_runtime_errors)
+			simple_error(src," generated a trap representation: undefined behavior (C99 6.2.6.1p5)");
+		return true;
+		}
+	return false;
+}
+
+//! this doesn't do anything to dest's type
+static void force_unary_negative_literal(parse_tree& dest,const parse_tree& src)
+{
+	assert(0==dest.size<0>());
+	assert(0==dest.size<1>());
+	assert(1==dest.size<2>());
+	assert(!dest.index_tokens[1].token.first);
+	dest.grab_index_token_from_str_literal<0>("-",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
+	*dest.c_array<2>() = src;
+	dest.core_flag_update();
+	dest.flags |= PARSE_STRICT_UNARY_EXPRESSION;
+	dest.subtype = C99_UNARY_SUBTYPE_NEG;
+	assert(dest.index_tokens[0].src_filename);
+	assert(is_C99_unary_operator_expression<'-'>(dest));
+}
+
+//! \throw std::bad_alloc()
+static bool terse_locate_C99_bitwise_complement(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_char<'~'>(src.data<0>()[i].index_tokens[0].token))
+		{
+		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
+			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
+		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
+			{
+			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_COMPL);
+			assert(is_C99_unary_operator_expression<'~'>(src.data<0>()[i]));
+			return true;
+			};
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool terse_locate_CPP_bitwise_complement(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_char<'~'>(src.data<0>()[i].index_tokens[0].token) || token_is_string<5>(src.data<0>()[i].index_tokens[0].token,"compl"))
+		{
+		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
+			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
+		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
+			{
+			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_COMPL);
+			assert(is_CPP_bitwise_complement_expression(src.data<0>()[i]));
+			return true;
+			};
+		}
+	return false;
+}
+
+// all three users of this want the resulting type to be the same as dest's type
+//! \throw std::bad_alloc()
+static void construct_twos_complement_int_min(parse_tree& dest, const type_system& types, const virtual_machine::std_int_enum machine_type, const parse_tree& src_loc)
+{
+	zaimoni::autoval_ptr<parse_tree> tmp2;
+	tmp2 = _new_buffer_nonNULL_throws<parse_tree>(1);	// XXX we recycle this variable later
+	zaimoni::autoval_ptr<parse_tree> tmp3;
+	tmp3 = _new_buffer_nonNULL_throws<parse_tree>(1);	// XXX we recycle this variable later
+	{
+	umaxint tmp_int(target_machine->signed_max(machine_type));
+	zaimoni::autoval_ptr<parse_tree> tmp;
+	tmp = _new_buffer_nonNULL_throws<parse_tree>(1);	// XXX we recycle this variable later
+	VM_to_literal(*tmp,tmp_int,src_loc,types);
+
+	tmp_int = 1;
+	try {
+		VM_to_literal(*tmp2,tmp_int,src_loc,types);
+		}
+	catch(const std::bad_alloc&)
+		{
+		tmp->destroy();
+		throw;
+		}
+
+	force_unary_negative_token(*tmp3,tmp.release(),src_loc ARG_TYPES);
+	}
+	
+	parse_tree_class tmp4;
+	tmp4.grab_index_token_from_str_literal<0>("-",C_TESTFLAG_NONATOMIC_PP_OP_PUNC);
+	tmp4.grab_index_token_location_from<0,0>(src_loc);
+	tmp4.fast_set_arg<1>(tmp3.release());
+	tmp4.fast_set_arg<2>(tmp2.release());
+
+	tmp4.core_flag_update();
+	tmp4.flags |= PARSE_STRICT_ADD_EXPRESSION;
+	tmp4.subtype = C99_ADD_SUBTYPE_MINUS;
+	assert(is_C99_add_operator_expression<'-'>(tmp4));
+
+	dest.type_code.MoveInto(tmp4.type_code);
+	tmp4.MoveInto(dest);
+	// do not handle type here: C++ operator overloading risk
+}
+
+//! \throw std::bad_alloc()
+static bool eval_bitwise_compl(parse_tree& src, const type_system& types,func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	assert(is_bitwise_complement_expression(src));
+	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
+	if (is_noticed_enumerator(*src.data<2>(),types))
+		{
+		enumerator_to_integer_representation(*src.c_array<2>(),types);
+		value_copy(src.type_code,src.data<2>()->type_code);
+		}
+	umaxint res_int;
+	if (intlike_literal_to_VM(res_int,*src.data<2>() ARG_TYPES)) 
+		{
+		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
+		res_int.auto_bitwise_complement();
+		res_int.mask_to(target_machine->C_bit(machine_type));
+
+		if (int_has_trapped(src,res_int)) return false;
+
+		const bool negative_signed_int = 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && res_int.test(target_machine->C_bit(machine_type)-1);
+		if (negative_signed_int) target_machine->signed_additive_inverse(res_int,machine_type);
+		if (	virtual_machine::twos_complement==target_machine->C_signed_int_representation()
+			&& 	0==(src.type_code.base_type_index-C_TYPE::INT)%2
+			&& 	!bool_options[boolopt::int_traps]
+			&&	res_int>target_machine->signed_max(machine_type))
+			{	// trap representation; need to get it into -INT_MAX-1 form
+			construct_twos_complement_int_min(src,types,machine_type,src);
+			return true;
+			}
+
+		parse_tree tmp;
+		VM_to_literal(tmp,res_int,src,types);	// two's-complement non-trapping INT_MIN dies if it gets here
+
+		if (negative_signed_int)
+			// convert to parsed - literal
+			force_unary_negative_literal(src,tmp);
+		else{	// convert to positive literal
+			src.type_code.MoveInto(tmp.type_code);
+			tmp.MoveInto(src);
+			}
+		return true;
+		};
+	if (	is_bitwise_complement_expression(*src.data<2>())
+		&&	is_bitwise_complement_expression(*src.data<2>()->data<2>()))
+		{	// ~~~__ reduces to ~__ safely
+		parse_tree tmp;
+		src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
+		tmp.MoveInto(src);
+		return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static void C_bitwise_complement_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_unary_operator_expression<'~'>(src));
+	const POD_pair<size_t,bool> tmp = default_promotion_is_integerlike(src.data<2>()->type_code ARG_TYPES);
+	if (!tmp.second)
+		{	//! \test Error_if_control25.h
+		src.type_code.set_type(0);
+		simple_error(src," applies ~ to a nonintegral type (C99 6.5.3.3p1)");
+		return;
+		}
+	src.type_code.set_type(tmp.first);
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_compl(src,types,is_C99_unary_operator_expression<'~'>,C99_intlike_literal_to_VM)) return;
+}
+
+//! \throw std::bad_alloc()
+static void CPP_bitwise_complement_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_CPP_bitwise_complement_expression(src));
+	const POD_pair<size_t,bool> tmp = default_promotion_is_integerlike(src.data<2>()->type_code ARG_TYPES);
+	if (!tmp.second)
+		{
+		src.type_code.set_type(0);
+		simple_error(src," applies ~ to a nonintegral type (C99 6.5.3.3p1)");
+		return;
+		}
+	src.type_code.set_type(tmp.first);
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_compl(src,types,is_CPP_bitwise_complement_expression,CPP_intlike_literal_to_VM)) return;
+}
+
+//! \throw std::bad_alloc()
+static bool locate_C99_bitwise_complement(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+
+	if (	!(PARSE_OBVIOUS & src.data<0>()[i].flags)
+		&&	src.data<0>()[i].is_atomic()
+		&&	terse_locate_C99_bitwise_complement(src,i,types))
+		{
+		C_bitwise_complement_easy_syntax_check(src.c_array<0>()[i],types);
+		return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool locate_CPP_bitwise_complement(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+
+	if (	!(PARSE_OBVIOUS & src.data<0>()[i].flags)
+		&&	src.data<0>()[i].is_atomic()
+		&&	terse_locate_CPP_bitwise_complement(src,i,types))
+		{	//! \todo handle overloading
+		CPP_bitwise_complement_easy_syntax_check(src.c_array<0>()[i],types);
+		return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool terse_locate_C99_unary_plusminus(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	const size_t unary_subtype 	= (token_is_char<'-'>(src.data<0>()[i].index_tokens[0].token)) ? C99_UNARY_SUBTYPE_NEG
+								: (token_is_char<'+'>(src.data<0>()[i].index_tokens[0].token)) ? C99_UNARY_SUBTYPE_PLUS : 0;
+	if (unary_subtype)
+		{
+		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
+			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
+		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
+			{
+			assemble_unary_postfix_arguments(src,i,unary_subtype);
+			src.c_array<0>()[i].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
+			if (0==i)	// unless no predecessor possible
+				C_unary_plusminus_easy_syntax_check(src.c_array<0>()[0],types);
+			assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i]));
+			return true;
+			};
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool terse_locate_CPP_unary_plusminus(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	const size_t unary_subtype 	= (token_is_char<'-'>(src.data<0>()[i].index_tokens[0].token)) ? C99_UNARY_SUBTYPE_NEG
+								: (token_is_char<'+'>(src.data<0>()[i].index_tokens[0].token)) ? C99_UNARY_SUBTYPE_PLUS : 0;
+	if (unary_subtype)
+		{
+		assert(1<src.size<0>()-i);	// should be intercepted at context-free check
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
+			CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
+		if (PARSE_CAST_EXPRESSION & src.data<0>()[i+1].flags)
+			{
+			assemble_unary_postfix_arguments(src,i,unary_subtype);
+			src.c_array<0>()[i].type_code.set_type(C_TYPE::NOT_VOID);	// defer to later
+			if (0==i)	// unless no predecessor possible
+				CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[0],types);
+			assert((C99_UNARY_SUBTYPE_PLUS==unary_subtype) ? is_C99_unary_operator_expression<'+'>(src.data<0>()[i]) : is_C99_unary_operator_expression<'-'>(src.data<0>()[i]));
+			return true;
+			};
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool locate_C99_unary_plusminus(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return false;
+
+	return terse_locate_C99_unary_plusminus(src,i,types);
+}
+
+//! \throw std::bad_alloc()
+static bool locate_CPP_unary_plusminus(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return false;
+
+	return terse_locate_CPP_unary_plusminus(src,i,types);
+}
+
+// handle C++0X sizeof... elsewhere (context-free syntax checks should be fixed first, possibly consider sizeof... a psuedo-identifier)
+//! \throw std::bad_alloc
+static bool terse_locate_C99_CPP_sizeof(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"sizeof"))
+		{
+		assert(1<src.size<0>()-i);
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i+1]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i+1]))
+			C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i+1],types);
+		else if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i+1]))
+			C_deref_easy_syntax_check(src.c_array<0>()[i+1],types);
+		if (   (PARSE_UNARY_EXPRESSION & src.data<0>()[i+1].flags)
+			|| (is_naked_parentheses_pair(src.data<0>()[i+1]) && (PARSE_TYPE & src.data<0>()[i+1].flags)))
+			{
+			assemble_unary_postfix_arguments(src,i,C99_UNARY_SUBTYPE_SIZEOF);
+			src.c_array<0>()[i].type_code.set_type(unsigned_type_from_machine_type(target_machine->size_t_type()));
+			assert(is_C99_CPP_sizeof_expression(src.c_array<0>()[i]));
+			return true;			
+			}
+		}
+	return false;
+}
+
+static size_t _eval_sizeof_core_type(const size_t base_type_index)
+{	//! \todo eventually handle the floating and complex types here as well
+	// floating is just a matter of modeling
+	// complex may also involve ABI issues (cf. Intel)
+	switch(base_type_index)
+	{
+	default: return 0;
+	case C_TYPE::CHAR:
+	case C_TYPE::SCHAR:
+	case C_TYPE::UCHAR:
+		// defined to be 1: C99 6.5.3.4p3, C++98 5.3.3p1, same paragraphs in C1X and C++0X
+		return 1;
+	case C_TYPE::SHRT:
+	case C_TYPE::USHRT:
+		return target_machine->C_sizeof_short();
+	case C_TYPE::INT:
+	case C_TYPE::UINT:
+		return target_machine->C_sizeof_int();
+	case C_TYPE::LONG:
+	case C_TYPE::ULONG:
+		return target_machine->C_sizeof_long();
+	case C_TYPE::LLONG:
+	case C_TYPE::ULLONG:
+		return target_machine->C_sizeof_long_long();
+	}
+#if 0
+	FLOAT,
+	DOUBLE,
+	LDOUBLE,
+	FLOAT__COMPLEX,
+	DOUBLE__COMPLEX,
+	LDOUBLE__COMPLEX,
+#endif
+}
+
+//! \throw std::bad_alloc()
+static bool eval_sizeof_core_type(parse_tree& src,const size_t base_type_index,const type_system& types)
+{	//! \todo eventually handle the floating and complex types here as well
+	//! \todo types parameter is close to redundant
+	// floating is just a matter of modeling
+	// complex may also involve ABI issues (cf. Intel)
+	const size_t fundamental_size = _eval_sizeof_core_type(base_type_index);
+	if (0<fundamental_size)
+		{
+		parse_tree tmp;
+		const size_t size_t_type = unsigned_type_from_machine_type(target_machine->size_t_type());
+		src.type_code.set_type(size_t_type);
+		uint_to_literal(tmp,fundamental_size,src,types);
+		tmp.MoveInto(src);
+		assert(size_t_type==src.type_code.base_type_index);
+		return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool eval_C99_CPP_sizeof(parse_tree& src,const type_system& types, func_traits<size_t (*)(parse_tree&,const type_system&)>::function_ref_type failover_sizeof)
+{
+	assert(is_C99_CPP_sizeof_expression(src));
+	//! \todo error if given a function type
+	//! \todo handle function pointers distinctly from data pointers
+	const size_t size_t_type = unsigned_type_from_machine_type(target_machine->size_t_type());
+	size_t i = src.data<2>()->type_code.pointer_power;
+	if (0==i) return eval_sizeof_core_type(src,src.data<2>()->type_code.base_type_index,types);
+	{
+	umaxint scaling(1,target_machine->unsigned_max(target_machine->size_t_type()).size());
+	{
+	umaxint tmp2(target_machine->unsigned_max(target_machine->size_t_type()));
+	const umaxint target_size_max(tmp2);
+	umaxint tmp;
+	bool want_fundamental = true;
+	do  {
+		--i;
+		if (type_spec::_array & src.data<2>()->type_code.qualifier(i+1))
+			{
+			if (0>=src.data<2>()->type_code.extent_vector[i])
+				// C99 variable-length array: can't sizeof it at compile time
+				return false;
+			tmp = src.data<2>()->type_code.extent_vector[i];
+			}
+		else{	// data pointer (for now); 0==i actually could be function pointer
+			tmp = _eval_sizeof_core_type(unsigned_type_from_machine_type(target_machine->size_t_type()));
+			assert(0<tmp);
+			want_fundamental = false;
+			}
+		if (1<tmp)
+			{
+			tmp2 /= scaling;
+			if (tmp2<tmp)
+				{
+				simple_error(src," sizeof operator evaluation failed: object is larger than target SIZE_MAX bytes.");
+				return false;
+				}
+			tmp2 = target_size_max;
+			scaling *= tmp;
+			}
+		}
+	while(0<i && want_fundamental);
+	if (want_fundamental)
+		{
+		tmp = _eval_sizeof_core_type(src.data<2>()->type_code.base_type_index);
+		if (0==tmp) tmp = failover_sizeof(src,types);
+		if (0==tmp) return false;
+		else if (1<tmp)
+			{
+			tmp2 /= scaling;
+			if (tmp2<tmp)
+				{
+				simple_error(src," sizeof operator evaluation failed: object is larger than target SIZE_MAX bytes.");
+				return false;
+				}
+			scaling *= tmp;
+			}
+		//! \todo handle struct, union, class here (or maybe as part of core type wrapper)
+		// enum is post-processed due to differences between C, C++
+		}
+	}
+	parse_tree tmp3;
+	src.type_code.set_type(size_t_type);
+	VM_to_literal(tmp3,scaling,src,types);
+	tmp3.MoveInto(src);
+	}
+	assert(size_t_type==src.type_code.base_type_index);
+	return true;
+}
+
+static size_t _C99_failover_sizeof(parse_tree& src,const type_system& types)
+{
+	const enum_def* const tmp = types.get_enum_def(src.data<2>()->type_code.base_type_index);
+	if (tmp)
+		{
+		if (0==src.data<2>()->type_code.pointer_power && is_noticed_enumerator(src,types))
+			return _eval_sizeof_core_type(C_TYPE::INT); // type is int per C99 6.7.2.2p3
+		if (!tmp->represent_as)
+			{
+			simple_error(src," applies sizeof to incomplete enumeration (C99 6.5.3.4p1)");
+			return false;
+			}
+		// process tmp->represent_as as a core type
+		// C99 6.7.2.2p4 merely requires the underlying type to be able to represent all values
+		assert(C_TYPE::CHAR<=tmp->represent_as && C_TYPE::INT>=tmp->represent_as);
+		return _eval_sizeof_core_type(tmp->represent_as);
+		}
+	return 0;
+}
+
+//! \throw std::bad_alloc()
+static bool eval_C99_sizeof(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_CPP_sizeof_expression(src));
+	return eval_C99_CPP_sizeof(src,types,_C99_failover_sizeof);
+}
+
+static size_t _CPP_failover_sizeof(parse_tree& src,const type_system& types)
+{
+	if (C_TYPE::WCHAR_T==src.data<2>()->type_code.base_type_index)
+		return _eval_sizeof_core_type(unsigned_type_from_machine_type(target_machine->UNICODE_wchar_t()));
+	const enum_def* const tmp = types.get_enum_def(src.data<2>()->type_code.base_type_index);
+	if (tmp)
+		{
+		if (0==src.data<2>()->type_code.pointer_power && is_noticed_enumerator(*src.data<2>(),types))
+			{
+			const type_system::enumerator_info* const tmp2 = types.get_enumerator(src.data<2>()->index_tokens[0].token.first);
+			assert(tmp2);
+			assert(C_TYPE::INT<=tmp2->second.first.second && C_TYPE::ULLONG>=tmp2->second.first.second);
+			return _eval_sizeof_core_type(tmp2->second.first.second);
+			}
+		if (!tmp->represent_as)
+			{
+			simple_error(src," applies sizeof to incomplete enumeration (C++98 5.3.3p1)");
+			return false;
+			}
+		// C++0X 7.2p6 merely requires the underlying type to be able to represent all values
+		assert(C_TYPE::CHAR<=tmp->represent_as && C_TYPE::ULLONG>=tmp->represent_as);
+		return _eval_sizeof_core_type(tmp->represent_as);
+		}
+	return 0;
+}
+
+//! \throw std::bad_alloc()
+static bool eval_CPP_sizeof(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_CPP_sizeof_expression(src));
+	return eval_C99_CPP_sizeof(src,types,_CPP_failover_sizeof);
+}
+
+//! \throw std::bad_alloc()
+static void C99_sizeof_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_CPP_sizeof_expression(src));
+	//! \todo intercept incomplete types, function types here
+	if (eval_C99_sizeof(src,types)) return;
+}
+
+//! \throw std::bad_alloc()
+static void CPP_sizeof_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_CPP_sizeof_expression(src));
+	//! \todo intercept incomplete types, function types here
+	if (eval_CPP_sizeof(src,types)) return;
+}
+
+//! \throw std::bad_alloc()
+static bool locate_C99_sizeof(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+
+	if (	!(PARSE_OBVIOUS & src.data<0>()[i].flags)
+		&&	src.data<0>()[i].is_atomic()
+		&&	terse_locate_C99_CPP_sizeof(src,i,types))
+		{
+		C99_sizeof_easy_syntax_check(src.c_array<0>()[i],types);
+		return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool locate_CPP_sizeof(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+
+	if (	!(PARSE_OBVIOUS & src.data<0>()[i].flags)
+		&&	src.data<0>()[i].is_atomic()
+		&&	terse_locate_C99_CPP_sizeof(src,i,types))
+		{
+		CPP_sizeof_easy_syntax_check(src.c_array<0>()[i],types);
+		return true;
+		}
+	return false;
+}
+
+/* Scan for unary operators and cast expressions
+unary-expression:
+	postfix-expression
+	++ unary-expression
+	-- unary-expression
+	unary-operator cast-expression
+	sizeof unary-expression
+	sizeof ( type-name )
+unary-operator: one of
+	& * + - ~ !
+
+cast-expression:
+	unary-expression
+	( type-name ) cast-expression
+
+Note that the binary operators *,+,- are effectively handled by first building the unary operator, then checking whether the left-hand-side qualifies for extension to binary operator
+*/
+//! \throw std::bad_alloc()
+static void locate_C99_unary_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (	(PARSE_OBVIOUS & src.data<0>()[i].flags)
+		||	!src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_C99_deref(src,i,types)) return;
+	if (locate_C99_logical_NOT(src,i,types)) return;
+	if (locate_C99_bitwise_complement(src,i,types)) return;
+	if (locate_C99_unary_plusminus(src,i,types)) return;
+	if (locate_C99_sizeof(src,i,types)) return;
+
+#if 0
+	if (terse_locate_unary_operator(src,i))
+		{
+		C_unary_op_easy_syntax_check(src.c_array<0>()[i],types);
+		return;
+		}
+	else if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"++"))
+		{
+		}
+	else if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"--"))
+		{
+		}
+	else if (   token_is_char<'('>(src.data<0>()[i].index_tokens[0].token)
+			 && token_is_char<')'>(src.data<0>()[i].index_tokens[1].token))
+		{
+		}
+#endif
+}
+
+/* Scan for unary expressions and cast expressions
+unaryexpression:
+	postfixexpression
+	++ castexpression
+	-- castexpression
+	unaryoperator castexpression
+	sizeof unaryexpression
+	sizeof ( typeid )
+	newexpression
+	deleteexpression
+
+unaryoperator:
+	one of * & + - ! ~
+	note that compl, not end up here as well.  compl may be used to make psuedo-destructor interpretation illegal
+	note that bitand does *not* end up here, so it can prevent inadvertently taking an address
+
+castexpression:
+	unaryexpression
+	( typeid ) castexpression
+
+deleteexpression:
+	::opt delete castexpression
+	::opt delete [ ] castexpression
+
+newexpression:
+	::opt new newplacementopt newtypeid newinitializeropt
+	::opt new newplacementopt ( typeid) newinitializeropt
+newplacement:
+	( expressionlist )
+newtypeid:
+	typespecifierseq
+	newdeclaratoropt
+newdeclarator:
+	ptroperator
+	newdeclaratoropt
+	directnewdeclarator
+directnewdeclarator:
+	[ expression ]
+	directnewdeclarator [ constantexpression ]
+newinitializer:
+	( expressionlistopt )
+
+Note that the binary operators *,+,- are effectively handled by first building the unary operator, then checking whether the left-hand-side qualifies for extension to binary operator
+*/
+//! \throw std::bad_alloc()
+static void locate_CPP_unary_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (	(PARSE_OBVIOUS & src.data<0>()[i].flags)
+		||	!src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_CPP_deref(src,i,types)) return;
+	if (locate_CPP_logical_NOT(src,i,types)) return;
+	if (locate_CPP_bitwise_complement(src,i,types)) return;
+	if (locate_CPP_unary_plusminus(src,i,types)) return;
+	if (locate_CPP_sizeof(src,i,types)) return;
+
+#if 0
+	if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"++"))
+		{
+		}
+	else if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"--"))
+		{
+		}
+	else if (   token_is_char<'('>(src.data<0>()[i].index_tokens[0].token)
+			 && token_is_char<')'>(src.data<0>()[i].index_tokens[1].token))
+		{
+		}
+	else if (token_is_string<3>(src.data<0>()[i].index_tokens[0].token,"new"))
+		{
+		}
+	else if (token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"delete"))
+		{
+		}
+#endif
+}
+
+//! \throw std::bad_alloc()
+static void assemble_binary_infix_arguments(parse_tree& src, size_t& i, const lex_flags _flags)
+{
+	assert(1<=i && 2<=src.size<0>()-i);
+	{
+	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+	zaimoni::autoval_ptr<parse_tree> tmp;
+	tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
+	parse_tree* const tmp2 = repurpose_inner_parentheses(tmp_c_array[2]);	// RAM conservation
+	tmp_c_array[0].OverwriteInto(*tmp);
+	tmp_c_array[2].OverwriteInto(*tmp2);
+	tmp_c_array[1].fast_set_arg<1>(tmp.release());
+	tmp_c_array[1].fast_set_arg<2>(tmp2);
+	tmp_c_array[1].core_flag_update();
+	tmp_c_array[1].flags |= _flags;
+	}
+	src.DeleteIdx<0>(i+1);
+	src.DeleteIdx<0>(--i);
+
+	parse_tree& tmp = src.c_array<0>()[i];
+	cancel_outermost_parentheses(tmp.c_array<1>()[0]);
+	cancel_outermost_parentheses(tmp.c_array<2>()[0]);
+}
+
+//! \throw std::bad_alloc()
+static void merge_binary_infix_argument(parse_tree& src, size_t& i, const lex_flags _flags)
+{
+	assert(1<=i);
+ 	{
+	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+	parse_tree* const tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
+	tmp_c_array[0].OverwriteInto(*tmp);
+
+	tmp_c_array[1].fast_set_arg<1>(tmp);
+	tmp_c_array[1].core_flag_update();
+	tmp_c_array[1].flags |= _flags;
+	}
+	src.DeleteIdx<0>(--i);
+	cancel_outermost_parentheses(src.c_array<0>()[i].c_array<1>()[0]);
+}
+
+//! \throw std::bad_alloc()
+static bool terse_C99_augment_mult_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i]))
+		{
+		if (1<=i && (PARSE_MULT_EXPRESSION & src.data<0>()[i-1].flags))
+			{
+			merge_binary_infix_argument(src,i,PARSE_STRICT_MULT_EXPRESSION);
+			assert(is_C99_mult_operator_expression(src.data<0>()[i]));
+			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
+			assert(is_C99_mult_operator_expression(src.data<0>()[i]));
+			return true;
+			};
+		// run syntax-checks against unary *
+		C_deref_easy_syntax_check(src.c_array<0>()[i],types);
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool terse_CPP_augment_mult_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (is_C99_unary_operator_expression<'*'>(src.data<0>()[i]))
+		{
+		if (1<=i && (inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]),(PARSE_MULT_EXPRESSION & src.data<0>()[i-1].flags)))
+			{
+			merge_binary_infix_argument(src,i,PARSE_STRICT_MULT_EXPRESSION);
+			assert(is_C99_mult_operator_expression(src.data<0>()[i]));
+			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
+			assert(is_C99_mult_operator_expression(src.data<0>()[i]));
+			return true;
+			};
+		// run syntax-checks against unary *
+		//! \todo handle operator overloading
+		C_deref_easy_syntax_check(src.c_array<0>()[i],types);
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool terse_locate_mult_expression(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	const size_t mult_subtype 	= (token_is_char<'/'>(src.data<0>()[i].index_tokens[0].token)) ? C99_MULT_SUBTYPE_DIV
+								: (token_is_char<'%'>(src.data<0>()[i].index_tokens[0].token)) ? C99_MULT_SUBTYPE_MOD
+								: (token_is_char<'*'>(src.data<0>()[i].index_tokens[0].token)) ? C99_MULT_SUBTYPE_MULT : 0;
+	if (mult_subtype)
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if ((PARSE_MULT_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_PM_EXPRESSION & tmp_c_array[2].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_MULT_EXPRESSION);	// tmp_c_array goes invalid here
+			assert(is_C99_mult_operator_expression(src.data<0>()[i]));
+			{
+			parse_tree& tmp = src.c_array<0>()[i];
+			tmp.subtype = mult_subtype;
+			tmp.type_code.set_type(0);	// handle type inference later
+			}
+			assert(is_C99_mult_operator_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool eval_mult_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	assert(is_C99_mult_operator_expression<'*'>(src));
+
+	bool is_true = false;
+
+	// do this first to avoid unnecessary dynamic memory allocation
+	if (	(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)	// 0 * __
+		||	(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true))	// __ * 0
+		{
+		// construct +0 to defuse 1-0*6
+		parse_tree tmp = decimal_literal("0",src,types);
+		if (C_TYPE::INTEGERLIKE==src.type_code.base_type_index)
+			{
+			message_header(src.index_tokens[0]);
+			INC_INFORM("invalid ");
+			INC_INFORM(src);
+			INFORM(" optimized to valid 0");
+			tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
+			}
+		else value_copy(tmp.type_code,src.type_code);
+		src.DeleteIdx<1>(0);
+		force_unary_positive_literal(src,tmp ARG_TYPES);
+		return true;
+		};
+
+	umaxint res_int;
+	umaxint rhs_int;
+	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
+	if (lhs_converted && 1==res_int)
+		{
+		src.type_code.MoveInto(src.c_array<2>()->type_code);
+		src.eval_to_arg<2>(0);
+		return true;
+		};
+	if (rhs_converted && 1==rhs_int)
+		{
+		src.type_code.MoveInto(src.c_array<1>()->type_code);
+		src.eval_to_arg<1>(0);
+		return true;
+		};
+	if (lhs_converted && rhs_converted)
+		{
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
+		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
+		assert(old.bitcount>=lhs.bitcount);
+		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
+		assert(old.bitcount>=rhs.bitcount);
+
+		// handle sign-extension of lhs, rhs
+		const bool lhs_negative = target_machine->C_promote_integer(res_int,lhs,old);
+		const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
+		if (old.is_signed)
+			{	// signed integer result: overflow is undefined
+			umaxint lhs_test(res_int);
+			umaxint rhs_test(rhs_int);
+			umaxint ub(target_machine->signed_max(old.machine_type));
+			const bool tweak_ub = rhs_negative!=lhs_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation() && !bool_options[boolopt::int_traps];
+			if (rhs_negative) target_machine->signed_additive_inverse(rhs_test,old.machine_type);
+			if (lhs_negative) target_machine->signed_additive_inverse(lhs_test,old.machine_type);
+			if (tweak_ub) ub += 1;
+			if (ub<lhs_test || ub<rhs_test)
+				{
+				if (!no_runtime_errors)
+					//! \todo catch this in two's-complement specific testing
+					simple_error(src," signed * overflow, undefined behavior (C99 6.5p5, C++98 5p5)");
+				return false;
+				}
+			const bool lhs_lt_rhs = lhs_test<rhs_test;
+			ub /= (lhs_lt_rhs) ? rhs_test : lhs_test;
+			if (ub<(lhs_lt_rhs ? lhs_test : rhs_test))
+				{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
+				if (!no_runtime_errors)
+					//! \test default/Error_if_control29.hpp, default/Error_if_control29.h
+					simple_error(src," signed * overflow, undefined behavior (C99 6.5p5, C++98 5p5)");
+				return false;
+				}
+			lhs_test *= rhs_test;
+			if (rhs_negative!=lhs_negative)
+				{	// valid result, but not representable: do not reduce (errors out spuriously)
+				if (tweak_ub && target_machine->signed_max(old.machine_type)<lhs_test) return false;
+
+				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
+				// convert to parsed - literal
+				parse_tree tmp;
+				VM_to_literal(tmp,lhs_test,src,types);
+
+				src.DeleteIdx<1>(0);
+				force_unary_negative_literal(src,tmp);
+				return true;
+				}
+			res_int = lhs_test;
+			}
+		else
+			res_int *= rhs_int;
+
+		// convert to parsed + literal
+		parse_tree tmp;
+		VM_to_literal(tmp,res_int,src,types);
+		value_copy(tmp.type_code,src.type_code);
+		src.DeleteIdx<1>(0);
+		force_unary_positive_literal(src,tmp ARG_TYPES);
+		return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool eval_div_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	assert(is_C99_mult_operator_expression<'/'>(src));
+
+	bool is_true = false;
+	if (converts_to_integerlike(src.type_code ARG_TYPES))
+		{
+		if 		(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
+			{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
+			if (!no_runtime_errors)
+				//! \test default/Error_if_control30.hpp, default/Error_if_control30.h
+				simple_error(src," division by zero, undefined behavior (C99 6.5.5p5, C++98 5.6p4)");
+			return false;
+			}
+		/*! \todo would like a simple comparison of absolute values to auto-detect zero, possibly after mainline code */
+		else if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
+			{
+			// construct +0 to defuse 1-0/6
+			parse_tree tmp = decimal_literal("0",src,types);
+			if (C_TYPE::INTEGERLIKE==src.type_code.base_type_index)
+				{
+				message_header(src.index_tokens[0]);
+				INC_INFORM("invalid ");
+				INC_INFORM(src);
+				INFORM(" optimized to valid 0");
+				tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
+				}
+			else value_copy(tmp.type_code,src.type_code);
+			src.DeleteIdx<1>(0);
+			force_unary_positive_literal(src,tmp ARG_TYPES);
+			return true;
+			}
+		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
+		};
+
+	umaxint res_int;
+	umaxint rhs_int;
+	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
+	if (rhs_converted && rhs_int==1)
+		{	// __/1 |-> __
+		src.type_code.MoveInto(src.c_array<1>()->type_code);
+		src.eval_to_arg<1>(0);
+		return true;
+		};
+	// two's complement can overflow: INT_MIN/-1
+	// implementation-defined whether negative results round away or to zero (standard prefers to zero, so default to that)
+	if (lhs_converted && rhs_converted)
+		{
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
+		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
+		assert(old.bitcount>=lhs.bitcount);
+		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
+		assert(old.bitcount>=rhs.bitcount);
+
+		// handle sign-extension of lhs, rhs
+		const bool lhs_negative = target_machine->C_promote_integer(res_int,lhs,old);
+		const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
+		if (old.is_signed)
+			{	// signed integer result
+			umaxint lhs_test(res_int);
+			umaxint rhs_test(rhs_int);
+			umaxint ub(target_machine->signed_max(old.machine_type));
+			if (rhs_negative) target_machine->signed_additive_inverse(rhs_test,old.machine_type);
+			if (lhs_negative) target_machine->signed_additive_inverse(lhs_test,old.machine_type);
+			if (rhs_negative!=lhs_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation()) ub += 1;
+			if (lhs_test<rhs_test)
+				{
+				const bool want_zero = rhs_negative==lhs_negative || !bool_options[boolopt::int_neg_div_rounds_away_from_zero];
+				parse_tree tmp = decimal_literal(want_zero ? "0" : "1",src,types);
+				src.DeleteIdx<1>(0);
+				if (want_zero)
+					{
+					value_copy(tmp.type_code,src.type_code);
+					force_unary_positive_literal(src,tmp ARG_TYPES); // +0
+					}
+				else	
+					force_unary_negative_literal(src,tmp); // -1
+				return true;
+				}
+
+			bool round_away = false;
+			if (rhs_negative!=lhs_negative && bool_options[boolopt::int_neg_div_rounds_away_from_zero])
+				{
+				umaxint lhs_mod_test(lhs_test);
+				lhs_mod_test %= rhs_test;
+				round_away = 0!=lhs_mod_test;
+				}
+			lhs_test /= rhs_test;
+			if (rhs_negative!=lhs_negative)
+				{
+				if (round_away) lhs_test += 1;
+				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
+				// convert to parsed - literal
+				parse_tree tmp;
+				VM_to_literal(tmp,lhs_test,src,types);
+
+				src.DeleteIdx<1>(0);
+				force_unary_negative_literal(src,tmp);
+				return true;
+				}
+			if (ub<lhs_test)
+				{	//! \todo test this in two's complement code
+				assert(virtual_machine::twos_complement==target_machine->C_signed_int_representation());
+				if (!no_runtime_errors)
+					simple_error(src," signed / overflow, undefined behavior (C99 6.5p5, C++98 5p5)");
+				return false;
+				}
+
+			res_int = lhs_test;
+			}
+		else
+			res_int /= rhs_int;
+
+		// convert to parsed + literal
+		parse_tree tmp;
+		VM_to_literal(tmp,res_int,src,types);
+
+		value_copy(tmp.type_code,src.type_code);
+		src.DeleteIdx<1>(0);
+		force_unary_positive_literal(src,tmp ARG_TYPES);
+		return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool eval_mod_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	assert(is_C99_mult_operator_expression<'%'>(src));
+
+	bool is_true = false;
+	if (converts_to_integerlike(src.type_code ARG_TYPES))
+		{
+		if 		(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
+			{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
+			if (!no_runtime_errors)
+				//! \test default/Error_if_control31.hpp, Error_if_control31.h
+				simple_error(src," modulo by zero, undefined behavior (C99 6.5.5p5, C++98 5.6p4)");
+			return false;
+			}
+		/*! \todo would like a simple comparison of absolute values to auto-detect zero, possibly after mainline code */
+		else if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
+			{
+			// construct +0 to defuse 1-0%6
+			parse_tree tmp = decimal_literal("0",src,types);
+			if (C_TYPE::INTEGERLIKE==src.type_code.base_type_index)
+				{
+				message_header(src.index_tokens[0]);
+				INC_INFORM("invalid ");
+				INC_INFORM(src);
+				INFORM(" optimized to valid 0");
+				tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
+				}
+			else value_copy(tmp.type_code,src.type_code);
+			src.DeleteIdx<1>(0);
+			force_unary_positive_literal(src,tmp ARG_TYPES);
+			return true;
+			}
+		//! \todo change target for formal verification; would like to inject a constraint against div-by-integer-zero here
+		};
+
+	umaxint res_int;
+	umaxint rhs_int;
+	const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
+	if (rhs_converted && rhs_int==1)
+		{	// __%1 |-> +0
+		parse_tree tmp = decimal_literal("0",src,types);
+		if (C_TYPE::INTEGERLIKE!=src.type_code.base_type_index)
+			value_copy(tmp.type_code,src.type_code);
+		else
+			tmp.type_code.set_type(C_TYPE::LLONG);	// legalize
+		src.DeleteIdx<1>(0);
+		force_unary_positive_literal(src,tmp ARG_TYPES);
+		return true;
+		};
+	if (lhs_converted && rhs_converted)
+		{
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
+		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
+		assert(old.bitcount>=lhs.bitcount);
+		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
+		assert(old.bitcount>=rhs.bitcount);
+
+		// handle sign-extension of lhs, rhs
+		const bool lhs_negative = target_machine->C_promote_integer(res_int,lhs,old);
+		const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
+		if (old.is_signed)
+			{	// signed integer result
+			umaxint lhs_test(res_int);
+			umaxint rhs_test(rhs_int);
+			umaxint ub(target_machine->signed_max(old.machine_type));
+			if (rhs_negative) target_machine->signed_additive_inverse(rhs_test,old.machine_type);
+			if (lhs_negative) target_machine->signed_additive_inverse(lhs_test,old.machine_type);
+			if (rhs_negative!=lhs_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation()) ub += 1;
+
+			lhs_test %= rhs_test;
+			if (0!=lhs_test && rhs_negative!=lhs_negative)
+				{
+				if (!bool_options[boolopt::int_neg_div_rounds_away_from_zero])
+					{	// convert to parsed - literal
+					parse_tree tmp;
+					VM_to_literal(tmp,lhs_test,src,types);
+
+					src.DeleteIdx<1>(0);
+					force_unary_negative_literal(src,tmp);
+					return true;
+					};
+				rhs_test -= lhs_test;
+				lhs_test = rhs_test;
+				};
+
+			res_int = lhs_test;
+			}
+		else	// unsigned integer result: C99 6.3.1.3p2 dictates modulo conversion to unsigned
+			res_int %= rhs_int;
+
+		// convert to parsed + literal
+		parse_tree tmp;
+		VM_to_literal(tmp,res_int,src,types);
+
+		value_copy(tmp.type_code,src.type_code);
+		src.DeleteIdx<1>(0);
+		force_unary_positive_literal(src,tmp ARG_TYPES);
+		return true;
+		}
+	return false;
+}
+
+BOOST_STATIC_ASSERT(1==C99_MULT_SUBTYPE_MOD-C99_MULT_SUBTYPE_DIV);
+BOOST_STATIC_ASSERT(1==C99_MULT_SUBTYPE_MULT-C99_MULT_SUBTYPE_MOD);
+
+//! \throw std::bad_alloc
+static bool _mod_expression_typecheck(parse_tree& src SIG_CONST_TYPES)
+{
+	assert(C99_MULT_SUBTYPE_MOD==src.subtype && is_C99_mult_operator_expression<'%'>(src));
+	POD_pair<size_t,bool> lhs = default_promotion_is_integerlike(src.data<1>()->type_code ARG_TYPES);
+	POD_pair<size_t,bool> rhs = default_promotion_is_integerlike(src.data<2>()->type_code ARG_TYPES);
+	if (!lhs.second)
+		{	//! \test default/Error_if_control33.hpp, default/Error_if_control33.h
+			//! \test default/Error_if_control34.hpp, default/Error_if_control34.h
+		simple_error(src,rhs.second ? " has nonintegral LHS (C99 6.5.5p2, C++98 5.6p2)" : " has nonintegral LHS and RHS (C99 6.5.5p2, C++98 5.6p2)");
+		return false;
+		}
+	else if (!rhs.second)
+		{	//! \test default/Error_if_control32.hpp, default/Error_if_control32.h
+		simple_error(src," has nonintegral RHS (C99 6.5.5p2, C++98 5.6p2)");
+		return false;
+		};
+	if (is_noticed_enumerator(*src.data<1>(),types))
+		{
+		enumerator_to_integer_representation(*src.c_array<1>(),types);
+		lhs = default_promotion_is_integerlike(src.data<1>()->type_code,types);
+		assert(lhs.second);
+		}
+	if (is_noticed_enumerator(*src.data<2>(),types)) 
+		{
+		enumerator_to_integer_representation(*src.c_array<2>(),types);
+		rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
+		assert(rhs.second);
+		}
+	src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
+	return true;
+}
+
+//! \throw std::bad_alloc
+static bool _mult_div_expression_typecheck(parse_tree& src SIG_CONST_TYPES)
+{
+	assert(C99_MULT_SUBTYPE_DIV==src.subtype || C99_MULT_SUBTYPE_MULT==src.subtype);
+	assert((C99_MULT_SUBTYPE_DIV==src.subtype) ? is_C99_mult_operator_expression<'/'>(src) : is_C99_mult_operator_expression<'*'>(src));
+	POD_pair<size_t,bool> lhs = default_promotion_is_arithmeticlike(src.data<1>()->type_code ARG_TYPES);
+	POD_pair<size_t,bool> rhs = default_promotion_is_arithmeticlike(src.data<2>()->type_code ARG_TYPES);
+	if (!lhs.second)
+		{	//! \test default/Error_if_control36.hpp, default/Error_if_control36.h
+			//! \test default/Error_if_control37.hpp, default/Error_if_control37.h
+			//! \test default/Error_if_control39.hpp, default/Error_if_control39.h
+			//! \test default/Error_if_control40.hpp, default/Error_if_control40.h
+		simple_error(src,rhs.second ? " has nonarithmetic LHS (C99 6.5.5p2, C++98 5.6p2)" : " has nonarithmetic LHS and RHS (C99 6.5.5p2, C++98 5.6p2)");
+		return false;
+		}
+	else if (!rhs.second)
+		{	//! \test default/Error_if_control35.hpp, default/Error_if_control35.h
+			//! \test default/Error_if_control38.hpp, default/Error_if_control38.h
+		simple_error(src," has nonarithmetic RHS (C99 6.5.5p2, C++98 5.6p2)");
+		return false;
+		};
+
+	// arithmeticlike subsumes integerlike so this is fine
+	if (is_noticed_enumerator(*src.data<1>(),types))
+		{
+		enumerator_to_integer_representation(*src.c_array<1>(),types);
+		lhs = default_promotion_is_integerlike(src.data<1>()->type_code,types);
+		assert(lhs.second);
+		}
+	if (is_noticed_enumerator(*src.data<2>(),types)) 
+		{
+		enumerator_to_integer_representation(*src.c_array<2>(),types);
+		rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
+		assert(rhs.second);
+		}
+	src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
+	return true;
+}
+
+//! \throw std::bad_alloc()
+static void C_mult_expression_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(C99_MULT_SUBTYPE_DIV<=src.subtype && C99_MULT_SUBTYPE_MULT>=src.subtype);
+	assert((C99_MULT_SUBTYPE_DIV==src.subtype) ? is_C99_mult_operator_expression<'/'>(src) : (C99_MULT_SUBTYPE_MULT==src.subtype) ? is_C99_mult_operator_expression<'*'>(src) : is_C99_mult_operator_expression<'%'>(src));
+	// note that 0*integerlike and so on are invalid, but do optimize to valid (but this is probably worth a separate execution path)
+	if (C99_MULT_SUBTYPE_MOD==src.subtype)
+		{	// require integral type
+		if (!_mod_expression_typecheck(src ARG_TYPES)) return;
+		zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+		eval_mod_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+		}
+	else{	// require arithmetic type
+		if (!_mult_div_expression_typecheck(src ARG_TYPES)) return;
+		zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+		if (C99_MULT_SUBTYPE_MULT==src.subtype)
+			eval_mult_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+		else
+			eval_div_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);			
+		}
+}
+
+//! \throw std::bad_alloc()
+static void CPP_mult_expression_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(C99_MULT_SUBTYPE_DIV<=src.subtype && C99_MULT_SUBTYPE_MULT>=src.subtype);
+	assert((C99_MULT_SUBTYPE_DIV==src.subtype) ? is_C99_mult_operator_expression<'/'>(src) : (C99_MULT_SUBTYPE_MULT==src.subtype) ? is_C99_mult_operator_expression<'*'>(src) : is_C99_mult_operator_expression<'%'>(src));
+
+	if (C99_MULT_SUBTYPE_MOD==src.subtype)
+		{	// require integral type
+		if (!_mod_expression_typecheck(src ARG_TYPES)) return;
+		zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+		eval_mod_expression(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
+		}
+	else{	// require arithmetic type
+		if (!_mult_div_expression_typecheck(src ARG_TYPES)) return;
+		zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+		if (C99_MULT_SUBTYPE_MULT==src.subtype)
+			eval_mult_expression(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
+		else
+			eval_div_expression(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
+		}
+}
+
+/*
+multiplicative-expression:
+	cast-expression
+	multiplicative-expression * cast-expression
+	multiplicative-expression / cast-expression
+	multiplicative-expression % cast-expression
+*/
+//! \throw std::bad_alloc()
+static void locate_C99_mult_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+
+	if (terse_C99_augment_mult_expression(src,i,types))
+		{
+		C_mult_expression_easy_syntax_check(src.c_array<0>()[i],types);
+		return;
+		}
+
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_mult_expression(src,i)) C_mult_expression_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+/*
+multexpression:
+	pmexpression
+	multexpression * pmexpression
+	multexpression / pmexpression
+	multexpression % pmexpression
+*/
+//! \throw std::bad_alloc()
+static void locate_CPP_mult_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+
+	if (terse_CPP_augment_mult_expression(src,i,types))
+		{	//! \todo handle operator overloading
+		CPP_mult_expression_easy_syntax_check(src.c_array<0>()[i],types);
+		return;
+		}
+
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_mult_expression(src,i))
+		//! \todo handle operator overloading
+		CPP_mult_expression_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+// Law of Demeter conversion is object-size neutral [Dec. 9 2009], so don't do it
+static bool C_string_literal_equal_content(const parse_tree& lhs, const parse_tree& rhs,bool& is_equal)
+{
+	if (C_TESTFLAG_STRING_LITERAL==lhs.index_tokens[0].flags && C_TESTFLAG_STRING_LITERAL==rhs.index_tokens[0].flags)
+		{
+		const size_t lhs_len = LengthOfCStringLiteral(lhs.index_tokens[0].token.first,lhs.index_tokens[0].token.second);
+		if (LengthOfCStringLiteral(rhs.index_tokens[0].token.first,rhs.index_tokens[0].token.second)!=lhs_len)
+			{	// string literals of different length are necessarily different decayed pointers even if they overlap
+			is_equal = false;
+			return true;
+			};
+		if (('L'==*lhs.index_tokens[0].token.first)!=('L'==*rhs.index_tokens[0].token.first))
+			{	// wide string literals never overlap with narrow string literals with the same character values
+				//! \todo check language standards: is it implementation-defined whether a wide-string character literal 
+				//! can overlap a narrow-string character literal with a suitable placement of NUL bytes?
+			is_equal = false;
+			return true;
+			};
+
+		size_t i = 0;
+		while(i<lhs_len-1)
+			{
+			char* lhs_lit = NULL;
+			char* rhs_lit = NULL;
+			GetCCharacterLiteralAt(lhs.index_tokens[0].token.first,lhs.index_tokens[0].token.second,i,lhs_lit);
+			GetCCharacterLiteralAt(rhs.index_tokens[0].token.first,rhs.index_tokens[0].token.second,i,rhs_lit);
+			const uintmax_t lhs_val = EvalCharacterLiteral(lhs_lit,strlen(lhs_lit));
+			const uintmax_t rhs_val = EvalCharacterLiteral(rhs_lit,strlen(rhs_lit));
+			free(lhs_lit);
+			free(rhs_lit);
+			if (lhs_val!=rhs_val)
+				{	// different at this place, so different
+				is_equal = false;
+				return true;
+				}
+			++i;
+			}
+		// assume hyper-optimizing linker; the string literals overlap
+		is_equal = true;
+		return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool terse_C99_augment_add_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i]))
+		{
+		if (1<=i && (inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]),(PARSE_ADD_EXPRESSION & src.data<0>()[i-1].flags)))
+			{
+			merge_binary_infix_argument(src,i,PARSE_STRICT_ADD_EXPRESSION);
+			assert(is_C99_add_operator_expression(src.data<0>()[i]));
+			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
+			assert(is_C99_add_operator_expression(src.data<0>()[i]));
+			return true;
+			};
+		// run syntax-checks against unary + or unary -
+		C_unary_plusminus_easy_syntax_check(src.c_array<0>()[i],types);
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool terse_CPP_augment_add_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (is_C99_unary_operator_expression<'+'>(src.data<0>()[i]) || is_C99_unary_operator_expression<'-'>(src.data<0>()[i]))
+		{
+		if (1<=i && (inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]),(PARSE_ADD_EXPRESSION & src.data<0>()[i-1].flags)))
+			{
+			merge_binary_infix_argument(src,i,PARSE_STRICT_ADD_EXPRESSION);
+			assert(is_C99_add_operator_expression(src.data<0>()[i]));
+			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
+			assert(is_C99_add_operator_expression(src.data<0>()[i]));
+			return true;
+			};
+		// run syntax-checks against unary + or unary -
+		CPP_unary_plusminus_easy_syntax_check(src.c_array<0>()[i],types);
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool terse_locate_add_expression(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	const size_t add_subtype 	= (token_is_char<'+'>(src.data<0>()[i].index_tokens[0].token)) ? C99_ADD_SUBTYPE_PLUS
+								: (token_is_char<'-'>(src.data<0>()[i].index_tokens[0].token)) ? C99_ADD_SUBTYPE_MINUS : 0;
+	if (add_subtype)
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_ADD_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_MULT_EXPRESSION & tmp_c_array[2].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_ADD_EXPRESSION);	// tmp_c_array goes invalid here
+			assert(is_C99_add_operator_expression(src.data<0>()[i]));
+			parse_tree& tmp = src.c_array<0>()[i];
+			tmp.subtype = add_subtype;
+			tmp.type_code.set_type(0);	// handle type inference later
+			assert(is_C99_add_operator_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool eval_add_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	assert(is_C99_add_operator_expression<'+'>(src));
+
+	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power;
+	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power;	
+	// void pointers should have been intercepted by now
+	assert(1!=lhs_pointer || C_TYPE::VOID!=src.data<1>()->type_code.base_type_index);
+	assert(1!=rhs_pointer || C_TYPE::VOID!=src.data<2>()->type_code.base_type_index);
+
+	switch((0<lhs_pointer)+2*(0<rhs_pointer))
+	{
+#ifndef NDEBUG
+	default: FATAL_CODE("hardware/compiler error: invalid linear combination in eval_add_expression",3);
+#endif
+	case 0:	{
+			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES));
+			assert(converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES));
+			bool is_true = false;
+			if 		(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
+				{	// 0 + __ |-> __
+				src.type_code.MoveInto(src.c_array<2>()->type_code);
+				src.eval_to_arg<2>(0);
+				return true;
+				}
+			else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
+				{	// __ + 0 |-> __
+				src.type_code.MoveInto(src.c_array<1>()->type_code);
+				src.eval_to_arg<1>(0);
+				return true;
+				};
+			umaxint res_int;
+			umaxint rhs_int;
+			const promote_aux old(src.type_code.base_type_index ARG_TYPES);
+			const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
+			assert(old.bitcount>=lhs.bitcount);
+			const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
+			assert(old.bitcount>=rhs.bitcount);
+			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
+			const bool lhs_negative = lhs_converted && target_machine->C_promote_integer(res_int,lhs,old);
+			const bool rhs_negative = rhs_converted && target_machine->C_promote_integer(rhs_int,rhs,old);
+			if (lhs_converted && rhs_converted)
+				{
+				if (old.is_signed)
+					{	// signed integer result
+					umaxint lhs_test(res_int);
+					umaxint rhs_test(rhs_int);
+					umaxint ub(target_machine->signed_max(old.machine_type));
+					bool result_is_negative = false;
+					if (rhs_negative) target_machine->signed_additive_inverse(rhs_test,old.machine_type);
+					if (lhs_negative) target_machine->signed_additive_inverse(lhs_test,old.machine_type);
+					if (rhs_negative!=lhs_negative)
+						{	// cancellation...safe
+						switch(cmp(lhs_test,rhs_test))
+						{
+						case -1:{
+								result_is_negative = rhs_negative;
+								rhs_test -= lhs_test;
+								lhs_test = rhs_test;
+								break;
+								}
+						case 0:	{
+								lhs_test.clear();
+								break;
+								}
+						case 1:	{
+								result_is_negative = lhs_negative;
+								lhs_test -= rhs_test;
+								break;
+								}
+						};
+						}
+					else{	// augmentation: bounds-check
+						result_is_negative = lhs_negative;
+						const bool tweak_ub = result_is_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation() && !bool_options[boolopt::int_traps];
+						if (tweak_ub) ub += 1;
+						if (ub<lhs_test || ub<rhs_test || (ub -= lhs_test)<rhs_test)
+							{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
+							if (!no_runtime_errors)
+								//! \test default/Error_if_control41.hpp, default/Error_if_control41.h
+								simple_error(src," signed + overflow, undefined behavior (C99 6.5p5, C++98 5p5)");
+							return false;
+							};
+						lhs_test += rhs_test;
+						// if we can't render it, do not reduce
+						if (tweak_ub && target_machine->signed_max(old.machine_type)<lhs_test) return false;
+						}
+
+					if (result_is_negative)
+						{
+						// convert to parsed - literal
+						parse_tree tmp;
+						VM_to_literal(tmp,lhs_test,src,types);
+
+						src.DeleteIdx<1>(0);
+						force_unary_negative_literal(src,tmp);
+						return true;
+						};
+					res_int = lhs_test;
+					}
+				else
+					res_int += rhs_int;
+
+				// convert to parsed + literal
+				parse_tree tmp;
+				VM_to_literal(tmp,res_int,src,types);
+				value_copy(tmp.type_code,src.type_code);
+				src.DeleteIdx<1>(0);
+				force_unary_positive_literal(src,tmp ARG_TYPES);
+				return true;
+				}
+			break;
+			}
+	case 1:	{
+			assert(converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES));
+			bool is_true = false;
+			if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
+				{	// __ + 0 |-> __
+				src.type_code.MoveInto(src.c_array<1>()->type_code);
+				src.eval_to_arg<1>(0);
+				return true;
+				}
+			break;
+			}
+	case 2:	{
+			assert(converts_to_integerlike(src.data<1>()->type_code.base_type_index ARG_TYPES));
+			bool is_true = false;
+			if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
+				{	// 0 + __ |-> __
+				src.type_code.MoveInto(src.c_array<2>()->type_code);
+				src.eval_to_arg<2>(0);
+				return true;
+				}
+			break;
+			}
+#ifndef NDEBUG
+	case 3:	FATAL_CODE("invalid expression not flagged as invalid expression",3);
+#endif
+	}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool eval_sub_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	assert(is_C99_add_operator_expression<'-'>(src));
+	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power;
+	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power;	
+	// void pointers should have been intercepted by now
+	assert(1!=lhs_pointer || C_TYPE::VOID!=src.data<1>()->type_code.base_type_index);
+	assert(1!=rhs_pointer || C_TYPE::VOID!=src.data<2>()->type_code.base_type_index);
+
+	switch((0<lhs_pointer)+2*(0<rhs_pointer))
+	{
+#ifndef NDEBUG
+	default: FATAL_CODE("hardware/compiler error: invalid linear combination in eval_sub_expression",3);
+#endif
+	case 0:	{
+			assert(converts_to_arithmeticlike(src.data<1>()->type_code.base_type_index ARG_TYPES));
+			assert(converts_to_arithmeticlike(src.data<2>()->type_code.base_type_index ARG_TYPES));
+			bool is_true = false;
+			if 		(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)
+				{	// 0 - __ |-> - __
+				src.DeleteIdx<1>(0);
+				src.core_flag_update();
+				src.flags |= PARSE_STRICT_UNARY_EXPRESSION;
+				src.subtype = C99_UNARY_SUBTYPE_NEG;
+				assert(is_C99_unary_operator_expression<'-'>(src));
+				return true;
+				}
+			else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
+				{	// __ - 0 |-> __
+				src.type_code.MoveInto(src.c_array<1>()->type_code);
+				src.eval_to_arg<1>(0);
+				return true;
+				}
+			umaxint res_int;
+			umaxint rhs_int;
+			const bool lhs_converted = intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
+			if (lhs_converted && rhs_converted)
+				{	//! \todo deal with signed integer arithmetic
+				const promote_aux old(src.type_code.base_type_index ARG_TYPES);
+				const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
+				assert(old.bitcount>=lhs.bitcount);
+				const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
+				assert(old.bitcount>=rhs.bitcount);
+
+				// handle sign-extension of lhs, rhs
+				const bool lhs_negative = target_machine->C_promote_integer(res_int,lhs,old);
+				const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
+				if (old.is_signed)
+					{	// signed integer result
+					umaxint lhs_test(res_int);
+					umaxint rhs_test(rhs_int);
+					umaxint ub(target_machine->signed_max(old.machine_type));
+					bool result_is_negative = false;
+					if (rhs_negative) target_machine->signed_additive_inverse(rhs_test,old.machine_type);
+					if (lhs_negative) target_machine->signed_additive_inverse(lhs_test,old.machine_type);
+					if (rhs_negative==lhs_negative)
+						{	// cancellation: safe
+						switch(cmp(lhs_test,rhs_test))
+						{
+						case -1:{
+								result_is_negative = !lhs_negative;
+								rhs_test -= lhs_test;
+								lhs_test = rhs_test;
+								break;
+								}
+						case 0:	{
+								lhs_test.clear();
+								break;
+								}
+						case 1:	{
+								result_is_negative = lhs_negative;
+								lhs_test -= rhs_test;
+								break;
+								}
+						};
+						}
+					else{	// augmentation: need bounds check
+						result_is_negative = lhs_negative;
+						const bool tweak_ub = result_is_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation() && !bool_options[boolopt::int_traps];
+						if (tweak_ub) ub += 1;
+						if (ub<lhs_test || ub<rhs_test || (ub -= lhs_test)<rhs_test)
+							{	//! \test if.C99/Pass_conditional_op_noeval.hpp, if.C99/Pass_conditional_op_noeval.h
+							if (!no_runtime_errors)
+								//! \test default/Error_if_control42.hpp, default/Error_if_control42.h
+								simple_error(src," signed - overflow, undefined behavior (C99 6.5p5, C++98 5p5)");
+							return false;
+							};
+						lhs_test += rhs_test;
+						// if we can't render it, do not reduce
+						if (tweak_ub && target_machine->signed_max(old.machine_type)<lhs_test) return false;
+						}
+
+					if (result_is_negative)
+						{
+						// convert to parsed - literal
+						parse_tree tmp;
+						VM_to_literal(tmp,lhs_test,src,types);
+						src.DeleteIdx<1>(0);
+						force_unary_negative_literal(src,tmp);
+						return true;
+						};
+					res_int = lhs_test;
+					}
+				else
+					res_int -= rhs_int;
+
+				// convert to parsed + literal
+				parse_tree tmp;
+				VM_to_literal(tmp,res_int,src,types);
+				value_copy(tmp.type_code,src.type_code);
+				src.DeleteIdx<1>(0);
+				force_unary_positive_literal(src,tmp ARG_TYPES);
+				return true;
+				}
+			break;
+			}
+	case 1:	{
+			assert(converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES));
+			bool is_true = false;
+			if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
+				{	// __ - 0 |-> __
+				src.type_code.MoveInto(src.c_array<1>()->type_code);
+				src.eval_to_arg<1>(0);
+				return true;
+				}
+			break;
+			}
+#ifndef NDEBUG
+	case 2:	FATAL_CODE("invalid expression not flagged as invalid expression",3);
+#endif
+	case 3:	{	// hyper-optimizing linker: two string literals decay to equal pointers iff they are equal under strcmp
+				// use this to short-circuit to 0; remember to adjust the preprocessor hacks as well
+			bool is_equal = false;
+			if (C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal) && is_equal)
+				{	//! \test default/Pass_if_zero.hpp, default/Pass_if_zero.h
+				type_spec old_type;
+				src.type_code.OverwriteInto(old_type);
+				force_decimal_literal(src,"0",types);
+				old_type.MoveInto(src.type_code);
+				return true;
+				}
+			break;
+			}
+	}
+	return false;
+}
+
+// +: either both are arithmetic, or one is raw pointer and one is integer
+// -: either both are arithmetic, or both are compatible raw pointer, or left is raw pointer and right is integer
+//! \throw std::bad_alloc()
+static void C_CPP_add_expression_easy_syntax_check(parse_tree& src,const type_system& types,literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	assert((C99_ADD_SUBTYPE_PLUS==src.subtype && is_C99_add_operator_expression<'+'>(src)) || (C99_ADD_SUBTYPE_MINUS==src.subtype && is_C99_add_operator_expression<'-'>(src)));
+	BOOST_STATIC_ASSERT(1==C99_ADD_SUBTYPE_MINUS-C99_ADD_SUBTYPE_PLUS);
+	const size_t lhs_pointer = src.data<1>()->type_code.pointer_power;
+	const size_t rhs_pointer = src.data<2>()->type_code.pointer_power;	
+
+	// pointers to void are disallowed; not testable from preprocessor
+	const bool exact_rhs_voidptr = 1==rhs_pointer && C_TYPE::VOID==src.data<2>()->type_code.base_type_index;
+	if (1==lhs_pointer && C_TYPE::VOID==src.data<1>()->type_code.base_type_index)
+		{
+		simple_error(src,exact_rhs_voidptr ? " uses void* arguments (C99 6.5.6p2,3; C++98 5.7p1,2)" : " uses void* left-hand argument (C99 6.5.6p2,3; C++98 5.7p1,2)");
+		return;
+		}
+	else if (exact_rhs_voidptr)
+		{
+		simple_error(src," uses void* right-hand argument (C99 6.5.6p2,3; C++98 5.7p1,2)");
+		return;
+		}
+
+	switch((0<lhs_pointer)+2*(0<rhs_pointer)+4*(src.subtype-C99_ADD_SUBTYPE_PLUS))
+	{
+#ifndef NDEBUG
+	default: FATAL_CODE("hardware/compiler error: invalid linear combination in C_add_expression_easy_syntax_check",3);
+#endif
+	case 0:	{	// cannot test errors from preprocessor
+			POD_pair<size_t,bool> lhs = default_promotion_is_arithmeticlike(src.data<1>()->type_code ARG_TYPES);
+			POD_pair<size_t,bool> rhs = default_promotion_is_arithmeticlike(src.data<2>()->type_code ARG_TYPES);
+			if (!lhs.second)
+				{
+				simple_error(src,rhs.second ? " has non-arithmetic non-pointer right argument (C99 6.5.6p2; C++98 5.7p1)" : " has non-arithmetic non-pointer arguments (C99 6.5.6p2; C++98 5.7p1)");
+				return;
+				}
+			else if (!rhs.second)
+				{
+				simple_error(src," has non-arithmetic non-pointer left argument (C99 6.5.6p2; C++98 5.7p1)");
+				return;
+				}
+
+			// arithmeticlike subsumes integerlike so this is fine
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				{
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
+				lhs = default_promotion_is_integerlike(src.data<1>()->type_code,types);
+				assert(lhs.second);
+				}
+			if (is_noticed_enumerator(*src.data<2>(),types)) 
+				{
+				enumerator_to_integer_representation(*src.c_array<2>(),types);
+				rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
+				assert(rhs.second);
+				}
+			src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_add_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			break;
+			}
+	case 1:	{	// ptr + integer, hopefully
+				// requires floating-point literals to test errors from preprocessor
+			value_copy(src.type_code,src.data<1>()->type_code);
+			if (!converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
+				{
+				simple_error(src," adds pointer to non-integer (C99 6.5.6p2; C++98 5.7p1)");
+				return;
+				}
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_add_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			break;
+			}
+	case 2:	{	// integer + ptr, hopefully
+				// requires floating-point literals to test errors from preprocessor
+			value_copy(src.type_code,src.data<2>()->type_code);
+			if (!converts_to_integerlike(src.data<1>()->type_code.base_type_index ARG_TYPES))
+				{
+				simple_error(src," adds pointer to non-integer (C99 6.5.6p2; C++98 5.7p1)");
+				return;
+				}
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_add_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			break;
+			}
+	case 3:	{	//	ptr + ptr dies
+				//! \test default/Error_if_control43.hpp, default/Error_if_control43.h
+			simple_error(src," adds two pointers (C99 6.5.6p2; C++98 5.7p1)");
+			return;
+			}
+	case 4:	{	// cannot test errors from preprocessor
+			POD_pair<size_t,bool> lhs = default_promotion_is_arithmeticlike(src.data<1>()->type_code ARG_TYPES);
+			POD_pair<size_t,bool> rhs = default_promotion_is_arithmeticlike(src.data<2>()->type_code ARG_TYPES);
+			if (!lhs.second)
+				{
+				simple_error(src,rhs.second ? " has non-arithmetic non-pointer right argument (C99 6.5.6p3; C++98 5.7p2)" : " has non-arithmetic non-pointer arguments (C99 6.5.6p3; C++98 5.7p2)");
+				return;
+				}
+			else if (!rhs.second)
+				{
+				simple_error(src," has non-arithmetic non-pointer left argument (C99 6.5.6p3; C++98 5.7p2)");
+				return;
+				}
+
+			// arithmeticlike subsumes integerlike so this is fine
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				{
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
+				lhs = default_promotion_is_integerlike(src.data<1>()->type_code,types);
+				assert(lhs.second);
+				}
+			if (is_noticed_enumerator(*src.data<2>(),types)) 
+				{
+				enumerator_to_integer_representation(*src.c_array<2>(),types);
+				rhs = default_promotion_is_integerlike(src.data<2>()->type_code,types);
+				assert(rhs.second);
+				}
+			src.type_code.set_type(arithmetic_reconcile(lhs.first,rhs.first ARG_TYPES));
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_sub_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			break;
+			}
+	case 5:	{	// ptr - integer, hopefully; requires floating-point literal to test from preprocessor
+			value_copy(src.type_code,src.data<1>()->type_code);
+			if (!converts_to_integerlike(src.data<2>()->type_code.base_type_index ARG_TYPES))
+				{
+				simple_error(src," subtracts non-integer from pointer (C99 6.5.6p3; C++98 5.7p2)");
+				return;
+				}
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_sub_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			break;
+			}
+	case 6:	{	// non-ptr - ptr dies
+				//! \test default/Error_if_control44.hpp, default/Error_if_control44.h
+			simple_error(src," subtracts a non-pointer from a pointer (C99 6.5.6p3; C++98 5.7p2)");
+			return;
+			}
+	case 7:	{	// ptr - ptr should be compatible
+				// type is ptrdiff_t
+			const virtual_machine::std_int_enum tmp = target_machine->ptrdiff_t_type();
+			assert(tmp);
+			src.type_code.set_type((virtual_machine::std_int_char==tmp ? C_TYPE::CHAR
+							:	virtual_machine::std_int_short==tmp ? C_TYPE::SHRT
+							:	virtual_machine::std_int_int==tmp ? C_TYPE::INT
+							:	virtual_machine::std_int_long==tmp ? C_TYPE::LONG
+							:	virtual_machine::std_int_long_long==tmp ? C_TYPE::LLONG : 0));
+			assert(0!=src.type_code.base_type_index);
+			zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+			eval_sub_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+			break;
+			}
+	}
+}
+
+/*
+additive-expression:
+	multiplicative-expression
+	additive-expression + multiplicative-expression
+	additive-expression - multiplicative-expression
+*/
+static void locate_C99_add_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+
+	if (terse_C99_augment_add_expression(src,i,types))
+		{
+		C_CPP_add_expression_easy_syntax_check(src.c_array<0>()[i],types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+		return;
+		}
+
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_add_expression(src,i))
+		C_CPP_add_expression_easy_syntax_check(src.c_array<0>()[i],types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+}
+
+/*
+additive-expression:
+	multiplicative-expression
+	additive-expression + multiplicative-expression
+	additive-expression - multiplicative-expression
+*/
+static void locate_CPP_add_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+
+	if (terse_CPP_augment_add_expression(src,i,types))
+		{	//! \todo handle operator overloading
+		C_CPP_add_expression_easy_syntax_check(src.c_array<0>()[i],types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
+		return;
+		}
+
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_add_expression(src,i))
+		//! \todo handle operator overloading
+		C_CPP_add_expression_easy_syntax_check(src.c_array<0>()[i],types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
+}
+
+static bool binary_infix_failed_integer_arguments(parse_tree& src, const char* standard SIG_CONST_TYPES)
+{
+	assert(NULL!=standard);
+	if (parse_tree::INVALID & src.flags)	// already invalid, don't make noise
+		return !converts_to_integerlike(src.data<1>()->type_code ARG_TYPES) || !converts_to_integerlike(src.data<2>()->type_code ARG_TYPES);
+
+	// hmm... 45-47, 48-50, 51-53, 54-56, 57-59
+	//! \todo need tests for float literal in place of int literal: << >> & ^ |
+	const bool rhs_integerlike = converts_to_integerlike(src.data<2>()->type_code ARG_TYPES);
+	if (!converts_to_integerlike(src.data<1>()->type_code ARG_TYPES))
+		{	// tests for string literal in place of integer literal
+			//! \test default/Error_if_control46.hpp, default/Error_if_control46.h
+			//! \test default/Error_if_control47.hpp, default/Error_if_control47.h
+			//! \test default/Error_if_control49.hpp, default/Error_if_control49.h
+			//! \test default/Error_if_control50.hpp, default/Error_if_control50.h
+			//! \test default/Error_if_control52.hpp, default/Error_if_control52.h
+			//! \test default/Error_if_control53.hpp, default/Error_if_control53.h
+			//! \test default/Error_if_control55.hpp, default/Error_if_control55.h
+			//! \test default/Error_if_control56.hpp, default/Error_if_control56.h
+			//! \test default/Error_if_control58.hpp, default/Error_if_control58.h
+			//! \test default/Error_if_control59.hpp, default/Error_if_control59.h
+		src.flags |= parse_tree::INVALID;
+		message_header(src.index_tokens[0]);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(src);
+		INC_INFORM(rhs_integerlike ? " has nonintegral LHS " : " has nonintegral LHS and RHS ");
+		INFORM(standard);
+		zcc_errors.inc_error();
+		return true;
+		}
+	else if (!rhs_integerlike)
+		{	// tests for string literal in place of integer literal
+			//! \test default/Error_if_control45.hpp, default/Error_if_control45.h
+			//! \test default/Error_if_control48.hpp, default/Error_if_control48.h
+			//! \test default/Error_if_control51.hpp, default/Error_if_control51.h
+			//! \test default/Error_if_control54.hpp, default/Error_if_control54.h
+			//! \test default/Error_if_control57.hpp, default/Error_if_control57.h
+		src.flags |= parse_tree::INVALID;
+		message_header(src.index_tokens[0]);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(src);
+		INC_INFORM(" has nonintegral RHS ");
+		INFORM(standard);
+		zcc_errors.inc_error();
+		return true;
+		}
+	return false;
+}
+
+static bool terse_locate_shift_expression(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	const size_t shift_subtype 	= (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"<<")) ? C99_SHIFT_SUBTYPE_LEFT
+								: (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,">>")) ? C99_SHIFT_SUBTYPE_RIGHT : 0;
+	if (shift_subtype)
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_SHIFT_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_ADD_EXPRESSION & tmp_c_array[2].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_SHIFT_EXPRESSION);	// tmp_c_array goes invalid here
+			assert(is_C99_shift_expression(src.data<0>()[i]));
+			parse_tree& tmp = src.c_array<0>()[i];
+			tmp.subtype = shift_subtype;
+			tmp.type_code.set_type(0);	// handle type inference later
+			assert(is_C99_shift_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool eval_shift(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
+	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
+	assert(C99_SHIFT_SUBTYPE_LEFT<=src.subtype && C99_SHIFT_SUBTYPE_RIGHT>=src.subtype);
+	BOOST_STATIC_ASSERT(1==C99_SHIFT_SUBTYPE_RIGHT-C99_SHIFT_SUBTYPE_LEFT);
+	// handle:
+	// 0 << __ |-> 0
+	// __ << 0 |-> __
+	// 0 >> __ |-> 0
+	// __ >> 0 |-> __
+	// two integer literals
+	// error if RHS is literal "out of bounds"
+	bool is_true = false;
+	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true)
+		{
+		if (!is_true)
+			{	// __ << 0 or __ >> 0: lift
+			// handle enumerators now
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
+			src.type_code.MoveInto(src.c_array<1>()->type_code);
+			src.eval_to_arg<1>(0);
+			return true;
+			}
+		};
+
+	umaxint rhs_int;
+	if (intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
+		{
+		const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
+		const bool undefined_behavior = target_machine->C_bit(machine_type)<=rhs_int;
+
+		//! \todo can't test with static test case (need to use bitcount of uintmax_t/intmax_t)
+		if (undefined_behavior)
+			simple_error(src," : RHS is at least as large as bits of LHS; undefined behavior (C99 6.5.7p3/C++98 5.8p1)");
+
+		if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES))
+			{
+			if (!is_true)
+				{	// 0 << __ or 0 >> __: zero out (note that we can do this even if we invoked undefined behavior)
+				type_spec tmp;
+				src.type_code.OverwriteInto(tmp);
+				force_decimal_literal(src,"0",types);
+				tmp.MoveInto(src.type_code);
+				return true;
+				}
+			};
+		if (undefined_behavior) return false;
+
+		umaxint res_int;
+		if (intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES))
+			{
+			// note that incoming negative signed integers are not handled by this code path
+			if (C99_SHIFT_SUBTYPE_LEFT==src.subtype)
+				{
+				//! \todo but signed integers do go undefined in C if left-shifted too much; C++ accepts
+#if 0
+				if (0==(src.type_code.base_type_index-C_TYPE::INT)%2 && target_machine->C_bit(machine_type)<=rhs_int.to_uint()+lhs_int.int_log2()+1)
+					simple_error(src," : result does not fit in LHS type; undefined behavior (C99 6.5.7p3)");
+#endif
+				res_int <<= rhs_int.to_uint();
+				if (int_has_trapped(src,res_int)) return false;
+				}
+			else	// if (C99_SHIFT_SUBTYPE_RIGHT==src.subtype)
+				res_int >>= rhs_int.to_uint();
+
+			const virtual_machine::std_int_enum machine_type = machine_type_from_type_index(src.type_code.base_type_index);
+			const bool negative_signed_int = 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && res_int.test(target_machine->C_bit(machine_type)-1);
+			if (negative_signed_int) target_machine->signed_additive_inverse(res_int,machine_type);
+			parse_tree tmp;
+			VM_to_literal(tmp,res_int,src,types);
+
+			if (negative_signed_int)
+				{	// convert to parsed - literal
+				src.DeleteIdx<1>(0);
+				force_unary_negative_literal(src,tmp);
+				}
+			else{	// convert to positive literal
+				src.type_code.MoveInto(tmp.type_code);
+				tmp.MoveInto(src);
+				}
+			return true;
+			}
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static void C_shift_expression_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_shift_expression(src));
+	// C99 6.5.7p2: requires being an integer type
+	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.7p2)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_shift(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
+}
+
+//! \throw std::bad_alloc()
+static void CPP_shift_expression_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_shift_expression(src));
+	// C++98 5.8p1: requires being an integer or enumeration type
+	if (binary_infix_failed_integer_arguments(src,"(C++98 5.8p1)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(src.data<1>()->type_code.base_type_index ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_shift(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
+}
+
+/*
+shift-expression:
+	additive-expression
+	shift-expression << additive-expression
+	shift-expression >> additive-expression
+*/
+//! \throw std::bad_alloc()
+static void locate_C99_shift_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_shift_expression(src,i))
+		C_shift_expression_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+/*
+shift-expression:
+	additive-expression
+	shift-expression << additive-expression
+	shift-expression >> additive-expression
+*/
+//! \throw std::bad_alloc()
+static void locate_CPP_shift_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_shift_expression(src,i))
+		//! \todo handle overloading
+		CPP_shift_expression_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+//! \throw std::bad_alloc
+static bool terse_locate_relation_expression(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	const size_t rel_subtype 	= (token_is_char<'<'>(src.data<0>()[i].index_tokens[0].token)) ? C99_RELATION_SUBTYPE_LT
+								: (token_is_char<'>'>(src.data<0>()[i].index_tokens[0].token)) ? C99_RELATION_SUBTYPE_GT
+								: (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"<=")) ? C99_RELATION_SUBTYPE_LTE
+								: (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,">=")) ? C99_RELATION_SUBTYPE_GTE : 0;
+	if (rel_subtype)
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_SHIFT_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_ADD_EXPRESSION & tmp_c_array[2].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_RELATIONAL_EXPRESSION);	// tmp_c_array goes invalid here
+			assert(is_C99_relation_expression(src.data<0>()[i]));
+			parse_tree& tmp = src.c_array<0>()[i];
+			tmp.subtype = rel_subtype;
+			tmp.type_code.set_type(C_TYPE::BOOL);
+			assert(is_C99_relation_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+static bool eval_relation_expression(parse_tree& src, const type_system& types,intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_GT-C99_RELATION_SUBTYPE_LT);
+	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_LTE-C99_RELATION_SUBTYPE_GT);
+	BOOST_STATIC_ASSERT(1==C99_RELATION_SUBTYPE_GTE-C99_RELATION_SUBTYPE_LTE);
+	assert(C99_RELATION_SUBTYPE_LT<=src.subtype && C99_RELATION_SUBTYPE_GTE>=src.subtype);
+	umaxint lhs_int;
+	umaxint rhs_int;
+
+	const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES);
+	const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
+	if (lhs_converted && rhs_converted)
+		{
+		const char* result 	= NULL;
+		const promote_aux targ(arithmetic_reconcile(src.data<1>()->type_code.base_type_index, src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+		const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
+		assert(targ.bitcount>=lhs.bitcount);
+		const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
+		assert(targ.bitcount>=rhs.bitcount);
+
+		// handle sign-extension of lhs, rhs
+		bool use_unsigned_compare = true;
+		const bool lhs_negative = target_machine->C_promote_integer(lhs_int,lhs,targ);
+		const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,targ);
+		if (rhs_negative) target_machine->signed_additive_inverse(rhs_int,targ.machine_type);
+		if (lhs_negative) target_machine->signed_additive_inverse(lhs_int,targ.machine_type);
+
+		//! \todo --do-what-i-mean redefines < > operators to handle cross-domain
+		if (targ.is_signed && (lhs_negative || rhs_negative))
+			{	// repair switch to handle signed numerals
+			if (lhs_negative && rhs_negative)
+				std::swap(lhs_int,rhs_int);
+			else{
+				const bool lhs_zero = target_machine->is_zero(lhs_int.data(),lhs_int.size(),targ);
+				const bool rhs_zero = target_machine->is_zero(rhs_int.data(),rhs_int.size(),targ);
+				const bool op_uses_less_than = (src.subtype%2);	// low-level, check with static assertions
+				// is above correct?
+				BOOST_STATIC_ASSERT(C99_RELATION_SUBTYPE_LT%2);
+				BOOST_STATIC_ASSERT(C99_RELATION_SUBTYPE_LTE%2);
+				BOOST_STATIC_ASSERT(!(C99_RELATION_SUBTYPE_GT%2));
+				BOOST_STATIC_ASSERT(!(C99_RELATION_SUBTYPE_GTE%2));
+				use_unsigned_compare = false;
+				if (!lhs_zero)
+					result = lhs_negative ? (op_uses_less_than ? "1" : "0") : (op_uses_less_than ? "0" : "1");
+				else if (!rhs_zero)
+					result = rhs_negative ? (op_uses_less_than ? "0" : "1") : (op_uses_less_than ? "1" : "0");
+				else{	// is below correct?
+					BOOST_STATIC_ASSERT(C99_RELATION_SUBTYPE_LTE<=C99_RELATION_SUBTYPE_GTE);
+					BOOST_STATIC_ASSERT(C99_RELATION_SUBTYPE_LT<C99_RELATION_SUBTYPE_LTE);
+					BOOST_STATIC_ASSERT(C99_RELATION_SUBTYPE_GT<C99_RELATION_SUBTYPE_LTE);
+					result = (C99_RELATION_SUBTYPE_LTE<=src.subtype) ? "1" : "0"; 	// low-level, check with static assertions					
+					}				
+				}
+			};
+		if (use_unsigned_compare)
+			{
+			switch(src.subtype)
+			{
+			case C99_RELATION_SUBTYPE_LT:	{
+											result = (lhs_int<rhs_int) ? "1" : "0";
+											break;
+											}
+			case C99_RELATION_SUBTYPE_GT:	{
+											result = (lhs_int>rhs_int) ? "1" : "0";
+											break;
+											}
+			case C99_RELATION_SUBTYPE_LTE:	{
+											result = (lhs_int<=rhs_int) ? "1" : "0";
+											break;
+											}
+			case C99_RELATION_SUBTYPE_GTE:	{
+											result = (lhs_int>=rhs_int) ? "1" : "0";
+											break;
+											}
+			}
+			}
+		force_decimal_literal(src,result,types);
+		return true;
+		};
+	//! \bug: string literals can't handle GTE, LTE
+	//! \bug: string literals handle GT, LT only with respect to zero (NULL constant)?
+	return false;
+}
+
+static bool C_CPP_relation_expression_core_syntax_ok(parse_tree& src,const type_system& types)
+{
+	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power)+2*(0<src.data<2>()->type_code.pointer_power);
+	switch(ptr_case)
+	{
+	case 0:	{	// can't test from preprocessor
+			if (!converts_to_reallike(src.data<1>()->type_code.base_type_index ARG_TYPES) || !converts_to_reallike(src.data<2>()->type_code.base_type_index ARG_TYPES))
+				{
+				simple_error(src," compares non-real type(s) (C99 6.5.8p2/C++98 5.9p2)");
+				return false;
+				}
+			break;
+			}
+	case 1:	{	//! \todo need floating-point literal to test first half
+				//! \todo figure out how to test second half
+			if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+				{	// oops
+				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
+				return false;
+				}
+			break;
+			}
+	case 2:	{	//! \todo need floating-point literal to test first half
+				//! \todo figure out how to test second half
+			if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
+				{	// oops
+				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
+				return false;
+				}
+			break;
+			}
+	}
+	return true;
+}
+
+static void C_relation_expression_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	if (!C_CPP_relation_expression_core_syntax_ok(src,types))
+		eval_relation_expression(src,types,C99_intlike_literal_to_VM);
+}
+
+static void CPP_relation_expression_easy_syntax_check(parse_tree& src,const type_system& types)
+{	//! \todo handle operator overloading
+	if (!C_CPP_relation_expression_core_syntax_ok(src,types))
+		eval_relation_expression(src,types,CPP_intlike_literal_to_VM);
+}
+
+/*
+relational-expression:
+	shift-expression
+	relational-expression < shift-expression
+	relational-expression > shift-expression
+	relational-expression <= shift-expression
+	relational-expression >= shift-expression
+*/
+//! \throw std::bad_alloc
+static void locate_C99_relation_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_relation_expression(src,i))
+		C_relation_expression_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+/*
+relational-expression:
+	shift-expression
+	relational-expression < shift-expression
+	relational-expression > shift-expression
+	relational-expression <= shift-expression
+	relational-expression >= shift-expression
+*/
+//! \throw std::bad_alloc
+static void locate_CPP_relation_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_relation_expression(src,i))
+		//! \todo handle overloading
+		CPP_relation_expression_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+//! \throw std::bad_alloc
+static bool terse_locate_C99_equality_expression(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	const size_t eq_subtype = (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"==")) ? C99_EQUALITY_SUBTYPE_EQ
+							: (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"!=")) ? C99_EQUALITY_SUBTYPE_NEQ : 0;
+	if (eq_subtype)
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_EQUALITY_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_RELATIONAL_EXPRESSION & tmp_c_array[2].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_EQUALITY_EXPRESSION);	// tmp_c_array becomes invalid here
+			assert(is_C99_equality_expression(src.data<0>()[i]));
+			parse_tree& tmp = src.c_array<0>()[i];
+			tmp.subtype = eq_subtype;
+			tmp.type_code.set_type(C_TYPE::BOOL);
+			assert(is_C99_equality_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool terse_locate_CPP_equality_expression(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	const size_t eq_subtype = (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"==")) ? C99_EQUALITY_SUBTYPE_EQ
+							: (		token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"!=")
+							   ||	token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"not_eq")) ? C99_EQUALITY_SUBTYPE_NEQ : 0;
+	if (eq_subtype)
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_EQUALITY_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_RELATIONAL_EXPRESSION & tmp_c_array[2].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_EQUALITY_EXPRESSION);	// tmp_c_array becomes invalid here
+			assert(is_CPP_equality_expression(src.data<0>()[i]));
+			parse_tree& tmp = src.c_array<0>()[i];
+			tmp.subtype = eq_subtype;
+			tmp.type_code.set_type(C_TYPE::BOOL);
+			assert(is_CPP_equality_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+static bool typeid_equal_content(const parse_tree& lhs, const parse_tree& rhs,bool& is_equal)
+{
+	if (   is_CPP0X_typeid_expression(lhs) && is_CPP0X_typeid_expression(rhs)
+		&& C_TYPE::NOT_VOID!=lhs.data<2>()->type_code.base_type_index
+		&& C_TYPE::NOT_VOID!=rhs.data<2>()->type_code.base_type_index)
+		{
+		is_equal = lhs.data<2>()->type_code.typeid_equal(rhs.data<2>()->type_code);
+		return true;
+		}
+	return false;
+}
+
+static bool eval_equality_expression(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+{	
+	BOOST_STATIC_ASSERT(1==C99_EQUALITY_SUBTYPE_NEQ-C99_EQUALITY_SUBTYPE_EQ);
+	assert(C99_EQUALITY_SUBTYPE_EQ<=src.subtype && C99_EQUALITY_SUBTYPE_NEQ>=src.subtype);
+	umaxint lhs_int;
+	umaxint rhs_int;
+	const unsigned int integer_literal_case = 	  converts_to_integer(src.data<1>()->type_code ARG_TYPES)
+											+	2*converts_to_integer(src.data<2>()->type_code ARG_TYPES);
+	const bool is_equal_op = src.subtype==C99_EQUALITY_SUBTYPE_EQ;
+	bool is_true = false;
+	switch(integer_literal_case)
+	{
+	case 0:	{	// string literal == string literal (assume hyper-optimizing linker, this should be true iff the string literals are equal as static arrays of char)
+				//! \test default/Pass_if_nonzero.hpp, default/Pass_if_nonzero.h, 
+				//! \test default/Pass_if_zero.hpp, default/Pass_if_zero.h, 
+			bool is_equal = false;
+			if (   C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal)
+				|| typeid_equal_content(*src.data<1>(),*src.data<2>(),is_equal)
+				)
+				{
+				force_decimal_literal(src,is_equal_op==is_equal ? "1" : "0",types);
+				return true;
+				};
+			break;
+			}
+	case 1:	{
+			if (0<src.data<2>()->type_code.pointer_power && literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES)) 
+				{
+				if (!is_true)
+					{	
+					if (src.data<2>()->type_code.decays_to_nonnull_pointer())
+						{	// string literal != NULL, etc.
+						//! \test default/Pass_if_nonzero.hpp, default/Pass_if_nonzero.h, 
+						//! \test default/Pass_if_zero.hpp, default/Pass_if_zero.h, 
+						force_decimal_literal(src,is_equal_op ? "0" : "1",types);
+						return true;
+						}
+					}
+				else if (!(parse_tree::INVALID & src.flags))
+					//! \test default/Error_if_control60.hpp, default/Error_if_control60.h 
+					//! \test default/Error_if_control61.hpp, default/Error_if_control61.h
+					simple_error(src," compares pointer to integer that is not a null pointer constant (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
+				return false;
+				}
+			break;
+			}
+	case 2:	{
+			if (0<src.data<1>()->type_code.pointer_power && literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES)) 
+				{
+				if (!is_true)
+					{
+					if (src.data<1>()->type_code.decays_to_nonnull_pointer())
+						{	// string literal != NULL
+						//! \test default/Pass_if_nonzero.hpp, default/Pass_if_nonzero.h, 
+						//! \test default/Pass_if_zero.hpp, default/Pass_if_zero.h, 
+						force_decimal_literal(src,is_equal_op ? "0" : "1",types);
+						return true;
+						}
+					}
+				else if (!(parse_tree::INVALID & src.flags))
+					//! \test default/Error_if_control62.hpp, default/Error_if_control62.h 
+					//! \test default/Error_if_control63.hpp, default/Error_if_control63.h
+					simple_error(src," compares pointer to integer that is not a null pointer constant (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
+				return false;
+				}
+			break;
+			}
+	case 3:	{	// integer literal == integer literal
+			const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
+			const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
+			const promote_aux old(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+			assert(old.bitcount>=lhs.bitcount);
+			assert(old.bitcount>=rhs.bitcount);
+			const bool lhs_converted = intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES);
+			const bool rhs_converted = intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
+			// general case here in case we try to do with converted/not converted mixed cases
+//			if (lhs_converted) target_machine->C_promote_integer(lhs_int,lhs,old);
+//			if (rhs_converted) target_machine->C_promote_integer(rhs_int,rhs,old);
+			if (lhs_converted && rhs_converted)
+				{
+				target_machine->C_promote_integer(lhs_int,lhs,old);
+				target_machine->C_promote_integer(rhs_int,rhs,old);
+				force_decimal_literal(src,(lhs_int==rhs_int)==is_equal_op ? "1" : "0",types);
+				return true;
+				};
+//			break;
+			}
+	};
+	
+	return false;
+}
+
+static bool C_CPP_equality_expression_syntax_ok_core(parse_tree& src,const type_system& types)
+{	// admit legality of:
+	// numeric == numeric
+	// string literal == string literal
+	// string literal == integer literal zero
+	// deny legality of : string literal == integer/float
+	// more to come later
+	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power)+2*(0<src.data<2>()->type_code.pointer_power);
+	switch(ptr_case)
+	{
+	case 0:	{	// can't test from preprocessor
+			if (C_TYPE::VOID>=src.data<1>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index)
+				{
+				simple_error(src," can't use a void or indeterminately typed argument");
+				return false;
+				}
+			break;
+			}
+	case 1:	{	// need floating-point literal to test from preprocessor
+			if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+				{	// oops
+				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
+				return false;
+				}
+			break;
+			}
+	case 2:	{	// need floating-point literal to test from preprocessor
+			if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
+				{	// oops
+				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
+				return false;
+				}
+			break;
+			}
+	}
+	return true;
+}
+
+static void C_equality_expression_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	if (!C_CPP_equality_expression_syntax_ok_core(src,types)) return;
+	eval_equality_expression(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM);
+}
+
+static void CPP_equality_expression_easy_syntax_check(parse_tree& src,const type_system& types)
+{	//! \todo check for operator overloading
+	if (!C_CPP_equality_expression_syntax_ok_core(src,types)) return;
+	eval_equality_expression(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM);
+}
+
+/*
+equality-expression:
+	relational-expression
+	equality-expression == relational-expression
+	equality-expression != relational-expression
+*/
+//! \throw std::bad_alloc
+static void locate_C99_equality_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_C99_equality_expression(src,i))
+		C_equality_expression_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+/*
+equality-expression:
+	relational-expression
+	equality-expression == relational-expression
+	equality-expression != relational-expression
+*/
+//! \throw std::bad_alloc
+static void locate_CPP_equality_expression(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_CPP_equality_expression(src,i))
+		//! \todo handle operator overloading
+		CPP_equality_expression_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+//! \throw std::bad_alloc
+static bool terse_locate_C99_bitwise_AND(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	//! \todo deal with unary & parses
+	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+	if (token_is_char<'&'>(tmp_c_array[1].index_tokens[0].token))
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_BITAND_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_EQUALITY_EXPRESSION & tmp_c_array[2].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITAND_EXPRESSION);	// tmp_c_array becomes invalid here
+			assert(is_C99_bitwise_AND_expression(src.data<0>()[i]));
+			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
+			assert(is_C99_bitwise_AND_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+static bool terse_locate_CPP_bitwise_AND(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_char<'&'>(src.data<0>()[i].index_tokens[0].token) || token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"bitand"))
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if (	(PARSE_BITAND_EXPRESSION & src.data<0>()[i-1].flags)
+			&&	(PARSE_EQUALITY_EXPRESSION & src.data<0>()[i+1].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITAND_EXPRESSION);
+			assert(is_CPP_bitwise_AND_expression(src.data<0>()[i]));
+			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
+			assert(is_CPP_bitwise_AND_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_bitwise_AND(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
+	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
+	// handle following:
+	// __ & 0 |-> 0
+	// 0 & __ |-> 0
+	// int-literal | int-literal |-> int-literal *if* both fit
+	// unary - gives us problems (result is target-specific, could generate a trap representation)
+	bool is_true = false;
+	if (	(literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES) && !is_true)	// 0 & __
+		||	(literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES) && !is_true))	// __ & 0
+		{
+		if (C_TYPE::INTEGERLIKE==src.type_code.base_type_index)
+			{
+			message_header(src.index_tokens[0]);
+			INC_INFORM("invalid ");
+			INC_INFORM(src);
+			INFORM(" optimized to valid 0");
+			force_decimal_literal(src,"0",types);
+			src.type_code.set_type(C_TYPE::LLONG);	// legalize
+			}
+		else{
+			type_spec tmp;
+			src.type_code.OverwriteInto(tmp);
+			force_decimal_literal(src,"0",types);
+			tmp.MoveInto(src.type_code);
+			}
+		return true;
+		};
+
+	umaxint lhs_int;
+	umaxint rhs_int;
+	if (intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES) && intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
+		{
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
+		umaxint res_int(lhs_int);
+		res_int &= rhs_int;
+
+		// check for trap representation for signed types
+		if (int_has_trapped(src,res_int)) return false;
+
+		if 		(res_int==lhs_int)
+			// lhs & rhs = lhs; conserve type
+			{
+			// handle enumerators now
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
+			src.type_code.MoveInto(src.c_array<1>()->type_code);
+			src.eval_to_arg<1>(0);
+			}
+		else if (res_int==rhs_int)
+			// lhs & rhs = rhs; conserve type
+			{
+			// handle enumerators now
+			if (is_noticed_enumerator(*src.data<2>(),types))
+				enumerator_to_integer_representation(*src.c_array<2>(),types);
+			src.type_code.MoveInto(src.c_array<2>()->type_code);
+			src.eval_to_arg<2>(0);
+			}
+		else{
+			const bool negative_signed_int = old.is_signed && res_int.test(old.bitcount-1);
+			if (negative_signed_int) target_machine->signed_additive_inverse(res_int,old.machine_type);
+			if (	virtual_machine::twos_complement==target_machine->C_signed_int_representation()
+				&& 	old.is_signed
+				&& 	!bool_options[boolopt::int_traps]
+				&&	res_int>target_machine->signed_max(old.machine_type))
+				{	// trap representation; need to get it into -INT_MAX-1 form
+				construct_twos_complement_int_min(src,types,old.machine_type,src);
+				return true;
+				}
+
+			parse_tree tmp;
+			VM_to_signed_literal(tmp,negative_signed_int,res_int,src,types);
+			src.type_code.MoveInto(tmp.type_code);
+			tmp.MoveInto(src);
+			}
+		return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static void C_bitwise_AND_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_bitwise_AND_expression(src));
+	// C99 6.5.10p2: requires being an integer type
+	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.10p2)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_AND(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
+}
+
+//! \throw std::bad_alloc
+static void CPP_bitwise_AND_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_CPP_bitwise_AND_expression(src));
+	// C++98 5.11p1: requires being an integer or enumeration type
+	if (binary_infix_failed_integer_arguments(src,"(C++98 5.11p1)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_AND(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
+}
+
+/*
+AND-expression:
+	equality-expression
+	AND-expression & equality-expression
+*/
+//! \throw std::bad_alloc
+static void locate_C99_bitwise_AND(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_C99_bitwise_AND(src,i))
+		C_bitwise_AND_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+/*
+AND-expression:
+	equality-expression
+	AND-expression & equality-expression
+*/
+//! \throw std::bad_alloc
+static void locate_CPP_bitwise_AND(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_CPP_bitwise_AND(src,i))
+		//! \todo handle overloading
+		CPP_bitwise_AND_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+static bool terse_locate_C99_bitwise_XOR(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+	if (token_is_char<'^'>(tmp_c_array[1].index_tokens[0].token))
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_BITXOR_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_BITAND_EXPRESSION & tmp_c_array[2].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITXOR_EXPRESSION);	// tmp_c_array becomes invalid here
+			assert(is_C99_bitwise_XOR_expression(src.data<0>()[i]));
+			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
+			assert(is_C99_bitwise_XOR_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+static bool terse_locate_CPP_bitwise_XOR(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_char<'^'>(src.data<0>()[i].index_tokens[0].token) || token_is_string<3>(src.data<0>()[i].index_tokens[0].token,"xor"))
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if (	(PARSE_BITXOR_EXPRESSION & src.data<0>()[i-1].flags)
+			&&	(PARSE_BITAND_EXPRESSION & src.data<0>()[i+1].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITXOR_EXPRESSION);
+			assert(is_CPP_bitwise_XOR_expression(src.data<0>()[i]));
+			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
+			assert(is_CPP_bitwise_XOR_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+// throws std::bad_alloc
+static bool eval_bitwise_XOR(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
+	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
+	// handle following
+	// x ^ x |-> 0 [later, need sensible detection of "equal" expressions first]
+	// 0 ^ __ |-> __
+	// __ ^ 0 |-> __
+	// also handle double-literal case
+	bool is_true = false;
+	if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES))
+		{
+		if (!is_true)
+			{	// 0 ^ __
+			// handle enumerators now
+			if (is_noticed_enumerator(*src.data<2>(),types))
+				enumerator_to_integer_representation(*src.c_array<2>(),types);
+			src.eval_to_arg<2>(0);
+			//! \bug convert char literal to appropriate integer
+			return true;
+			}
+		};
+	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES))
+		{
+		if (!is_true)
+			{	// __ ^ 0
+			// handle enumerators now
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
+			src.eval_to_arg<1>(0);
+			//! \bug convert char literal to appropriate integer
+			return true;
+			}
+		};
+
+	umaxint lhs_int;
+	umaxint rhs_int;
+	if (intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES) && intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
+		{
+		const promote_aux old(src.type_code.base_type_index ARG_TYPES);
+		umaxint res_int(lhs_int);
+		res_int ^= rhs_int;
+//		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
+
+		if (int_has_trapped(src,res_int)) return false;
+
+		const bool negative_signed_int = old.is_signed && res_int.test(old.bitcount-1);
+		if (negative_signed_int) target_machine->signed_additive_inverse(res_int,old.machine_type);
+		if (	virtual_machine::twos_complement==target_machine->C_signed_int_representation()
+			&& 	old.is_signed
+			&& 	!bool_options[boolopt::int_traps]
+			&&	res_int>target_machine->signed_max(old.machine_type))
+			{	// trap representation; need to get it into -INT_MAX-1 form
+			construct_twos_complement_int_min(src,types,old.machine_type,src);
+			return true;
+			}
+
+		parse_tree tmp;
+		VM_to_signed_literal(tmp,negative_signed_int,res_int,src,types);
+		src.type_code.MoveInto(tmp.type_code);
+		tmp.MoveInto(src);
+		return true;
+		}
+	return false;
+}
+
+// throws std::bad_alloc
+static void C_bitwise_XOR_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_bitwise_XOR_expression(src));
+	// C99 6.5.11p2: requires being an integer type
+	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.11p2)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_XOR(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
+}
+
+// throws std::bad_alloc
+static void CPP_bitwise_XOR_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_CPP_bitwise_XOR_expression(src));
+	// C++98 5.12p1: requires being an integer or enumeration type
+	if (binary_infix_failed_integer_arguments(src,"(C++98 5.12p1)" ARG_TYPES)) return;
+	src.type_code.base_type_index = default_promote_type(arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES) ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_XOR(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
+}
+
+/*
+exclusive-OR-expression:
+	AND-expression
+	exclusive-OR-expression ^ AND-expression
+*/
+// throws std::bad_alloc
+static void locate_C99_bitwise_XOR(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_C99_bitwise_XOR(src,i)) C_bitwise_XOR_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+/*
+exclusive-OR-expression:
+	AND-expression
+	exclusive-OR-expression ^ AND-expression
+*/
+// throws std::bad_alloc
+static void locate_CPP_bitwise_XOR(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_CPP_bitwise_XOR(src,i))
+		//! \todo handle operator overloading
+		CPP_bitwise_XOR_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+static bool terse_locate_C99_bitwise_OR(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+	if (token_is_char<'|'>(tmp_c_array[1].index_tokens[0].token))
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_BITOR_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_BITXOR_EXPRESSION & tmp_c_array[2].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITOR_EXPRESSION);	// tmp_c_array becomes invalid here
+			assert(is_C99_bitwise_OR_expression(src.data<0>()[i]));
+			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
+			assert(is_C99_bitwise_OR_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+static bool terse_locate_CPP_bitwise_OR(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_char<'|'>(src.data<0>()[i].index_tokens[0].token) || token_is_string<5>(src.data<0>()[i].index_tokens[0].token,"bitor"))
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if (	(PARSE_BITOR_EXPRESSION & src.data<0>()[i-1].flags)
+			&&	(PARSE_BITXOR_EXPRESSION & src.data<0>()[i+1].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_BITOR_EXPRESSION);
+			assert(is_CPP_bitwise_OR_expression(src.data<0>()[i]));
+			src.c_array<0>()[i].type_code.set_type(0);	// handle type inference later
+			assert(is_CPP_bitwise_OR_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static bool eval_bitwise_OR(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool,intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	assert(converts_to_integerlike(src.data<1>()->type_code ARG_TYPES));
+	assert(converts_to_integerlike(src.data<2>()->type_code ARG_TYPES));
+	// handle following:
+	// __ | 0 |-> __
+	// 0 | __ |-> __
+	// int-literal | int-literal |-> int-literal *if* both fit
+	// unary - gives us problems (result is target-specific, could generate a trap representation)
+	bool is_true = false;
+	if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES))
+		{
+		if (!is_true)
+			{	// 0 | __
+			// handle enumerators now
+			if (is_noticed_enumerator(*src.data<2>(),types))
+				enumerator_to_integer_representation(*src.c_array<2>(),types);
+			src.eval_to_arg<2>(0);
+			//! \bug convert char literal to appropriate integer
+			return true;
+			}
+		};
+	if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES))
+		{
+		if (!is_true)
+			{	// __ | 0
+			// handle enumerators now
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
+			src.eval_to_arg<1>(0);
+			//! \bug convert char literal to appropriate integer
+			return true;
+			}
+		};
+
+	umaxint lhs_int;
+	umaxint rhs_int;
+	if (intlike_literal_to_VM(lhs_int,*src.data<1>() ARG_TYPES) && intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES))
+		{
+		umaxint res_int(lhs_int);
+
+		res_int |= rhs_int;
+//		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
+		if 		(res_int==lhs_int)
+			// lhs | rhs = lhs; conserve type
+			{
+			// handle enumerators now
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
+			src.type_code.MoveInto(src.c_array<1>()->type_code);
+			src.eval_to_arg<1>(0);
+			}
+		else if (res_int==rhs_int)
+			// lhs | rhs = rhs; conserve type
+			{
+			// handle enumerators now
+			if (is_noticed_enumerator(*src.data<1>(),types))
+				enumerator_to_integer_representation(*src.c_array<1>(),types);
+			src.type_code.MoveInto(src.c_array<2>()->type_code);
+			src.eval_to_arg<2>(0);
+			}
+		else{
+			if (int_has_trapped(src,res_int)) return false;
+
+			const virtual_machine::std_int_enum machine_type = (virtual_machine::std_int_enum)((src.type_code.base_type_index-C_TYPE::INT)/2+virtual_machine::std_int_int);
+			const bool negative_signed_int = 0==(src.type_code.base_type_index-C_TYPE::INT)%2 && res_int.test(target_machine->C_bit(machine_type)-1);
+			if (negative_signed_int) target_machine->signed_additive_inverse(res_int,machine_type);
+			parse_tree tmp;
+			VM_to_literal(tmp,res_int,src,types);
+
+			if (negative_signed_int)
+				{	// convert to parsed - literal
+				src.DeleteIdx<1>(0);
+				force_unary_negative_literal(src,tmp);
+				}
+			else{	// convert to positive literal
+				src.type_code.MoveInto(tmp.type_code);
+				tmp.MoveInto(src);
+				}
+			}
+		return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc()
+static void C_bitwise_OR_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_bitwise_OR_expression(src));
+	// C99 6.5.12p2: requires being an integer type
+	if (binary_infix_failed_integer_arguments(src,"(C99 6.5.12p2)" ARG_TYPES)) return;
+	src.type_code.base_type_index = arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_OR(src,types,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) return;
+}
+
+//! \throw std::bad_alloc()
+static void CPP_bitwise_OR_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_CPP_bitwise_OR_expression(src));
+	// C++98 5.13p1: requires being an integer or enumeration type
+	if (binary_infix_failed_integer_arguments(src,"(C++98 5.13p1)" ARG_TYPES)) return;
+	src.type_code.base_type_index = arithmetic_reconcile(src.data<1>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES);
+	assert(converts_to_integerlike(src.type_code.base_type_index ARG_TYPES));
+	zaimoni::simple_lock<unsigned int> lock(no_runtime_errors);
+	if (eval_bitwise_OR(src,types,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) return;
+}
+
+/*
+inclusive-OR-expression:
+	exclusive-OR-expression
+	inclusive-OR-expression | exclusive-OR-expression
+*/
+//! \throw std::bad_alloc()
+static void locate_C99_bitwise_OR(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_C99_bitwise_OR(src,i))
+		C_bitwise_OR_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+/*
+inclusive-OR-expression:
+	exclusive-OR-expression
+	inclusive-OR-expression | exclusive-OR-expression
+*/
+//! \throw std::bad_alloc()
+static void locate_CPP_bitwise_OR(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_CPP_bitwise_OR(src,i))
+		//! \todo handle overloading
+		CPP_bitwise_OR_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+static bool binary_infix_failed_boolean_arguments(parse_tree& src, const char* standard SIG_CONST_TYPES)
+{	//! \todo so the error message isn't technically right...convertible to bool in C++ is morally equivalent to scalar in C
+	// cannot test this within preprocessor
+	assert(standard && *standard);
+
+	const bool rhs_converts_to_bool =  converts_to_bool(src.data<2>()->type_code ARG_TYPES);
+	if (!converts_to_bool(src.data<1>()->type_code ARG_TYPES))
+		{
+		simple_error(src,rhs_converts_to_bool ? " has nonscalar LHS" : " has nonscalar LHS and RHS");
+		INFORM(standard);
+		return true;
+		}
+	else if (!rhs_converts_to_bool)
+		{
+		simple_error(src," has nonscalar RHS");
+		INFORM(standard);
+		return true;
+		}
+	return false;
+}
+
+static bool terse_locate_C99_logical_AND(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+	if (token_is_string<2>(tmp_c_array[1].index_tokens[0].token,"&&"))
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_LOGICAND_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_BITOR_EXPRESSION & tmp_c_array[2].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_LOGICAND_EXPRESSION);	// tmp_c_array becomes invalid here
+			assert(is_C99_logical_AND_expression(src.data<0>()[i]));
+			src.c_array<0>()[i].type_code.set_type(C_TYPE::BOOL);	// technically wrong, but range is correct
+			assert(is_C99_logical_AND_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+static bool terse_locate_CPP_logical_AND(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"&&") || token_is_string<3>(src.data<0>()[i].index_tokens[0].token,"and"))
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if (	(PARSE_LOGICAND_EXPRESSION & src.data<0>()[i-1].flags)
+			&&	(PARSE_BITOR_EXPRESSION & src.data<0>()[i+1].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_LOGICAND_EXPRESSION);
+			assert(is_CPP_logical_AND_expression(src.data<0>()[i]));
+			//! \todo handle overloading
+			src.c_array<0>()[i].type_code.set_type(C_TYPE::BOOL);
+			assert(is_CPP_logical_AND_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+static bool eval_logical_AND(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool)
+{
+	// deal with literals here.  && short-circuit evaluates.
+	// 1 && __ |-> 0!=__
+	// 0 && __ |-> 0
+	// __ && 1 |-> 0!=__
+	// __ && 0 |-> __ && 0 (__ may have side effects...), *but* does "stop the buck" so
+	// (__ && 1) && __ |-> __ && 1
+
+	bool is_true = false;
+	if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES))
+		{	// one of 0 && __ or 1 && __
+		if (!is_true)
+			{	// 0 && __
+			if (src.flags & parse_tree::INVALID)
+				{
+				message_header(src.index_tokens[0]);
+				INC_INFORM("invalid ");
+				INC_INFORM(src);
+				INFORM(" optimized to valid 0");
+				};
+			force_decimal_literal(src,"0",types);
+			return true;
+			}
+		else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES))
+			{	// 1 && 1 or 1 && 0
+			force_decimal_literal(src,is_true ? "1" : "0",types);
+			return true;
+			}
+#if 0
+		//! \todo fixup 1 && __ when we have != and are working on C/C++ proper; anything already type bool could be reduced now
+		else{
+			}
+#endif
+		};
+#if 0
+		//! \todo fixup (__ && 1) && __ when we are working on C/C++ proper
+#endif
+	return false;
+}
+
+static void C_logical_AND_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_logical_AND_expression(src));
+	if (binary_infix_failed_boolean_arguments(src,"(C99 6.5.13p2)" ARG_TYPES)) return;
+
+	if (eval_logical_AND(src,types,C99_literal_converts_to_bool)) return;
+}
+
+static void CPP_logical_AND_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_CPP_logical_AND_expression(src));
+	if (binary_infix_failed_boolean_arguments(src,"(C++98 5.14p1)" ARG_TYPES)) return;
+
+	if (eval_logical_AND(src,types,CPP_literal_converts_to_bool)) return;
+}
+
+/*
+logical-AND-expression:
+	inclusive-OR-expression
+	logical-AND-expression && inclusive-OR-expression
+*/
+static void locate_C99_logical_AND(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_C99_logical_AND(src,i))
+		C_logical_AND_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+/*
+logical-AND-expression:
+	inclusive-OR-expression
+	logical-AND-expression && inclusive-OR-expression
+*/
+static void locate_CPP_logical_AND(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_CPP_logical_AND(src,i))
+		//! \todo check for operator overloading
+		CPP_logical_AND_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+static bool terse_locate_C99_logical_OR(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+	if (token_is_string<2>(tmp_c_array[1].index_tokens[0].token,"||"))
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		inspect_potential_paren_primary_expression(tmp_c_array[0]);
+		inspect_potential_paren_primary_expression(tmp_c_array[2]);
+		if (	(PARSE_LOGICOR_EXPRESSION & tmp_c_array[0].flags)
+			&&	(PARSE_LOGICAND_EXPRESSION & tmp_c_array[2].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_LOGICOR_EXPRESSION);	// tmp_c_array becomes invalid here
+			assert(is_C99_logical_OR_expression(src.data<0>()[i]));
+			src.c_array<0>()[i].type_code.set_type(C_TYPE::BOOL);	// technically wrong, but range is correct
+			assert(is_C99_logical_OR_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+static bool terse_locate_CPP_logical_OR(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"||") || token_is_string<2>(src.data<0>()[i].index_tokens[0].token,"or"))
+		{
+		if (1>i || 2>src.size<0>()-i) return false;
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i-1]);
+		inspect_potential_paren_primary_expression(src.c_array<0>()[i+1]);
+		if (	(PARSE_LOGICOR_EXPRESSION & src.data<0>()[i-1].flags)
+			&&	(PARSE_LOGICAND_EXPRESSION & src.data<0>()[i+1].flags))
+			{
+			assemble_binary_infix_arguments(src,i,PARSE_STRICT_LOGICOR_EXPRESSION);
+			assert(is_CPP_logical_OR_expression(src.data<0>()[i]));
+			src.c_array<0>()[i].type_code.set_type(C_TYPE::BOOL);
+			assert(is_CPP_logical_OR_expression(src.data<0>()[i]));
+			return true;
+			}
+		}
+	return false;
+}
+
+static bool eval_logical_OR(parse_tree& src, const type_system& types, literal_converts_to_bool_func& literal_converts_to_bool)
+{
+	// deal with literals here.  || short-circuit evaluates.
+	// 0 || __ |-> 0!=__
+	// 1 || __ |-> 1
+	// __ || 0 |-> 0!=__
+	// __ || 1 |-> __ || 1 (__ may have side effects...), *but* does "stop the buck" so
+	// (__ || 1) || __ |-> __ || 1
+
+	bool is_true = false;
+	if (literal_converts_to_bool(*src.data<1>(),is_true ARG_TYPES))
+		{	// one of 0 || __ or 1 || __
+		if (is_true)
+			{	// 1 || __
+			if (src.flags & parse_tree::INVALID)
+				{
+				message_header(src.index_tokens[0]);
+				INC_INFORM("invalid ");
+				INC_INFORM(src);
+				INFORM(" optimized to valid 1");
+				};
+			force_decimal_literal(src,"1",types);
+			return true;
+			}
+		else if (literal_converts_to_bool(*src.data<2>(),is_true ARG_TYPES))
+			{	// 0 || 1 or 0 || 0
+			force_decimal_literal(src,is_true ? "1" : "0",types);
+			return true;
+			}
+#if 0
+		//! \todo fixup 0 || __ when we have != and are working on C/C++ proper; anything already type bool could be reduced now
+		else{
+			}
+#endif
+		};
+#if 0
+		//! \todo fixup (__ || 1) || __ when we are working on C/C++ proper
+#endif
+	return false;
+}
+
+static void C_logical_OR_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_logical_OR_expression(src));
+	if (binary_infix_failed_boolean_arguments(src,"(C99 6.5.14p2)" ARG_TYPES)) return;
+
+	if (eval_logical_OR(src,types,C99_literal_converts_to_bool)) return;
+}
+
+static void CPP_logical_OR_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_CPP_logical_OR_expression(src));
+	if (binary_infix_failed_boolean_arguments(src,"(C++98 5.15p1)" ARG_TYPES)) return;
+
+	if (eval_logical_OR(src,types,CPP_literal_converts_to_bool)) return;
+}
+
+/*
+logical-OR-expression:
+	logical-AND-expression
+	logical-OR-expression || logical-AND-expression
+*/
+static void locate_C99_logical_OR(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_C99_logical_OR(src,i))
+		C_logical_OR_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+/*
+logical-OR-expression:
+	logical-AND-expression
+	logical-OR-expression || logical-AND-expression
+*/
+static void locate_CPP_logical_OR(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_CPP_logical_OR(src,i))
+		//! \todo check for operator overloading
+		CPP_logical_OR_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+//! \throw std::bad_alloc
+static bool terse_locate_conditional_op(parse_tree& src, size_t& i)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	assert(!(PARSE_OBVIOUS & src.data<0>()[i].flags));
+	assert(src.data<0>()[i].is_atomic());
+
+	if (token_is_char<'?'>(src.data<0>()[i].index_tokens[0].token))
+		{
+		// ? as first might be space deficiency (check uniqueness of construction)
+		if (1>i || 3>src.size<0>()-i) return false;
+		parse_tree* const tmp_c_array = src.c_array<0>()+(i-1);
+		if (	tmp_c_array[3].is_atomic()
+			&&	token_is_char<':'>(tmp_c_array[3].index_tokens[0].token))
+			{
+			inspect_potential_paren_primary_expression(tmp_c_array[0]);
+			inspect_potential_paren_primary_expression(tmp_c_array[2]);
+			inspect_potential_paren_primary_expression(tmp_c_array[4]);
+			if (	(PARSE_LOGICOR_EXPRESSION & src.data<0>()[i-1].flags)
+				&&	(PARSE_EXPRESSION & src.data<0>()[i+1].flags)
+				&&	(PARSE_CONDITIONAL_EXPRESSION & src.data<0>()[i+3].flags))
+				{
+				zaimoni::autoval_ptr<parse_tree> tmp;
+				zaimoni::autoval_ptr<parse_tree> tmp2;
+				tmp = repurpose_inner_parentheses(tmp_c_array[0]);	// RAM conservation
+				tmp2 = repurpose_inner_parentheses(tmp_c_array[2]);	// RAM conservation
+				parse_tree* const tmp3 = repurpose_inner_parentheses(tmp_c_array[4]);	// RAM conservation
+				tmp_c_array[0].OverwriteInto(*tmp);
+				tmp_c_array[2].OverwriteInto(*tmp2);
+				tmp_c_array[4].OverwriteInto(*tmp3);
+				tmp_c_array[1].grab_index_token_from<1,0>(tmp_c_array[3]);
+				tmp_c_array[1].grab_index_token_location_from<1,0>(tmp_c_array[3]);
+				tmp_c_array[1].fast_set_arg<0>(tmp2.release());
+				tmp_c_array[1].fast_set_arg<1>(tmp.release());
+				tmp_c_array[1].fast_set_arg<2>(tmp3);
+				tmp_c_array[1].core_flag_update();
+				tmp_c_array[1].flags |= PARSE_STRICT_CONDITIONAL_EXPRESSION;
+				src.DeleteNSlotsAt<0>(3,i+1);	// tmp_c_array becomes invalid here
+				src.DeleteIdx<0>(--i);
+				assert(is_C99_conditional_operator_expression_strict(src.data<0>()[i]));
+				parse_tree& tmp4 = src.c_array<0>()[i];
+				cancel_outermost_parentheses(tmp4.front<0>());
+				cancel_outermost_parentheses(tmp4.front<1>());
+				cancel_outermost_parentheses(tmp4.front<2>());
+				assert(is_C99_conditional_operator_expression(src.data<0>()[i]));
+				return true;
+				}
+			}
+		}
+	return false;
+}
+
+static bool eval_conditional_op(parse_tree& src, literal_converts_to_bool_func& literal_converts_to_bool SIG_CONST_TYPES)
+{
+	bool is_true = false;
+	if (literal_converts_to_bool(*src.c_array<1>(),is_true ARG_TYPES))
+		{
+		const bool was_invalid = src.flags & parse_tree::INVALID;
+		if (is_true)
+			{	// it's the infix arg
+			src.type_code.MoveInto(src.c_array<0>()->type_code);
+			src.eval_to_arg<0>(0);
+			}
+		else{	// it's the postfix arg
+			src.type_code.MoveInto(src.c_array<2>()->type_code);
+			src.eval_to_arg<2>(0);
+			};
+		if (was_invalid && !(src.flags & parse_tree::INVALID))
+			{
+			message_header(src.index_tokens[0]);
+			INC_INFORM("invalid ? : operator optimized to valid ");
+			INFORM(src);
+			}
+		return true;
+		}
+	return false;
+}
+
+//! \throws std::bad_alloc
+static void C_conditional_op_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_conditional_operator_expression(src));
+	// \todo 1) infix, postfix args have common non-void type (controls whether expression has valid type)
+	// \todo change target for multidimensional arrays
+	// \todo change target for const/volatile/restricted pointers
+	// NOTE: result is always an rvalue in C (C99 6.5.15p4)
+	switch(cmp(src.data<0>()->type_code.pointer_power,src.data<2>()->type_code.pointer_power))
+	{
+	case 1:	{	// LHS has more guaranteed indirectability than RHS
+			if (C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
+				{	// recoverable
+				src.type_code.set_type(C_TYPE::NOT_VOID);
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
+				}
+			else if (is_null_pointer_constant(*src.data<2>(),C99_intlike_literal_to_VM ARG_TYPES))
+				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
+				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
+				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
+				value_copy(src.type_code,src.data<0>()->type_code);
+			else{
+				src.type_code.set_type(0);	// incoherent type
+				// (...) ? string : int -- error
+				//! \test default/Error_if_control64.h 
+				simple_error(src," has incoherent type");
+				}
+			break;
+			}
+	case -1:{	// LHS has less guaranteed indirectability than RHS
+			if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index)
+				{	// recoverable
+				src.type_code.set_type(C_TYPE::NOT_VOID);
+				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power);
+				}
+			else if (is_null_pointer_constant(*src.data<0>(),C99_intlike_literal_to_VM ARG_TYPES))
+				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
+				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
+				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
+				value_copy(src.type_code,src.data<2>()->type_code);
+			else{
+				src.type_code.set_type(0);	// incoherent type
+				// (...) ? int : string -- error
+				//! \test default/Error_if_control65.h
+				simple_error(src," has incoherent type");
+				}
+			break;
+			}
+	case 0:	{
+			if (src.data<0>()->type_code.base_type_index==src.data<2>()->type_code.base_type_index)
+				{
+				src.type_code.set_type(src.data<0>()->type_code.base_type_index);
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
+				}
+			else if (0==src.data<0>()->type_code.pointer_power && (C_TYPE::VOID>=src.data<0>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index))
+				{	// can't test this from preprocessor
+				src.type_code.set_type(0);	// incoherent type
+				simple_error(src," has incoherent type");
+				}
+			//! \todo test cases at preprocessor level
+			else if (0==src.data<0>()->type_code.pointer_power && is_innate_definite_type(src.data<0>()->type_code.base_type_index) && is_innate_definite_type(src.data<2>()->type_code.base_type_index))
+				// standard arithmetic conversions
+				src.type_code.set_type(arithmetic_reconcile(src.data<0>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES));
+			//! \todo --do-what-i-mean can handle elementary integer types with same indirection as well
+			else if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index || C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
+				{
+				src.type_code.set_type(C_TYPE::NOT_VOID);
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
+				}
+			else{	// can't test this from preprocessor
+				src.type_code.set_type(0);	// incoherent type
+				simple_error(src," has incoherent type");
+				}
+			break;
+			}
+	}
+
+	// 2) prefix arg type convertible to _Bool (control whether expression is evaluatable at all)
+	if (!converts_to_bool(src.data<1>()->type_code ARG_TYPES))
+		{	// can't test this from preprocessor
+		simple_error(src," has nonscalar control expression");
+		return;
+		}
+	// 3) RAM conservation: if we have a suitable literal Do It Now
+	// \todo disable this at O0?
+	if (eval_conditional_op(src,C99_literal_converts_to_bool ARG_TYPES)) return;
+}
+
+//! \throws std::bad_alloc
+static void CPP_conditional_op_easy_syntax_check(parse_tree& src,const type_system& types)
+{
+	assert(is_C99_conditional_operator_expression(src));
+	// C++98/C++0x 13.3.1.2p1 mentions that overloading ? : is prohibited
+	// \todo 1) infix, postfix args have common non-void type (controls whether expression has valid type); watch out for throw expressions
+	// \todo change target for throw expressions
+	// \todo change target for multidimensional arrays
+	// \todo change target for const/volatile/restricted pointers
+	// NOTE: result is an lvalue if both are lvalues of identical type (C++98 5.16p4)
+	// NOTE: throw expressions play nice (they always have the type of the other half)
+	switch(cmp(src.data<0>()->type_code.pointer_power,src.data<2>()->type_code.pointer_power))
+	{
+	case 1:	{	// LHS has more guaranteed indirectability than RHS
+			if (C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
+				{	// recoverable
+				src.type_code.set_type(C_TYPE::NOT_VOID);
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
+				}
+			else if (is_null_pointer_constant(*src.data<2>(),CPP_intlike_literal_to_VM ARG_TYPES))
+				// (...) ? string : 0 -- do *not* error (null pointer); check true/false status
+				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
+				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
+				value_copy(src.type_code,src.data<0>()->type_code);
+			else{
+				src.type_code.set_type(0);	// incoherent type
+				// (...) ? string : int -- error
+				//! \test default/Error_if_control64.hpp
+				simple_error(src," has incoherent type");
+				}
+			break;
+			}
+	case -1:{	// LHS has less guaranteed indirectability than RHS
+			if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index)
+				{	// recoverable
+				src.type_code.set_type(C_TYPE::NOT_VOID);
+				src.type_code.set_pointer_power(src.data<2>()->type_code.pointer_power);
+				}
+			else if (is_null_pointer_constant(*src.data<0>(),CPP_intlike_literal_to_VM ARG_TYPES))
+				// (...) ? 0 : string -- do *not* error (null pointer); check true/false status
+				//! \test default/Pass_if_zero.h, default/Pass_if_zero.hpp 
+				// actually, could be either 1 (positively is null pointer constant) or -1 (could be).  We do the same thing in either case.
+				value_copy(src.type_code,src.data<2>()->type_code);
+			else{
+				src.type_code.set_type(0);	// incoherent type
+				// (...) ? int : string -- error
+				//! \test default/Error_if_control65.hpp
+				simple_error(src," has incoherent type");
+				}
+			break;
+			}
+	case 0:	{
+			if (src.data<0>()->type_code.base_type_index==src.data<2>()->type_code.base_type_index)
+				{
+				src.type_code.set_type(src.data<0>()->type_code.base_type_index);
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
+				}
+			else if (0==src.data<0>()->type_code.pointer_power && (C_TYPE::VOID>=src.data<0>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index))
+				{	// can't test this from preprocessor
+				src.type_code.set_type(0);	// incoherent type
+				simple_error(src," has incoherent type");
+				}
+			else if (0==src.data<0>()->type_code.pointer_power && is_innate_definite_type(src.data<0>()->type_code.base_type_index) && is_innate_definite_type(src.data<2>()->type_code.base_type_index))
+				// standard arithmetic conversions
+				src.type_code.set_type(arithmetic_reconcile(src.data<0>()->type_code.base_type_index,src.data<2>()->type_code.base_type_index ARG_TYPES));
+			//! \todo --do-what-i-mean can handle elementary integer types with same indirection as well
+			else if (C_TYPE::NOT_VOID==src.data<0>()->type_code.base_type_index || C_TYPE::NOT_VOID==src.data<2>()->type_code.base_type_index)
+				{
+				src.type_code.set_type(C_TYPE::NOT_VOID);
+				src.type_code.set_pointer_power(src.data<0>()->type_code.pointer_power);
+				}
+			else{	// can't test this from preprocessor
+				src.type_code.set_type(0);	// incoherent type
+				simple_error(src," has incoherent type");
+				}
+			break;
+			}
+	}
+
+	// 2) prefix arg type convertible to bool (control whether expression is evaluatable at all)
+	if (!converts_to_bool(src.data<1>()->type_code ARG_TYPES))
+		{	// can't test this from preprocessor
+		simple_error(src," has control expression unconvertible to bool");
+		return;
+		}
+	// 3) RAM conservation: if we have a suitable literal Do It Now
+	// \todo disable this at O0?
+	if (eval_conditional_op(src,CPP_literal_converts_to_bool ARG_TYPES)) return;
+}
+
+//! \throws std::bad_alloc
+static void locate_C99_conditional_op(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_conditional_op(src,i))
+		C_conditional_op_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+//! \throws std::bad_alloc
+static void locate_CPP_conditional_op(parse_tree& src, size_t& i, const type_system& types)
+{
+	assert(!src.empty<0>());
+	assert(i<src.size<0>());
+	if (   (PARSE_OBVIOUS & src.data<0>()[i].flags)
+		|| !src.data<0>()[i].is_atomic())
+		return;
+
+	if (terse_locate_conditional_op(src,i))
+		CPP_conditional_op_easy_syntax_check(src.c_array<0>()[i],types);
+}
+
+template<class T>
+static void parse_forward(parse_tree& src,const type_system& types, T parse_handler)
+{
+	assert(!src.empty<0>());
+	if (0<src.size<0>())
+		{
+		size_t i = 0;
+		do	{
+			if (parse_tree::INVALID & src.data<0>()[i].flags) continue;
+			parse_handler(src,i,types);
+			}
+		while(src.size<0>()>++i);
+		};
+}
+
+template<class T>
+static void parse_backward(parse_tree& src,const type_system& types, T parse_handler)
+{
+	assert(!src.empty<0>());
+	if (0<src.size<0>())
+		{
+		size_t i = src.size<0>();
+		do	{
+			if (parse_tree::INVALID & src.data<0>()[--i].flags) continue;
+			parse_handler(src,i,types);
+			}
+		while(0<i);
+		};
+}
+
+// top-level has SIZE_MAX for parent_identifier_count
+//! \throws std::bad_alloc
+static void C99_locate_expressions(parse_tree& src,const size_t parent_identifier_count,const type_system& types)
+{
+	if (PARSE_OBVIOUS & src.flags) return;
+	size_t identifier_count = (0==parent_identifier_count) ? 0 : _count_identifiers(src);
+	{
+	size_t i[3] = {src.size<0>(), src.size<1>(), src.size<2>()};
+	size_t initial_i[3];
+full_restart:
+	memmove(initial_i,i,3*sizeof(size_t));
+	size_t stalled[3] = {SIZE_MAX,SIZE_MAX,SIZE_MAX};
+	try {
+		while(0<i[0]) C99_locate_expressions(src.c_array<0>()[--i[0]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[0] = i[0]++;
+		goto restart_1;
+		}
+restart_1:
+	try {
+		while(0<i[1]) C99_locate_expressions(src.c_array<1>()[--i[1]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[1] = i[1]++;
+		goto restart_2;
+		}
+restart_2:
+	try {
+		while(0<i[2]) C99_locate_expressions(src.c_array<2>()[--i[2]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[2] = i[2]++;
+		goto restart_3;
+		}
+restart_3:
+	if (SIZE_MAX>stalled[0] || SIZE_MAX>stalled[1] || SIZE_MAX>stalled[2])
+		{	// had a memory management problem
+		if (i[0]<initial_i[0] || i[1]<initial_i[1] || i[2]<initial_i[2])
+			// if we made some progress, restart
+			goto full_restart;
+		// otherwise give up
+		throw std::bad_alloc();
+		}
+	}
+
+	const bool top_level = SIZE_MAX==parent_identifier_count;
+	const bool parens_are_expressions = 0==parent_identifier_count	// no identifiers from outside
+									|| (top_level && 0==identifier_count);	// top-level, no identifiers
+
+	if (parens_are_expressions || top_level || parent_identifier_count==identifier_count)
+		if (inspect_potential_paren_primary_expression(src))
+			{
+			if (top_level && 1==src.size<0>() && is_naked_parentheses_pair(src))
+				src.eval_to_arg<0>(0);
+			return;
+			}
+
+	// top-level [ ] and { } die regardless of contents
+	// note that top-level [ ] should be asphyxiating now
+	if (top_level && suppress_naked_brackets_and_braces(src,"top-level",sizeof("top-level")-1))
+		return;
+
+	if (!src.empty<0>())
+		{
+		suppress_naked_brackets_and_braces(*src.c_array<0>(),"top-level",sizeof("top-level")-1);
+		parse_forward(src,types,locate_C99_postfix_expression);
+		parse_backward(src,types,locate_C99_unary_expression);
+		parse_forward(src,types,locate_C99_mult_expression);
+		parse_forward(src,types,locate_C99_add_expression);
+		parse_forward(src,types,locate_C99_shift_expression);
+		parse_forward(src,types,locate_C99_relation_expression);
+		parse_forward(src,types,locate_C99_equality_expression);
+		parse_forward(src,types,locate_C99_bitwise_AND);
+		parse_forward(src,types,locate_C99_bitwise_XOR);
+		parse_forward(src,types,locate_C99_bitwise_OR);
+		parse_forward(src,types,locate_C99_logical_AND);
+		parse_forward(src,types,locate_C99_logical_OR);
+		parse_backward(src,types,locate_C99_conditional_op);
+/*
+assignment-expression:
+	conditional-expression
+	unary-expression assignment-operator assignment-expression
+
+assignment-operator: one of
+	= *= /= %= += -= <<= >>= &= ^= |=
+*/
+#if 0
+		parse_backward(src,types,...);
+#endif
+/*
+expression:
+	assignment-expression
+	expression , assignment-expression
+*/
+#if 0
+		parse_forward(src,types,...);
+#endif
+		};
+}
+
+// top-level has SIZE_MAX for parent_identifier_count
+//! \throws std::bad_alloc
+static void CPP_locate_expressions(parse_tree& src,const size_t parent_identifier_count,const type_system& types)
+{
+	if (PARSE_OBVIOUS & src.flags) return;
+	const size_t identifier_count = (0==parent_identifier_count) ? 0 : _count_identifiers(src);
+	{
+	size_t i[3] = {src.size<0>(), src.size<1>(), src.size<2>()};
+	size_t initial_i[3];
+full_restart:
+	memmove(initial_i,i,3*sizeof(size_t));
+	size_t stalled[3] = {SIZE_MAX,SIZE_MAX,SIZE_MAX};
+	try {
+		while(0<i[0]) CPP_locate_expressions(src.c_array<0>()[--i[0]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[0] = i[0]++;
+		goto restart_1;
+		}
+restart_1:
+	try {
+		while(0<i[1]) CPP_locate_expressions(src.c_array<1>()[--i[1]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[1] = i[1]++;
+		goto restart_2;
+		}
+restart_2:
+	try {
+		while(0<i[2]) CPP_locate_expressions(src.c_array<2>()[--i[2]],identifier_count,types);
+		}
+	catch(std::bad_alloc&)
+		{
+		stalled[2] = i[2]++;
+		goto restart_3;
+		}
+restart_3:
+	if (SIZE_MAX>stalled[0] || SIZE_MAX>stalled[1] || SIZE_MAX>stalled[2])
+		{	// had a memory management problem
+		if (i[0]<initial_i[0] || i[1]<initial_i[1] || i[2]<initial_i[2])
+			// if we made some progress, restart
+			goto full_restart;
+		// otherwise give up
+		throw std::bad_alloc();
+		}
+	}
+	
+	const bool top_level = SIZE_MAX==parent_identifier_count;
+	const bool parens_are_expressions = 0==parent_identifier_count	// no identifiers from outside
+									|| (top_level && 0==identifier_count);	// top-level, no identifiers
+
+	// try for ( expression )
+	if (parens_are_expressions || top_level || parent_identifier_count==identifier_count)
+		if (inspect_potential_paren_primary_expression(src))
+			{
+			if (top_level && 1==src.size<0>() && is_naked_parentheses_pair(src))
+				src.eval_to_arg<0>(0);
+			return;
+			}
+
+	// top-level [ ] and { } die regardless of contents
+	if (top_level && suppress_naked_brackets_and_braces(src,"top-level",sizeof("top-level")-1))
+		return;
+
+	if (!src.empty<0>())
+		{
+		suppress_naked_brackets_and_braces(*src.c_array<0>(),"top-level",sizeof("top-level")-1);
+		parse_forward(src,types,locate_CPP_postfix_expression);
+		parse_backward(src,types,locate_CPP_unary_expression);
+#if 0
+/*
+pmexpression:
+	castexpression
+	pmexpression .* castexpression
+	pmexpression ->* castexpression
+*/
+		parse_forward(src,types,...);
+#endif
+		parse_forward(src,types,locate_CPP_mult_expression);
+		parse_forward(src,types,locate_CPP_add_expression);
+		parse_forward(src,types,locate_CPP_shift_expression);
+		parse_forward(src,types,locate_CPP_relation_expression);
+		parse_forward(src,types,locate_CPP_equality_expression);
+		parse_forward(src,types,locate_CPP_bitwise_AND);
+		parse_forward(src,types,locate_CPP_bitwise_XOR);
+		parse_forward(src,types,locate_CPP_bitwise_OR);
+		parse_forward(src,types,locate_CPP_logical_AND);
+		parse_forward(src,types,locate_CPP_logical_OR);
+		parse_backward(src,types,locate_CPP_conditional_op);
+/*
+assignment-expression:
+	conditional-expression
+	unary-expression assignment-operator assignment-expression
+
+assignment-operator: one of
+	= *= /= %= += -= <<= >>= &= ^= |=
+*/
+#if 0
+		parse_backward(src,types,...);
+#endif
+/*
+expression:
+	assignment-expression
+	expression , assignment-expression
+*/
+#if 0
+		parse_forward(src,types,...);
+#endif
+		};
+}
+
+static void _label_CPP_literal(parse_tree& src)
+{
+	if (src.is_atomic() && C_TESTFLAG_IDENTIFIER==src.index_tokens[0].flags) 
+		{
+		if 		(token_is_string<4>(src.index_tokens[0].token,"true"))
+			{
+			src.flags |= (PARSE_PRIMARY_EXPRESSION | parse_tree::CONSTANT_EXPRESSION);
+			src.type_code.set_type(C_TYPE::BOOL);
+			}
+		else if (token_is_string<4>(src.index_tokens[0].token,"this"))
+			{
+			src.flags |= PARSE_PRIMARY_EXPRESSION;
+			src.type_code.set_type(C_TYPE::NOT_VOID);
+			src.type_code.set_pointer_power(1);
+			}
+		else if (token_is_string<5>(src.index_tokens[0].token,"false"))
+			{
+			src.flags |= (PARSE_PRIMARY_EXPRESSION | parse_tree::CONSTANT_EXPRESSION);
+			src.type_code.set_type(C_TYPE::BOOL);
+			}
+		}
+}
+
+//! \throw std::bad_alloc
+static bool C99_CondenseParseTree(parse_tree& src,const type_system& types)
+{
+	assert(src.is_raw_list());
+	assert(1<src.size<0>());
+	const size_t starting_errors = zcc_errors.err_count();
+	_label_literals(src,types);
+	if (!_match_pairs(src)) return false;
+	try {
+		C99_locate_expressions(src,SIZE_MAX,types);
+		}
+	catch(std::bad_alloc&)
+		{	// error count change is already false
+		if (starting_errors<zcc_errors.err_count()) return false;
+		throw;
+		}
+	if (starting_errors<zcc_errors.err_count()) return false;
+	while(src.is_raw_list() && 1==src.size<0>()) src.eval_to_arg<0>(0);
+	return true;
+}
+
+//! \throw std::bad_alloc
+static bool CPP_CondenseParseTree(parse_tree& src,const type_system& types)
+{
+	assert(src.is_raw_list());
+	assert(1<src.size<0>());
+	const size_t starting_errors = zcc_errors.err_count();
+	_label_literals(src,types);
+	std::for_each(src.begin<0>(),src.end<0>(),_label_CPP_literal);	// intercepts: true, false, this
+	if (!_match_pairs(src)) return false;
+	// check that this is at least within a brace pair or a parentheses pair (it is actually required to be in a non-static member function, or constructor mem-initializer
+	if (!_this_vaguely_where_it_could_be_cplusplus(src)) return false;
+	try {
+		CPP_locate_expressions(src,SIZE_MAX,types);
+		}
+	catch(std::bad_alloc&)
+		{	// error count change is already false
+		if (starting_errors<zcc_errors.err_count()) return false;
+		throw;
+		}
+	if (starting_errors<zcc_errors.err_count()) return false;
+	while(src.is_raw_list() && 1==src.size<0>()) src.eval_to_arg<0>(0);
+	return true;
+}
+
+static const POD_pair<const char*,size_t> C99_nontype_decl_specifier_list[] =
+	{	DICT_STRUCT("typedef"),
+		DICT_STRUCT("const"),
+		DICT_STRUCT("volatile"),
+		DICT_STRUCT("restrict"),
+		DICT_STRUCT("register"),
+		DICT_STRUCT("static"),
+		DICT_STRUCT("extern"),
+		DICT_STRUCT("inline"),
+		DICT_STRUCT("auto"),
+		DICT_STRUCT("_Thread_Local"),	// C1X, actually
+	};
+
+static const POD_pair<const char*,size_t> CPP0X_nontype_decl_specifier_list[] =
+	{	DICT_STRUCT("typedef"),
+		DICT_STRUCT("const"),
+		DICT_STRUCT("volatile"),
+		DICT_STRUCT("register"),
+		DICT_STRUCT("static"),
+		DICT_STRUCT("extern"),
+		DICT_STRUCT("inline"),
+		DICT_STRUCT("thread_local"),	// C1X _Thread_Local
+		DICT_STRUCT("constexpr"),
+		DICT_STRUCT("mutable"),
+		DICT_STRUCT("virtual"),
+		DICT_STRUCT("explicit"),
+		DICT_STRUCT("friend")
+	};
+
+size_t C99_type_or_invariant_decl_specifier(const parse_tree& x)
+{
+	if (PARSE_TYPE & x.flags)
+		return STATIC_SIZE(C99_nontype_decl_specifier_list);
+	if (x.is_atomic())
+		{
+		const errr i = linear_find(x.index_tokens[0].token.first,C99_nontype_decl_specifier_list,STATIC_SIZE(C99_nontype_decl_specifier_list));
+		if (STATIC_SIZE(C99_nontype_decl_specifier_list)>i) return i;
+		}
+	return SIZE_MAX;
+}
+
+size_t CPP0X_type_or_invariant_decl_specifier(const parse_tree& x)
+{
+	if (PARSE_TYPE & x.flags)
+		return STATIC_SIZE(CPP0X_nontype_decl_specifier_list); 
+	if (x.is_atomic())
+		{
+		const errr i = linear_find(x.index_tokens[0].token.first,CPP0X_nontype_decl_specifier_list,STATIC_SIZE(CPP0X_nontype_decl_specifier_list));
+		if (STATIC_SIZE(CPP0X_nontype_decl_specifier_list)>i) return i;
+		}
+	return SIZE_MAX;
+}	
+
+void record_qualifier(parse_tree* x, unsigned char qualify)
+{
+	assert(x);
+	assert(PARSE_TYPE & x->flags);
+tail_recurse:
+	x->type_code.q_vector.back() |= qualify;
+	if (is_naked_parentheses_pair(*x) && 1==x->size<0>() && (PARSE_TYPE & x->data<0>()->flags))
+		{	// discard nested parentheses
+		while(is_naked_parentheses_pair(*x->data<0>()) && 1==x->data<0>()->size<0>() && (PARSE_TYPE & x->data<0>()->data<0>()->flags))
+			x->c_array<0>()->eval_to_arg<0>(0);
+		// tail-recurse
+		x = x->c_array<0>();
+		goto tail_recurse;
+		}
+}
+
+void record_qualifier_or_warn(parse_tree& src,unsigned char qualify,size_t type_at,size_t qual_at,bool& have_warned,const char* const warning)
+{
+	assert(src.size<0>()>type_at);
+	assert(src.size<0>()>qual_at);
+	assert(PARSE_TYPE & src.data<0>()[type_at].flags);
+	if (!(qualify & src.data<0>()[type_at].type_code.q_vector.back()))
+		record_qualifier(src.c_array<0>()+type_at,qualify);
+	else if (!have_warned)
+		{	// already qualified, have not warned yet
+		message_header(src.data<0>()[qual_at].index_tokens[0]);
+		INC_INFORM(WARN_STR);
+		INFORM(warning);
+		if (bool_options[boolopt::warnings_are_errors])
+			zcc_errors.inc_error();
+		have_warned = true;
+		}
+}
+
+static void _condense_const_volatile_onto_type(parse_tree& src,size_t& i,kleene_star_core<size_t (*)(const parse_tree&)>& invariant_decl_scanner,const char* const warn_const,const char* const warn_volatile)
+{
+	size_t offset = 0;
+	bool have_warned_too_many_types = false;
+	bool have_warned_about_const = false;
+	bool have_warned_about_volatile = false;
+
+	assert(PARSE_TYPE & src.data<0>()[i].flags);
+	while(0<i-offset && invariant_decl_scanner(src.data<0>()[i- ++offset]))
+		switch(invariant_decl_scanner[offset-1])
+		{
+		case C99_CPP_CONST_IDX:
+			//! \test decl.C99/Warn_dup_const.h
+			//! \test decl.C99/Warn_dup_const.hpp
+			//! \test decl.C99/Warn_dup_const2.h
+			//! \test decl.C99/Warn_dup_const2.hpp
+			record_qualifier_or_warn(src,type_spec::_const,i,i-offset,have_warned_about_const,warn_const);
+			src.DeleteIdx<0>(i-- -offset);
+			invariant_decl_scanner.DeleteIdx(--offset);
+			continue;
+		case C99_CPP_VOLATILE_IDX:
+			//! \test decl.C99/Warn_dup_volatile.h
+			//! \test decl.C99/Warn_dup_volatile.hpp
+			//! \test decl.C99/Warn_dup_volatile2.h
+			//! \test decl.C99/Warn_dup_volatile2.hpp
+			record_qualifier_or_warn(src,type_spec::_volatile,i,i-offset,have_warned_about_volatile,warn_volatile);
+			src.DeleteIdx<0>(i-- -offset);
+			invariant_decl_scanner.DeleteIdx(--offset);
+			continue;
+		default:
+			if (invariant_decl_scanner.strict_ub()-1==invariant_decl_scanner[offset-1])
+				{
+				if (!have_warned_too_many_types)
+					{
+					message_header(src.data<0>()[i-offset].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("multiple types in decl-specifier sequence, discarding extra types");
+					zcc_errors.inc_error();
+					have_warned_too_many_types = true;
+					}
+				src.DeleteIdx<0>(i-- -offset);
+				invariant_decl_scanner.DeleteIdx(--offset);
+				continue;
+				}
+		}
+
+	invariant_decl_scanner.clear();
+	offset = 0;
+	while(src.size<0>()-i>offset+1 && invariant_decl_scanner(src.data<0>()[i+ ++offset]))
+		switch(invariant_decl_scanner[offset-1])
+		{
+		case C99_CPP_CONST_IDX:
+			//! \test decl.C99/Warn_dup_const2.h
+			//! \test decl.C99/Warn_dup_const2.hpp
+			//! \test decl.C99/Warn_dup_const3.h
+			//! \test decl.C99/Warn_dup_const3.hpp
+			record_qualifier_or_warn(src,type_spec::_const,i,i+offset,have_warned_about_const,warn_const);
+			src.DeleteIdx<0>(i+offset);
+			invariant_decl_scanner.DeleteIdx(--offset);
+			continue;
+		case C99_CPP_VOLATILE_IDX:
+			//! \test decl.C99/Warn_dup_volatile2.h
+			//! \test decl.C99/Warn_dup_volatile2.hpp
+			//! \test decl.C99/Warn_dup_volatile3.h
+			//! \test decl.C99/Warn_dup_volatile3.hpp
+			record_qualifier_or_warn(src,type_spec::_volatile,i,i+offset,have_warned_about_volatile,warn_volatile);
+			src.DeleteIdx<0>(i+offset);
+			invariant_decl_scanner.DeleteIdx(--offset);
+			continue;
+		default:
+			if (invariant_decl_scanner.strict_ub()-1==invariant_decl_scanner[offset-1])
+				{
+				if (!have_warned_too_many_types)
+					{
+					message_header(src.data<0>()[i+offset].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("multiple types in decl-specifier sequence, discarding extra types");
+					zcc_errors.inc_error();
+					have_warned_too_many_types = true;
+					}
+				src.DeleteIdx<0>(i-- +offset);
+				invariant_decl_scanner.DeleteIdx(--offset);
+				continue;
+				}
+		}
+
+	invariant_decl_scanner.clear();
+}
+
+void C99_condense_const_volatile_onto_type(parse_tree& src)
+{
+	assert(src.is_raw_list());
+	size_t i = 0;
+	kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(C99_type_or_invariant_decl_specifier);
+	do	if (PARSE_TYPE & src.data<0>()[i].flags)
+			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+	while(src.size<0>()> ++i);
+}
+
+void CPP0X_condense_const_volatile_onto_type(parse_tree& src)
+{
+	assert(src.is_raw_list());
+	size_t i = 0;
+	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier);
+	do	if (PARSE_TYPE & src.data<0>()[i].flags)
+			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+	while(src.size<0>()> ++i);
+}
+
+//! \todo check that the fact all literals are already legal-form is used
+//! \throw std::bad_alloc()
+static void C99_ContextFreeParse(parse_tree& src,const type_system& types)
+{
+	assert(src.is_raw_list());
+	_label_literals(src,types);
+	// handle core type specifiers
+	C99_notice_primary_type(src);
+	C99_condense_const_volatile_onto_type(src);
+	if (!_match_pairs(src)) return;
+	// struct/union/enum specifiers can occur in all sorts of strange places
+	C99_notice_struct_union_enum(src);
+}
+
+static bool CPP_ok_for_toplevel_qualified_name(const parse_tree& x)
+{
+	if (!x.is_atomic()) return false;
+	if (PARSE_PRIMARY_TYPE & x.flags) return false;
+	if (CPP_echo_reserved_keyword(x.index_tokens[0].token.first,x.index_tokens[0].token.second)) return false;
+	if (C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags) return true;
+	if (token_is_string<2>(x.index_tokens[0].token,"::")) return true;
+	return false;
+}
+
+//! \throw std::bad_alloc
+static void CPP_notice_scope_glue(parse_tree& src)
+{
+	assert(!src.empty<0>());
+	size_t i = 0;
+	{
+	size_t offset = 0;
+	while(i+offset<src.size<0>())
+		{
+		if (robust_token_is_string<2>(src.data<0>()[i],"::"))
+			{
+			const bool is_global = (0<i) && !CPP_ok_for_toplevel_qualified_name(src.data<0>()[i-1]);
+			size_t resize_to = src.data<0>()[i].index_tokens[0].token.second;
+			size_t forward_span = 0;
+			bool last_scope = true;
+			bool have_suppressed_consecutive_scope = false;
+			while(i+offset+forward_span+1<src.size<0>() && CPP_ok_for_toplevel_qualified_name(src.data<0>()[i+forward_span+1]))
+				{
+				const bool this_scope = robust_token_is_string<2>(src.data<0>()[i+forward_span+1],"::");
+				if (!last_scope && !this_scope) break;
+				if (last_scope && this_scope)
+					{
+					if (!have_suppressed_consecutive_scope)
+						{	//! \test zcc/decl.C99/Error_consecutive_doublecolon_type.hpp
+						simple_error(src.c_array<0>()[i]," consecutive :: operators in nested-name-specifier");
+						have_suppressed_consecutive_scope = true;
+						}
+					// remove from parse
+					src.DestroyNAtAndRotateTo<0>(1,i+forward_span,src.size<0>()-offset);
+					offset += 1;
+					continue;
+					}
+				last_scope = this_scope;
+				++forward_span;
+				resize_to += src.data<0>()[i+forward_span].index_tokens[0].token.second;
+				};
+			// assemble this into something identifier-like
+			if (!is_global)
+				{
+				--i;
+				++forward_span;
+				resize_to += src.data<0>()[i].index_tokens[0].token.second;
+				};
+			if (0<forward_span)
+				{
+				char* tmp = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(resize_to));
+				if (NULL==tmp)
+					{
+					if (0==offset) throw std::bad_alloc();
+					src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
+					offset = 0;
+					tmp = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(resize_to));
+					};
+				strncpy(tmp,src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].token.second);
+				size_t j = 1;
+				do	strncat(tmp,src.data<0>()[i+j].index_tokens[0].token.first,src.data<0>()[i+j].index_tokens[0].token.second);
+				while(forward_span>= ++j);
+				const char* tmp2 = is_string_registered(tmp);
+				if (NULL==tmp2)
+					{
+					src.c_array<0>()[i].grab_index_token_from_str_literal<0>(tmp,C_TESTFLAG_IDENTIFIER);	// well...not really, but it'll substitute for one
+					src.c_array<0>()[i].control_index_token<0>(true);
+					}
+				else{
+					free(tmp);
+					src.c_array<0>()[i].grab_index_token_from_str_literal<0>(tmp2,C_TESTFLAG_IDENTIFIER);	// well...not really, but it'll substitute for one
+					};
+				j = 1;
+				do	src.c_array<0>()[i+j].destroy();
+				while(forward_span>= ++j);
+				src.DestroyNAtAndRotateTo<0>(forward_span,i+1,src.size<0>()-offset);
+				offset += forward_span;
+				};
+			if (last_scope)
+				{	// might be able to save: new, delete, operator ___, destructor name
+				if (	i+offset+1>=src.size<0>()
+					||	(   !robust_token_is_string<3>(src.data<0>()[i+1],"new")
+						 && !robust_token_is_string<6>(src.data<0>()[i+1],"delete")
+						 && !robust_token_is_string<8>(src.data<0>()[i+1],"operator")
+						 && !robust_token_is_char<'~'>(src.data<0>()[i+1])))	// no, compl does not interoperate for destructor names
+					//! \test zcc/decl.C99/Error_doublecolon_type.hpp
+					simple_error(src.c_array<0>()[i]," nested-name-specifier ending in ::");
+				}
+			};
+		++i;
+		};
+	if (0<offset) src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
+	}
+
+	// efficiency tuning: we have to have no empty slots at top level before recursing,
+	// to mitigate risk of dynamic memory allocation failure
+	std::for_each(src.begin<0>(),src.end<0>(),conditional_action<bool (*)(const parse_tree&),void (*)(parse_tree&)>(is_nonempty_naked_pair,CPP_notice_scope_glue));
+}
+
+static void CPP_handle_pragma_relay(parse_tree& src)
+{
+	assert(src.is_raw_list());
+	// early return implied never to happen by assert, but don't want risk of undefined behavior in release mode
+	if (src.empty<0>()) return;
+	bool typeid_is_ok = false;	// has to be enabled in #include <typeinfo>
+	size_t i = 0;
+	do	{
+		if (src.data<0>()[i].is_atomic())
+			{
+			const errr Idx = linear_find(src.data<0>()[i].index_tokens[0].token.first, src.data<0>()[i].index_tokens[0].token.second,pragma_relay_keywords,PRAGMA_RELAY_KEYWORDS_STRICT_UB);
+			if (0<=Idx)
+				{	// react to any relay keywords that actually mean anything here
+				if (RELAY_ZCC_ENABLE_TYPEID==Idx) typeid_is_ok = true;
+				src.DeleteIdx<0>(i);
+				}
+			else if (!typeid_is_ok && token_is_string<6>(src.data<0>()[i].index_tokens[0].token,"typeid"))
+				//! \test staticassert.C1X/Error_typeid_no_typeinfo.hpp
+				simple_error(src.c_array<0>()[i]," requires #include <typeinfo> first (C++0X 5.2.8p6)");
+			}
+		}
+	while(src.size<0>()> ++i);
+}
+
+//! \todo check that the fact all literals are already legal-form is used
+//! \throw std::bad_alloc
+static void CPP_ContextFreeParse(parse_tree& src,const type_system& types)
+{
+	assert(src.is_raw_list());
+	CPP_handle_pragma_relay(src);
+	_label_literals(src,types);
+	std::for_each(src.begin<0>(),src.end<0>(),_label_CPP_literal);	// intercepts: true, false, this
+	// handle core type specifiers
+	CPP_notice_primary_type(src);
+	CPP0X_condense_const_volatile_onto_type(src);
+	if (!_match_pairs(src)) return;
+	// do context-free part of qualified-names
+	CPP_notice_scope_glue(src);
+	// class/struct/union/enum specifiers can occur in all sorts of strange places
+	CPP_notice_class_struct_union_enum(src);
+}
+
+//! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
+bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
+{
+	assert(x && *x);
+	assert(0<x_len);
+	assert(C_TESTFLAG_PP_NUMERAL & flags);
+	assert(!(C_TESTFLAG_FLOAT & flags));
+	C_REALITY_CHECK_PP_NUMERAL_FLAGS(flags);
+	//! \todo need some way to signal legality for integer literals
+	switch(C_EXTRACT_BASE_CODE(flags))
+	{
+#ifndef NDEBUG
+	default: FATAL_CODE("unclassified integer literal",3);
+#endif
+	case C_BASE_OCTAL:
+		{	// all-zeros is zero, ok with leading 0 prefix
+		C_PPOctalInteger test_oct;
+		ZAIMONI_PASSTHROUGH_ASSERT(C_PPOctalInteger::is(x,x_len,test_oct));
+		return strspn(test_oct.ptr,"0") == test_oct.digit_span;
+		};
+	case C_BASE_DECIMAL:
+		{	// decimal is easy
+		C_PPDecimalInteger test_dec;
+		ZAIMONI_PASSTHROUGH_ASSERT(C_PPDecimalInteger::is(x,x_len,test_dec));
+		return 1==test_dec.digit_span && '0'==test_dec.ptr[0];
+		};
+	case C_BASE_HEXADECIMAL:
+		{	// all-zeros is zero, but ignore the leading 0x prefix
+		C_PPHexInteger test_hex;
+		ZAIMONI_PASSTHROUGH_ASSERT(C_PPHexInteger::is(x,x_len,test_hex));
+		return strspn(test_hex.ptr+2,"0")+2 == test_hex.digit_span;
+		};
+	}
+#ifdef NDEBUG
+	return false;
+#endif
+}
+
+static void eval_string_literal_deref(parse_tree& src,const type_system& types,const POD_pair<const char*,size_t>& str_lit,const umaxint& tmp,bool is_negative,bool index_src_is_char)
+{
+	const size_t strict_ub = LengthOfCStringLiteral(str_lit.first,str_lit.second);
+	// C99 6.2.6.2p3 -0 is not actually allowed to generate the bitpattern -0, so no trapping
+	if (is_negative && tmp==0) is_negative = false;
+	if (is_negative)
+		{	//! \test default/Error_if_control66.hpp, default/Error_if_control66.h
+			//! \test default/Error_if_control67.hpp, default/Error_if_control67.h
+		if (!(src.flags & parse_tree::INVALID))
+			{
+			message_header(src.index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INC_INFORM("undefined behavior: ");
+			INC_INFORM(src);
+			INFORM(" dereferences string literal with negative index");
+			if (index_src_is_char)
+				INFORM("(does this source code want char to act like unsigned char?)");
+			src.flags |= parse_tree::INVALID;
+			zcc_errors.inc_error();
+			}
+		return;
+		}
+	else if (strict_ub <= tmp)
+		{	//! \test default/Error_if_control68.hpp, default/Error_if_control68.h
+			//! \test default/Error_if_control69.hpp, default/Error_if_control69.h
+		if (!(src.flags & parse_tree::INVALID))
+			{
+			message_header(src.index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INC_INFORM("undefined behavior: ");
+			INC_INFORM(src);
+			INFORM(" dereferences string literal past its end");
+			if (index_src_is_char && target_machine->signed_max<virtual_machine::std_int_char>()<tmp)
+				{
+				if (tmp.to_uint()-1==target_machine->signed_max<virtual_machine::std_int_char>())
+					INFORM("(does this source code want char to act like signed char, with integer representation sign-and-magnitude?)");
+				else if (tmp==target_machine->unsigned_max<virtual_machine::std_int_char>())
+					INFORM("(does this source code want char to act like signed char, with integer representation one's complement?)");
+				}
+			src.flags |= parse_tree::INVALID;
+			zcc_errors.inc_error();
+			}
+		return;
+		};
+	char* tmp2 = NULL;
+	assert(tmp.representable_as_uint());
+	GetCCharacterLiteralAt(str_lit.first,str_lit.second,tmp.to_uint(),tmp2);
+	assert(tmp2);
+	src.destroy();	// str_lit goes invalid here, don't use again
+	src.grab_index_token_from<0>(tmp2,C_TESTFLAG_CHAR_LITERAL);
+	_label_one_literal(src,types);
+}
+
+#define ZCC_EVALPARSETREE_PAIR_EVAL(A,B)	\
+	{	\
+	bool RAM_err = false;	\
+	try {	\
+		EvalParseTree(*src.c_array<A>(),types);	\
+		}	\
+	catch(std::bad_alloc&)	\
+		{	\
+		RAM_err = true;	\
+		goto restart_1;	\
+		}	\
+restart_1:	\
+	/* can't recover locally if this throws std::bad_alloc */	\
+	EvalParseTree(*src.c_array<B>(),types);	\
+	if (RAM_err) EvalParseTree(*src.c_array<A>(),types);	\
+	}
+
+
+//! \throw std::bad_alloc
+static bool
+eval_array_deref(parse_tree& src,const type_system& types,
+				 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+				 func_traits<bool (*)(const parse_tree&)>::function_ref_type literal_converts_to_integer,
+				 intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	if (!is_array_deref(src)) return false;
+	// crunch __[...]
+	// canonical definition: *((__)+(...))
+	ZCC_EVALPARSETREE_PAIR_EVAL(0,1);
+	if (parse_tree::CONSTANT_EXPRESSION & src.flags)
+		{
+		const unsigned int str_index = 	(C_TESTFLAG_STRING_LITERAL==src.data<0>()->index_tokens[0].flags) ? 0 :
+										(C_TESTFLAG_STRING_LITERAL==src.data<1>()->index_tokens[0].flags) ? 1 : UINT_MAX;
+		if (UINT_MAX>str_index)
+			{
+			umaxint tmp; 
+			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index) ARG_TYPES)) return false;
+			const size_t promoted_type = default_promote_type(src.type_code.base_type_index ARG_TYPES);
+			const virtual_machine::std_int_enum machine_type = (virtual_machine::std_int_enum)((promoted_type-C_TYPE::INT)/2+virtual_machine::std_int_int);
+			eval_string_literal_deref(src,types,src.data(str_index)->index_tokens[0].token,tmp,tmp.test(target_machine->C_bit(machine_type)-1),C_TESTFLAG_CHAR_LITERAL==src.data(1-str_index)->index_tokens[0].flags);
+			return true;
+			}
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_deref(	parse_tree& src, const type_system& types,
+						func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
+{
+	//! \todo handle operator overloading (fork to handle C/C++?)
+	//! \todo catch *& cancellation
+	if (is_C99_unary_operator_expression<'*'>(src))
+		{
+		EvalParseTree(*src.c_array<2>(),types);
+		if (C_TESTFLAG_STRING_LITERAL==src.data<2>()->index_tokens[0].flags)
+			{
+			//! \test default/Pass_if_zero.hpp
+			//! \test default/Pass_if_zero.h
+			//! \test default/Pass_if_nonzero.hpp
+			//! \test default/Pass_if_nonzero.h
+			eval_string_literal_deref(src,types,src.data<2>()->index_tokens[0].token,umaxint(0),false,false);
+			return true;
+			}
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_logical_NOT(parse_tree& src, const type_system& types,
+							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							 func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_NOT_expression,
+							 literal_converts_to_bool_func& literal_converts_to_bool)
+{
+	if (is_logical_NOT_expression(src))
+		{
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_logical_NOT(src,types,is_logical_NOT_expression,literal_converts_to_bool)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_bitwise_compl(	parse_tree& src, const type_system& types,
+								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+								func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_complement_expression,
+								intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	if (is_bitwise_complement_expression(src))
+		{
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_bitwise_compl(src,types,is_bitwise_complement_expression,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_unary_plus(parse_tree& src, const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
+{
+	if (is_C99_unary_operator_expression<'+'>(src))
+		{
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_unary_plus(src,types)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_unary_minus(parse_tree& src, const type_system& types,
+							 func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							 literal_converts_to_bool_func& literal_converts_to_bool,
+							 intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	if (is_C99_unary_operator_expression<'-'>(src))
+		{
+		EvalParseTree(*src.c_array<2>(),types);
+		if (eval_unary_minus(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_mult_expression(parse_tree& src,const type_system& types,
+								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+								literal_converts_to_bool_func& literal_converts_to_bool,
+								intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	if (is_C99_mult_operator_expression<'*'>(src))
+		{
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
+		if (eval_mult_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_div_expression(parse_tree& src,const type_system& types,
+								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+								literal_converts_to_bool_func& literal_converts_to_bool,
+								intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	if (is_C99_mult_operator_expression<'/'>(src))
+		{
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
+		if (eval_div_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_mod_expression(parse_tree& src,const type_system& types,
+								func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+								literal_converts_to_bool_func& literal_converts_to_bool,
+								intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	if (is_C99_mult_operator_expression<'%'>(src))
+		{
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
+		if (eval_mod_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_add_expression(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	if (is_C99_add_operator_expression<'+'>(src))
+		{
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
+		if (eval_add_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_sub_expression(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	if (is_C99_add_operator_expression<'-'>(src))
+		{
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
+		if (eval_sub_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_shift(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	if (is_C99_shift_expression(src))
+		{
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
+		if (eval_shift(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_relation_expression(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	if (is_C99_relation_expression(src))
+		{
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
+		if (eval_relation_expression(src,types,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_equality_expression(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_equality_expression,
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	if (is_equality_expression(src))
+		{
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
+		if (eval_equality_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_bitwise_AND(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_AND_expression,
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	if (is_bitwise_AND_expression(src))
+		{
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
+		if (eval_bitwise_AND(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_bitwise_XOR(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_XOR_expression,
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	if (is_bitwise_XOR_expression(src))
+		{
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
+		if (eval_bitwise_XOR(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_bitwise_OR(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_bitwise_OR_expression,
+							literal_converts_to_bool_func& literal_converts_to_bool,
+							intlike_literal_to_VM_func& intlike_literal_to_VM)
+{
+	if (is_bitwise_OR_expression(src))
+		{
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
+		if (eval_bitwise_OR(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_logical_AND(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_AND_expression,
+							literal_converts_to_bool_func& literal_converts_to_bool)
+{
+	if (is_logical_AND_expression(src))
+		{
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
+		if (eval_logical_AND(src,types,literal_converts_to_bool)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_logical_OR(parse_tree& src,const type_system& types,
+							func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+							func_traits<bool (*)(const parse_tree&)>::function_ref_type is_logical_OR_expression,
+							literal_converts_to_bool_func& literal_converts_to_bool)
+{
+	if (is_logical_OR_expression(src))
+		{
+		ZCC_EVALPARSETREE_PAIR_EVAL(1,2);
+		if (eval_logical_OR(src,types,literal_converts_to_bool)) return true;
+		}
+	return false;
+}
+
+//! \throw std::bad_alloc
+static bool eval_conditional_operator(parse_tree& src,const type_system& types,
+									  func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree,
+									  literal_converts_to_bool_func& literal_converts_to_bool)
+{
+	if (is_C99_conditional_operator_expression(src))
+		{	// prefix operator is boolean
+		EvalParseTree(*src.c_array<1>(),types);
+		if (eval_conditional_op(src,literal_converts_to_bool ARG_TYPES)) return true;
+		}
+	return false;
+}
+
+#if 0
+static bool cancel_addressof_deref_operators(parse_tree& src)
+{
+	assert(is_C99_unary_operator_expression(src));
+	if ('&'==*src.index_tokens[0].token.first)
+		{	// strip off &*, and remove lvalue-ness of target
+		if (is_C99_unary_operator_expression<'*'>(*src.data<2>()) && 0<src.data<2>()->data<2>()->type_code.pointer_power)
+			{
+			parse_tree tmp;
+			src.c_array<2>()->c_array<2>()->OverwriteInto(tmp);
+			tmp.type_code.traits &= ~type_spec::lvalue;
+			tmp.MoveInto(src);
+			}
+#if 0
+		if (is_array_deref(*src.data<2>()))
+			{	//! \todo convert &(___[...]) to (__+...)
+			}
+#endif
+		};
+	return false;
+}
+#endif
+
+//! \throw std::bad_alloc
+static bool C99_EvalParseTree(parse_tree& src,const type_system& types)
+{
+	const size_t starting_errors = zcc_errors.err_count();
+RestartEval:
+	if (src.is_atomic() || (parse_tree::INVALID & src.flags)) return starting_errors==zcc_errors.err_count();
+	if (eval_array_deref(src,types,C99_EvalParseTree,C99_literal_converts_to_integer,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_conditional_operator(src,types,C99_EvalParseTree,C99_literal_converts_to_bool)) goto RestartEval;
+	if (eval_logical_OR(src,types,C99_EvalParseTree,is_C99_logical_OR_expression,C99_literal_converts_to_bool)) goto RestartEval;
+	if (eval_logical_AND(src,types,C99_EvalParseTree,is_C99_logical_AND_expression,C99_literal_converts_to_bool)) goto RestartEval;
+	if (eval_deref(src,types,C99_EvalParseTree)) goto RestartEval; 
+	if (eval_logical_NOT(src,types,C99_EvalParseTree,is_C99_unary_operator_expression<'!'>,C99_literal_converts_to_bool)) goto RestartEval;
+	if (eval_unary_plus(src,types,C99_EvalParseTree)) goto RestartEval;
+	if (eval_unary_minus(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_mult_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_div_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_mod_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_add_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_sub_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_shift(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_relation_expression(src,types,C99_EvalParseTree,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_equality_expression(src,types,C99_EvalParseTree,is_C99_equality_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_AND(src,types,C99_EvalParseTree,is_C99_bitwise_AND_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_XOR(src,types,C99_EvalParseTree,is_C99_bitwise_XOR_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_OR(src,types,C99_EvalParseTree,is_C99_bitwise_OR_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_compl(src,types,C99_EvalParseTree,is_C99_unary_operator_expression<'~'>,C99_intlike_literal_to_VM)) goto RestartEval;
+	return starting_errors==zcc_errors.err_count();
+}
+
+//! \throw std::bad_alloc
+static bool CPP_EvalParseTree(parse_tree& src,const type_system& types)
+{
+	const size_t starting_errors = zcc_errors.err_count();
+RestartEval:
+	if (src.is_atomic() || (parse_tree::INVALID & src.flags)) return starting_errors==zcc_errors.err_count();
+	if (eval_array_deref(src,types,CPP_EvalParseTree,CPP_literal_converts_to_integer,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_conditional_operator(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool)) goto RestartEval;
+	if (eval_logical_OR(src,types,CPP_EvalParseTree,is_CPP_logical_OR_expression,CPP_literal_converts_to_bool)) goto RestartEval;
+	if (eval_logical_AND(src,types,CPP_EvalParseTree,is_CPP_logical_AND_expression,CPP_literal_converts_to_bool)) goto RestartEval;
+	if (eval_deref(src,types,CPP_EvalParseTree)) goto RestartEval; 
+	if (eval_logical_NOT(src,types,CPP_EvalParseTree,is_CPP_logical_NOT_expression,CPP_literal_converts_to_bool)) goto RestartEval;
+	if (eval_unary_plus(src,types,CPP_EvalParseTree)) goto RestartEval;
+	if (eval_unary_minus(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_mult_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_div_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_mod_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_add_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_sub_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_shift(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_relation_expression(src,types,CPP_EvalParseTree,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_equality_expression(src,types,CPP_EvalParseTree,is_CPP_equality_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_AND(src,types,CPP_EvalParseTree,is_CPP_bitwise_AND_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_XOR(src,types,CPP_EvalParseTree,is_CPP_bitwise_XOR_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_OR(src,types,CPP_EvalParseTree,is_CPP_bitwise_OR_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_compl(src,types,CPP_EvalParseTree,is_CPP_bitwise_complement_expression,CPP_intlike_literal_to_VM)) goto RestartEval;
+	return starting_errors==zcc_errors.err_count();
+}
+
+//! \throw std::bad_alloc
+void C99_PPHackTree(parse_tree& src,const type_system& types)
+{
+	if (parse_tree::INVALID & src.flags) return;
+	if (	is_C99_unary_operator_expression<'-'>(src)
+		&&	(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+		{	// compact - literal to literal to get past preprocessor
+		src.eval_to_arg<2>(0);
+		return;
+		};
+	const type_spec old_type = src.type_code;
+	const bool non_representable_int_min = virtual_machine::twos_complement==target_machine->C_signed_int_representation() && !bool_options[boolopt::int_traps];
+	//! \todo handle other instances of non-representable int min constant expressions
+	if (is_C99_add_operator_expression<'-'>(src))
+		{
+		bool is_equal = false;
+		if (C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal))
+			{
+			assert(!is_equal);	// should have intercepted equal-literal reduction earlier
+#ifndef NDEBUG
+			force_decimal_literal(src,"1",types);
+#else
+			force_decimal_literal(src,is_equal ? "0" : "1",types);
+#endif
+			src.type_code.set_type(C_TYPE::INT);
+			return;
+			};
+		if (non_representable_int_min)
+			{
+			umaxint res_int;
+			umaxint rhs_int;
+			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
+			if (lhs_converted && rhs_converted)
+				{	//! \todo deal with signed integer arithmetic
+				const promote_aux old(old_type.base_type_index ARG_TYPES);
+				assert(old.is_signed);
+				const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
+				assert(old.bitcount>=lhs.bitcount);
+				const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
+				assert(old.bitcount>=rhs.bitcount);
+
+				// handle sign-extension of lhs, rhs
+#ifndef NDEBUG
+				const bool lhs_negative = target_machine->C_promote_integer(res_int,lhs,old);
+				const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
+#else
+				target_machine->C_promote_integer(res_int,lhs,old);
+				target_machine->C_promote_integer(rhs_int,rhs,old);
+#endif
+				assert(lhs_negative && !rhs_negative);
+				umaxint lhs_test(res_int);
+				umaxint rhs_test(rhs_int);
+				umaxint ub(target_machine->signed_max(old.machine_type));
+				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
+				ub += 1;
+				assert(ub>=lhs_test && ub>=rhs_test);
+				ub -= lhs_test;
+				assert(ub>=rhs_test);
+				lhs_test += rhs_test;
+				assert(target_machine->signed_max(old.machine_type)<lhs_test);
+				// ok...valid but won't reduce.  pick an argument and mock this up
+				src.eval_to_arg<2>(0);
+				return;
+				}
+			}
+		}
+	if (src.type_code.decays_to_nonnull_pointer())
+		{
+		force_decimal_literal(src,"1",types);
+		src.type_code.set_type(C_TYPE::INT);
+		return;
+		}
+}
+
+//! \throw std::bad_alloc
+void CPP_PPHackTree(parse_tree& src,const type_system& types)
+{
+	if (parse_tree::INVALID & src.flags) return;
+	if (	is_C99_unary_operator_expression<'-'>(src)
+		&&	(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+		{	// compact - literal to literal to get past preprocessor
+		src.eval_to_arg<2>(0);
+		return;
+		};
+	const type_spec old_type = src.type_code;
+	const bool non_representable_int_min = virtual_machine::twos_complement==target_machine->C_signed_int_representation() && !bool_options[boolopt::int_traps];
+	//! \todo handle other instances of non-representable int min constant expressions
+	if (is_C99_add_operator_expression<'-'>(src))
+		{
+		bool is_equal = false;
+		if (C_string_literal_equal_content(*src.data<1>(),*src.data<2>(),is_equal))
+			{
+			assert(!is_equal);	// should have intercepted equal-literal reduction earlier
+#ifndef NDEBUG
+			force_decimal_literal(src,"1",types);
+#else
+			force_decimal_literal(src,is_equal ? "0" : "1",types);
+#endif
+			src.type_code.set_type(C_TYPE::INT);
+			return;
+			};
+		if (non_representable_int_min)
+			{
+			umaxint res_int;
+			umaxint rhs_int;
+			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data<1>() ARG_TYPES);
+			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data<2>() ARG_TYPES);
+			if (lhs_converted && rhs_converted)
+				{	//! \todo deal with signed integer arithmetic
+				const promote_aux old(old_type.base_type_index ARG_TYPES);
+				assert(old.is_signed);
+				const promote_aux lhs(src.data<1>()->type_code.base_type_index ARG_TYPES);
+				assert(old.bitcount>=lhs.bitcount);
+				const promote_aux rhs(src.data<2>()->type_code.base_type_index ARG_TYPES);
+				assert(old.bitcount>=rhs.bitcount);
+
+				// handle sign-extension of lhs, rhs
+#ifndef NDEBUG
+				const bool lhs_negative = target_machine->C_promote_integer(res_int,lhs,old);
+				const bool rhs_negative = target_machine->C_promote_integer(rhs_int,rhs,old);
+#else
+				target_machine->C_promote_integer(res_int,lhs,old);
+				target_machine->C_promote_integer(rhs_int,rhs,old);
+#endif
+				assert(lhs_negative && !rhs_negative);
+				umaxint lhs_test(res_int);
+				umaxint rhs_test(rhs_int);
+				umaxint ub(target_machine->signed_max(old.machine_type));
+				target_machine->signed_additive_inverse(lhs_test,old.machine_type);
+				ub += 1;
+				assert(ub>=lhs_test && ub>=rhs_test);
+				ub -= lhs_test;
+				assert(ub>=rhs_test);
+				lhs_test += rhs_test;
+				assert(target_machine->signed_max(old.machine_type)<lhs_test);
+				// ok...valid but won't reduce.  pick an argument and mock this up
+				src.eval_to_arg<2>(0);
+				return;
+				}
+			}
+		}
+	if (src.type_code.decays_to_nonnull_pointer())
+		{
+		force_decimal_literal(src,"1",types);
+		src.type_code.set_type(C_TYPE::INT);
+		return;
+		}
+}
+
+static void conserve_tokens(parse_tree& x)
+{
+	if (x.own_index_token<0>())
+		{
+		const char* const tmp = is_substring_registered(x.index_tokens[0].token.first,x.index_tokens[0].token.second);
+		if (tmp)
+			{
+			assert(tmp!=x.index_tokens[0].token.first);
+			free(const_cast<char*>(x.index_tokens[0].token.first));
+			x.index_tokens[0].token.first = tmp;
+			x.control_index_token<0>(false);
+			}
+		}
+	if (x.own_index_token<1>())
+		{
+		const char* const tmp = is_substring_registered(x.index_tokens[1].token.first,x.index_tokens[1].token.second);
+		if (tmp)
+			{
+			assert(tmp!=x.index_tokens[1].token.first);
+			free(const_cast<char*>(x.index_tokens[1].token.first));
+			x.index_tokens[1].token.first = tmp;
+			x.control_index_token<1>(false);
+			}
+		}
+}
+
+//! \todo really should be somewhere in natural-language output
+void INFORM_separated_list(const char* const* x,size_t x_len, const char* const sep)
+{
+	assert(sep && *sep);
+	assert(x);
+	if (0<x_len)
+		{
+		INC_INFORM(*x);
+		while(0< --x_len)
+			{
+			INC_INFORM(sep);
+			INC_INFORM(*(++x));
+			}
+		};
+}
+
+//! \todo should this be a type_system member?
+//! \throw std::bad_alloc
+static bool check_for_typedef(type_spec& dest,const char* const src,const type_system& types)
+{
+	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(src);
+	if (tmp)
+		{	//! \todo C++: check for access control if source ends up being a class or struct
+		value_copy(dest,tmp->first);
+		return true;
+		}
+	return false;
+}
+
+//! \todo should this be a type_system member?
+//! \throw std::bad_alloc
+static bool check_for_typedef(type_spec& dest,const char* const src,const char* const active_namespace,const type_system& types)
+{
+	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef_CPP(src,active_namespace);
+	if (tmp)
+		{	//! \todo C++: check for access control if source ends up being a class or struct
+		value_copy(dest,tmp->first);
+		return true;
+		}
+	return false;
+}
+
+//! \todo does this need to be in ParseTree.hpp?
+static size_t 
+flush_token(parse_tree& x, const size_t i, const size_t n, const char* const target)
+{
+	assert(x.size<0>()>i);
+	assert(x.size<0>()-i>=n);
+	size_t offset = 0;
+	size_t j = 0;
+	do	if (robust_token_is_string(x.data<0>()[i+j],target))
+			++offset;
+		else if (0<offset)
+			x.c_array<0>()[i+j-offset] = x.data<0>()[i+j];
+	while(n> ++j);
+	if (0<offset)
+		{
+		j = offset;
+		while(0<j) x.c_array<0>()[i+n- j--].clear();
+		x.DeleteNSlotsAt<0>(offset,i+n-offset);
+		}
+	return offset;
+}
+
+class C99_decl_specifier_scanner
+{
+private:
+	size_t decl_count[CHAR_BIT*sizeof(uintmax_t)];
+	uintmax_t flags;
+	type_spec base_type;
+	const type_system& types;
+public:
+	C99_decl_specifier_scanner(const type_system& _types) : flags(0),types(_types)
+		{
+		clear(decl_count);
+		base_type.clear();
+		};
+	// trivial destructor, copy constructor, assignment fine
+	//! \throw std::bad_alloc
+	bool operator()(const parse_tree& x)
+		{
+		BOOST_STATIC_ASSERT(CHAR_BIT*sizeof(uintmax_t)>=STATIC_SIZE(C99_decl_specifiers));
+		if (!x.is_atomic()) return false;
+		const errr Idx = linear_find(x.index_tokens[0].token.first,x.index_tokens[0].token.second,C99_decl_specifiers,STATIC_SIZE(C99_decl_specifiers));
+		if (0<=Idx)
+			{
+			flags |= (1ULL<<Idx);
+			++decl_count[Idx];
+			return true;
+			};
+		// not a decl-specifier; bail out if we already have a type
+		if (base_type.base_type_index) return false;
+		if (PARSE_TYPE & x.flags)
+			{
+			value_copy(base_type,x.type_code);
+			return true;
+			}
+		// handle typedefs
+		if (check_for_typedef(base_type,x.index_tokens[0].token.first,types)) return true;
+		return false;
+		};
+	bool analyze_flags_global(parse_tree& x, size_t i, size_t& decl_count)
+		{
+		assert(x.size<0>()>i);
+		assert(x.size<0>()-i>=decl_count);
+		if ((C99_CPP0X_DECLSPEC_TYPEDEF | C99_CPP0X_DECLSPEC_REGISTER | C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN | C99_DECLSPEC_AUTO) & flags)
+			{	// storage class specifiers
+			const char* specs[5];
+			unsigned int storage_count = 0;
+			unsigned int erased_count = 0;
+			if (C99_CPP0X_DECLSPEC_TYPEDEF & flags)
+				specs[storage_count++] = "typedef";
+			if (C99_CPP0X_DECLSPEC_STATIC & flags)
+				specs[storage_count++] = "static";
+			if (C99_CPP0X_DECLSPEC_EXTERN & flags)
+				specs[storage_count++] = "extern";
+			if (C99_CPP0X_DECLSPEC_REGISTER & flags)
+				{	//! \test zcc/decl.C99/Error_register_global.h
+				//! \todo should be warning for --do-what-i-mean
+				specs[storage_count++] = "register";
+				++erased_count;
+				message_header(x.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("storage-class specifier register disallowed at translation-unit level (C99 6.9p2)");
+				zcc_errors.inc_error();
+				decl_count -= flush_token(x,i,decl_count,"register");
+				flags &= ~C99_CPP0X_DECLSPEC_REGISTER;
+				}
+			if (C99_DECLSPEC_AUTO & flags)
+				{	//! \test zcc/decl.C99/Error_auto_global.h
+				//! \todo should be warning for --do-what-i-mean
+				specs[storage_count++] = "auto";
+				++erased_count;
+				message_header(x.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("storage-class specifier auto disallowed at translation-unit level (C99 6.9p2)");
+				zcc_errors.inc_error();
+				decl_count -= flush_token(x,i,decl_count,"auto");
+				flags &= ~C99_DECLSPEC_AUTO;
+				};
+			if (1<storage_count)
+				{	//! \test zcc/decl.C99/Error_extern_static.h
+					//! \test zcc/decl.C99/Error_extern_typedef.h
+					//! \test zcc/decl.C99/Error_static_typedef.h
+					//! \test zcc/decl.C99/Error_extern_static_typedef.h
+				message_header(x.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("declaration has too many storage-class specifiers: ");
+				INFORM_separated_list(specs,storage_count,", ");
+				INFORM(" (C99 6.7.1p2)");
+				zcc_errors.inc_error();
+				};
+			storage_count -= erased_count;
+			// inline requires a function type
+			// typedef must have a function type to tolerate anything (but kills inline)
+			return 1>=storage_count;
+			};
+		return true;
+		}
+	void fixup_type() { base_type.qualifier<0>() |= ((C99_CPP0X_DECLSPEC_CONST | C99_CPP0X_DECLSPEC_VOLATILE) & flags); };
+	uintmax_t get_flags() const {return flags;};
+	//! \throw std::bad_alloc
+	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
+};
+
+class CPP0X_decl_specifier_scanner
+{
+private:
+	size_t decl_count[CHAR_BIT*sizeof(uintmax_t)];
+	uintmax_t flags;
+	type_spec base_type;
+	const type_system& types;
+	// these two might belong in a koenig_lookup object
+	const char* const active_namespace;
+public:
+	CPP0X_decl_specifier_scanner(const type_system& _types,const char* const _active_namespace) : flags(0),types(_types),active_namespace(_active_namespace)
+		{
+		clear(decl_count);
+		base_type.clear();
+		}
+	// trivial destructor, copy constructor, assignment fine
+	//! \throw std::bad_alloc
+	bool operator()(parse_tree& x,const size_t i)
+		{
+		BOOST_STATIC_ASSERT(CHAR_BIT*sizeof(uintmax_t)>=STATIC_SIZE(CPP0X_decl_specifiers));
+		assert(x.size<0>()>i);
+		if (!x.data<0>()[i].is_atomic()) return false;
+		const errr Idx = linear_find(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second,CPP0X_decl_specifiers,STATIC_SIZE(CPP0X_decl_specifiers));
+		if (0<=Idx)
+			{
+			flags |= (1ULL<<Idx);
+			++decl_count[Idx];
+			return true;
+			};
+		// not a decl-specifier; bail out if we already have a type
+		if (base_type.base_type_index) return false;
+		if (PARSE_TYPE & x.data<0>()[i].flags)
+			{
+			value_copy(base_type,x.data<0>()[i].type_code);
+			return true;
+			}
+		{	// handle typedefs
+		// determine what fully-qualified name would be
+		if (   x.data<0>()[i].is_atomic()
+			&& !(PARSE_TYPE & x.data<0>()[i].flags)
+			&& !CPP_echo_reserved_keyword(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second)
+			&& (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags))
+			// shove Koenig lookup into type_system
+			return check_for_typedef(base_type,x.data<0>()[i].index_tokens[0].token.first,active_namespace,types);
+		}
+		return false;
+		};
+	bool analyze_flags_global(parse_tree& x, size_t i, size_t& decl_count)
+		{
+		assert(x.size<0>()>i);
+		assert(x.size<0>()-i>=decl_count);
+		if ((C99_CPP0X_DECLSPEC_TYPEDEF | C99_CPP0X_DECLSPEC_REGISTER | C99_CPP0X_DECLSPEC_STATIC | C99_CPP0X_DECLSPEC_EXTERN | CPP_DECLSPEC_MUTABLE | CPP_DECLSPEC_VIRTUAL | CPP_DECLSPEC_EXPLICIT | CPP_DECLSPEC_FRIEND) & flags)
+			{	// storage class specifiers
+			const char* specs[5];
+			unsigned int storage_count = 0;
+			unsigned int erased_count = 0;
+			if (C99_CPP0X_DECLSPEC_TYPEDEF & flags)
+				specs[storage_count++] = "typedef";
+			if (C99_CPP0X_DECLSPEC_STATIC & flags)
+				specs[storage_count++] = "static";
+			if (C99_CPP0X_DECLSPEC_EXTERN & flags)
+				specs[storage_count++] = "extern";
+			if (C99_CPP0X_DECLSPEC_REGISTER & flags)
+				{	//! \test zcc/default/decl.C99/Error_register_global.hpp
+				//! \todo should be warning for --do-what-i-mean
+				specs[storage_count++] = "register";
+				++erased_count;
+				message_header(x.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("storage-class specifier register allowed only to objects named in a block, or function parameters (C++98 7.1.1p2)");
+				zcc_errors.inc_error();
+				decl_count -= flush_token(x,i,decl_count,"register");
+				flags &= ~C99_CPP0X_DECLSPEC_REGISTER;
+				}
+			if (CPP_DECLSPEC_MUTABLE & flags)
+				{	//! \test zcc/default/decl.C99/Error_mutable_global.hpp
+				//! \todo should be warning for --do-what-i-mean
+				specs[storage_count++] = "mutable";
+				++erased_count;
+				message_header(x.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("storage-class specifier mutable only allowed for non-static non-const non-reference class data members (C++0X 7.1.1p10)");
+				zcc_errors.inc_error();
+				decl_count -= flush_token(x,i,decl_count,"mutable");
+				flags &= ~CPP_DECLSPEC_MUTABLE;
+				};
+			if (1<storage_count)
+				{	//! \test zcc/decl.C99/Error_extern_static.hpp
+					//! \test zcc/decl.C99/Error_extern_typedef.hpp
+					//! \test zcc/decl.C99/Error_static_typedef.hpp
+					//! \test zcc/decl.C99/Error_extern_static_typedef.hpp
+				//! \todo should be warning for --do-what-i-mean
+				message_header(x.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("declaration has too many storage-class specifiers: ");
+				INFORM_separated_list(specs,storage_count,", ");
+				INFORM(" (C++0X 7.1.1p1)");
+				zcc_errors.inc_error();
+				}
+			storage_count -= erased_count;
+			// thread_local ok at namespace scope for objects/references
+			// inline dies if not a function type
+			// typedef must have a function type to tolerate anything (but kills inline)
+			// virtual and explicit can only be used in class declarations: erase (C++0X 7.1.2p5, 7.1.2p6
+			if (CPP_DECLSPEC_VIRTUAL & flags)
+				{	//! \test zcc/default/decl.C99/Error_virtual_global.hpp
+				//! \todo should be warning for --do-what-i-mean
+				message_header(x.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("function specifier virtual allowed only for class member functions (C++98 7.1.2p5)");
+				zcc_errors.inc_error();
+				decl_count -= flush_token(x,i,decl_count,"virtual");
+				flags &= ~CPP_DECLSPEC_VIRTUAL;
+				};
+			if (CPP_DECLSPEC_EXPLICIT & flags)
+				{	//! \test zcc/default/decl.C99/Error_explicit_global.hpp
+				//! \todo should be warning for --do-what-i-mean
+				message_header(x.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("function specifier explicit allowed only for constructors (C++98 7.1.2p6)");
+				zcc_errors.inc_error();
+				decl_count -= flush_token(x,i,decl_count,"explicit");
+				flags &= ~CPP_DECLSPEC_EXPLICIT;
+				};
+			// friend is only usable within a class
+			if (CPP_DECLSPEC_FRIEND & flags)
+				{	//! \test zcc/default/decl.C99/Error_friend_global.hpp
+				//! \todo should be warning for --do-what-i-mean
+				message_header(x.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("decl-specifier friend only useful within a class definition (C++98 7.1.4)");
+				zcc_errors.inc_error();
+				decl_count -= flush_token(x,i,decl_count,"friend");
+				flags &= ~CPP_DECLSPEC_FRIEND;
+				};
+			return 1>=storage_count;
+			};
+		return true;
+		};
+	void fixup_type() { base_type.qualifier<0>() |= ((C99_CPP0X_DECLSPEC_CONST | C99_CPP0X_DECLSPEC_VOLATILE) & flags); };
+	uintmax_t get_flags() const {return flags;};
+	//! \throw std::bad_alloc
+	void value_copy_type(type_spec& dest) const {value_copy(dest,base_type);};
+};
+
+static size_t C99_cv_qualifier_span(parse_tree& x, size_t i,type_spec& target_type)
+{
+	unsigned int warn_queue = 0;
+	size_t ub = 0;
+	if (x.size<0>()>i)
+		{
+		do	{
+			if (robust_token_is_string<5>(x.data<0>()[i+ub],"const"))
+				{	//! \bug need test cases
+				if (target_type.q_vector.back() & type_spec::_const)
+					{	
+					warn_queue |= type_spec::_const;
+					// optimize source
+					x.DeleteIdx<0>(i+ub);
+					continue;
+					}
+				target_type.q_vector.back() |= type_spec::_const;
+				}
+			else if (robust_token_is_string<8>(x.data<0>()[i+ub],"volatile"))
+				{	//! \bug need test cases
+				if (target_type.q_vector.back() & type_spec::_volatile)
+					{
+					warn_queue |= type_spec::_volatile;
+					// optimize source
+					x.DeleteIdx<0>(i+ub);
+					continue;
+					}
+				target_type.q_vector.back() |= type_spec::_volatile;
+				}
+			else if (robust_token_is_string<8>(x.data<0>()[i+ub],"restrict"))
+				{	//! \bug need test cases
+				if (target_type.q_vector.back() & type_spec::_restrict)
+					{
+					warn_queue |= type_spec::_restrict;
+					// optimize source
+					x.DeleteIdx<0>(i+ub);
+					continue;
+					}
+				target_type.q_vector.back() |= type_spec::_restrict;
+				}
+			else break;
+			}
+		while(x.size<0>()>i+ ++ub);
+		//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+		//! \todo should this be a context-free check?
+		if (warn_queue)
+			{	//! \bug need test cases
+			message_header(x.data<0>()[i].index_tokens[0]);
+			INC_INFORM(WARN_STR);
+			INFORM("duplicate type qualifiers have no effect (C99 6.7.3p4)");
+			if (bool_options[boolopt::warnings_are_errors])
+				zcc_errors.inc_error();
+			}
+		}
+	return ub;
+}
+
+/*
+C99 6.7.5p1, C1X 6.7.6p1
+pointer:
+* type-qualifier-listopt
+* type-qualifier-listopt pointer
+*/
+static size_t C99_recognize_pointerlike_declarator_section(parse_tree& x, size_t i,type_spec& target_type)
+{
+	assert(x.size<0>()>i);
+	size_t ub = 0;
+	while(robust_token_is_char<'*'>(x.data<0>()[i+ub]))
+		{
+		target_type.make_C_pointer();
+		++ub;
+		ub += C99_cv_qualifier_span(x,i+ub,target_type);
+		}
+	return ub;
+}
+
+// forward-declare for recursive definition
+static size_t C99_init_declarator_scanner(parse_tree& x, size_t i,type_spec& target_type, parse_tree*& initdecl_identifier);
+
+/*
+C99 6.7.5p1, C1X 6.7.6p1
+direct-declarator:
+identifier
+( declarator )
+direct-declarator [ type-qualifier-listopt assignment-expressionopt ]
+direct-declarator [ static type-qualifier-listopt assignment-expression ]
+direct-declarator [ type-qualifier-list static assignment-expression ]
+direct-declarator [ type-qualifier-listopt * ]
+direct-declarator ( parameter-type-list )
+direct-declarator ( identifier-listopt )
+*/
+static size_t C99_recognize_direct_declaratorlike_section(parse_tree& x, size_t i,type_spec& target_type, parse_tree*& initdecl_identifier)
+{
+	assert(x.size<0>()>i);
+	assert(!initdecl_identifier);
+	size_t ub = 0;
+	if (	x.data<0>()[i].is_atomic()
+		&& (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags)
+		&& !(PARSE_TYPE & x.data<0>()[i].flags) 	// internal representation could land some types here, especially primary types
+		&& !C99_echo_reserved_keyword(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second))
+		{	// identifier counts
+		ub = 1;
+		initdecl_identifier = x.c_array<0>()+i;
+		}
+	else if (is_naked_parentheses_pair(x.data<0>()[i]))
+		{
+		const size_t content_length = x.size<0>();
+		if (0<content_length && content_length==C99_init_declarator_scanner(x.c_array<0>()[i],0,target_type,initdecl_identifier))
+			ub = 1;
+		}
+	if (0<ub)
+		{
+		while(i+ub<x.size<0>())
+			{
+			if (is_naked_bracket_pair(x.data<0>()[i+ub]))
+				{	// we'll catch the array size, etc. later
+				if (!(target_type.qualifier<0>() & type_spec::_function_return_value))
+					target_type.make_C_array(0);
+				++ub;
+				continue;
+				}
+			else if (is_naked_parentheses_pair(x.data<0>()[i+ub]))
+				{	// handle the prototype later
+				target_type.qualifier<0>() |= type_spec::_function_return_value;
+				++ub;
+				continue;
+				}
+			break;
+			}
+		}
+	return ub;
+}
+
+/*
+declarator:
+pointeropt direct-declarator
+*/
+static size_t C99_init_declarator_scanner(parse_tree& x, size_t i,type_spec& target_type, parse_tree*& initdecl_identifier)
+{
+	assert(x.size<0>()>i);
+	assert(!initdecl_identifier);
+	const size_t ptr_like = C99_recognize_pointerlike_declarator_section(x,i,target_type);
+	if (x.size<0>()-i <= ptr_like) return 0;
+	const size_t direct_decl_like = C99_recognize_direct_declaratorlike_section(x,i+ptr_like,target_type,initdecl_identifier);
+	if (0<direct_decl_like) return ptr_like+direct_decl_like;
+	return 0;
+}
+
+// very basic syntax check; defer real parsing to later
+static bool is_CPP0X_attribute(const parse_tree& x)
+{
+	if (   is_naked_bracket_pair(x)
+		&& 1==x.size<0>()
+		&& is_naked_bracket_pair(*x.data<0>()))
+		return true;
+	return false;
+}
+
+static bool is_CPP0X_ref_qualifier(const parse_tree& x)
+{
+	if (   robust_token_is_char<'&'>(x)
+		|| robust_token_is_string<2>(x,"&&"))
+		return true;
+	return false;
+}
+
+// very basic syntax check; defer real parsing to later
+static size_t is_CPP0X_exception_specification_here(const parse_tree& x,size_t i)
+{
+	if (x.size<0>()>i)
+		{
+		const bool have_parens = 1<x.size<0>()-i && is_naked_parentheses_pair(x.data<0>()[i+1]);
+		if (robust_token_is_string<8>(x,"noexcept")) return 1+have_parens;
+		if (have_parens && robust_token_is_string<5>(x,"throw")) return 2;
+		}
+	return 0;
+}
+
+static size_t CPP_cv_qualifier_span(parse_tree& x, size_t i,type_spec& target_type)
+{
+	unsigned int warn_queue = 0;
+	size_t ub = 0;
+	if (x.size<0>()>i)
+		{
+		do	{
+			if (robust_token_is_string<5>(x.data<0>()[i+ub],"const"))
+				{	//! \bug need test cases
+				if (target_type.q_vector.back() & type_spec::_const)
+					{	
+					warn_queue |= type_spec::_const;
+					// optimize source
+					x.DeleteIdx<0>(i+ub);
+					continue;
+					}
+				target_type.q_vector.back() |= type_spec::_const;
+				}
+			else if (robust_token_is_string<8>(x.data<0>()[i+ub],"volatile"))
+				{	//! \bug need test cases
+				if (target_type.q_vector.back() & type_spec::_volatile)
+					{
+					warn_queue |= type_spec::_volatile;
+					// optimize source
+					x.DeleteIdx<0>(i+ub);
+					continue;
+					}
+				target_type.q_vector.back() |= type_spec::_volatile;
+				}
+			else break;
+			}
+		while(x.size<0>()>i+ ++ub);
+		//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+		//! \todo should this be a context-free check?
+		if (warn_queue)
+			{	//! \bug need test cases
+			message_header(x.data<0>()[i].index_tokens[0]);
+			INC_INFORM(WARN_STR);
+			INFORM("duplicate type qualifiers have no effect (C++0X 7.1.6.1p1)");
+			if (bool_options[boolopt::warnings_are_errors])
+				zcc_errors.inc_error();
+			}
+		}
+	return ub;
+}
+
+/*
+C++0X 8p4
+ptr-operator:
+* attribute-specifieropt cv-qualifier-seqopt
+& attribute-specifieropt
+&& attribute-specifieropt
+::opt nested-name-specifier * attribute-specifieropt cv-qualifier-seqopt*/
+static size_t CPP_recognize_pointerlike_declarator_section(parse_tree& x, size_t i,type_spec& target_type)
+{
+	assert(x.size<0>()>i);
+	size_t ub = 0;
+	// handle C-like case
+	while(robust_token_is_char<'*'>(x.data<0>()[i+ub]))
+		{
+		target_type.make_C_pointer();
+		++ub;
+		//! \todo would check for attributes here
+		ub += CPP_cv_qualifier_span(x,i+ub,target_type);
+		}
+	return ub;
+}
+
+// forward-declaration for recursive definition
+static size_t CPP_init_declarator_scanner(parse_tree& x, size_t i,type_spec& target_type, parse_tree*& initdecl_identifier);
+
+/*
+noptr-declarator:
+declarator-id attribute-specifieropt
+noptr-declarator parameters-and-qualifiers
+noptr-declarator [ constant-expressionopt ] attribute-specifieropt
+( ptr-declarator )
+*/
+static size_t CPP_recognize_noptr_declaratorlike_section(parse_tree& x, size_t i,type_spec& target_type, parse_tree*& initdecl_identifier)
+{
+	assert(x.size<0>()>i);
+	bool local_identifier = false;
+	size_t ub = 0;
+	if (	x.data<0>()[i].is_atomic()
+		&& (C_TESTFLAG_IDENTIFIER & x.data<0>()[i].index_tokens[0].flags)
+		&& !(PARSE_TYPE & x.data<0>()[i].flags) 	// internal representation could land some types here, especially primary types
+		&& !CPP_echo_reserved_keyword(x.data<0>()[i].index_tokens[0].token.first,x.data<0>()[i].index_tokens[0].token.second))
+		{	// identifier counts
+		ub = 1;
+		initdecl_identifier = x.c_array<0>()+i;
+		if (x.size<0>()-i>ub) ub += is_CPP0X_attribute(x.data<0>()[i+ub]);
+		local_identifier = true;
+		}
+	else if (is_naked_parentheses_pair(x.data<0>()[i]))
+		{
+		const size_t content_length = x.size<0>();
+		if (0<content_length && content_length==CPP_init_declarator_scanner(x.c_array<0>()[i],0,target_type,initdecl_identifier))
+			ub = 1;
+		}
+	if (0<ub)
+		{
+		while(x.size<0>()-i>ub)
+			{
+			if (is_naked_bracket_pair(x.data<0>()[i+ub]))
+				{	// we'll catch the array size, etc. later
+				if (!(target_type.qualifier<0>() & type_spec::_function_return_value))
+					target_type.make_C_array(0);
+				++ub;
+				if (x.size<0>()-i>ub) ub += is_CPP0X_attribute(x.data<0>()[i+ub]);
+				continue;
+				}
+			else if (is_naked_parentheses_pair(x.data<0>()[i+ub]))
+				{	// handle the prototype later
+				target_type.qualifier<0>() |= type_spec::_function_return_value;
+				++ub;
+				if (x.size<0>()-i>ub) ub += is_CPP0X_attribute(x.data<0>()[i+ub]);
+				if (x.size<0>()-i>ub) ub += CPP_cv_qualifier_span(x,i+ub,target_type);
+				if (x.size<0>()-i>ub) ub += is_CPP0X_ref_qualifier(x.c_array<0>()[i+ub]);
+				if (x.size<0>()-i>ub) ub += is_CPP0X_exception_specification_here(x,i+ub);
+				// regenerate the initdecl_identifier if we have it
+				if (local_identifier) initdecl_identifier = x.c_array<0>()+i; 
+				continue;
+				}
+			break;
+			}
+		}
+	return ub;
+}
+
+/*
+declarator:
+ptr-declarator
+noptr-declarator parameters-and-qualifiers trailing-return-type
+
+ptr-declarator:
+noptr-declarator
+ptr-operator ptr-declarator
+*/
+static size_t CPP_init_declarator_scanner(parse_tree& x, size_t i,type_spec& target_type, parse_tree*& initdecl_identifier)
+{
+	assert(x.size<0>()>i);
+	const size_t ptr_like = CPP_recognize_pointerlike_declarator_section(x,i,target_type);
+	if (x.size<0>()-i <= ptr_like) return 0;
+	const size_t noptr_like = CPP_recognize_noptr_declaratorlike_section(x,i+ptr_like,target_type,initdecl_identifier);
+	if (0<noptr_like)
+		{
+		if (0<ptr_like) return ptr_like+noptr_like;
+		//! \todo handle rest of other case
+		return noptr_like;
+		}
+	return 0;
+}
+
+static size_t span_to_semicolon(const parse_tree* const first,const parse_tree* const last)
+{
+	assert(first);
+	assert(last);
+	const parse_tree* iter = first;
+	while(iter!=last && !robust_token_is_char<';'>(*iter)) ++iter;
+	return iter-first;
+}
+
+#if 0
+static bool is_identifier_list(const parse_tree& src,func_traits<const char* (*)(const char* x,size_t x_len)>::function_ref_type EchoReservedKeyword)
+{
+	assert(!src.empty());
+	size_t j = src.size<0>();
+	if (!(j%2)) return false;
+	const parse_tree* const x = src.data<0>();
+	assert(x);
+	do	{
+		if (!x[--j].is_atomic()) return false;
+		if (0==j%2)
+			{	// identifier needed
+			if (   C_TESTFLAG_IDENTIFIER!=x[j].index_tokens[0].flags	// must be identifier
+				|| (PARSE_TYPE & x[j].flags) 	// internal representation could land some types here, especially primary types
+				|| EchoReservedKeyword(x[j].index_tokens[0].token.first,x[j].index_tokens[0].token.second))	// keywords are only lexically identifiers, they'll cause problems
+				return false;
+			}
+		else{	// comma needed
+			if (!token_is_char<','>(x[j].index_tokens[0].token))
+				return false;
+			}
+		}
+	while(0<j);
+	return true;
+}
+#endif
+
+static void notice_enumerator_CPP(parse_tree& x,const type_system& types,const char* const active_namespace)
+{
+	if (x.is_atomic() && (C_TESTFLAG_IDENTIFIER & x.index_tokens[0].flags))
+		{
+		const type_system::enumerator_info* const tmp = types.get_enumerator_CPP(x.index_tokens[0].token.first,active_namespace);
+		if (tmp)
+			{
+			x.set_index_token_from_str_literal<0>(tmp->first);
+			x.type_code.set_type(tmp->second.first.first);
+			x.flags |= PARSE_PRIMARY_EXPRESSION;
+			// XXX would be handy to keep the tmp around, consider as time optimization XXX
+			}
+		}
+	size_t i = x.size<0>();
+	while(0<i) notice_enumerator_CPP(x.c_array<0>()[--i],types,active_namespace);
+	assert(x.empty<1>());	// expand these into loops if needed
+	assert(x.empty<2>());
+}
+
+//! \throw std::bad_alloc()
+static void C99_CPP_handle_static_assertion(parse_tree& src,type_system& types,PP_auxfunc& langinfo,const size_t i,const char* const err,const char* const active_namespace)
+{
+	assert(err && *err);
+	// find the next ';'
+	const size_t j = i+span_to_semicolon(src.data<0>()+i,src.end<0>());
+	if (src.size<0>()<=j)
+		{	//! \test zcc/staticassert.C99/Error_scope1.h, zcc/staticassert.C99/Error_scope1.hpp
+			//! \test zcc/staticassert.C99/Error_scope2.h, zcc/staticassert.C99/Error_scope2.hpp
+		message_header(src.data<0>()[i].index_tokens[0]);
+		INC_INFORM(ERR_STR);
+		INFORM("static assertion cut off by end of scope");
+		zcc_errors.inc_error();
+		src.DeleteNSlotsAt<0>(j-i,i);
+		return;
+		};
+	if (   !is_naked_parentheses_pair(src.data<0>()[i+1])
+		|| 3>src.data<0>()[i+1].size<0>()
+		|| !robust_token_is_char<','>(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-2])
+		|| !src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].is_atomic()
+		|| C_TESTFLAG_STRING_LITERAL!=src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].flags)
+		{	//! \test zcc/staticassert.C99/Error_badarg1.h, zcc/staticassert.C99/Error_badarg1.hpp
+			//! \test zcc/staticassert.C99/Error_badarg2.h, zcc/staticassert.C99/Error_badarg2.hpp
+			//! \test zcc/staticassert.C99/Error_badarg3.h, zcc/staticassert.C99/Error_badarg3.hpp
+			//! \test zcc/staticassert.C99/Error_badarg5.h, zcc/staticassert.C99/Error_badarg5.hpp
+			//! \test zcc/staticassert.C99/Error_badarg6.h, zcc/staticassert.C99/Error_badarg6.hpp
+			//! \test zcc/staticassert.C99/Error_badarg7.h, zcc/staticassert.C99/Error_badarg7.hpp
+		message_header(src.data<0>()[i].index_tokens[0]);
+		INC_INFORM(ERR_STR);
+		INFORM("malformed static assertion");
+		zcc_errors.inc_error();
+		src.DeleteNSlotsAt<0>(j-i+1,i);
+		return;
+		};
+	if (2!=j-i)
+		{	//! \test zcc/staticassert.C99/Error_badarg4.h, zcc/staticassert.C99/Error_badarg4.hpp
+		message_header(src.data<0>()[i].index_tokens[0]);
+		INC_INFORM(ERR_STR);
+		INFORM("garbage between static assertion arguments and terminating ;");
+		zcc_errors.inc_error();
+		src.DeleteNSlotsAt<0>(j-i+1,i);
+		return;
+		};
+	// actually use the static assertion correctly.
+	parse_tree_class parsetree;
+	{
+	const size_t k = src.data<0>()[i+1].size<0>()-2;
+	if (!parsetree.resize<0>(k))
+		{
+		message_header(src.data<0>()[i].index_tokens[0]);
+		INC_INFORM(ERR_STR);
+		_fatal("insufficient RAM to parse static assertion");
+		};
+	zaimoni::autotransform_n<void (*)(parse_tree&,const parse_tree&)>(parsetree.c_array<0>(),src.data<0>()[i+1].data<0>(),k,value_copy);
+	// type all enumerators now to make life reasonable later on for the expression-parser
+	size_t enum_scan = k;
+	do	notice_enumerator_CPP(parsetree.c_array<0>()[--enum_scan],types,active_namespace);
+	while(0<enum_scan);
+	}
+	// init above correctly
+	// snip from Condense
+	const size_t starting_errors = zcc_errors.err_count();
+	(langinfo.LocateExpression)(parsetree,SIZE_MAX,types);
+	if (starting_errors==zcc_errors.err_count())
+		{
+		while(parsetree.is_raw_list() && 1==parsetree.size<0>())
+			parsetree.eval_to_arg<0>(0);
+		// end snip from Condense
+		// snip from CPreproc
+		if (!parsetree.is_atomic() && !(langinfo.EvalParseTree)(parsetree,types))
+			{
+			parsetree.destroy();	// efficiency
+			message_header(src.data<0>()[i].index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM(err);
+			zcc_errors.inc_error();
+			src.DeleteNSlotsAt<0>(j-i+1,i);
+			return;
+			}
+		(langinfo.PPHackTree)(parsetree,types);
+		// final, when above is working properly
+		if (!parsetree.is_atomic())
+			{	//! \bug need test cases
+			parsetree.destroy();	// efficiency
+			message_header(src.data<0>()[i].index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM(err);
+			zcc_errors.inc_error();
+			src.DeleteNSlotsAt<0>(j-i+1,i);
+			return;
+			}
+		// end snip from CPreproc
+
+		// handle top-level enumerators
+		if (is_noticed_enumerator(parsetree,types))
+			enumerator_to_integer_representation(parsetree,types);
+
+		bool is_true = false;
+		if (!(langinfo.LiteralConvertsToBool)(parsetree,is_true,types))
+			{	//! \bug need test cases
+			parsetree.destroy();	// efficiency
+			message_header(src.data<0>()[i].index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM(err);
+			zcc_errors.inc_error();
+			src.DeleteNSlotsAt<0>(j-i+1,i);
+			return;
+			};
+		parsetree.destroy();	// efficiency
+		//! \test zcc/staticassert.C1X/Pass_autosucceed.h, zcc/staticassert.C1X/Pass_autosucceed.hpp
+		if (!is_true)
+			{	//! \test zcc/staticassert.C1X/Error_autofail.h, zcc/staticassert.C1X/Error_autofail.hpp
+			message_header(src.data<0>()[i].index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			// hmm...really should unescape string before emitting
+			const size_t tmp_size = LengthOfCStringLiteral(src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.second);
+			if (1U>=tmp_size || 'L'== *src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first)
+				{	//! \todo handle wide-strings later
+				INFORM("(static assertion failure)");
+				zcc_errors.inc_error();
+				src.DeleteNSlotsAt<0>(j-i+1,i);
+				return;
+				};
+
+			char* tmp = _new_buffer<char>(tmp_size);
+			if (!tmp)
+				{
+				INFORM("(static assertion failure)");
+				zcc_errors.inc_error();
+				src.DeleteNSlotsAt<0>(j-i+1,i);
+				return;
+				}
+			UnescapeCString(tmp,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.first+1,src.data<0>()[i+1].data<0>()[src.data<0>()[i+1].size<0>()-1].index_tokens[0].token.second-2);
+			INFORM(tmp);
+			free(tmp);
+			zcc_errors.inc_error();
+			src.DeleteNSlotsAt<0>(j-i+1,i);
+			return;
+			};
+		}
+	src.DeleteNSlotsAt<0>(j-i+1,i);
+}
+
+static bool default_enumerator_init_legal(const bool allow_empty, unsigned char& current_enumerator_type, const unsigned_var_int& prior_value, const weak_token& src, const type_system& types)
+{
+	if (allow_empty)
+		{	// C++
+		//! \todo research how to rewrite this without the goto
+cpp_enum_was_retyped:
+		const promote_aux test(current_enumerator_type,types);
+		// -Wc-c++-compat trips: C++ tolerates enumerator values that don't fit in int 
+		if (bool_options[boolopt::warn_crosslang_compatibility] && C_TYPE::INT==current_enumerator_type && prior_value==target_machine->signed_max(test.machine_type))
+			{	//! \test compat/Warn_enum_overflow.hpp
+			message_header(src);
+			INC_INFORM(WARN_STR);
+			INFORM("enumerator value not representable by int is an error in C (C99 6.7.2.2p3)");
+			if (bool_options[boolopt::warnings_are_errors]) zcc_errors.inc_error();
+			};
+		if (test.is_signed)
+			{
+			if (prior_value==target_machine->signed_max(test.machine_type))
+				{
+				++current_enumerator_type;	// smallest type that can handle this
+				goto cpp_enum_was_retyped;
+				}
+			}
+		else{
+			if (prior_value==target_machine->unsigned_max(test.machine_type))
+				{
+				if (C_TYPE::INTEGERLIKE == ++current_enumerator_type)	// smallest type that can handle this
+					{	// unsigned long long overflow, fact it's defined doesn't save us
+					//! \test decl.C99/Error_enum_overflow.hpp
+					message_header(src);
+					INC_INFORM(ERR_STR);
+					INFORM("default-initialization of enumerator requires uintmax_t overflow (C++0X 7.2p5)");
+					zcc_errors.inc_error();
+					return false;
+					}
+				goto cpp_enum_was_retyped;
+				}
+			}
+		}
+	else{	// C
+		if (prior_value==target_machine->signed_max<virtual_machine::std_int_int>())
+			{	// signed integer overflow
+				//! \test decl.C99/Error_enum_overflow.h
+			message_header(src);
+			INC_INFORM(ERR_STR);
+			INFORM("default-initialization of enumerator requires signed int overflow (C99 6.7.2.2p3)");
+			zcc_errors.inc_error();
+			return false;
+			}
+		}
+	return true;
+}
+
+//! \throw std::bad_alloc
+static bool record_enum_values(parse_tree& src, type_system& types, const type_system::type_index enum_type_index, const char* const active_namespace,bool allow_empty,func_traits<const char* (*)(const char*, size_t)>::function_ref_type echo_reserved_keyword, intlike_literal_to_VM_func& intlike_literal_to_VM, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type CondenseParseTree, func_traits<bool (*)(parse_tree&,const type_system&)>::function_ref_type EvalParseTree)
+{
+	assert(enum_type_index);
+	assert(!active_namespace || *active_namespace);
+	assert(is_naked_brace_pair(src));
+	// enumeration idea:
+	// * identifer [= ...] ,
+	// terminal , is optional (and in fact should trigger a warning for -Wbackport)
+	// empty collection of enumerators is fine for C++, rejected by C (should be error in C and -Wc-c++-compat for C++)
+	// XXX use allow_empty to signal C vs. C++ language
+	// values would be unsigned_var_int
+	if (src.empty<0>())
+		{
+		if (!allow_empty)
+			{	//! \test zcc/decl.C99/Error_enum_empty.h
+			message_header(src.index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM("enumeration has no enumerators (C99 6.7.2.2p1)");
+			zcc_errors.inc_error();
+			return false;
+			}
+		else if (bool_options[boolopt::warn_crosslang_compatibility])
+			{	//! \test zcc/compat/Warn_enum_empty.hpp
+			message_header(src.index_tokens[0]);
+			INC_INFORM(WARN_STR);
+			INFORM("enumeration with no enumerators is an error in C90/C99/C1X");
+			if (bool_options[boolopt::warnings_are_errors])
+				{
+				zcc_errors.inc_error();
+				return false;
+				}
+			}
+		//! \test zcc/decl.C99/Pass_enum_empty.hpp
+		return true;
+		};
+	// determine if format generally there
+	// stage 1: top-level comma check
+	// * terminal comma is optional, zap it and warn if -Wbackport
+	// * one more enumerator possible than surviving commas; use this to construct buffers
+	size_t i = 0;
+	while(src.size<0>()>i)
+		{	// require identifier that is neither keyword nor a primitive type
+			// C++ will have problems with enum/struct/class/union names, verify status of both of these (could be -Wc-c++-compat issue if legal in C)
+			// if identifier, verify next is = or ,
+			// if next is =, locate comma afterwards (do not do expression parsing yet)
+			//! \todo: enforce One Definition Rule for C++ vs types; determine how much of the effect is in C as well
+		if (   !src.data<0>()[i].is_atomic()
+			||  C_TESTFLAG_IDENTIFIER!=src.data<0>()[i].index_tokens[0].flags
+			|| (PARSE_TYPE & src.data<0>()[i].flags)
+			|| echo_reserved_keyword(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].token.second))
+			{	//! \test zcc/decl.C99/Error_enum_brace.h, zcc/decl.C99/Error_enum_brace.hpp
+				//! \test zcc/decl.C99/Error_enum_symbol.h, zcc/decl.C99/Error_enum_symbol.hpp
+				//! \test zcc/decl.C99/Error_enum_type.h, zcc/decl.C99/Error_enum_type.hpp
+				//! \test zcc/decl.C99/Error_enum_keyword.h, zcc/decl.C99/Error_enum_keyword.hpp
+			message_header(0==i ? src.index_tokens[0] : src.data<0>()[i-i].index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM("non-keyword identifier expected as enumerator (C99 6.4.4.3p1/C++0X 7.2p1)");
+			zcc_errors.inc_error();
+			return false;
+			}
+		if (1>=src.size<0>()-i) break;	// fine, would default-update
+		if (robust_token_is_char<','>(src.data<0>()[i+1]))
+			{	// would default-update
+			i += 2;
+			continue;
+			};
+		if (!robust_token_is_char<'='>(src.data<0>()[i+1]))
+			{	//! \test zcc/decl.C99/Error_enum_no_init.h, zcc/decl.C99/Error_enum_no_init.hpp
+			message_header(src.data<0>()[i].index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM("enumerator neither explicitly initialized nor default-initialized (C99 6.4.4.3p1/C++0X 7.2p1)");
+			zcc_errors.inc_error();
+			return false;
+			};
+		i += 2;
+		if (src.size<0>()<=i || robust_token_is_char<','>(src.data<0>()[i]))
+			{	//! \test zcc/decl.C99/Error_enum_init_truncated.h, zcc/decl.C99/Error_enum_init_truncated.hpp
+			message_header(src.data<0>()[i].index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM("enumerator initializer cut off by , (C99 6.4.4.3p1/C++0X 7.2p1)");
+			zcc_errors.inc_error();
+			return false;
+			};
+		while(++i < src.size<0>())
+			{
+			if (robust_token_is_char<','>(src.data<0>()[i]))
+				{
+				++i;
+				break;
+				}
+			};
+		}
+	if (robust_token_is_char<','>(src.back<0>()))
+		{	// warn for -Wbackport
+			//! \test zcc/decl.C99/Pass_enum_trailing_comma.h, zcc/decl.C99/Pass_enum_trailing_comma.hpp
+			//! \test zcc/backport/Warn_enum_trailing_comma.h, zcc/backport/Warn_enum_trailing_comma.hpp
+		if (bool_options[boolopt::warn_backport])
+			{
+			message_header(src.back<0>().index_tokens[0]);
+			INC_INFORM(WARN_STR);
+			INFORM("trailing , in enumeration definition would be an error in C90/C++98");
+			if (bool_options[boolopt::warnings_are_errors])
+				{
+				zcc_errors.inc_error();
+				return false;
+				}
+			}
+		src.DeleteIdx<0>(src.size<0>()-1); // clean up anyway
+		}
+	//! \todo actually record enumerator matchings
+	unsigned_var_int latest_value(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
+	unsigned_var_int prior_value(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
+	unsigned char current_enumerator_type = C_TYPE::INT;
+	unsigned char base_enum_type = C_TYPE::INT;
+	bool cpp_using_negative = false;
+	i = 0;
+	while(src.size<0>()>i)
+		{	// require identifier that is neither keyword nor a primitive type
+			// C++ will have problems with enum/struct/class/union names, verify status of both of these (could be -Wc-c++-compat issue if legal in C)
+			// if identifier, verify next is = or ,
+			// if next is =, locate comma afterwards (do not do expression parsing yet)
+			//! \todo: enforce One Definition Rule for C++ vs types; determine how much of the effect is in C as well
+		assert(src.data<0>()[i].is_atomic());
+		assert(C_TESTFLAG_IDENTIFIER==src.data<0>()[i].index_tokens[0].flags);
+		assert(!(PARSE_TYPE & src.data<0>()[i].flags));
+		assert(!echo_reserved_keyword(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].token.second));
+		{
+		char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[0].token.first,active_namespace,"::") : NULL;
+		const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[0].token.first;
+		{
+		const type_system::enumerator_info* tmp = types.get_enumerator(fullname);
+		if (tmp)
+			{	// --do-what-i-mean could recover if the prior definition were identical
+				// C: note on C99/C1X 6.7.2.2p3 indicates autofail no matter where it was defined
+				// C++: One Definition Rule wipes out
+				//! \test decl.C99/Error_enum_multidef.h, decl.C99/Error_enum_multidef.hpp 
+			message_header(src.data<0>()[i].index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM("enumerator is already defined (C99 6.7.2.2p3/C++98 3.2)");
+			zcc_errors.inc_error();
+			free(namespace_name);
+			return false;
+			};
+		}
+		free(namespace_name);
+		}
+#if 0
+		// next proposed function call is a bit handwavish right now...
+		// C++0X 3.3.1p4: enumerator gets to hide class names and enum names, nothing else [in particular dies against typedefs and functions]
+		if (types.enum_already_defined(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
+			{	// -Wbackport warn in C++, fail in C
+			if (allow_empty)
+				{	// C++0X
+				if (bool_options[boolopt::warn_crosslang_compatibility] || bool_options[boolopt::warn_backport])
+					{
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("enum with same name as enumerator is already defined (C99 6.7.2.2p3/C++98 3.2/C++0X 3.2)");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					}
+				}
+			else{	// C
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("enum with same name as enumerator is already defined (C99 6.7.2.2p3)");
+				zcc_errors.inc_error();
+				return false;
+				}	
+			};
+		if (types.union_class_struct_already_declared(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
+			{	// -Wbackport warn in C++, fail in C
+			if (allow_empty)
+				{	// C++0X
+				if (bool_options[boolopt::warn_crosslang_compatibility] || bool_options[boolopt::warn_backport])
+					{
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("union, struct, or class with same name as enumerator is already defined (C99 6.7.2.2p3/C++98 3.2/C++0X 3.2)");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					}
+				}
+			else{	// C
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("union or struct with same name as enumerator is already defined (C99 6.7.2.2p3)");
+				zcc_errors.inc_error();
+				return false;
+				}	
+			};
+		if (types.function_already_declared(active_namespace,src.data<0>()[i].index_tokens[0].token.first))
+			{	// C++: One Definition Rule
+			};
+#endif
+		{
+		const zaimoni::POD_triple<type_spec,const char*,size_t>* const tmp = types.get_typedef_CPP(src.data<0>()[i].index_tokens[0].token.first,active_namespace); 
+		if (tmp)
+			{	// C++: One Definition Rule
+				//! \test decl.C99/Error_enum_typedef.h, decl.C99/Error_enum_typedef.hpp 
+			message_header(src.data<0>()[i].index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM("typedef is already defined, conflicts with enumerator (C99 6.7.2.2p3/C++98 3.2)");
+			INC_INFORM(tmp->second);
+			INC_INFORM(":");
+			INC_INFORM(tmp->third);
+			INFORM(": typedef definition here");
+			zcc_errors.inc_error();
+			return false;
+			};
+		}
+
+		// The type and representation of an enumeration varies by language
+		// C: values are type int; actual representation can be decided after seeing all enumeration values.
+		// C++: if the underlying type is fixed, then the enumerator is of that type.  Othewise,
+		// each enumerator has the same type as its initializing expression, and the underlying type of
+		// the enumeration is large enough to represent all values.
+		// So, for the default-update cases
+		// C: type int, hard-error if going above INT_MAX
+		// C++: type per language specification,
+		// * hard-error if going above ULONG_MAX
+		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
+		// in any case, do not react if the default-init isn't used
+		value_copy(prior_value,latest_value);
+		{
+		bool value_is_nonnegative = true;
+		const promote_aux test(current_enumerator_type,types);
+		if (test.is_signed && latest_value.test(test.bitcount-1))
+			{
+			target_machine->signed_additive_inverse(latest_value,test.machine_type);
+			if (0<latest_value)
+				{
+				latest_value -= 1;
+				if (0<latest_value) target_machine->signed_additive_inverse(latest_value,test.machine_type);
+				value_is_nonnegative = false;
+				}
+			}
+		if (value_is_nonnegative) latest_value += 1;
+		}
+
+		if (1>=src.size<0>()-i)
+			{	// default-update
+			// handle type errors
+			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0],types))
+				return false;
+			uchar_blob latest_value_copy;
+			latest_value_copy.init(0);
+			value_copy(latest_value_copy,latest_value);
+			if (active_namespace)
+				types.set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+			else
+				types.set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+			break;
+			}
+		// complete conversion
+		// C: type int, hard-error if not within INT_MIN..INT_MAX
+		// C++: type per language specification
+		// * invoke -Wc-c++-compat if not within INT_MIN..INT_MAX
+		if (robust_token_is_char<','>(src.data<0>()[i+1]))
+			{	// would default-update
+			if (!default_enumerator_init_legal(allow_empty,current_enumerator_type,prior_value,src.data<0>()[i].index_tokens[0],types))
+				return false;
+			uchar_blob latest_value_copy;
+			latest_value_copy.init(0);
+			value_copy(latest_value_copy,latest_value);
+			if (active_namespace)
+				types.set_enumerator_def_CPP(src.data<0>()[i].index_tokens[0].token.first, active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+			else
+				types.set_enumerator_def(src.data<0>()[i].index_tokens[0].token.first,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+			i += 2;
+			continue;
+			};
+		assert(robust_token_is_char<'='>(src.data<0>()[i+1]));
+		i += 2;
+		const size_t origin = i;
+		assert(src.size<0>()>i && !robust_token_is_char<','>(src.data<0>()[i]));
+		bool comma_overextended = false;
+		while(++i < src.size<0>())
+			{
+			if (robust_token_is_char<','>(src.data<0>()[i]))
+				{
+				++i;
+				comma_overextended = true;
+				break;
+				}
+			};
+		{	// see if it's a compile-time constant
+		parse_tree_class tmp(src,origin,i-comma_overextended,0);
+		if (tmp.is_raw_list() && !CondenseParseTree(tmp,types)) return false;
+		if (!EvalParseTree(tmp,types)) return false;
+		if (!intlike_literal_to_VM(latest_value,tmp,types))
+			{	//! \bug need test case
+			message_header(src.data<0>()[origin-2].index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INFORM("enumerator can only be explicitly initialized by a compile-time constant (C99 6.7.2.2p3/C++98 7.2p1)");
+			zcc_errors.inc_error();
+			return false;
+			}
+		// range checks
+		if (allow_empty)
+			{	// C++
+			current_enumerator_type = tmp.type_code.base_type_index;
+			const promote_aux test(current_enumerator_type,types);
+			if (test.is_signed && latest_value.test(test.bitcount-1))
+				{	// negative
+				unsigned_var_int abs_latest_value(latest_value);
+				target_machine->signed_additive_inverse(abs_latest_value,test.machine_type);
+				if (virtual_machine::twos_complement==target_machine->C_signed_int_representation() && !bool_options[boolopt::int_traps])
+					abs_latest_value-=1;
+				cpp_using_negative = true;
+				// sign filter
+				switch(base_enum_type)
+				{
+				case C_TYPE::INT:
+				case C_TYPE::LONG:
+				case C_TYPE::LLONG:
+					break;	// these three are already signed, no representation change incurred
+				case C_TYPE::UINT:
+					if (target_machine->C_sizeof_int()<target_machine->C_sizeof_long())
+						{
+						base_enum_type = C_TYPE::LONG;
+						break;
+						}
+				case C_TYPE::ULONG:
+					if (target_machine->C_sizeof_long()<target_machine->C_sizeof_long_long())
+						{
+						base_enum_type = C_TYPE::LLONG;
+						break;
+						}
+				default:	//! \test decl.C99/Error_enum_nobase.hpp
+					message_header(src.data<0>()[origin-2].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("enumeration requires both negative values and values above INTMAX_MAX, underlying type doesn't exist (C++0X 7.2p6)");
+					zcc_errors.inc_error();
+					return false;
+				}
+				// value filter
+				switch(base_enum_type)
+				{
+				case C_TYPE::INT:
+					if (target_machine->signed_max<virtual_machine::std_int_int>()>=abs_latest_value) break;
+					base_enum_type = C_TYPE::LONG;
+				case C_TYPE::LONG:
+					if (target_machine->signed_max<virtual_machine::std_int_long>()>=abs_latest_value) break;
+					base_enum_type = C_TYPE::LLONG;
+				case C_TYPE::LLONG:
+					if (target_machine->signed_max<virtual_machine::std_int_long_long>()>=abs_latest_value) break;
+				default:	//! \bug needs test case
+					message_header(src.data<0>()[origin-2].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("enumeration requires value below INTMAX_MIN, underlying type doesn't exist (C++0X 7.2p6)");
+					zcc_errors.inc_error();
+					return false;
+				}
+				}
+			else{	// positive
+				if (cpp_using_negative)
+					{
+					switch(base_enum_type)
+					{
+					case C_TYPE::INT:
+						if (target_machine->signed_max<virtual_machine::std_int_int>()>=latest_value) break;
+						base_enum_type = C_TYPE::LONG;
+					case C_TYPE::LONG:
+						if (target_machine->signed_max<virtual_machine::std_int_long>()>=latest_value) break;
+						base_enum_type = C_TYPE::LLONG;
+					case C_TYPE::LLONG:
+						if (target_machine->signed_max<virtual_machine::std_int_long_long>()>=latest_value) break;
+					default:	//! \test decl.C99/Error_enum_nobase2.hpp
+						message_header(src.data<0>()[origin-2].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("enumeration requires both negative values and values above INTMAX_MAX, underlying type doesn't exist (C++0X 7.2p6)");
+						zcc_errors.inc_error();
+						return false;
+					}
+					}
+				else{
+					switch(base_enum_type)
+					{
+					case C_TYPE::INT:
+						if (target_machine->signed_max<virtual_machine::std_int_int>()>=latest_value) break;
+						base_enum_type = C_TYPE::UINT;
+					case C_TYPE::UINT:
+						if (target_machine->unsigned_max<virtual_machine::std_int_int>()>=latest_value) break;
+						base_enum_type = C_TYPE::LONG;
+					case C_TYPE::LONG:
+						if (target_machine->signed_max<virtual_machine::std_int_long>()>=latest_value) break;
+						base_enum_type = C_TYPE::ULONG;
+					case C_TYPE::ULONG:
+						if (target_machine->unsigned_max<virtual_machine::std_int_long>()>=latest_value) break;
+						base_enum_type = C_TYPE::LLONG;
+					case C_TYPE::LLONG:
+						if (target_machine->signed_max<virtual_machine::std_int_long_long>()>=latest_value) break;
+						base_enum_type = C_TYPE::ULLONG;
+					case C_TYPE::ULLONG:
+						if (target_machine->unsigned_max<virtual_machine::std_int_long_long>()>=latest_value) break;
+					default:	//! \test decl.C99\Error_enum_overflow.hpp
+						message_header(src.data<0>()[origin-2].index_tokens[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("enumeration requires values above UINTMAX_MAX, underlying type doesn't exist (C++0X 7.2p6)");
+						zcc_errors.inc_error();
+						return false;
+					}
+					}
+				}
+			}
+		else{	// C
+			const promote_aux test(tmp.type_code.base_type_index,types);
+			const promote_aux dest_type(C_TYPE::INT,types);
+			const bool is_negative = test.is_signed && latest_value.test(test.bitcount-1);
+			if (is_negative)
+				target_machine->signed_additive_inverse(latest_value,test.machine_type);
+			bool out_of_range = latest_value>target_machine->signed_max<virtual_machine::std_int_int>();
+			if (out_of_range && is_negative && virtual_machine::twos_complement==target_machine->C_signed_int_representation())
+				{	// handle two's complement INT_MIN
+				latest_value -= 1;
+				if (latest_value<=target_machine->signed_max<virtual_machine::std_int_int>()) 
+					out_of_range = false;
+				latest_value += 1;
+				}
+			if (out_of_range)
+				{	//! \test decl.C99/Error_enum_overflow2.h
+				message_header(src.data<0>()[origin-2].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("initializer of enumerator not representable as signed int (C99 6.7.2.2p3)");
+				zcc_errors.inc_error();
+				if (bool_options[boolopt::warn_crosslang_compatibility])
+					INFORM("(this may be valid C++, if the value is representable as either uintmax_t or intmax_t)");
+				return false;
+				}
+			if (is_negative)
+				target_machine->signed_additive_inverse(latest_value,dest_type.machine_type);
+			tmp.type_code.base_type_index = C_TYPE::INT;
+			}
+#if 0
+		if (origin+1<i-comma_overextended)
+			{	// net token reduction, do source code optimization?
+			}
+#endif
+		}
+
+		{	// actually register the enumerator
+		uchar_blob latest_value_copy;
+		latest_value_copy.init(0);
+		value_copy(latest_value_copy,latest_value);
+		if (active_namespace)
+			types.set_enumerator_def_CPP(src.data<0>()[origin-2].index_tokens[0].token.first, active_namespace,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+		else
+			types.set_enumerator_def(src.data<0>()[origin-2].index_tokens[0].token.first,src.data<0>()[origin-2].index_tokens[0].logical_line,src.data<0>()[origin-2].index_tokens[0].src_filename,current_enumerator_type,latest_value_copy,enum_type_index);
+		}
+		}
+	// now ok to crunch underlying type/machine representation
+	types.set_enum_underlying_type(enum_type_index,allow_empty ? base_enum_type : C_TYPE::INT);
+	return true;
+}
+
+// will need: "function-type vector"
+// return: 1 typespec record (for now, other languages may have more demanding requirements)
+// incoming: n typespec records, flag for trailing ...
+// will need: typedef map: identifier |-> typespec record
+//! \todo check that the fact all literals are already legal-form is used
+//! \throw std::bad_alloc
+static void C99_ContextParse(parse_tree& src,type_system& types)
+{
+	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle in type_spec, which is required to be POD to allow C memory management:
+	// * indirection depth n (already have this in practice)
+	// * const, volatile at each level of indirection 0..n
+	// * extent at each level of indirection 1..n (0 := raw-ptr, positive := array that can be bounds-checked for undefined behavior
+	// * top-level reference (check standards to see if reference-in-middle is illegal, never seen it in real source)
+	// * C99: restrict qualifier at each level of indirection 1..n (this is *not* in C++0x as of April 8 2009!)
+	// * storage-qualifiers extern, static, register, auto
+	// * fake type-qualifier typedef
+	// Exploit uintptr_t to mitigate dynamic memory management.
+	// * union of uintptr_t,unsigned char[sizeof(uintptr_t)] is probably best way to handle the qualifier-vector
+	// * extent-vector will be painful: properly should be a CPUInfo-controlled type.  Can get away with uintmax_t for now.  (size_t won't work because we're
+	//   a cross-compiler; target size_t could be larger than host size_t.  size_t does work for string literals since we have to represent those on the host.)
+	// note that typedefs and struct/union declarations/definitions create new types; if this happens we are no longer context-free (so second pass with context-based parsing)
+	// ask GCC: struct/class/union/enum collides with each other (both C and C++), does not collide with namespace
+	// think we can handle this as "disallow conflicting definitions"
+	kleene_star<STATIC_SIZE(C99_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(C99_type_or_invariant_decl_specifier);
+	size_t i = 0;
+	while(i<src.size<0>())
+		{
+		conserve_tokens(src.c_array<0>()[i]);
+		// C static assertion scanner
+		if (robust_token_is_string<14>(src.data<0>()[i],"_Static_Assert"))
+			{	// _Static_Assert ( constant-expression , string-literal ) ;
+			C99_CPP_handle_static_assertion(src,types,*CLexer->pp_support,i,"control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)",NULL);
+			continue;
+			};
+		// XXX C allows mixing definitions and declaring variables at the same time, but this is a bit unusual
+		// check naked declarations first
+		if (is_C99_named_specifier(src.data<0>()[i],"union"))
+			{
+C99_union_specifier:
+			const type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
+			if (tmp)
+				{
+				src.c_array<0>()[i].type_code.set_type(tmp);
+				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+				};
+			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+			if (tmp2)
+				{	//! \test zcc/decl.C99/Pass_union_forward_def.h
+				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array<0>()[i].type_code.set_type(tmp2);
+				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+				};
+			assert(tmp || tmp2);
+			if (   1<src.size<0>()-i
+				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// check for forward-declaration here (C99 6.7.2.3)
+				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Warn_union_forward_def_const.h
+						//! \test decl.C99/Warn_union_forward_def_const2.h
+						//! \test decl.C99/Warn_union_forward_def_const3.h
+						//! \test decl.C99/Warn_union_forward_def_const4.h
+						//! \test decl.C99/Warn_union_forward_def_volatile.h
+						//! \test decl.C99/Warn_union_forward_def_volatile2.h
+						//! \test decl.C99/Warn_union_forward_def_volatile3.h
+						//! \test decl.C99/Warn_union_forward_def_volatile4.h
+						//! \test decl.C99/Warn_union_forward_def_const_volatile.h
+						//! \test decl.C99/Warn_union_forward_def_const_volatile2.h
+						//! \test decl.C99/Warn_union_forward_def_const_volatile3.h
+						//! \test decl.C99/Warn_union_forward_def_const_volatile4.h
+						//! \test decl.C99/Warn_union_forward_def_const_volatile5.h
+						//! \test decl.C99/Warn_union_forward_def_const_volatile6.h
+						//! \test decl.C99/Warn_union_forward_def_const_volatile7.h
+						//! \test decl.C99/Warn_union_forward_def_const_volatile8.h
+						//! \test decl.C99/Warn_union_forward_def_const_volatile9.h
+						//! \test decl.C99/Warn_union_forward_def_const_volatile10.h
+						//! \test decl.C99/Warn_union_forward_def_const_volatile11.h
+						//! \test decl.C99/Warn_union_forward_def_const_volatile12.h
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("useless const/volatile qualification of a forward-declaration (C99 6.7.3p3)");
+					if (bool_options[boolopt::warn_crosslang_compatibility])
+						INFORM("(error in C++: C++0X 7.1.6.1p1)");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					};
+				if (tmp)
+					{	// but if already (forward-)declared then this is a no-op
+						// think this is common enough to not warrant OAOO/DRY treatment
+					//! \test zcc/decl.C99/Pass_union_forward_def.h
+					// remove from parse
+					src.DeleteNSlotsAt<0>(2,i);
+					continue;					
+					}
+				// forward-declare
+				//! \test zcc/decl.C99/Pass_union_forward_def.h
+				assert(tmp2);
+				i += 2;
+				continue;
+				}
+			else if (!tmp)
+				{	// used without at least forward-declaring
+					//! \bug needs test cases
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("used without at least forward-declaring");
+				zcc_errors.inc_error();
+				}
+			}
+		else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
+			{
+C99_struct_specifier:
+			const type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+			if (tmp)
+				{
+				src.c_array<0>()[i].type_code.set_type(tmp);
+				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+				};
+			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+			if (tmp2)
+				{	//! \test zcc/decl.C99/Pass_struct_forward_def.h
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array<0>()[i].type_code.set_type(tmp2);
+				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+				};
+			assert(tmp || tmp2);
+			if (   1<src.size<0>()-i
+				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// check for forward-declaration here (C99 6.7.2.3)
+				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Warn_struct_forward_def_const.h
+						//! \test decl.C99/Warn_struct_forward_def_const2.h
+						//! \test decl.C99/Warn_struct_forward_def_const3.h
+						//! \test decl.C99/Warn_struct_forward_def_const4.h
+						//! \test decl.C99/Warn_struct_forward_def_volatile.h
+						//! \test decl.C99/Warn_struct_forward_def_volatile2.h
+						//! \test decl.C99/Warn_struct_forward_def_volatile3.h
+						//! \test decl.C99/Warn_struct_forward_def_volatile4.h
+						//! \test decl.C99/Warn_struct_forward_def_const_volatile.h
+						//! \test decl.C99/Warn_struct_forward_def_const_volatile2.h
+						//! \test decl.C99/Warn_struct_forward_def_const_volatile3.h
+						//! \test decl.C99/Warn_struct_forward_def_const_volatile4.h
+						//! \test decl.C99/Warn_struct_forward_def_const_volatile5.h
+						//! \test decl.C99/Warn_struct_forward_def_const_volatile6.h
+						//! \test decl.C99/Warn_struct_forward_def_const_volatile7.h
+						//! \test decl.C99/Warn_struct_forward_def_const_volatile8.h
+						//! \test decl.C99/Warn_struct_forward_def_const_volatile9.h
+						//! \test decl.C99/Warn_struct_forward_def_const_volatile10.h
+						//! \test decl.C99/Warn_struct_forward_def_const_volatile11.h
+						//! \test decl.C99/Warn_struct_forward_def_const_volatile12.h
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("useless const/volatile qualification of a forward-declaration (C99 6.7.3p3)");
+					if (bool_options[boolopt::warn_crosslang_compatibility])
+						INFORM("(error in C++: C++0X 7.1.6.1p1)");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					};
+				if (tmp)
+					{	// but if already (forward-)declared then this is a no-op
+						// think this is common enough to not warrant OAOO/DRY treatment
+					//! \test zcc/decl.C99/Pass_struct_forward_def.h
+					// remove from parse
+					src.DeleteNSlotsAt<0>(2,i);
+					continue;					
+					}
+				// forward-declare
+				//! \test zcc/decl.C99/Pass_struct_forward_def.h
+				assert(tmp2);
+				i += 2;
+				continue;
+				}
+			else if (!tmp)
+				{	// used without at least forward-declaring
+					//! \bug needs test cases
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("used without at least forward-declaring");
+				zcc_errors.inc_error();
+				}
+			}
+		else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
+			{	// can only define once
+			const type_system::type_index tmp = types.get_id_union(src.data<0>()[i].index_tokens[1].token.first);
+			if (tmp)
+				{
+				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				if (fatal_def)
+					{	//! \test zcc/decl.C99/Error_union_multidef.h
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'union ");
+					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INFORM("' already defined (C99 6.7.2.3p1)");
+					message_header(*fatal_def);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					// reduce to named-specifier
+					src.c_array<0>()[i].DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+					goto C99_union_specifier;
+					}
+				src.c_array<0>()[i].type_code.set_type(tmp);
+				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+				};
+			//! \bug C1X 6.7.2.3p2 states that conflicting enum or struct must error
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+			if (tmp2)
+				{	//! \test zcc/decl.C99/Pass_union_forward_def.h
+				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array<0>()[i].type_code.set_type(tmp2);
+				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+				};
+			assert(tmp || tmp2);
+			// parse the union and upgrade it to a full definition
+			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
+			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			assert(tmp3);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record field structure, etc.
+			types.upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(types.get_C_structdef(vr_tmp));
+			if (   1<src.size<0>()-i
+				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// no objects declared, trigger the const/volatile warnings
+				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Warn_union_def_const.h
+						//! \test decl.C99/Warn_union_def_const2.h
+						//! \test decl.C99/Warn_union_def_volatile.h
+						//! \test decl.C99/Warn_union_def_volatile2.h
+						//! \test decl.C99/Warn_union_def_const_volatile.h
+						//! \test decl.C99/Warn_union_def_const_volatile2.h
+						//! \test decl.C99/Warn_union_def_const_volatile3.h
+						//! \test decl.C99/Warn_union_def_const_volatile4.h
+						//! \test decl.C99/Warn_union_def_const_volatile5.h
+						//! \test decl.C99/Warn_union_def_const_volatile6.h
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("useless const/volatile qualification of a definition (C99 6.7.3p3)");
+					if (bool_options[boolopt::warn_crosslang_compatibility])
+						INFORM("(error in C++: C++0X 7.1.6.1p1)");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					};
+				// accept definition
+				//! \test zcc/decl.C99/Pass_union_forward_def.h
+				i += 2;
+				continue;
+				};
+			}
+		else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
+			{	// can only define once
+			const type_system::type_index tmp = types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first);
+			if (tmp)
+				{
+				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				if (fatal_def)
+					{	//! \test zcc/decl.C99/Error_struct_multidef.h
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'struct ");
+					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INFORM("' already defined (C99 6.7.2.3p1)");
+					message_header(*fatal_def);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					// reduce to named-specifier
+					src.c_array<0>()[i].DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
+					goto C99_struct_specifier;
+					}
+				src.c_array<0>()[i].type_code.set_type(tmp);
+				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+				};
+			//! \bug C1X 6.7.2.3p2 states that conflicting enum or union must error
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+			if (tmp2)
+				{	//! \test zcc/decl.C99/Pass_struct_forward_def.h
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array<0>()[i].type_code.set_type(tmp2);
+				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+				};
+			assert(tmp || tmp2);
+			// parse the union and upgrade it to a full definition
+			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
+			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			assert(tmp3);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record field structure, etc.
+			types.upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(types.get_C_structdef(vr_tmp));
+			if (   1<src.size<0>()-i
+				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// no objects declared, trigger the const/volatile warnings
+				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Warn_struct_def_const.h
+						//! \test decl.C99/Warn_struct_def_const2.h
+						//! \test decl.C99/Warn_struct_def_volatile.h
+						//! \test decl.C99/Warn_struct_def_volatile2.h
+						//! \test decl.C99/Warn_struct_def_const_volatile.h
+						//! \test decl.C99/Warn_struct_def_const_volatile2.h
+						//! \test decl.C99/Warn_struct_def_const_volatile3.h
+						//! \test decl.C99/Warn_struct_def_const_volatile4.h
+						//! \test decl.C99/Warn_struct_def_const_volatile5.h
+						//! \test decl.C99/Warn_struct_def_const_volatile6.h
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("useless const/volatile qualification of a definition (C99 6.7.3p3)");
+					if (bool_options[boolopt::warn_crosslang_compatibility])
+						INFORM("(error in C++: C++0X 7.1.6.1p1)");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					};
+				// accept definition
+				//! \test zcc/decl.C99/Pass_union_forward_def.h
+				i += 2;
+				continue;
+				};
+			}
+		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
+		else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
+			{	// C99 6.7.2.3: allowed only after name is defined
+			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
+				{
+				type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+				src.c_array<0>()[i].type_code.set_type(C_TYPE::INT);	// C: enums are int (although we'd like to extend this a bit)
+				if (!tmp)
+					{	//! \test zcc/decl.C99/Error_enum_undef.h
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'enum ");
+					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INFORM("' must refer to completely defined enum (C99 6.7.2.3p2)");
+					zcc_errors.inc_error();
+					src.c_array<0>()[i].flags |= parse_tree::INVALID;
+					}
+				}
+			}
+		else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
+			{	// can only define once
+			const type_system::type_index tmp = types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first);
+			if (tmp)
+				{	//! \test zcc/decl.C99/Error_enum_multidef.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("'enum ");
+				INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+				INFORM("' already defined (C99 6.7.2.3p1)");
+				const enum_def* const tmp2 = types.get_enum_def(tmp);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				// now it's gone
+				src.DeleteNSlotsAt<0>(1,i);
+				continue;
+				};
+			// enum-specifier doesn't have a specific declaration mode
+			//! \test zcc/decl.C99/Pass_enum_def.h
+			const type_system::type_index tmp2 = types.register_enum_def(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			assert(types.get_id_enum(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp2,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+				{
+				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+				return;
+				}
+			}
+		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
+			{	// enum-specifier doesn't have a specific declaration mode
+				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
+			const type_system::type_index tmp = types.register_enum_def("<unknown>",src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp,NULL,false,C99_echo_reserved_keyword,C99_intlike_literal_to_VM,C99_CondenseParseTree,C99_EvalParseTree))
+				{
+				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+				return;
+				}
+			}
+
+		if (	1<src.size<0>()-i
+			&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
+			{	// is_C99_named_specifier(src.data<0>()[i],"enum") will cause an error later, in variable parsing
+			if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_union.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous union declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_struct.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous struct declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+/*			else if (is_C99_named_specifier(src.data<0>()[i],"union"))
+				{	// forward-declaration already handled
+				} */
+/*			else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
+				{	// forward-declaration already handled
+				}	*/
+/*			else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
+				{	// forward-declaration already handled
+				} */
+/*			else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
+				{	// forward-declaration already handled
+				}; */
+			};
+		// general declaration scanner 
+		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
+		// intercept declarations as follows
+		// * storage-class specifiers
+		// ** C: extern static auto register
+		// ** C: taking address of a register-qualified var is an error; not so for C++ (just downgrades register to auto implicitly)
+		// * typedef (pretty much a fake storage-class specifier)
+		// * function specifiers
+		// ** C: inline
+		// * cv-qualification
+		// ** C: const volatile restrict (but pointer type required for restrict)
+		// * atomic types have already been parsed, we need to catch the others
+		{
+		C99_decl_specifier_scanner declFind(types);
+		size_t decl_count = src.get_span<0>(i,declFind);
+		if (decl_count)
+			{
+			const bool coherent_storage_specifiers = declFind.analyze_flags_global(src,i,decl_count);
+			if (src.size<0>()-i<=decl_count)
+				{	// unterminated declaration
+					//! \test zcc/decl.C99/Error_extern_scope.h
+					//! \test zcc/decl.C99/Error_static_scope.h
+					//! \test zcc/decl.C99/Error_typedef_scope.h
+					//! \test zcc/decl.C99/Error_register_scope.h
+					//! \test zcc/decl.C99/Error_auto_scope.h
+				if (src.size<0>()>i) message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("declaration cut off by end of scope (C99 6.7p1)");
+				zcc_errors.inc_error();
+				// remove from parse
+				if (src.size<0>()>i)
+					src.DeleteNSlotsAt<0>(decl_count,i);
+				return;
+				};
+			if (robust_token_is_char<';'>(src.data<0>()[i+decl_count]))
+				{	// C99 7p2 error: must declare something
+					//! \test zcc/decl.C99/Error_extern_semicolon.h
+					//! \test zcc/decl.C99/Error_static_semicolon.h
+					//! \test zcc/decl.C99/Error_typedef_semicolon.h
+					//! \test zcc/decl.C99/Error_register_semicolon.h
+					//! \test zcc/decl.C99/Error_auto_semicolon.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("declaration must declare something (C99 6.7p2)");
+				zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(decl_count+1,i);
+				continue;
+				};
+			declFind.fixup_type();	// apply const, volatile
+
+			size_t decl_offset = 0;
+			bool have_we_parsed_yet = false;
+			do	{
+				type_spec bootstrap;
+				bootstrap.clear();
+				declFind.value_copy_type(bootstrap);
+				parse_tree* initdecl_identifier = NULL;
+				size_t initdecl_span = C99_init_declarator_scanner(src,i+decl_count+decl_offset,bootstrap,initdecl_identifier);
+				assert(0<initdecl_span || !initdecl_identifier);
+				if (0==initdecl_span)
+					{	// no declarator where expected
+					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("declarator missing (C99 6.7p1)");
+					zcc_errors.inc_error();
+					// find the next semicolon
+					const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
+					if (have_we_parsed_yet)
+						src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
+					else
+						src.DeleteNSlotsAt<0>((j-i)+(src.size<0>()>j),i);
+					break;
+					};
+				if (!initdecl_identifier)
+					{	// didn't find identifier when needed
+					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("declarator has no identifier to declare (C99 6.7p1)");
+					zcc_errors.inc_error();
+					// find the next semicolon, unless we have () immediately in which case we have nothing to look for
+					const bool unwind_to_compound_statement = is_naked_parentheses_pair(src.data<0>()[i+decl_count+decl_offset]);
+					if (unwind_to_compound_statement)
+						{
+						assert(!have_we_parsed_yet);
+						src.DeleteNSlotsAt<0>(decl_count+decl_offset+initdecl_span,i);
+						}
+					else{
+						const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
+						if (have_we_parsed_yet)
+							src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
+						else
+							src.DeleteNSlotsAt<0>((j-i)+1,i);
+						}
+					break;
+					};
+				//! \todo analyze decl_specifiers for errors (now have full target type)
+				// something is being declared
+				have_we_parsed_yet = true;
+				if (coherent_storage_specifiers)
+					{
+					if (C99_CPP0X_DECLSPEC_TYPEDEF & declFind.get_flags())
+						{	// typedef
+						register_token<0>(*initdecl_identifier);
+						// verify that there is no prior definition
+						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(initdecl_identifier->index_tokens[0].token.first);
+						if (tmp)
+							{
+							if (bootstrap==tmp->first)
+								{	// warn if there is a prior, consistent definition
+									//! \test zcc/decl.C99/Warn_redeclare_typedef.h
+									//! \todo control this warning with an option --no-OAOO or --no-DRY
+								message_header(initdecl_identifier->index_tokens[0]);
+								INC_INFORM(WARN_STR);
+								INC_INFORM("redeclaring typedef ");
+								INFORM(initdecl_identifier->index_tokens[0].token.first);
+								INC_INFORM(tmp->second);
+								INC_INFORM(':');
+								INC_INFORM(tmp->third);
+								INFORM(": prior typedef");
+								if (bool_options[boolopt::warnings_are_errors])
+									zcc_errors.inc_error();
+								}
+							else{	// error if there is a prior, inconsistent definition
+									//! \test zcc/decl.C99/Error_redeclare_typedef.h
+								message_header(initdecl_identifier->index_tokens[0]);
+								INC_INFORM(ERR_STR);
+								INC_INFORM("redeclaring typedef ");
+								INFORM(initdecl_identifier->index_tokens[0].token.first);
+								INC_INFORM(tmp->second);
+								INC_INFORM(':');
+								INC_INFORM(tmp->third);
+								INFORM(": prior typedef");
+								zcc_errors.inc_error();
+								}	
+							// do not re-register if there is a prior definition
+							}
+						else{	// prepare to register this with types object
+							const type_system::enumerator_info* tmp2 = types.get_enumerator(initdecl_identifier->index_tokens[0].token.first);
+							if (tmp2)
+								{	//! \test zcc/decl.C99/Error_typedef_enum.h
+								message_header(src.data<0>()[i].index_tokens[0]);
+								INC_INFORM(ERR_STR);
+								INFORM("enumerator is already defined, conflicts with typedef (C99 6.7.2.2p3)");
+								INC_INFORM(tmp2->second.second.first);
+								INC_INFORM(":");
+								INC_INFORM(tmp2->second.second.second.first);
+								INFORM(": enumerator definition here");
+								zcc_errors.inc_error();
+								return;
+								}
+							types.set_typedef(initdecl_identifier->index_tokens[0].token.first,initdecl_identifier->index_tokens[0].src_filename,initdecl_identifier->index_tokens[0].logical_line.first,bootstrap);
+							}
+						}
+#if 0
+					else{	// something else
+						};
+#endif
+					}
+				decl_offset += initdecl_span;
+				if (src.size<0>()-(i+decl_count)<=decl_offset)
+					{	// unterminated declaration: error
+						//! \test zcc/decl.C99/Error_scope.h
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("declaration cut off by end of scope (C99 6.7p1)");
+					zcc_errors.inc_error();
+					return;
+					};
+				//! \todo function declarations can be self-terminating
+				// ;: done
+				if (robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset]))
+					{
+					src.c_array<0>()[i+decl_count+decl_offset].flags |= parse_tree::GOOD_LINE_BREAK;
+					++decl_offset;
+					break;
+					};
+				// ,: iterate
+				// anything else: error
+				if (!robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset]))
+					{
+					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("declaration disoriented by missing , (C99 6.7p1)");
+					// find the next semicolon
+					size_t j = i+decl_count+decl_offset;
+					while(!robust_token_is_char<';'>(src.data<0>()[j]) && src.size<0>()> ++j);
+					src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
+					continue;
+					}
+				++decl_offset;
+				}
+			while(src.size<0>()>(i+decl_count+decl_offset));
+			i += decl_count+decl_offset;
+			continue;
+			}
+		}
+		++i;
+		}
+}
+
+// relies on _fatal_code being noreturn to avoid risk of undefined return value
+static const char* text_from_keyword(const union_struct_decl& x)
+{
+	switch(x.keyword())
+	{
+	default: _fatal_code("invalid state",3); 
+	case union_struct_decl::decl_union: return "union ";
+	case union_struct_decl::decl_struct: return "struct ";
+	case union_struct_decl::decl_class: return "class ";
+	}				
+}
+
+// this needs to line up with the return type for type_spec::qualifier
+static void display_qualifier_text(unsigned char x)
+{
+	if (type_spec::_restrict & x) INC_INFORM("restrict ");
+	if (type_spec::_const    & x) INC_INFORM("const ");
+	if (type_spec::_volatile & x) INC_INFORM("volatile ");
+}
+
+// language-specific printing overrides
+static void render_type(const type_spec& src,const type_system& types, const char* const name)
+{	// function types will need a different naming scheme
+	const char* const type_name = types.name(src.base_type_index);
+	// each ptr to array transition needs a parentheses pair to group properly
+	size_t i = src.pointer_power;
+	size_t start_ptr_scan = src.pointer_power;
+	while(0<i)
+		{
+		if (type_spec::_array & src.qualifier(i--)) continue;
+		if (0<i && (type_spec::_array & src.qualifier(i)) && !(type_spec::_array & src.qualifier(i+1)))
+			{
+			while(--start_ptr_scan>i)
+				{
+				if (type_spec::_array & src.qualifier(start_ptr_scan+1)) continue;
+				INC_INFORM('*');
+				display_qualifier_text(src.qualifier(start_ptr_scan+1));
+				};
+			INC_INFORM("(");
+			}
+		}
+		
+	display_qualifier_text(src.qualifier<0>());
+
+	if (types.get_enum_def(src.base_type_index))
+		INC_INFORM("enum ");
+	else{
+		zaimoni::POD_pair<const union_struct_decl*,const C_union_struct_def*> tmp;
+		tmp.first = types.get_structdecl(src.base_type_index);
+		if (tmp.first) INC_INFORM(text_from_keyword(*tmp.first));
+		else{
+			tmp.second = types.get_C_structdef(src.base_type_index);
+			if (tmp.second)
+				INC_INFORM(text_from_keyword(tmp.second->_decl));
+			}
+		}
+	INC_INFORM(type_name ? type_name : "<unresolved type>");
+
+	while(0<start_ptr_scan--)
+		{
+		if (type_spec::_array & src.qualifier(start_ptr_scan+1)) continue;
+		INC_INFORM('*');
+		display_qualifier_text(src.qualifier(start_ptr_scan+1));		
+		}
+
+	if (name && *name) INC_INFORM(name);
+		
+	i = 0;
+	while(i<src.pointer_power)
+		{
+		if (!(type_spec::_array & src.qualifier(++i)))
+			{
+			if (type_spec::_array & src.qualifier(i-1))
+				INC_INFORM(")");
+			continue;
+			}
+		INC_INFORM("[");
+		if (src.extent_vector[i-1]) INC_INFORM(src.extent_vector[i-1]); 
+		INC_INFORM("]");
+		}
+	
+}
+
+bool C99_hook_INC_INFORM(const parse_tree& src)
+{
+	if (PARSE_TYPE & src.flags)
+		{
+		assert(parse_tree::types);
+		render_type(src.type_code,*parse_tree::types,NULL);
+		if (is_C99_named_specifier_definitionlike(src))
+			INC_INFORM(*src.data<2>());
+		return true;
+		}
+	return false;
+}
+
+static bool is_CPP_namespace(const parse_tree& src)
+{
+	return	robust_token_is_string<9>(src.index_tokens[0].token,"namespace")
+		&&	src.index_tokens[1].token.first
+		&&	1==src.size<2>()
+#ifndef NDEBUG
+		&&	C_TESTFLAG_IDENTIFIER==src.index_tokens[1].flags
+#endif
+		&&	robust_token_is_char<'{'>(src.data<2>()[0].index_tokens[0].token)
+		&&	robust_token_is_char<'}'>(src.data<2>()[0].index_tokens[1].token);
+}
+
+bool CPP_hook_INC_INFORM(const parse_tree& src)
+{
+	if (PARSE_TYPE & src.flags)
+		{
+		assert(parse_tree::types);
+		render_type(src.type_code,*parse_tree::types,NULL);
+		if (is_C99_named_specifier_definitionlike(src))
+			INC_INFORM(*src.data<2>());
+		return true;
+		}
+	if (is_CPP_namespace(src) && robust_token_is_string<9>(src.index_tokens[1].token,"<unknown>"))
+		{	// make anonymous namespaces look like authentic source code
+		// first index token
+		INC_INFORM(src.index_tokens[0].token.first,src.index_tokens[0].token.second);
+		INC_INFORM(' ');
+		// postfix data
+		INC_INFORM(*src.data<2>());
+		if (src.flags & parse_tree::GOOD_LINE_BREAK) INC_INFORM('\n');
+		return true;
+		};
+	return false;
+}
+
+// handle namespaces or else
+//! \todo check that the fact all literals are already legal-form is used
+//! \throw std::bad_alloc
+static void CPP_ParseNamespace(parse_tree& src,type_system& types,const char* const active_namespace)
+{
+	//! \todo type-vectorize as part of the lexical-forward loop.  Need to handle
+	// * indirection depth n (already have this in practice)
+	// * const, volatile at each level of indirection 0..n
+	// * extent at each level of indirection 1..n (0 := raw-ptr, positive := array that can be bounds-checked for undefined behavior
+	// * top-level reference (check standards to see if reference-in-middle is illegal, never seen it in real source)
+	// * storage-qualifiers extern, static, register, mutable, thread_local
+	// * fake type-qualifier typedef
+	// note that typedefs and struct/union declarations/definitions create new types
+	// C++: note that class declarations/definitions create new types
+	// note that we need a sense of "current namespace" in C++
+	// ask GCC: struct/class/union/enum collides with each other (both C and C++), does not collide with namespace
+	// think we can handle this as "disallow conflicting definitions"
+	// should be able to disable this warning (it's about bloat)
+	if (src.empty<0>())
+		{	//! \test zcc/namespace.CPP/Warn_emptybody1.hpp
+			//! \test zcc/namespace.CPP/Warn_emptybody2.hpp
+			//! \todo -Wno-bloat turns off 
+		message_header(src.index_tokens[0]);
+		INC_INFORM(WARN_STR);
+		INFORM("namespace contains no declarations");
+		if (bool_options[boolopt::warnings_are_errors])
+			zcc_errors.inc_error();
+		return;
+		}
+
+	kleene_star<STATIC_SIZE(CPP0X_nontype_decl_specifier_list)+1,size_t (*)(const parse_tree&)> invariant_decl_scanner(CPP0X_type_or_invariant_decl_specifier);
+	size_t i = 0;
+	while(i<src.size<0>())
+		{
+		conserve_tokens(src.c_array<0>()[i]);
+		// C++ static assertion scanner
+		if (robust_token_is_string<13>(src.data<0>()[i],"static_assert"))
+			{	// static_assert ( constant-expression , string-literal ) ;
+			C99_CPP_handle_static_assertion(src,types,*CPlusPlusLexer->pp_support,i,"control expression for static assertion must be a constant convertible to bool (C++0X 7p4)",active_namespace);
+			continue;
+			};
+		// XXX C++ allows mixing definitions and declaring variables at the same time, but this is a bit unusual
+		// check naked declarations first; handle namespaces later
+		if (is_C99_named_specifier(src.data<0>()[i],"union"))
+			{
+CPP_union_specifier:
+			const type_system::type_index tmp = types.get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			if (tmp)
+				{
+				src.c_array<0>()[i].type_code.set_type(tmp);
+				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+				};
+			//! \bug [find citation] states that conflicting enum, struct, or class must error
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+			if (tmp2)
+				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array<0>()[i].type_code.set_type(tmp2);
+				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+				};
+			assert(tmp || tmp2);
+			if (   1<src.size<0>()-i
+				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// check for forward-declaration here
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Error_union_forward_def_const.hpp
+						//! \test decl.C99/Error_union_forward_def_const2.hpp
+						//! \test decl.C99/Error_union_forward_def_const3.hpp
+						//! \test decl.C99/Error_union_forward_def_const4.hpp
+						//! \test decl.C99/Error_union_forward_def_volatile.hpp
+						//! \test decl.C99/Error_union_forward_def_volatile2.hpp
+						//! \test decl.C99/Error_union_forward_def_volatile3.hpp
+						//! \test decl.C99/Error_union_forward_def_volatile4.hpp
+						//! \test decl.C99/Error_union_forward_def_const_volatile.hpp
+						//! \test decl.C99/Error_union_forward_def_const_volatile2.hpp
+						//! \test decl.C99/Error_union_forward_def_const_volatile3.hpp
+						//! \test decl.C99/Error_union_forward_def_const_volatile4.hpp
+						//! \test decl.C99/Error_union_forward_def_const_volatile5.hpp
+						//! \test decl.C99/Error_union_forward_def_const_volatile6.hpp
+						//! \test decl.C99/Error_union_forward_def_const_volatile7.hpp
+						//! \test decl.C99/Error_union_forward_def_const_volatile8.hpp
+						//! \test decl.C99/Error_union_forward_def_const_volatile9.hpp
+						//! \test decl.C99/Error_union_forward_def_const_volatile10.hpp
+						//! \test decl.C99/Error_union_forward_def_const_volatile11.hpp
+						//! \test decl.C99/Error_union_forward_def_const_volatile12.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
+					zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					}
+				if (tmp)
+					{	// but if already (forward-)declared then this is a no-op
+						// think this is common enough to not warrant OAOO/DRY treatment
+					//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+					// remove from parse
+					src.DeleteNSlotsAt<0>(2,i);
+					continue;					
+					};
+				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+				assert(tmp2);
+				i += 2;
+				continue;
+				}
+			else if (!tmp)
+				{	// used without at least forward-declaring
+					//! \bug needs test cases
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("used without at least forward-declaring");
+				zcc_errors.inc_error();
+				}
+			}
+		else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
+			{
+CPP_struct_specifier:				
+			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			if (tmp)
+				{
+				src.c_array<0>()[i].type_code.set_type(tmp);
+				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+				};
+			//! \bug [find citation] states that conflicting enum, struct, or class must error
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+			if (tmp2)
+				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array<0>()[i].type_code.set_type(tmp2);
+				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+				};
+			assert(tmp || tmp2);
+			if (   1<src.size<0>()-i
+				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// check for forward-declaration here
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Error_struct_forward_def_const.hpp
+						//! \test decl.C99/Error_struct_forward_def_const2.hpp
+						//! \test decl.C99/Error_struct_forward_def_const3.hpp
+						//! \test decl.C99/Error_struct_forward_def_const4.hpp
+						//! \test decl.C99/Error_struct_forward_def_volatile.hpp
+						//! \test decl.C99/Error_struct_forward_def_volatile2.hpp
+						//! \test decl.C99/Error_struct_forward_def_volatile3.hpp
+						//! \test decl.C99/Error_struct_forward_def_volatile4.hpp
+						//! \test decl.C99/Error_struct_forward_def_const_volatile.hpp
+						//! \test decl.C99/Error_struct_forward_def_const_volatile2.hpp
+						//! \test decl.C99/Error_struct_forward_def_const_volatile3.hpp
+						//! \test decl.C99/Error_struct_forward_def_const_volatile4.hpp
+						//! \test decl.C99/Error_struct_forward_def_const_volatile5.hpp
+						//! \test decl.C99/Error_struct_forward_def_const_volatile6.hpp
+						//! \test decl.C99/Error_struct_forward_def_const_volatile7.hpp
+						//! \test decl.C99/Error_struct_forward_def_const_volatile8.hpp
+						//! \test decl.C99/Error_struct_forward_def_const_volatile9.hpp
+						//! \test decl.C99/Error_struct_forward_def_const_volatile10.hpp
+						//! \test decl.C99/Error_struct_forward_def_const_volatile11.hpp
+						//! \test decl.C99/Error_struct_forward_def_const_volatile12.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
+					zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					}
+				if (tmp)
+					{	// but if already (forward-)declared then this is a no-op
+						// think this is common enough to not warrant OAOO/DRY treatment
+					//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+					// remove from parse
+					src.DeleteNSlotsAt<0>(2,i);
+					continue;					
+					}
+				// forward-declare
+				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+				assert(tmp2);
+				i += 2;
+				continue;
+				}
+			else if (!tmp)
+				{	// used without at least forward-declaring
+					//! \bug needs test cases
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("used without at least forward-declaring");
+				zcc_errors.inc_error();
+				}
+			}
+		else if (is_C99_named_specifier(src.data<0>()[i],"class"))
+			{
+CPP_class_specifier:
+			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			if (tmp)
+				{
+				src.c_array<0>()[i].type_code.set_type(tmp);
+				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+				};
+			//! \bug [find citation] states that conflicting enum, struct, or class must error
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+			if (tmp2)
+				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array<0>()[i].type_code.set_type(tmp2);
+				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+				};
+			assert(tmp || tmp2);
+			if (   1<src.size<0>()-i
+				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// check for forward-declaration here
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Error_class_forward_def_const.hpp
+						//! \test decl.C99/Error_class_forward_def_const2.hpp
+						//! \test decl.C99/Error_class_forward_def_const3.hpp
+						//! \test decl.C99/Error_class_forward_def_const4.hpp
+						//! \test decl.C99/Error_class_forward_def_volatile.hpp
+						//! \test decl.C99/Error_class_forward_def_volatile2.hpp
+						//! \test decl.C99/Error_class_forward_def_volatile3.hpp
+						//! \test decl.C99/Error_class_forward_def_volatile4.hpp
+						//! \test decl.C99/Error_class_forward_def_const_volatile.hpp
+						//! \test decl.C99/Error_class_forward_def_const_volatile2.hpp
+						//! \test decl.C99/Error_class_forward_def_const_volatile3.hpp
+						//! \test decl.C99/Error_class_forward_def_const_volatile4.hpp
+						//! \test decl.C99/Error_class_forward_def_const_volatile5.hpp
+						//! \test decl.C99/Error_class_forward_def_const_volatile6.hpp
+						//! \test decl.C99/Error_class_forward_def_const_volatile7.hpp
+						//! \test decl.C99/Error_class_forward_def_const_volatile8.hpp
+						//! \test decl.C99/Error_class_forward_def_const_volatile9.hpp
+						//! \test decl.C99/Error_class_forward_def_const_volatile10.hpp
+						//! \test decl.C99/Error_class_forward_def_const_volatile11.hpp
+						//! \test decl.C99/Error_class_forward_def_const_volatile12.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
+					zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					}
+				if (tmp)
+					{	// but if already (forward-)declared then this is a no-op
+						// think this is common enough to not warrant OAOO/DRY treatment
+					//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+					// remove from parse
+					src.DeleteNSlotsAt<0>(2,i);
+					continue;					
+					}
+				// forward-declare
+				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+				assert(tmp2);
+				i += 2;
+				continue;
+				}
+			else if (!tmp)
+				{	// used without at least forward-declaring
+					//! \bug needs test cases
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("used without at least forward-declaring");
+				zcc_errors.inc_error();
+				}
+			}
+		else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
+			{	// can only define once
+			const type_system::type_index tmp = types.get_id_union_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			if (tmp)
+				{
+				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				if (fatal_def)
+					{	//! \test zcc/decl.C99/Error_union_multidef.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'union ");
+					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INFORM("' already defined (C++98 3.2p1)");
+					message_header(*fatal_def);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					// reduce to named-specifier
+					src.c_array<0>()[i].DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(src.data<0>()[i],"union"));
+					goto CPP_union_specifier;
+					}					
+				src.c_array<0>()[i].type_code.set_type(tmp);
+				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+				};
+			//! \bug [find citation] states that conflicting enum, struct, or class must error
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_union);
+			if (tmp2)
+				{	//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+				assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array<0>()[i].type_code.set_type(tmp2);
+				src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+				};
+			assert(tmp || tmp2);
+			// parse the union and upgrade it to a full definition
+			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
+			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			assert(tmp3);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record field structure, etc.
+			types.upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(types.get_C_structdef(vr_tmp));
+			if (   1<src.size<0>()-i
+				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// check for forward-declaration here
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Error_union_def_const.hpp
+						//! \test decl.C99/Error_union_def_const2.hpp
+						//! \test decl.C99/Error_union_def_volatile.hpp
+						//! \test decl.C99/Error_union_def_volatile2.hpp
+						//! \test decl.C99/Error_union_def_const_volatile.hpp
+						//! \test decl.C99/Error_union_def_const_volatile2.hpp
+						//! \test decl.C99/Error_union_def_const_volatile3.hpp
+						//! \test decl.C99/Error_union_def_const_volatile4.hpp
+						//! \test decl.C99/Error_union_def_const_volatile5.hpp
+						//! \test decl.C99/Error_union_def_const_volatile6.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
+					zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					}
+				// accept definition
+				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+				i += 2;
+				continue;
+				}
+			}
+		else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
+			{	// can only define once
+			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			if (tmp)
+				{
+				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				if (fatal_def)
+					{	//! \test zcc/decl.C99/Error_struct_multidef.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'struct ");
+					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INFORM("' already defined (C++98 3.2p1)");
+					message_header(*fatal_def);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					// reduce to named-specifier
+					src.c_array<0>()[i].DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(src.data<0>()[i],"struct"));
+					goto CPP_struct_specifier;
+					}					
+				src.c_array<0>()[i].type_code.set_type(tmp);
+				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+				};
+			//! \bug [find citation] states that conflicting enum, struct, or class must error
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_struct);
+			if (tmp2)
+				{	//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array<0>()[i].type_code.set_type(tmp2);
+				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+				};
+			assert(tmp || tmp2);
+			// parse the union and upgrade it to a full definition
+			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
+			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			assert(tmp3);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record field structure, etc.
+			types.upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(types.get_C_structdef(vr_tmp));
+			if (   1<src.size<0>()-i
+				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// check for forward-declaration here
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Error_struct_def_const.hpp
+						//! \test decl.C99/Error_struct_def_const2.hpp
+						//! \test decl.C99/Error_struct_def_volatile.hpp
+						//! \test decl.C99/Error_struct_def_volatile2.hpp
+						//! \test decl.C99/Error_struct_def_const_volatile.hpp
+						//! \test decl.C99/Error_struct_def_const_volatile2.hpp
+						//! \test decl.C99/Error_struct_def_const_volatile3.hpp
+						//! \test decl.C99/Error_struct_def_const_volatile4.hpp
+						//! \test decl.C99/Error_struct_def_const_volatile5.hpp
+						//! \test decl.C99/Error_struct_def_const_volatile6.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
+					zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					}
+				// accept definition
+				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
+				i += 2;
+				continue;
+				}
+			}
+		else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
+			{	// can only define once
+			const type_system::type_index tmp = types.get_id_struct_class_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+			if (tmp)
+				{
+				const C_union_struct_def* const fatal_def = types.get_C_structdef(tmp);
+				if (fatal_def)
+					{	//! \test zcc/decl.C99/Error_class_multidef.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'class ");
+					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INFORM("' already defined (C++98 3.2p1)");
+					message_header(*fatal_def);
+					INFORM("prior definition here");
+					zcc_errors.inc_error();
+					// reduce to named-specifier
+					src.c_array<0>()[i].DeleteIdx<2>(0);
+					assert(is_C99_named_specifier(src.data<0>()[i],"class"));
+					goto CPP_class_specifier;
+					}					
+				src.c_array<0>()[i].type_code.set_type(tmp);
+				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+				};
+			//! \bug [find citation] states that conflicting enum, struct, or class must error
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = tmp ? 0 : types.register_structdecl_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,union_struct_decl::decl_class);
+			if (tmp2)
+				{	//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+				assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+				assert(types.get_structdecl(tmp2));
+				src.c_array<0>()[i].type_code.set_type(tmp2);
+				src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+				_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+				};
+			assert(tmp || tmp2);
+			// parse the union and upgrade it to a full definition
+			const type_system::type_index vr_tmp = tmp ? tmp : tmp2;
+			const union_struct_decl* tmp3 = types.get_structdecl(vr_tmp);
+			assert(tmp3);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record field structure, etc.
+			types.upgrade_decl_to_def(vr_tmp,tmp4);
+			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==vr_tmp);
+			assert(types.get_C_structdef(vr_tmp));
+			if (   1<src.size<0>()-i
+				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// check for forward-declaration here
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Error_class_def_const.hpp
+						//! \test decl.C99/Error_class_def_const2.hpp
+						//! \test decl.C99/Error_class_def_volatile.hpp
+						//! \test decl.C99/Error_class_def_volatile2.hpp
+						//! \test decl.C99/Error_class_def_const_volatile.hpp
+						//! \test decl.C99/Error_class_def_const_volatile2.hpp
+						//! \test decl.C99/Error_class_def_const_volatile3.hpp
+						//! \test decl.C99/Error_class_def_const_volatile4.hpp
+						//! \test decl.C99/Error_class_def_const_volatile5.hpp
+						//! \test decl.C99/Error_class_def_const_volatile6.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
+					zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					}
+				// accept definition
+				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
+				i += 2;
+				continue;
+				}
+			}
+		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
+		//! \todo actually, we can try forward-declare both scoped enums and enum-based enums (C++0X 7.2p3, these have enough size information); but other parts of the standard get in the way
+		else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
+			{
+			if (!(src.c_array<0>()[i].flags & parse_tree::INVALID))
+				{
+				type_system::type_index tmp = types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace);
+				src.c_array<0>()[i].type_code.set_type(tmp);	// C++: enums are own type
+				if (!tmp)
+					{	// this belongs elsewhere
+						//! \test zcc/decl.C99/Error_enum_undef.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("'enum ");
+					INC_INFORM(src.data<0>()[i].index_tokens[1].token.first,src.data<0>()[i].index_tokens[1].token.second);
+					INFORM("' must refer to completely defined enum (C++98/C++0X 3.1p2, C++98 7.1.5.3p2-4/C++0X 7.1.6.3p2)");
+					zcc_errors.inc_error();
+					src.c_array<0>()[i].flags |= parse_tree::INVALID;
+					}
+				}
+			//! \todo we should reject plain enum test; anyway (no-variable definition, not a forward-declare exemption)
+			}
+		else if (is_C99_named_specifier_definition(src.data<0>()[i],"enum"))
+			{	// can only define once
+			char* namespace_name = active_namespace ? type_system::namespace_concatenate(src.data<0>()[i].index_tokens[1].token.first,active_namespace,"::") : NULL;
+			const char* fullname = namespace_name ? namespace_name : src.data<0>()[i].index_tokens[1].token.first;
+			type_system::type_index tmp = types.get_id_enum(fullname);
+			if (tmp)
+				{	//! \test zcc/decl.C99/Error_enum_multidef.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("'enum ");
+				INC_INFORM(fullname);
+				free(namespace_name);
+				INFORM("' already defined (C++98 3.2p1)");
+				const enum_def* const tmp2 = types.get_enum_def(tmp);
+				assert(tmp2);
+				message_header(*tmp2);
+				INFORM("prior definition here");
+				zcc_errors.inc_error();
+				// now it's gone
+				src.DeleteNSlotsAt<0>(1,i);
+				continue;
+				};
+			free(namespace_name);
+			//! \test zcc/decl.C99/Pass_enum_def.hpp
+			// enum-specifier doesn't have a specific declaration mode
+			const type_system::type_index tmp2 = types.register_enum_def_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			assert(types.get_id_enum_CPP(src.data<0>()[i].index_tokens[1].token.first,active_namespace)==tmp2);
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp2,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+				{
+				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+				return;
+				}
+			}
+		else if (is_C99_anonymous_specifier(src.data<0>()[i],"enum"))
+			{	// enum-specifier doesn't have a specific declaration mode
+				//! \test zcc/decl.C99/Pass_anonymous_enum_def.h
+			const type_system::type_index tmp = types.register_enum_def_CPP("<unknown>",active_namespace,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
+			if (!record_enum_values(*src.c_array<0>()[i].c_array<2>(),types,tmp,active_namespace,true,CPP_echo_reserved_keyword,CPP_intlike_literal_to_VM,CPP_CondenseParseTree,CPP_EvalParseTree))
+				{
+				INFORM("enumeration not fully parsed: stopping to prevent spurious errors");
+				return;
+				}
+			}
+
+		if (	1<src.size<0>()-i
+			&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
+			{	// is_C99_named_specifier(src.data<0>()[i],"enum") will cause an error later, in variable parsing
+			if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous union declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous struct declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			else if (is_C99_anonymous_specifier(src.data<0>()[i],"class"))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous class declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+/*			else if (is_C99_named_specifier(src.data<0>()[i],"union"))
+				{	// forward-declaration already handled
+				}	*/
+/*			else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
+				{	// forward-declaration already handled
+				}	*/
+/*			else if (is_C99_named_specifier(src.data<0>()[i],"class"))
+				{	// forward-declaration already handled
+				} */
+/*			else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
+				{	// forward-declaration already handled
+				}	*/
+/*			else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
+				{	// forward-declaration already handled
+				} */
+/*			else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
+				{	// forward-declaration already handled
+				} */
+			};
+		// namespace scanner
+		// need some scheme to handle unnamed namespaces (probably alphabetical counter after something illegal so unmatchable)
+		// C++0X has inline namespaces; ignore these for now (well, maybe not: consuming the inline will prevent problems)
+		// C++0X has more complicated using namespace directives: ignore these for now
+		// basic namespace; C++98 and C++0X agree on what this is
+		if (robust_token_is_string<9>(src.data<0>()[i],"namespace"))
+			{	// fail if: end of token stream
+				// fail if: next token is a type
+				// accept if: next token is {} (unnamed namespace)
+				// accept if: next token is an identifier, and the token after that is {} (typical namespace)
+				// fail otherwise
+			if (1>=src.size<0>()-i)
+				{	//! \test zcc/namespace.CPP/Error_premature1.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("namespace declaration cut off by end of scope");
+				zcc_errors.inc_error();
+				src.DeleteIdx<0>(i);
+				break;
+				};
+			if (	robust_token_is_char<'{'>(src.data<0>()[i+1].index_tokens[0].token)
+				&&	robust_token_is_char<'}'>(src.data<0>()[i+1].index_tokens[1].token))
+				{	//! handle unnamed namespace
+					//! \test zcc/namespace.CPP/Warn_emptybody2.hpp
+					// regardless of official linkage, entities in anonymous namespaces aren't very accessible outside of the current translation unit;
+					// any reasonable linker thinks they have static linkage
+				src.c_array<0>()[i].resize<2>(1);
+				src.c_array<0>()[i+1].OverwriteInto(src.c_array<0>()[i].c_array<2>()[0]);
+				src.DeleteIdx<0>(i+1);
+
+				// anonymous namespace names are technically illegal
+				// GCC uses <unknown> and handles uniqueness at link time
+				src.c_array<0>()[i].grab_index_token_from_str_literal<1>("<unknown>",C_TESTFLAG_IDENTIFIER);	// pretend it's an identifier
+				src.c_array<0>()[i].grab_index_token_location_from<1,0>(src.data<0>()[i].data<2>()[0]);	// inject it at where the namespace body starts
+				src.c_array<0>()[i].flags |= parse_tree::GOOD_LINE_BREAK;
+				assert(is_CPP_namespace(src.data<0>()[i]));
+
+				if (active_namespace)
+					{
+					char* new_active_namespace = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(strlen(active_namespace)+11 /*sizeof("::<unknown>")-1*/));
+					strcpy(new_active_namespace,active_namespace);
+					strcat(new_active_namespace,"::<unknown>");
+					strcat(new_active_namespace,"");
+					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],types,new_active_namespace);
+					free(new_active_namespace);
+					}
+				else{
+					CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],types,"<unknown>");
+					}
+				++i;
+				continue;
+				}
+			const bool namespace_has_body = (	3<=src.size<0>()-i
+											&&	robust_token_is_char<'{'>(src.data<0>()[i+2].index_tokens[0].token)
+											&&	robust_token_is_char<'}'>(src.data<0>()[i+2].index_tokens[1].token));
+			// next token must be an atomic identifier
+			// already-parsed primary types are no good, neither are reserved keywords
+			if (	!src.data<0>()[i+1].is_atomic()
+				|| 	!(C_TESTFLAG_IDENTIFIER & src.data<0>()[i+1].index_tokens[0].flags)
+				||	(PARSE_TYPE & src.data<0>()[i+1].flags)
+				||	CPP_echo_reserved_keyword(src.data<0>()[i+1].index_tokens[0].token.first,src.data<0>()[i+1].index_tokens[0].token.second))
+				{	//! \test zcc/namespace.CPP/Error_badname1.hpp
+					//! \test zcc/namespace.CPP/Error_badname2.hpp
+					//! \test zcc/namespace.CPP/Error_badname3.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("named namespace declaration must use non-reserved identifier (C++98 7.3.1p1, 7.3.2p1)");
+				zcc_errors.inc_error();
+				src.DeleteNSlotsAt<0>(2+namespace_has_body,i);
+				continue;
+				};
+			if (!namespace_has_body)
+				{	//! \test zcc/namespace.CPP/Error_premature2.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("'namespace ");
+				INC_INFORM(src.data<0>()[i+1]);
+				INFORM("' definition needs a body (C++98 7.3.1p1)");
+				zcc_errors.inc_error();
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				};
+			//! \test zcc/namespace.CPP/Warn_emptybody1.hpp
+			// process namespace
+			// namespace name: postfix arg 1
+			// namespace definition body: postfix arg 2
+			// the namespace name is likely to be reused: atomic string target
+			register_token<0>(src.c_array<0>()[i+1]);
+			src.c_array<0>()[i].resize<2>(1);
+			src.c_array<0>()[i].grab_index_token_from<1,0>(src.c_array<0>()[i+1]);
+			src.c_array<0>()[i].grab_index_token_location_from<1,0>(src.data<0>()[i+1]);	// inject it at where the namespace body starts
+			src.c_array<0>()[i+2].OverwriteInto(src.c_array<0>()[i].c_array<2>()[0]);
+			src.DeleteNSlotsAt<0>(2,i+1);
+			src.c_array<0>()[i].flags |= parse_tree::GOOD_LINE_BREAK;
+			assert(is_CPP_namespace(src.data<0>()[i]));
+			// handle named namespace
+			if (NULL==active_namespace)
+				{	// global
+					//! \todo expand namespace aliases
+				CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],types,src.c_array<0>()[i].index_tokens[1].token.first);
+				}
+			else{	// nested
+					//! \todo expand namespace aliases
+				char* const new_active_namespace = type_system::namespace_concatenate(src.c_array<0>()[i].index_tokens[1].token.first,active_namespace,"::");
+				CPP_ParseNamespace(src.c_array<0>()[i].c_array<2>()[0],types,new_active_namespace);
+				free(new_active_namespace);
+				}
+			++i;
+			continue;
+			};
+		// C++0X also has inline namespaces; all anonymous namespaces are already inline
+		// general declaration scanner (have to catch C++0X inline namespaces first when those come up)
+		// ideally would cope with both C++98 and C++0X
+		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
+		// intercept declarations as follows
+		// * storage-class specifiers
+		// ** C++98: auto register static extern mutable [class-data only]
+		// ** C++0x: register static thread_local extern mutable [class-data only]
+		// ** C: taking address of a register-qualified var is an error; not so for C++ (just downgrades register to auto implicitly)
+		// * typedef (pretty much a fake storage-class specifier)
+		// * C++0X: constexpr
+		// * function specifiers
+		// ** C++: inline virtual [nonstatic class-member-function only] explicit [constructors only]
+		// * C++: friend (inside class declaration only)
+		// * cv-qualification
+		// ** C++: const volatile
+		// * atomic types have already been parsed, we need to catch the others
+		// * C++0x: auto is a possible type!
+		{
+		CPP0X_decl_specifier_scanner declFind(types,active_namespace);
+		size_t decl_count = src.destructive_get_span<0>(i,declFind);
+		if (decl_count)
+			{
+			const bool coherent_storage_specifiers = declFind.analyze_flags_global(src,i,decl_count);
+			if (src.size<0>()-i<=decl_count)
+				{	// unterminated declaration
+					//! \test zcc/decl.C99/Error_extern_scope.hpp
+					//! \test zcc/decl.C99/Error_static_scope.hpp
+					//! \test zcc/decl.C99/Error_typedef_scope.hpp
+					//! \test zcc/decl.C99/Error_register_scope.hpp
+					//! \test zcc/decl.C99/Error_mutable_scope.hpp
+					//! \test zcc/decl.C99/Error_virtual_scope.hpp
+					//! \test zcc/decl.C99/Error_friend_scope.hpp
+					//! \test zcc/decl.C99/Error_explicit_scope.hpp
+				if (src.size<0>()>i) message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("declaration cut off by end of scope (C++98 7p1)");
+				zcc_errors.inc_error();
+				// remove from parse
+				if (src.size<0>()>i)
+					src.DeleteNSlotsAt<0>(decl_count,i);
+				return;
+				};
+			if (robust_token_is_char<';'>(src.data<0>()[i+decl_count]))
+				{	// must declare something
+					//! \test zcc/decl.C99/Error_extern_semicolon.hpp
+					//! \test zcc/decl.C99/Error_static_semicolon.hpp
+					//! \test zcc/decl.C99/Error_typedef_semicolon.hpp
+					//! \test zcc/decl.C99/Error_register_semicolon.hpp
+					//! \test zcc/decl.C99/Error_mutable_semicolon.hpp
+					//! \test zcc/decl.C99/Error_virtual_semicolon.hpp
+					//! \test zcc/decl.C99/Error_friend_semicolon.hpp
+					//! \test zcc/decl.C99/Error_explicit_semicolon.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("declaration must declare something (C++98 7p4)");
+				zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(decl_count+1,i);
+				continue;
+				};
+			declFind.fixup_type();	// apply const, volatile
+
+			size_t decl_offset = 0;
+			bool have_we_parsed_yet = false;
+			do	{
+				type_spec bootstrap;
+				bootstrap.clear();
+				declFind.value_copy_type(bootstrap);
+				parse_tree* initdecl_identifier = NULL;
+				size_t initdecl_span = CPP_init_declarator_scanner(src,i+decl_count+decl_offset,bootstrap,initdecl_identifier);
+				assert(0<initdecl_span || !initdecl_identifier);
+				if (0==initdecl_span)
+					{	// no declarator where expected
+					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("declarator missing (C++98 7p1)");
+					zcc_errors.inc_error();
+					// find the next semicolon
+					const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
+					if (have_we_parsed_yet)
+						src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
+					else
+						src.DeleteNSlotsAt<0>((j-i)+(src.size<0>()>j),i);
+					break;
+					};
+				if (!initdecl_identifier)
+					{	// didn't find identifier when needed
+					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("declarator has no name to declare (C++98 7p1)");
+					zcc_errors.inc_error();
+					// find the next semicolon, unless we have () immediately in which case we have nothing to look for
+					const bool unwind_to_compound_statement = is_naked_parentheses_pair(src.data<0>()[i+decl_count+decl_offset]);
+					if (unwind_to_compound_statement)
+						{
+						assert(!have_we_parsed_yet);
+						src.DeleteNSlotsAt<0>(decl_count+decl_offset+initdecl_span,i);
+						}
+					else{
+						const size_t j = i+decl_count+decl_offset+span_to_semicolon(src.data<0>()+i+decl_count+decl_offset,src.end<0>());
+						if (have_we_parsed_yet)
+							src.DeleteNSlotsAt<0>(j-(i+decl_count+decl_offset),i+decl_count+decl_offset-1);
+						else
+							src.DeleteNSlotsAt<0>((j-i)+1,i);
+						}
+					break;
+					};
+				//! \todo analyze decl_specifiers for errors (now have full target type)
+				// something is being declared
+				have_we_parsed_yet = true;
+				if (coherent_storage_specifiers)
+					{
+					if (C99_CPP0X_DECLSPEC_TYPEDEF & declFind.get_flags())
+						{	// typedef
+						register_token<0>(*initdecl_identifier);
+						char* namespace_name = active_namespace ? type_system::namespace_concatenate(initdecl_identifier->index_tokens[0].token.first,active_namespace,"::") : NULL;
+						const char* fullname = namespace_name ? namespace_name : initdecl_identifier->index_tokens[0].token.first;
+						// We could run an is_string_registered check to try to conserve RAM, but in this case conserving RAM 
+						// doesn't actually reduce maximum RAM loading before the types.set_typedef_CPP call.
+
+						// verify that there is no prior definition
+						// we're fine redeclaring at a different level, so do not use full C++ typedef lookup
+						const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef(fullname);					
+						if (tmp)
+							{
+							if (bootstrap==tmp->first)
+								{	// warn if there is a prior, consistent definition
+									//! \test zcc/decl.C99/Warn_redeclare_typedef.hpp
+									//! \todo control this warning with an option --no-OAOO or --no-DRY
+								message_header(initdecl_identifier->index_tokens[0]);
+								INC_INFORM(WARN_STR);
+								INC_INFORM("redeclaring typedef ");
+								INFORM(fullname);
+								INC_INFORM(tmp->second);
+								INC_INFORM(':');
+								INC_INFORM(tmp->third);
+								INFORM(": prior typedef");
+								if (bool_options[boolopt::warnings_are_errors])
+									zcc_errors.inc_error();
+								}
+							else{	// error if there is a prior, inconsistent definition
+									//! \test zcc/decl.C99/Error_redeclare_typedef.hpp
+								message_header(initdecl_identifier->index_tokens[0]);
+								INC_INFORM(ERR_STR);
+								INC_INFORM("redeclaring typedef ");
+								INFORM(fullname);
+								INC_INFORM(tmp->second);
+								INC_INFORM(':');
+								INC_INFORM(tmp->third);
+								INFORM(": prior typedef");
+								zcc_errors.inc_error();
+								}
+							// do not re-register if there is a prior definition
+							free(namespace_name);
+							}
+						else{	// register this with types object
+							free(namespace_name);
+							const type_system::enumerator_info* tmp2 = types.get_enumerator_CPP(initdecl_identifier->index_tokens[0].token.first,active_namespace);
+							if (tmp2)
+								{	//! \test zcc/decl.C99/Error_typedef_enum.hpp
+									//! \test zcc/decl.C99/Error_typedef_enum2.hpp
+								message_header(src.data<0>()[i].index_tokens[0]);
+								INC_INFORM(ERR_STR);
+								INFORM("enumerator is already defined, conflicts with typedef (C++98 3.2)");
+								INC_INFORM(tmp2->second.second.first);
+								INC_INFORM(":");
+								INC_INFORM(tmp2->second.second.second.first);
+								INFORM(": enumerator definition here");
+								zcc_errors.inc_error();
+								return;
+								}							
+							types.set_typedef_CPP(initdecl_identifier->index_tokens[0].token.first,active_namespace,initdecl_identifier->index_tokens[0].src_filename,initdecl_identifier->index_tokens[0].logical_line.first,bootstrap);
+							}
+						}
+#if 0
+					else{	// something else
+						};
+#endif
+					};
+				decl_offset += initdecl_span;
+				if (src.size<0>()-(i+decl_count)<=decl_offset)
+					{	// unterminated declaration: error
+						//! \test zcc/decl.C99/Error_scope.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("declaration cut off by end of scope (C++98 7p1)");
+					zcc_errors.inc_error();
+					return;
+					};
+				//! \todo function declarations can be self-terminating
+				// ;: done
+				if (robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset]))
+					{
+					src.c_array<0>()[i+decl_count+decl_offset].flags |= parse_tree::GOOD_LINE_BREAK;
+					++decl_offset;
+					break;
+					};
+				// ,: iterate
+				// anything else: error
+				if (!robust_token_is_char<';'>(src.data<0>()[i+decl_count+decl_offset]))
+					{
+					message_header(src.data<0>()[i+decl_count+decl_offset].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("declaration disoriented by missing , (C++98 7p1)");
+					// find the next semicolon
+					const size_t span = span_to_semicolon(src.begin<0>()+(i+decl_count+decl_offset),src.end<0>());
+					src.DeleteNSlotsAt<0>(span,i+decl_count+decl_offset);
+					continue;
+					}
+				++decl_offset;
+				}
+			while(src.size<0>()>(i+decl_count+decl_offset));
+			i += decl_count+decl_offset;
+			continue;
+			}
+		}
+		++i;
+		}
+}
+
+//! \throw std::bad_alloc
+static void CPP_ContextParse(parse_tree& src,type_system& types)
+{
+	CPP_ParseNamespace(src,types,NULL);
+}
+
+PP_auxfunc C99_aux
+ = 	{
+	LengthOfCSystemHeader,
+	CPurePreprocessingOperatorPunctuationCode,
+	CPurePreprocessingOperatorPunctuationFlags,
+	C_like_BalancingCheck,
+	C99_ControlExpressionContextFreeErrorCount,
+	C99_CondenseParseTree,
+	C99_EvalParseTree,
+	C99_PPHackTree,
+	ConcatenateCStringLiterals,
+	C99_bad_syntax_tokenized,
+	C99_echo_reserved_keyword,
+	C99_echo_reserved_symbol,
+	C99_ContextFreeParse,
+	C99_ContextParse,
+	C99_locate_expressions,
+	C99_literal_converts_to_bool
+	};
+
+PP_auxfunc CPlusPlus_aux
+ = 	{
+	LengthOfCPPSystemHeader,
+	CPPPurePreprocessingOperatorPunctuationCode,
+	CPPPurePreprocessingOperatorPunctuationFlags,
+	C_like_BalancingCheck,
+	CPP_ControlExpressionContextFreeErrorCount,
+	CPP_CondenseParseTree,
+	CPP_EvalParseTree,
+	CPP_PPHackTree,
+	ConcatenateCStringLiterals,
+	CPP_bad_syntax_tokenized,
+	CPP_echo_reserved_keyword,
+	CPP_echo_reserved_symbol,
+	CPP_ContextFreeParse,
+	CPP_ContextParse,
+	CPP_locate_expressions,
+	CPP_literal_converts_to_bool
+	};
+
+#if 0
+// this is causing crashes post-exit
+static void clear_lexer_defs(void)
+{
+	delete CLexer;
+	delete CPlusPlusLexer;
+}
+#endif
+
+void InitializeCLexerDefs(const virtual_machine::CPUInfo& target)
+{
+	// main code
+	target_machine = &target;
+	CLexer = new LangConf(	"//",			// C99, should be NULL for C90, C94
+							"/*",
+							"*/",
+							&C_IsLegalSourceChar,
+							&IsCIdentifierChar,
+							NULL,
+							NULL,
+							LengthOfEscapedCString,
+							EscapeCString,
+							LengthOfUnescapedCString,
+							UnescapeCString,
+							"'\"",
+							C_WHITESPACE,	// prepare LangConf change to test for all-but-first WS character
+							C_ATOMIC_CHAR,
+							valid_keyword+C_KEYWORD_NONSTRICT_LB,C_KEYWORD_STRICT_UB-C_KEYWORD_NONSTRICT_LB,
+							&C99_aux,
+							0,2,
+							'\\','\\',true,true);
+	CPlusPlusLexer = new LangConf(	"//",
+									"/*",
+									"*/",
+									&C_IsLegalSourceChar,
+									&IsCIdentifierChar,
+									NULL,
+									NULL,
+									LengthOfEscapedCString,		// think we're fine for C++98
+									EscapeCString,
+									LengthOfUnescapedCString,
+									UnescapeCString,
+									"'\"",
+									C_WHITESPACE,	// prepare LangConf change to test for all-but-first WS character
+									C_ATOMIC_CHAR,
+									valid_keyword+CPP_KEYWORD_NONSTRICT_LB,CPP_KEYWORD_STRICT_UB-CPP_KEYWORD_NONSTRICT_LB,
+									&CPlusPlus_aux,
+									0,2,
+									'\\','\\',true,true);
+
+	CLexer->InstallGlobalFilter(&TrimMandatoryTerminalNewline);
+	CLexer->InstallGlobalFilter(&TerminalLineContinue);
+	CLexer->InstallGlobalFilter(&EnforceCTrigraphs);
+	CLexer->InstallGlobalFilter(&FlattenUNICODE);
+
+	CLexer->InstallTokenizer(&LengthOfCCharLiteral,CPP_FLAG_CHAR_LITERAL);
+	CLexer->InstallTokenizer(&LengthOfCStringLiteral,CPP_FLAG_STRING_LITERAL);
+	CLexer->InstallTokenizer(&LengthOfCPurePreprocessingOperatorPunctuation,CPP_FLAG_PP_OP_PUNC);
+	CLexer->InstallTokenizer(&LengthOfCIdentifier,CPP_FLAG_IDENTIFIER);
+	CLexer->InstallTokenizer(&LengthOfCPreprocessingNumber,CPP_FLAG_PP_NUMERAL);
+
+	CPlusPlusLexer->InstallGlobalFilter(&TrimMandatoryTerminalNewline);
+	CPlusPlusLexer->InstallGlobalFilter(&TerminalLineContinue);
+	CPlusPlusLexer->InstallGlobalFilter(&EnforceCTrigraphs);
+	CPlusPlusLexer->InstallGlobalFilter(&FlattenUNICODE);
+
+	CPlusPlusLexer->InstallTokenizer(&LengthOfCCharLiteral,CPP_FLAG_CHAR_LITERAL);
+	CPlusPlusLexer->InstallTokenizer(&LengthOfCStringLiteral,CPP_FLAG_STRING_LITERAL);
+	CPlusPlusLexer->InstallTokenizer(&LengthOfCPPPurePreprocessingOperatorPunctuation,CPP_FLAG_PP_OP_PUNC);
+	CPlusPlusLexer->InstallTokenizer(&LengthOfCIdentifier,CPP_FLAG_IDENTIFIER);
+	CPlusPlusLexer->InstallTokenizer(&LengthOfCPreprocessingNumber,CPP_FLAG_PP_NUMERAL);
+
+#if 0
+	if (atexit(clear_lexer_defs)) FATAL("atexit handler not installed");
+#endif
+
+	// integrity checks on the data definitions
+	// do the constants match the function calls
+	assert(C_TYPE::NOT_VOID==linear_find("$not-void",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::INTEGERLIKE==linear_find("$integer-like",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::VOID==linear_find("void",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::CHAR==linear_find("char",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::SCHAR==linear_find("signed char",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::UCHAR==linear_find("unsigned char",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::SHRT==linear_find("short",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::USHRT==linear_find("unsigned short",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::INT==linear_find("int",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::UINT==linear_find("unsigned",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::LONG==linear_find("long",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::ULONG==linear_find("unsigned long",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::LLONG==linear_find("long long",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::ULLONG==linear_find("unsigned long long",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::FLOAT==linear_find("float",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::DOUBLE==linear_find("double",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::LDOUBLE==linear_find("long double",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::BOOL==linear_find("_Bool",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::FLOAT__COMPLEX==linear_find("float _Complex",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::DOUBLE__COMPLEX==linear_find("double _Complex",C_atomic_types,C_TYPE_MAX)+1);
+	assert(C_TYPE::LDOUBLE__COMPLEX==linear_find("long double _Complex",C_atomic_types,C_TYPE_MAX)+1);
+
+	assert(C_TYPE::NOT_VOID==linear_find("$not-void",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::INTEGERLIKE==linear_find("$integer-like",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::VOID==linear_find("void",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::CHAR==linear_find("char",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::SCHAR==linear_find("signed char",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::UCHAR==linear_find("unsigned char",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::SHRT==linear_find("short",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::USHRT==linear_find("unsigned short",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::INT==linear_find("int",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::UINT==linear_find("unsigned",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::LONG==linear_find("long",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::ULONG==linear_find("unsigned long",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::LLONG==linear_find("long long",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::ULLONG==linear_find("unsigned long long",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::FLOAT==linear_find("float",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::DOUBLE==linear_find("double",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::LDOUBLE==linear_find("long double",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::BOOL==linear_find("bool",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::FLOAT__COMPLEX==linear_find("float _Complex",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::DOUBLE__COMPLEX==linear_find("double _Complex",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::LDOUBLE__COMPLEX==linear_find("long double _Complex",CPP_atomic_types,CPP_TYPE_MAX)+1);
+	assert(C_TYPE::WCHAR_T==linear_find("wchar_t",CPP_atomic_types,CPP_TYPE_MAX)+1);
+
+	assert(C99_CPP_TYPEDEF_IDX==linear_find("typedef",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_TYPEDEF_IDX==linear_find("typedef",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_CONST_IDX==linear_find("const",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_CONST_IDX==linear_find("const",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_CONST_IDX==linear_find("const",C99_nontype_decl_specifier_list,STATIC_SIZE(C99_nontype_decl_specifier_list)));
+	assert(C99_CPP_CONST_IDX==linear_find("const",CPP0X_nontype_decl_specifier_list,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)));
+	assert(C99_CPP_VOLATILE_IDX==linear_find("volatile",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_VOLATILE_IDX==linear_find("volatile",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_VOLATILE_IDX==linear_find("volatile",C99_nontype_decl_specifier_list,STATIC_SIZE(C99_nontype_decl_specifier_list)));
+	assert(C99_CPP_VOLATILE_IDX==linear_find("volatile",CPP0X_nontype_decl_specifier_list,STATIC_SIZE(CPP0X_nontype_decl_specifier_list)));
+	assert(C99_RESTRICT_IDX==linear_find("restrict",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_REGISTER_IDX==linear_find("register",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_REGISTER_IDX==linear_find("register",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_STATIC_IDX==linear_find("static",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_STATIC_IDX==linear_find("static",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_EXTERN_IDX==linear_find("extern",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_EXTERN_IDX==linear_find("extern",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_AUTO_IDX==linear_find("auto",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_AUTO_IDX==linear_find("auto",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_CHAR_IDX==linear_find("char",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_CHAR_IDX==linear_find("char",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_SHORT_IDX==linear_find("short",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_SHORT_IDX==linear_find("short",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_INT_IDX==linear_find("int",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_INT_IDX==linear_find("int",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_LONG_IDX==linear_find("long",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_LONG_IDX==linear_find("long",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_FLOAT_IDX==linear_find("float",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_FLOAT_IDX==linear_find("float",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_DOUBLE_IDX==linear_find("double",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_DOUBLE_IDX==linear_find("double",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_SIGNED_IDX==linear_find("signed",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_SIGNED_IDX==linear_find("signed",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_UNSIGNED_IDX==linear_find("unsigned",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_UNSIGNED_IDX==linear_find("unsigned",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_COMPLEX_IDX==linear_find("_Complex",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_COMPLEX_IDX==linear_find("_Complex",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C99_CPP_COMPLEX_IDX==linear_find("_Complex",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C99_CPP_COMPLEX_IDX==linear_find("_Complex",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("_Thread_Local",C99_decl_specifier_list,STATIC_SIZE(C99_decl_specifier_list)));
+	assert(C1X_CPP0X_THREAD_LOCAL_IDX==linear_find("thread_local",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+	assert(CPP_MUTABLE_IDX==linear_find("mutable",CPP0X_decl_specifier_list,STATIC_SIZE(CPP0X_decl_specifier_list)));
+
+	/* does bool converts_to_integerlike(size_t base_type_index) work */
+	BOOST_STATIC_ASSERT(!(C_TYPE::BOOL<=C_TYPE::NOT_VOID && C_TYPE::NOT_VOID<=C_TYPE::INTEGERLIKE));
+	BOOST_STATIC_ASSERT(!(C_TYPE::BOOL<=C_TYPE::VOID && C_TYPE::VOID<=C_TYPE::INTEGERLIKE));
+	BOOST_STATIC_ASSERT(C_TYPE::BOOL<=C_TYPE::BOOL && C_TYPE::BOOL<=C_TYPE::INTEGERLIKE);
+	BOOST_STATIC_ASSERT(C_TYPE::BOOL<=C_TYPE::CHAR && C_TYPE::CHAR<=C_TYPE::INTEGERLIKE);
+	BOOST_STATIC_ASSERT(C_TYPE::BOOL<=C_TYPE::SCHAR && C_TYPE::SCHAR<=C_TYPE::INTEGERLIKE);
+	BOOST_STATIC_ASSERT(C_TYPE::BOOL<=C_TYPE::UCHAR && C_TYPE::UCHAR<=C_TYPE::INTEGERLIKE);
+	BOOST_STATIC_ASSERT(C_TYPE::BOOL<=C_TYPE::SHRT && C_TYPE::SHRT<=C_TYPE::INTEGERLIKE);
+	BOOST_STATIC_ASSERT(C_TYPE::BOOL<=C_TYPE::USHRT && C_TYPE::USHRT<=C_TYPE::INTEGERLIKE);
+	BOOST_STATIC_ASSERT(C_TYPE::BOOL<=C_TYPE::INT && C_TYPE::INT<=C_TYPE::INTEGERLIKE);
+	BOOST_STATIC_ASSERT(C_TYPE::BOOL<=C_TYPE::UINT && C_TYPE::UINT<=C_TYPE::INTEGERLIKE);
+	BOOST_STATIC_ASSERT(C_TYPE::BOOL<=C_TYPE::LONG && C_TYPE::LONG<=C_TYPE::INTEGERLIKE);
+	BOOST_STATIC_ASSERT(C_TYPE::BOOL<=C_TYPE::ULONG && C_TYPE::ULONG<=C_TYPE::INTEGERLIKE);
+	BOOST_STATIC_ASSERT(C_TYPE::BOOL<=C_TYPE::LLONG && C_TYPE::LLONG<=C_TYPE::INTEGERLIKE);
+	BOOST_STATIC_ASSERT(C_TYPE::BOOL<=C_TYPE::ULLONG && C_TYPE::ULLONG<=C_TYPE::INTEGERLIKE);
+	BOOST_STATIC_ASSERT(C_TYPE::BOOL<=C_TYPE::INTEGERLIKE && C_TYPE::INTEGERLIKE<=C_TYPE::INTEGERLIKE);
+	BOOST_STATIC_ASSERT(!(C_TYPE::BOOL<=C_TYPE::FLOAT && C_TYPE::FLOAT<=C_TYPE::INTEGERLIKE));
+	BOOST_STATIC_ASSERT(!(C_TYPE::BOOL<=C_TYPE::DOUBLE && C_TYPE::DOUBLE<=C_TYPE::INTEGERLIKE));
+	BOOST_STATIC_ASSERT(!(C_TYPE::BOOL<=C_TYPE::LDOUBLE && C_TYPE::LDOUBLE<=C_TYPE::INTEGERLIKE));
+	BOOST_STATIC_ASSERT(!(C_TYPE::BOOL<=C_TYPE::FLOAT__COMPLEX && C_TYPE::FLOAT__COMPLEX<=C_TYPE::INTEGERLIKE));
+	BOOST_STATIC_ASSERT(!(C_TYPE::BOOL<=C_TYPE::DOUBLE__COMPLEX && C_TYPE::DOUBLE__COMPLEX<=C_TYPE::INTEGERLIKE));
+	BOOST_STATIC_ASSERT(!(C_TYPE::BOOL<=C_TYPE::LDOUBLE__COMPLEX && C_TYPE::LDOUBLE__COMPLEX<=C_TYPE::INTEGERLIKE));
+}
+



From zaimoni at mail.berlios.de  Mon Oct 25 03:56:15 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 25 Oct 2010 03:56:15 +0200
Subject: [Zcplusplus-commits] r499 - trunk
Message-ID: <20101025015615.80DDA481082@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-25 03:56:15 +0200 (Mon, 25 Oct 2010)
New Revision: 499

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
reorganize recognition of anonymous union/struct (no augmentation of behavior)

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-20 18:44:52 UTC (rev 498)
+++ trunk/CSupport.cpp	2010-10-25 01:56:15 UTC (rev 499)
@@ -13272,6 +13272,86 @@
 				continue;
 				};
 			}
+		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
+			{
+#if 0
+			// fix following: anonymous types are un-matchable
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+			assert(tmp2);
+
+			//! \test zcc/decl.C99/Pass_union_forward_def.h
+			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+			assert(types.get_structdecl(tmp2));
+			src.c_array<0>()[i].type_code.set_type(tmp2);
+			src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+
+			// parse the union and upgrade it to a full definition
+			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			assert(tmp3);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record field structure, etc.
+			types.upgrade_decl_to_def(tmp2,tmp4);
+			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+			assert(types.get_C_structdef(tmp2));
+#endif
+			if (   1<src.size<0>()-i
+				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_union.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous union declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			}
+		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
+			{
+#if 0
+			// fix following: anonymous types are un-matchable
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+			assert(tmp2);
+
+			//! \test zcc/decl.C99/Pass_struct_forward_def.h
+			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+			assert(types.get_structdecl(tmp2));
+			src.c_array<0>()[i].type_code.set_type(tmp2);
+			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+
+			// parse the union and upgrade it to a full definition
+			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			assert(tmp3);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record field structure, etc.
+			types.upgrade_decl_to_def(tmp2,tmp4);
+			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+			assert(types.get_C_structdef(tmp2));
+#endif
+			if (   1<src.size<0>()-i
+				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_struct.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous struct declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			}
 		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
 		else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
 			{	// C99 6.7.2.3: allowed only after name is defined
@@ -13331,48 +13411,6 @@
 				}
 			}
 
-		if (	1<src.size<0>()-i
-			&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
-			{	// is_C99_named_specifier(src.data<0>()[i],"enum") will cause an error later, in variable parsing
-			if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_union.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous union declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_struct.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous struct declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-/*			else if (is_C99_named_specifier(src.data<0>()[i],"union"))
-				{	// forward-declaration already handled
-				} */
-/*			else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
-				{	// forward-declaration already handled
-				}	*/
-/*			else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
-				{	// forward-declaration already handled
-				} */
-/*			else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
-				{	// forward-declaration already handled
-				}; */
-			};
 		// general declaration scanner 
 		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
 		// intercept declarations as follows

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-20 18:44:52 UTC (rev 498)
+++ trunk/CSupport.cpp.in	2010-10-25 01:56:15 UTC (rev 499)
@@ -13411,6 +13411,86 @@
 				continue;
 				};
 			}
+		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
+			{
+#if 0
+			// fix following: anonymous types are un-matchable
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+			assert(tmp2);
+
+			//! \test zcc/decl.C99/Pass_union_forward_def.h
+			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
+			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+			assert(types.get_structdecl(tmp2));
+			src.c_array<0>()[i].type_code.set_type(tmp2);
+			src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+
+			// parse the union and upgrade it to a full definition
+			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			assert(tmp3);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record field structure, etc.
+			types.upgrade_decl_to_def(tmp2,tmp4);
+			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+			assert(types.get_C_structdef(tmp2));
+#endif
+			if (   1<src.size<0>()-i
+				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_union.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous union declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			}
+		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
+			{
+#if 0
+			// fix following: anonymous types are un-matchable
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+			assert(tmp2);
+
+			//! \test zcc/decl.C99/Pass_struct_forward_def.h
+			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
+			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+			assert(types.get_structdecl(tmp2));
+			src.c_array<0>()[i].type_code.set_type(tmp2);
+			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
+
+			// parse the union and upgrade it to a full definition
+			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			assert(tmp3);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record field structure, etc.
+			types.upgrade_decl_to_def(tmp2,tmp4);
+			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
+			assert(types.get_C_structdef(tmp2));
+#endif
+			if (   1<src.size<0>()-i
+				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_struct.h
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous struct declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			}
 		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
 		else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
 			{	// C99 6.7.2.3: allowed only after name is defined
@@ -13470,48 +13550,6 @@
 				}
 			}
 
-		if (	1<src.size<0>()-i
-			&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
-			{	// is_C99_named_specifier(src.data<0>()[i],"enum") will cause an error later, in variable parsing
-			if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_union.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous union declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_struct.h
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous struct declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-/*			else if (is_C99_named_specifier(src.data<0>()[i],"union"))
-				{	// forward-declaration already handled
-				} */
-/*			else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
-				{	// forward-declaration already handled
-				}	*/
-/*			else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
-				{	// forward-declaration already handled
-				} */
-/*			else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
-				{	// forward-declaration already handled
-				}; */
-			};
 		// general declaration scanner 
 		// we intercept typedefs as part of general variable declaration detection (weird storage qualifier)
 		// intercept declarations as follows



From zaimoni at mail.berlios.de  Mon Oct 25 05:47:36 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 25 Oct 2010 05:47:36 +0200
Subject: [Zcplusplus-commits] r500 - trunk
Message-ID: <20101025034737.1771A481087@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-25 05:47:36 +0200 (Mon, 25 Oct 2010)
New Revision: 500

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
reorganize recognition of anonymous union/struct/class (no augmentation of behavior)

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-25 01:56:15 UTC (rev 499)
+++ trunk/CSupport.cpp	2010-10-25 03:47:36 UTC (rev 500)
@@ -13277,13 +13277,10 @@
 #if 0
 			// fix following: anonymous types are un-matchable
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = types.register_structdecl("<unknown>",union_struct_decl::decl_union);
 			assert(tmp2);
+			assert(types.get_structdecl(tmp2));
 
-			//! \test zcc/decl.C99/Pass_union_forward_def.h
-			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-			assert(types.get_structdecl(tmp2));
 			src.c_array<0>()[i].type_code.set_type(tmp2);
 			src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
@@ -13294,7 +13291,6 @@
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
 			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
 			assert(types.get_C_structdef(tmp2));
 #endif
 			if (   1<src.size<0>()-i
@@ -13317,13 +13313,10 @@
 #if 0
 			// fix following: anonymous types are un-matchable
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = types.register_structdecl("<unknown>",union_struct_decl::decl_struct);
 			assert(tmp2);
+			assert(types.get_structdecl(tmp2));
 
-			//! \test zcc/decl.C99/Pass_struct_forward_def.h
-			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-			assert(types.get_structdecl(tmp2));
 			src.c_array<0>()[i].type_code.set_type(tmp2);
 			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
@@ -13334,7 +13327,6 @@
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
 			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
 			assert(types.get_C_structdef(tmp2));
 #endif
 			if (   1<src.size<0>()-i
@@ -14238,6 +14230,113 @@
 				continue;
 				}
 			}
+		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
+			{
+#if 0
+			// fix following
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union);
+			assert(tmp2);
+
+			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+			assert(types.get_structdecl(tmp2));
+			src.c_array<0>()[i].type_code.set_type(tmp2);
+			src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+
+			// parse the union and upgrade it to a full definition
+			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			assert(tmp3);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record field structure, etc.
+			types.upgrade_decl_to_def(tmp2,tmp4);
+			assert(types.get_C_structdef(tmp2));
+#endif
+			if (	1<src.size<0>()-i
+				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous union declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			}
+		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
+			{
+#if 0
+			// fix following
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct);
+			assert(tmp2);
+			assert(types.get_structdecl(tmp2));
+			src.c_array<0>()[i].type_code.set_type(tmp2);
+			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+
+			// parse the union and upgrade it to a full definition
+			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			assert(tmp3);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record field structure, etc.
+			types.upgrade_decl_to_def(tmp2,tmp4);
+			assert(types.get_C_structdef(tmp2));
+#endif
+			if (	1<src.size<0>()-i
+				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous struct declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			}
+		else if (is_C99_anonymous_specifier(src.data<0>()[i],"class"))
+			{
+#if 0
+			// fix following
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class);
+			assert(tmp2);
+			assert(types.get_structdecl(tmp2));
+			src.c_array<0>()[i].type_code.set_type(tmp2);
+			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+
+			// parse the union and upgrade it to a full definition
+			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			assert(tmp3);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record field structure, etc.
+			types.upgrade_decl_to_def(tmp2,tmp4);
+			assert(types.get_C_structdef(tmp2));
+#endif
+			if (	1<src.size<0>()-i
+				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous class declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			}
 		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
 		//! \todo actually, we can try forward-declare both scoped enums and enum-based enums (C++0X 7.2p3, these have enough size information); but other parts of the standard get in the way
 		else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
@@ -14304,67 +14403,6 @@
 				}
 			}
 
-		if (	1<src.size<0>()-i
-			&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
-			{	// is_C99_named_specifier(src.data<0>()[i],"enum") will cause an error later, in variable parsing
-			if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous union declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous struct declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			else if (is_C99_anonymous_specifier(src.data<0>()[i],"class"))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous class declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-/*			else if (is_C99_named_specifier(src.data<0>()[i],"union"))
-				{	// forward-declaration already handled
-				}	*/
-/*			else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
-				{	// forward-declaration already handled
-				}	*/
-/*			else if (is_C99_named_specifier(src.data<0>()[i],"class"))
-				{	// forward-declaration already handled
-				} */
-/*			else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
-				{	// forward-declaration already handled
-				}	*/
-/*			else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
-				{	// forward-declaration already handled
-				} */
-/*			else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
-				{	// forward-declaration already handled
-				} */
-			};
 		// namespace scanner
 		// need some scheme to handle unnamed namespaces (probably alphabetical counter after something illegal so unmatchable)
 		// C++0X has inline namespaces; ignore these for now (well, maybe not: consuming the inline will prevent problems)

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-25 01:56:15 UTC (rev 499)
+++ trunk/CSupport.cpp.in	2010-10-25 03:47:36 UTC (rev 500)
@@ -13416,13 +13416,10 @@
 #if 0
 			// fix following: anonymous types are un-matchable
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_union);
+			const type_system::type_index tmp2 = types.register_structdecl("<unknown>",union_struct_decl::decl_union);
 			assert(tmp2);
+			assert(types.get_structdecl(tmp2));
 
-			//! \test zcc/decl.C99/Pass_union_forward_def.h
-			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first));
-			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-			assert(types.get_structdecl(tmp2));
 			src.c_array<0>()[i].type_code.set_type(tmp2);
 			src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
@@ -13433,7 +13430,6 @@
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
 			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_id_union(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
 			assert(types.get_C_structdef(tmp2));
 #endif
 			if (   1<src.size<0>()-i
@@ -13456,13 +13452,10 @@
 #if 0
 			// fix following: anonymous types are un-matchable
 			// tentatively forward-declare immediately
-			const type_system::type_index tmp2 = types.register_structdecl(src.data<0>()[i].index_tokens[1].token.first,union_struct_decl::decl_struct);
+			const type_system::type_index tmp2 = types.register_structdecl("<unknown>",union_struct_decl::decl_struct);
 			assert(tmp2);
+			assert(types.get_structdecl(tmp2));
 
-			//! \test zcc/decl.C99/Pass_struct_forward_def.h
-			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first));
-			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
-			assert(types.get_structdecl(tmp2));
 			src.c_array<0>()[i].type_code.set_type(tmp2);
 			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
 			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const type qualifier (C99 6.7.3p4)","removing redundant volatile type qualifier (C99 6.7.3p4)");
@@ -13473,7 +13466,6 @@
 			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
 			//! \todo record field structure, etc.
 			types.upgrade_decl_to_def(tmp2,tmp4);
-			assert(types.get_id_struct_class(src.data<0>()[i].index_tokens[1].token.first)==tmp2);
 			assert(types.get_C_structdef(tmp2));
 #endif
 			if (   1<src.size<0>()-i
@@ -14377,6 +14369,113 @@
 				continue;
 				}
 			}
+		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
+			{
+#if 0
+			// fix following
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union);
+			assert(tmp2);
+
+			//! \test zcc/decl.C99/Pass_union_forward_def.hpp
+			assert(types.get_structdecl(tmp2));
+			src.c_array<0>()[i].type_code.set_type(tmp2);
+			src.c_array<0>()[i].flags |= PARSE_UNION_TYPE;
+			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+
+			// parse the union and upgrade it to a full definition
+			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			assert(tmp3);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record field structure, etc.
+			types.upgrade_decl_to_def(tmp2,tmp4);
+			assert(types.get_C_structdef(tmp2));
+#endif
+			if (	1<src.size<0>()-i
+				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous union declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			}
+		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
+			{
+#if 0
+			// fix following
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct);
+			assert(tmp2);
+			assert(types.get_structdecl(tmp2));
+			src.c_array<0>()[i].type_code.set_type(tmp2);
+			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+
+			// parse the union and upgrade it to a full definition
+			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			assert(tmp3);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record field structure, etc.
+			types.upgrade_decl_to_def(tmp2,tmp4);
+			assert(types.get_C_structdef(tmp2));
+#endif
+			if (	1<src.size<0>()-i
+				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous struct declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			}
+		else if (is_C99_anonymous_specifier(src.data<0>()[i],"class"))
+			{
+#if 0
+			// fix following
+			// tentatively forward-declare immediately
+			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class);
+			assert(tmp2);
+			assert(types.get_structdecl(tmp2));
+			src.c_array<0>()[i].type_code.set_type(tmp2);
+			src.c_array<0>()[i].flags |= PARSE_CLASS_STRUCT_TYPE;
+			_condense_const_volatile_onto_type(src,i,invariant_decl_scanner,"removing redundant const cv-qualifier (C++0X 7.1.6.1p1)","removing redundant volatile cv-qualifier (C++0X 7.1.6.1p1)");
+
+			// parse the union and upgrade it to a full definition
+			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
+			assert(tmp3);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			//! \todo record field structure, etc.
+			types.upgrade_decl_to_def(tmp2,tmp4);
+			assert(types.get_C_structdef(tmp2));
+#endif
+			if (	1<src.size<0>()-i
+				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
+				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
+				message_header(src.data<0>()[i].index_tokens[0]);
+				INC_INFORM(WARN_STR);
+				INFORM("unreferenceable anonymous class declaration");
+				if (bool_options[boolopt::warnings_are_errors])
+					zcc_errors.inc_error();
+				// remove from parse
+				src.DeleteNSlotsAt<0>(2,i);
+				continue;
+				}
+			}
 		// enum was difficult to interpret in C++, so parked here while waiting on comp.std.c++
 		//! \todo actually, we can try forward-declare both scoped enums and enum-based enums (C++0X 7.2p3, these have enough size information); but other parts of the standard get in the way
 		else if (is_C99_named_specifier(src.data<0>()[i],"enum"))
@@ -14443,67 +14542,6 @@
 				}
 			}
 
-		if (	1<src.size<0>()-i
-			&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
-			{	// is_C99_named_specifier(src.data<0>()[i],"enum") will cause an error later, in variable parsing
-			if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous union declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous struct declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-			else if (is_C99_anonymous_specifier(src.data<0>()[i],"class"))
-				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
-				message_header(src.data<0>()[i].index_tokens[0]);
-				INC_INFORM(WARN_STR);
-				INFORM("unreferenceable anonymous class declaration");
-				if (bool_options[boolopt::warnings_are_errors])
-					zcc_errors.inc_error();
-				// remove from parse
-				src.DeleteNSlotsAt<0>(2,i);
-				continue;
-				}
-/*			else if (is_C99_named_specifier(src.data<0>()[i],"union"))
-				{	// forward-declaration already handled
-				}	*/
-/*			else if (is_C99_named_specifier(src.data<0>()[i],"struct"))
-				{	// forward-declaration already handled
-				}	*/
-/*			else if (is_C99_named_specifier(src.data<0>()[i],"class"))
-				{	// forward-declaration already handled
-				} */
-/*			else if (is_C99_named_specifier_definition(src.data<0>()[i],"union"))
-				{	// forward-declaration already handled
-				}	*/
-/*			else if (is_C99_named_specifier_definition(src.data<0>()[i],"struct"))
-				{	// forward-declaration already handled
-				} */
-/*			else if (is_C99_named_specifier_definition(src.data<0>()[i],"class"))
-				{	// forward-declaration already handled
-				} */
-			};
 		// namespace scanner
 		// need some scheme to handle unnamed namespaces (probably alphabetical counter after something illegal so unmatchable)
 		// C++0X has inline namespaces; ignore these for now (well, maybe not: consuming the inline will prevent problems)



From zaimoni at mail.berlios.de  Mon Oct 25 20:47:49 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 25 Oct 2010 20:47:49 +0200
Subject: [Zcplusplus-commits] r501 - trunk
Message-ID: <20101025184749.E16D74801BF@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-25 20:47:49 +0200 (Mon, 25 Oct 2010)
New Revision: 501

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
actually record existence of anonymous union/struct/class

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-25 03:47:36 UTC (rev 500)
+++ trunk/CSupport.cpp	2010-10-25 18:47:49 UTC (rev 501)
@@ -13273,9 +13273,7 @@
 				};
 			}
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
-			{
-#if 0
-			// fix following: anonymous types are un-matchable
+			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = types.register_structdecl("<unknown>",union_struct_decl::decl_union);
 			assert(tmp2);
@@ -13288,14 +13286,15 @@
 			// parse the union and upgrade it to a full definition
 			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
 			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
 			types.upgrade_decl_to_def(tmp2,tmp4);
 			assert(types.get_C_structdef(tmp2));
-#endif
+
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo handle useless const/volatile warning as well
 					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 					//! \test zcc/decl.C99/Warn_inaccessible_union.h
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -13309,9 +13308,7 @@
 				}
 			}
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
-			{
-#if 0
-			// fix following: anonymous types are un-matchable
+			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = types.register_structdecl("<unknown>",union_struct_decl::decl_struct);
 			assert(tmp2);
@@ -13324,14 +13321,15 @@
 			// parse the union and upgrade it to a full definition
 			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
 			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
 			types.upgrade_decl_to_def(tmp2,tmp4);
 			assert(types.get_C_structdef(tmp2));
-#endif
+
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo handle useless const/volatile warning as well
 					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 					//! \test zcc/decl.C99/Warn_inaccessible_struct.h
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -14231,9 +14229,7 @@
 				}
 			}
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
-			{
-#if 0
-			// fix following
+			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union);
 			assert(tmp2);
@@ -14247,14 +14243,15 @@
 			// parse the union and upgrade it to a full definition
 			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
 			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
 			types.upgrade_decl_to_def(tmp2,tmp4);
 			assert(types.get_C_structdef(tmp2));
-#endif
+
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo handle useless const/volatile warning as well
 					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 					//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -14268,9 +14265,7 @@
 				}
 			}
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
-			{
-#if 0
-			// fix following
+			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct);
 			assert(tmp2);
@@ -14282,14 +14277,15 @@
 			// parse the union and upgrade it to a full definition
 			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
 			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
 			types.upgrade_decl_to_def(tmp2,tmp4);
 			assert(types.get_C_structdef(tmp2));
-#endif
+
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo handle useless const/volatile warning as well
 					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -14303,9 +14299,7 @@
 				}
 			}
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"class"))
-			{
-#if 0
-			// fix following
+			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class);
 			assert(tmp2);
@@ -14317,14 +14311,15 @@
 			// parse the union and upgrade it to a full definition
 			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
 			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
 			types.upgrade_decl_to_def(tmp2,tmp4);
 			assert(types.get_C_structdef(tmp2));
-#endif
+
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo handle useless const/volatile warning as well
 					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-25 03:47:36 UTC (rev 500)
+++ trunk/CSupport.cpp.in	2010-10-25 18:47:49 UTC (rev 501)
@@ -13412,9 +13412,7 @@
 				};
 			}
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
-			{
-#if 0
-			// fix following: anonymous types are un-matchable
+			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = types.register_structdecl("<unknown>",union_struct_decl::decl_union);
 			assert(tmp2);
@@ -13427,14 +13425,15 @@
 			// parse the union and upgrade it to a full definition
 			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
 			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
 			types.upgrade_decl_to_def(tmp2,tmp4);
 			assert(types.get_C_structdef(tmp2));
-#endif
+
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo handle useless const/volatile warning as well
 					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 					//! \test zcc/decl.C99/Warn_inaccessible_union.h
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -13448,9 +13447,7 @@
 				}
 			}
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
-			{
-#if 0
-			// fix following: anonymous types are un-matchable
+			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = types.register_structdecl("<unknown>",union_struct_decl::decl_struct);
 			assert(tmp2);
@@ -13463,14 +13460,15 @@
 			// parse the union and upgrade it to a full definition
 			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
 			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
 			types.upgrade_decl_to_def(tmp2,tmp4);
 			assert(types.get_C_structdef(tmp2));
-#endif
+
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo handle useless const/volatile warning as well
 					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 					//! \test zcc/decl.C99/Warn_inaccessible_struct.h
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -14370,9 +14368,7 @@
 				}
 			}
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"union"))
-			{
-#if 0
-			// fix following
+			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_union);
 			assert(tmp2);
@@ -14386,14 +14382,15 @@
 			// parse the union and upgrade it to a full definition
 			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
 			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
 			types.upgrade_decl_to_def(tmp2,tmp4);
 			assert(types.get_C_structdef(tmp2));
-#endif
+
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo handle useless const/volatile warning as well
 					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 					//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -14407,9 +14404,7 @@
 				}
 			}
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"struct"))
-			{
-#if 0
-			// fix following
+			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_struct);
 			assert(tmp2);
@@ -14421,14 +14416,15 @@
 			// parse the union and upgrade it to a full definition
 			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
 			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
 			types.upgrade_decl_to_def(tmp2,tmp4);
 			assert(types.get_C_structdef(tmp2));
-#endif
+
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo handle useless const/volatile warning as well
 					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -14442,9 +14438,7 @@
 				}
 			}
 		else if (is_C99_anonymous_specifier(src.data<0>()[i],"class"))
-			{
-#if 0
-			// fix following
+			{	// anonymous types cannot be matched
 			// tentatively forward-declare immediately
 			const type_system::type_index tmp2 = types.register_structdecl_CPP("<unknown>",active_namespace,union_struct_decl::decl_class);
 			assert(tmp2);
@@ -14456,14 +14450,15 @@
 			// parse the union and upgrade it to a full definition
 			const union_struct_decl* tmp3 = types.get_structdecl(tmp2);
 			assert(tmp3);
-			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[1].logical_line,src.data<0>()[i].index_tokens[1].src_filename);
+			C_union_struct_def* tmp4 = new C_union_struct_def(*tmp3,src.data<0>()[i].index_tokens[0].logical_line,src.data<0>()[i].index_tokens[0].src_filename);
 			//! \todo record field structure, etc.
 			types.upgrade_decl_to_def(tmp2,tmp4);
 			assert(types.get_C_structdef(tmp2));
-#endif
+
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
+					//! \todo handle useless const/volatile warning as well
 					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);



From zaimoni at mail.berlios.de  Mon Oct 25 22:27:36 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Mon, 25 Oct 2010 22:27:36 +0200
Subject: [Zcplusplus-commits] r502 - in trunk: . tests/zcc/decl.C99
Message-ID: <20101025202736.F05A34801BF@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-25 22:27:36 +0200 (Mon, 25 Oct 2010)
New Revision: 502

Added:
   trunk/tests/zcc/decl.C99/Error_union_anon_def_const.hpp
   trunk/tests/zcc/decl.C99/Error_union_anon_def_const2.hpp
   trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile.hpp
   trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile2.hpp
   trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile3.hpp
   trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile4.hpp
   trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile5.hpp
   trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile6.hpp
   trunk/tests/zcc/decl.C99/Error_union_anon_def_volatile.hpp
   trunk/tests/zcc/decl.C99/Error_union_anon_def_volatile2.hpp
   trunk/tests/zcc/decl.C99/Warn_union_anon_def_const.h
   trunk/tests/zcc/decl.C99/Warn_union_anon_def_const2.h
   trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile.h
   trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile2.h
   trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile3.h
   trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile4.h
   trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile5.h
   trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile6.h
   trunk/tests/zcc/decl.C99/Warn_union_anon_def_volatile.h
   trunk/tests/zcc/decl.C99/Warn_union_anon_def_volatile2.h
Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
check that we don't assert on const/volatile qualified anonymous unions

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-25 18:47:49 UTC (rev 501)
+++ trunk/CSupport.cpp	2010-10-25 20:27:36 UTC (rev 502)
@@ -13294,9 +13294,30 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo handle useless const/volatile warning as well
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_union.h
+				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Warn_union_anon_def_const.h
+						//! \test decl.C99/Warn_union_anon_def_const2.h
+						//! \test decl.C99/Warn_union_anon_def_volatile.h
+						//! \test decl.C99/Warn_union_anon_def_volatile2.h
+						//! \test decl.C99/Warn_union_anon_def_const_volatile.h
+						//! \test decl.C99/Warn_union_anon_def_const_volatile2.h
+						//! \test decl.C99/Warn_union_anon_def_const_volatile3.h
+						//! \test decl.C99/Warn_union_anon_def_const_volatile4.h
+						//! \test decl.C99/Warn_union_anon_def_const_volatile5.h
+						//! \test decl.C99/Warn_union_anon_def_const_volatile6.h
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("useless const/volatile qualification of a definition (C99 6.7.3p3)");
+					if (bool_options[boolopt::warn_crosslang_compatibility])
+						INFORM("(error in C++: C++0X 7.1.6.1p1)");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					};
+				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+				//! \test zcc/decl.C99/Warn_inaccessible_union.h
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(WARN_STR);
 				INFORM("unreferenceable anonymous union declaration");
@@ -14251,9 +14272,26 @@
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo handle useless const/volatile warning as well
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Error_union_anon_def_const.hpp
+						//! \test decl.C99/Error_union_anon_def_const2.hpp
+						//! \test decl.C99/Error_union_anon_def_volatile.hpp
+						//! \test decl.C99/Error_union_anon_def_volatile2.hpp
+						//! \test decl.C99/Error_union_anon_def_const_volatile.hpp
+						//! \test decl.C99/Error_union_anon_def_const_volatile2.hpp
+						//! \test decl.C99/Error_union_anon_def_const_volatile3.hpp
+						//! \test decl.C99/Error_union_anon_def_const_volatile4.hpp
+						//! \test decl.C99/Error_union_anon_def_const_volatile5.hpp
+						//! \test decl.C99/Error_union_anon_def_const_volatile6.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
+					zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					}
+				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+				//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(WARN_STR);
 				INFORM("unreferenceable anonymous union declaration");

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-25 18:47:49 UTC (rev 501)
+++ trunk/CSupport.cpp.in	2010-10-25 20:27:36 UTC (rev 502)
@@ -13433,9 +13433,30 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo handle useless const/volatile warning as well
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_union.h
+				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Warn_union_anon_def_const.h
+						//! \test decl.C99/Warn_union_anon_def_const2.h
+						//! \test decl.C99/Warn_union_anon_def_volatile.h
+						//! \test decl.C99/Warn_union_anon_def_volatile2.h
+						//! \test decl.C99/Warn_union_anon_def_const_volatile.h
+						//! \test decl.C99/Warn_union_anon_def_const_volatile2.h
+						//! \test decl.C99/Warn_union_anon_def_const_volatile3.h
+						//! \test decl.C99/Warn_union_anon_def_const_volatile4.h
+						//! \test decl.C99/Warn_union_anon_def_const_volatile5.h
+						//! \test decl.C99/Warn_union_anon_def_const_volatile6.h
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("useless const/volatile qualification of a definition (C99 6.7.3p3)");
+					if (bool_options[boolopt::warn_crosslang_compatibility])
+						INFORM("(error in C++: C++0X 7.1.6.1p1)");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					};
+				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+				//! \test zcc/decl.C99/Warn_inaccessible_union.h
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(WARN_STR);
 				INFORM("unreferenceable anonymous union declaration");
@@ -14390,9 +14411,26 @@
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo handle useless const/volatile warning as well
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Error_union_anon_def_const.hpp
+						//! \test decl.C99/Error_union_anon_def_const2.hpp
+						//! \test decl.C99/Error_union_anon_def_volatile.hpp
+						//! \test decl.C99/Error_union_anon_def_volatile2.hpp
+						//! \test decl.C99/Error_union_anon_def_const_volatile.hpp
+						//! \test decl.C99/Error_union_anon_def_const_volatile2.hpp
+						//! \test decl.C99/Error_union_anon_def_const_volatile3.hpp
+						//! \test decl.C99/Error_union_anon_def_const_volatile4.hpp
+						//! \test decl.C99/Error_union_anon_def_const_volatile5.hpp
+						//! \test decl.C99/Error_union_anon_def_const_volatile6.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
+					zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					}
+				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+				//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(WARN_STR);
 				INFORM("unreferenceable anonymous union declaration");

Added: trunk/tests/zcc/decl.C99/Error_union_anon_def_const.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_anon_def_const.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_anon_def_const.hpp	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Error_union_anon_def_const.hpp
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+const union {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_union_anon_def_const2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_anon_def_const2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_anon_def_const2.hpp	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Error_union_anon_def_const2.hpp
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union {
+	int x_factor;
+} const;
+

Added: trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile.hpp	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Error_union_anon_def_const_volatile.hpp
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+const volatile union {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile2.hpp	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Error_union_anon_def_const_volatile2.hpp
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+volatile const union {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile3.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile3.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile3.hpp	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Error_union_anon_def_const_volatile3.hpp
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+const union {
+	int x_factor;
+} volatile;
+

Added: trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile4.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile4.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile4.hpp	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Error_union_anon_def_const_volatile4.hpp
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+volatile union {
+	int x_factor;
+} const;
+

Added: trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile5.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile5.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile5.hpp	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Error_union_anon_def_const_volatile5.hpp
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union {
+	int x_factor;
+} const volatile;
+

Added: trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile6.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile6.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_anon_def_const_volatile6.hpp	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Error_union_anon_def_const_volatile6.hpp
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union {
+	int x_factor;
+} volatile const;
+

Added: trunk/tests/zcc/decl.C99/Error_union_anon_def_volatile.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_anon_def_volatile.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_anon_def_volatile.hpp	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Error_union_anon_def_volatile.hpp
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+volatile union {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_union_anon_def_volatile2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_union_anon_def_volatile2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_union_anon_def_volatile2.hpp	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,7 @@
+// decl.C99\Error_union_anon_def_volatile2.hpp
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union {
+	int x_factor;
+} volatile;

Added: trunk/tests/zcc/decl.C99/Warn_union_anon_def_const.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_union_anon_def_const.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_union_anon_def_const.h	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_union_anon_def_const.h
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+const union {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Warn_union_anon_def_const2.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_union_anon_def_const2.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_union_anon_def_const2.h	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_union_anon_def_const2.h
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union {
+	int x_factor;
+} const;
+

Added: trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile.h	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_union_anon_def_const_volatile.h
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+const volatile union {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile2.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile2.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile2.h	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_union_anon_def_const_volatile2.h
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+volatile const union {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile3.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile3.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile3.h	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_union_anon_def_const_volatile3.h
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+const union {
+	int x_factor;
+} volatile;
+

Added: trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile4.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile4.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile4.h	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_union_anon_def_const_volatile4.h
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+volatile union {
+	int x_factor;
+} const;
+

Added: trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile5.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile5.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile5.h	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_union_anon_def_const_volatile5.h
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union {
+	int x_factor;
+} const volatile;
+

Added: trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile6.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile6.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_union_anon_def_const_volatile6.h	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_union_anon_def_const_volatile6.h
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union {
+	int x_factor;
+} volatile const;
+

Added: trunk/tests/zcc/decl.C99/Warn_union_anon_def_volatile.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_union_anon_def_volatile.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_union_anon_def_volatile.h	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_union_anon_def_volatile.h
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+volatile union {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Warn_union_anon_def_volatile2.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_union_anon_def_volatile2.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_union_anon_def_volatile2.h	2010-10-25 20:27:36 UTC (rev 502)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_union_anon_def_volatile2.h
+// using singly defined union
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+union {
+	int x_factor;
+} volatile;
+



From zaimoni at mail.berlios.de  Tue Oct 26 05:45:11 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 26 Oct 2010 05:45:11 +0200
Subject: [Zcplusplus-commits] r503 - trunk/tests/zcc/decl.C99
Message-ID: <20101026034512.0653C4801EB@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-26 05:45:11 +0200 (Tue, 26 Oct 2010)
New Revision: 503

Added:
   trunk/tests/zcc/decl.C99/Error_class_anon_def_const.hpp
   trunk/tests/zcc/decl.C99/Error_class_anon_def_const2.hpp
   trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile.hpp
   trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile2.hpp
   trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile3.hpp
   trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile4.hpp
   trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile5.hpp
   trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile6.hpp
   trunk/tests/zcc/decl.C99/Error_class_anon_def_volatile.hpp
   trunk/tests/zcc/decl.C99/Error_class_anon_def_volatile2.hpp
Log:
test cases prelude

Added: trunk/tests/zcc/decl.C99/Error_class_anon_def_const.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_anon_def_const.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_anon_def_const.hpp	2010-10-26 03:45:11 UTC (rev 503)
@@ -0,0 +1,8 @@
+// decl.C99\Error_class_anon_def_const.hpp
+// using singly defined class
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+const class {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_class_anon_def_const2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_anon_def_const2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_anon_def_const2.hpp	2010-10-26 03:45:11 UTC (rev 503)
@@ -0,0 +1,8 @@
+// decl.C99\Error_class_anon_def_const2.hpp
+// using singly defined class
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+class {
+	int x_factor;
+} const;
+

Added: trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile.hpp	2010-10-26 03:45:11 UTC (rev 503)
@@ -0,0 +1,8 @@
+// decl.C99\Error_class_anon_def_const_volatile.hpp
+// using singly defined class
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+const volatile class {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile2.hpp	2010-10-26 03:45:11 UTC (rev 503)
@@ -0,0 +1,8 @@
+// decl.C99\Error_class_anon_def_const_volatile2.hpp
+// using singly defined class
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+volatile const class {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile3.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile3.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile3.hpp	2010-10-26 03:45:11 UTC (rev 503)
@@ -0,0 +1,8 @@
+// decl.C99\Error_class_anon_def_const_volatile3.hpp
+// using singly defined class
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+const class {
+	int x_factor;
+} volatile;
+

Added: trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile4.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile4.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile4.hpp	2010-10-26 03:45:11 UTC (rev 503)
@@ -0,0 +1,8 @@
+// decl.C99\Error_class_anon_def_const_volatile4.hpp
+// using singly defined class
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+volatile class {
+	int x_factor;
+} const;
+

Added: trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile5.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile5.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile5.hpp	2010-10-26 03:45:11 UTC (rev 503)
@@ -0,0 +1,8 @@
+// decl.C99\Error_class_anon_def_const_volatile5.hpp
+// using singly defined class
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+class {
+	int x_factor;
+} const volatile;
+

Added: trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile6.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile6.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_anon_def_const_volatile6.hpp	2010-10-26 03:45:11 UTC (rev 503)
@@ -0,0 +1,8 @@
+// decl.C99\Error_class_def_anon_const_volatile6.hpp
+// using singly defined class
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+class {
+	int x_factor;
+} volatile const;
+

Added: trunk/tests/zcc/decl.C99/Error_class_anon_def_volatile.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_anon_def_volatile.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_anon_def_volatile.hpp	2010-10-26 03:45:11 UTC (rev 503)
@@ -0,0 +1,8 @@
+// decl.C99\Error_class_anon_def_volatile.hpp
+// using singly defined class
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+volatile class {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_class_anon_def_volatile2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_class_anon_def_volatile2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_class_anon_def_volatile2.hpp	2010-10-26 03:45:11 UTC (rev 503)
@@ -0,0 +1,8 @@
+// decl.C99\Error_class_anon_def_volatile2.hpp
+// using singly defined class
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+class {
+	int x_factor;
+} volatile;
+



From zaimoni at mail.berlios.de  Tue Oct 26 05:45:40 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 26 Oct 2010 05:45:40 +0200
Subject: [Zcplusplus-commits] r504 - in trunk: . tests/zcc/decl.C99
Message-ID: <20101026034540.A06424801CF@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-26 05:45:40 +0200 (Tue, 26 Oct 2010)
New Revision: 504

Added:
   trunk/tests/zcc/decl.C99/Error_struct_anon_def_const.hpp
   trunk/tests/zcc/decl.C99/Error_struct_anon_def_const2.hpp
   trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile.hpp
   trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile2.hpp
   trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile3.hpp
   trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile4.hpp
   trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile5.hpp
   trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile6.hpp
   trunk/tests/zcc/decl.C99/Error_struct_anon_def_volatile.hpp
   trunk/tests/zcc/decl.C99/Error_struct_anon_def_volatile2.hpp
   trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const.h
   trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const2.h
   trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile.h
   trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile2.h
   trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile3.h
   trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile4.h
   trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile5.h
   trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile6.h
   trunk/tests/zcc/decl.C99/Warn_struct_anon_def_volatile.h
   trunk/tests/zcc/decl.C99/Warn_struct_anon_def_volatile2.h
Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
check that we don't assert on const/volatile qualified anonymous structs, classes

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-26 03:45:11 UTC (rev 503)
+++ trunk/CSupport.cpp	2010-10-26 03:45:40 UTC (rev 504)
@@ -13350,9 +13350,30 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo handle useless const/volatile warning as well
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_struct.h
+				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Warn_struct_anon_def_const.h
+						//! \test decl.C99/Warn_struct_anon_def_const2.h
+						//! \test decl.C99/Warn_struct_anon_def_volatile.h
+						//! \test decl.C99/Warn_struct_anon_def_volatile2.h
+						//! \test decl.C99/Warn_struct_anon_def_const_volatile.h
+						//! \test decl.C99/Warn_struct_anon_def_const_volatile2.h
+						//! \test decl.C99/Warn_struct_anon_def_const_volatile3.h
+						//! \test decl.C99/Warn_struct_anon_def_const_volatile4.h
+						//! \test decl.C99/Warn_struct_anon_def_const_volatile5.h
+						//! \test decl.C99/Warn_struct_anon_def_const_volatile6.h
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("useless const/volatile qualification of a definition (C99 6.7.3p3)");
+					if (bool_options[boolopt::warn_crosslang_compatibility])
+						INFORM("(error in C++: C++0X 7.1.6.1p1)");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					};
+				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+				//! \test zcc/decl.C99/Warn_inaccessible_struct.h
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(WARN_STR);
 				INFORM("unreferenceable anonymous struct declaration");
@@ -14323,9 +14344,26 @@
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo handle useless const/volatile warning as well
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Error_struct_anon_def_const.hpp
+						//! \test decl.C99/Error_struct_anon_def_const2.hpp
+						//! \test decl.C99/Error_struct_anon_def_volatile.hpp
+						//! \test decl.C99/Error_struct_anon_def_volatile2.hpp
+						//! \test decl.C99/Error_struct_anon_def_const_volatile.hpp
+						//! \test decl.C99/Error_struct_anon_def_const_volatile2.hpp
+						//! \test decl.C99/Error_struct_anon_def_const_volatile3.hpp
+						//! \test decl.C99/Error_struct_anon_def_const_volatile4.hpp
+						//! \test decl.C99/Error_struct_anon_def_const_volatile5.hpp
+						//! \test decl.C99/Error_struct_anon_def_const_volatile6.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
+					zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					}
+				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+				//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(WARN_STR);
 				INFORM("unreferenceable anonymous struct declaration");
@@ -14357,9 +14395,26 @@
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo handle useless const/volatile warning as well
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Error_class_anon_def_const.hpp
+						//! \test decl.C99/Error_class_anon_def_const2.hpp
+						//! \test decl.C99/Error_class_anon_def_volatile.hpp
+						//! \test decl.C99/Error_class_anon_def_volatile2.hpp
+						//! \test decl.C99/Error_class_anon_def_const_volatile.hpp
+						//! \test decl.C99/Error_class_anon_def_const_volatile2.hpp
+						//! \test decl.C99/Error_class_anon_def_const_volatile3.hpp
+						//! \test decl.C99/Error_class_anon_def_const_volatile4.hpp
+						//! \test decl.C99/Error_class_anon_def_const_volatile5.hpp
+						//! \test decl.C99/Error_class_anon_def_const_volatile6.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
+					zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					}
+				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+				//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(WARN_STR);
 				INFORM("unreferenceable anonymous class declaration");

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-26 03:45:11 UTC (rev 503)
+++ trunk/CSupport.cpp.in	2010-10-26 03:45:40 UTC (rev 504)
@@ -13489,9 +13489,30 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo handle useless const/volatile warning as well
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_struct.h
+				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Warn_struct_anon_def_const.h
+						//! \test decl.C99/Warn_struct_anon_def_const2.h
+						//! \test decl.C99/Warn_struct_anon_def_volatile.h
+						//! \test decl.C99/Warn_struct_anon_def_volatile2.h
+						//! \test decl.C99/Warn_struct_anon_def_const_volatile.h
+						//! \test decl.C99/Warn_struct_anon_def_const_volatile2.h
+						//! \test decl.C99/Warn_struct_anon_def_const_volatile3.h
+						//! \test decl.C99/Warn_struct_anon_def_const_volatile4.h
+						//! \test decl.C99/Warn_struct_anon_def_const_volatile5.h
+						//! \test decl.C99/Warn_struct_anon_def_const_volatile6.h
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(WARN_STR);
+					INFORM("useless const/volatile qualification of a definition (C99 6.7.3p3)");
+					if (bool_options[boolopt::warn_crosslang_compatibility])
+						INFORM("(error in C++: C++0X 7.1.6.1p1)");
+					if (bool_options[boolopt::warnings_are_errors])
+						zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					};
+				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+				//! \test zcc/decl.C99/Warn_inaccessible_struct.h
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(WARN_STR);
 				INFORM("unreferenceable anonymous struct declaration");
@@ -14462,9 +14483,26 @@
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo handle useless const/volatile warning as well
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Error_struct_anon_def_const.hpp
+						//! \test decl.C99/Error_struct_anon_def_const2.hpp
+						//! \test decl.C99/Error_struct_anon_def_volatile.hpp
+						//! \test decl.C99/Error_struct_anon_def_volatile2.hpp
+						//! \test decl.C99/Error_struct_anon_def_const_volatile.hpp
+						//! \test decl.C99/Error_struct_anon_def_const_volatile2.hpp
+						//! \test decl.C99/Error_struct_anon_def_const_volatile3.hpp
+						//! \test decl.C99/Error_struct_anon_def_const_volatile4.hpp
+						//! \test decl.C99/Error_struct_anon_def_const_volatile5.hpp
+						//! \test decl.C99/Error_struct_anon_def_const_volatile6.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
+					zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					}
+				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+				//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(WARN_STR);
 				INFORM("unreferenceable anonymous struct declaration");
@@ -14496,9 +14534,26 @@
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-					//! \todo handle useless const/volatile warning as well
-					//! \todo do not warn for -Wno-OOAO/-Wno-DRY
-					//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
+				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
+					{	//! \test decl.C99/Error_class_anon_def_const.hpp
+						//! \test decl.C99/Error_class_anon_def_const2.hpp
+						//! \test decl.C99/Error_class_anon_def_volatile.hpp
+						//! \test decl.C99/Error_class_anon_def_volatile2.hpp
+						//! \test decl.C99/Error_class_anon_def_const_volatile.hpp
+						//! \test decl.C99/Error_class_anon_def_const_volatile2.hpp
+						//! \test decl.C99/Error_class_anon_def_const_volatile3.hpp
+						//! \test decl.C99/Error_class_anon_def_const_volatile4.hpp
+						//! \test decl.C99/Error_class_anon_def_const_volatile5.hpp
+						//! \test decl.C99/Error_class_anon_def_const_volatile6.hpp
+					message_header(src.data<0>()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
+					zcc_errors.inc_error();
+					// XXX may not behave well on trapping-int hosts XXX
+					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+					}
+				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
+				//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
 				INC_INFORM(WARN_STR);
 				INFORM("unreferenceable anonymous class declaration");

Added: trunk/tests/zcc/decl.C99/Error_struct_anon_def_const.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_anon_def_const.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_anon_def_const.hpp	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Error_struct_anon_def_const.hpp
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+const struct {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_struct_anon_def_const2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_anon_def_const2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_anon_def_const2.hpp	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Error_struct_anon_def_const2.hpp
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct {
+	int x_factor;
+} const;
+

Added: trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile.hpp	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Error_struct_anon_def_const_volatile.hpp
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+const volatile struct {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile2.hpp	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Error_struct_anon_def_const_volatile2.hpp
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+volatile const struct {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile3.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile3.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile3.hpp	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Error_struct_anon_def_const_volatile3.hpp
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+const struct {
+	int x_factor;
+} volatile;
+

Added: trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile4.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile4.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile4.hpp	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Error_struct_anon_def_const_volatile4.hpp
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+volatile struct {
+	int x_factor;
+} const;
+

Added: trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile5.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile5.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile5.hpp	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Error_struct_anon_def_const_volatile5.hpp
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct {
+	int x_factor;
+} const volatile;
+

Added: trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile6.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile6.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_anon_def_const_volatile6.hpp	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Error_struct_anon_def_const_volatile6.hpp
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct {
+	int x_factor;
+} volatile const;
+

Added: trunk/tests/zcc/decl.C99/Error_struct_anon_def_volatile.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_anon_def_volatile.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_anon_def_volatile.hpp	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Error_struct_anon_def_volatile.hpp
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+volatile struct {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Error_struct_anon_def_volatile2.hpp
===================================================================
--- trunk/tests/zcc/decl.C99/Error_struct_anon_def_volatile2.hpp	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Error_struct_anon_def_volatile2.hpp	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Error_struct_anon_def_volatile2.hpp
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct {
+	int x_factor;
+} volatile;
+

Added: trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const.h	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_struct_anon_def_const.h
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+const struct {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const2.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const2.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const2.h	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_struct_anon_def_const2.h
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct {
+	int x_factor;
+} const;
+

Added: trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile.h	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_struct_anon_def_const_volatile.h
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+const volatile struct {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile2.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile2.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile2.h	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_struct_anon_def_const_volatile2.h
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+volatile const struct {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile3.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile3.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile3.h	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_struct_anon_def_const_volatile3.h
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+const struct {
+	int x_factor;
+} volatile;
+

Added: trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile4.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile4.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile4.h	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_struct_anon_def_const_volatile4.h
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+volatile struct {
+	int x_factor;
+} const;
+

Added: trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile5.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile5.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile5.h	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_struct_anon_def_const_volatile5.h
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct {
+	int x_factor;
+} const volatile;
+

Added: trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile6.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile6.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_struct_anon_def_const_volatile6.h	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_struct_anon_def_const_volatile6.h
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct {
+	int x_factor;
+} volatile const;
+

Added: trunk/tests/zcc/decl.C99/Warn_struct_anon_def_volatile.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_struct_anon_def_volatile.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_struct_anon_def_volatile.h	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_struct_anon_def_volatile.h
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+volatile struct {
+	int x_factor;
+};
+

Added: trunk/tests/zcc/decl.C99/Warn_struct_anon_def_volatile2.h
===================================================================
--- trunk/tests/zcc/decl.C99/Warn_struct_anon_def_volatile2.h	                        (rev 0)
+++ trunk/tests/zcc/decl.C99/Warn_struct_anon_def_volatile2.h	2010-10-26 03:45:40 UTC (rev 504)
@@ -0,0 +1,8 @@
+// decl.C99\Warn_struct_anon_def_volatile2.h
+// using singly defined struct
+// (C)2010 Kenneth Boyd, license: MIT.txt
+
+struct {
+	int x_factor;
+} volatile;
+



From zaimoni at mail.berlios.de  Tue Oct 26 22:02:11 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Tue, 26 Oct 2010 22:02:11 +0200
Subject: [Zcplusplus-commits] r505 - trunk
Message-ID: <20101026200212.958E7480E64@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-26 22:02:11 +0200 (Tue, 26 Oct 2010)
New Revision: 505

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
object file size reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-26 03:45:40 UTC (rev 504)
+++ trunk/CSupport.cpp	2010-10-26 20:02:11 UTC (rev 505)
@@ -13775,6 +13775,19 @@
 	return false;
 }
 
+static void CPP0X_flush_const_volatile_without_object(parse_tree& src)
+{
+	if ((type_spec::_const | type_spec::_volatile) & src.type_code.q_vector.back())
+		{
+		message_header(src.index_tokens[0]);
+		INC_INFORM(ERR_STR);
+		INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
+		zcc_errors.inc_error();
+		// XXX may not behave well on trapping-int hosts XXX
+		src.type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+		}
+}
+
 // handle namespaces or else
 //! \todo check that the fact all literals are already legal-form is used
 //! \throw std::bad_alloc
@@ -13844,34 +13857,27 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_union_forward_def_const.hpp
-						//! \test decl.C99/Error_union_forward_def_const2.hpp
-						//! \test decl.C99/Error_union_forward_def_const3.hpp
-						//! \test decl.C99/Error_union_forward_def_const4.hpp
-						//! \test decl.C99/Error_union_forward_def_volatile.hpp
-						//! \test decl.C99/Error_union_forward_def_volatile2.hpp
-						//! \test decl.C99/Error_union_forward_def_volatile3.hpp
-						//! \test decl.C99/Error_union_forward_def_volatile4.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile2.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile3.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile4.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile5.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile6.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile7.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile8.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile9.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile10.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile11.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile12.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_union_forward_def_const.hpp
+				//! \test decl.C99/Error_union_forward_def_const2.hpp
+				//! \test decl.C99/Error_union_forward_def_const3.hpp
+				//! \test decl.C99/Error_union_forward_def_const4.hpp
+				//! \test decl.C99/Error_union_forward_def_volatile.hpp
+				//! \test decl.C99/Error_union_forward_def_volatile2.hpp
+				//! \test decl.C99/Error_union_forward_def_volatile3.hpp
+				//! \test decl.C99/Error_union_forward_def_volatile4.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile2.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile3.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile4.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile5.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile6.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile7.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile8.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile9.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile10.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile11.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile12.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				if (tmp)
 					{	// but if already (forward-)declared then this is a no-op
 						// think this is common enough to not warrant OAOO/DRY treatment
@@ -13920,34 +13926,27 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_struct_forward_def_const.hpp
-						//! \test decl.C99/Error_struct_forward_def_const2.hpp
-						//! \test decl.C99/Error_struct_forward_def_const3.hpp
-						//! \test decl.C99/Error_struct_forward_def_const4.hpp
-						//! \test decl.C99/Error_struct_forward_def_volatile.hpp
-						//! \test decl.C99/Error_struct_forward_def_volatile2.hpp
-						//! \test decl.C99/Error_struct_forward_def_volatile3.hpp
-						//! \test decl.C99/Error_struct_forward_def_volatile4.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile2.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile3.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile4.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile5.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile6.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile7.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile8.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile9.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile10.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile11.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile12.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_struct_forward_def_const.hpp
+				//! \test decl.C99/Error_struct_forward_def_const2.hpp
+				//! \test decl.C99/Error_struct_forward_def_const3.hpp
+				//! \test decl.C99/Error_struct_forward_def_const4.hpp
+				//! \test decl.C99/Error_struct_forward_def_volatile.hpp
+				//! \test decl.C99/Error_struct_forward_def_volatile2.hpp
+				//! \test decl.C99/Error_struct_forward_def_volatile3.hpp
+				//! \test decl.C99/Error_struct_forward_def_volatile4.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile2.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile3.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile4.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile5.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile6.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile7.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile8.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile9.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile10.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile11.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile12.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				if (tmp)
 					{	// but if already (forward-)declared then this is a no-op
 						// think this is common enough to not warrant OAOO/DRY treatment
@@ -13997,34 +13996,27 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_class_forward_def_const.hpp
-						//! \test decl.C99/Error_class_forward_def_const2.hpp
-						//! \test decl.C99/Error_class_forward_def_const3.hpp
-						//! \test decl.C99/Error_class_forward_def_const4.hpp
-						//! \test decl.C99/Error_class_forward_def_volatile.hpp
-						//! \test decl.C99/Error_class_forward_def_volatile2.hpp
-						//! \test decl.C99/Error_class_forward_def_volatile3.hpp
-						//! \test decl.C99/Error_class_forward_def_volatile4.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile2.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile3.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile4.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile5.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile6.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile7.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile8.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile9.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile10.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile11.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile12.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_class_forward_def_const.hpp
+				//! \test decl.C99/Error_class_forward_def_const2.hpp
+				//! \test decl.C99/Error_class_forward_def_const3.hpp
+				//! \test decl.C99/Error_class_forward_def_const4.hpp
+				//! \test decl.C99/Error_class_forward_def_volatile.hpp
+				//! \test decl.C99/Error_class_forward_def_volatile2.hpp
+				//! \test decl.C99/Error_class_forward_def_volatile3.hpp
+				//! \test decl.C99/Error_class_forward_def_volatile4.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile2.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile3.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile4.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile5.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile6.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile7.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile8.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile9.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile10.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile11.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile12.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				if (tmp)
 					{	// but if already (forward-)declared then this is a no-op
 						// think this is common enough to not warrant OAOO/DRY treatment
@@ -14098,24 +14090,17 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_union_def_const.hpp
-						//! \test decl.C99/Error_union_def_const2.hpp
-						//! \test decl.C99/Error_union_def_volatile.hpp
-						//! \test decl.C99/Error_union_def_volatile2.hpp
-						//! \test decl.C99/Error_union_def_const_volatile.hpp
-						//! \test decl.C99/Error_union_def_const_volatile2.hpp
-						//! \test decl.C99/Error_union_def_const_volatile3.hpp
-						//! \test decl.C99/Error_union_def_const_volatile4.hpp
-						//! \test decl.C99/Error_union_def_const_volatile5.hpp
-						//! \test decl.C99/Error_union_def_const_volatile6.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_union_def_const.hpp
+				//! \test decl.C99/Error_union_def_const2.hpp
+				//! \test decl.C99/Error_union_def_volatile.hpp
+				//! \test decl.C99/Error_union_def_volatile2.hpp
+				//! \test decl.C99/Error_union_def_const_volatile.hpp
+				//! \test decl.C99/Error_union_def_const_volatile2.hpp
+				//! \test decl.C99/Error_union_def_const_volatile3.hpp
+				//! \test decl.C99/Error_union_def_const_volatile4.hpp
+				//! \test decl.C99/Error_union_def_const_volatile5.hpp
+				//! \test decl.C99/Error_union_def_const_volatile6.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				// accept definition
 				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 				i += 2;
@@ -14172,24 +14157,17 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_struct_def_const.hpp
-						//! \test decl.C99/Error_struct_def_const2.hpp
-						//! \test decl.C99/Error_struct_def_volatile.hpp
-						//! \test decl.C99/Error_struct_def_volatile2.hpp
-						//! \test decl.C99/Error_struct_def_const_volatile.hpp
-						//! \test decl.C99/Error_struct_def_const_volatile2.hpp
-						//! \test decl.C99/Error_struct_def_const_volatile3.hpp
-						//! \test decl.C99/Error_struct_def_const_volatile4.hpp
-						//! \test decl.C99/Error_struct_def_const_volatile5.hpp
-						//! \test decl.C99/Error_struct_def_const_volatile6.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_struct_def_const.hpp
+				//! \test decl.C99/Error_struct_def_const2.hpp
+				//! \test decl.C99/Error_struct_def_volatile.hpp
+				//! \test decl.C99/Error_struct_def_volatile2.hpp
+				//! \test decl.C99/Error_struct_def_const_volatile.hpp
+				//! \test decl.C99/Error_struct_def_const_volatile2.hpp
+				//! \test decl.C99/Error_struct_def_const_volatile3.hpp
+				//! \test decl.C99/Error_struct_def_const_volatile4.hpp
+				//! \test decl.C99/Error_struct_def_const_volatile5.hpp
+				//! \test decl.C99/Error_struct_def_const_volatile6.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				// accept definition
 				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 				i += 2;
@@ -14246,24 +14224,17 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_class_def_const.hpp
-						//! \test decl.C99/Error_class_def_const2.hpp
-						//! \test decl.C99/Error_class_def_volatile.hpp
-						//! \test decl.C99/Error_class_def_volatile2.hpp
-						//! \test decl.C99/Error_class_def_const_volatile.hpp
-						//! \test decl.C99/Error_class_def_const_volatile2.hpp
-						//! \test decl.C99/Error_class_def_const_volatile3.hpp
-						//! \test decl.C99/Error_class_def_const_volatile4.hpp
-						//! \test decl.C99/Error_class_def_const_volatile5.hpp
-						//! \test decl.C99/Error_class_def_const_volatile6.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_class_def_const.hpp
+				//! \test decl.C99/Error_class_def_const2.hpp
+				//! \test decl.C99/Error_class_def_volatile.hpp
+				//! \test decl.C99/Error_class_def_volatile2.hpp
+				//! \test decl.C99/Error_class_def_const_volatile.hpp
+				//! \test decl.C99/Error_class_def_const_volatile2.hpp
+				//! \test decl.C99/Error_class_def_const_volatile3.hpp
+				//! \test decl.C99/Error_class_def_const_volatile4.hpp
+				//! \test decl.C99/Error_class_def_const_volatile5.hpp
+				//! \test decl.C99/Error_class_def_const_volatile6.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				// accept definition
 				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
 				i += 2;
@@ -14293,24 +14264,17 @@
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_union_anon_def_const.hpp
-						//! \test decl.C99/Error_union_anon_def_const2.hpp
-						//! \test decl.C99/Error_union_anon_def_volatile.hpp
-						//! \test decl.C99/Error_union_anon_def_volatile2.hpp
-						//! \test decl.C99/Error_union_anon_def_const_volatile.hpp
-						//! \test decl.C99/Error_union_anon_def_const_volatile2.hpp
-						//! \test decl.C99/Error_union_anon_def_const_volatile3.hpp
-						//! \test decl.C99/Error_union_anon_def_const_volatile4.hpp
-						//! \test decl.C99/Error_union_anon_def_const_volatile5.hpp
-						//! \test decl.C99/Error_union_anon_def_const_volatile6.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_union_anon_def_const.hpp
+				//! \test decl.C99/Error_union_anon_def_const2.hpp
+				//! \test decl.C99/Error_union_anon_def_volatile.hpp
+				//! \test decl.C99/Error_union_anon_def_volatile2.hpp
+				//! \test decl.C99/Error_union_anon_def_const_volatile.hpp
+				//! \test decl.C99/Error_union_anon_def_const_volatile2.hpp
+				//! \test decl.C99/Error_union_anon_def_const_volatile3.hpp
+				//! \test decl.C99/Error_union_anon_def_const_volatile4.hpp
+				//! \test decl.C99/Error_union_anon_def_const_volatile5.hpp
+				//! \test decl.C99/Error_union_anon_def_const_volatile6.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 				//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -14344,24 +14308,17 @@
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_struct_anon_def_const.hpp
-						//! \test decl.C99/Error_struct_anon_def_const2.hpp
-						//! \test decl.C99/Error_struct_anon_def_volatile.hpp
-						//! \test decl.C99/Error_struct_anon_def_volatile2.hpp
-						//! \test decl.C99/Error_struct_anon_def_const_volatile.hpp
-						//! \test decl.C99/Error_struct_anon_def_const_volatile2.hpp
-						//! \test decl.C99/Error_struct_anon_def_const_volatile3.hpp
-						//! \test decl.C99/Error_struct_anon_def_const_volatile4.hpp
-						//! \test decl.C99/Error_struct_anon_def_const_volatile5.hpp
-						//! \test decl.C99/Error_struct_anon_def_const_volatile6.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_struct_anon_def_const.hpp
+				//! \test decl.C99/Error_struct_anon_def_const2.hpp
+				//! \test decl.C99/Error_struct_anon_def_volatile.hpp
+				//! \test decl.C99/Error_struct_anon_def_volatile2.hpp
+				//! \test decl.C99/Error_struct_anon_def_const_volatile.hpp
+				//! \test decl.C99/Error_struct_anon_def_const_volatile2.hpp
+				//! \test decl.C99/Error_struct_anon_def_const_volatile3.hpp
+				//! \test decl.C99/Error_struct_anon_def_const_volatile4.hpp
+				//! \test decl.C99/Error_struct_anon_def_const_volatile5.hpp
+				//! \test decl.C99/Error_struct_anon_def_const_volatile6.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 				//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -14395,24 +14352,17 @@
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_class_anon_def_const.hpp
-						//! \test decl.C99/Error_class_anon_def_const2.hpp
-						//! \test decl.C99/Error_class_anon_def_volatile.hpp
-						//! \test decl.C99/Error_class_anon_def_volatile2.hpp
-						//! \test decl.C99/Error_class_anon_def_const_volatile.hpp
-						//! \test decl.C99/Error_class_anon_def_const_volatile2.hpp
-						//! \test decl.C99/Error_class_anon_def_const_volatile3.hpp
-						//! \test decl.C99/Error_class_anon_def_const_volatile4.hpp
-						//! \test decl.C99/Error_class_anon_def_const_volatile5.hpp
-						//! \test decl.C99/Error_class_anon_def_const_volatile6.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_class_anon_def_const.hpp
+				//! \test decl.C99/Error_class_anon_def_const2.hpp
+				//! \test decl.C99/Error_class_anon_def_volatile.hpp
+				//! \test decl.C99/Error_class_anon_def_volatile2.hpp
+				//! \test decl.C99/Error_class_anon_def_const_volatile.hpp
+				//! \test decl.C99/Error_class_anon_def_const_volatile2.hpp
+				//! \test decl.C99/Error_class_anon_def_const_volatile3.hpp
+				//! \test decl.C99/Error_class_anon_def_const_volatile4.hpp
+				//! \test decl.C99/Error_class_anon_def_const_volatile5.hpp
+				//! \test decl.C99/Error_class_anon_def_const_volatile6.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 				//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-26 03:45:40 UTC (rev 504)
+++ trunk/CSupport.cpp.in	2010-10-26 20:02:11 UTC (rev 505)
@@ -13914,6 +13914,19 @@
 	return false;
 }
 
+static void CPP0X_flush_const_volatile_without_object(parse_tree& src)
+{
+	if ((type_spec::_const | type_spec::_volatile) & src.type_code.q_vector.back())
+		{
+		message_header(src.index_tokens[0]);
+		INC_INFORM(ERR_STR);
+		INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
+		zcc_errors.inc_error();
+		// XXX may not behave well on trapping-int hosts XXX
+		src.type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+		}
+}
+
 // handle namespaces or else
 //! \todo check that the fact all literals are already legal-form is used
 //! \throw std::bad_alloc
@@ -13983,34 +13996,27 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_union_forward_def_const.hpp
-						//! \test decl.C99/Error_union_forward_def_const2.hpp
-						//! \test decl.C99/Error_union_forward_def_const3.hpp
-						//! \test decl.C99/Error_union_forward_def_const4.hpp
-						//! \test decl.C99/Error_union_forward_def_volatile.hpp
-						//! \test decl.C99/Error_union_forward_def_volatile2.hpp
-						//! \test decl.C99/Error_union_forward_def_volatile3.hpp
-						//! \test decl.C99/Error_union_forward_def_volatile4.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile2.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile3.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile4.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile5.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile6.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile7.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile8.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile9.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile10.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile11.hpp
-						//! \test decl.C99/Error_union_forward_def_const_volatile12.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_union_forward_def_const.hpp
+				//! \test decl.C99/Error_union_forward_def_const2.hpp
+				//! \test decl.C99/Error_union_forward_def_const3.hpp
+				//! \test decl.C99/Error_union_forward_def_const4.hpp
+				//! \test decl.C99/Error_union_forward_def_volatile.hpp
+				//! \test decl.C99/Error_union_forward_def_volatile2.hpp
+				//! \test decl.C99/Error_union_forward_def_volatile3.hpp
+				//! \test decl.C99/Error_union_forward_def_volatile4.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile2.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile3.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile4.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile5.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile6.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile7.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile8.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile9.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile10.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile11.hpp
+				//! \test decl.C99/Error_union_forward_def_const_volatile12.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				if (tmp)
 					{	// but if already (forward-)declared then this is a no-op
 						// think this is common enough to not warrant OAOO/DRY treatment
@@ -14059,34 +14065,27 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_struct_forward_def_const.hpp
-						//! \test decl.C99/Error_struct_forward_def_const2.hpp
-						//! \test decl.C99/Error_struct_forward_def_const3.hpp
-						//! \test decl.C99/Error_struct_forward_def_const4.hpp
-						//! \test decl.C99/Error_struct_forward_def_volatile.hpp
-						//! \test decl.C99/Error_struct_forward_def_volatile2.hpp
-						//! \test decl.C99/Error_struct_forward_def_volatile3.hpp
-						//! \test decl.C99/Error_struct_forward_def_volatile4.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile2.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile3.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile4.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile5.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile6.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile7.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile8.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile9.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile10.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile11.hpp
-						//! \test decl.C99/Error_struct_forward_def_const_volatile12.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_struct_forward_def_const.hpp
+				//! \test decl.C99/Error_struct_forward_def_const2.hpp
+				//! \test decl.C99/Error_struct_forward_def_const3.hpp
+				//! \test decl.C99/Error_struct_forward_def_const4.hpp
+				//! \test decl.C99/Error_struct_forward_def_volatile.hpp
+				//! \test decl.C99/Error_struct_forward_def_volatile2.hpp
+				//! \test decl.C99/Error_struct_forward_def_volatile3.hpp
+				//! \test decl.C99/Error_struct_forward_def_volatile4.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile2.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile3.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile4.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile5.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile6.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile7.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile8.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile9.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile10.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile11.hpp
+				//! \test decl.C99/Error_struct_forward_def_const_volatile12.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				if (tmp)
 					{	// but if already (forward-)declared then this is a no-op
 						// think this is common enough to not warrant OAOO/DRY treatment
@@ -14136,34 +14135,27 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_class_forward_def_const.hpp
-						//! \test decl.C99/Error_class_forward_def_const2.hpp
-						//! \test decl.C99/Error_class_forward_def_const3.hpp
-						//! \test decl.C99/Error_class_forward_def_const4.hpp
-						//! \test decl.C99/Error_class_forward_def_volatile.hpp
-						//! \test decl.C99/Error_class_forward_def_volatile2.hpp
-						//! \test decl.C99/Error_class_forward_def_volatile3.hpp
-						//! \test decl.C99/Error_class_forward_def_volatile4.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile2.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile3.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile4.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile5.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile6.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile7.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile8.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile9.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile10.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile11.hpp
-						//! \test decl.C99/Error_class_forward_def_const_volatile12.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_class_forward_def_const.hpp
+				//! \test decl.C99/Error_class_forward_def_const2.hpp
+				//! \test decl.C99/Error_class_forward_def_const3.hpp
+				//! \test decl.C99/Error_class_forward_def_const4.hpp
+				//! \test decl.C99/Error_class_forward_def_volatile.hpp
+				//! \test decl.C99/Error_class_forward_def_volatile2.hpp
+				//! \test decl.C99/Error_class_forward_def_volatile3.hpp
+				//! \test decl.C99/Error_class_forward_def_volatile4.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile2.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile3.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile4.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile5.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile6.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile7.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile8.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile9.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile10.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile11.hpp
+				//! \test decl.C99/Error_class_forward_def_const_volatile12.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				if (tmp)
 					{	// but if already (forward-)declared then this is a no-op
 						// think this is common enough to not warrant OAOO/DRY treatment
@@ -14237,24 +14229,17 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_union_def_const.hpp
-						//! \test decl.C99/Error_union_def_const2.hpp
-						//! \test decl.C99/Error_union_def_volatile.hpp
-						//! \test decl.C99/Error_union_def_volatile2.hpp
-						//! \test decl.C99/Error_union_def_const_volatile.hpp
-						//! \test decl.C99/Error_union_def_const_volatile2.hpp
-						//! \test decl.C99/Error_union_def_const_volatile3.hpp
-						//! \test decl.C99/Error_union_def_const_volatile4.hpp
-						//! \test decl.C99/Error_union_def_const_volatile5.hpp
-						//! \test decl.C99/Error_union_def_const_volatile6.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_union_def_const.hpp
+				//! \test decl.C99/Error_union_def_const2.hpp
+				//! \test decl.C99/Error_union_def_volatile.hpp
+				//! \test decl.C99/Error_union_def_volatile2.hpp
+				//! \test decl.C99/Error_union_def_const_volatile.hpp
+				//! \test decl.C99/Error_union_def_const_volatile2.hpp
+				//! \test decl.C99/Error_union_def_const_volatile3.hpp
+				//! \test decl.C99/Error_union_def_const_volatile4.hpp
+				//! \test decl.C99/Error_union_def_const_volatile5.hpp
+				//! \test decl.C99/Error_union_def_const_volatile6.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				// accept definition
 				//! \test zcc/decl.C99/Pass_union_forward_def.hpp
 				i += 2;
@@ -14311,24 +14296,17 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_struct_def_const.hpp
-						//! \test decl.C99/Error_struct_def_const2.hpp
-						//! \test decl.C99/Error_struct_def_volatile.hpp
-						//! \test decl.C99/Error_struct_def_volatile2.hpp
-						//! \test decl.C99/Error_struct_def_const_volatile.hpp
-						//! \test decl.C99/Error_struct_def_const_volatile2.hpp
-						//! \test decl.C99/Error_struct_def_const_volatile3.hpp
-						//! \test decl.C99/Error_struct_def_const_volatile4.hpp
-						//! \test decl.C99/Error_struct_def_const_volatile5.hpp
-						//! \test decl.C99/Error_struct_def_const_volatile6.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_struct_def_const.hpp
+				//! \test decl.C99/Error_struct_def_const2.hpp
+				//! \test decl.C99/Error_struct_def_volatile.hpp
+				//! \test decl.C99/Error_struct_def_volatile2.hpp
+				//! \test decl.C99/Error_struct_def_const_volatile.hpp
+				//! \test decl.C99/Error_struct_def_const_volatile2.hpp
+				//! \test decl.C99/Error_struct_def_const_volatile3.hpp
+				//! \test decl.C99/Error_struct_def_const_volatile4.hpp
+				//! \test decl.C99/Error_struct_def_const_volatile5.hpp
+				//! \test decl.C99/Error_struct_def_const_volatile6.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				// accept definition
 				//! \test zcc/decl.C99/Pass_struct_forward_def.hpp
 				i += 2;
@@ -14385,24 +14363,17 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_class_def_const.hpp
-						//! \test decl.C99/Error_class_def_const2.hpp
-						//! \test decl.C99/Error_class_def_volatile.hpp
-						//! \test decl.C99/Error_class_def_volatile2.hpp
-						//! \test decl.C99/Error_class_def_const_volatile.hpp
-						//! \test decl.C99/Error_class_def_const_volatile2.hpp
-						//! \test decl.C99/Error_class_def_const_volatile3.hpp
-						//! \test decl.C99/Error_class_def_const_volatile4.hpp
-						//! \test decl.C99/Error_class_def_const_volatile5.hpp
-						//! \test decl.C99/Error_class_def_const_volatile6.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_class_def_const.hpp
+				//! \test decl.C99/Error_class_def_const2.hpp
+				//! \test decl.C99/Error_class_def_volatile.hpp
+				//! \test decl.C99/Error_class_def_volatile2.hpp
+				//! \test decl.C99/Error_class_def_const_volatile.hpp
+				//! \test decl.C99/Error_class_def_const_volatile2.hpp
+				//! \test decl.C99/Error_class_def_const_volatile3.hpp
+				//! \test decl.C99/Error_class_def_const_volatile4.hpp
+				//! \test decl.C99/Error_class_def_const_volatile5.hpp
+				//! \test decl.C99/Error_class_def_const_volatile6.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				// accept definition
 				//! \test zcc/decl.C99/Pass_class_forward_def.hpp
 				i += 2;
@@ -14432,24 +14403,17 @@
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_union_anon_def_const.hpp
-						//! \test decl.C99/Error_union_anon_def_const2.hpp
-						//! \test decl.C99/Error_union_anon_def_volatile.hpp
-						//! \test decl.C99/Error_union_anon_def_volatile2.hpp
-						//! \test decl.C99/Error_union_anon_def_const_volatile.hpp
-						//! \test decl.C99/Error_union_anon_def_const_volatile2.hpp
-						//! \test decl.C99/Error_union_anon_def_const_volatile3.hpp
-						//! \test decl.C99/Error_union_anon_def_const_volatile4.hpp
-						//! \test decl.C99/Error_union_anon_def_const_volatile5.hpp
-						//! \test decl.C99/Error_union_anon_def_const_volatile6.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_union_anon_def_const.hpp
+				//! \test decl.C99/Error_union_anon_def_const2.hpp
+				//! \test decl.C99/Error_union_anon_def_volatile.hpp
+				//! \test decl.C99/Error_union_anon_def_volatile2.hpp
+				//! \test decl.C99/Error_union_anon_def_const_volatile.hpp
+				//! \test decl.C99/Error_union_anon_def_const_volatile2.hpp
+				//! \test decl.C99/Error_union_anon_def_const_volatile3.hpp
+				//! \test decl.C99/Error_union_anon_def_const_volatile4.hpp
+				//! \test decl.C99/Error_union_anon_def_const_volatile5.hpp
+				//! \test decl.C99/Error_union_anon_def_const_volatile6.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 				//! \test zcc/decl.C99/Warn_inaccessible_union.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -14483,24 +14447,17 @@
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_struct_anon_def_const.hpp
-						//! \test decl.C99/Error_struct_anon_def_const2.hpp
-						//! \test decl.C99/Error_struct_anon_def_volatile.hpp
-						//! \test decl.C99/Error_struct_anon_def_volatile2.hpp
-						//! \test decl.C99/Error_struct_anon_def_const_volatile.hpp
-						//! \test decl.C99/Error_struct_anon_def_const_volatile2.hpp
-						//! \test decl.C99/Error_struct_anon_def_const_volatile3.hpp
-						//! \test decl.C99/Error_struct_anon_def_const_volatile4.hpp
-						//! \test decl.C99/Error_struct_anon_def_const_volatile5.hpp
-						//! \test decl.C99/Error_struct_anon_def_const_volatile6.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_struct_anon_def_const.hpp
+				//! \test decl.C99/Error_struct_anon_def_const2.hpp
+				//! \test decl.C99/Error_struct_anon_def_volatile.hpp
+				//! \test decl.C99/Error_struct_anon_def_volatile2.hpp
+				//! \test decl.C99/Error_struct_anon_def_const_volatile.hpp
+				//! \test decl.C99/Error_struct_anon_def_const_volatile2.hpp
+				//! \test decl.C99/Error_struct_anon_def_const_volatile3.hpp
+				//! \test decl.C99/Error_struct_anon_def_const_volatile4.hpp
+				//! \test decl.C99/Error_struct_anon_def_const_volatile5.hpp
+				//! \test decl.C99/Error_struct_anon_def_const_volatile6.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 				//! \test zcc/decl.C99/Warn_inaccessible_struct.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -14534,24 +14491,17 @@
 			if (	1<src.size<0>()-i
 				&& 	robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Error_class_anon_def_const.hpp
-						//! \test decl.C99/Error_class_anon_def_const2.hpp
-						//! \test decl.C99/Error_class_anon_def_volatile.hpp
-						//! \test decl.C99/Error_class_anon_def_volatile2.hpp
-						//! \test decl.C99/Error_class_anon_def_const_volatile.hpp
-						//! \test decl.C99/Error_class_anon_def_const_volatile2.hpp
-						//! \test decl.C99/Error_class_anon_def_const_volatile3.hpp
-						//! \test decl.C99/Error_class_anon_def_const_volatile4.hpp
-						//! \test decl.C99/Error_class_anon_def_const_volatile5.hpp
-						//! \test decl.C99/Error_class_anon_def_const_volatile6.hpp
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(ERR_STR);
-					INFORM("const/volatile qualification must apply to an object (C++0X 7.1.6.1p1)");
-					zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					}
+				//! \test decl.C99/Error_class_anon_def_const.hpp
+				//! \test decl.C99/Error_class_anon_def_const2.hpp
+				//! \test decl.C99/Error_class_anon_def_volatile.hpp
+				//! \test decl.C99/Error_class_anon_def_volatile2.hpp
+				//! \test decl.C99/Error_class_anon_def_const_volatile.hpp
+				//! \test decl.C99/Error_class_anon_def_const_volatile2.hpp
+				//! \test decl.C99/Error_class_anon_def_const_volatile3.hpp
+				//! \test decl.C99/Error_class_anon_def_const_volatile4.hpp
+				//! \test decl.C99/Error_class_anon_def_const_volatile5.hpp
+				//! \test decl.C99/Error_class_anon_def_const_volatile6.hpp
+				CPP0X_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 				//! \test zcc/decl.C99/Warn_inaccessible_class.hpp
 				message_header(src.data<0>()[i].index_tokens[0]);



From zaimoni at mail.berlios.de  Wed Oct 27 03:12:51 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Wed, 27 Oct 2010 03:12:51 +0200
Subject: [Zcplusplus-commits] r506 - trunk
Message-ID: <20101027011251.BD1EF480E7E@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-27 03:12:51 +0200 (Wed, 27 Oct 2010)
New Revision: 506

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
object file size reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-26 20:02:11 UTC (rev 505)
+++ trunk/CSupport.cpp	2010-10-27 01:12:51 UTC (rev 506)
@@ -12918,6 +12918,22 @@
 	return true;
 }
 
+static void C99_flush_const_volatile_without_object(parse_tree& src)
+{	//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
+	if ((type_spec::_const | type_spec::_volatile) & src.type_code.q_vector.back())
+		{
+		message_header(src.index_tokens[0]);
+		INC_INFORM(WARN_STR);
+		INFORM("useless const/volatile qualification of a forward-declaration (C99 6.7.3p3)");
+		if (bool_options[boolopt::warn_crosslang_compatibility])
+			INFORM("(error in C++: C++0X 7.1.6.1p1)");
+		if (bool_options[boolopt::warnings_are_errors])
+			zcc_errors.inc_error();
+		// XXX may not behave well on trapping-int hosts XXX
+		src.type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+		};
+}
+
 // will need: "function-type vector"
 // return: 1 typespec record (for now, other languages may have more demanding requirements)
 // incoming: n typespec records, flag for trailing ...
@@ -12980,38 +12996,27 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here (C99 6.7.2.3)
-				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Warn_union_forward_def_const.h
-						//! \test decl.C99/Warn_union_forward_def_const2.h
-						//! \test decl.C99/Warn_union_forward_def_const3.h
-						//! \test decl.C99/Warn_union_forward_def_const4.h
-						//! \test decl.C99/Warn_union_forward_def_volatile.h
-						//! \test decl.C99/Warn_union_forward_def_volatile2.h
-						//! \test decl.C99/Warn_union_forward_def_volatile3.h
-						//! \test decl.C99/Warn_union_forward_def_volatile4.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile2.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile3.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile4.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile5.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile6.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile7.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile8.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile9.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile10.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile11.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile12.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("useless const/volatile qualification of a forward-declaration (C99 6.7.3p3)");
-					if (bool_options[boolopt::warn_crosslang_compatibility])
-						INFORM("(error in C++: C++0X 7.1.6.1p1)");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					};
+				//! \test decl.C99/Warn_union_forward_def_const.h
+				//! \test decl.C99/Warn_union_forward_def_const2.h
+				//! \test decl.C99/Warn_union_forward_def_const3.h
+				//! \test decl.C99/Warn_union_forward_def_const4.h
+				//! \test decl.C99/Warn_union_forward_def_volatile.h
+				//! \test decl.C99/Warn_union_forward_def_volatile2.h
+				//! \test decl.C99/Warn_union_forward_def_volatile3.h
+				//! \test decl.C99/Warn_union_forward_def_volatile4.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile2.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile3.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile4.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile5.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile6.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile7.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile8.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile9.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile10.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile11.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile12.h
+				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				if (tmp)
 					{	// but if already (forward-)declared then this is a no-op
 						// think this is common enough to not warrant OAOO/DRY treatment
@@ -13061,38 +13066,27 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here (C99 6.7.2.3)
-				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Warn_struct_forward_def_const.h
-						//! \test decl.C99/Warn_struct_forward_def_const2.h
-						//! \test decl.C99/Warn_struct_forward_def_const3.h
-						//! \test decl.C99/Warn_struct_forward_def_const4.h
-						//! \test decl.C99/Warn_struct_forward_def_volatile.h
-						//! \test decl.C99/Warn_struct_forward_def_volatile2.h
-						//! \test decl.C99/Warn_struct_forward_def_volatile3.h
-						//! \test decl.C99/Warn_struct_forward_def_volatile4.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile2.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile3.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile4.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile5.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile6.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile7.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile8.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile9.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile10.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile11.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile12.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("useless const/volatile qualification of a forward-declaration (C99 6.7.3p3)");
-					if (bool_options[boolopt::warn_crosslang_compatibility])
-						INFORM("(error in C++: C++0X 7.1.6.1p1)");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					};
+				//! \test decl.C99/Warn_struct_forward_def_const.h
+				//! \test decl.C99/Warn_struct_forward_def_const2.h
+				//! \test decl.C99/Warn_struct_forward_def_const3.h
+				//! \test decl.C99/Warn_struct_forward_def_const4.h
+				//! \test decl.C99/Warn_struct_forward_def_volatile.h
+				//! \test decl.C99/Warn_struct_forward_def_volatile2.h
+				//! \test decl.C99/Warn_struct_forward_def_volatile3.h
+				//! \test decl.C99/Warn_struct_forward_def_volatile4.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile2.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile3.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile4.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile5.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile6.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile7.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile8.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile9.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile10.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile11.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile12.h
+				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				if (tmp)
 					{	// but if already (forward-)declared then this is a no-op
 						// think this is common enough to not warrant OAOO/DRY treatment
@@ -13166,28 +13160,17 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// no objects declared, trigger the const/volatile warnings
-				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Warn_union_def_const.h
-						//! \test decl.C99/Warn_union_def_const2.h
-						//! \test decl.C99/Warn_union_def_volatile.h
-						//! \test decl.C99/Warn_union_def_volatile2.h
-						//! \test decl.C99/Warn_union_def_const_volatile.h
-						//! \test decl.C99/Warn_union_def_const_volatile2.h
-						//! \test decl.C99/Warn_union_def_const_volatile3.h
-						//! \test decl.C99/Warn_union_def_const_volatile4.h
-						//! \test decl.C99/Warn_union_def_const_volatile5.h
-						//! \test decl.C99/Warn_union_def_const_volatile6.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("useless const/volatile qualification of a definition (C99 6.7.3p3)");
-					if (bool_options[boolopt::warn_crosslang_compatibility])
-						INFORM("(error in C++: C++0X 7.1.6.1p1)");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					};
+				//! \test decl.C99/Warn_union_def_const.h
+				//! \test decl.C99/Warn_union_def_const2.h
+				//! \test decl.C99/Warn_union_def_volatile.h
+				//! \test decl.C99/Warn_union_def_volatile2.h
+				//! \test decl.C99/Warn_union_def_const_volatile.h
+				//! \test decl.C99/Warn_union_def_const_volatile2.h
+				//! \test decl.C99/Warn_union_def_const_volatile3.h
+				//! \test decl.C99/Warn_union_def_const_volatile4.h
+				//! \test decl.C99/Warn_union_def_const_volatile5.h
+				//! \test decl.C99/Warn_union_def_const_volatile6.h
+				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				// accept definition
 				//! \test zcc/decl.C99/Pass_union_forward_def.h
 				i += 2;
@@ -13244,28 +13227,17 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// no objects declared, trigger the const/volatile warnings
-				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Warn_struct_def_const.h
-						//! \test decl.C99/Warn_struct_def_const2.h
-						//! \test decl.C99/Warn_struct_def_volatile.h
-						//! \test decl.C99/Warn_struct_def_volatile2.h
-						//! \test decl.C99/Warn_struct_def_const_volatile.h
-						//! \test decl.C99/Warn_struct_def_const_volatile2.h
-						//! \test decl.C99/Warn_struct_def_const_volatile3.h
-						//! \test decl.C99/Warn_struct_def_const_volatile4.h
-						//! \test decl.C99/Warn_struct_def_const_volatile5.h
-						//! \test decl.C99/Warn_struct_def_const_volatile6.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("useless const/volatile qualification of a definition (C99 6.7.3p3)");
-					if (bool_options[boolopt::warn_crosslang_compatibility])
-						INFORM("(error in C++: C++0X 7.1.6.1p1)");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					};
+				//! \test decl.C99/Warn_struct_def_const.h
+				//! \test decl.C99/Warn_struct_def_const2.h
+				//! \test decl.C99/Warn_struct_def_volatile.h
+				//! \test decl.C99/Warn_struct_def_volatile2.h
+				//! \test decl.C99/Warn_struct_def_const_volatile.h
+				//! \test decl.C99/Warn_struct_def_const_volatile2.h
+				//! \test decl.C99/Warn_struct_def_const_volatile3.h
+				//! \test decl.C99/Warn_struct_def_const_volatile4.h
+				//! \test decl.C99/Warn_struct_def_const_volatile5.h
+				//! \test decl.C99/Warn_struct_def_const_volatile6.h
+				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				// accept definition
 				//! \test zcc/decl.C99/Pass_union_forward_def.h
 				i += 2;
@@ -13294,28 +13266,17 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Warn_union_anon_def_const.h
-						//! \test decl.C99/Warn_union_anon_def_const2.h
-						//! \test decl.C99/Warn_union_anon_def_volatile.h
-						//! \test decl.C99/Warn_union_anon_def_volatile2.h
-						//! \test decl.C99/Warn_union_anon_def_const_volatile.h
-						//! \test decl.C99/Warn_union_anon_def_const_volatile2.h
-						//! \test decl.C99/Warn_union_anon_def_const_volatile3.h
-						//! \test decl.C99/Warn_union_anon_def_const_volatile4.h
-						//! \test decl.C99/Warn_union_anon_def_const_volatile5.h
-						//! \test decl.C99/Warn_union_anon_def_const_volatile6.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("useless const/volatile qualification of a definition (C99 6.7.3p3)");
-					if (bool_options[boolopt::warn_crosslang_compatibility])
-						INFORM("(error in C++: C++0X 7.1.6.1p1)");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					};
+				//! \test decl.C99/Warn_union_anon_def_const.h
+				//! \test decl.C99/Warn_union_anon_def_const2.h
+				//! \test decl.C99/Warn_union_anon_def_volatile.h
+				//! \test decl.C99/Warn_union_anon_def_volatile2.h
+				//! \test decl.C99/Warn_union_anon_def_const_volatile.h
+				//! \test decl.C99/Warn_union_anon_def_const_volatile2.h
+				//! \test decl.C99/Warn_union_anon_def_const_volatile3.h
+				//! \test decl.C99/Warn_union_anon_def_const_volatile4.h
+				//! \test decl.C99/Warn_union_anon_def_const_volatile5.h
+				//! \test decl.C99/Warn_union_anon_def_const_volatile6.h
+				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 				//! \test zcc/decl.C99/Warn_inaccessible_union.h
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -13350,28 +13311,17 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Warn_struct_anon_def_const.h
-						//! \test decl.C99/Warn_struct_anon_def_const2.h
-						//! \test decl.C99/Warn_struct_anon_def_volatile.h
-						//! \test decl.C99/Warn_struct_anon_def_volatile2.h
-						//! \test decl.C99/Warn_struct_anon_def_const_volatile.h
-						//! \test decl.C99/Warn_struct_anon_def_const_volatile2.h
-						//! \test decl.C99/Warn_struct_anon_def_const_volatile3.h
-						//! \test decl.C99/Warn_struct_anon_def_const_volatile4.h
-						//! \test decl.C99/Warn_struct_anon_def_const_volatile5.h
-						//! \test decl.C99/Warn_struct_anon_def_const_volatile6.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("useless const/volatile qualification of a definition (C99 6.7.3p3)");
-					if (bool_options[boolopt::warn_crosslang_compatibility])
-						INFORM("(error in C++: C++0X 7.1.6.1p1)");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					};
+				//! \test decl.C99/Warn_struct_anon_def_const.h
+				//! \test decl.C99/Warn_struct_anon_def_const2.h
+				//! \test decl.C99/Warn_struct_anon_def_volatile.h
+				//! \test decl.C99/Warn_struct_anon_def_volatile2.h
+				//! \test decl.C99/Warn_struct_anon_def_const_volatile.h
+				//! \test decl.C99/Warn_struct_anon_def_const_volatile2.h
+				//! \test decl.C99/Warn_struct_anon_def_const_volatile3.h
+				//! \test decl.C99/Warn_struct_anon_def_const_volatile4.h
+				//! \test decl.C99/Warn_struct_anon_def_const_volatile5.h
+				//! \test decl.C99/Warn_struct_anon_def_const_volatile6.h
+				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 				//! \test zcc/decl.C99/Warn_inaccessible_struct.h
 				message_header(src.data<0>()[i].index_tokens[0]);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-26 20:02:11 UTC (rev 505)
+++ trunk/CSupport.cpp.in	2010-10-27 01:12:51 UTC (rev 506)
@@ -13057,6 +13057,22 @@
 	return true;
 }
 
+static void C99_flush_const_volatile_without_object(parse_tree& src)
+{	//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
+	if ((type_spec::_const | type_spec::_volatile) & src.type_code.q_vector.back())
+		{
+		message_header(src.index_tokens[0]);
+		INC_INFORM(WARN_STR);
+		INFORM("useless const/volatile qualification of a forward-declaration (C99 6.7.3p3)");
+		if (bool_options[boolopt::warn_crosslang_compatibility])
+			INFORM("(error in C++: C++0X 7.1.6.1p1)");
+		if (bool_options[boolopt::warnings_are_errors])
+			zcc_errors.inc_error();
+		// XXX may not behave well on trapping-int hosts XXX
+		src.type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
+		};
+}
+
 // will need: "function-type vector"
 // return: 1 typespec record (for now, other languages may have more demanding requirements)
 // incoming: n typespec records, flag for trailing ...
@@ -13119,38 +13135,27 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here (C99 6.7.2.3)
-				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Warn_union_forward_def_const.h
-						//! \test decl.C99/Warn_union_forward_def_const2.h
-						//! \test decl.C99/Warn_union_forward_def_const3.h
-						//! \test decl.C99/Warn_union_forward_def_const4.h
-						//! \test decl.C99/Warn_union_forward_def_volatile.h
-						//! \test decl.C99/Warn_union_forward_def_volatile2.h
-						//! \test decl.C99/Warn_union_forward_def_volatile3.h
-						//! \test decl.C99/Warn_union_forward_def_volatile4.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile2.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile3.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile4.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile5.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile6.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile7.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile8.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile9.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile10.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile11.h
-						//! \test decl.C99/Warn_union_forward_def_const_volatile12.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("useless const/volatile qualification of a forward-declaration (C99 6.7.3p3)");
-					if (bool_options[boolopt::warn_crosslang_compatibility])
-						INFORM("(error in C++: C++0X 7.1.6.1p1)");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					};
+				//! \test decl.C99/Warn_union_forward_def_const.h
+				//! \test decl.C99/Warn_union_forward_def_const2.h
+				//! \test decl.C99/Warn_union_forward_def_const3.h
+				//! \test decl.C99/Warn_union_forward_def_const4.h
+				//! \test decl.C99/Warn_union_forward_def_volatile.h
+				//! \test decl.C99/Warn_union_forward_def_volatile2.h
+				//! \test decl.C99/Warn_union_forward_def_volatile3.h
+				//! \test decl.C99/Warn_union_forward_def_volatile4.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile2.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile3.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile4.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile5.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile6.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile7.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile8.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile9.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile10.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile11.h
+				//! \test decl.C99/Warn_union_forward_def_const_volatile12.h
+				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				if (tmp)
 					{	// but if already (forward-)declared then this is a no-op
 						// think this is common enough to not warrant OAOO/DRY treatment
@@ -13200,38 +13205,27 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// check for forward-declaration here (C99 6.7.2.3)
-				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Warn_struct_forward_def_const.h
-						//! \test decl.C99/Warn_struct_forward_def_const2.h
-						//! \test decl.C99/Warn_struct_forward_def_const3.h
-						//! \test decl.C99/Warn_struct_forward_def_const4.h
-						//! \test decl.C99/Warn_struct_forward_def_volatile.h
-						//! \test decl.C99/Warn_struct_forward_def_volatile2.h
-						//! \test decl.C99/Warn_struct_forward_def_volatile3.h
-						//! \test decl.C99/Warn_struct_forward_def_volatile4.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile2.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile3.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile4.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile5.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile6.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile7.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile8.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile9.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile10.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile11.h
-						//! \test decl.C99/Warn_struct_forward_def_const_volatile12.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("useless const/volatile qualification of a forward-declaration (C99 6.7.3p3)");
-					if (bool_options[boolopt::warn_crosslang_compatibility])
-						INFORM("(error in C++: C++0X 7.1.6.1p1)");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					};
+				//! \test decl.C99/Warn_struct_forward_def_const.h
+				//! \test decl.C99/Warn_struct_forward_def_const2.h
+				//! \test decl.C99/Warn_struct_forward_def_const3.h
+				//! \test decl.C99/Warn_struct_forward_def_const4.h
+				//! \test decl.C99/Warn_struct_forward_def_volatile.h
+				//! \test decl.C99/Warn_struct_forward_def_volatile2.h
+				//! \test decl.C99/Warn_struct_forward_def_volatile3.h
+				//! \test decl.C99/Warn_struct_forward_def_volatile4.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile2.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile3.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile4.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile5.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile6.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile7.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile8.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile9.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile10.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile11.h
+				//! \test decl.C99/Warn_struct_forward_def_const_volatile12.h
+				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				if (tmp)
 					{	// but if already (forward-)declared then this is a no-op
 						// think this is common enough to not warrant OAOO/DRY treatment
@@ -13305,28 +13299,17 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// no objects declared, trigger the const/volatile warnings
-				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Warn_union_def_const.h
-						//! \test decl.C99/Warn_union_def_const2.h
-						//! \test decl.C99/Warn_union_def_volatile.h
-						//! \test decl.C99/Warn_union_def_volatile2.h
-						//! \test decl.C99/Warn_union_def_const_volatile.h
-						//! \test decl.C99/Warn_union_def_const_volatile2.h
-						//! \test decl.C99/Warn_union_def_const_volatile3.h
-						//! \test decl.C99/Warn_union_def_const_volatile4.h
-						//! \test decl.C99/Warn_union_def_const_volatile5.h
-						//! \test decl.C99/Warn_union_def_const_volatile6.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("useless const/volatile qualification of a definition (C99 6.7.3p3)");
-					if (bool_options[boolopt::warn_crosslang_compatibility])
-						INFORM("(error in C++: C++0X 7.1.6.1p1)");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					};
+				//! \test decl.C99/Warn_union_def_const.h
+				//! \test decl.C99/Warn_union_def_const2.h
+				//! \test decl.C99/Warn_union_def_volatile.h
+				//! \test decl.C99/Warn_union_def_volatile2.h
+				//! \test decl.C99/Warn_union_def_const_volatile.h
+				//! \test decl.C99/Warn_union_def_const_volatile2.h
+				//! \test decl.C99/Warn_union_def_const_volatile3.h
+				//! \test decl.C99/Warn_union_def_const_volatile4.h
+				//! \test decl.C99/Warn_union_def_const_volatile5.h
+				//! \test decl.C99/Warn_union_def_const_volatile6.h
+				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				// accept definition
 				//! \test zcc/decl.C99/Pass_union_forward_def.h
 				i += 2;
@@ -13383,28 +13366,17 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// no objects declared, trigger the const/volatile warnings
-				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Warn_struct_def_const.h
-						//! \test decl.C99/Warn_struct_def_const2.h
-						//! \test decl.C99/Warn_struct_def_volatile.h
-						//! \test decl.C99/Warn_struct_def_volatile2.h
-						//! \test decl.C99/Warn_struct_def_const_volatile.h
-						//! \test decl.C99/Warn_struct_def_const_volatile2.h
-						//! \test decl.C99/Warn_struct_def_const_volatile3.h
-						//! \test decl.C99/Warn_struct_def_const_volatile4.h
-						//! \test decl.C99/Warn_struct_def_const_volatile5.h
-						//! \test decl.C99/Warn_struct_def_const_volatile6.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("useless const/volatile qualification of a definition (C99 6.7.3p3)");
-					if (bool_options[boolopt::warn_crosslang_compatibility])
-						INFORM("(error in C++: C++0X 7.1.6.1p1)");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					};
+				//! \test decl.C99/Warn_struct_def_const.h
+				//! \test decl.C99/Warn_struct_def_const2.h
+				//! \test decl.C99/Warn_struct_def_volatile.h
+				//! \test decl.C99/Warn_struct_def_volatile2.h
+				//! \test decl.C99/Warn_struct_def_const_volatile.h
+				//! \test decl.C99/Warn_struct_def_const_volatile2.h
+				//! \test decl.C99/Warn_struct_def_const_volatile3.h
+				//! \test decl.C99/Warn_struct_def_const_volatile4.h
+				//! \test decl.C99/Warn_struct_def_const_volatile5.h
+				//! \test decl.C99/Warn_struct_def_const_volatile6.h
+				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				// accept definition
 				//! \test zcc/decl.C99/Pass_union_forward_def.h
 				i += 2;
@@ -13433,28 +13405,17 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Warn_union_anon_def_const.h
-						//! \test decl.C99/Warn_union_anon_def_const2.h
-						//! \test decl.C99/Warn_union_anon_def_volatile.h
-						//! \test decl.C99/Warn_union_anon_def_volatile2.h
-						//! \test decl.C99/Warn_union_anon_def_const_volatile.h
-						//! \test decl.C99/Warn_union_anon_def_const_volatile2.h
-						//! \test decl.C99/Warn_union_anon_def_const_volatile3.h
-						//! \test decl.C99/Warn_union_anon_def_const_volatile4.h
-						//! \test decl.C99/Warn_union_anon_def_const_volatile5.h
-						//! \test decl.C99/Warn_union_anon_def_const_volatile6.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("useless const/volatile qualification of a definition (C99 6.7.3p3)");
-					if (bool_options[boolopt::warn_crosslang_compatibility])
-						INFORM("(error in C++: C++0X 7.1.6.1p1)");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					};
+				//! \test decl.C99/Warn_union_anon_def_const.h
+				//! \test decl.C99/Warn_union_anon_def_const2.h
+				//! \test decl.C99/Warn_union_anon_def_volatile.h
+				//! \test decl.C99/Warn_union_anon_def_volatile2.h
+				//! \test decl.C99/Warn_union_anon_def_const_volatile.h
+				//! \test decl.C99/Warn_union_anon_def_const_volatile2.h
+				//! \test decl.C99/Warn_union_anon_def_const_volatile3.h
+				//! \test decl.C99/Warn_union_anon_def_const_volatile4.h
+				//! \test decl.C99/Warn_union_anon_def_const_volatile5.h
+				//! \test decl.C99/Warn_union_anon_def_const_volatile6.h
+				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 				//! \test zcc/decl.C99/Warn_inaccessible_union.h
 				message_header(src.data<0>()[i].index_tokens[0]);
@@ -13489,28 +13450,17 @@
 			if (   1<src.size<0>()-i
 				&& robust_token_is_char<';'>(src.data<0>()[i+1]))
 				{	// unreferenceable declaration without static/extern/typedef...warn and optimize away
-				//! \todo even if we use -Wno-OAOO/-Wno-DRY, -Wc-c++-compat should advise that const/volatile qualification of a forward-declaration is an error in C++
-				if ((type_spec::_const | type_spec::_volatile) & src.data<0>()[i].type_code.q_vector.back())
-					{	//! \test decl.C99/Warn_struct_anon_def_const.h
-						//! \test decl.C99/Warn_struct_anon_def_const2.h
-						//! \test decl.C99/Warn_struct_anon_def_volatile.h
-						//! \test decl.C99/Warn_struct_anon_def_volatile2.h
-						//! \test decl.C99/Warn_struct_anon_def_const_volatile.h
-						//! \test decl.C99/Warn_struct_anon_def_const_volatile2.h
-						//! \test decl.C99/Warn_struct_anon_def_const_volatile3.h
-						//! \test decl.C99/Warn_struct_anon_def_const_volatile4.h
-						//! \test decl.C99/Warn_struct_anon_def_const_volatile5.h
-						//! \test decl.C99/Warn_struct_anon_def_const_volatile6.h
-					message_header(src.data<0>()[i].index_tokens[0]);
-					INC_INFORM(WARN_STR);
-					INFORM("useless const/volatile qualification of a definition (C99 6.7.3p3)");
-					if (bool_options[boolopt::warn_crosslang_compatibility])
-						INFORM("(error in C++: C++0X 7.1.6.1p1)");
-					if (bool_options[boolopt::warnings_are_errors])
-						zcc_errors.inc_error();
-					// XXX may not behave well on trapping-int hosts XXX
-					src.c_array<0>()[i].type_code.q_vector.back() &= ~(type_spec::_const | type_spec::_volatile);
-					};
+				//! \test decl.C99/Warn_struct_anon_def_const.h
+				//! \test decl.C99/Warn_struct_anon_def_const2.h
+				//! \test decl.C99/Warn_struct_anon_def_volatile.h
+				//! \test decl.C99/Warn_struct_anon_def_volatile2.h
+				//! \test decl.C99/Warn_struct_anon_def_const_volatile.h
+				//! \test decl.C99/Warn_struct_anon_def_const_volatile2.h
+				//! \test decl.C99/Warn_struct_anon_def_const_volatile3.h
+				//! \test decl.C99/Warn_struct_anon_def_const_volatile4.h
+				//! \test decl.C99/Warn_struct_anon_def_const_volatile5.h
+				//! \test decl.C99/Warn_struct_anon_def_const_volatile6.h
+				C99_flush_const_volatile_without_object(src.c_array<0>()[i]);
 				//! \todo do not warn for -Wno-OOAO/-Wno-DRY
 				//! \test zcc/decl.C99/Warn_inaccessible_struct.h
 				message_header(src.data<0>()[i].index_tokens[0]);



From zaimoni at mail.berlios.de  Thu Oct 28 20:18:40 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 28 Oct 2010 20:18:40 +0200
Subject: [Zcplusplus-commits] r507 - trunk
Message-ID: <20101028181840.B6639480C84@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-28 20:18:40 +0200 (Thu, 28 Oct 2010)
New Revision: 507

Added:
   trunk/type_system.cpp.in
Modified:
   trunk/POSIX.dep
   trunk/type_system.cpp
Log:
build system tweak

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-10-27 01:12:51 UTC (rev 506)
+++ trunk/POSIX.dep	2010-10-28 18:18:40 UTC (rev 507)
@@ -35,7 +35,7 @@
 CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operat
 or.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h type_system.hpp Zaimoni.STL/Perl_localize.hpp
-type_system.o: type_system.hpp type_system_pp.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
+type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 CSupport.o: CSupport.hpp _CSupport3.hpp _CSupport4.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp kleene_star.hpp cond_act.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_l
 t.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
 CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp _CSupport3.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/lo
 gic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2010-10-27 01:12:51 UTC (rev 506)
+++ trunk/type_system.cpp	2010-10-28 18:18:40 UTC (rev 507)
@@ -1,11 +1,7 @@
 // type_system.cpp
 // (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
-#/*cut-cpp*/
 #include "type_system.hpp"
-#/*cut-cpp*/
-#include "type_system_pp.hpp"
-#/*cut-cpp*/
 #include "enum_type.hpp"
 #include "struct_type.hpp"
 #include "Zaimoni.STL/search.hpp"
@@ -265,19 +261,15 @@
 		}
 	return _get_id_enum_CPP(alias);
 }
-#/*cut-cpp*/
 
 const char* type_system::_name(size_t id) const
 {
 	if (0==id) return "(?)";
 	if (core_types_size> --id) return core_types[id].first;
-#/*cut-cpp*/
 	if (dynamic_types.size() > (id -= core_types_size))
 		return dynamic_types[id].first;
-#/*cut-cpp*/
 	return "(?)";
 }
-#/*cut-cpp*/
 
 // implement C/C++ typedef system
 void type_system::set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec& src)
@@ -869,5 +861,4 @@
 	tmp.third.first.third = src;
 	src = NULL;
 }
-#/*cut-cpp*/
 

Added: trunk/type_system.cpp.in
===================================================================
--- trunk/type_system.cpp.in	                        (rev 0)
+++ trunk/type_system.cpp.in	2010-10-28 18:18:40 UTC (rev 507)
@@ -0,0 +1,875 @@
+// type_system.cpp
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+
+#/*cut-cpp*/
+#include "type_system.hpp"
+#/*cut-cpp*/
+#/*cut-nocpp*/
+#include "type_system_pp.hpp"
+#/*cut-nocpp*/
+#/*cut-cpp*/
+#include "enum_type.hpp"
+#include "struct_type.hpp"
+#include "Zaimoni.STL/search.hpp"
+#include "Zaimoni.STL/Pure.C/auto_int.h"
+#include "AtomicString.h"
+#include "str_aux.h"
+
+// macros to help out dynamic registration
+#define DYNAMIC_FUNCTYPE 1
+#define DYNAMIC_STRUCTDECL 2
+#define DYNAMIC_C_STRUCTDEF 3
+#define DYNAMIC_ENUMDEF 4
+
+type_system::type_index type_system::_get_id_union(const char* const x) const
+{
+	const size_t x_len = strlen(x);
+	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
+	while(0<=tmp)
+		{
+		if (DYNAMIC_STRUCTDECL==dynamic_types[tmp].third.second)
+			{
+			if (union_struct_decl::decl_union==dynamic_types[tmp].third.first.second->keyword())
+				return tmp+1+core_types_size;
+			return 0;
+			};
+		if (DYNAMIC_C_STRUCTDEF==dynamic_types[tmp].third.second)
+			{
+			if (union_struct_decl::decl_union==dynamic_types[tmp].third.first.third->_decl.keyword())
+				return tmp+1+core_types_size;
+			return 0;
+			}
+		// in a different tag space...retry
+		if (1>=dynamic_types.size()-tmp) break;
+		errr tmp2 = linear_find_lencached(x,x_len,dynamic_types.data()+tmp+1,dynamic_types.size()-(tmp+1));
+		if (0>tmp2) break;
+		tmp += 1+tmp2;
+		}
+	return 0;
+}
+
+type_system::type_index
+type_system::_get_id_union_CPP(const char* const x) const
+{
+	errr tmp = _get_id_union(x);
+	if (0<tmp) return tmp;
+
+	// hmm...not an exact match
+	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(x);
+	if (0>tmp2.first) return 0;
+
+	// it was remapped
+	while(tmp2.first<tmp2.second)
+		{
+		tmp = _get_id_union(inline_namespace_alias_map.data()[tmp2.first++].second);
+		if (0<tmp) return tmp;
+		}
+	return _get_id_union(inline_namespace_alias_map.data()[tmp2.first].second);
+}
+
+type_system::type_index
+type_system::get_id_union_CPP(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+
+	if (!strncmp(alias,"::",2))
+		{	// fully-qualified
+		// pretend not fully qualified, but no surrounding namespace
+		alias += 2;
+		active_namespace = NULL;
+		};
+	if (active_namespace && *active_namespace)
+		{
+		// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		if (is_string_registered(tmp_alias))
+			{	// registered, so could be indexed
+			const type_index tmp2 = _get_id_union_CPP(tmp_alias);
+			if (tmp2) return (free(tmp_alias),tmp2);
+			}
+
+		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
+		if (extra_namespaces)
+			{
+			zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
+			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[--i]-active_namespace,"::");
+				const type_index tmp2 = _get_id_union_CPP(tmp_alias);
+				if (tmp2) return (free(tmp_alias),tmp2);
+				}
+			while(0<i);
+			}
+		free(tmp_alias);
+		}
+	return _get_id_union_CPP(alias);
+}
+
+type_system::type_index
+type_system::_get_id_struct_class(const char* const x) const
+{
+	const size_t x_len = strlen(x);
+	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
+	while(0<=tmp)
+		{
+		if (DYNAMIC_STRUCTDECL==dynamic_types[tmp].third.second)
+			{
+			if (union_struct_decl::decl_union!=dynamic_types[tmp].third.first.second->keyword())
+				return tmp+1+core_types_size;
+			return 0;
+			};
+		if (DYNAMIC_C_STRUCTDEF==dynamic_types[tmp].third.second)
+			{
+			if (union_struct_decl::decl_union!=dynamic_types[tmp].third.first.third->_decl.keyword())
+				return tmp+1+core_types_size;
+			return 0;
+			}
+		// in a different tag space...retry
+		if (1>=dynamic_types.size()-tmp) break;
+		errr tmp2 = linear_find_lencached(x,x_len,dynamic_types.data()+tmp+1,dynamic_types.size()-(tmp+1));
+		if (0>tmp2) break;
+		tmp += 1+tmp2;
+		}
+	return 0;
+}
+
+type_system::type_index
+type_system::_get_id_struct_class_CPP(const char* const x) const
+{
+	errr tmp = _get_id_struct_class(x);
+	if (0<tmp) return tmp;
+
+	// hmm...not an exact match
+	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(x);
+	if (0>tmp2.first) return 0;
+
+	// it was remapped
+	while(tmp2.first<tmp2.second)
+		{
+		tmp = _get_id_struct_class(inline_namespace_alias_map.data()[tmp2.first++].second);
+		if (0<tmp) return tmp;
+		}
+	return _get_id_struct_class(inline_namespace_alias_map.data()[tmp2.first].second);
+}
+
+type_system::type_index
+type_system::get_id_struct_class_CPP(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+
+	if (!strncmp(alias,"::",2))
+		{	// fully-qualified
+		// pretend not fully qualified, but no surrounding namespace
+		alias += 2;
+		active_namespace = NULL;
+		};
+	if (active_namespace && *active_namespace)
+		{
+		// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		if (is_string_registered(tmp_alias))
+			{	// registered, so could be indexed
+			const type_index tmp2 = _get_id_struct_class_CPP(tmp_alias);
+			if (tmp2) return (free(tmp_alias),tmp2);
+			}
+
+		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
+		if (extra_namespaces)
+			{
+			zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
+			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[--i]-active_namespace,"::");
+				const type_index tmp2 = _get_id_struct_class_CPP(tmp_alias);
+				if (tmp2) return (free(tmp_alias),tmp2);
+				}
+			while(0<i);
+			}
+		free(tmp_alias);
+		}
+	return _get_id_struct_class_CPP(alias);
+}
+
+type_system::type_index type_system::_get_id_enum(const char* const x) const
+{
+	const size_t x_len = strlen(x);
+	errr tmp = linear_find_lencached(x,x_len,dynamic_types);
+	while(0<=tmp)
+		{
+		if (DYNAMIC_ENUMDEF==dynamic_types[tmp].third.second)
+			return tmp+1+core_types_size;
+
+		// in a different tag space...retry
+		if (1>=dynamic_types.size()-tmp) break;
+		errr tmp2 = linear_find_lencached(x,x_len,dynamic_types.data()+tmp+1,dynamic_types.size()-(tmp+1));
+		if (0>tmp2) break;
+		tmp += 1+tmp2;
+		}
+	return 0;
+}
+
+type_system::type_index
+type_system::_get_id_enum_CPP(const char* const x) const
+{
+	errr tmp = _get_id_enum(x);
+	if (0<tmp) return tmp;
+
+	// hmm...not an exact match
+	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(x);
+	if (0>tmp2.first) return 0;
+
+	// it was remapped
+	while(tmp2.first<tmp2.second)
+		{
+		tmp = _get_id_enum(inline_namespace_alias_map.data()[tmp2.first++].second);
+		if (0<tmp) return tmp;
+		}
+	return _get_id_enum(inline_namespace_alias_map.data()[tmp2.first].second);
+}
+
+type_system::type_index
+type_system::get_id_enum_CPP(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+
+	if (!strncmp(alias,"::",2))
+		{	// fully-qualified
+		// pretend not fully qualified, but no surrounding namespace
+		alias += 2;
+		active_namespace = NULL;
+		};
+	if (active_namespace && *active_namespace)
+		{
+		// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		if (is_string_registered(tmp_alias))
+			{	// registered, so could be indexed
+			const type_index tmp2 = _get_id_enum_CPP(tmp_alias);
+			if (tmp2) return (free(tmp_alias),tmp2);
+			}
+
+		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
+		if (extra_namespaces)
+			{
+			zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
+			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[--i]-active_namespace,"::");
+				const type_index tmp2 = _get_id_enum_CPP(tmp_alias);
+				if (tmp2) return (free(tmp_alias),tmp2);
+				}
+			while(0<i);
+			}
+		free(tmp_alias);
+		}
+	return _get_id_enum_CPP(alias);
+}
+#/*cut-cpp*/
+
+const char* type_system::_name(size_t id) const
+{
+	if (0==id) return "(?)";
+	if (core_types_size> --id) return core_types[id].first;
+#/*cut-cpp*/
+	if (dynamic_types.size() > (id -= core_types_size))
+		return dynamic_types[id].first;
+#/*cut-cpp*/
+	return "(?)";
+}
+#/*cut-cpp*/
+
+// implement C/C++ typedef system
+void type_system::set_typedef(const char* const alias, const char* filename, const size_t lineno, type_spec& src)
+{
+	assert(alias && *alias);
+	assert(filename && *filename);
+	errr tmp = binary_find(alias,strlen(alias),typedef_registry.data(),typedef_registry.size());
+	assert(0>tmp);		// error to call with conflicting prior definition
+	if (0<=tmp) return;	// conflicting prior definition
+#if UINTMAX_MAX==SIZE_MAX
+	if (-1==tmp) _fatal("implementation limit exceeded (typedefs registered at once)");
+#endif
+	zaimoni::POD_pair<const char*,zaimoni::POD_triple<type_spec,const char*,size_t> > tmp2 = {alias, {src, filename, lineno}};
+	if (!typedef_registry.InsertSlotAt(BINARY_SEARCH_DECODE_INSERTION_POINT(tmp),tmp2)) throw std::bad_alloc();
+	src.clear();
+}
+
+void type_system::set_typedef_CPP(const char* name, const char* const active_namespace, const char* filename, const size_t lineno, type_spec& src)
+{
+	assert(name && *name);
+	assert(filename && *filename);
+
+	// use active namespace if present
+	if (active_namespace && *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	return set_typedef(name,filename,lineno,src);
+}
+
+const zaimoni::POD_triple<type_spec,const char*,size_t>* type_system::get_typedef(const char* const alias) const
+{
+	assert(alias && *alias);
+	//! \todo: strip off trailing inline namespaces
+	// <unknown> is the hack for anonymous namespaces taken from GCC, it's always inline
+	errr tmp = binary_find(alias,strlen(alias),typedef_registry.data(),typedef_registry.size());
+	if (0<=tmp) return &typedef_registry[tmp].second;
+	return NULL;
+}
+
+const zaimoni::POD_triple<type_spec,const char*,size_t>* type_system::_get_typedef_CPP(const char* const alias) const
+{
+	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = get_typedef(alias);
+	if (tmp) return tmp;
+
+	// hmm...not an exact match
+	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(alias);
+	if (0>tmp2.first) return NULL;
+
+	// it was remapped
+	while(tmp2.first<tmp2.second)
+		{
+		tmp = get_typedef(inline_namespace_alias_map.data()[tmp2.first++].second);
+		if (tmp) return tmp;
+		}
+	return get_typedef(inline_namespace_alias_map.data()[tmp2.first].second);
+}
+
+const zaimoni::POD_triple<type_spec,const char*,size_t>* type_system::get_typedef_CPP(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+
+	if (!strncmp(alias,"::",2))
+		{	// fully-qualified typedef name
+			// cheat: pretend not fully qualified but no surrounding namespace
+		alias += 2;
+		active_namespace = NULL;
+		};
+	if (active_namespace && *active_namespace)
+		{
+		// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		if (is_string_registered(tmp_alias))
+			{	// registered, so could be indexed
+			const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp2 = _get_typedef_CPP(tmp_alias);
+			if (tmp2) return (free(tmp_alias),tmp2);
+			}
+
+		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
+		if (extra_namespaces)
+			{
+			zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
+			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[--i]-active_namespace,"::");
+				const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp2 = _get_typedef_CPP(tmp_alias);
+				if (tmp2) return (free(tmp_alias),tmp2);
+				}
+			while(0<i);
+			}
+		free(tmp_alias);
+		}
+	return _get_typedef_CPP(alias);
+}
+
+void type_system::set_enumerator_def(const char* const alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename,unsigned char representation,const uchar_blob& src,type_index type)
+{
+	assert(alias && *alias);
+	assert(src_filename && *src_filename);
+	assert(type);
+	assert(get_enum_def(type));
+	errr tmp = binary_find(alias,strlen(alias),enumerator_registry.data(),enumerator_registry.size());
+	assert(0>tmp);		// error to call with conflicting prior definition
+	if (0<=tmp) return;	// conflicting prior definition
+#if UINTMAX_MAX==SIZE_MAX
+	if (-1==tmp) _fatal("implementation limit exceeded (enumerators registered at once)");
+#endif
+	enumerator_info tmp2 = {alias, { {type, representation, src}, {src_filename, logical_line} } };
+	if (!enumerator_registry.InsertSlotAt(BINARY_SEARCH_DECODE_INSERTION_POINT(tmp),tmp2)) throw std::bad_alloc();
+}
+
+void type_system::set_enumerator_def_CPP(const char* name, const char* const active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename,unsigned char representation,const uchar_blob& src,type_index type)
+{
+	assert(name && *name);
+	assert(src_filename && *src_filename);
+	assert(type);
+
+	// use active namespace if present
+	if (active_namespace && *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	set_enumerator_def(name,logical_line,src_filename,representation,src,type);
+}
+
+const type_system::enumerator_info* type_system::get_enumerator(const char* const alias) const
+{
+	assert(alias && *alias);
+	//! \todo: strip off trailing inline namespaces
+	// <unknown> is the hack for anonymous namespaces taken from GCC, it's always inline
+	errr tmp = binary_find(alias,strlen(alias),enumerator_registry.data(),enumerator_registry.size());
+	if (0<=tmp)
+		{
+		assert(get_enum_def(enumerator_registry[tmp].second.first.first));
+		return &enumerator_registry[tmp];
+		}
+	return NULL;
+}
+
+const type_system::enumerator_info* type_system::_get_enumerator_CPP(const char* const alias) const
+{
+	const enumerator_info* tmp = get_enumerator(alias);
+	if (tmp) return tmp;
+
+	// hmm...not an exact match
+	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp2 = dealias_inline_namespace_index(alias);
+	if (0>tmp2.first) return NULL;
+
+	// it was remapped
+	while(tmp2.first<tmp2.second)
+		{
+		tmp = get_enumerator(inline_namespace_alias_map.data()[tmp2.first++].second);
+		if (tmp) return tmp;
+		}
+	return get_enumerator(inline_namespace_alias_map.data()[tmp2.first].second);
+}
+
+const type_system::enumerator_info* type_system::get_enumerator_CPP(const char* alias,const char* active_namespace) const
+{
+	assert(alias && *alias);
+
+	if (!strncmp(alias,"::",2))
+		{	// fully-qualified typedef name
+			// cheat: pretend not fully qualified but no surrounding namespace
+		alias += 2;
+		active_namespace = NULL;
+		};
+	if (active_namespace && *active_namespace)
+		{
+		// ok..march up to global
+		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
+		if (is_string_registered(tmp_alias))
+			{	// registered, so could be indexed
+			const enumerator_info* tmp2 = _get_enumerator_CPP(tmp_alias);
+			if (tmp2) return (free(tmp_alias),tmp2);
+			}
+
+		const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
+		if (extra_namespaces)
+			{
+			zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
+			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				namespace_concatenate(tmp_alias,alias,active_namespace,intra_namespace[--i]-active_namespace,"::");
+				const enumerator_info* tmp2 = _get_enumerator_CPP(tmp_alias);
+				if (tmp2) return (free(tmp_alias),tmp2);
+				}
+			while(0<i);
+			}
+		free(tmp_alias);
+		}
+	return _get_enumerator_CPP(alias);
+}
+
+char* type_system::_namespace_concatenate(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len)
+{	// remove comment after other seven wrapper variants implemented
+//	assert(active_namespace && *active_namespace && 0<active_namespace_len && active_namespace_len<=strlen(active_namespace));
+//	assert(name && *name && 0<name_len && name_len<=strlen(name));
+//	assert(namespace_separator && *namespace_separator && 0<namespace_separator_len && namespace_separator_len<=strlen(namespace_separator));
+	char* const actual_name = zaimoni::_new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(active_namespace_len+2+name_len));
+	strncpy(actual_name,active_namespace,active_namespace_len);
+	strncpy(actual_name+active_namespace_len,namespace_separator,namespace_separator_len);
+	strncpy(actual_name+active_namespace_len+namespace_separator_len,name,name_len);
+	return actual_name;
+}
+
+void type_system::_namespace_concatenate(char* buf, const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len)
+{	// remove comment after other seven wrapper variants implemented
+//	assert(buf)
+//	assert(active_namespace && *active_namespace && 0<active_namespace_len && active_namespace_len<=strlen(active_namespace));
+//	assert(name && *name && 0<name_len && name_len<=strlen(name));
+//	assert(namespace_separator && *namespace_separator && 0<namespace_separator_len && namespace_separator_len<=strlen(namespace_separator));
+	strncpy(buf,active_namespace,active_namespace_len);
+	strncpy(buf+active_namespace_len,namespace_separator,namespace_separator_len);
+	strncpy(buf+active_namespace_len+namespace_separator_len,name,name_len);
+	ZAIMONI_NULL_TERMINATE(buf[active_namespace_len+namespace_separator_len+name_len]);
+}
+
+zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> type_system::dealias_inline_namespace_index(const char* const alias) const
+{
+	assert(alias && *alias);
+	zaimoni::POD_pair<ptrdiff_t,ptrdiff_t> tmp = {-1,-1};
+	size_t strict_ub = inline_namespace_alias_map.size();
+	size_t lb = 0;
+	// binary search
+	// is inline_namespace_alias_map.data() a code size optimization target?
+	while(strict_ub>lb)
+		{
+		const size_t midpoint = lb+(strict_ub-lb)/2;
+		switch(strcmp(inline_namespace_alias_map.data()[midpoint].first,alias))
+		{
+#ifndef NDEBUG
+		default: FATAL("strcmp out of range -1,0,1");
+#endif
+		case 0: {
+			tmp.first = midpoint;
+			tmp.second = midpoint;
+			while(lb<(size_t)tmp.first && !strcmp(inline_namespace_alias_map.data()[tmp.first-1].first,alias)) --tmp.first;
+			while(strict_ub-1>(size_t)tmp.second && !strcmp(inline_namespace_alias_map.data()[tmp.second+1].first,alias)) ++tmp.second;
+			return tmp;
+			}
+		case 1: {
+			strict_ub = midpoint;
+			break;
+			}
+		case -1:{
+			lb = midpoint+1;
+			}
+		}
+		}
+	return tmp;
+}
+
+bool type_system::is_inline_namespace_CPP(const char* const active_namespace, const size_t active_namespace_len) const
+{
+	assert(active_namespace && *active_namespace && 0<active_namespace_len);
+	assert(strncmp(active_namespace,"::",2));
+	
+	// ::<unknown>, our hack for anonymous namespaces, is always an inline namespace 
+	if (sizeof("<unknown>")-1==active_namespace_len && !strncmp(active_namespace,"<unknown>",sizeof("<unknown>")-1)) return true;
+	if (sizeof("::<unknown>")-1<active_namespace_len && !strncmp(active_namespace+(active_namespace_len-(sizeof("::<unknown>")-1)),"::<unknown>",sizeof("::<unknown>")-1)) return true;
+
+	//! \todo check for C++0X inline namespaces
+	// should be fine with binary search against canonical names
+	return false;
+}
+
+const char* type_system::canonical_name_is_inline_namespace_alias_target(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len,const char* namespace_separator, size_t namespace_separator_len) const
+{
+	assert(active_namespace && *active_namespace && 0<active_namespace_len);
+	assert(name && *name && 0<name_len);
+	assert(namespace_separator && *namespace_separator && 0<namespace_separator_len);
+	size_t strict_ub = inline_namespace_alias_targets.size();
+	size_t lb = 0;
+	// classic binary search.
+	// is inline_namespace_alias_targets.data() a code-size optimization target?
+	while(strict_ub>lb)
+		{
+		const size_t midpoint = lb+(strict_ub-lb)/2;
+		int tmp = strncmp(inline_namespace_alias_targets.data()[midpoint],active_namespace,active_namespace_len);
+		if (!tmp) tmp = strncmp(inline_namespace_alias_targets.data()[midpoint]+active_namespace_len,namespace_separator,namespace_separator_len);
+		if (!tmp) tmp = strncmp(inline_namespace_alias_targets.data()[midpoint]+active_namespace_len+namespace_separator_len,name,name_len);
+		switch(tmp)
+		{
+#ifndef NDEBUG
+		default: FATAL("strncmp out of range -1,0,1");
+#endif
+		case 0: return  inline_namespace_alias_targets.data()[midpoint];
+		case 1: {
+			strict_ub = midpoint;
+			break;
+			}
+		case -1:{
+			lb = midpoint+1;
+			}
+		}
+		}
+	return NULL;
+}
+
+const char* type_system::construct_canonical_name_and_aliasing_CPP(const char* const name, size_t name_len, const char* const active_namespace, size_t active_namespace_len)
+{
+	assert(active_namespace && *active_namespace && 0<active_namespace_len);
+	assert(name && *name && 0<name_len);
+	assert(strncmp(active_namespace,"::",2));
+	// check for whether we already are aliased
+	const char* retval = canonical_name_is_inline_namespace_alias_target(name,name_len,active_namespace,active_namespace_len,"::",2);
+	if (NULL!=retval) return retval;
+
+	// canonical name is simply active_namespace::name
+	zaimoni::autoval_ptr<char> retval_tmp;
+	retval_tmp = _namespace_concatenate(name,name_len,active_namespace,active_namespace_len,"::",2);
+
+	// aliasing is built by removing trailing inline namespaces incrementally
+	const size_t extra_namespaces = count_disjoint_substring_instances(active_namespace,"::");
+	if (is_inline_namespace_CPP(active_namespace,active_namespace_len))
+		{
+		zaimoni::autovalarray_ptr_throws<char*> namespace_tmp(extra_namespaces);
+#ifndef ZAIMONI_NULL_REALLY_IS_ZERO
+#error need to null-initialize pointers for namespace_tmp
+#endif
+		bool can_be_completely_gone = false;
+		{
+		zaimoni::weakautovalarray_ptr_throws<const char*> intra_namespace(extra_namespaces);
+		if (extra_namespaces)
+			{
+			report_disjoint_substring_instances(active_namespace,"::",intra_namespace.c_array(),extra_namespaces);
+			size_t i = extra_namespaces;
+			do	{
+				if (!is_inline_namespace_CPP(active_namespace,i==extra_namespaces ? active_namespace_len : intra_namespace[i]-active_namespace))
+					break;
+				--i;
+				namespace_tmp[i] = _namespace_concatenate(name,name_len,active_namespace,intra_namespace[i]-active_namespace,"::",2);
+				}
+			while(0<i);
+			can_be_completely_gone = (0==i && is_inline_namespace_CPP(active_namespace,intra_namespace[0]-active_namespace));
+			if (0<i) namespace_tmp.DeleteNSlotsAt(i,0);
+			}
+		else{
+			can_be_completely_gone = true;
+			}
+		}
+		assert(can_be_completely_gone || !namespace_tmp.empty());
+
+		size_t origin = inline_namespace_alias_map.size();
+		size_t origin2 = inline_namespace_alias_targets.size();
+		inline_namespace_alias_targets.resize(origin2+1);
+		try	{
+			inline_namespace_alias_map.resize(origin+namespace_tmp.size()+can_be_completely_gone);
+			}
+		catch(std::bad_alloc& e)
+			{
+			inline_namespace_alias_targets.resize(origin2);
+			throw;
+			}
+
+		retval = register_string(retval_tmp);	//! \todo would prefer to consume the string; changes reset() to NULLPtr() to be safe
+		retval_tmp.reset();
+		/* do a downward insertsort against the second index*/
+		while(origin2 && 1==strcmp(inline_namespace_alias_targets.c_array()[origin2-1],retval))
+			{
+			inline_namespace_alias_targets.c_array()[origin2] = inline_namespace_alias_targets.c_array()[origin2-1];
+			--origin2;
+			};
+		inline_namespace_alias_targets.c_array()[origin2] = retval;
+
+		size_t i = namespace_tmp.size();
+		while(0<i)
+			{
+			const zaimoni::POD_pair<const char*,const char*> tmp = {register_string(namespace_tmp[--i]), retval};
+			size_t j = origin;
+			while(j && 1==strcmp(inline_namespace_alias_map.c_array()[j-1].first,tmp.first))
+				{
+				inline_namespace_alias_map.c_array()[j] = inline_namespace_alias_map.c_array()[j-1];
+				--j;
+				};
+			inline_namespace_alias_map.c_array()[origin++] = tmp;
+			free(namespace_tmp[i]);
+			namespace_tmp[i] = NULL;
+			};
+		if (can_be_completely_gone)
+			{
+			const zaimoni::POD_pair<const char*,const char*> tmp = {register_substring(name,name_len), retval};
+			size_t j = origin;
+			while(j && 1==strcmp(inline_namespace_alias_map.c_array()[j-1].first,tmp.first))
+				{
+				inline_namespace_alias_map.c_array()[j] = inline_namespace_alias_map.c_array()[j-1];
+				--j;
+				};
+			inline_namespace_alias_map.c_array()[origin++] = tmp;
+			}
+		}
+
+	if (!retval)
+		{
+		retval = register_string(retval_tmp);	//! \todo would prefer to consume the string; changes reset() to NULLPtr() to be safe
+		retval_tmp.reset();
+		};
+	// return the canonical name
+	return retval;
+}
+
+type_system::type_index type_system::register_functype(const char* const alias, function_type*& src)
+{
+	assert(alias && *alias);
+	assert(src);
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_FUNCTYPE}};
+	tmp.third.first.first = src;
+
+	const size_t dynamic_types_size = dynamic_types.size();
+	const size_t dynamic_types_max_size = dynamic_types.max_size();
+	if (	dynamic_types_max_size<1+core_types_size
+		|| 	dynamic_types_max_size-(1+core_types_size)<dynamic_types_size)
+		FATAL("Host implementation limit exceeded: cannot record function type used in program");
+	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp)) throw std::bad_alloc();
+	src = NULL;
+	return dynamic_types_size+1+core_types_size;
+}
+
+type_system::type_index type_system::register_functype_CPP(const char* name, const char* const active_namespace, function_type*& src)
+{
+	assert(name && *name);
+	assert(src);
+
+	// use active namespace if present
+	if (active_namespace && *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	return register_functype(name,src);
+}
+
+type_system::type_index type_system::register_structdecl(const char* const alias, int keyword)
+{
+	assert(alias && *alias);
+	const size_t dynamic_types_size = dynamic_types.size();
+	const size_t dynamic_types_max_size = dynamic_types.max_size();
+	if (	dynamic_types_max_size<2+core_types_size
+		|| 	dynamic_types_max_size-(2+core_types_size)<dynamic_types_size)
+		FATAL("Host implementation limit exceeded: cannot record union/struct type used in program");
+
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_STRUCTDECL}};
+	tmp.third.first.second = new union_struct_decl((union_struct_decl::keywords)keyword,alias);
+
+	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp))
+		{
+		delete tmp.third.first.second;
+		throw std::bad_alloc();
+		}
+	return dynamic_types_size+1+core_types_size;
+}
+
+type_system::type_index type_system::register_structdecl_CPP(const char* name, const char* const active_namespace, int keyword)
+{
+	assert(name && *name);
+
+	// use active namespace if present
+	if (active_namespace && *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	return register_structdecl(name,keyword);
+}
+
+type_system::type_index type_system::register_C_structdef(const char* const alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename, int keyword)
+{
+	assert(alias && *alias);
+	assert(src_filename && *src_filename);
+	const size_t dynamic_types_size = dynamic_types.size();
+	const size_t dynamic_types_max_size = dynamic_types.max_size();
+	if (	dynamic_types_max_size<2+core_types_size
+		|| 	dynamic_types_max_size-(2+core_types_size)<dynamic_types_size)
+		FATAL("Host implementation limit exceeded: cannot record union/struct type used in program");
+
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_C_STRUCTDEF}};
+	tmp.third.first.third = new C_union_struct_def((union_struct_decl::keywords)keyword,alias,logical_line,src_filename);
+
+	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp))
+		{
+		delete tmp.third.first.third;
+		throw std::bad_alloc();
+		}
+	return dynamic_types_size+1+core_types_size;
+}
+
+type_system::type_index type_system::register_C_structdef_CPP(const char* name, const char* const active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename, int keyword)
+{
+	assert(name && *name);
+	assert(src_filename && *src_filename);
+
+	// use active namespace if present
+	if (active_namespace && *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	return register_C_structdef(name,logical_line,src_filename,keyword);
+}
+
+type_system::type_index type_system::register_enum_def(const char* const alias, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename)
+{
+	assert(alias && *alias);
+	assert(src_filename && *src_filename);
+	const size_t dynamic_types_size = dynamic_types.size();
+	const size_t dynamic_types_max_size = dynamic_types.max_size();
+	if (	dynamic_types_max_size<2+core_types_size
+		|| 	dynamic_types_max_size-(2+core_types_size)<dynamic_types_size)
+		FATAL("Host implementation limit exceeded: cannot record enum type used in program");
+
+	dynamic_type_format tmp = {alias,strlen(alias),{{NULL},DYNAMIC_ENUMDEF}};
+	tmp.third.first.fourth = new enum_def(alias,logical_line,src_filename);
+
+	if (!dynamic_types.InsertSlotAt(dynamic_types_size,tmp))
+		{
+		delete tmp.third.first.fourth;
+		throw std::bad_alloc();
+		}
+	return dynamic_types_size+1+core_types_size;
+}
+
+type_system::type_index type_system::register_enum_def_CPP(const char* name, const char* const active_namespace, zaimoni::POD_pair<size_t,size_t> logical_line, const char* const src_filename)
+{
+	assert(name && *name);
+	assert(src_filename && *src_filename);
+
+	// use active namespace if present
+	if (active_namespace && *active_namespace)
+		name = construct_canonical_name_and_aliasing_CPP(name,strlen(name),active_namespace,strlen(active_namespace));
+
+	return register_enum_def(name,logical_line,src_filename);
+}
+
+const function_type* type_system::get_functype(type_system::type_index i)  const
+{
+	if (core_types_size>=i) return NULL;
+	i -= core_types_size;
+	if (dynamic_types.size()<= --i) return NULL;
+	const dynamic_type_format& tmp = dynamic_types[i];
+	if (DYNAMIC_FUNCTYPE!=tmp.third.second) return NULL;
+	return tmp.third.first.first;
+}
+
+const union_struct_decl* type_system::get_structdecl(type_system::type_index i)  const
+{
+	if (core_types_size>=i) return NULL;
+	i -= core_types_size;
+	if (dynamic_types.size()<= --i) return NULL;
+	const dynamic_type_format& tmp = dynamic_types[i];
+	if (DYNAMIC_STRUCTDECL!=tmp.third.second) return NULL;
+	return tmp.third.first.second;
+}
+
+const C_union_struct_def* type_system::get_C_structdef(type_system::type_index i)  const
+{
+	if (core_types_size>=i) return NULL;
+	i -= core_types_size;
+	if (dynamic_types.size()<= --i) return NULL;
+	const dynamic_type_format& tmp = dynamic_types[i];
+	if (DYNAMIC_C_STRUCTDEF!=tmp.third.second) return NULL;
+	return tmp.third.first.third;
+}
+
+enum_def* type_system::_get_enum_def(type_index i) const
+{
+	if (core_types_size>=i) return NULL;
+	i -= core_types_size;
+	if (dynamic_types.size()<= --i) return NULL;
+	const dynamic_type_format& tmp = dynamic_types[i];
+	if (DYNAMIC_ENUMDEF!=tmp.third.second) return NULL;
+	return tmp.third.first.fourth;
+}
+
+void type_system::set_enum_underlying_type(type_index i,size_t new_type)
+{
+	assert(UCHAR_MAX>=new_type);
+	enum_def* const tmp = _get_enum_def(i);
+	assert(tmp);
+	tmp->represent_as = new_type;
+}
+
+void type_system::upgrade_decl_to_def(type_index i,C_union_struct_def*& src)
+{	// cf. get_structdecl
+	assert(src);
+	assert(core_types_size<i);
+	i -= core_types_size;
+	--i;
+	assert(dynamic_types.size()>i);
+	dynamic_type_format& tmp = dynamic_types[i];
+	assert(DYNAMIC_STRUCTDECL==tmp.third.second);
+	assert(*tmp.third.first.second==src->_decl);
+	tmp.third.second = DYNAMIC_C_STRUCTDEF;
+	delete tmp.third.first.second;
+	tmp.third.first.third = src;
+	src = NULL;
+}
+#/*cut-cpp*/
+



From zaimoni at mail.berlios.de  Thu Oct 28 23:32:14 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Thu, 28 Oct 2010 23:32:14 +0200
Subject: [Zcplusplus-commits] r508 - trunk
Message-ID: <20101028213215.05CEF480C84@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-28 23:32:14 +0200 (Thu, 28 Oct 2010)
New Revision: 508

Modified:
   trunk/type_system.cpp
   trunk/type_system.cpp.in
Log:
stage 3: line count compaction

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2010-10-28 18:18:40 UTC (rev 507)
+++ trunk/type_system.cpp	2010-10-28 21:32:14 UTC (rev 508)
@@ -73,8 +73,7 @@
 		active_namespace = NULL;
 		};
 	if (active_namespace && *active_namespace)
-		{
-		// ok..march up to global
+		{	// ok..march up to global
 		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
 		if (is_string_registered(tmp_alias))
 			{	// registered, so could be indexed
@@ -159,8 +158,7 @@
 		active_namespace = NULL;
 		};
 	if (active_namespace && *active_namespace)
-		{
-		// ok..march up to global
+		{	// ok..march up to global
 		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
 		if (is_string_registered(tmp_alias))
 			{	// registered, so could be indexed
@@ -235,8 +233,7 @@
 		active_namespace = NULL;
 		};
 	if (active_namespace && *active_namespace)
-		{
-		// ok..march up to global
+		{	// ok..march up to global
 		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
 		if (is_string_registered(tmp_alias))
 			{	// registered, so could be indexed
@@ -338,8 +335,7 @@
 		active_namespace = NULL;
 		};
 	if (active_namespace && *active_namespace)
-		{
-		// ok..march up to global
+		{	// ok..march up to global
 		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
 		if (is_string_registered(tmp_alias))
 			{	// registered, so could be indexed
@@ -437,8 +433,7 @@
 		active_namespace = NULL;
 		};
 	if (active_namespace && *active_namespace)
-		{
-		// ok..march up to global
+		{	// ok..march up to global
 		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
 		if (is_string_registered(tmp_alias))
 			{	// registered, so could be indexed
@@ -515,9 +510,7 @@
 			strict_ub = midpoint;
 			break;
 			}
-		case -1:{
-			lb = midpoint+1;
-			}
+		case -1: lb = midpoint+1;
 		}
 		}
 	return tmp;
@@ -562,9 +555,7 @@
 			strict_ub = midpoint;
 			break;
 			}
-		case -1:{
-			lb = midpoint+1;
-			}
+		case -1: lb = midpoint+1;
 		}
 		}
 	return NULL;
@@ -608,9 +599,7 @@
 			can_be_completely_gone = (0==i && is_inline_namespace_CPP(active_namespace,intra_namespace[0]-active_namespace));
 			if (0<i) namespace_tmp.DeleteNSlotsAt(i,0);
 			}
-		else{
-			can_be_completely_gone = true;
-			}
+		else can_be_completely_gone = true;
 		}
 		assert(can_be_completely_gone || !namespace_tmp.empty());
 
@@ -668,8 +657,7 @@
 		retval = register_string(retval_tmp);	//! \todo would prefer to consume the string; changes reset() to NULLPtr() to be safe
 		retval_tmp.reset();
 		};
-	// return the canonical name
-	return retval;
+	return retval;	// return the canonical name
 }
 
 type_system::type_index type_system::register_functype(const char* const alias, function_type*& src)

Modified: trunk/type_system.cpp.in
===================================================================
--- trunk/type_system.cpp.in	2010-10-28 18:18:40 UTC (rev 507)
+++ trunk/type_system.cpp.in	2010-10-28 21:32:14 UTC (rev 508)
@@ -79,8 +79,7 @@
 		active_namespace = NULL;
 		};
 	if (active_namespace && *active_namespace)
-		{
-		// ok..march up to global
+		{	// ok..march up to global
 		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
 		if (is_string_registered(tmp_alias))
 			{	// registered, so could be indexed
@@ -165,8 +164,7 @@
 		active_namespace = NULL;
 		};
 	if (active_namespace && *active_namespace)
-		{
-		// ok..march up to global
+		{	// ok..march up to global
 		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
 		if (is_string_registered(tmp_alias))
 			{	// registered, so could be indexed
@@ -241,8 +239,7 @@
 		active_namespace = NULL;
 		};
 	if (active_namespace && *active_namespace)
-		{
-		// ok..march up to global
+		{	// ok..march up to global
 		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
 		if (is_string_registered(tmp_alias))
 			{	// registered, so could be indexed
@@ -348,8 +345,7 @@
 		active_namespace = NULL;
 		};
 	if (active_namespace && *active_namespace)
-		{
-		// ok..march up to global
+		{	// ok..march up to global
 		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
 		if (is_string_registered(tmp_alias))
 			{	// registered, so could be indexed
@@ -447,8 +443,7 @@
 		active_namespace = NULL;
 		};
 	if (active_namespace && *active_namespace)
-		{
-		// ok..march up to global
+		{	// ok..march up to global
 		char* tmp_alias = namespace_concatenate(alias,active_namespace,"::");
 		if (is_string_registered(tmp_alias))
 			{	// registered, so could be indexed
@@ -525,9 +520,7 @@
 			strict_ub = midpoint;
 			break;
 			}
-		case -1:{
-			lb = midpoint+1;
-			}
+		case -1: lb = midpoint+1;
 		}
 		}
 	return tmp;
@@ -572,9 +565,7 @@
 			strict_ub = midpoint;
 			break;
 			}
-		case -1:{
-			lb = midpoint+1;
-			}
+		case -1: lb = midpoint+1;
 		}
 		}
 	return NULL;
@@ -618,9 +609,7 @@
 			can_be_completely_gone = (0==i && is_inline_namespace_CPP(active_namespace,intra_namespace[0]-active_namespace));
 			if (0<i) namespace_tmp.DeleteNSlotsAt(i,0);
 			}
-		else{
-			can_be_completely_gone = true;
-			}
+		else can_be_completely_gone = true;
 		}
 		assert(can_be_completely_gone || !namespace_tmp.empty());
 
@@ -678,8 +667,7 @@
 		retval = register_string(retval_tmp);	//! \todo would prefer to consume the string; changes reset() to NULLPtr() to be safe
 		retval_tmp.reset();
 		};
-	// return the canonical name
-	return retval;
+	return retval;	// return the canonical name
 }
 
 type_system::type_index type_system::register_functype(const char* const alias, function_type*& src)



From zaimoni at mail.berlios.de  Fri Oct 29 00:33:13 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 29 Oct 2010 00:33:13 +0200
Subject: [Zcplusplus-commits] r509 - trunk
Message-ID: <20101028223314.3DFBD480F4D@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-29 00:33:13 +0200 (Fri, 29 Oct 2010)
New Revision: 509

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/CSupport_pp.cpp
Log:
stage 3: line count reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-28 21:32:14 UTC (rev 508)
+++ trunk/CSupport.cpp	2010-10-28 22:33:13 UTC (rev 509)
@@ -197,10 +197,7 @@
 
 bool IsUnaccentedAlphabeticChar(unsigned char x)
 {	// FORMALLY CORRECT: Kenneth Boyd, 7/29/2001
-	if (   in_range<'A','Z'>(x)
-		|| in_range<'a','z'>(x))
-		return true;
-	return false;
+	return in_range<'A','Z'>(x) || in_range<'a','z'>(x);
 }
 
 bool IsAlphabeticChar(unsigned char x)
@@ -211,8 +208,8 @@
 //		|| (unsigned char)('\x8c')==x				// OE ligature
 //		|| (unsigned char)('\x9c')==x				// oe ligature
 //		|| (unsigned char)('\x9f')==x				// Y umlaut
-		|| ((unsigned char)('\xc0')<=x && (unsigned char)('\xd6')>=x)	// various accented characters
-		|| ((unsigned char)('\xd8')<=x && (unsigned char)('\xf6')>=x)	// various accented characters
+		|| in_range<'\xc0','\xd6'>(x)	// various accented characters
+		|| in_range<'\xd8','\xf6'>(x)	// various accented characters
 		|| ((unsigned char)('\xf8')<=x /* && (unsigned char)('\xff')>=x */))	// various accented characters
 		return true;
 	return false;
@@ -220,10 +217,8 @@
 
 bool C_IsLegalSourceChar(char x)
 {
-	if (   IsAlphabeticChar(x)
-		|| in_range<'0','9'>(x)
-		|| strchr(C_WHITESPACE,x)
-		|| strchr(C_ATOMIC_CHAR,x)
+	if (   IsAlphabeticChar(x) || in_range<'0','9'>(x)
+		|| strchr(C_WHITESPACE,x) || strchr(C_ATOMIC_CHAR,x)
 		|| strchr("_#<>%:.*+?/^&|!=\\",x))
 		return true;
 	return false;
@@ -235,13 +230,6 @@
 }
 
 #if 0
-static bool C_ExtendedSource(unsigned char x)
-{
-	return in_range<'\xA0','\xFF'>(x);	//! \todo fix: assumes CHAR_BIT 8, UNICODE
-}
-#endif
-
-#if 0
 	identifier
 		nondigit
 		identifier nondigit
@@ -258,7 +246,7 @@
 
 size_t LengthOfCIdentifier(const char* const x)
 {	//! \todo should handle universal character names
-	assert(NULL!=x);
+	assert(x);
 	const char* x2 = x;
 	if (IsAlphabeticChar(*x2) || '_'==*x2)
 		while(IsCIdentifierChar(*++x2));
@@ -277,12 +265,11 @@
 #endif
 size_t LengthOfCPreprocessingNumber(const char* const x)
 {
-	assert(NULL!=x);
+	assert(x);
 	size_t i = 0;	// Length
 	if (IsNumericChar(*x)) i = 1;
 	else if ('.'==*x && IsNumericChar(x[1])) i = 2;
 	if (0<i)
-		{
 		do	if ('.'==x[i] || IsNumericChar(x[i]))
 				++i;
 			else if (IsAlphabeticChar(x[i]))
@@ -293,55 +280,49 @@
 				else
 					i += 1;
 				}
-			else
-				return i;
+			else return i;
 		while(1);
-		};
 	return 0;
 }
 
 size_t LengthOfCCharLiteral(const char* const x)
 {	// FORMALLY CORRECT: Kenneth Boyd, 10/17/2004
-	size_t Length = 0;
-	if ('\''==*x)
-		Length = 1;
-	else if ('L'==x[0] && '\''==x[1])
-		Length = 2;
-	if (0==Length) return 0;
+	size_t Length;
+	if ('\''==*x) Length = 1;
+	else if ('L'==x[0] && '\''==x[1]) Length = 2;
+	else return 0;
 
 	const char* base = x+Length;
 	const char* find_end = strpbrk(base,"\\'\n");
-	while(NULL!=find_end)
+	while(find_end)
 		{
 		Length = find_end-x+1;
 		if ('\''==find_end[0]) return Length;
 		if ('\n'==find_end[0]) return Length-1;
 		if ('\0'==find_end[1]) return Length;
 		base = find_end+2;
-		find_end = ('\0'==base[0]) ? NULL : strpbrk(base,"\\'\n");
+		find_end = !base[0] ? NULL : strpbrk(base,"\\'\n");
 		};
 	return strlen(x);
 }
 
 size_t LengthOfCStringLiteral(const char* const x)
 {	// FORMALLY CORRECT: Kenneth Boyd, 10/17/2004
-	size_t Length = 0;
-	if ('"'==*x)
-		Length = 1;
-	else if ('L'==x[0] && '"'==x[1])
-		Length = 2;
-	if (0==Length) return 0;
+	size_t Length;
+	if ('"'==*x) Length = 1;
+	else if ('L'==x[0] && '"'==x[1]) Length = 2;
+	else return 0;
 
 	const char* base = x+Length;
 	const char* find_end = strpbrk(base,"\\\"\n");
-	while(NULL!=find_end)
+	while(find_end)
 		{
 		Length = find_end-x+1;
 		if ('"'==find_end[0]) return Length;
 		if ('\n'==find_end[0]) return Length-1;
 		if ('\0'==find_end[1]) return Length;
 		base = find_end+2;
-		find_end = ('\0'==base[0]) ? NULL : strpbrk(base,"\\\"\n");
+		find_end = !base[0] ? NULL : strpbrk(base,"\\\"\n");
 		};
 	return strlen(x);
 }

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-28 21:32:14 UTC (rev 508)
+++ trunk/CSupport.cpp.in	2010-10-28 22:33:13 UTC (rev 509)
@@ -215,10 +215,7 @@
 
 bool IsUnaccentedAlphabeticChar(unsigned char x)
 {	// FORMALLY CORRECT: Kenneth Boyd, 7/29/2001
-	if (   in_range<'A','Z'>(x)
-		|| in_range<'a','z'>(x))
-		return true;
-	return false;
+	return in_range<'A','Z'>(x) || in_range<'a','z'>(x);
 }
 
 bool IsAlphabeticChar(unsigned char x)
@@ -229,8 +226,8 @@
 //		|| (unsigned char)('\x8c')==x				// OE ligature
 //		|| (unsigned char)('\x9c')==x				// oe ligature
 //		|| (unsigned char)('\x9f')==x				// Y umlaut
-		|| ((unsigned char)('\xc0')<=x && (unsigned char)('\xd6')>=x)	// various accented characters
-		|| ((unsigned char)('\xd8')<=x && (unsigned char)('\xf6')>=x)	// various accented characters
+		|| in_range<'\xc0','\xd6'>(x)	// various accented characters
+		|| in_range<'\xd8','\xf6'>(x)	// various accented characters
 		|| ((unsigned char)('\xf8')<=x /* && (unsigned char)('\xff')>=x */))	// various accented characters
 		return true;
 	return false;
@@ -238,10 +235,8 @@
 
 bool C_IsLegalSourceChar(char x)
 {
-	if (   IsAlphabeticChar(x)
-		|| in_range<'0','9'>(x)
-		|| strchr(C_WHITESPACE,x)
-		|| strchr(C_ATOMIC_CHAR,x)
+	if (   IsAlphabeticChar(x) || in_range<'0','9'>(x)
+		|| strchr(C_WHITESPACE,x) || strchr(C_ATOMIC_CHAR,x)
 		|| strchr("_#<>%:.*+?/^&|!=\\",x))
 		return true;
 	return false;
@@ -253,13 +248,6 @@
 }
 
 #if 0
-static bool C_ExtendedSource(unsigned char x)
-{
-	return in_range<'\xA0','\xFF'>(x);	//! \todo fix: assumes CHAR_BIT 8, UNICODE
-}
-#endif
-
-#if 0
 	identifier
 		nondigit
 		identifier nondigit
@@ -276,7 +264,7 @@
 
 size_t LengthOfCIdentifier(const char* const x)
 {	//! \todo should handle universal character names
-	assert(NULL!=x);
+	assert(x);
 	const char* x2 = x;
 	if (IsAlphabeticChar(*x2) || '_'==*x2)
 		while(IsCIdentifierChar(*++x2));
@@ -295,12 +283,11 @@
 #endif
 size_t LengthOfCPreprocessingNumber(const char* const x)
 {
-	assert(NULL!=x);
+	assert(x);
 	size_t i = 0;	// Length
 	if (IsNumericChar(*x)) i = 1;
 	else if ('.'==*x && IsNumericChar(x[1])) i = 2;
 	if (0<i)
-		{
 		do	if ('.'==x[i] || IsNumericChar(x[i]))
 				++i;
 			else if (IsAlphabeticChar(x[i]))
@@ -311,55 +298,49 @@
 				else
 					i += 1;
 				}
-			else
-				return i;
+			else return i;
 		while(1);
-		};
 	return 0;
 }
 
 size_t LengthOfCCharLiteral(const char* const x)
 {	// FORMALLY CORRECT: Kenneth Boyd, 10/17/2004
-	size_t Length = 0;
-	if ('\''==*x)
-		Length = 1;
-	else if ('L'==x[0] && '\''==x[1])
-		Length = 2;
-	if (0==Length) return 0;
+	size_t Length;
+	if ('\''==*x) Length = 1;
+	else if ('L'==x[0] && '\''==x[1]) Length = 2;
+	else return 0;
 
 	const char* base = x+Length;
 	const char* find_end = strpbrk(base,"\\'\n");
-	while(NULL!=find_end)
+	while(find_end)
 		{
 		Length = find_end-x+1;
 		if ('\''==find_end[0]) return Length;
 		if ('\n'==find_end[0]) return Length-1;
 		if ('\0'==find_end[1]) return Length;
 		base = find_end+2;
-		find_end = ('\0'==base[0]) ? NULL : strpbrk(base,"\\'\n");
+		find_end = !base[0] ? NULL : strpbrk(base,"\\'\n");
 		};
 	return strlen(x);
 }
 
 size_t LengthOfCStringLiteral(const char* const x)
 {	// FORMALLY CORRECT: Kenneth Boyd, 10/17/2004
-	size_t Length = 0;
-	if ('"'==*x)
-		Length = 1;
-	else if ('L'==x[0] && '"'==x[1])
-		Length = 2;
-	if (0==Length) return 0;
+	size_t Length;
+	if ('"'==*x) Length = 1;
+	else if ('L'==x[0] && '"'==x[1]) Length = 2;
+	else return 0;
 
 	const char* base = x+Length;
 	const char* find_end = strpbrk(base,"\\\"\n");
-	while(NULL!=find_end)
+	while(find_end)
 		{
 		Length = find_end-x+1;
 		if ('"'==find_end[0]) return Length;
 		if ('\n'==find_end[0]) return Length-1;
 		if ('\0'==find_end[1]) return Length;
 		base = find_end+2;
-		find_end = ('\0'==base[0]) ? NULL : strpbrk(base,"\\\"\n");
+		find_end = !base[0] ? NULL : strpbrk(base,"\\\"\n");
 		};
 	return strlen(x);
 }

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-10-28 21:32:14 UTC (rev 508)
+++ trunk/CSupport_pp.cpp	2010-10-28 22:33:13 UTC (rev 509)
@@ -191,10 +191,7 @@
 
 bool IsUnaccentedAlphabeticChar(unsigned char x)
 {	// FORMALLY CORRECT: Kenneth Boyd, 7/29/2001
-	if (   in_range<'A','Z'>(x)
-		|| in_range<'a','z'>(x))
-		return true;
-	return false;
+	return in_range<'A','Z'>(x) || in_range<'a','z'>(x);
 }
 
 bool IsAlphabeticChar(unsigned char x)
@@ -205,8 +202,8 @@
 //		|| (unsigned char)('\x8c')==x				// OE ligature
 //		|| (unsigned char)('\x9c')==x				// oe ligature
 //		|| (unsigned char)('\x9f')==x				// Y umlaut
-		|| ((unsigned char)('\xc0')<=x && (unsigned char)('\xd6')>=x)	// various accented characters
-		|| ((unsigned char)('\xd8')<=x && (unsigned char)('\xf6')>=x)	// various accented characters
+		|| in_range<'\xc0','\xd6'>(x)	// various accented characters
+		|| in_range<'\xd8','\xf6'>(x)	// various accented characters
 		|| ((unsigned char)('\xf8')<=x /* && (unsigned char)('\xff')>=x */))	// various accented characters
 		return true;
 	return false;
@@ -214,10 +211,8 @@
 
 bool C_IsLegalSourceChar(char x)
 {
-	if (   IsAlphabeticChar(x)
-		|| in_range<'0','9'>(x)
-		|| strchr(C_WHITESPACE,x)
-		|| strchr(C_ATOMIC_CHAR,x)
+	if (   IsAlphabeticChar(x) || in_range<'0','9'>(x)
+		|| strchr(C_WHITESPACE,x) || strchr(C_ATOMIC_CHAR,x)
 		|| strchr("_#<>%:.*+?/^&|!=\\",x))
 		return true;
 	return false;
@@ -229,13 +224,6 @@
 }
 
 #if 0
-static bool C_ExtendedSource(unsigned char x)
-{
-	return in_range<'\xA0','\xFF'>(x);	//! \todo fix: assumes CHAR_BIT 8, UNICODE
-}
-#endif
-
-#if 0
 	identifier
 		nondigit
 		identifier nondigit
@@ -252,7 +240,7 @@
 
 size_t LengthOfCIdentifier(const char* const x)
 {	//! \todo should handle universal character names
-	assert(NULL!=x);
+	assert(x);
 	const char* x2 = x;
 	if (IsAlphabeticChar(*x2) || '_'==*x2)
 		while(IsCIdentifierChar(*++x2));
@@ -271,12 +259,11 @@
 #endif
 size_t LengthOfCPreprocessingNumber(const char* const x)
 {
-	assert(NULL!=x);
+	assert(x);
 	size_t i = 0;	// Length
 	if (IsNumericChar(*x)) i = 1;
 	else if ('.'==*x && IsNumericChar(x[1])) i = 2;
 	if (0<i)
-		{
 		do	if ('.'==x[i] || IsNumericChar(x[i]))
 				++i;
 			else if (IsAlphabeticChar(x[i]))
@@ -287,55 +274,49 @@
 				else
 					i += 1;
 				}
-			else
-				return i;
+			else return i;
 		while(1);
-		};
 	return 0;
 }
 
 size_t LengthOfCCharLiteral(const char* const x)
 {	// FORMALLY CORRECT: Kenneth Boyd, 10/17/2004
-	size_t Length = 0;
-	if ('\''==*x)
-		Length = 1;
-	else if ('L'==x[0] && '\''==x[1])
-		Length = 2;
-	if (0==Length) return 0;
+	size_t Length;
+	if ('\''==*x) Length = 1;
+	else if ('L'==x[0] && '\''==x[1]) Length = 2;
+	else return 0;
 
 	const char* base = x+Length;
 	const char* find_end = strpbrk(base,"\\'\n");
-	while(NULL!=find_end)
+	while(find_end)
 		{
 		Length = find_end-x+1;
 		if ('\''==find_end[0]) return Length;
 		if ('\n'==find_end[0]) return Length-1;
 		if ('\0'==find_end[1]) return Length;
 		base = find_end+2;
-		find_end = ('\0'==base[0]) ? NULL : strpbrk(base,"\\'\n");
+		find_end = !base[0] ? NULL : strpbrk(base,"\\'\n");
 		};
 	return strlen(x);
 }
 
 size_t LengthOfCStringLiteral(const char* const x)
 {	// FORMALLY CORRECT: Kenneth Boyd, 10/17/2004
-	size_t Length = 0;
-	if ('"'==*x)
-		Length = 1;
-	else if ('L'==x[0] && '"'==x[1])
-		Length = 2;
-	if (0==Length) return 0;
+	size_t Length;
+	if ('"'==*x) Length = 1;
+	else if ('L'==x[0] && '"'==x[1]) Length = 2;
+	else return 0;
 
 	const char* base = x+Length;
 	const char* find_end = strpbrk(base,"\\\"\n");
-	while(NULL!=find_end)
+	while(find_end)
 		{
 		Length = find_end-x+1;
 		if ('"'==find_end[0]) return Length;
 		if ('\n'==find_end[0]) return Length-1;
 		if ('\0'==find_end[1]) return Length;
 		base = find_end+2;
-		find_end = ('\0'==base[0]) ? NULL : strpbrk(base,"\\\"\n");
+		find_end = !base[0] ? NULL : strpbrk(base,"\\\"\n");
 		};
 	return strlen(x);
 }



From zaimoni at mail.berlios.de  Fri Oct 29 00:39:06 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 29 Oct 2010 00:39:06 +0200
Subject: [Zcplusplus-commits] r510 - trunk
Message-ID: <20101028223906.CD0B5480C84@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-29 00:39:06 +0200 (Fri, 29 Oct 2010)
New Revision: 510

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/CSupport_pp.cpp
Log:
stage 3: line count reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-28 22:33:13 UTC (rev 509)
+++ trunk/CSupport.cpp	2010-10-28 22:39:06 UTC (rev 510)
@@ -509,7 +509,7 @@
 
 static const char* C99_echo_reserved_keyword(const char* x,size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(x_len<=strlen(x));
 	size_t i = C_KEYWORD_STRICT_UB-C_KEYWORD_NONSTRICT_LB;
 	do	if (x_len==valid_keyword[C_KEYWORD_NONSTRICT_LB + --i].second && !strncmp(valid_keyword[C_KEYWORD_NONSTRICT_LB + i].first,x,x_len))
@@ -520,7 +520,7 @@
 
 static const char* CPP_echo_reserved_keyword(const char* x,size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(x_len<=strlen(x));
 	size_t i = CPP_KEYWORD_STRICT_UB-CPP_KEYWORD_NONSTRICT_LB;
 	do	if (x_len==valid_keyword[CPP_KEYWORD_NONSTRICT_LB + --i].second && !strncmp(valid_keyword[CPP_KEYWORD_NONSTRICT_LB + i].first,x,x_len))
@@ -531,7 +531,7 @@
 
 static const char* C99_echo_reserved_symbol(const char* x,size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(x_len<=strlen(x));
 	size_t i = C_PREPROC_OP_STRICT_UB;
 	do	if (x_len==valid_pure_preprocessing_op_punc[--i].second && !strncmp(valid_pure_preprocessing_op_punc[i].first,x,x_len))
@@ -542,7 +542,7 @@
 
 static const char* CPP_echo_reserved_symbol(const char* x,size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(x_len<=strlen(x));
 	size_t i = CPP_PREPROC_OP_STRICT_UB;
 	do	if (x_len==valid_pure_preprocessing_op_punc[--i].second && !strncmp(valid_pure_preprocessing_op_punc[i].first,x,x_len))
@@ -592,28 +592,6 @@
 	return C_TYPE::SCHAR+2*(x-virtual_machine::std_int_char)+1;
 }
 
-#if 0
-static bool is_innate_type(size_t base_type_index)
-{
-	return C_TYPE::VOID<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
-}
-
-static bool is_innate_nonvoid_type(size_t base_type_index)
-{
-	return C_TYPE::NOT_VOID<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
-}
-
-static bool is_innate_integerlike(size_t base_type_index)
-{	// intentionally does not handle enum types
-	return C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index;
-}
-
-static bool is_innate_floatcomplexlike(size_t base_type_index)
-{
-	return C_TYPE::FLOAT<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
-}
-#endif
-
 static bool is_innate_definite_type(size_t base_type_index)
 {
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
@@ -766,21 +744,15 @@
 	if (0==base_type_index1%2)
 		{	// first is unsigned
 		if ((base_type_index1-1)/2>=(base_type_index2-1)/2)
-			{
 			return base_type_index1;
-			}
-		else{
+		else
 			return base_type_index2;
-			}
 		}
 	else{	// second is unsigned
 		if ((base_type_index1-1)/2<=(base_type_index2-1)/2)
-			{
 			return base_type_index2;
-			}
-		else{
+		else
 			return base_type_index1;
-			}
 		}
 }
 
@@ -1200,7 +1172,7 @@
 static POD_pair<size_t,size_t>
 _balanced_character_count(const weak_token* tokenlist,size_t tokenlist_len,const char l_match,const char r_match)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0,0};
 	const weak_token* const iter_end = tokenlist+tokenlist_len;
@@ -1217,7 +1189,7 @@
 template<char l_match,char r_match>
 inline static POD_pair<size_t,size_t> balanced_character_count(const weak_token* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	return _balanced_character_count(tokenlist,tokenlist_len,l_match,r_match);
 }
@@ -1225,7 +1197,7 @@
 template<>
 POD_pair<size_t,size_t> balanced_character_count<'[',']'>(const weak_token* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0, 0};
 	const weak_token* const iter_end = tokenlist+tokenlist_len;
@@ -1239,7 +1211,7 @@
 template<>
 POD_pair<size_t,size_t> balanced_character_count<'{','}'>(const weak_token* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0, 0};
 	const weak_token* const iter_end = tokenlist+tokenlist_len;
@@ -1253,12 +1225,12 @@
 static POD_pair<size_t,size_t>
 _balanced_character_count(const parse_tree* tokenlist,size_t tokenlist_len,const char l_match,const char r_match)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0, 0};
 	const parse_tree* const iter_end = tokenlist+tokenlist_len;
 	const parse_tree* iter = tokenlist;
-	do	if (1==iter->index_tokens[0].token.second && NULL==iter->index_tokens[1].token.first)
+	do	if (1==iter->index_tokens[0].token.second && !iter->index_tokens[1].token.first)
 			{
 			if 		(l_match==iter->index_tokens[0].token.first[0]) ++depth.first;
 			else if (r_match==iter->index_tokens[0].token.first[0]) ++depth.second;
@@ -1270,7 +1242,7 @@
 template<char l_match,char r_match>
 inline static POD_pair<size_t,size_t> balanced_character_count(const parse_tree* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	return _balanced_character_count(tokenlist,tokenlist_len,l_match,r_match);
 }
@@ -1278,12 +1250,12 @@
 template<>
 POD_pair<size_t,size_t> balanced_character_count<'[',']'>(const parse_tree* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0, 0};
 	const parse_tree* const iter_end = tokenlist+tokenlist_len;
 	const parse_tree* iter = tokenlist;
-	do	if (NULL==iter->index_tokens[1].token.first)
+	do	if (!iter->index_tokens[1].token.first)
 			{
 			if 		(detect_C_left_bracket_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.first;
 			else if (detect_C_right_bracket_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.second;
@@ -1295,12 +1267,12 @@
 template<>
 POD_pair<size_t,size_t> balanced_character_count<'{','}'>(const parse_tree* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0, 0};
 	const parse_tree* const iter_end = tokenlist+tokenlist_len;
 	const parse_tree* iter = tokenlist;
-	do	if (NULL==iter->index_tokens[1].token.first)
+	do	if (!iter->index_tokens[1].token.first)
 			{
 			if 		(detect_C_left_brace_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.first;
 			else if (detect_C_right_brace_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.second;
@@ -1323,15 +1295,14 @@
 
 static void _construct_matched_pairs(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1,const char l_match,const char r_match)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = _balanced_character_count(tokenlist,tokenlist_len,l_match,r_match);	// pre-scan
 	std::pair<size_t,size_t> unbalanced_loc(0,0);
 	const size_t starting_errors = zcc_errors.err_count();
 
 	if (0<depth.first && 0<depth.second)
-		{
-		// reality-check: balanced parentheses
+		{	// reality-check: balanced parentheses
 		autovalarray_ptr_throws<size_t> fixedstack(depth.first);
 		autovalarray_ptr_throws<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 
@@ -1341,7 +1312,7 @@
 		size_t i = 0;
 		do	if (1==tokenlist[i].token.second)
 				{
-				assert(NULL!=tokenlist[i].token.first);
+				assert(tokenlist[i].token.first);
 				if 		(l_match==tokenlist[i].token.first[0])
 					{	// soft-left: not an error
 					if (0<depth.second)
@@ -1385,7 +1356,7 @@
 template<char l_match,char r_match>
 static void construct_matched_pairs(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	_construct_matched_pairs(tokenlist,tokenlist_len,stack1,l_match,r_match);
 }
@@ -1393,15 +1364,14 @@
 template<>
 void construct_matched_pairs<'[',']'>(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = balanced_character_count<'[',']'>(tokenlist,tokenlist_len);	// pre-scan
 	std::pair<size_t,size_t> unbalanced_loc(0,0);
 	const size_t starting_errors = zcc_errors.err_count();
 
 	if (0<depth.first && 0<depth.second)
-		{
-		// reality-check: balanced parentheses
+		{	// reality-check: balanced parentheses
 		autovalarray_ptr_throws<size_t> fixedstack(depth.first);
 		autovalarray_ptr_throws<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 
@@ -1411,7 +1381,7 @@
 		size_t i = 0;
 		do	if (1==tokenlist[i].token.second)
 				{
-				assert(NULL!=tokenlist[i].token.first);
+				assert(tokenlist[i].token.first);
 				if 		(detect_C_left_bracket_op(tokenlist[i].token.first,tokenlist[i].token.second))
 					{
 					if (0<depth.second)
@@ -1453,15 +1423,14 @@
 template<>
 void construct_matched_pairs<'{','}'>(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = balanced_character_count<'{','}'>(tokenlist,tokenlist_len);	// pre-scan
 	std::pair<size_t,size_t> unbalanced_loc(0,0);
 	const size_t starting_errors = zcc_errors.err_count();
 
 	if (0<depth.first && 0<depth.second)
-		{
-		// reality-check: balanced parentheses
+		{	// reality-check: balanced parentheses
 		autovalarray_ptr_throws<size_t> fixedstack(depth.first);
 		autovalarray_ptr_throws<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 
@@ -1471,7 +1440,7 @@
 		size_t i = 0;
 		do	if (1==tokenlist[i].token.second)
 				{
-				assert(NULL!=tokenlist[i].token.first);
+				assert(tokenlist[i].token.first);
 				if 		(detect_C_left_brace_op(tokenlist[i].token.first,tokenlist[i].token.second))
 					{
 					if (0<depth.second)
@@ -1529,7 +1498,7 @@
 static void
 find_sliced_pairs(const weak_token* tokenlist, const autovalarray_ptr<POD_pair<size_t,size_t> >& stack1, const autovalarray_ptr<POD_pair<size_t,size_t> >& stack2,const std::pair<char,char>& pair1,const std::pair<char,char>& pair2)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	if (stack1.empty()) return;
 	if (stack2.empty()) return;
 	size_t i = 0;
@@ -1575,7 +1544,7 @@
 
 static bool C_like_BalancingCheck(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	autovalarray_ptr<POD_pair<size_t,size_t> > parenpair_stack;
 	autovalarray_ptr<POD_pair<size_t,size_t> > bracketpair_stack;
@@ -1589,7 +1558,7 @@
 		construct_matched_pairs<'[',']'>(tokenlist,tokenlist_len,bracketpair_stack);
 		construct_matched_pairs<'{','}'>(tokenlist,tokenlist_len,bracepair_stack);
 		if (starting_errors==zcc_errors.err_count())
-			{	/* check for slicing */
+			{	// check for slicing
 			const int test_these = (!parenpair_stack.empty())+2*(!bracketpair_stack.empty())+4*(!bracepair_stack.empty());
 			switch(test_these)
 			{

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-28 22:33:13 UTC (rev 509)
+++ trunk/CSupport.cpp.in	2010-10-28 22:39:06 UTC (rev 510)
@@ -528,7 +528,7 @@
 
 static const char* C99_echo_reserved_keyword(const char* x,size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(x_len<=strlen(x));
 	size_t i = C_KEYWORD_STRICT_UB-C_KEYWORD_NONSTRICT_LB;
 	do	if (x_len==valid_keyword[C_KEYWORD_NONSTRICT_LB + --i].second && !strncmp(valid_keyword[C_KEYWORD_NONSTRICT_LB + i].first,x,x_len))
@@ -539,7 +539,7 @@
 
 static const char* CPP_echo_reserved_keyword(const char* x,size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(x_len<=strlen(x));
 	size_t i = CPP_KEYWORD_STRICT_UB-CPP_KEYWORD_NONSTRICT_LB;
 	do	if (x_len==valid_keyword[CPP_KEYWORD_NONSTRICT_LB + --i].second && !strncmp(valid_keyword[CPP_KEYWORD_NONSTRICT_LB + i].first,x,x_len))
@@ -550,7 +550,7 @@
 
 static const char* C99_echo_reserved_symbol(const char* x,size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(x_len<=strlen(x));
 	size_t i = C_PREPROC_OP_STRICT_UB;
 	do	if (x_len==valid_pure_preprocessing_op_punc[--i].second && !strncmp(valid_pure_preprocessing_op_punc[i].first,x,x_len))
@@ -561,7 +561,7 @@
 
 static const char* CPP_echo_reserved_symbol(const char* x,size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(x_len<=strlen(x));
 	size_t i = CPP_PREPROC_OP_STRICT_UB;
 	do	if (x_len==valid_pure_preprocessing_op_punc[--i].second && !strncmp(valid_pure_preprocessing_op_punc[i].first,x,x_len))
@@ -614,28 +614,6 @@
 }
 #/*cut-cpp*/
 
-#if 0
-static bool is_innate_type(size_t base_type_index)
-{
-	return C_TYPE::VOID<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
-}
-
-static bool is_innate_nonvoid_type(size_t base_type_index)
-{
-	return C_TYPE::NOT_VOID<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
-}
-
-static bool is_innate_integerlike(size_t base_type_index)
-{	// intentionally does not handle enum types
-	return C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index;
-}
-
-static bool is_innate_floatcomplexlike(size_t base_type_index)
-{
-	return C_TYPE::FLOAT<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
-}
-#endif
-
 static bool is_innate_definite_type(size_t base_type_index)
 {
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
@@ -810,21 +788,15 @@
 	if (0==base_type_index1%2)
 		{	// first is unsigned
 		if ((base_type_index1-1)/2>=(base_type_index2-1)/2)
-			{
 			return base_type_index1;
-			}
-		else{
+		else
 			return base_type_index2;
-			}
 		}
 	else{	// second is unsigned
 		if ((base_type_index1-1)/2<=(base_type_index2-1)/2)
-			{
 			return base_type_index2;
-			}
-		else{
+		else
 			return base_type_index1;
-			}
 		}
 }
 
@@ -1250,7 +1222,7 @@
 static POD_pair<size_t,size_t>
 _balanced_character_count(const weak_token* tokenlist,size_t tokenlist_len,const char l_match,const char r_match)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0,0};
 	const weak_token* const iter_end = tokenlist+tokenlist_len;
@@ -1267,7 +1239,7 @@
 template<char l_match,char r_match>
 inline static POD_pair<size_t,size_t> balanced_character_count(const weak_token* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	return _balanced_character_count(tokenlist,tokenlist_len,l_match,r_match);
 }
@@ -1275,7 +1247,7 @@
 template<>
 POD_pair<size_t,size_t> balanced_character_count<'[',']'>(const weak_token* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0, 0};
 	const weak_token* const iter_end = tokenlist+tokenlist_len;
@@ -1289,7 +1261,7 @@
 template<>
 POD_pair<size_t,size_t> balanced_character_count<'{','}'>(const weak_token* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0, 0};
 	const weak_token* const iter_end = tokenlist+tokenlist_len;
@@ -1303,12 +1275,12 @@
 static POD_pair<size_t,size_t>
 _balanced_character_count(const parse_tree* tokenlist,size_t tokenlist_len,const char l_match,const char r_match)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0, 0};
 	const parse_tree* const iter_end = tokenlist+tokenlist_len;
 	const parse_tree* iter = tokenlist;
-	do	if (1==iter->index_tokens[0].token.second && NULL==iter->index_tokens[1].token.first)
+	do	if (1==iter->index_tokens[0].token.second && !iter->index_tokens[1].token.first)
 			{
 			if 		(l_match==iter->index_tokens[0].token.first[0]) ++depth.first;
 			else if (r_match==iter->index_tokens[0].token.first[0]) ++depth.second;
@@ -1320,7 +1292,7 @@
 template<char l_match,char r_match>
 inline static POD_pair<size_t,size_t> balanced_character_count(const parse_tree* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	return _balanced_character_count(tokenlist,tokenlist_len,l_match,r_match);
 }
@@ -1328,12 +1300,12 @@
 template<>
 POD_pair<size_t,size_t> balanced_character_count<'[',']'>(const parse_tree* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0, 0};
 	const parse_tree* const iter_end = tokenlist+tokenlist_len;
 	const parse_tree* iter = tokenlist;
-	do	if (NULL==iter->index_tokens[1].token.first)
+	do	if (!iter->index_tokens[1].token.first)
 			{
 			if 		(detect_C_left_bracket_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.first;
 			else if (detect_C_right_bracket_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.second;
@@ -1345,12 +1317,12 @@
 template<>
 POD_pair<size_t,size_t> balanced_character_count<'{','}'>(const parse_tree* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0, 0};
 	const parse_tree* const iter_end = tokenlist+tokenlist_len;
 	const parse_tree* iter = tokenlist;
-	do	if (NULL==iter->index_tokens[1].token.first)
+	do	if (!iter->index_tokens[1].token.first)
 			{
 			if 		(detect_C_left_brace_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.first;
 			else if (detect_C_right_brace_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.second;
@@ -1373,15 +1345,14 @@
 
 static void _construct_matched_pairs(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1,const char l_match,const char r_match)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = _balanced_character_count(tokenlist,tokenlist_len,l_match,r_match);	// pre-scan
 	std::pair<size_t,size_t> unbalanced_loc(0,0);
 	const size_t starting_errors = zcc_errors.err_count();
 
 	if (0<depth.first && 0<depth.second)
-		{
-		// reality-check: balanced parentheses
+		{	// reality-check: balanced parentheses
 		autovalarray_ptr_throws<size_t> fixedstack(depth.first);
 		autovalarray_ptr_throws<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 
@@ -1391,7 +1362,7 @@
 		size_t i = 0;
 		do	if (1==tokenlist[i].token.second)
 				{
-				assert(NULL!=tokenlist[i].token.first);
+				assert(tokenlist[i].token.first);
 				if 		(l_match==tokenlist[i].token.first[0])
 					{	// soft-left: not an error
 					if (0<depth.second)
@@ -1435,7 +1406,7 @@
 template<char l_match,char r_match>
 static void construct_matched_pairs(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	_construct_matched_pairs(tokenlist,tokenlist_len,stack1,l_match,r_match);
 }
@@ -1443,15 +1414,14 @@
 template<>
 void construct_matched_pairs<'[',']'>(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = balanced_character_count<'[',']'>(tokenlist,tokenlist_len);	// pre-scan
 	std::pair<size_t,size_t> unbalanced_loc(0,0);
 	const size_t starting_errors = zcc_errors.err_count();
 
 	if (0<depth.first && 0<depth.second)
-		{
-		// reality-check: balanced parentheses
+		{	// reality-check: balanced parentheses
 		autovalarray_ptr_throws<size_t> fixedstack(depth.first);
 		autovalarray_ptr_throws<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 
@@ -1461,7 +1431,7 @@
 		size_t i = 0;
 		do	if (1==tokenlist[i].token.second)
 				{
-				assert(NULL!=tokenlist[i].token.first);
+				assert(tokenlist[i].token.first);
 				if 		(detect_C_left_bracket_op(tokenlist[i].token.first,tokenlist[i].token.second))
 					{
 					if (0<depth.second)
@@ -1503,15 +1473,14 @@
 template<>
 void construct_matched_pairs<'{','}'>(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = balanced_character_count<'{','}'>(tokenlist,tokenlist_len);	// pre-scan
 	std::pair<size_t,size_t> unbalanced_loc(0,0);
 	const size_t starting_errors = zcc_errors.err_count();
 
 	if (0<depth.first && 0<depth.second)
-		{
-		// reality-check: balanced parentheses
+		{	// reality-check: balanced parentheses
 		autovalarray_ptr_throws<size_t> fixedstack(depth.first);
 		autovalarray_ptr_throws<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 
@@ -1521,7 +1490,7 @@
 		size_t i = 0;
 		do	if (1==tokenlist[i].token.second)
 				{
-				assert(NULL!=tokenlist[i].token.first);
+				assert(tokenlist[i].token.first);
 				if 		(detect_C_left_brace_op(tokenlist[i].token.first,tokenlist[i].token.second))
 					{
 					if (0<depth.second)
@@ -1579,7 +1548,7 @@
 static void
 find_sliced_pairs(const weak_token* tokenlist, const autovalarray_ptr<POD_pair<size_t,size_t> >& stack1, const autovalarray_ptr<POD_pair<size_t,size_t> >& stack2,const std::pair<char,char>& pair1,const std::pair<char,char>& pair2)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	if (stack1.empty()) return;
 	if (stack2.empty()) return;
 	size_t i = 0;
@@ -1625,7 +1594,7 @@
 
 static bool C_like_BalancingCheck(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	autovalarray_ptr<POD_pair<size_t,size_t> > parenpair_stack;
 	autovalarray_ptr<POD_pair<size_t,size_t> > bracketpair_stack;
@@ -1639,7 +1608,7 @@
 		construct_matched_pairs<'[',']'>(tokenlist,tokenlist_len,bracketpair_stack);
 		construct_matched_pairs<'{','}'>(tokenlist,tokenlist_len,bracepair_stack);
 		if (starting_errors==zcc_errors.err_count())
-			{	/* check for slicing */
+			{	// check for slicing
 			const int test_these = (!parenpair_stack.empty())+2*(!bracketpair_stack.empty())+4*(!bracepair_stack.empty());
 			switch(test_these)
 			{

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-10-28 22:33:13 UTC (rev 509)
+++ trunk/CSupport_pp.cpp	2010-10-28 22:39:06 UTC (rev 510)
@@ -537,28 +537,6 @@
 	return (virtual_machine::std_int_enum)((base_type_index-C_TYPE::INT)/2+virtual_machine::std_int_int);
 }
 
-#if 0
-static bool is_innate_type(size_t base_type_index)
-{
-	return C_TYPE::VOID<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
-}
-
-static bool is_innate_nonvoid_type(size_t base_type_index)
-{
-	return C_TYPE::NOT_VOID<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
-}
-
-static bool is_innate_integerlike(size_t base_type_index)
-{	// intentionally does not handle enum types
-	return C_TYPE::BOOL<=base_type_index && C_TYPE::INTEGERLIKE>=base_type_index;
-}
-
-static bool is_innate_floatcomplexlike(size_t base_type_index)
-{
-	return C_TYPE::FLOAT<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
-}
-#endif
-
 static bool is_innate_definite_type(size_t base_type_index)
 {
 	return C_TYPE::BOOL<=base_type_index && C_TYPE::LDOUBLE__COMPLEX>=base_type_index;
@@ -701,21 +679,15 @@
 	if (0==base_type_index1%2)
 		{	// first is unsigned
 		if ((base_type_index1-1)/2>=(base_type_index2-1)/2)
-			{
 			return base_type_index1;
-			}
-		else{
+		else
 			return base_type_index2;
-			}
 		}
 	else{	// second is unsigned
 		if ((base_type_index1-1)/2<=(base_type_index2-1)/2)
-			{
 			return base_type_index2;
-			}
-		else{
+		else
 			return base_type_index1;
-			}
 		}
 }
 
@@ -979,7 +951,7 @@
 static POD_pair<size_t,size_t>
 _balanced_character_count(const weak_token* tokenlist,size_t tokenlist_len,const char l_match,const char r_match)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0,0};
 	const weak_token* const iter_end = tokenlist+tokenlist_len;
@@ -996,7 +968,7 @@
 template<char l_match,char r_match>
 inline static POD_pair<size_t,size_t> balanced_character_count(const weak_token* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	return _balanced_character_count(tokenlist,tokenlist_len,l_match,r_match);
 }
@@ -1004,7 +976,7 @@
 template<>
 POD_pair<size_t,size_t> balanced_character_count<'[',']'>(const weak_token* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0, 0};
 	const weak_token* const iter_end = tokenlist+tokenlist_len;
@@ -1018,7 +990,7 @@
 template<>
 POD_pair<size_t,size_t> balanced_character_count<'{','}'>(const weak_token* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0, 0};
 	const weak_token* const iter_end = tokenlist+tokenlist_len;
@@ -1032,12 +1004,12 @@
 static POD_pair<size_t,size_t>
 _balanced_character_count(const parse_tree* tokenlist,size_t tokenlist_len,const char l_match,const char r_match)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0, 0};
 	const parse_tree* const iter_end = tokenlist+tokenlist_len;
 	const parse_tree* iter = tokenlist;
-	do	if (1==iter->index_tokens[0].token.second && NULL==iter->index_tokens[1].token.first)
+	do	if (1==iter->index_tokens[0].token.second && !iter->index_tokens[1].token.first)
 			{
 			if 		(l_match==iter->index_tokens[0].token.first[0]) ++depth.first;
 			else if (r_match==iter->index_tokens[0].token.first[0]) ++depth.second;
@@ -1049,7 +1021,7 @@
 template<char l_match,char r_match>
 inline static POD_pair<size_t,size_t> balanced_character_count(const parse_tree* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	return _balanced_character_count(tokenlist,tokenlist_len,l_match,r_match);
 }
@@ -1057,12 +1029,12 @@
 template<>
 POD_pair<size_t,size_t> balanced_character_count<'[',']'>(const parse_tree* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0, 0};
 	const parse_tree* const iter_end = tokenlist+tokenlist_len;
 	const parse_tree* iter = tokenlist;
-	do	if (NULL==iter->index_tokens[1].token.first)
+	do	if (!iter->index_tokens[1].token.first)
 			{
 			if 		(detect_C_left_bracket_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.first;
 			else if (detect_C_right_bracket_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.second;
@@ -1074,12 +1046,12 @@
 template<>
 POD_pair<size_t,size_t> balanced_character_count<'{','}'>(const parse_tree* tokenlist,size_t tokenlist_len)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = {0, 0};
 	const parse_tree* const iter_end = tokenlist+tokenlist_len;
 	const parse_tree* iter = tokenlist;
-	do	if (NULL==iter->index_tokens[1].token.first)
+	do	if (!iter->index_tokens[1].token.first)
 			{
 			if 		(detect_C_left_brace_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.first;
 			else if (detect_C_right_brace_op(iter->index_tokens[0].token.first,iter->index_tokens[0].token.second)) ++depth.second;
@@ -1102,15 +1074,14 @@
 
 static void _construct_matched_pairs(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1,const char l_match,const char r_match)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = _balanced_character_count(tokenlist,tokenlist_len,l_match,r_match);	// pre-scan
 	std::pair<size_t,size_t> unbalanced_loc(0,0);
 	const size_t starting_errors = zcc_errors.err_count();
 
 	if (0<depth.first && 0<depth.second)
-		{
-		// reality-check: balanced parentheses
+		{	// reality-check: balanced parentheses
 		autovalarray_ptr_throws<size_t> fixedstack(depth.first);
 		autovalarray_ptr_throws<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 
@@ -1120,7 +1091,7 @@
 		size_t i = 0;
 		do	if (1==tokenlist[i].token.second)
 				{
-				assert(NULL!=tokenlist[i].token.first);
+				assert(tokenlist[i].token.first);
 				if 		(l_match==tokenlist[i].token.first[0])
 					{	// soft-left: not an error
 					if (0<depth.second)
@@ -1164,7 +1135,7 @@
 template<char l_match,char r_match>
 static void construct_matched_pairs(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	_construct_matched_pairs(tokenlist,tokenlist_len,stack1,l_match,r_match);
 }
@@ -1172,15 +1143,14 @@
 template<>
 void construct_matched_pairs<'[',']'>(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = balanced_character_count<'[',']'>(tokenlist,tokenlist_len);	// pre-scan
 	std::pair<size_t,size_t> unbalanced_loc(0,0);
 	const size_t starting_errors = zcc_errors.err_count();
 
 	if (0<depth.first && 0<depth.second)
-		{
-		// reality-check: balanced parentheses
+		{	// reality-check: balanced parentheses
 		autovalarray_ptr_throws<size_t> fixedstack(depth.first);
 		autovalarray_ptr_throws<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 
@@ -1190,7 +1160,7 @@
 		size_t i = 0;
 		do	if (1==tokenlist[i].token.second)
 				{
-				assert(NULL!=tokenlist[i].token.first);
+				assert(tokenlist[i].token.first);
 				if 		(detect_C_left_bracket_op(tokenlist[i].token.first,tokenlist[i].token.second))
 					{
 					if (0<depth.second)
@@ -1232,15 +1202,14 @@
 template<>
 void construct_matched_pairs<'{','}'>(const weak_token* tokenlist,size_t tokenlist_len, autovalarray_ptr<POD_pair<size_t,size_t> >& stack1)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	POD_pair<size_t,size_t> depth = balanced_character_count<'{','}'>(tokenlist,tokenlist_len);	// pre-scan
 	std::pair<size_t,size_t> unbalanced_loc(0,0);
 	const size_t starting_errors = zcc_errors.err_count();
 
 	if (0<depth.first && 0<depth.second)
-		{
-		// reality-check: balanced parentheses
+		{	// reality-check: balanced parentheses
 		autovalarray_ptr_throws<size_t> fixedstack(depth.first);
 		autovalarray_ptr_throws<POD_pair<size_t,size_t> > pair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 
@@ -1250,7 +1219,7 @@
 		size_t i = 0;
 		do	if (1==tokenlist[i].token.second)
 				{
-				assert(NULL!=tokenlist[i].token.first);
+				assert(tokenlist[i].token.first);
 				if 		(detect_C_left_brace_op(tokenlist[i].token.first,tokenlist[i].token.second))
 					{
 					if (0<depth.second)
@@ -1308,7 +1277,7 @@
 static void
 find_sliced_pairs(const weak_token* tokenlist, const autovalarray_ptr<POD_pair<size_t,size_t> >& stack1, const autovalarray_ptr<POD_pair<size_t,size_t> >& stack2,const std::pair<char,char>& pair1,const std::pair<char,char>& pair2)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	if (stack1.empty()) return;
 	if (stack2.empty()) return;
 	size_t i = 0;
@@ -1354,7 +1323,7 @@
 
 static bool C_like_BalancingCheck(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	autovalarray_ptr<POD_pair<size_t,size_t> > parenpair_stack;
 	autovalarray_ptr<POD_pair<size_t,size_t> > bracketpair_stack;
@@ -1368,7 +1337,7 @@
 		construct_matched_pairs<'[',']'>(tokenlist,tokenlist_len,bracketpair_stack);
 		construct_matched_pairs<'{','}'>(tokenlist,tokenlist_len,bracepair_stack);
 		if (starting_errors==zcc_errors.err_count())
-			{	/* check for slicing */
+			{	// check for slicing
 			const int test_these = (!parenpair_stack.empty())+2*(!bracketpair_stack.empty())+4*(!bracepair_stack.empty());
 			switch(test_these)
 			{



From zaimoni at mail.berlios.de  Fri Oct 29 01:00:29 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 29 Oct 2010 01:00:29 +0200
Subject: [Zcplusplus-commits] r511 - trunk
Message-ID: <20101028230030.7742948100B@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-29 01:00:29 +0200 (Fri, 29 Oct 2010)
New Revision: 511

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/CSupport_pp.cpp
Log:
stage 3: line count reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-28 22:39:06 UTC (rev 510)
+++ trunk/CSupport.cpp	2010-10-28 23:00:29 UTC (rev 511)
@@ -1593,36 +1593,34 @@
 static inline bool
 robust_token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
 {
-	assert(NULL!=target);
+	assert(target);
 	assert(targ_len==strlen(target));
-	return NULL!=x.first && targ_len==x.second
-		&& !strncmp(x.first,target,targ_len);
+	return x.first && targ_len==x.second && !strncmp(x.first,target,targ_len);
 }
 
 static inline bool
 robust_token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
 {
-	assert(NULL!=target);
+	assert(target);
 	const size_t targ_len = strlen(target);
-	return NULL!=x.first && targ_len==x.second
-		&& !strncmp(x.first,target,targ_len);
+	return x.first && targ_len==x.second && !strncmp(x.first,target,targ_len);
 }
 
 template<size_t targ_len>
 static inline bool
 token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
 {
-	assert(NULL!=target);
+	assert(target);
 	assert(targ_len==strlen(target));
-	assert(NULL!=x.first);
+	assert(x.first);
 	return targ_len==x.second && !strncmp(x.first,target,targ_len);
 }
 
 static inline bool
 token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
 {
-	assert(NULL!=target);
-	assert(NULL!=x.first);
+	assert(target);
+	assert(x.first);
 	const size_t targ_len = strlen(target);
 	return targ_len==x.second && !strncmp(x.first,target,targ_len);
 }
@@ -1644,79 +1642,79 @@
 static inline bool
 token_is_char(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return 1==x.second && c== *x.first;
 }
 
 template<>
 inline bool token_is_char<'#'>(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return detect_C_stringize_op(x.first,x.second);
 }
 
 template<>
 inline bool token_is_char<'['>(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return detect_C_left_bracket_op(x.first,x.second);
 }
 
 template<>
 inline bool token_is_char<']'>(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return detect_C_right_bracket_op(x.first,x.second);
 }
 
 template<>
 inline bool token_is_char<'{'>(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return detect_C_left_brace_op(x.first,x.second);
 }
 
 template<>
 inline bool token_is_char<'}'>(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return detect_C_right_brace_op(x.first,x.second);
 }
 
 template<char c>
 inline bool robust_token_is_char(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && 1==x.second && c== *x.first;
+	return x.first && 1==x.second && c== *x.first;
 }
 
 template<>
 inline bool robust_token_is_char<'#'>(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && detect_C_stringize_op(x.first,x.second);
+	return x.first && detect_C_stringize_op(x.first,x.second);
 }
 
 template<>
 inline bool robust_token_is_char<'['>(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && detect_C_left_bracket_op(x.first,x.second);
+	return x.first && detect_C_left_bracket_op(x.first,x.second);
 }
 
 template<>
 inline bool robust_token_is_char<']'>(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && detect_C_right_bracket_op(x.first,x.second);
+	return x.first && detect_C_right_bracket_op(x.first,x.second);
 }
 
 template<>
 inline bool robust_token_is_char<'{'>(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && detect_C_left_brace_op(x.first,x.second);
+	return x.first && detect_C_left_brace_op(x.first,x.second);
 }
 
 template<>
 inline bool robust_token_is_char<'}'>(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && detect_C_right_brace_op(x.first,x.second);
+	return x.first && detect_C_right_brace_op(x.first,x.second);
 }
 
 template<char c> inline bool robust_token_is_char(const parse_tree& x)
@@ -1826,7 +1824,7 @@
 
 static bool C99_CoreControlExpressionContextFreeErrorCount(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	const size_t starting_errors = zcc_errors.err_count();
 	bool already_errored = false;
@@ -1879,14 +1877,14 @@
 
 static bool C99_ControlExpressionContextFreeErrorCount(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	return C99_CoreControlExpressionContextFreeErrorCount(tokenlist,tokenlist_len,hard_start,hard_end);
 }
 
 static bool CPP_ControlExpressionContextFreeErrorCount(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	return C99_CoreControlExpressionContextFreeErrorCount(tokenlist,tokenlist_len,hard_start,hard_end);
 }
@@ -2075,7 +2073,7 @@
 
 static size_t LengthOfEscapedCString(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	size_t actual_size = src_len;
 	size_t i = 0;
@@ -2152,7 +2150,7 @@
 
 static size_t LengthOfEscapedCString(const my_UNICODE* src, size_t src_len)
 {	//! \todo synchronize with EscapeCString
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	size_t actual_size = src_len;
 	size_t i = 0;
@@ -2166,8 +2164,7 @@
 				continue;
 				};
 			if (!C_IsPrintableChar(src[i]))
-				{
-				// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
+				{	// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
 				my_UNICODE tmp = src[i];
 				bool must_escape = (1<src_len-i && strchr(list_hexadecimal_digits,src[i+1]));
 				//! \todo fix to handle target CHAR_BIT different than ours
@@ -2229,7 +2226,7 @@
 
 static void EscapeCString(char* dest, const char* src, size_t src_len)
 {	// \todo fix ASCII dependency.
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	size_t i = 0;
 	do	{
@@ -2254,8 +2251,7 @@
 		// however, octal isn't that user friendly; we clearly want to octal-escape only through 7
 		// \bug need test cases
 		if (!C_IsPrintableChar(src[i]))
-			{
-			// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
+			{	// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
 			unsigned char tmp = src[i];
 			bool must_escape = (1<src_len-i && strchr(list_hexadecimal_digits,src[i+1]));
 			*(dest++) = '\\';
@@ -2367,7 +2363,7 @@
 
 static void EscapeCString(char* dest, const my_UNICODE* src, size_t src_len)
 {	// \todo fix ASCII dependency.
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	size_t i = 0;
 	do	{
@@ -2392,8 +2388,7 @@
 		// however, octal isn't that user friendly; we clearly want to octal-escape only through 7
 		// \bug need test cases
 		if (!C_IsPrintableChar(src[i]))
-			{
-			// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
+			{	// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
 			my_UNICODE tmp = src[i];
 			bool must_escape = (1<src_len-i && UCHAR_MAX>=src[i] && strchr(list_hexadecimal_digits,src[i+1]));
 			*(dest++) = '\\';
@@ -2489,14 +2484,14 @@
 
 static size_t octal_escape_length(const char* const src, const size_t ub)
 {
-	assert(NULL!=src);
+	assert(src);
 	const size_t oct_len = strspn(src,C_OCTAL_DIGITS);
 	return (ub<oct_len) ? ub : oct_len;
 }
 
 static unsigned int eval_octal_escape(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len && src_len<=3);
 	unsigned int tmp = 0;
 	do	{
@@ -2511,14 +2506,14 @@
 
 static size_t hex_escape_length(const char* const src, const size_t ub)
 {
-	assert(NULL!=src);
+	assert(src);
 	const size_t hex_len = strspn(src,C_HEXADECIMAL_DIGITS);
 	return (ub<hex_len) ? ub : hex_len;
 }
 
 static umaxint eval_hex_escape(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 #ifndef NDEBUG
@@ -2539,7 +2534,7 @@
 // must remain synchronized with RobustEscapedCharLength_C
 static size_t EscapedCharLength_C(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	if ('\\' != *src) return 1;
 	assert(1<src_len && '\0'!=src[1]);
@@ -2574,7 +2569,7 @@
 // must remain synchronized with EscapedCharLength_C
 static size_t RobustEscapedCharLength_C(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	if ('\\' != *src) return 1;
 	if (1>=src_len || '\0'==src[1]) return 0;
@@ -2608,7 +2603,7 @@
 
 static size_t LengthOfUnescapedCString(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 
 	size_t analyze_length = 0;

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-28 22:39:06 UTC (rev 510)
+++ trunk/CSupport.cpp.in	2010-10-28 23:00:29 UTC (rev 511)
@@ -1643,36 +1643,34 @@
 static inline bool
 robust_token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
 {
-	assert(NULL!=target);
+	assert(target);
 	assert(targ_len==strlen(target));
-	return NULL!=x.first && targ_len==x.second
-		&& !strncmp(x.first,target,targ_len);
+	return x.first && targ_len==x.second && !strncmp(x.first,target,targ_len);
 }
 
 static inline bool
 robust_token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
 {
-	assert(NULL!=target);
+	assert(target);
 	const size_t targ_len = strlen(target);
-	return NULL!=x.first && targ_len==x.second
-		&& !strncmp(x.first,target,targ_len);
+	return x.first && targ_len==x.second && !strncmp(x.first,target,targ_len);
 }
 
 template<size_t targ_len>
 static inline bool
 token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
 {
-	assert(NULL!=target);
+	assert(target);
 	assert(targ_len==strlen(target));
-	assert(NULL!=x.first);
+	assert(x.first);
 	return targ_len==x.second && !strncmp(x.first,target,targ_len);
 }
 
 static inline bool
 token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
 {
-	assert(NULL!=target);
-	assert(NULL!=x.first);
+	assert(target);
+	assert(x.first);
 	const size_t targ_len = strlen(target);
 	return targ_len==x.second && !strncmp(x.first,target,targ_len);
 }
@@ -1694,79 +1692,79 @@
 static inline bool
 token_is_char(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return 1==x.second && c== *x.first;
 }
 
 template<>
 inline bool token_is_char<'#'>(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return detect_C_stringize_op(x.first,x.second);
 }
 
 template<>
 inline bool token_is_char<'['>(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return detect_C_left_bracket_op(x.first,x.second);
 }
 
 template<>
 inline bool token_is_char<']'>(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return detect_C_right_bracket_op(x.first,x.second);
 }
 
 template<>
 inline bool token_is_char<'{'>(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return detect_C_left_brace_op(x.first,x.second);
 }
 
 template<>
 inline bool token_is_char<'}'>(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return detect_C_right_brace_op(x.first,x.second);
 }
 
 template<char c>
 inline bool robust_token_is_char(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && 1==x.second && c== *x.first;
+	return x.first && 1==x.second && c== *x.first;
 }
 
 template<>
 inline bool robust_token_is_char<'#'>(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && detect_C_stringize_op(x.first,x.second);
+	return x.first && detect_C_stringize_op(x.first,x.second);
 }
 
 template<>
 inline bool robust_token_is_char<'['>(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && detect_C_left_bracket_op(x.first,x.second);
+	return x.first && detect_C_left_bracket_op(x.first,x.second);
 }
 
 template<>
 inline bool robust_token_is_char<']'>(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && detect_C_right_bracket_op(x.first,x.second);
+	return x.first && detect_C_right_bracket_op(x.first,x.second);
 }
 
 template<>
 inline bool robust_token_is_char<'{'>(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && detect_C_left_brace_op(x.first,x.second);
+	return x.first && detect_C_left_brace_op(x.first,x.second);
 }
 
 template<>
 inline bool robust_token_is_char<'}'>(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && detect_C_right_brace_op(x.first,x.second);
+	return x.first && detect_C_right_brace_op(x.first,x.second);
 }
 
 template<char c> inline bool robust_token_is_char(const parse_tree& x)
@@ -1876,7 +1874,7 @@
 
 static bool C99_CoreControlExpressionContextFreeErrorCount(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	const size_t starting_errors = zcc_errors.err_count();
 	bool already_errored = false;
@@ -1929,14 +1927,14 @@
 
 static bool C99_ControlExpressionContextFreeErrorCount(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	return C99_CoreControlExpressionContextFreeErrorCount(tokenlist,tokenlist_len,hard_start,hard_end);
 }
 
 static bool CPP_ControlExpressionContextFreeErrorCount(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	return C99_CoreControlExpressionContextFreeErrorCount(tokenlist,tokenlist_len,hard_start,hard_end);
 }
@@ -2125,7 +2123,7 @@
 
 static size_t LengthOfEscapedCString(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	size_t actual_size = src_len;
 	size_t i = 0;
@@ -2202,7 +2200,7 @@
 
 static size_t LengthOfEscapedCString(const my_UNICODE* src, size_t src_len)
 {	//! \todo synchronize with EscapeCString
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	size_t actual_size = src_len;
 	size_t i = 0;
@@ -2216,8 +2214,7 @@
 				continue;
 				};
 			if (!C_IsPrintableChar(src[i]))
-				{
-				// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
+				{	// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
 				my_UNICODE tmp = src[i];
 				bool must_escape = (1<src_len-i && strchr(list_hexadecimal_digits,src[i+1]));
 				//! \todo fix to handle target CHAR_BIT different than ours
@@ -2279,7 +2276,7 @@
 
 static void EscapeCString(char* dest, const char* src, size_t src_len)
 {	// \todo fix ASCII dependency.
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	size_t i = 0;
 	do	{
@@ -2304,8 +2301,7 @@
 		// however, octal isn't that user friendly; we clearly want to octal-escape only through 7
 		// \bug need test cases
 		if (!C_IsPrintableChar(src[i]))
-			{
-			// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
+			{	// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
 			unsigned char tmp = src[i];
 			bool must_escape = (1<src_len-i && strchr(list_hexadecimal_digits,src[i+1]));
 			*(dest++) = '\\';
@@ -2417,7 +2413,7 @@
 
 static void EscapeCString(char* dest, const my_UNICODE* src, size_t src_len)
 {	// \todo fix ASCII dependency.
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	size_t i = 0;
 	do	{
@@ -2442,8 +2438,7 @@
 		// however, octal isn't that user friendly; we clearly want to octal-escape only through 7
 		// \bug need test cases
 		if (!C_IsPrintableChar(src[i]))
-			{
-			// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
+			{	// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
 			my_UNICODE tmp = src[i];
 			bool must_escape = (1<src_len-i && UCHAR_MAX>=src[i] && strchr(list_hexadecimal_digits,src[i+1]));
 			*(dest++) = '\\';
@@ -2539,14 +2534,14 @@
 
 static size_t octal_escape_length(const char* const src, const size_t ub)
 {
-	assert(NULL!=src);
+	assert(src);
 	const size_t oct_len = strspn(src,C_OCTAL_DIGITS);
 	return (ub<oct_len) ? ub : oct_len;
 }
 
 static unsigned int eval_octal_escape(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len && src_len<=3);
 	unsigned int tmp = 0;
 	do	{
@@ -2561,14 +2556,14 @@
 
 static size_t hex_escape_length(const char* const src, const size_t ub)
 {
-	assert(NULL!=src);
+	assert(src);
 	const size_t hex_len = strspn(src,C_HEXADECIMAL_DIGITS);
 	return (ub<hex_len) ? ub : hex_len;
 }
 
 static umaxint eval_hex_escape(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 #ifndef NDEBUG
@@ -2589,7 +2584,7 @@
 // must remain synchronized with RobustEscapedCharLength_C
 static size_t EscapedCharLength_C(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	if ('\\' != *src) return 1;
 	assert(1<src_len && '\0'!=src[1]);
@@ -2624,7 +2619,7 @@
 // must remain synchronized with EscapedCharLength_C
 static size_t RobustEscapedCharLength_C(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	if ('\\' != *src) return 1;
 	if (1>=src_len || '\0'==src[1]) return 0;
@@ -2658,7 +2653,7 @@
 
 static size_t LengthOfUnescapedCString(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 
 	size_t analyze_length = 0;

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-10-28 22:39:06 UTC (rev 510)
+++ trunk/CSupport_pp.cpp	2010-10-28 23:00:29 UTC (rev 511)
@@ -1372,36 +1372,34 @@
 static inline bool
 robust_token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
 {
-	assert(NULL!=target);
+	assert(target);
 	assert(targ_len==strlen(target));
-	return NULL!=x.first && targ_len==x.second
-		&& !strncmp(x.first,target,targ_len);
+	return x.first && targ_len==x.second && !strncmp(x.first,target,targ_len);
 }
 
 static inline bool
 robust_token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
 {
-	assert(NULL!=target);
+	assert(target);
 	const size_t targ_len = strlen(target);
-	return NULL!=x.first && targ_len==x.second
-		&& !strncmp(x.first,target,targ_len);
+	return x.first && targ_len==x.second && !strncmp(x.first,target,targ_len);
 }
 
 template<size_t targ_len>
 static inline bool
 token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
 {
-	assert(NULL!=target);
+	assert(target);
 	assert(targ_len==strlen(target));
-	assert(NULL!=x.first);
+	assert(x.first);
 	return targ_len==x.second && !strncmp(x.first,target,targ_len);
 }
 
 static inline bool
 token_is_string(const POD_pair<const char*,size_t>& x,const char* const target)
 {
-	assert(NULL!=target);
-	assert(NULL!=x.first);
+	assert(target);
+	assert(x.first);
 	const size_t targ_len = strlen(target);
 	return targ_len==x.second && !strncmp(x.first,target,targ_len);
 }
@@ -1423,79 +1421,79 @@
 static inline bool
 token_is_char(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return 1==x.second && c== *x.first;
 }
 
 template<>
 inline bool token_is_char<'#'>(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return detect_C_stringize_op(x.first,x.second);
 }
 
 template<>
 inline bool token_is_char<'['>(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return detect_C_left_bracket_op(x.first,x.second);
 }
 
 template<>
 inline bool token_is_char<']'>(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return detect_C_right_bracket_op(x.first,x.second);
 }
 
 template<>
 inline bool token_is_char<'{'>(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return detect_C_left_brace_op(x.first,x.second);
 }
 
 template<>
 inline bool token_is_char<'}'>(const POD_pair<const char*,size_t>& x)
 {
-	assert(NULL!=x.first);
+	assert(x.first);
 	return detect_C_right_brace_op(x.first,x.second);
 }
 
 template<char c>
 inline bool robust_token_is_char(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && 1==x.second && c== *x.first;
+	return x.first && 1==x.second && c== *x.first;
 }
 
 template<>
 inline bool robust_token_is_char<'#'>(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && detect_C_stringize_op(x.first,x.second);
+	return x.first && detect_C_stringize_op(x.first,x.second);
 }
 
 template<>
 inline bool robust_token_is_char<'['>(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && detect_C_left_bracket_op(x.first,x.second);
+	return x.first && detect_C_left_bracket_op(x.first,x.second);
 }
 
 template<>
 inline bool robust_token_is_char<']'>(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && detect_C_right_bracket_op(x.first,x.second);
+	return x.first && detect_C_right_bracket_op(x.first,x.second);
 }
 
 template<>
 inline bool robust_token_is_char<'{'>(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && detect_C_left_brace_op(x.first,x.second);
+	return x.first && detect_C_left_brace_op(x.first,x.second);
 }
 
 template<>
 inline bool robust_token_is_char<'}'>(const POD_pair<const char*,size_t>& x)
 {
-	return NULL!=x.first && detect_C_right_brace_op(x.first,x.second);
+	return x.first && detect_C_right_brace_op(x.first,x.second);
 }
 
 template<char c> inline bool robust_token_is_char(const parse_tree& x)
@@ -1605,7 +1603,7 @@
 
 static bool C99_CoreControlExpressionContextFreeErrorCount(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	const size_t starting_errors = zcc_errors.err_count();
 	bool already_errored = false;
@@ -1658,14 +1656,14 @@
 
 static bool C99_ControlExpressionContextFreeErrorCount(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	return C99_CoreControlExpressionContextFreeErrorCount(tokenlist,tokenlist_len,hard_start,hard_end);
 }
 
 static bool CPP_ControlExpressionContextFreeErrorCount(const weak_token* tokenlist,size_t tokenlist_len,bool hard_start,bool hard_end)
 {
-	assert(NULL!=tokenlist);
+	assert(tokenlist);
 	assert(0<tokenlist_len);
 	return C99_CoreControlExpressionContextFreeErrorCount(tokenlist,tokenlist_len,hard_start,hard_end);
 }
@@ -1854,7 +1852,7 @@
 
 static size_t LengthOfEscapedCString(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	size_t actual_size = src_len;
 	size_t i = 0;
@@ -1931,7 +1929,7 @@
 
 static size_t LengthOfEscapedCString(const my_UNICODE* src, size_t src_len)
 {	//! \todo synchronize with EscapeCString
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	size_t actual_size = src_len;
 	size_t i = 0;
@@ -1945,8 +1943,7 @@
 				continue;
 				};
 			if (!C_IsPrintableChar(src[i]))
-				{
-				// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
+				{	// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
 				my_UNICODE tmp = src[i];
 				bool must_escape = (1<src_len-i && strchr(list_hexadecimal_digits,src[i+1]));
 				//! \todo fix to handle target CHAR_BIT different than ours
@@ -2008,7 +2005,7 @@
 
 static void EscapeCString(char* dest, const char* src, size_t src_len)
 {	// \todo fix ASCII dependency.
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	size_t i = 0;
 	do	{
@@ -2033,8 +2030,7 @@
 		// however, octal isn't that user friendly; we clearly want to octal-escape only through 7
 		// \bug need test cases
 		if (!C_IsPrintableChar(src[i]))
-			{
-			// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
+			{	// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
 			unsigned char tmp = src[i];
 			bool must_escape = (1<src_len-i && strchr(list_hexadecimal_digits,src[i+1]));
 			*(dest++) = '\\';
@@ -2146,7 +2142,7 @@
 
 static void EscapeCString(char* dest, const my_UNICODE* src, size_t src_len)
 {	// \todo fix ASCII dependency.
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	size_t i = 0;
 	do	{
@@ -2171,8 +2167,7 @@
 		// however, octal isn't that user friendly; we clearly want to octal-escape only through 7
 		// \bug need test cases
 		if (!C_IsPrintableChar(src[i]))
-			{
-			// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
+			{	// note that octal escaping can only go up to 511, which is a problem if our CHAR_BIT exceeds 9 
 			my_UNICODE tmp = src[i];
 			bool must_escape = (1<src_len-i && UCHAR_MAX>=src[i] && strchr(list_hexadecimal_digits,src[i+1]));
 			*(dest++) = '\\';
@@ -2268,14 +2263,14 @@
 
 static size_t octal_escape_length(const char* const src, const size_t ub)
 {
-	assert(NULL!=src);
+	assert(src);
 	const size_t oct_len = strspn(src,C_OCTAL_DIGITS);
 	return (ub<oct_len) ? ub : oct_len;
 }
 
 static unsigned int eval_octal_escape(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len && src_len<=3);
 	unsigned int tmp = 0;
 	do	{
@@ -2290,14 +2285,14 @@
 
 static size_t hex_escape_length(const char* const src, const size_t ub)
 {
-	assert(NULL!=src);
+	assert(src);
 	const size_t hex_len = strspn(src,C_HEXADECIMAL_DIGITS);
 	return (ub<hex_len) ? ub : hex_len;
 }
 
 static umaxint eval_hex_escape(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	unsigned_var_int tmp(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 #ifndef NDEBUG
@@ -2318,7 +2313,7 @@
 // must remain synchronized with RobustEscapedCharLength_C
 static size_t EscapedCharLength_C(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	if ('\\' != *src) return 1;
 	assert(1<src_len && '\0'!=src[1]);
@@ -2353,7 +2348,7 @@
 // must remain synchronized with EscapedCharLength_C
 static size_t RobustEscapedCharLength_C(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	if ('\\' != *src) return 1;
 	if (1>=src_len || '\0'==src[1]) return 0;
@@ -2387,7 +2382,7 @@
 
 static size_t LengthOfUnescapedCString(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 
 	size_t analyze_length = 0;



From zaimoni at mail.berlios.de  Fri Oct 29 02:37:11 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 29 Oct 2010 02:37:11 +0200
Subject: [Zcplusplus-commits] r512 - trunk
Message-ID: <20101029003711.AD53E480C84@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-29 02:37:11 +0200 (Fri, 29 Oct 2010)
New Revision: 512

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/CSupport_pp.cpp
Log:
stage 3: line count reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-28 23:00:29 UTC (rev 511)
+++ trunk/CSupport.cpp	2010-10-29 00:37:11 UTC (rev 512)
@@ -2618,11 +2618,11 @@
 
 static uintmax_t _eval_character(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	if (1==src_len) return (unsigned char)(*src);
 	const char* tmp_escape = strchr(C_OCTAL_DIGITS,src[1]);
-	if (NULL!=tmp_escape)
+	if (tmp_escape)
 		{
 		const size_t oct_len = octal_escape_length(src+1,(3U>src_len-1U) ? 3U : src_len-1U);
 		assert(0<oct_len);
@@ -2643,7 +2643,7 @@
 
 static void UnescapeCString(char* dest, const char* src, size_t src_len)
 {	//! \todo cross-compiler augmentation target, dest needs to be able represent target strings
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	assert(CHAR_BIT>=target_machine->C_char_bit());
 
@@ -2659,7 +2659,7 @@
 
 static void UnescapeCWideString(my_UNICODE* dest, const char* src, size_t src_len)
 {	//! \todo cross-compiler change target, dest needs to be able represent target strings
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	assert(C_UNICODE_MAX>=target_machine->unsigned_max(target_machine->UNICODE_wchar_t()));
 
@@ -2675,7 +2675,7 @@
 
 bool IsLegalCString(const char* x, size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(0<x_len);
 	if ('"' != x[x_len-1]) return false;
 	if (0 == --x_len) return false;
@@ -2702,7 +2702,7 @@
 
 bool IsLegalCCharacterLiteral(const char* x, size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(0<x_len);
 	if ('\'' != x[x_len-1]) return false;
 	if (0 == --x_len) return false;
@@ -2729,7 +2729,7 @@
 
 static size_t LengthOfCStringLiteral(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(2<=src_len);
 	const bool wide_str = ('L'==src[0]);
 	if (wide_str)
@@ -2745,7 +2745,7 @@
 
 static size_t LengthOfCCharLiteral(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(2<=src_len);
 	const bool wide_char = ('L'==src[0]);
 	if (wide_char)
@@ -2772,7 +2772,7 @@
  */
 bool LocateCCharacterLiteralAt(const char* const src, size_t src_len, size_t target_idx, size_t& char_offset, size_t& char_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(2<=src_len);
 	assert(IsLegalCString(src,src_len));
 	const char* src2 = src;
@@ -2809,9 +2809,9 @@
 
 void GetCCharacterLiteralAt(const char* src, size_t src_len, size_t target_idx, char*& tmp)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(2<=src_len);
-	assert(NULL==tmp);
+	assert(!tmp);
 	assert(IsLegalCString(src,src_len));
 	const size_t C_str_len = LengthOfCStringLiteral(src,src_len);
 	assert(C_str_len>target_idx);
@@ -2876,13 +2876,13 @@
  */
 static int ConcatenateCStringLiterals(const char* src, size_t src_len, const char* src2, size_t src2_len, char*& target)
 {
-	assert(NULL!=src);
-	assert(NULL!=src2);
+	assert(src);
+	assert(src2);
 	assert(2<=src_len);
 	assert(2<=src2_len);
 	assert(IsLegalCString(src,src_len));
 	assert(IsLegalCString(src2,src2_len));
-	assert(NULL==target);
+	assert(!target);
 
 	const char* str1 = src;
 	const char* str2 = src2;
@@ -2949,7 +2949,7 @@
 		const size_t new_start = (str_target_wide) ? 2 : 1;
 		const size_t new_width = str1_len+str2_len+new_start+1U;
 		target = reinterpret_cast<char*>(calloc(new_width,1));
-		if (NULL==target) return -5;
+		if (!target) return -5;
 		target[new_width-1] = '"';
 		target[new_start-1] = '"';
 		if (str_target_wide) target[0] = 'L';
@@ -2966,17 +2966,13 @@
 	if (str_target_wide)
 		{
 		buf.second = zaimoni::_new_buffer<my_UNICODE>(buf_len);
-		if (NULL==buf.second) return -5;
+		if (!buf.second) return -5;
 		UnescapeCWideString(buf.second,str1,str1_len);
 		UnescapeCWideString(buf.second+str1_un_len,str2,str2_len);
 		//! \todo C vs C++
 		const size_t target_len = LengthOfEscapedCString(buf.second,buf_len);
 		target = zaimoni::_new_buffer<char>(target_len);
-		if (NULL==target)
-			{
-			free(buf.second);
-			return -5;
-			}
+		if (!target) return free(buf.second),-5; 
 		EscapeCString(target,buf.second,buf_len);
 		free(buf.second);
 		assert(IsLegalCString(target,target_len));
@@ -2984,16 +2980,12 @@
 		}
 	else{
 		buf.first = zaimoni::_new_buffer<char>(buf_len);
-		if (NULL==buf.first) return -5;
+		if (!buf.first) return -5;
 		UnescapeCString(buf.first,str1,str1_len);
 		UnescapeCString(buf.first+str1_un_len,str2,str2_len);
 		const size_t target_len = LengthOfEscapedCString(buf.first,buf_len);
 		target = zaimoni::_new_buffer<char>(target_len);
-		if (NULL==target)
-			{
-			free(buf.first);
-			return -5;
-			}
+		if (!target) return free(buf.first),-5;
 		EscapeCString(target,buf.first,buf_len);
 		free(buf.first);
 		assert(IsLegalCString(target,target_len));
@@ -3004,7 +2996,7 @@
 
 static uintmax_t EvalCharacterLiteral(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(3<=src_len);
 	assert(IsLegalCCharacterLiteral(src,src_len));
 	const bool is_wide = 'L'== *src;
@@ -3034,7 +3026,7 @@
 
 bool CCharLiteralIsFalse(const char* x,size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(0<x_len);
 	assert(IsLegalCCharacterLiteral(x,x_len));
 	const uintmax_t result = EvalCharacterLiteral(x,x_len);
@@ -3460,25 +3452,19 @@
 					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX,C99_CPP_LONG_IDX))
 					{
 					case 0:
-						{
 						BOOST_STATIC_ASSERT(1==C_TYPE::UINT-C_TYPE::INT);
 						set_C_canonical_type_representation(src,i,C_TYPE::INT+(2==tmp));
 						break;
-						}
 					case 1:
-						{
 						BOOST_STATIC_ASSERT(1==C_TYPE::USHRT-C_TYPE::SHRT);
 						set_C_canonical_type_representation(src,i,C_TYPE::SHRT+(2==tmp));
 						break;
-						}
 					default:
-						{
 						BOOST_STATIC_ASSERT(3==C_TYPE::ULLONG-C_TYPE::LONG);
 						BOOST_STATIC_ASSERT(2==C_TYPE::LLONG-C_TYPE::LONG);
 						BOOST_STATIC_ASSERT(1==C_TYPE::ULONG-C_TYPE::LONG);
 						set_C_canonical_type_representation(src,i,C_TYPE::LONG+(2==tmp)+2*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
 //						break;
-						}
 					}
 					}
 					break;
@@ -3547,7 +3533,6 @@
 					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_FLOAT_IDX,C99_CPP_DOUBLE_IDX))
 					{
 					case 0:
-						{
 						if (!have_warned_about_Complex)
 							{
 							message_header(src.data<0>()[i].index_tokens[0]);
@@ -3559,7 +3544,6 @@
 						// remove the unusable token
 						src.DeleteIdx<0>(i--);
 						break;
-						}
 					case 1:
 						src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
 						set_C_canonical_type_representation(src,i,C_TYPE::FLOAT__COMPLEX);
@@ -3783,25 +3767,19 @@
 					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX,C99_CPP_LONG_IDX))
 					{
 					case 0:
-						{
 						BOOST_STATIC_ASSERT(1==C_TYPE::UINT-C_TYPE::INT);
 						set_C_canonical_type_representation(src,i,C_TYPE::INT+(2==tmp));
 						break;
-						}
 					case 1:
-						{
 						BOOST_STATIC_ASSERT(1==C_TYPE::USHRT-C_TYPE::SHRT);
 						set_C_canonical_type_representation(src,i,C_TYPE::SHRT+(2==tmp));
 						break;
-						}
 					default:
-						{
 						BOOST_STATIC_ASSERT(3==C_TYPE::ULLONG-C_TYPE::LONG);
 						BOOST_STATIC_ASSERT(2==C_TYPE::LLONG-C_TYPE::LONG);
 						BOOST_STATIC_ASSERT(1==C_TYPE::ULONG-C_TYPE::LONG);
 						set_C_canonical_type_representation(src,i,C_TYPE::LONG+(2==tmp)+2*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
 //						break;
-						}
 					}
 					}
 					break;
@@ -3870,7 +3848,6 @@
 					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_FLOAT_IDX,C99_CPP_DOUBLE_IDX))
 					{
 					case 0:
-						{
 						if (!have_warned_about_Complex)
 							{
 							message_header(src.data<0>()[i].index_tokens[0]);
@@ -3882,7 +3859,6 @@
 						// remove the unusable token
 						src.DeleteIdx<0>(i--);
 						break;
-						}
 					case 1:
 						src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
 						set_C_canonical_type_representation(src,i,C_TYPE::FLOAT__COMPLEX);
@@ -3910,8 +3886,8 @@
 static size_t _count_identifiers(const parse_tree& src)
 {
 	size_t count_id = 0;
-	if (NULL!=src.index_tokens[0].token.first && C_TESTFLAG_IDENTIFIER==src.index_tokens[0].flags) ++count_id;
-	if (NULL!=src.index_tokens[1].token.first && C_TESTFLAG_IDENTIFIER==src.index_tokens[1].flags) ++count_id;
+	if (src.index_tokens[0].token.first && C_TESTFLAG_IDENTIFIER==src.index_tokens[0].flags) ++count_id;
+	if (src.index_tokens[1].token.first && C_TESTFLAG_IDENTIFIER==src.index_tokens[1].flags) ++count_id;
 	size_t i = src.size<0>();
 	while(0<i) count_id += _count_identifiers(src.data<0>()[--i]);
 	i = src.size<1>();
@@ -3926,7 +3902,7 @@
 	return		robust_token_is_char<'('>(src.index_tokens[0].token)
 			&&	robust_token_is_char<')'>(src.index_tokens[1].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 #endif
 			&&	src.empty<1>() && src.empty<2>();
 }
@@ -3936,7 +3912,7 @@
 	return		robust_token_is_char<'{'>(src.index_tokens[0].token)
 			&&	robust_token_is_char<'}'>(src.index_tokens[1].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 #endif
 			&&	src.empty<1>() && src.empty<2>();
 }
@@ -3946,7 +3922,7 @@
 	return		robust_token_is_char<'['>(src.index_tokens[0].token)
 			&&	robust_token_is_char<']'>(src.index_tokens[1].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 #endif
 			&&	src.empty<1>() && src.empty<2>();
 }
@@ -3954,8 +3930,7 @@
 static bool is_nonempty_naked_pair(const parse_tree& src)
 {
 	return !src.empty<0>()  && (is_naked_parentheses_pair(src) 
-		|| is_naked_brace_pair(src)
-		|| is_naked_bracket_pair(src));
+		|| is_naked_brace_pair(src) || is_naked_bracket_pair(src));
 }
 
 #ifndef NDEBUG
@@ -3963,7 +3938,7 @@
 {
 	return		robust_token_is_char<'['>(src.index_tokens[0].token)
 			&&	robust_token_is_char<']'>(src.index_tokens[1].token)
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<0>()->flags)			// content of [ ]
 			&&	1==src.size<1>() && (PARSE_POSTFIX_EXPRESSION & src.data<1>()->flags)	// prefix arg of [ ]
 			&&	src.empty<2>();
@@ -3975,7 +3950,7 @@
 	return		robust_token_is_char<'['>(src.index_tokens[0].token)
 			&&	robust_token_is_char<']'>(src.index_tokens[1].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 #endif
 			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<0>()->flags)			// content of [ ]
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)	// prefix arg of [ ]

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-28 23:00:29 UTC (rev 511)
+++ trunk/CSupport.cpp.in	2010-10-29 00:37:11 UTC (rev 512)
@@ -2668,11 +2668,11 @@
 
 static uintmax_t _eval_character(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	if (1==src_len) return (unsigned char)(*src);
 	const char* tmp_escape = strchr(C_OCTAL_DIGITS,src[1]);
-	if (NULL!=tmp_escape)
+	if (tmp_escape)
 		{
 		const size_t oct_len = octal_escape_length(src+1,(3U>src_len-1U) ? 3U : src_len-1U);
 		assert(0<oct_len);
@@ -2693,7 +2693,7 @@
 
 static void UnescapeCString(char* dest, const char* src, size_t src_len)
 {	//! \todo cross-compiler augmentation target, dest needs to be able represent target strings
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	assert(CHAR_BIT>=target_machine->C_char_bit());
 
@@ -2709,7 +2709,7 @@
 
 static void UnescapeCWideString(my_UNICODE* dest, const char* src, size_t src_len)
 {	//! \todo cross-compiler change target, dest needs to be able represent target strings
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	assert(C_UNICODE_MAX>=target_machine->unsigned_max(target_machine->UNICODE_wchar_t()));
 
@@ -2725,7 +2725,7 @@
 
 bool IsLegalCString(const char* x, size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(0<x_len);
 	if ('"' != x[x_len-1]) return false;
 	if (0 == --x_len) return false;
@@ -2752,7 +2752,7 @@
 
 bool IsLegalCCharacterLiteral(const char* x, size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(0<x_len);
 	if ('\'' != x[x_len-1]) return false;
 	if (0 == --x_len) return false;
@@ -2779,7 +2779,7 @@
 
 static size_t LengthOfCStringLiteral(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(2<=src_len);
 	const bool wide_str = ('L'==src[0]);
 	if (wide_str)
@@ -2795,7 +2795,7 @@
 
 static size_t LengthOfCCharLiteral(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(2<=src_len);
 	const bool wide_char = ('L'==src[0]);
 	if (wide_char)
@@ -2822,7 +2822,7 @@
  */
 bool LocateCCharacterLiteralAt(const char* const src, size_t src_len, size_t target_idx, size_t& char_offset, size_t& char_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(2<=src_len);
 	assert(IsLegalCString(src,src_len));
 	const char* src2 = src;
@@ -2859,9 +2859,9 @@
 
 void GetCCharacterLiteralAt(const char* src, size_t src_len, size_t target_idx, char*& tmp)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(2<=src_len);
-	assert(NULL==tmp);
+	assert(!tmp);
 	assert(IsLegalCString(src,src_len));
 	const size_t C_str_len = LengthOfCStringLiteral(src,src_len);
 	assert(C_str_len>target_idx);
@@ -2926,13 +2926,13 @@
  */
 static int ConcatenateCStringLiterals(const char* src, size_t src_len, const char* src2, size_t src2_len, char*& target)
 {
-	assert(NULL!=src);
-	assert(NULL!=src2);
+	assert(src);
+	assert(src2);
 	assert(2<=src_len);
 	assert(2<=src2_len);
 	assert(IsLegalCString(src,src_len));
 	assert(IsLegalCString(src2,src2_len));
-	assert(NULL==target);
+	assert(!target);
 
 	const char* str1 = src;
 	const char* str2 = src2;
@@ -2999,7 +2999,7 @@
 		const size_t new_start = (str_target_wide) ? 2 : 1;
 		const size_t new_width = str1_len+str2_len+new_start+1U;
 		target = reinterpret_cast<char*>(calloc(new_width,1));
-		if (NULL==target) return -5;
+		if (!target) return -5;
 		target[new_width-1] = '"';
 		target[new_start-1] = '"';
 		if (str_target_wide) target[0] = 'L';
@@ -3016,17 +3016,13 @@
 	if (str_target_wide)
 		{
 		buf.second = zaimoni::_new_buffer<my_UNICODE>(buf_len);
-		if (NULL==buf.second) return -5;
+		if (!buf.second) return -5;
 		UnescapeCWideString(buf.second,str1,str1_len);
 		UnescapeCWideString(buf.second+str1_un_len,str2,str2_len);
 		//! \todo C vs C++
 		const size_t target_len = LengthOfEscapedCString(buf.second,buf_len);
 		target = zaimoni::_new_buffer<char>(target_len);
-		if (NULL==target)
-			{
-			free(buf.second);
-			return -5;
-			}
+		if (!target) return free(buf.second),-5; 
 		EscapeCString(target,buf.second,buf_len);
 		free(buf.second);
 		assert(IsLegalCString(target,target_len));
@@ -3034,16 +3030,12 @@
 		}
 	else{
 		buf.first = zaimoni::_new_buffer<char>(buf_len);
-		if (NULL==buf.first) return -5;
+		if (!buf.first) return -5;
 		UnescapeCString(buf.first,str1,str1_len);
 		UnescapeCString(buf.first+str1_un_len,str2,str2_len);
 		const size_t target_len = LengthOfEscapedCString(buf.first,buf_len);
 		target = zaimoni::_new_buffer<char>(target_len);
-		if (NULL==target)
-			{
-			free(buf.first);
-			return -5;
-			}
+		if (!target) return free(buf.first),-5;
 		EscapeCString(target,buf.first,buf_len);
 		free(buf.first);
 		assert(IsLegalCString(target,target_len));
@@ -3054,7 +3046,7 @@
 
 static uintmax_t EvalCharacterLiteral(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(3<=src_len);
 	assert(IsLegalCCharacterLiteral(src,src_len));
 	const bool is_wide = 'L'== *src;
@@ -3084,7 +3076,7 @@
 
 bool CCharLiteralIsFalse(const char* x,size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(0<x_len);
 	assert(IsLegalCCharacterLiteral(x,x_len));
 	const uintmax_t result = EvalCharacterLiteral(x,x_len);
@@ -3511,25 +3503,19 @@
 					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX,C99_CPP_LONG_IDX))
 					{
 					case 0:
-						{
 						BOOST_STATIC_ASSERT(1==C_TYPE::UINT-C_TYPE::INT);
 						set_C_canonical_type_representation(src,i,C_TYPE::INT+(2==tmp));
 						break;
-						}
 					case 1:
-						{
 						BOOST_STATIC_ASSERT(1==C_TYPE::USHRT-C_TYPE::SHRT);
 						set_C_canonical_type_representation(src,i,C_TYPE::SHRT+(2==tmp));
 						break;
-						}
 					default:
-						{
 						BOOST_STATIC_ASSERT(3==C_TYPE::ULLONG-C_TYPE::LONG);
 						BOOST_STATIC_ASSERT(2==C_TYPE::LLONG-C_TYPE::LONG);
 						BOOST_STATIC_ASSERT(1==C_TYPE::ULONG-C_TYPE::LONG);
 						set_C_canonical_type_representation(src,i,C_TYPE::LONG+(2==tmp)+2*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
 //						break;
-						}
 					}
 					}
 					break;
@@ -3598,7 +3584,6 @@
 					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_FLOAT_IDX,C99_CPP_DOUBLE_IDX))
 					{
 					case 0:
-						{
 						if (!have_warned_about_Complex)
 							{
 							message_header(src.data<0>()[i].index_tokens[0]);
@@ -3610,7 +3595,6 @@
 						// remove the unusable token
 						src.DeleteIdx<0>(i--);
 						break;
-						}
 					case 1:
 						src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
 						set_C_canonical_type_representation(src,i,C_TYPE::FLOAT__COMPLEX);
@@ -3834,25 +3818,19 @@
 					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_SHORT_IDX,C99_CPP_LONG_IDX))
 					{
 					case 0:
-						{
 						BOOST_STATIC_ASSERT(1==C_TYPE::UINT-C_TYPE::INT);
 						set_C_canonical_type_representation(src,i,C_TYPE::INT+(2==tmp));
 						break;
-						}
 					case 1:
-						{
 						BOOST_STATIC_ASSERT(1==C_TYPE::USHRT-C_TYPE::SHRT);
 						set_C_canonical_type_representation(src,i,C_TYPE::SHRT+(2==tmp));
 						break;
-						}
 					default:
-						{
 						BOOST_STATIC_ASSERT(3==C_TYPE::ULLONG-C_TYPE::LONG);
 						BOOST_STATIC_ASSERT(2==C_TYPE::LLONG-C_TYPE::LONG);
 						BOOST_STATIC_ASSERT(1==C_TYPE::ULONG-C_TYPE::LONG);
 						set_C_canonical_type_representation(src,i,C_TYPE::LONG+(2==tmp)+2*optional_keyword(src,i,invariant_decl_scanner,C99_CPP_LONG_IDX));
 //						break;
-						}
 					}
 					}
 					break;
@@ -3921,7 +3899,6 @@
 					switch(optional_keyword_choice(src,i,invariant_decl_scanner,C99_CPP_FLOAT_IDX,C99_CPP_DOUBLE_IDX))
 					{
 					case 0:
-						{
 						if (!have_warned_about_Complex)
 							{
 							message_header(src.data<0>()[i].index_tokens[0]);
@@ -3933,7 +3910,6 @@
 						// remove the unusable token
 						src.DeleteIdx<0>(i--);
 						break;
-						}
 					case 1:
 						src.c_array<0>()[i].flags |= PARSE_PRIMARY_TYPE;
 						set_C_canonical_type_representation(src,i,C_TYPE::FLOAT__COMPLEX);
@@ -3962,8 +3938,8 @@
 static size_t _count_identifiers(const parse_tree& src)
 {
 	size_t count_id = 0;
-	if (NULL!=src.index_tokens[0].token.first && C_TESTFLAG_IDENTIFIER==src.index_tokens[0].flags) ++count_id;
-	if (NULL!=src.index_tokens[1].token.first && C_TESTFLAG_IDENTIFIER==src.index_tokens[1].flags) ++count_id;
+	if (src.index_tokens[0].token.first && C_TESTFLAG_IDENTIFIER==src.index_tokens[0].flags) ++count_id;
+	if (src.index_tokens[1].token.first && C_TESTFLAG_IDENTIFIER==src.index_tokens[1].flags) ++count_id;
 	size_t i = src.size<0>();
 	while(0<i) count_id += _count_identifiers(src.data<0>()[--i]);
 	i = src.size<1>();
@@ -3978,7 +3954,7 @@
 	return		robust_token_is_char<'('>(src.index_tokens[0].token)
 			&&	robust_token_is_char<')'>(src.index_tokens[1].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 #endif
 			&&	src.empty<1>() && src.empty<2>();
 }
@@ -3989,7 +3965,7 @@
 	return		robust_token_is_char<'{'>(src.index_tokens[0].token)
 			&&	robust_token_is_char<'}'>(src.index_tokens[1].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 #endif
 			&&	src.empty<1>() && src.empty<2>();
 }
@@ -3999,7 +3975,7 @@
 	return		robust_token_is_char<'['>(src.index_tokens[0].token)
 			&&	robust_token_is_char<']'>(src.index_tokens[1].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 #endif
 			&&	src.empty<1>() && src.empty<2>();
 }
@@ -4007,8 +3983,7 @@
 static bool is_nonempty_naked_pair(const parse_tree& src)
 {
 	return !src.empty<0>()  && (is_naked_parentheses_pair(src) 
-		|| is_naked_brace_pair(src)
-		|| is_naked_bracket_pair(src));
+		|| is_naked_brace_pair(src) || is_naked_bracket_pair(src));
 }
 #/*cut-cpp*/
 
@@ -4017,7 +3992,7 @@
 {
 	return		robust_token_is_char<'['>(src.index_tokens[0].token)
 			&&	robust_token_is_char<']'>(src.index_tokens[1].token)
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<0>()->flags)			// content of [ ]
 			&&	1==src.size<1>() && (PARSE_POSTFIX_EXPRESSION & src.data<1>()->flags)	// prefix arg of [ ]
 			&&	src.empty<2>();
@@ -4029,7 +4004,7 @@
 	return		robust_token_is_char<'['>(src.index_tokens[0].token)
 			&&	robust_token_is_char<']'>(src.index_tokens[1].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 #endif
 			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<0>()->flags)			// content of [ ]
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)	// prefix arg of [ ]

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-10-28 23:00:29 UTC (rev 511)
+++ trunk/CSupport_pp.cpp	2010-10-29 00:37:11 UTC (rev 512)
@@ -2397,11 +2397,11 @@
 
 static uintmax_t _eval_character(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	if (1==src_len) return (unsigned char)(*src);
 	const char* tmp_escape = strchr(C_OCTAL_DIGITS,src[1]);
-	if (NULL!=tmp_escape)
+	if (tmp_escape)
 		{
 		const size_t oct_len = octal_escape_length(src+1,(3U>src_len-1U) ? 3U : src_len-1U);
 		assert(0<oct_len);
@@ -2422,7 +2422,7 @@
 
 static void UnescapeCString(char* dest, const char* src, size_t src_len)
 {	//! \todo cross-compiler augmentation target, dest needs to be able represent target strings
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	assert(CHAR_BIT>=target_machine->C_char_bit());
 
@@ -2438,7 +2438,7 @@
 
 static void UnescapeCWideString(my_UNICODE* dest, const char* src, size_t src_len)
 {	//! \todo cross-compiler change target, dest needs to be able represent target strings
-	assert(NULL!=src);
+	assert(src);
 	assert(0<src_len);
 	assert(C_UNICODE_MAX>=target_machine->unsigned_max(target_machine->UNICODE_wchar_t()));
 
@@ -2454,7 +2454,7 @@
 
 bool IsLegalCString(const char* x, size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(0<x_len);
 	if ('"' != x[x_len-1]) return false;
 	if (0 == --x_len) return false;
@@ -2481,7 +2481,7 @@
 
 bool IsLegalCCharacterLiteral(const char* x, size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(0<x_len);
 	if ('\'' != x[x_len-1]) return false;
 	if (0 == --x_len) return false;
@@ -2508,7 +2508,7 @@
 
 static size_t LengthOfCStringLiteral(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(2<=src_len);
 	const bool wide_str = ('L'==src[0]);
 	if (wide_str)
@@ -2524,7 +2524,7 @@
 
 static size_t LengthOfCCharLiteral(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(2<=src_len);
 	const bool wide_char = ('L'==src[0]);
 	if (wide_char)
@@ -2551,7 +2551,7 @@
  */
 bool LocateCCharacterLiteralAt(const char* const src, size_t src_len, size_t target_idx, size_t& char_offset, size_t& char_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(2<=src_len);
 	assert(IsLegalCString(src,src_len));
 	const char* src2 = src;
@@ -2588,9 +2588,9 @@
 
 void GetCCharacterLiteralAt(const char* src, size_t src_len, size_t target_idx, char*& tmp)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(2<=src_len);
-	assert(NULL==tmp);
+	assert(!tmp);
 	assert(IsLegalCString(src,src_len));
 	const size_t C_str_len = LengthOfCStringLiteral(src,src_len);
 	assert(C_str_len>target_idx);
@@ -2655,13 +2655,13 @@
  */
 static int ConcatenateCStringLiterals(const char* src, size_t src_len, const char* src2, size_t src2_len, char*& target)
 {
-	assert(NULL!=src);
-	assert(NULL!=src2);
+	assert(src);
+	assert(src2);
 	assert(2<=src_len);
 	assert(2<=src2_len);
 	assert(IsLegalCString(src,src_len));
 	assert(IsLegalCString(src2,src2_len));
-	assert(NULL==target);
+	assert(!target);
 
 	const char* str1 = src;
 	const char* str2 = src2;
@@ -2728,7 +2728,7 @@
 		const size_t new_start = (str_target_wide) ? 2 : 1;
 		const size_t new_width = str1_len+str2_len+new_start+1U;
 		target = reinterpret_cast<char*>(calloc(new_width,1));
-		if (NULL==target) return -5;
+		if (!target) return -5;
 		target[new_width-1] = '"';
 		target[new_start-1] = '"';
 		if (str_target_wide) target[0] = 'L';
@@ -2745,17 +2745,13 @@
 	if (str_target_wide)
 		{
 		buf.second = zaimoni::_new_buffer<my_UNICODE>(buf_len);
-		if (NULL==buf.second) return -5;
+		if (!buf.second) return -5;
 		UnescapeCWideString(buf.second,str1,str1_len);
 		UnescapeCWideString(buf.second+str1_un_len,str2,str2_len);
 		//! \todo C vs C++
 		const size_t target_len = LengthOfEscapedCString(buf.second,buf_len);
 		target = zaimoni::_new_buffer<char>(target_len);
-		if (NULL==target)
-			{
-			free(buf.second);
-			return -5;
-			}
+		if (!target) return free(buf.second),-5; 
 		EscapeCString(target,buf.second,buf_len);
 		free(buf.second);
 		assert(IsLegalCString(target,target_len));
@@ -2763,16 +2759,12 @@
 		}
 	else{
 		buf.first = zaimoni::_new_buffer<char>(buf_len);
-		if (NULL==buf.first) return -5;
+		if (!buf.first) return -5;
 		UnescapeCString(buf.first,str1,str1_len);
 		UnescapeCString(buf.first+str1_un_len,str2,str2_len);
 		const size_t target_len = LengthOfEscapedCString(buf.first,buf_len);
 		target = zaimoni::_new_buffer<char>(target_len);
-		if (NULL==target)
-			{
-			free(buf.first);
-			return -5;
-			}
+		if (!target) return free(buf.first),-5;
 		EscapeCString(target,buf.first,buf_len);
 		free(buf.first);
 		assert(IsLegalCString(target,target_len));
@@ -2783,7 +2775,7 @@
 
 static uintmax_t EvalCharacterLiteral(const char* src, size_t src_len)
 {
-	assert(NULL!=src);
+	assert(src);
 	assert(3<=src_len);
 	assert(IsLegalCCharacterLiteral(src,src_len));
 	const bool is_wide = 'L'== *src;
@@ -2813,7 +2805,7 @@
 
 bool CCharLiteralIsFalse(const char* x,size_t x_len)
 {
-	assert(NULL!=x);
+	assert(x);
 	assert(0<x_len);
 	assert(IsLegalCCharacterLiteral(x,x_len));
 	const uintmax_t result = EvalCharacterLiteral(x,x_len);
@@ -2911,8 +2903,8 @@
 static size_t _count_identifiers(const parse_tree& src)
 {
 	size_t count_id = 0;
-	if (NULL!=src.index_tokens[0].token.first && C_TESTFLAG_IDENTIFIER==src.index_tokens[0].flags) ++count_id;
-	if (NULL!=src.index_tokens[1].token.first && C_TESTFLAG_IDENTIFIER==src.index_tokens[1].flags) ++count_id;
+	if (src.index_tokens[0].token.first && C_TESTFLAG_IDENTIFIER==src.index_tokens[0].flags) ++count_id;
+	if (src.index_tokens[1].token.first && C_TESTFLAG_IDENTIFIER==src.index_tokens[1].flags) ++count_id;
 	size_t i = src.size<0>();
 	while(0<i) count_id += _count_identifiers(src.data<0>()[--i]);
 	i = src.size<1>();
@@ -2927,7 +2919,7 @@
 	return		robust_token_is_char<'('>(src.index_tokens[0].token)
 			&&	robust_token_is_char<')'>(src.index_tokens[1].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 #endif
 			&&	src.empty<1>() && src.empty<2>();
 }
@@ -2937,7 +2929,7 @@
 {
 	return		robust_token_is_char<'['>(src.index_tokens[0].token)
 			&&	robust_token_is_char<']'>(src.index_tokens[1].token)
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<0>()->flags)			// content of [ ]
 			&&	1==src.size<1>() && (PARSE_POSTFIX_EXPRESSION & src.data<1>()->flags)	// prefix arg of [ ]
 			&&	src.empty<2>();
@@ -2949,7 +2941,7 @@
 	return		robust_token_is_char<'['>(src.index_tokens[0].token)
 			&&	robust_token_is_char<']'>(src.index_tokens[1].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 #endif
 			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<0>()->flags)			// content of [ ]
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)	// prefix arg of [ ]



From zaimoni at mail.berlios.de  Fri Oct 29 04:34:36 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 29 Oct 2010 04:34:36 +0200
Subject: [Zcplusplus-commits] r513 - trunk
Message-ID: <20101029023437.3A280480C84@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-29 04:34:36 +0200 (Fri, 29 Oct 2010)
New Revision: 513

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/CSupport_pp.cpp
Log:
stage 3: line count reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-29 00:37:11 UTC (rev 512)
+++ trunk/CSupport.cpp	2010-10-29 02:34:36 UTC (rev 513)
@@ -3969,11 +3969,10 @@
 {
 	return		robust_token_is_char<c>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	!src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 //			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
 }
@@ -3982,11 +3981,10 @@
 {
 	return		(robust_token_is_char<'!'>(src.index_tokens[0].token) || robust_token_is_string<3>(src.index_tokens[0].token,"not"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	!src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 //			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
 }
@@ -3995,11 +3993,10 @@
 {
 	return		(robust_token_is_char<'~'>(src.index_tokens[0].token) || robust_token_is_string<5>(src.index_tokens[0].token,"compl"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	!src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 //			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
 }
@@ -4008,11 +4005,10 @@
 {
 	return		(robust_token_is_string<6>(src.index_tokens[0].token,"typeid"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	!src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags)
 			&&	C_TYPE::TYPEINFO==src.type_code.base_type_index
 			&&	0==src.type_code.pointer_power
@@ -4024,11 +4020,10 @@
 {
 	return		(robust_token_is_string<6>(src.index_tokens[0].token,"sizeof"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	!src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
 //			&&	1==src.size<2>() && ((PARSE_UNARY_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
 }
@@ -4044,8 +4039,8 @@
 static bool is_C99_mult_operator_expression(const parse_tree& src)
 {
 	return		(robust_token_is_char<'/'>(src.index_tokens[0].token) || robust_token_is_char<'%'>(src.index_tokens[0].token) || robust_token_is_char<'*'>(src.index_tokens[0].token))
-			&&	NULL!=src.index_tokens[0].src_filename
-			&&	NULL==src.index_tokens[1].token.first
+			&&	src.index_tokens[0].src_filename
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4058,9 +4053,9 @@
 {
 	return		robust_token_is_char<c>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4079,9 +4074,9 @@
 {
 	return		(robust_token_is_char<'+'>(src.index_tokens[0].token) || robust_token_is_char<'-'>(src.index_tokens[0].token))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4094,9 +4089,9 @@
 {
 	return		robust_token_is_char<c>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4110,9 +4105,9 @@
 {
 	return		(robust_token_is_string<2>(src.index_tokens[0].token,"<<") || robust_token_is_string<2>(src.index_tokens[0].token,">>"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4129,9 +4124,9 @@
 {
 	return		(robust_token_is_char<'<'>(src.index_tokens[0].token) || robust_token_is_char<'>'>(src.index_tokens[0].token) || robust_token_is_string<2>(src.index_tokens[0].token,"<=") || robust_token_is_string<2>(src.index_tokens[0].token,">="))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4145,9 +4140,9 @@
 {
 	return		(robust_token_is_string<2>(src.index_tokens[0].token,"==") || robust_token_is_string<2>(src.index_tokens[0].token,"!="))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4159,9 +4154,9 @@
 {
 	return		(robust_token_is_string<2>(src.index_tokens[0].token,"==") || robust_token_is_string<2>(src.index_tokens[0].token,"!=") || robust_token_is_string<6>(src.index_tokens[0].token,"not_eq"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4173,9 +4168,9 @@
 {
 	return (	robust_token_is_char<'&'>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4187,9 +4182,9 @@
 {
 	return (	(robust_token_is_char<'&'>(src.index_tokens[0].token) || robust_token_is_string<6>(src.index_tokens[0].token,"bitand"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4201,9 +4196,9 @@
 {
 	return (	robust_token_is_char<'^'>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4215,9 +4210,9 @@
 {
 	return (	(robust_token_is_char<'^'>(src.index_tokens[0].token) || robust_token_is_string<3>(src.index_tokens[0].token,"xor"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4229,9 +4224,9 @@
 {
 	return (	robust_token_is_char<'|'>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4243,9 +4238,9 @@
 {
 	return (	(robust_token_is_char<'|'>(src.index_tokens[0].token) || robust_token_is_string<5>(src.index_tokens[0].token,"bitor"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4257,9 +4252,9 @@
 {
 	return (	robust_token_is_string<2>(src.index_tokens[0].token,"&&")
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4271,9 +4266,9 @@
 {
 	return (	(robust_token_is_string<2>(src.index_tokens[0].token,"&&") || robust_token_is_string<3>(src.index_tokens[0].token,"and"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-29 00:37:11 UTC (rev 512)
+++ trunk/CSupport.cpp.in	2010-10-29 02:34:36 UTC (rev 513)
@@ -4023,11 +4023,10 @@
 {
 	return		robust_token_is_char<c>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	!src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 //			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
 }
@@ -4036,11 +4035,10 @@
 {
 	return		(robust_token_is_char<'!'>(src.index_tokens[0].token) || robust_token_is_string<3>(src.index_tokens[0].token,"not"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	!src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 //			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
 }
@@ -4049,11 +4047,10 @@
 {
 	return		(robust_token_is_char<'~'>(src.index_tokens[0].token) || robust_token_is_string<5>(src.index_tokens[0].token,"compl"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	!src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 //			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
 }
@@ -4063,11 +4060,10 @@
 {
 	return		(robust_token_is_string<6>(src.index_tokens[0].token,"typeid"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	!src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags)
 			&&	C_TYPE::TYPEINFO==src.type_code.base_type_index
 			&&	0==src.type_code.pointer_power
@@ -4079,11 +4075,10 @@
 {
 	return		(robust_token_is_string<6>(src.index_tokens[0].token,"sizeof"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	!src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && ((PARSE_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
 //			&&	1==src.size<2>() && ((PARSE_UNARY_EXPRESSION | PARSE_TYPE) & src.data<2>()->flags);
 }
@@ -4100,8 +4095,8 @@
 static bool is_C99_mult_operator_expression(const parse_tree& src)
 {
 	return		(robust_token_is_char<'/'>(src.index_tokens[0].token) || robust_token_is_char<'%'>(src.index_tokens[0].token) || robust_token_is_char<'*'>(src.index_tokens[0].token))
-			&&	NULL!=src.index_tokens[0].src_filename
-			&&	NULL==src.index_tokens[1].token.first
+			&&	src.index_tokens[0].src_filename
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4114,9 +4109,9 @@
 {
 	return		robust_token_is_char<c>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4135,9 +4130,9 @@
 {
 	return		(robust_token_is_char<'+'>(src.index_tokens[0].token) || robust_token_is_char<'-'>(src.index_tokens[0].token))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4150,9 +4145,9 @@
 {
 	return		robust_token_is_char<c>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4166,9 +4161,9 @@
 {
 	return		(robust_token_is_string<2>(src.index_tokens[0].token,"<<") || robust_token_is_string<2>(src.index_tokens[0].token,">>"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4185,9 +4180,9 @@
 {
 	return		(robust_token_is_char<'<'>(src.index_tokens[0].token) || robust_token_is_char<'>'>(src.index_tokens[0].token) || robust_token_is_string<2>(src.index_tokens[0].token,"<=") || robust_token_is_string<2>(src.index_tokens[0].token,">="))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4201,9 +4196,9 @@
 {
 	return		(robust_token_is_string<2>(src.index_tokens[0].token,"==") || robust_token_is_string<2>(src.index_tokens[0].token,"!="))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4215,9 +4210,9 @@
 {
 	return		(robust_token_is_string<2>(src.index_tokens[0].token,"==") || robust_token_is_string<2>(src.index_tokens[0].token,"!=") || robust_token_is_string<6>(src.index_tokens[0].token,"not_eq"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -4229,9 +4224,9 @@
 {
 	return (	robust_token_is_char<'&'>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4243,9 +4238,9 @@
 {
 	return (	(robust_token_is_char<'&'>(src.index_tokens[0].token) || robust_token_is_string<6>(src.index_tokens[0].token,"bitand"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4257,9 +4252,9 @@
 {
 	return (	robust_token_is_char<'^'>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4271,9 +4266,9 @@
 {
 	return (	(robust_token_is_char<'^'>(src.index_tokens[0].token) || robust_token_is_string<3>(src.index_tokens[0].token,"xor"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4285,9 +4280,9 @@
 {
 	return (	robust_token_is_char<'|'>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4299,9 +4294,9 @@
 {
 	return (	(robust_token_is_char<'|'>(src.index_tokens[0].token) || robust_token_is_string<5>(src.index_tokens[0].token,"bitor"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4313,9 +4308,9 @@
 {
 	return (	robust_token_is_string<2>(src.index_tokens[0].token,"&&")
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4327,9 +4322,9 @@
 {
 	return (	(robust_token_is_string<2>(src.index_tokens[0].token,"&&") || robust_token_is_string<3>(src.index_tokens[0].token,"and"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-10-29 00:37:11 UTC (rev 512)
+++ trunk/CSupport_pp.cpp	2010-10-29 02:34:36 UTC (rev 513)
@@ -1,4 +1,4 @@
-// CSupport_pp.cpp
+// CSupport.cpp
 // support for C/C++ parsing
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
@@ -2960,11 +2960,10 @@
 {
 	return		robust_token_is_char<c>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	!src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 //			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
 }
@@ -2973,11 +2972,10 @@
 {
 	return		(robust_token_is_char<'!'>(src.index_tokens[0].token) || robust_token_is_string<3>(src.index_tokens[0].token,"not"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	!src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 //			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
 }
@@ -2986,11 +2984,10 @@
 {
 	return		(robust_token_is_char<'~'>(src.index_tokens[0].token) || robust_token_is_string<5>(src.index_tokens[0].token,"compl"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	!src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
 //			&&	1==src.size<2>() && (PARSE_CAST_EXPRESSION & src.data<2>()->flags);
 }
@@ -3005,8 +3002,8 @@
 static bool is_C99_mult_operator_expression(const parse_tree& src)
 {
 	return		(robust_token_is_char<'/'>(src.index_tokens[0].token) || robust_token_is_char<'%'>(src.index_tokens[0].token) || robust_token_is_char<'*'>(src.index_tokens[0].token))
-			&&	NULL!=src.index_tokens[0].src_filename
-			&&	NULL==src.index_tokens[1].token.first
+			&&	src.index_tokens[0].src_filename
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -3019,9 +3016,9 @@
 {
 	return		robust_token_is_char<c>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -3040,9 +3037,9 @@
 {
 	return		(robust_token_is_char<'+'>(src.index_tokens[0].token) || robust_token_is_char<'-'>(src.index_tokens[0].token))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -3055,9 +3052,9 @@
 {
 	return		robust_token_is_char<c>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -3071,9 +3068,9 @@
 {
 	return		(robust_token_is_string<2>(src.index_tokens[0].token,"<<") || robust_token_is_string<2>(src.index_tokens[0].token,">>"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -3090,9 +3087,9 @@
 {
 	return		(robust_token_is_char<'<'>(src.index_tokens[0].token) || robust_token_is_char<'>'>(src.index_tokens[0].token) || robust_token_is_string<2>(src.index_tokens[0].token,"<=") || robust_token_is_string<2>(src.index_tokens[0].token,">="))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -3106,9 +3103,9 @@
 {
 	return		(robust_token_is_string<2>(src.index_tokens[0].token,"==") || robust_token_is_string<2>(src.index_tokens[0].token,"!="))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -3120,9 +3117,9 @@
 {
 	return		(robust_token_is_string<2>(src.index_tokens[0].token,"==") || robust_token_is_string<2>(src.index_tokens[0].token,"!=") || robust_token_is_string<6>(src.index_tokens[0].token,"not_eq"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags);
@@ -3134,9 +3131,9 @@
 {
 	return (	robust_token_is_char<'&'>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -3148,9 +3145,9 @@
 {
 	return (	(robust_token_is_char<'&'>(src.index_tokens[0].token) || robust_token_is_string<6>(src.index_tokens[0].token,"bitand"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -3162,9 +3159,9 @@
 {
 	return (	robust_token_is_char<'^'>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -3176,9 +3173,9 @@
 {
 	return (	(robust_token_is_char<'^'>(src.index_tokens[0].token) || robust_token_is_string<3>(src.index_tokens[0].token,"xor"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -3190,9 +3187,9 @@
 {
 	return (	robust_token_is_char<'|'>(src.index_tokens[0].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -3204,9 +3201,9 @@
 {
 	return (	(robust_token_is_char<'|'>(src.index_tokens[0].token) || robust_token_is_string<5>(src.index_tokens[0].token,"bitor"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -3218,9 +3215,9 @@
 {
 	return (	robust_token_is_string<2>(src.index_tokens[0].token,"&&")
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -3232,9 +3229,9 @@
 {
 	return (	(robust_token_is_string<2>(src.index_tokens[0].token,"&&") || robust_token_is_string<3>(src.index_tokens[0].token,"and"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));



From zaimoni at mail.berlios.de  Fri Oct 29 06:17:50 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 29 Oct 2010 06:17:50 +0200
Subject: [Zcplusplus-commits] r514 - trunk
Message-ID: <20101029041751.5252E480F4D@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-29 06:17:50 +0200 (Fri, 29 Oct 2010)
New Revision: 514

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/CSupport_pp.cpp
Log:
stage 3: line count reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-29 02:34:36 UTC (rev 513)
+++ trunk/CSupport.cpp	2010-10-29 04:17:50 UTC (rev 514)
@@ -4280,9 +4280,9 @@
 {
 	return (	robust_token_is_string<2>(src.index_tokens[0].token,"||")
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4294,9 +4294,9 @@
 {
 	return (	(robust_token_is_string<2>(src.index_tokens[0].token,"||") || robust_token_is_string<2>(src.index_tokens[0].token,"or"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4309,7 +4309,7 @@
 {
 	return		robust_token_is_char<'?'>(src.index_tokens[0].token)
 			&&	robust_token_is_char<':'>(src.index_tokens[1].token)
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<2>()->flags)
 			&&	1==src.size<1>() && (PARSE_LOGICOR_EXPRESSION & src.data<2>()->flags)
 			&&	1==src.size<2>() && (PARSE_CONDITIONAL_EXPRESSION & src.data<2>()->flags);		
@@ -4321,7 +4321,7 @@
 	return		robust_token_is_char<'?'>(src.index_tokens[0].token)
 			&&	robust_token_is_char<':'>(src.index_tokens[1].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 #endif
 			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<2>()->flags)
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<2>()->flags)
@@ -4332,11 +4332,10 @@
 {
 	if (	robust_token_is_string(src.index_tokens[0].token,spec_name)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	!src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && is_naked_brace_pair(*src.data<2>()))
 		return true;
 	return false;
@@ -4346,11 +4345,10 @@
 {
 	if (	robust_token_is_string(src.index_tokens[0].token,spec_name)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL!=src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	src.empty<2>())
 		return true;
 	return false;
@@ -4360,11 +4358,10 @@
 {
 	if (	robust_token_is_string(src.index_tokens[0].token,spec_name)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL!=src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && is_naked_brace_pair(*src.data<2>()))
 		return true;
 	return false;
@@ -4374,11 +4371,10 @@
 {
 	if (	NULL!=src.index_tokens[0].token.first
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL!=src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && is_naked_brace_pair(*src.data<2>()))
 		return true;
 	return false;
@@ -4404,7 +4400,7 @@
 static void make_target_postfix_arg(parse_tree& src,size_t& offset,const size_t i,const size_t j)
 {
 	parse_tree* tmp = (0==offset ? _new_buffer_nonNULL_throws<parse_tree>(1) :  _new_buffer<parse_tree>(1));
-	if (NULL==tmp)
+	if (!tmp)
 		{	// need that slack space now
 		src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
 		offset = 0;
@@ -4606,7 +4602,7 @@
 bool convert_to(umaxint& dest,const C_PPIntCore& src)
 {
 	assert(8==src.radix || 10==src.radix || 16==src.radix);
-	assert(NULL!=src.ptr && 0<src.digit_span);
+	assert(src.ptr && 0<src.digit_span);
 
 	const unsigned_var_int alt_radix(src.radix,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 	unsigned_var_int strict_ub(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
@@ -4717,8 +4713,7 @@
 }
 
 static bool _CPP_intlike_literal_to_VM(umaxint& dest, const parse_tree& src)
-{
-	//! \todo: similar code for handling LLONG_MIN as above.  Need that only for zcc; can't test in preprocessor as the true reserved word won't make it this far.
+{	//! \todo: similar code for handling LLONG_MIN as above.  Need that only for zcc; can't test in preprocessor as the true reserved word won't make it this far.
 	if (!src.is_atomic()) return false;
 	// intercept true, false
 	if 		(token_is_string<4>(src.index_tokens[0].token,"true"))
@@ -4740,7 +4735,7 @@
 static POD_pair<const parse_tree*,bool>
 _find_intlike_literal(const parse_tree* src SIG_CONST_TYPES)
 {
-	assert(NULL!=src);
+	assert(src);
 	POD_pair<const parse_tree*,bool> ret = {src,false};
 	while(converts_to_integer(ret.first->type_code ARG_TYPES))
 		{
@@ -4748,12 +4743,12 @@
 			{
 			ret.second = !ret.second;
 			ret.first = ret.first->data<2>();
-			assert(NULL!=ret.first);
+			assert(ret.first);
 			}
 		else if (is_C99_unary_operator_expression<'+'>(*ret.first))
 			{
 			ret.first = ret.first->data<2>();
-			assert(NULL!=ret.first);
+			assert(ret.first);
 			}
 		else
 			break;
@@ -4856,42 +4851,36 @@
 				size_t i = 0;
 				do	switch(types.int_priority[i])
 					{
-					case C_TYPE::INT:	{
-										if (no_signed || C_PPIntCore::L<=type_hint) continue;
-										if (tmp>target_machine->signed_max<virtual_machine::std_int_int>()) continue;
-										src.type_code.base_type_index = C_TYPE::INT;
-										return;
-										}
-					case C_TYPE::UINT:	{
-										if (no_unsigned || C_PPIntCore::L<=type_hint) continue;
-										if (tmp>target_machine->unsigned_max<virtual_machine::std_int_int>()) continue;
-										src.type_code.base_type_index = C_TYPE::UINT;
-										return;
-										}
-					case C_TYPE::LONG:	{
-										if (no_signed || C_PPIntCore::LL<=type_hint) continue;
-										if (tmp>target_machine->signed_max<virtual_machine::std_int_long>()) continue;
-										src.type_code.base_type_index = C_TYPE::LONG;
-										return;
-										}
-					case C_TYPE::ULONG:	{
-										if (no_unsigned || C_PPIntCore::LL<=type_hint) continue;
-										if (tmp>target_machine->unsigned_max<virtual_machine::std_int_long>()) continue;
-										src.type_code.base_type_index = C_TYPE::ULONG;
-										return;
-										}
-					case C_TYPE::LLONG:	{
-										if (no_signed) continue;
-										if (tmp>target_machine->signed_max<virtual_machine::std_int_long_long>()) continue;
-										src.type_code.base_type_index = C_TYPE::LLONG;
-										return;
-										}
-					case C_TYPE::ULLONG:{
-										if (no_unsigned) continue;
-										if (tmp>target_machine->unsigned_max<virtual_machine::std_int_long_long>()) continue;
-										src.type_code.base_type_index = C_TYPE::ULLONG;
-										return;
-										}
+					case C_TYPE::INT:
+						if (no_signed || C_PPIntCore::L<=type_hint) continue;
+						if (tmp>target_machine->signed_max<virtual_machine::std_int_int>()) continue;
+						src.type_code.base_type_index = C_TYPE::INT;
+						return;
+					case C_TYPE::UINT:
+						if (no_unsigned || C_PPIntCore::L<=type_hint) continue;
+						if (tmp>target_machine->unsigned_max<virtual_machine::std_int_int>()) continue;
+						src.type_code.base_type_index = C_TYPE::UINT;
+						return;
+					case C_TYPE::LONG:
+						if (no_signed || C_PPIntCore::LL<=type_hint) continue;
+						if (tmp>target_machine->signed_max<virtual_machine::std_int_long>()) continue;
+						src.type_code.base_type_index = C_TYPE::LONG;
+						return;
+					case C_TYPE::ULONG:
+						if (no_unsigned || C_PPIntCore::LL<=type_hint) continue;
+						if (tmp>target_machine->unsigned_max<virtual_machine::std_int_long>()) continue;
+						src.type_code.base_type_index = C_TYPE::ULONG;
+						return;
+					case C_TYPE::LLONG:
+						if (no_signed) continue;
+						if (tmp>target_machine->signed_max<virtual_machine::std_int_long_long>()) continue;
+						src.type_code.base_type_index = C_TYPE::LLONG;
+						return;
+					case C_TYPE::ULLONG:
+						if (no_unsigned) continue;
+						if (tmp>target_machine->unsigned_max<virtual_machine::std_int_long_long>()) continue;
+						src.type_code.base_type_index = C_TYPE::ULLONG;
+						return;
 					}
 				while(types.int_priority_size > ++i);
 				};
@@ -4908,8 +4897,7 @@
 			INFORM(" (C99 6.4.4.1p5/C++0x 2.13.1p3)");
 			zcc_errors.inc_error();
 			}
-		else{
-			//! \todo --do-what-i-mean should check for floating-point numerals that convert exactly to integers
+		else{	//! \todo --do-what-i-mean should check for floating-point numerals that convert exactly to integers
 			src.type_code.set_type(	(C_TESTFLAG_L & src.index_tokens[0].flags) ? C_TYPE::LDOUBLE : 
 									(C_TESTFLAG_F & src.index_tokens[0].flags) ? C_TYPE::FLOAT : C_TYPE::DOUBLE);
 			}
@@ -4964,8 +4952,7 @@
 				str_span.first += 2;
 				want_first_slideup = true;
 				}
-			else{
-				// more than two strings to psuedo-concatenate
+			else{	// more than two strings to psuedo-concatenate
 				POD_pair<size_t,size_t> scan = {str_span.first,str_span.first+2};
 				while(src.size<0>()>scan.second+1 && C_TESTFLAG_STRING_LITERAL==src.data<0>()[scan.second+1].index_tokens[0].flags) ++scan.second;
 				if (parse_tree::collapse_matched_pair(src,scan))
@@ -5042,7 +5029,7 @@
 
 	size_t j = STATIC_SIZE(src.args);
 	do	{
-		if (0== --j && NULL!=src.index_tokens[0].token.first && NULL!=src.index_tokens[1].token.first)
+		if (0== --j && src.index_tokens[0].token.first && src.index_tokens[1].token.first)
 			{
 			if (token_is_char<'('>(src.index_tokens[0].token) && token_is_char<')'>(src.index_tokens[1].token)) break;	// need to parse to rule out constructor memory initializer
 			if (token_is_char<'{'>(src.index_tokens[0].token) && token_is_char<'}'>(src.index_tokens[1].token)) break;	// need to parse to rule out non-static member function
@@ -5088,7 +5075,7 @@
 	size_t i = 0;
 	//! \todo optimize this loop
 	do	{
-		if (NULL!=src.data<0>()[i].index_tokens[1].token.first) continue;
+		if (src.data<0>()[i].index_tokens[1].token.first) continue;
 		if 		(token_is_char<')'>(src.data<0>()[i].index_tokens[0].token))
 			{
 			assert(0<paren_idx);
@@ -5282,8 +5269,7 @@
 static bool suppress_naked_brackets_and_braces(parse_tree& src,const char* const err_prefix,size_t err_len)
 {
 	if (!(PARSE_OBVIOUS & src.flags) && src.empty<1>() && src.empty<2>())
-		{
-		// top-level [ ] dies regardless of contents
+		{	// top-level [ ] dies regardless of contents
 		// not testable with preprocessor expression (not sure whether reachable with full source code)
 		if 		(robust_token_is_char<'['>(src.index_tokens[0].token))
 			{
@@ -7846,21 +7832,18 @@
 						{	// cancellation...safe
 						switch(cmp(lhs_test,rhs_test))
 						{
-						case -1:{
-								result_is_negative = rhs_negative;
-								rhs_test -= lhs_test;
-								lhs_test = rhs_test;
-								break;
-								}
-						case 0:	{
-								lhs_test.clear();
-								break;
-								}
-						case 1:	{
-								result_is_negative = lhs_negative;
-								lhs_test -= rhs_test;
-								break;
-								}
+						case -1:
+							result_is_negative = rhs_negative;
+							rhs_test -= lhs_test;
+							lhs_test = rhs_test;
+							break;
+						case 0:
+							lhs_test.clear();
+							break;
+						case 1:
+							result_is_negative = lhs_negative;
+							lhs_test -= rhs_test;
+							break;
 						};
 						}
 					else{	// augmentation: bounds-check
@@ -7880,8 +7863,7 @@
 						}
 
 					if (result_is_negative)
-						{
-						// convert to parsed - literal
+						{	// convert to parsed - literal
 						parse_tree tmp;
 						VM_to_literal(tmp,lhs_test,src,types);
 

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-29 02:34:36 UTC (rev 513)
+++ trunk/CSupport.cpp.in	2010-10-29 04:17:50 UTC (rev 514)
@@ -4336,9 +4336,9 @@
 {
 	return (	robust_token_is_string<2>(src.index_tokens[0].token,"||")
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4350,9 +4350,9 @@
 {
 	return (	(robust_token_is_string<2>(src.index_tokens[0].token,"||") || robust_token_is_string<2>(src.index_tokens[0].token,"or"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -4365,7 +4365,7 @@
 {
 	return		robust_token_is_char<'?'>(src.index_tokens[0].token)
 			&&	robust_token_is_char<':'>(src.index_tokens[1].token)
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<2>()->flags)
 			&&	1==src.size<1>() && (PARSE_LOGICOR_EXPRESSION & src.data<2>()->flags)
 			&&	1==src.size<2>() && (PARSE_CONDITIONAL_EXPRESSION & src.data<2>()->flags);		
@@ -4377,7 +4377,7 @@
 	return		robust_token_is_char<'?'>(src.index_tokens[0].token)
 			&&	robust_token_is_char<':'>(src.index_tokens[1].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 #endif
 			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<2>()->flags)
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<2>()->flags)
@@ -4389,11 +4389,10 @@
 {
 	if (	robust_token_is_string(src.index_tokens[0].token,spec_name)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	!src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && is_naked_brace_pair(*src.data<2>()))
 		return true;
 	return false;
@@ -4403,11 +4402,10 @@
 {
 	if (	robust_token_is_string(src.index_tokens[0].token,spec_name)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL!=src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	src.empty<2>())
 		return true;
 	return false;
@@ -4417,11 +4415,10 @@
 {
 	if (	robust_token_is_string(src.index_tokens[0].token,spec_name)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL!=src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && is_naked_brace_pair(*src.data<2>()))
 		return true;
 	return false;
@@ -4431,11 +4428,10 @@
 {
 	if (	NULL!=src.index_tokens[0].token.first
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL!=src.index_tokens[1].token.first
-			&&	src.empty<0>()
-			&&	src.empty<1>()
+			&&	src.index_tokens[1].token.first
+			&&	src.empty<0>() && src.empty<1>()
 			&&	1==src.size<2>() && is_naked_brace_pair(*src.data<2>()))
 		return true;
 	return false;
@@ -4461,7 +4457,7 @@
 static void make_target_postfix_arg(parse_tree& src,size_t& offset,const size_t i,const size_t j)
 {
 	parse_tree* tmp = (0==offset ? _new_buffer_nonNULL_throws<parse_tree>(1) :  _new_buffer<parse_tree>(1));
-	if (NULL==tmp)
+	if (!tmp)
 		{	// need that slack space now
 		src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
 		offset = 0;
@@ -4664,7 +4660,7 @@
 bool convert_to(umaxint& dest,const C_PPIntCore& src)
 {
 	assert(8==src.radix || 10==src.radix || 16==src.radix);
-	assert(NULL!=src.ptr && 0<src.digit_span);
+	assert(src.ptr && 0<src.digit_span);
 
 	const unsigned_var_int alt_radix(src.radix,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 	unsigned_var_int strict_ub(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
@@ -4779,8 +4775,7 @@
 }
 
 static bool _CPP_intlike_literal_to_VM(umaxint& dest, const parse_tree& src)
-{
-	//! \todo: similar code for handling LLONG_MIN as above.  Need that only for zcc; can't test in preprocessor as the true reserved word won't make it this far.
+{	//! \todo: similar code for handling LLONG_MIN as above.  Need that only for zcc; can't test in preprocessor as the true reserved word won't make it this far.
 	if (!src.is_atomic()) return false;
 	// intercept true, false
 	if 		(token_is_string<4>(src.index_tokens[0].token,"true"))
@@ -4802,7 +4797,7 @@
 static POD_pair<const parse_tree*,bool>
 _find_intlike_literal(const parse_tree* src SIG_CONST_TYPES)
 {
-	assert(NULL!=src);
+	assert(src);
 	POD_pair<const parse_tree*,bool> ret = {src,false};
 	while(converts_to_integer(ret.first->type_code ARG_TYPES))
 		{
@@ -4810,12 +4805,12 @@
 			{
 			ret.second = !ret.second;
 			ret.first = ret.first->data<2>();
-			assert(NULL!=ret.first);
+			assert(ret.first);
 			}
 		else if (is_C99_unary_operator_expression<'+'>(*ret.first))
 			{
 			ret.first = ret.first->data<2>();
-			assert(NULL!=ret.first);
+			assert(ret.first);
 			}
 		else
 			break;
@@ -4918,42 +4913,36 @@
 				size_t i = 0;
 				do	switch(types.int_priority[i])
 					{
-					case C_TYPE::INT:	{
-										if (no_signed || C_PPIntCore::L<=type_hint) continue;
-										if (tmp>target_machine->signed_max<virtual_machine::std_int_int>()) continue;
-										src.type_code.base_type_index = C_TYPE::INT;
-										return;
-										}
-					case C_TYPE::UINT:	{
-										if (no_unsigned || C_PPIntCore::L<=type_hint) continue;
-										if (tmp>target_machine->unsigned_max<virtual_machine::std_int_int>()) continue;
-										src.type_code.base_type_index = C_TYPE::UINT;
-										return;
-										}
-					case C_TYPE::LONG:	{
-										if (no_signed || C_PPIntCore::LL<=type_hint) continue;
-										if (tmp>target_machine->signed_max<virtual_machine::std_int_long>()) continue;
-										src.type_code.base_type_index = C_TYPE::LONG;
-										return;
-										}
-					case C_TYPE::ULONG:	{
-										if (no_unsigned || C_PPIntCore::LL<=type_hint) continue;
-										if (tmp>target_machine->unsigned_max<virtual_machine::std_int_long>()) continue;
-										src.type_code.base_type_index = C_TYPE::ULONG;
-										return;
-										}
-					case C_TYPE::LLONG:	{
-										if (no_signed) continue;
-										if (tmp>target_machine->signed_max<virtual_machine::std_int_long_long>()) continue;
-										src.type_code.base_type_index = C_TYPE::LLONG;
-										return;
-										}
-					case C_TYPE::ULLONG:{
-										if (no_unsigned) continue;
-										if (tmp>target_machine->unsigned_max<virtual_machine::std_int_long_long>()) continue;
-										src.type_code.base_type_index = C_TYPE::ULLONG;
-										return;
-										}
+					case C_TYPE::INT:
+						if (no_signed || C_PPIntCore::L<=type_hint) continue;
+						if (tmp>target_machine->signed_max<virtual_machine::std_int_int>()) continue;
+						src.type_code.base_type_index = C_TYPE::INT;
+						return;
+					case C_TYPE::UINT:
+						if (no_unsigned || C_PPIntCore::L<=type_hint) continue;
+						if (tmp>target_machine->unsigned_max<virtual_machine::std_int_int>()) continue;
+						src.type_code.base_type_index = C_TYPE::UINT;
+						return;
+					case C_TYPE::LONG:
+						if (no_signed || C_PPIntCore::LL<=type_hint) continue;
+						if (tmp>target_machine->signed_max<virtual_machine::std_int_long>()) continue;
+						src.type_code.base_type_index = C_TYPE::LONG;
+						return;
+					case C_TYPE::ULONG:
+						if (no_unsigned || C_PPIntCore::LL<=type_hint) continue;
+						if (tmp>target_machine->unsigned_max<virtual_machine::std_int_long>()) continue;
+						src.type_code.base_type_index = C_TYPE::ULONG;
+						return;
+					case C_TYPE::LLONG:
+						if (no_signed) continue;
+						if (tmp>target_machine->signed_max<virtual_machine::std_int_long_long>()) continue;
+						src.type_code.base_type_index = C_TYPE::LLONG;
+						return;
+					case C_TYPE::ULLONG:
+						if (no_unsigned) continue;
+						if (tmp>target_machine->unsigned_max<virtual_machine::std_int_long_long>()) continue;
+						src.type_code.base_type_index = C_TYPE::ULLONG;
+						return;
 					}
 				while(types.int_priority_size > ++i);
 				};
@@ -4970,8 +4959,7 @@
 			INFORM(" (C99 6.4.4.1p5/C++0x 2.13.1p3)");
 			zcc_errors.inc_error();
 			}
-		else{
-			//! \todo --do-what-i-mean should check for floating-point numerals that convert exactly to integers
+		else{	//! \todo --do-what-i-mean should check for floating-point numerals that convert exactly to integers
 			src.type_code.set_type(	(C_TESTFLAG_L & src.index_tokens[0].flags) ? C_TYPE::LDOUBLE : 
 									(C_TESTFLAG_F & src.index_tokens[0].flags) ? C_TYPE::FLOAT : C_TYPE::DOUBLE);
 			}
@@ -5026,8 +5014,7 @@
 				str_span.first += 2;
 				want_first_slideup = true;
 				}
-			else{
-				// more than two strings to psuedo-concatenate
+			else{	// more than two strings to psuedo-concatenate
 				POD_pair<size_t,size_t> scan = {str_span.first,str_span.first+2};
 				while(src.size<0>()>scan.second+1 && C_TESTFLAG_STRING_LITERAL==src.data<0>()[scan.second+1].index_tokens[0].flags) ++scan.second;
 				if (parse_tree::collapse_matched_pair(src,scan))
@@ -5105,7 +5092,7 @@
 
 	size_t j = STATIC_SIZE(src.args);
 	do	{
-		if (0== --j && NULL!=src.index_tokens[0].token.first && NULL!=src.index_tokens[1].token.first)
+		if (0== --j && src.index_tokens[0].token.first && src.index_tokens[1].token.first)
 			{
 			if (token_is_char<'('>(src.index_tokens[0].token) && token_is_char<')'>(src.index_tokens[1].token)) break;	// need to parse to rule out constructor memory initializer
 			if (token_is_char<'{'>(src.index_tokens[0].token) && token_is_char<'}'>(src.index_tokens[1].token)) break;	// need to parse to rule out non-static member function
@@ -5152,7 +5139,7 @@
 	size_t i = 0;
 	//! \todo optimize this loop
 	do	{
-		if (NULL!=src.data<0>()[i].index_tokens[1].token.first) continue;
+		if (src.data<0>()[i].index_tokens[1].token.first) continue;
 		if 		(token_is_char<')'>(src.data<0>()[i].index_tokens[0].token))
 			{
 			assert(0<paren_idx);
@@ -5348,8 +5335,7 @@
 static bool suppress_naked_brackets_and_braces(parse_tree& src,const char* const err_prefix,size_t err_len)
 {
 	if (!(PARSE_OBVIOUS & src.flags) && src.empty<1>() && src.empty<2>())
-		{
-		// top-level [ ] dies regardless of contents
+		{	// top-level [ ] dies regardless of contents
 		// not testable with preprocessor expression (not sure whether reachable with full source code)
 		if 		(robust_token_is_char<'['>(src.index_tokens[0].token))
 			{
@@ -7948,21 +7934,18 @@
 						{	// cancellation...safe
 						switch(cmp(lhs_test,rhs_test))
 						{
-						case -1:{
-								result_is_negative = rhs_negative;
-								rhs_test -= lhs_test;
-								lhs_test = rhs_test;
-								break;
-								}
-						case 0:	{
-								lhs_test.clear();
-								break;
-								}
-						case 1:	{
-								result_is_negative = lhs_negative;
-								lhs_test -= rhs_test;
-								break;
-								}
+						case -1:
+							result_is_negative = rhs_negative;
+							rhs_test -= lhs_test;
+							lhs_test = rhs_test;
+							break;
+						case 0:
+							lhs_test.clear();
+							break;
+						case 1:
+							result_is_negative = lhs_negative;
+							lhs_test -= rhs_test;
+							break;
 						};
 						}
 					else{	// augmentation: bounds-check
@@ -7982,8 +7965,7 @@
 						}
 
 					if (result_is_negative)
-						{
-						// convert to parsed - literal
+						{	// convert to parsed - literal
 						parse_tree tmp;
 						VM_to_literal(tmp,lhs_test,src,types);
 

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-10-29 02:34:36 UTC (rev 513)
+++ trunk/CSupport_pp.cpp	2010-10-29 04:17:50 UTC (rev 514)
@@ -1,4 +1,4 @@
-// CSupport.cpp
+// CSupport_pp.cpp
 // support for C/C++ parsing
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 
@@ -3243,9 +3243,9 @@
 {
 	return (	robust_token_is_string<2>(src.index_tokens[0].token,"||")
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -3257,9 +3257,9 @@
 {
 	return (	(robust_token_is_string<2>(src.index_tokens[0].token,"||") || robust_token_is_string<2>(src.index_tokens[0].token,"or"))
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename
+			&&	src.index_tokens[0].src_filename
 #endif
-			&&	NULL==src.index_tokens[1].token.first
+			&&	!src.index_tokens[1].token.first
 			&&	src.empty<0>()
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<1>()->flags)
 			&&	1==src.size<2>() && (PARSE_EXPRESSION & src.data<2>()->flags));
@@ -3272,7 +3272,7 @@
 {
 	return		robust_token_is_char<'?'>(src.index_tokens[0].token)
 			&&	robust_token_is_char<':'>(src.index_tokens[1].token)
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<2>()->flags)
 			&&	1==src.size<1>() && (PARSE_LOGICOR_EXPRESSION & src.data<2>()->flags)
 			&&	1==src.size<2>() && (PARSE_CONDITIONAL_EXPRESSION & src.data<2>()->flags);		
@@ -3284,7 +3284,7 @@
 	return		robust_token_is_char<'?'>(src.index_tokens[0].token)
 			&&	robust_token_is_char<':'>(src.index_tokens[1].token)
 #ifndef NDEBUG
-			&&	NULL!=src.index_tokens[0].src_filename && NULL!=src.index_tokens[1].src_filename
+			&&	src.index_tokens[0].src_filename && src.index_tokens[1].src_filename
 #endif
 			&&	1==src.size<0>() && (PARSE_EXPRESSION & src.data<2>()->flags)
 			&&	1==src.size<1>() && (PARSE_EXPRESSION & src.data<2>()->flags)
@@ -3294,7 +3294,7 @@
 bool convert_to(umaxint& dest,const C_PPIntCore& src)
 {
 	assert(8==src.radix || 10==src.radix || 16==src.radix);
-	assert(NULL!=src.ptr && 0<src.digit_span);
+	assert(src.ptr && 0<src.digit_span);
 
 	const unsigned_var_int alt_radix(src.radix,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
 	unsigned_var_int strict_ub(0,unsigned_var_int::bytes_from_bits(VM_MAX_BIT_PLATFORM));
@@ -3388,8 +3388,7 @@
 }
 
 static bool _CPP_intlike_literal_to_VM(umaxint& dest, const parse_tree& src)
-{
-	//! \todo: similar code for handling LLONG_MIN as above.  Need that only for zcc; can't test in preprocessor as the true reserved word won't make it this far.
+{	//! \todo: similar code for handling LLONG_MIN as above.  Need that only for zcc; can't test in preprocessor as the true reserved word won't make it this far.
 	if (!src.is_atomic()) return false;
 	// intercept true, false
 	if 		(token_is_string<4>(src.index_tokens[0].token,"true"))
@@ -3411,7 +3410,7 @@
 static POD_pair<const parse_tree*,bool>
 _find_intlike_literal(const parse_tree* src SIG_CONST_TYPES)
 {
-	assert(NULL!=src);
+	assert(src);
 	POD_pair<const parse_tree*,bool> ret = {src,false};
 	while(converts_to_integer(ret.first->type_code ARG_TYPES))
 		{
@@ -3419,12 +3418,12 @@
 			{
 			ret.second = !ret.second;
 			ret.first = ret.first->data<2>();
-			assert(NULL!=ret.first);
+			assert(ret.first);
 			}
 		else if (is_C99_unary_operator_expression<'+'>(*ret.first))
 			{
 			ret.first = ret.first->data<2>();
-			assert(NULL!=ret.first);
+			assert(ret.first);
 			}
 		else
 			break;
@@ -3527,42 +3526,36 @@
 				size_t i = 0;
 				do	switch(types.int_priority[i])
 					{
-					case C_TYPE::INT:	{
-										if (no_signed || C_PPIntCore::L<=type_hint) continue;
-										if (tmp>target_machine->signed_max<virtual_machine::std_int_int>()) continue;
-										src.type_code.base_type_index = C_TYPE::INT;
-										return;
-										}
-					case C_TYPE::UINT:	{
-										if (no_unsigned || C_PPIntCore::L<=type_hint) continue;
-										if (tmp>target_machine->unsigned_max<virtual_machine::std_int_int>()) continue;
-										src.type_code.base_type_index = C_TYPE::UINT;
-										return;
-										}
-					case C_TYPE::LONG:	{
-										if (no_signed || C_PPIntCore::LL<=type_hint) continue;
-										if (tmp>target_machine->signed_max<virtual_machine::std_int_long>()) continue;
-										src.type_code.base_type_index = C_TYPE::LONG;
-										return;
-										}
-					case C_TYPE::ULONG:	{
-										if (no_unsigned || C_PPIntCore::LL<=type_hint) continue;
-										if (tmp>target_machine->unsigned_max<virtual_machine::std_int_long>()) continue;
-										src.type_code.base_type_index = C_TYPE::ULONG;
-										return;
-										}
-					case C_TYPE::LLONG:	{
-										if (no_signed) continue;
-										if (tmp>target_machine->signed_max<virtual_machine::std_int_long_long>()) continue;
-										src.type_code.base_type_index = C_TYPE::LLONG;
-										return;
-										}
-					case C_TYPE::ULLONG:{
-										if (no_unsigned) continue;
-										if (tmp>target_machine->unsigned_max<virtual_machine::std_int_long_long>()) continue;
-										src.type_code.base_type_index = C_TYPE::ULLONG;
-										return;
-										}
+					case C_TYPE::INT:
+						if (no_signed || C_PPIntCore::L<=type_hint) continue;
+						if (tmp>target_machine->signed_max<virtual_machine::std_int_int>()) continue;
+						src.type_code.base_type_index = C_TYPE::INT;
+						return;
+					case C_TYPE::UINT:
+						if (no_unsigned || C_PPIntCore::L<=type_hint) continue;
+						if (tmp>target_machine->unsigned_max<virtual_machine::std_int_int>()) continue;
+						src.type_code.base_type_index = C_TYPE::UINT;
+						return;
+					case C_TYPE::LONG:
+						if (no_signed || C_PPIntCore::LL<=type_hint) continue;
+						if (tmp>target_machine->signed_max<virtual_machine::std_int_long>()) continue;
+						src.type_code.base_type_index = C_TYPE::LONG;
+						return;
+					case C_TYPE::ULONG:
+						if (no_unsigned || C_PPIntCore::LL<=type_hint) continue;
+						if (tmp>target_machine->unsigned_max<virtual_machine::std_int_long>()) continue;
+						src.type_code.base_type_index = C_TYPE::ULONG;
+						return;
+					case C_TYPE::LLONG:
+						if (no_signed) continue;
+						if (tmp>target_machine->signed_max<virtual_machine::std_int_long_long>()) continue;
+						src.type_code.base_type_index = C_TYPE::LLONG;
+						return;
+					case C_TYPE::ULLONG:
+						if (no_unsigned) continue;
+						if (tmp>target_machine->unsigned_max<virtual_machine::std_int_long_long>()) continue;
+						src.type_code.base_type_index = C_TYPE::ULLONG;
+						return;
 					}
 				while(types.int_priority_size > ++i);
 				};
@@ -3579,8 +3572,7 @@
 			INFORM(" (C99 6.4.4.1p5/C++0x 2.13.1p3)");
 			zcc_errors.inc_error();
 			}
-		else{
-			//! \todo --do-what-i-mean should check for floating-point numerals that convert exactly to integers
+		else{	//! \todo --do-what-i-mean should check for floating-point numerals that convert exactly to integers
 			src.type_code.set_type(	(C_TESTFLAG_L & src.index_tokens[0].flags) ? C_TYPE::LDOUBLE : 
 									(C_TESTFLAG_F & src.index_tokens[0].flags) ? C_TYPE::FLOAT : C_TYPE::DOUBLE);
 			}
@@ -3635,8 +3627,7 @@
 				str_span.first += 2;
 				want_first_slideup = true;
 				}
-			else{
-				// more than two strings to psuedo-concatenate
+			else{	// more than two strings to psuedo-concatenate
 				POD_pair<size_t,size_t> scan = {str_span.first,str_span.first+2};
 				while(src.size<0>()>scan.second+1 && C_TESTFLAG_STRING_LITERAL==src.data<0>()[scan.second+1].index_tokens[0].flags) ++scan.second;
 				if (parse_tree::collapse_matched_pair(src,scan))
@@ -3725,7 +3716,7 @@
 	size_t i = 0;
 	//! \todo optimize this loop
 	do	{
-		if (NULL!=src.data<0>()[i].index_tokens[1].token.first) continue;
+		if (src.data<0>()[i].index_tokens[1].token.first) continue;
 		if 		(token_is_char<')'>(src.data<0>()[i].index_tokens[0].token))
 			{
 			assert(0<paren_idx);
@@ -3912,8 +3903,7 @@
 static bool suppress_naked_brackets_and_braces(parse_tree& src,const char* const err_prefix,size_t err_len)
 {
 	if (!(PARSE_OBVIOUS & src.flags) && src.empty<1>() && src.empty<2>())
-		{
-		// top-level [ ] dies regardless of contents
+		{	// top-level [ ] dies regardless of contents
 		// not testable with preprocessor expression (not sure whether reachable with full source code)
 		if 		(robust_token_is_char<'['>(src.index_tokens[0].token))
 			{
@@ -6021,21 +6011,18 @@
 						{	// cancellation...safe
 						switch(cmp(lhs_test,rhs_test))
 						{
-						case -1:{
-								result_is_negative = rhs_negative;
-								rhs_test -= lhs_test;
-								lhs_test = rhs_test;
-								break;
-								}
-						case 0:	{
-								lhs_test.clear();
-								break;
-								}
-						case 1:	{
-								result_is_negative = lhs_negative;
-								lhs_test -= rhs_test;
-								break;
-								}
+						case -1:
+							result_is_negative = rhs_negative;
+							rhs_test -= lhs_test;
+							lhs_test = rhs_test;
+							break;
+						case 0:
+							lhs_test.clear();
+							break;
+						case 1:
+							result_is_negative = lhs_negative;
+							lhs_test -= rhs_test;
+							break;
 						};
 						}
 					else{	// augmentation: bounds-check
@@ -6055,8 +6042,7 @@
 						}
 
 					if (result_is_negative)
-						{
-						// convert to parsed - literal
+						{	// convert to parsed - literal
 						parse_tree tmp;
 						VM_to_literal(tmp,lhs_test,src,types);
 



From zaimoni at mail.berlios.de  Fri Oct 29 07:23:09 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Fri, 29 Oct 2010 07:23:09 +0200
Subject: [Zcplusplus-commits] r515 - trunk
Message-ID: <20101029052309.C3403481030@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-29 07:23:09 +0200 (Fri, 29 Oct 2010)
New Revision: 515

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
   trunk/CSupport_pp.cpp
Log:
stage 3: line count reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-29 04:17:50 UTC (rev 514)
+++ trunk/CSupport.cpp	2010-10-29 05:23:09 UTC (rev 515)
@@ -7976,21 +7976,18 @@
 						{	// cancellation: safe
 						switch(cmp(lhs_test,rhs_test))
 						{
-						case -1:{
-								result_is_negative = !lhs_negative;
-								rhs_test -= lhs_test;
-								lhs_test = rhs_test;
-								break;
-								}
-						case 0:	{
-								lhs_test.clear();
-								break;
-								}
-						case 1:	{
-								result_is_negative = lhs_negative;
-								lhs_test -= rhs_test;
-								break;
-								}
+						case -1:
+							result_is_negative = !lhs_negative;
+							rhs_test -= lhs_test;
+							lhs_test = rhs_test;
+							break;
+						case 0:
+							lhs_test.clear();
+							break;
+						case 1:
+							result_is_negative = lhs_negative;
+							lhs_test -= rhs_test;
+							break;
 						};
 						}
 					else{	// augmentation: need bounds check
@@ -8010,8 +8007,7 @@
 						}
 
 					if (result_is_negative)
-						{
-						// convert to parsed - literal
+						{	// convert to parsed - literal
 						parse_tree tmp;
 						VM_to_literal(tmp,lhs_test,src,types);
 						src.DeleteIdx<1>(0);
@@ -8404,8 +8400,7 @@
 			{
 			// note that incoming negative signed integers are not handled by this code path
 			if (C99_SHIFT_SUBTYPE_LEFT==src.subtype)
-				{
-				//! \todo but signed integers do go undefined in C if left-shifted too much; C++ accepts
+				{	//! \todo but signed integers do go undefined in C if left-shifted too much; C++ accepts
 #if 0
 				if (0==(src.type_code.base_type_index-C_TYPE::INT)%2 && target_machine->C_bit(machine_type)<=rhs_int.to_uint()+lhs_int.int_log2()+1)
 					simple_error(src," : result does not fit in LHS type; undefined behavior (C99 6.5.7p3)");
@@ -8588,27 +8583,21 @@
 				}
 			};
 		if (use_unsigned_compare)
-			{
 			switch(src.subtype)
 			{
-			case C99_RELATION_SUBTYPE_LT:	{
-											result = (lhs_int<rhs_int) ? "1" : "0";
-											break;
-											}
-			case C99_RELATION_SUBTYPE_GT:	{
-											result = (lhs_int>rhs_int) ? "1" : "0";
-											break;
-											}
-			case C99_RELATION_SUBTYPE_LTE:	{
-											result = (lhs_int<=rhs_int) ? "1" : "0";
-											break;
-											}
-			case C99_RELATION_SUBTYPE_GTE:	{
-											result = (lhs_int>=rhs_int) ? "1" : "0";
-											break;
-											}
-			}
-			}
+			case C99_RELATION_SUBTYPE_LT:
+				result = (lhs_int<rhs_int) ? "1" : "0";
+				break;
+			case C99_RELATION_SUBTYPE_GT:
+				result = (lhs_int>rhs_int) ? "1" : "0";
+				break;
+			case C99_RELATION_SUBTYPE_LTE:
+				result = (lhs_int<=rhs_int) ? "1" : "0";
+				break;
+			case C99_RELATION_SUBTYPE_GTE:
+				result = (lhs_int>=rhs_int) ? "1" : "0";
+				break;
+			};
 		force_decimal_literal(src,result,types);
 		return true;
 		};
@@ -8622,32 +8611,29 @@
 	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power)+2*(0<src.data<2>()->type_code.pointer_power);
 	switch(ptr_case)
 	{
-	case 0:	{	// can't test from preprocessor
-			if (!converts_to_reallike(src.data<1>()->type_code.base_type_index ARG_TYPES) || !converts_to_reallike(src.data<2>()->type_code.base_type_index ARG_TYPES))
-				{
-				simple_error(src," compares non-real type(s) (C99 6.5.8p2/C++98 5.9p2)");
-				return false;
-				}
-			break;
+	case 0:	// can't test from preprocessor
+		if (!converts_to_reallike(src.data<1>()->type_code.base_type_index ARG_TYPES) || !converts_to_reallike(src.data<2>()->type_code.base_type_index ARG_TYPES))
+			{
+			simple_error(src," compares non-real type(s) (C99 6.5.8p2/C++98 5.9p2)");
+			return false;
 			}
-	case 1:	{	//! \todo need floating-point literal to test first half
-				//! \todo figure out how to test second half
-			if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
-				{	// oops
-				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
-				return false;
-				}
-			break;
+		break;
+	case 1:	//! \todo need floating-point literal to test first half
+			//! \todo figure out how to test second half
+		if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+			{	// oops
+			simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
+			return false;
 			}
-	case 2:	{	//! \todo need floating-point literal to test first half
-				//! \todo figure out how to test second half
-			if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
-				{	// oops
-				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
-				return false;
-				}
-			break;
+		break;
+	case 2:	//! \todo need floating-point literal to test first half
+			//! \todo figure out how to test second half
+		if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
+			{	// oops
+			simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
+			return false;
 			}
+		break;
 	}
 	return true;
 }
@@ -8884,30 +8870,27 @@
 	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power)+2*(0<src.data<2>()->type_code.pointer_power);
 	switch(ptr_case)
 	{
-	case 0:	{	// can't test from preprocessor
-			if (C_TYPE::VOID>=src.data<1>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index)
-				{
-				simple_error(src," can't use a void or indeterminately typed argument");
-				return false;
-				}
-			break;
+	case 0:	// can't test from preprocessor
+		if (C_TYPE::VOID>=src.data<1>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index)
+			{
+			simple_error(src," can't use a void or indeterminately typed argument");
+			return false;
 			}
-	case 1:	{	// need floating-point literal to test from preprocessor
-			if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
-				{	// oops
-				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
-				return false;
-				}
-			break;
+		break;
+	case 1:	// need floating-point literal to test from preprocessor
+		if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+			{	// oops
+			simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
+			return false;
 			}
-	case 2:	{	// need floating-point literal to test from preprocessor
-			if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
-				{	// oops
-				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
-				return false;
-				}
-			break;
+		break;
+	case 2:	// need floating-point literal to test from preprocessor
+		if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
+			{	// oops
+			simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
+			return false;
 			}
+		break;
 	}
 	return true;
 }
@@ -9060,8 +9043,7 @@
 		if (int_has_trapped(src,res_int)) return false;
 
 		if 		(res_int==lhs_int)
-			// lhs & rhs = lhs; conserve type
-			{
+			{	// lhs & rhs = lhs; conserve type
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
@@ -9069,8 +9051,7 @@
 			src.eval_to_arg<1>(0);
 			}
 		else if (res_int==rhs_int)
-			// lhs & rhs = rhs; conserve type
-			{
+			{	// lhs & rhs = rhs; conserve type
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<2>(),types))
 				enumerator_to_integer_representation(*src.c_array<2>(),types);
@@ -9434,8 +9415,7 @@
 		res_int |= rhs_int;
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
 		if 		(res_int==lhs_int)
-			// lhs | rhs = lhs; conserve type
-			{
+			{	// lhs | rhs = lhs; conserve type
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);
@@ -9443,8 +9423,7 @@
 			src.eval_to_arg<1>(0);
 			}
 		else if (res_int==rhs_int)
-			// lhs | rhs = rhs; conserve type
-			{
+			{	// lhs | rhs = rhs; conserve type
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
 				enumerator_to_integer_representation(*src.c_array<1>(),types);

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-29 04:17:50 UTC (rev 514)
+++ trunk/CSupport.cpp.in	2010-10-29 05:23:09 UTC (rev 515)
@@ -8078,21 +8078,18 @@
 						{	// cancellation: safe
 						switch(cmp(lhs_test,rhs_test))
 						{
-						case -1:{
-								result_is_negative = !lhs_negative;
-								rhs_test -= lhs_test;
-								lhs_test = rhs_test;
-								break;
-								}
-						case 0:	{
-								lhs_test.clear();
-								break;
-								}
-						case 1:	{
-								result_is_negative = lhs_negative;
-								lhs_test -= rhs_test;
-								break;
-								}
+						case -1:
+							result_is_negative = !lhs_negative;
+							rhs_test -= lhs_test;
+							lhs_test = rhs_test;
+							break;
+						case 0:
+							lhs_test.clear();
+							break;
+						case 1:
+							result_is_negative = lhs_negative;
+							lhs_test -= rhs_test;
+							break;
 						};
 						}
 					else{	// augmentation: need bounds check
@@ -8112,8 +8109,7 @@
 						}
 
 					if (result_is_negative)
-						{
-						// convert to parsed - literal
+						{	// convert to parsed - literal
 						parse_tree tmp;
 						VM_to_literal(tmp,lhs_test,src,types);
 						src.DeleteIdx<1>(0);
@@ -8512,8 +8508,7 @@
 			{
 			// note that incoming negative signed integers are not handled by this code path
 			if (C99_SHIFT_SUBTYPE_LEFT==src.subtype)
-				{
-				//! \todo but signed integers do go undefined in C if left-shifted too much; C++ accepts
+				{	//! \todo but signed integers do go undefined in C if left-shifted too much; C++ accepts
 #if 0
 				if (0==(src.type_code.base_type_index-C_TYPE::INT)%2 && target_machine->C_bit(machine_type)<=rhs_int.to_uint()+lhs_int.int_log2()+1)
 					simple_error(src," : result does not fit in LHS type; undefined behavior (C99 6.5.7p3)");
@@ -8696,27 +8691,21 @@
 				}
 			};
 		if (use_unsigned_compare)
-			{
 			switch(src.subtype)
 			{
-			case C99_RELATION_SUBTYPE_LT:	{
-											result = (lhs_int<rhs_int) ? "1" : "0";
-											break;
-											}
-			case C99_RELATION_SUBTYPE_GT:	{
-											result = (lhs_int>rhs_int) ? "1" : "0";
-											break;
-											}
-			case C99_RELATION_SUBTYPE_LTE:	{
-											result = (lhs_int<=rhs_int) ? "1" : "0";
-											break;
-											}
-			case C99_RELATION_SUBTYPE_GTE:	{
-											result = (lhs_int>=rhs_int) ? "1" : "0";
-											break;
-											}
-			}
-			}
+			case C99_RELATION_SUBTYPE_LT:
+				result = (lhs_int<rhs_int) ? "1" : "0";
+				break;
+			case C99_RELATION_SUBTYPE_GT:
+				result = (lhs_int>rhs_int) ? "1" : "0";
+				break;
+			case C99_RELATION_SUBTYPE_LTE:
+				result = (lhs_int<=rhs_int) ? "1" : "0";
+				break;
+			case C99_RELATION_SUBTYPE_GTE:
+				result = (lhs_int>=rhs_int) ? "1" : "0";
+				break;
+			};
 		force_decimal_literal(src,result,types);
 		return true;
 		};
@@ -8730,32 +8719,29 @@
 	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power)+2*(0<src.data<2>()->type_code.pointer_power);
 	switch(ptr_case)
 	{
-	case 0:	{	// can't test from preprocessor
-			if (!converts_to_reallike(src.data<1>()->type_code.base_type_index ARG_TYPES) || !converts_to_reallike(src.data<2>()->type_code.base_type_index ARG_TYPES))
-				{
-				simple_error(src," compares non-real type(s) (C99 6.5.8p2/C++98 5.9p2)");
-				return false;
-				}
-			break;
+	case 0:	// can't test from preprocessor
+		if (!converts_to_reallike(src.data<1>()->type_code.base_type_index ARG_TYPES) || !converts_to_reallike(src.data<2>()->type_code.base_type_index ARG_TYPES))
+			{
+			simple_error(src," compares non-real type(s) (C99 6.5.8p2/C++98 5.9p2)");
+			return false;
 			}
-	case 1:	{	//! \todo need floating-point literal to test first half
-				//! \todo figure out how to test second half
-			if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
-				{	// oops
-				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
-				return false;
-				}
-			break;
+		break;
+	case 1:	//! \todo need floating-point literal to test first half
+			//! \todo figure out how to test second half
+		if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+			{	// oops
+			simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
+			return false;
 			}
-	case 2:	{	//! \todo need floating-point literal to test first half
-				//! \todo figure out how to test second half
-			if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
-				{	// oops
-				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
-				return false;
-				}
-			break;
+		break;
+	case 2:	//! \todo need floating-point literal to test first half
+			//! \todo figure out how to test second half
+		if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
+			{	// oops
+			simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
+			return false;
 			}
+		break;
 	}
 	return true;
 }
@@ -8996,30 +8982,27 @@
 	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power)+2*(0<src.data<2>()->type_code.pointer_power);
 	switch(ptr_case)
 	{
-	case 0:	{	// can't test from preprocessor
-			if (C_TYPE::VOID>=src.data<1>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index)
-				{
-				simple_error(src," can't use a void or indeterminately typed argument");
-				return false;
-				}
-			break;
+	case 0:	// can't test from preprocessor
+		if (C_TYPE::VOID>=src.data<1>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index)
+			{
+			simple_error(src," can't use a void or indeterminately typed argument");
+			return false;
 			}
-	case 1:	{	// need floating-point literal to test from preprocessor
-			if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
-				{	// oops
-				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
-				return false;
-				}
-			break;
+		break;
+	case 1:	// need floating-point literal to test from preprocessor
+		if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+			{	// oops
+			simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
+			return false;
 			}
-	case 2:	{	// need floating-point literal to test from preprocessor
-			if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
-				{	// oops
-				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
-				return false;
-				}
-			break;
+		break;
+	case 2:	// need floating-point literal to test from preprocessor
+		if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
+			{	// oops
+			simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
+			return false;
 			}
+		break;
 	}
 	return true;
 }
@@ -9172,8 +9155,7 @@
 		if (int_has_trapped(src,res_int)) return false;
 
 		if 		(res_int==lhs_int)
-			// lhs & rhs = lhs; conserve type
-			{
+			{	// lhs & rhs = lhs; conserve type
 #/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
@@ -9183,8 +9165,7 @@
 			src.eval_to_arg<1>(0);
 			}
 		else if (res_int==rhs_int)
-			// lhs & rhs = rhs; conserve type
-			{
+			{	// lhs & rhs = rhs; conserve type
 #/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<2>(),types))
@@ -9558,8 +9539,7 @@
 		res_int |= rhs_int;
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
 		if 		(res_int==lhs_int)
-			// lhs | rhs = lhs; conserve type
-			{
+			{	// lhs | rhs = lhs; conserve type
 #/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))
@@ -9569,8 +9549,7 @@
 			src.eval_to_arg<1>(0);
 			}
 		else if (res_int==rhs_int)
-			// lhs | rhs = rhs; conserve type
-			{
+			{	// lhs | rhs = rhs; conserve type
 #/*cut-cpp*/
 			// handle enumerators now
 			if (is_noticed_enumerator(*src.data<1>(),types))

Modified: trunk/CSupport_pp.cpp
===================================================================
--- trunk/CSupport_pp.cpp	2010-10-29 04:17:50 UTC (rev 514)
+++ trunk/CSupport_pp.cpp	2010-10-29 05:23:09 UTC (rev 515)
@@ -6155,21 +6155,18 @@
 						{	// cancellation: safe
 						switch(cmp(lhs_test,rhs_test))
 						{
-						case -1:{
-								result_is_negative = !lhs_negative;
-								rhs_test -= lhs_test;
-								lhs_test = rhs_test;
-								break;
-								}
-						case 0:	{
-								lhs_test.clear();
-								break;
-								}
-						case 1:	{
-								result_is_negative = lhs_negative;
-								lhs_test -= rhs_test;
-								break;
-								}
+						case -1:
+							result_is_negative = !lhs_negative;
+							rhs_test -= lhs_test;
+							lhs_test = rhs_test;
+							break;
+						case 0:
+							lhs_test.clear();
+							break;
+						case 1:
+							result_is_negative = lhs_negative;
+							lhs_test -= rhs_test;
+							break;
 						};
 						}
 					else{	// augmentation: need bounds check
@@ -6189,8 +6186,7 @@
 						}
 
 					if (result_is_negative)
-						{
-						// convert to parsed - literal
+						{	// convert to parsed - literal
 						parse_tree tmp;
 						VM_to_literal(tmp,lhs_test,src,types);
 						src.DeleteIdx<1>(0);
@@ -6554,8 +6550,7 @@
 			{
 			// note that incoming negative signed integers are not handled by this code path
 			if (C99_SHIFT_SUBTYPE_LEFT==src.subtype)
-				{
-				//! \todo but signed integers do go undefined in C if left-shifted too much; C++ accepts
+				{	//! \todo but signed integers do go undefined in C if left-shifted too much; C++ accepts
 #if 0
 				if (0==(src.type_code.base_type_index-C_TYPE::INT)%2 && target_machine->C_bit(machine_type)<=rhs_int.to_uint()+lhs_int.int_log2()+1)
 					simple_error(src," : result does not fit in LHS type; undefined behavior (C99 6.5.7p3)");
@@ -6738,27 +6733,21 @@
 				}
 			};
 		if (use_unsigned_compare)
-			{
 			switch(src.subtype)
 			{
-			case C99_RELATION_SUBTYPE_LT:	{
-											result = (lhs_int<rhs_int) ? "1" : "0";
-											break;
-											}
-			case C99_RELATION_SUBTYPE_GT:	{
-											result = (lhs_int>rhs_int) ? "1" : "0";
-											break;
-											}
-			case C99_RELATION_SUBTYPE_LTE:	{
-											result = (lhs_int<=rhs_int) ? "1" : "0";
-											break;
-											}
-			case C99_RELATION_SUBTYPE_GTE:	{
-											result = (lhs_int>=rhs_int) ? "1" : "0";
-											break;
-											}
-			}
-			}
+			case C99_RELATION_SUBTYPE_LT:
+				result = (lhs_int<rhs_int) ? "1" : "0";
+				break;
+			case C99_RELATION_SUBTYPE_GT:
+				result = (lhs_int>rhs_int) ? "1" : "0";
+				break;
+			case C99_RELATION_SUBTYPE_LTE:
+				result = (lhs_int<=rhs_int) ? "1" : "0";
+				break;
+			case C99_RELATION_SUBTYPE_GTE:
+				result = (lhs_int>=rhs_int) ? "1" : "0";
+				break;
+			};
 		force_decimal_literal(src,result,types);
 		return true;
 		};
@@ -6772,32 +6761,29 @@
 	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power)+2*(0<src.data<2>()->type_code.pointer_power);
 	switch(ptr_case)
 	{
-	case 0:	{	// can't test from preprocessor
-			if (!converts_to_reallike(src.data<1>()->type_code.base_type_index ARG_TYPES) || !converts_to_reallike(src.data<2>()->type_code.base_type_index ARG_TYPES))
-				{
-				simple_error(src," compares non-real type(s) (C99 6.5.8p2/C++98 5.9p2)");
-				return false;
-				}
-			break;
+	case 0:	// can't test from preprocessor
+		if (!converts_to_reallike(src.data<1>()->type_code.base_type_index ARG_TYPES) || !converts_to_reallike(src.data<2>()->type_code.base_type_index ARG_TYPES))
+			{
+			simple_error(src," compares non-real type(s) (C99 6.5.8p2/C++98 5.9p2)");
+			return false;
 			}
-	case 1:	{	//! \todo need floating-point literal to test first half
-				//! \todo figure out how to test second half
-			if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
-				{	// oops
-				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
-				return false;
-				}
-			break;
+		break;
+	case 1:	//! \todo need floating-point literal to test first half
+			//! \todo figure out how to test second half
+		if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+			{	// oops
+			simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
+			return false;
 			}
-	case 2:	{	//! \todo need floating-point literal to test first half
-				//! \todo figure out how to test second half
-			if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
-				{	// oops
-				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
-				return false;
-				}
-			break;
+		break;
+	case 2:	//! \todo need floating-point literal to test first half
+			//! \todo figure out how to test second half
+		if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
+			{	// oops
+			simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.8p2/C++98 4.10p1,5.9p2)");
+			return false;
 			}
+		break;
 	}
 	return true;
 }
@@ -7021,30 +7007,27 @@
 	const unsigned int ptr_case = (0<src.data<1>()->type_code.pointer_power)+2*(0<src.data<2>()->type_code.pointer_power);
 	switch(ptr_case)
 	{
-	case 0:	{	// can't test from preprocessor
-			if (C_TYPE::VOID>=src.data<1>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index)
-				{
-				simple_error(src," can't use a void or indeterminately typed argument");
-				return false;
-				}
-			break;
+	case 0:	// can't test from preprocessor
+		if (C_TYPE::VOID>=src.data<1>()->type_code.base_type_index || C_TYPE::VOID>=src.data<2>()->type_code.base_type_index)
+			{
+			simple_error(src," can't use a void or indeterminately typed argument");
+			return false;
 			}
-	case 1:	{	// need floating-point literal to test from preprocessor
-			if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
-				{	// oops
-				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
-				return false;
-				}
-			break;
+		break;
+	case 1:	// need floating-point literal to test from preprocessor
+		if (!converts_to_integer(src.data<2>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<2>()->flags))
+			{	// oops
+			simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
+			return false;
 			}
-	case 2:	{	// need floating-point literal to test from preprocessor
-			if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
-				{	// oops
-				simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
-				return false;
-				}
-			break;
+		break;
+	case 2:	// need floating-point literal to test from preprocessor
+		if (!converts_to_integer(src.data<1>()->type_code ARG_TYPES) || !(PARSE_PRIMARY_EXPRESSION & src.data<1>()->flags))
+			{	// oops
+			simple_error(src," compares pointer to something not an integer literal or pointer (C99 6.5.9p5/C++98 4.10p1,5.10p1)");
+			return false;
 			}
+		break;
 	}
 	return true;
 }
@@ -7197,14 +7180,12 @@
 		if (int_has_trapped(src,res_int)) return false;
 
 		if 		(res_int==lhs_int)
-			// lhs & rhs = lhs; conserve type
-			{
+			{	// lhs & rhs = lhs; conserve type
 			src.type_code.MoveInto(src.c_array<1>()->type_code);
 			src.eval_to_arg<1>(0);
 			}
 		else if (res_int==rhs_int)
-			// lhs & rhs = rhs; conserve type
-			{
+			{	// lhs & rhs = rhs; conserve type
 			src.type_code.MoveInto(src.c_array<2>()->type_code);
 			src.eval_to_arg<2>(0);
 			}
@@ -7553,14 +7534,12 @@
 		res_int |= rhs_int;
 //		res_int.mask_to(target_machine->C_bit(machine_type));	// shouldn't need this
 		if 		(res_int==lhs_int)
-			// lhs | rhs = lhs; conserve type
-			{
+			{	// lhs | rhs = lhs; conserve type
 			src.type_code.MoveInto(src.c_array<1>()->type_code);
 			src.eval_to_arg<1>(0);
 			}
 		else if (res_int==rhs_int)
-			// lhs | rhs = rhs; conserve type
-			{
+			{	// lhs | rhs = rhs; conserve type
 			src.type_code.MoveInto(src.c_array<2>()->type_code);
 			src.eval_to_arg<2>(0);
 			}



From zaimoni at mail.berlios.de  Sat Oct 30 11:12:34 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 30 Oct 2010 11:12:34 +0200
Subject: [Zcplusplus-commits] r516 - trunk
Message-ID: <20101030091234.DEC9A480E99@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-30 11:12:34 +0200 (Sat, 30 Oct 2010)
New Revision: 516

Modified:
   trunk/CSupport.cpp
   trunk/CSupport.cpp.in
Log:
stage 3: lines of code reduction

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2010-10-29 05:23:09 UTC (rev 515)
+++ trunk/CSupport.cpp	2010-10-30 09:12:34 UTC (rev 516)
@@ -10687,7 +10687,7 @@
 			if (0<forward_span)
 				{
 				char* tmp = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(resize_to));
-				if (NULL==tmp)
+				if (!tmp)
 					{
 					if (0==offset) throw std::bad_alloc();
 					src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
@@ -10699,7 +10699,7 @@
 				do	strncat(tmp,src.data<0>()[i+j].index_tokens[0].token.first,src.data<0>()[i+j].index_tokens[0].token.second);
 				while(forward_span>= ++j);
 				const char* tmp2 = is_string_registered(tmp);
-				if (NULL==tmp2)
+				if (!tmp2)
 					{
 					src.c_array<0>()[i].grab_index_token_from_str_literal<0>(tmp,C_TESTFLAG_IDENTIFIER);	// well...not really, but it'll substitute for one
 					src.c_array<0>()[i].control_index_token<0>(true);
@@ -11479,12 +11479,10 @@
 static bool check_for_typedef(type_spec& dest,const char* const src,const char* const active_namespace,const type_system& types)
 {
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef_CPP(src,active_namespace);
-	if (tmp)
-		{	//! \todo C++: check for access control if source ends up being a class or struct
-		value_copy(dest,tmp->first);
-		return true;
-		}
-	return false;
+	if (!tmp) return false;
+	//! \todo C++: check for access control if source ends up being a class or struct
+	value_copy(dest,tmp->first);
+	return true;
 }
 
 //! \todo does this need to be in ParseTree.hpp?
@@ -11906,19 +11904,14 @@
 // very basic syntax check; defer real parsing to later
 static bool is_CPP0X_attribute(const parse_tree& x)
 {
-	if (   is_naked_bracket_pair(x)
-		&& 1==x.size<0>()
-		&& is_naked_bracket_pair(*x.data<0>()))
-		return true;
-	return false;
+	return is_naked_bracket_pair(x) && 1==x.size<0>()
+	    && is_naked_bracket_pair(*x.data<0>());
 }
 
 static bool is_CPP0X_ref_qualifier(const parse_tree& x)
 {
-	if (   robust_token_is_char<'&'>(x)
-		|| robust_token_is_string<2>(x,"&&"))
-		return true;
-	return false;
+	return robust_token_is_char<'&'>(x)
+	    || robust_token_is_string<2>(x,"&&");
 }
 
 // very basic syntax check; defer real parsing to later

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-29 05:23:09 UTC (rev 515)
+++ trunk/CSupport.cpp.in	2010-10-30 09:12:34 UTC (rev 516)
@@ -10818,7 +10818,7 @@
 			if (0<forward_span)
 				{
 				char* tmp = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(resize_to));
-				if (NULL==tmp)
+				if (!tmp)
 					{
 					if (0==offset) throw std::bad_alloc();
 					src.DeleteNSlotsAt<0>(offset,src.size<0>()-offset);
@@ -10830,7 +10830,7 @@
 				do	strncat(tmp,src.data<0>()[i+j].index_tokens[0].token.first,src.data<0>()[i+j].index_tokens[0].token.second);
 				while(forward_span>= ++j);
 				const char* tmp2 = is_string_registered(tmp);
-				if (NULL==tmp2)
+				if (!tmp2)
 					{
 					src.c_array<0>()[i].grab_index_token_from_str_literal<0>(tmp,C_TESTFLAG_IDENTIFIER);	// well...not really, but it'll substitute for one
 					src.c_array<0>()[i].control_index_token<0>(true);
@@ -11618,12 +11618,10 @@
 static bool check_for_typedef(type_spec& dest,const char* const src,const char* const active_namespace,const type_system& types)
 {
 	const zaimoni::POD_triple<type_spec,const char*,size_t>* tmp = types.get_typedef_CPP(src,active_namespace);
-	if (tmp)
-		{	//! \todo C++: check for access control if source ends up being a class or struct
-		value_copy(dest,tmp->first);
-		return true;
-		}
-	return false;
+	if (!tmp) return false;
+	//! \todo C++: check for access control if source ends up being a class or struct
+	value_copy(dest,tmp->first);
+	return true;
 }
 
 //! \todo does this need to be in ParseTree.hpp?
@@ -12045,19 +12043,14 @@
 // very basic syntax check; defer real parsing to later
 static bool is_CPP0X_attribute(const parse_tree& x)
 {
-	if (   is_naked_bracket_pair(x)
-		&& 1==x.size<0>()
-		&& is_naked_bracket_pair(*x.data<0>()))
-		return true;
-	return false;
+	return is_naked_bracket_pair(x) && 1==x.size<0>()
+	    && is_naked_bracket_pair(*x.data<0>());
 }
 
 static bool is_CPP0X_ref_qualifier(const parse_tree& x)
 {
-	if (   robust_token_is_char<'&'>(x)
-		|| robust_token_is_string<2>(x,"&&"))
-		return true;
-	return false;
+	return robust_token_is_char<'&'>(x)
+	    || robust_token_is_string<2>(x,"&&");
 }
 
 // very basic syntax check; defer real parsing to later



From zaimoni at mail.berlios.de  Sat Oct 30 11:24:13 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 30 Oct 2010 11:24:13 +0200
Subject: [Zcplusplus-commits] r517 - in trunk: . tools
Message-ID: <20101030092413.76654480E99@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-30 11:24:13 +0200 (Sat, 30 Oct 2010)
New Revision: 517

Added:
   trunk/tools/POSIX.inc
Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc_pp.cpp
   trunk/POSIX.dep
Log:
build system adjust

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2010-10-30 09:12:34 UTC (rev 516)
+++ trunk/CPreproc.cpp	2010-10-30 09:24:13 UTC (rev 517)
@@ -1,10 +1,7 @@
 // CPreproc.cpp
 // (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
-#/*cut-cpp*/
 #include "CPreproc.hpp"
-#/*cut-cpp*/
-#include "CPreproc_pp.hpp"
 
 #include <limits.h>
 #include <time.h>
@@ -12,11 +9,8 @@
 #include <unistd.h>
 
 #include "AtomicString.h"
-#/*cut-cpp*/
 #include "CSupport.hpp"
 #include "_CSupport3.hpp"
-#/*cut-cpp*/
-#include "CSupport_pp.hpp"
 #include "C_PPDecimalInteger.hpp"
 #include "CPUInfo.hpp"
 #include "errors.hpp"
@@ -352,7 +346,6 @@
 
 #define PRAGMA_ZCC_LOCK 0
 #define PRAGMA_ZCC_ENABLE_TYPEID 1
-#/*cut-cpp*/
 
 const POD_pair<const char*,size_t> pragma_relay_keywords[]
 	=	{	DICT_STRUCT("_ZCC_FP_CONTRACT_OFF"),
@@ -368,7 +361,6 @@
 		};
 
 BOOST_STATIC_ASSERT(PRAGMA_RELAY_KEYWORDS_STRICT_UB==STATIC_SIZE(pragma_relay_keywords));		
-#/*cut-cpp*/
 #undef DICT_STRUCT
 
 static void _init_weak_token(weak_token& dest, const Token<char>& x,const POD_triple<size_t,size_t,lex_flags>& pretoken)
@@ -1420,25 +1412,19 @@
 					if (PP::PRAGMA==directive_type)
 						{
 						const size_t critical_offset = valid_directives[directive_type].second+2;
-#/*cut-cpp*/
 						const unsigned int pragma_code =
-#/*cut-cpp*/
 						interpret_pragma(TokenList[i]->data()+critical_offset,TokenList[i]->size()-critical_offset,locked_macros);
-#/*cut-cpp*/
 						switch(pragma_code)
 						{
 						default:
-#/*cut-cpp*/
 						TokenList.DeleteIdx(i);
 						if (0==i) goto Restart;
 						--i;
 						continue;
-#/*cut-cpp*/
 						case RELAY_ZCC_ENABLE_TYPEID+1:
 							TokenList[i]->replace_once(0,TokenList[i]->size(),pragma_relay_keywords[pragma_code-1].first,pragma_relay_keywords[pragma_code-1].second);
 							continue;
 						}
-#/*cut-cpp*/
 						}
 					}
 				}
@@ -1684,11 +1670,8 @@
 						{	//! \test Pass_pragma_STDC.hpp
 						autovalarray_ptr_throws<char> pragma_string(lang.UnescapeStringLength(TokenList[i+2]->data()+1,TokenList[i+2]->size()-2));
 						lang.UnescapeString(pragma_string.c_array(),TokenList[i+2]->data()+1,TokenList[i+2]->size()-2);
-#/*cut-cpp*/
 						const unsigned int pragma_code =
-#/*cut-cpp*/
 						interpret_pragma(pragma_string.data(),pragma_string.size(),locked_macros);
-#/*cut-cpp*/
 						switch(pragma_code)
 						{
 						case RELAY_ZCC_ENABLE_TYPEID+1:
@@ -1696,7 +1679,6 @@
 							TokenList.DeleteNSlotsAt(3,i+1);
 							continue;
 						}
-#/*cut-cpp*/
 						};
 					TokenList.DeleteNSlotsAt(4,i);
 					if (0==i) goto Restart;
@@ -2184,13 +2166,10 @@
 		{
 		if (1<pretokenized.size())
 			{
-#/*cut-cpp*/
 			BOOST_STATIC_ASSERT(RELAY_ZCC_ENABLE_TYPEID==STATIC_SIZE(pragma_STDC_on_off_switch)*STATIC_SIZE(pragma_STDC_keywords));
-#/*cut-cpp*/
 			const errr ZCC_pragma =  linear_find_lencached(x+pretokenized[1].first, pretokenized[1].second, pragma_ZCC_keywords, STATIC_SIZE(pragma_ZCC_keywords));
 			switch(ZCC_pragma)
 			{
-#/*cut-cpp*/
 			// #pragma ZCC enable_typeid gets rewritten to the 
 			// reserved-to-the-implementation keyword 
 			// _ZCC_pragma_enable_typeid, which in turn turns off the syntax
@@ -2198,7 +2177,6 @@
 			// instantly break other compilers inadvertently using our 
 			// #include <typeinfo>
 			case PRAGMA_ZCC_ENABLE_TYPEID: return STATIC_SIZE(pragma_STDC_on_off_switch)*STATIC_SIZE(pragma_STDC_keywords)+1;				
-#/*cut-cpp*/
 			case PRAGMA_ZCC_LOCK:
 				{	//! \test Error_undef_locked_macro.hpp
 				size_t j = pretokenized.size();
@@ -4297,10 +4275,8 @@
 // Macro names beginning with __STDC_ are reserved for future standardization.
 //! \bug should have positive test suite for named __STDC_ macros
 	if (7<=x_len && !strncmp(x,"__STDC_",sizeof("__STDC_")-1)) return true;
-#/*cut-cpp*/
 // Lock down our relay identifiers. to be safe
 	if (0<=linear_find_lencached(x,x_len,pragma_relay_keywords,STATIC_SIZE(pragma_relay_keywords))) return true;
-#/*cut-cpp*/
 // C++0x 17.4.3.2.2 simply prohibits all keywords as macros; prefer this to C++98.  C99/C0X is handled elsewhere, as it isn't so draconian.
 // follow C++0x when generalizing to non-standard languages, as that's more intuitive.
 	if (Lang::C!=lang_code && 0<=linear_find_lencached(x,x_len,lang.InvariantKeywords,lang.len_InvariantKeywords)) return true;
@@ -4807,3 +4783,4 @@
 C++98 17.3.3.1.1p1 prohibits undefining any macro defined in a library header (watch out for assert.h)
 C99 7.1.3p1,3 prohibit defining macros for any identifier declared in a library header
  */
+

Modified: trunk/CPreproc_pp.cpp
===================================================================
--- trunk/CPreproc_pp.cpp	2010-10-30 09:12:34 UTC (rev 516)
+++ trunk/CPreproc_pp.cpp	2010-10-30 09:24:13 UTC (rev 517)
@@ -18,7 +18,7 @@
 #include "langroute.hpp"
 #include "load_src.hpp"
 #include "ParseTree.hpp"
-#include "type_system.hpp"
+#include "type_system_pp.hpp"
 #include "weak_token.hpp"
 #include "_version.h"
 #include "Zaimoni.STL/POD.hpp"
@@ -4741,3 +4741,4 @@
 C++98 17.3.3.1.1p1 prohibits undefining any macro defined in a library header (watch out for assert.h)
 C99 7.1.3p1,3 prohibit defining macros for any identifier declared in a library header
  */
+

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-10-30 09:12:34 UTC (rev 516)
+++ trunk/POSIX.dep	2010-10-30 09:24:13 UTC (rev 517)
@@ -32,11 +32,11 @@
 end_lc.o: end_lc.hpp Zaimoni.STL/MetaRAM2.hpp errors.hpp errcount.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 end_nl.o: end_nl.hpp Zaimoni.STL/MetaRAM2.hpp errors.hpp errcount.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp end_nl.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/stdio_c.h Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
-CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operat
 or.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system_pp.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/lo
 gic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h type_system.hpp Zaimoni.STL/Perl_localize.hpp
 type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 CSupport.o: CSupport.hpp _CSupport3.hpp _CSupport4.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp kleene_star.hpp cond_act.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_l
 t.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
-CPreproc.o: CPreproc.hpp CPreproc_pp.hpp AtomicString.h CSupport.hpp _CSupport3.hpp CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/lo
 gic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp _CSupport3.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/
 operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 ZParser.o: ZParser.hpp CSupport.hpp _CSupport3.hpp _CSupport4.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/search.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/Perl_localize.hpp Zaimoni.STL/POD.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h weak_token.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/LexParse/MetaToken.hpp

Added: trunk/tools/POSIX.inc
===================================================================
--- trunk/tools/POSIX.inc	                        (rev 0)
+++ trunk/tools/POSIX.inc	2010-10-30 09:24:13 UTC (rev 517)
@@ -0,0 +1,90 @@
+# GNU compatibility core
+srcdir = /CPP_App/Z.C++
+prefix = /CPP_App/Z.C++
+exec_prefix = $(prefix)
+bindir = $(exec_prefix)/bin
+includedir = $(exec_prefix)/include
+libdir = $(exec_prefix)/lib
+
+AR = ar
+CC = gcc
+CXX = g++
+
+EXEEXT = exe
+OBJEXT = o
+
+CFLAGS = -fargument-alias -finline -Os -Wall -Wno-long-long --pedantic
+CXXFLAGS =
+ARCH_FLAGS = -mconsole -mno-cygwin -march=pentium -mtune=pentium3
+LINK_FLAGS = 
+
+OTHER_INCLUDEDIR = -I /MingWin.aux/Headers.lib
+C_MACROS = 
+CXX_MACROS = -D__STDC_LIMIT_MACROS
+
+# build rules
+PYTHON = c:\Python26\python
+SELECTIVE_CUT = tools\selective_cut.py
+SUPPRESS_CUT = tools\suppress_cut.py
+
+CPreproc_pp.hpp: CPreproc.hpp
+	$(PYTHON) $(SELECTIVE_CUT) cpp CPreproc.hpp CPreproc_pp.hpp.alt 
+	if cmp -s CPreproc_pp.hpp CPreproc_pp.hpp.alt; then rm CPreproc_pp.hpp.alt ; else mv CPreproc_pp.hpp.alt CPreproc_pp.hpp; fi
+
+CPreproc_pp.cpp: CPreproc.cpp.in
+	$(PYTHON) $(SELECTIVE_CUT) cpp CPreproc.cpp.in CPreproc_pp.cpp.alt2 
+	$(PYTHON) $(SUPPRESS_CUT) nocpp CPreproc_pp.cpp.alt2 CPreproc_pp.cpp.alt 
+	if cmp -s CPreproc_pp.cpp CPreproc_pp.cpp.alt; then rm CPreproc_pp.cpp.alt ; else mv CPreproc_pp.cpp.alt CPreproc_pp.cpp; fi
+	rm CPreproc_pp.cpp.alt2
+
+CPreproc.cpp: CPreproc.cpp.in
+	$(PYTHON) $(SUPPRESS_CUT) cpp CPreproc.cpp.in CPreproc.cpp.alt2 
+	$(PYTHON) $(SELECTIVE_CUT) nocpp CPreproc.cpp.alt2 CPreproc.cpp.alt 
+	if cmp -s CPreproc.cpp CPreproc.cpp.alt; then rm CPreproc.cpp.alt ; else mv CPreproc.cpp.alt CPreproc.cpp; fi
+	rm CPreproc.cpp.alt2
+	
+CPreproc_autogen_pp.cpp: CPreproc_autogen.cpp
+	$(PYTHON) $(SELECTIVE_CUT) cpp CPreproc_autogen.cpp CPreproc_autogen_pp.cpp.alt 
+	if cmp -s CPreproc_autogen_pp.cpp CPreproc_autogen_pp.cpp.alt; then rm CPreproc_autogen_pp.cpp.alt ; else mv CPreproc_autogen_pp.cpp.alt CPreproc_autogen_pp.cpp; fi
+
+CSupport_pp.hpp: CSupport.hpp
+	$(PYTHON) $(SELECTIVE_CUT) cpp CSupport.hpp CSupport_pp.hpp.alt 
+	if cmp -s CSupport_pp.hpp CSupport_pp.hpp.alt; then rm CSupport_pp.hpp.alt ; else mv CSupport_pp.hpp.alt CSupport_pp.hpp; fi
+
+CSupport_pp.cpp: CSupport.cpp.in
+	$(PYTHON) $(SELECTIVE_CUT) cpp CSupport.cpp.in CSupport_pp.cpp.alt2 
+	$(PYTHON) $(SUPPRESS_CUT) nocpp CSupport_pp.cpp.alt2 CSupport_pp.cpp.alt 
+	if cmp -s CSupport_pp.cpp CSupport_pp.cpp.alt; then rm CSupport_pp.cpp.alt ; else mv CSupport_pp.cpp.alt CSupport_pp.cpp; fi
+	rm CSupport_pp.cpp.alt2
+
+CSupport.cpp: CSupport.cpp.in
+	$(PYTHON) $(SUPPRESS_CUT) cpp CSupport.cpp.in CSupport.cpp.alt2 
+	$(PYTHON) $(SELECTIVE_CUT) nocpp CSupport.cpp.alt2 CSupport.cpp.alt 
+	if cmp -s CSupport.cpp CSupport.cpp.alt; then rm CSupport.cpp.alt ; else mv CSupport.cpp.alt CSupport.cpp; fi
+	rm CSupport.cpp.alt2
+	
+type_system_pp.hpp: type_system.hpp.in
+	$(PYTHON) $(SELECTIVE_CUT) cpp type_system.hpp.in type_system_pp.hpp.alt2 
+	$(PYTHON) $(SUPPRESS_CUT) nocpp type_system_pp.hpp.alt2 type_system_pp.hpp.alt 
+	if cmp -s type_system_pp.hpp type_system_pp.hpp.alt; then rm type_system_pp.hpp.alt ; else mv type_system_pp.hpp.alt type_system_pp.hpp; fi
+	rm type_system_pp.hpp.alt2
+
+type_system.hpp: type_system.hpp.in
+	$(PYTHON) $(SUPPRESS_CUT) cpp type_system.hpp.in type_system.hpp.alt2 
+	$(PYTHON) $(SELECTIVE_CUT) nocpp type_system.hpp.alt2 type_system.hpp.alt 
+	if cmp -s type_system.hpp type_system.hpp.alt; then rm type_system.hpp.alt ; else mv type_system.hpp.alt type_system.hpp; fi
+	rm type_system.hpp.alt2
+
+type_system_pp.cpp: type_system.cpp.in
+	$(PYTHON) $(SELECTIVE_CUT) cpp type_system.cpp.in type_system_pp.cpp.alt2 
+	$(PYTHON) $(SUPPRESS_CUT) nocpp type_system_pp.cpp.alt2 type_system_pp.cpp.alt 
+	if cmp -s type_system_pp.cpp type_system_pp.cpp.alt; then rm type_system_pp.cpp.alt ; else mv type_system_pp.cpp.alt type_system_pp.cpp; fi
+	rm type_system_pp.cpp.alt2
+
+type_system.cpp: type_system.cpp.in
+	$(PYTHON) $(SUPPRESS_CUT) cpp type_system.cpp.in type_system.cpp.alt2 
+	$(PYTHON) $(SELECTIVE_CUT) nocpp type_system.cpp.alt2 type_system.cpp.alt 
+	if cmp -s type_system.cpp type_system.cpp.alt; then rm type_system.cpp.alt ; else mv type_system.cpp.alt type_system.cpp; fi
+	rm type_system.cpp.alt2
+
+



From zaimoni at mail.berlios.de  Sat Oct 30 11:25:23 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 30 Oct 2010 11:25:23 +0200
Subject: [Zcplusplus-commits] r518 - trunk
Message-ID: <20101030092523.3B6C0480E99@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-30 11:25:23 +0200 (Sat, 30 Oct 2010)
New Revision: 518

Added:
   trunk/CPreproc.cpp.in
Log:
build system adjust

Added: trunk/CPreproc.cpp.in
===================================================================
--- trunk/CPreproc.cpp.in	                        (rev 0)
+++ trunk/CPreproc.cpp.in	2010-10-30 09:25:23 UTC (rev 518)
@@ -0,0 +1,6122 @@
+// CPreproc.cpp
+// (C)2009,2010 Kenneth Boyd, license: MIT.txt
+
+#/*cut-cpp*/
+#include "CPreproc.hpp"
+#/*cut-cpp*/
+#/*cut-nocpp*/
+#include "CPreproc_pp.hpp"
+#/*cut-nocpp*/
+
+#include <limits.h>
+#include <time.h>
+#include <stdexcept>
+#include <unistd.h>
+
+#include "AtomicString.h"
+#/*cut-cpp*/
+#include "CSupport.hpp"
+#include "_CSupport3.hpp"
+#/*cut-cpp*/
+#/*cut-nocpp*/
+#include "CSupport_pp.hpp"
+#/*cut-nocpp*/
+#include "C_PPDecimalInteger.hpp"
+#include "CPUInfo.hpp"
+#include "errors.hpp"
+#include "errcount.hpp"
+#include "filesystem.h"
+#include "langroute.hpp"
+#include "load_src.hpp"
+#include "ParseTree.hpp"
+#/*cut-cpp*/
+#include "type_system.hpp"
+#/*cut-cpp*/
+#/*cut-nocpp*/
+#include "type_system_pp.hpp"
+#/*cut-nocpp*/
+#include "weak_token.hpp"
+#include "_version.h"
+#include "Zaimoni.STL/POD.hpp"
+#include "Zaimoni.STL/LexParse/Token.hpp"
+#include "Zaimoni.STL/LexParse/LangConf.hpp"
+#include "Zaimoni.STL/search.hpp"
+#include "Zaimoni.STL/OS/mutex.hpp"
+#include "Zaimoni.STL/Pure.C/format_util.h"
+
+#include "DebugCSupport.h"
+
+using namespace zaimoni;
+
+// beginning of multilingual support
+#define ERR_STR "error: "
+#define WARN_STR "warning: "
+
+#define INSTALL_TO "\\CPP_App\\Z.C++"
+
+//! \todo this should be language-sensitive; LangConf not a good location
+static const char* const fixed_system_include_search[] = {
+	// C++-only install paths
+	INSTALL_TO ZAIMONI_PATH_SEP "lib" ZAIMONI_PATH_SEP "zc++-" ZCC_VERSION ZAIMONI_PATH_SEP "include",
+	INSTALL_TO ZAIMONI_PATH_SEP "lib" ZAIMONI_PATH_SEP "zc++" ZAIMONI_PATH_SEP "include",
+	// C++-only relative paths
+	".." ZAIMONI_PATH_SEP "lib" ZAIMONI_PATH_SEP "zc++-" ZCC_VERSION ZAIMONI_PATH_SEP "include",
+	".." ZAIMONI_PATH_SEP "lib" ZAIMONI_PATH_SEP "zc++" ZAIMONI_PATH_SEP "include",
+	// install path
+	INSTALL_TO ZAIMONI_PATH_SEP "lib" ZAIMONI_PATH_SEP "zcc-" ZCC_VERSION ZAIMONI_PATH_SEP "include",
+	INSTALL_TO ZAIMONI_PATH_SEP "lib" ZAIMONI_PATH_SEP "zcc" ZAIMONI_PATH_SEP "include",
+	INSTALL_TO ZAIMONI_PATH_SEP "include",
+	// relative paths
+	".." ZAIMONI_PATH_SEP "lib" ZAIMONI_PATH_SEP "zcc-" ZCC_VERSION ZAIMONI_PATH_SEP "include",
+	".." ZAIMONI_PATH_SEP "lib" ZAIMONI_PATH_SEP "zcc" ZAIMONI_PATH_SEP "include",
+	".." ZAIMONI_PATH_SEP "include"
+};
+
+static const char* actual_system_include_search[] =	{
+	// C++-only install paths
+	NULL,
+	NULL,
+	// C++-only relative paths
+	NULL,
+	NULL,
+	// install path
+	NULL,
+	NULL,
+	NULL,
+	// relative paths
+	NULL,
+	NULL,
+	NULL
+};
+
+BOOST_STATIC_ASSERT(STATIC_SIZE(fixed_system_include_search)==STATIC_SIZE(actual_system_include_search));
+
+#define START_CPP_ONLY_PATHS 4
+
+#undef INSTALL_TO
+
+static bool fixed_system_include_exists_init = false;
+
+static void init_fixed_system_include_search(void)
+{
+	if (fixed_system_include_exists_init) return;
+	char filepath[FILENAME_MAX];
+	char workpath[FILENAME_MAX];
+	size_t i = STATIC_SIZE(fixed_system_include_search);
+	do	{
+		--i;
+		assert(!is_empty_string(fixed_system_include_search[i]));
+		if ('.'==fixed_system_include_search[i][0] && FILENAME_MAX>strlen(self_path)+strlen(fixed_system_include_search[i])+1)
+			{	// obviously relative path
+			z_dirname(workpath,self_path);
+			strcat(workpath,ZAIMONI_PATH_SEP);
+			strcat(workpath,fixed_system_include_search[i]);
+			char* exists = z_realpath(filepath,workpath);
+			if (exists && !access(exists,F_OK))
+				actual_system_include_search[i] = register_string(filepath);
+			}
+		else if (ZAIMONI_PATH_SEP[0]==fixed_system_include_search[i][0])
+			{	// absolute path, current drive
+			char* exists = z_realpath(filepath,fixed_system_include_search[i]);
+			if (exists && !access(exists,F_OK))
+				actual_system_include_search[i] = register_string(filepath);
+			};
+		}
+	while(0<i);
+}
+
+#define LEXER_STRICT_UB (Lexer::CPlusPlus+1)
+
+/* C99
+1 The following macro names151) shall be defined by the implementation:
+_ _DATE_ _ The date of translation of the preprocessing translation unit: a character
+string literal of the form "Mmm dd yyyy", where the names of the
+months are the same as those generated by the asctime function, and the
+first character of dd is a space character if the value is less than 10. If the
+date of translation is not available, an implementation-defined valid date
+shall be supplied.
+_ _FILE_ _ The presumed name of the current source file (a character string literal).152)
+_ _LINE_ _ The presumed line number (within the current source file) of the current
+source line (an integer constant).152)
+_ _STDC_ _ The integer constant 1, intended to indicate a conforming implementation.
+_ _STDC_HOSTED_ _ The integer constant 1 if the implementation is a hosted
+implementation or the integer constant 0 if it is not.
+_ _STDC_VERSION_ _ The integer constant 199901L.153)
+_ _TIME_ _ The time of translation of the preprocessing translation unit: a character
+string literal of the form "hh:mm:ss" as in the time generated by the
+asctime function. If the time of translation is not available, an
+implementation-defined valid time shall be supplied.
+2 The following macro names are conditionally defined by the implementation:
+_ _STDC_IEC_559_ _ The integer constant 1, intended to indicate conformance to the
+specifications in annex F (IEC 60559 floating-point arithmetic).
+
+_ _STDC_IEC_559_COMPLEX_ _ The integer constant 1, intended to indicate
+adherence to the specifications in informative annex G (IEC 60559
+compatible complex arithmetic).
+_ _STDC_ISO_10646_ _ An integer constant of the form yyyymmL (for example,
+199712L). If this symbol is defined, then every character in the Unicode
+required set, when stored in an object of type wchar_t, has the same
+value as the short identifier of that character. The Unicode required set
+consists of all the characters that are defined by ISO/IEC 10646, along with
+all amendments and technical corrigenda, as of the specified year and
+month.
+3 The values of the predefined macros (except for _ _FILE_ _ and _ _LINE_ _) remain
+constant throughout the translation unit.
+4 None of these macro names, nor the identifier defined, shall be the subject of a
+#define or a #undef preprocessing directive. Any other predefined macro names
+shall begin with a leading underscore followed by an uppercase letter or a second
+underscore.
+5 The implementation shall not predefine the macro _ _cplusplus, nor shall it define it
+in any standard header.
+*/
+
+/* C++0x
+1 The following macro names shall be defined by the implementation:
+_ _ cplusplus
+The name _ _ cplusplus is defined to the value [tbd] when compiling a C++ translation unit.146)
+_ _ DATE _ _
+The date of translation of the source file (a character string literal of the form "Mmm dd yyyy", where the names
+of the months are the same as those generated by the asctime function, and the first character of dd is a space
+character if the value is less than 10). If the date of translation is not available, an implementation-defined valid
+date is supplied.
+_ _ FILE _ _
+The presumed name of the source file (a character string literal).
+_ _ LINE _ _
+The line number of the current source line (a decimal constant).
+_ _ STDC_HOSTED _ _
+The integer constant 1 if the implementation is a hosted implementation or the integer constant 0 if it is not.
+_ _ TIME _ _
+The time of translation of the source file (a character string literal of the form "hh:mm:ss" as in the time generated
+by the asctime function). If the time of translation is not available, an implementation-defined valid time is
+supplied.
+2 The following macro names are conditionally defined by the implementation:
+_ _ STDC _ _
+Whether _ _ STDC _ _ is predefined and if so, what its value is, are implementation-defined.
+
+_ _ STDC_VERSION _ _
+Whether _ _ STDC_VERSION _ _ is predefined and if so, what its value is, are implementation-defined.
+_ _ STDC_ISO_10646 _ _
+An integer constant of the form yyyymmL (for example, 199712L), intended to indicate that values of type
+wchar_t are the coded representations of the characters defined by ISO/IEC 10646, along with all amendments
+and technical corrigenda as of the specified year and month.
+
+3 The values of the predefined macros (except for _ _ LINE _ _ and _ _ FILE _ _) remain constant throughout the translation
+unit.
+4 If any of the pre-defined macro names in this subclause, or the identifier defined, is the subject of a #define or
+a #undef preprocessing directive, the behavior is undefined. Any other predefined macro names shall begin with a
+leading underscore followed by an uppercase letter or a second underscore.
+*/
+
+#define DICT_STRUCT(A) { (A), sizeof(A)-1 }
+
+// design decision: make this consistent across both C, C++
+// design decision: make this consistent across all versions of C, C++
+static const POD_pair<const char*,size_t> C99_CPP0x_locked_macros_default[]
+ =	{	DICT_STRUCT("__DATE__"),				// determine in realtime at start of translation
+		DICT_STRUCT("__TIME__"),				// determine in realtime at start of translation
+		DICT_STRUCT("__FILE__"),				// special handling
+		DICT_STRUCT("__LINE__"),				// special handling
+		DICT_STRUCT("__VA_ARGS__"),				// disallowed as identifier anywhere except variadic function macro replacement list, C99/C++0x
+		// __STDC_ macros are locked anyway, as they are reserved by the C/C++ standards
+//		DICT_STRUCT("__STDC__"),				// define to 1 for both (GCC, note that K&R prototype-compatibility code uses this)
+//		DICT_STRUCT("__STDC_HOSTED__"),			// define to 1 for now
+//		DICT_STRUCT("__STDC_VERSION__"),		// define to 1 for now (as we don't really implement much of anything yet)
+//		DICT_STRUCT("__STDC_IEC_559__"),		// undefined
+//		DICT_STRUCT("__STDC_IEC_559_COMPLEX__"),// mentioned in C99 only; undefined
+//		DICT_STRUCT("__STDC_IEC_10646__"),		// mentioned in C99 only; undefined
+		DICT_STRUCT("__cplusplus"),				// undefined/C99, define to 1 for C++0x
+		DICT_STRUCT("defined"),					// must be undefined or else undefined behavior, even not considering C99 6.10.8 p4
+		DICT_STRUCT("_Pragma"),					// considering the syntactical role of the _Pragma operator, lock it even though the standards don't require us to. 
+		DICT_STRUCT("__TIMESTAMP__"),			// lock down our extension macros
+		DICT_STRUCT("__COUNTER__"),				// lock down our extension macros
+		DICT_STRUCT("__INCLUDE_LEVEL__"),		// lock down our extension macros
+		DICT_STRUCT("__has_include"),			// lock down our extension macros
+		DICT_STRUCT("__ZCC__"),					// lock down our identity
+		DICT_STRUCT("__ZCC_MINOR__"),			// lock down our identity
+		DICT_STRUCT("__ZCC_PATCHLEVEL__")		// lock down our identity
+	};
+
+static const POD_pair<const char*,const char*> C99_macro_identifier_default[]
+ =	{	{"__DATE__", NULL},			// start standard-mandated macros
+		{"__TIME__", NULL},
+		{"__FILE__", NULL},
+		{"__LINE__", NULL},
+		{"__STDC__", "1"},
+		{"__STDC_HOSTED__", "1"},
+		{"__STDC_VERSION__", "1"},		// end standard-mandated macros
+		{"__TIMESTAMP__", NULL},		// extension: GCC, CLang, MSVC
+		{"__COUNTER__", NULL},			// extension: GCC, CLang, MSVC
+		{"__INCLUDE_LEVEL__", NULL},	// extension: GCC, CLang
+		{"__ZCC__", DEEP_STRINGIZE(ZCC_VERSION_MAJOR)},				// identity : major version
+		{"__ZCC_MINOR__", DEEP_STRINGIZE(ZCC_VERSION_MINOR)},		// minor version
+		{"__ZCC_PATCHLEVEL__", DEEP_STRINGIZE(ZCC_VERSION_PATCH)}	// patchlevel
+	};
+
+static const POD_pair<const char*,const char*> CPP0x_macro_identifier_default[]
+ =	{	{"__TIMESTAMP__", NULL},		// extension: GCC, CLang, MSVC
+		{"__COUNTER__", NULL},			// extension: GCC, CLang, MSVC
+		{"__INCLUDE_LEVEL__", NULL},	// extension: GCC, CLang
+		{"__DATE__", NULL},			// start standard-mandated macros
+		{"__TIME__", NULL},
+		{"__FILE__", NULL},
+		{"__LINE__", NULL},
+		{"__STDC__", "1"},
+		{"__STDC_HOSTED__", "1"},
+		{"__STDC_VERSION__", "1"},
+		{"__cplusplus", "1"},		// end standard-mandated macros
+		{"__ZCC__", DEEP_STRINGIZE(ZCC_VERSION_MAJOR)},				// identity : major version
+		{"__ZCC_MINOR__", DEEP_STRINGIZE(ZCC_VERSION_MINOR)},		// minor version
+		{"__ZCC_PATCHLEVEL__", DEEP_STRINGIZE(ZCC_VERSION_PATCH)}	// patchlevel
+	};
+
+CPreprocessor::CPreprocessor(const virtual_machine::CPUInfo& _target_machine, const char* const _lang)
+:	counter_macro(0),
+	include_level(0),
+	lang_code(lang_index(_lang)),
+	lang(lexer_from_lang(lang_code)),
+	target_machine(_target_machine),
+	macro_identifier_default(NULL),
+	macro_locked_default(C99_CPP0x_locked_macros_default),
+	macro_identifier_default_count(0),
+	macro_locked_default_count(STATIC_SIZE(C99_CPP0x_locked_macros_default)),
+	debug_mode(false)
+{
+	switch(lang_code)
+	{
+	case Lang::C: {
+			macro_identifier_default = C99_macro_identifier_default;
+			macro_identifier_default_count = STATIC_SIZE(C99_macro_identifier_default);
+			break;
+		};
+	case Lang::CPlusPlus: {
+			macro_identifier_default = CPP0x_macro_identifier_default;
+			macro_identifier_default_count = STATIC_SIZE(CPP0x_macro_identifier_default);
+			break;
+		};
+	default: FATAL("Invalid language code");
+	}
+	init_fixed_system_include_search();
+	// reality checks on the language
+	assert(NULL!=lang.EscapeStringLength);
+	assert(NULL!=lang.EscapeString);
+	assert(NULL!=lang.UnescapeStringLength);
+	assert(NULL!=lang.UnescapeString);
+	assert(NULL!=lang.pp_support);
+	assert(NULL!=lang.InvariantKeywords);
+	assert(0<lang.len_InvariantKeywords);
+}
+
+static const POD_pair<const char*,size_t> valid_directives[]
+	=	{	DICT_STRUCT("if"),
+			DICT_STRUCT("ifdef"),
+			DICT_STRUCT("ifndef"),
+			DICT_STRUCT("elif"),
+			DICT_STRUCT("else"),
+			DICT_STRUCT("endif"),
+			DICT_STRUCT("include"),
+			DICT_STRUCT("define"),
+			DICT_STRUCT("undef"),
+			DICT_STRUCT("line"),
+			DICT_STRUCT("error"),
+			DICT_STRUCT("pragma")
+		};
+
+static const POD_pair<const char*,size_t> accept_pragma_leading_tokens[]
+	=	{	DICT_STRUCT("STDC"),	// C99
+			DICT_STRUCT("ZCC"),		// our own
+			DICT_STRUCT("GCC"),		// we also pay attention to GCC pragmas
+			DICT_STRUCT("message")	// #pragma message("...")
+		};
+
+// yes, enum would be better style
+#define PRAGMA_LEADING_STDC 0
+#define PRAGMA_LEADING_ZCC 1
+// #define PRAGMA_LEADING_GCC 2
+#define PRAGMA_MESSAGE 3
+
+static const POD_pair<const char*,size_t> pragma_STDC_on_off_switch[]	// C99 6.10.5p2
+	=	{	DICT_STRUCT("OFF"),
+			DICT_STRUCT("DEFAULT"),
+			DICT_STRUCT("ON")
+		};
+
+#define ON_OFF_SWITCH_OFF 0
+#define ON_OFF_SWITCH_DEFAULT 1
+#define ON_OFF_SWITCH_ON 2
+
+static const POD_pair<const char*,size_t> pragma_STDC_keywords[]
+	=	{	DICT_STRUCT("FP_CONTRACT"),
+			DICT_STRUCT("FENV_ACCESS"),
+			DICT_STRUCT("CX_LIMITED_RANGE")
+		};
+
+#define PRAGMA_STDC_FP_CONTRACT 0
+#define PRAGMA_STDC_FENV_ACCESS 1
+#define PRAGMA_STDC_CX_LIMITED_RANGE 2
+
+static const POD_pair<const char*,size_t> pragma_ZCC_keywords[]
+	=	{	DICT_STRUCT("lock"),
+			DICT_STRUCT("enable_typeid")
+		};
+
+#define PRAGMA_ZCC_LOCK 0
+#define PRAGMA_ZCC_ENABLE_TYPEID 1
+#/*cut-cpp*/
+
+const POD_pair<const char*,size_t> pragma_relay_keywords[]
+	=	{	DICT_STRUCT("_ZCC_FP_CONTRACT_OFF"),
+			DICT_STRUCT("_ZCC_FP_CONTRACT_DEFAULT"),
+			DICT_STRUCT("_ZCC_FP_CONTRACT_ON"),
+			DICT_STRUCT("_ZCC_FENV_ACCESS_OFF"),
+			DICT_STRUCT("_ZCC_FENV_ACCESS_DEFAULT"),
+			DICT_STRUCT("_ZCC_FENV_ACCESS_ON"),
+			DICT_STRUCT("_ZCC_CX_LIMITED_RANGE_OFF"),
+			DICT_STRUCT("_ZCC_CX_LIMITED_RANGE_DEFAULT"),
+			DICT_STRUCT("_ZCC_CX_LIMITED_RANGE_ON"),
+			DICT_STRUCT("_ZCC_enable_typeid")
+		};
+
+BOOST_STATIC_ASSERT(PRAGMA_RELAY_KEYWORDS_STRICT_UB==STATIC_SIZE(pragma_relay_keywords));		
+#/*cut-cpp*/
+#undef DICT_STRUCT
+
+static void _init_weak_token(weak_token& dest, const Token<char>& x,const POD_triple<size_t,size_t,lex_flags>& pretoken)
+{
+	dest.token.first = x.data()+pretoken.first;
+	dest.token.second = pretoken.second;
+	dest.flags = pretoken.third;
+	dest.logical_line.first = x.original_line.first;
+	dest.logical_line.second = x.original_line.second+pretoken.first;
+	dest.src_filename = x.src_filename;
+}
+
+static void _weak_tokenize_aux(const Token<char>& x,const autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized, autovalarray_ptr<weak_token>& weaktoken_list)
+{
+	assert(!x.empty());
+	assert(!pretokenized.empty());
+	weaktoken_list.resize(pretokenized.size());
+	size_t j = pretokenized.size();
+	do	{
+		--j;
+		_init_weak_token(weaktoken_list[j],x,pretokenized[j]);
+		}
+	while(0<j);
+}
+
+static void _parsetreeize_aux(const Token<char>& x,const autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized, parse_tree& parsetree)
+{
+	assert(!x.empty());
+	assert(!pretokenized.empty());
+	if (1==pretokenized.size())
+		{
+		_init_weak_token(parsetree.index_tokens[0],x,pretokenized.front());
+		return;
+		}
+	if (!parsetree.resize<0>(pretokenized.size())) throw std::bad_alloc();
+	size_t j = pretokenized.size();
+	do	{
+		--j;
+		_init_weak_token(parsetree.c_array<0>()[j].index_tokens[0],x,pretokenized[j]);
+		}
+	while(0<j);
+}
+
+static void _flush_duplicated_ws(Token<char>& x, const LangConf& lang)
+{
+	lex_flags scratch_flags;
+	size_t offset2 = lang.UnfilteredNextToken(x.data(),scratch_flags);
+	while(offset2<x.size())
+		{
+		const size_t skip_ws = strspn(x.data()+offset2,lang.WhiteSpace);
+		if (0<skip_ws)
+			{
+			if (skip_ws>=x.size()-offset2)
+				{
+				x.lslice(offset2);
+				return;
+				};
+			if (strchr(lang.AtomicSymbols,x.data()[offset2-1]) || strchr(lang.AtomicSymbols,x.data()[offset2+skip_ws]))
+				x.intradelete(offset2,skip_ws);
+			else{
+				x.replace_once(std::nothrow,offset2,skip_ws,' ');
+				++offset2;
+				}
+			}
+		offset2 += lang.UnfilteredNextToken(x.data()+offset2,scratch_flags);
+		}
+}
+
+template<class IntType,class Iterator>
+void
+STL_translate_first(IntType origin, Iterator iter, const Iterator iter_end)
+{
+	while(iter_end!=iter) (iter++)->first += origin;
+}
+
+template<class IntType,class T>
+inline void STL_translate_first(IntType origin, T& x)
+{
+	assert(!x.empty());
+	STL_translate_first(origin,x.begin(),x.end());
+}
+
+template<class IntType,class Iterator>
+void
+STL_translate_second(IntType origin, Iterator iter, const Iterator iter_end)
+{
+	while(iter_end!=iter) (iter++)->second += origin;
+}
+
+//! \todo use lang.AtomicSymbols to get further compression
+static bool _flush_token_gaps(Token<char>& x, autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized, const LangConf& lang)
+{
+	assert(!x.empty());
+	assert(!pretokenized.empty());
+	bool acted = false;
+	if (x.size()>pretokenized.back().first+pretokenized.back().second)
+		{
+		x.lslice(pretokenized.back().first+pretokenized.back().second);
+		acted = true;
+		};
+	if (1<pretokenized.size())
+		{
+		size_t i = pretokenized.size()-1;
+		bool old_atomic = 1==pretokenized[i].second && strchr(lang.AtomicSymbols,x.data()[pretokenized[i].first]);
+		do	{
+			--i;
+			const bool new_atomic = 1==pretokenized[i].second && strchr(lang.AtomicSymbols,x.data()[pretokenized[i].first]);
+			if (new_atomic || old_atomic)
+				{
+				if (pretokenized[i+1].first>pretokenized[i].first+pretokenized[i].second)
+					{
+					const size_t delta = pretokenized[i+1].first-(pretokenized[i].first+pretokenized[i].second);
+					x.intradelete(pretokenized[i].first+pretokenized[i].second,delta);
+					STL_translate_first(-delta,pretokenized.begin()+i+1,pretokenized.end());	// unsigned modulo arithmetic makes this work
+					acted = true;
+					}
+				}
+			else if (pretokenized[i+1].first-1>pretokenized[i].first+pretokenized[i].second)
+				{
+				const size_t delta = pretokenized[i+1].first-(pretokenized[i].first+pretokenized[i].second)-1;
+				x.replace_once(std::nothrow,pretokenized[i].first+pretokenized[i].second,delta+1,' ');
+				STL_translate_first(-delta,pretokenized.begin()+i+1,pretokenized.end());	// unsigned modulo arithmetic makes this work
+				acted = true;
+				};
+			old_atomic = new_atomic;
+			}
+		while(0<i);
+		}
+	// do *not* remove space before the first token; CPreprocessor::if_elif_syntax_ok will break, as that's where the #if/#elif is
+	return acted;
+}
+
+namespace PP {
+
+enum directive_indexes	{	IF = 0,
+							IFDEF,
+							IFNDEF,
+							ELIF,
+							ELSE,
+							ENDIF,
+							INCLUDE,
+							DEFINE,
+							UNDEF,
+							LINE,
+							ERROR,
+							PRAGMA
+						};
+
+}
+
+#define MAX_PP_DIRECTIVE (PP::PRAGMA+1)
+#define PP_INVALID 15
+
+// we assume that it takes exactly 4 bits to numerically represent the above enum
+// we assume that 15 is available to flag invalid
+BOOST_STATIC_ASSERT((1<<4)>=MAX_PP_DIRECTIVE && ((1<<3)<MAX_PP_DIRECTIVE));
+
+static errr find_directive(const char* const Text, const LangConf& lang)
+{
+	assert(!is_empty_string(Text));
+	size_t i = STATIC_SIZE(valid_directives);
+	do	{
+		--i;
+		if (!strncmp(valid_directives[i].first,Text,valid_directives[i].second)
+			&& (valid_directives[i].second==strlen(Text) || lang.IsWS(Text[valid_directives[i].second])))
+			return i;
+		}
+	while(0<i);
+	return -1;
+}
+
+static void message_header(const Token<char>& src)
+{
+	assert(src.src_filename && *src.src_filename);
+	message_header(src.src_filename,src.logical_line.first);
+}
+
+static void message_header2(const Token<char>& src,size_t where)
+{
+	assert(NULL!=src.src_filename);
+	INC_INFORM(src.src_filename);
+	INC_INFORM(':');
+	INC_INFORM(src.logical_line.first);
+	INC_INFORM('.');
+	INC_INFORM(where);
+	INC_INFORM(": ");
+}
+
+void CPreprocessor::detailed_UNICODE_syntax(Token<char>& x) const
+{
+	assert(!x.empty());
+	const char* UNICODE_escape = strstr(x.data(),"\\U");
+	while(NULL!=UNICODE_escape)
+		{
+		const size_t tail = x.size()-(UNICODE_escape-x.data());
+		if (10U>tail)
+			{	//! \test UNICODE.C99/Error_AstralTruncate.h
+				//! \test UNICODE.C99/Error_AstralTruncate.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INFORM("C99 6.4.3p1/C++98 2.2p2: astral UNICODE escape prematurely terminated by end of line");
+			zcc_errors.inc_error();
+			break;
+			}
+		if (!and_range_n(IsHexadecimalDigit,UNICODE_escape+2,8))
+			{	//! \test UNICODE.C99/Error_AstralNonhex.h
+				//! \test UNICODE.C99/Error_AstralNonhex.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INFORM("C99 6.4.3p1/C++98 2.2p2: astral UNICODE escape contains non-hexadecimal digits");
+			zcc_errors.inc_error();
+			}
+		else
+			assert(4>std::count(UNICODE_escape+2,UNICODE_escape+6,'0'));	// should have caught this in pre-filtration
+		UNICODE_escape = (12U<=tail) ? strstr(UNICODE_escape+10,"\\U") : NULL;
+		};
+	UNICODE_escape = strstr(x.data(),"\\u");
+	while(NULL!=UNICODE_escape)
+		{
+		const size_t tail = x.size()-(UNICODE_escape-x.data());
+		if (6U>tail)
+			{	//! \test UNICODE.C99/Error_Truncate.h
+				//! \test UNICODE.C99/Error_Truncate.hpp
+				//! \test UNICODE.C99/Error_Truncate2.h
+				//! \test UNICODE.C99/Error_Truncate2.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INFORM("UNICODE escape prematurely terminated by end of line (C99 6.4.3p1/C++0x 2.2p2)");
+			zcc_errors.inc_error();
+			break;
+			}
+		if (!and_range_n(IsHexadecimalDigit,UNICODE_escape+2,4))
+			{	//! \test UNICODE.C99/Error_Nonhex.h
+				//! \test UNICODE.C99/Error_Nonhex.hpp
+				//! \test UNICODE.C99/Error_Nonhex2.h
+				//! \test UNICODE.C99/Error_Nonhex2.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INFORM("UNICODE escape contains non-hexadecimal digits (C99 6.4.3p1/C++0x 2.2p2)");
+			zcc_errors.inc_error();
+			}
+		else if ('D'==UNICODE_escape[2] && strchr(list_hexadecimal_digits+8,UNICODE_escape[3]))
+			{	//! \test UNICODE.C99/Error_SZone.h
+				//! \test UNICODE.C99/Error_SZone.hpp
+				//! \test UNICODE.C99/Error_SZone2.h
+				//! \test UNICODE.C99/Error_SZone2.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INFORM("UNICODE escape is in S-zone (D800-DFFF), reserved for UTF-16 (C99 6.4.3p1/C++0x 2.2p2)");
+			zcc_errors.inc_error();
+			}
+		else if (2==std::count(UNICODE_escape+2,UNICODE_escape+4,'0'))
+			{	//! \todo fix assumption that CHAR_BIT==8
+			const unsigned char tmp = (unsigned char)(16*InterpretHexadecimalDigit(UNICODE_escape[4])+InterpretHexadecimalDigit(UNICODE_escape[5]));
+			bool down_convert = true;
+			assert(160U>tmp);	// should have caught this already
+			// C++98 is "anything goes", but don't worry about that for now
+			// C99 and C++0x agree that these are bad
+			if ((unsigned char)(32U)>tmp || ((unsigned char)('\x7F')<=tmp && (unsigned char)('\x9F')>=tmp))
+				{	//! \test UNICODE.C99/Error_CTRL_low.h
+					//! \test UNICODE.C99/Error_CTRL_low.hpp
+					//! \test UNICODE.C99/Error_CTRL_low2.h
+					//! \test UNICODE.C99/Error_CTRL_low2.hpp
+					//! \test UNICODE.C99/Error_CTRL_high.h
+					//! \test UNICODE.C99/Error_CTRL_high.hpp
+					//! \test UNICODE.C99/Error_CTRL_high2.h
+					//! \test UNICODE.C99/Error_CTRL_high2.hpp
+				message_header(x);
+				INC_INFORM(ERR_STR);
+				INFORM("UNICODE escape is in a control character range (C99 6.4.3p1/C++0x 2.2p2)");
+				zcc_errors.inc_error();
+				down_convert = false;
+				}
+			else if (Lang::C==lang_code)
+				{	// C rejects anything escapeish, or in the source character set
+					//! \test UNICODE.C99/Error_Source.h
+					//! \test UNICODE.C99/Error_Source2.h
+				if ('$'!=tmp && '@'!=tmp && '`'!=tmp)	//! \todo deal with ASCII dependence
+					{
+					message_header(x);
+					INC_INFORM(ERR_STR);
+					INFORM("UNICODE escape is in the source character set (C99 6.4.3p1)");
+					zcc_errors.inc_error();
+					down_convert = false;
+					}
+				};
+			if (down_convert)
+				{	//! \test cpp/default/Preprocess_UNICODE_deastral.hpp, cpp/default/Preprocess_UNICODE_deastral.h
+				const size_t offset = UNICODE_escape-x.data();
+				x.replace_once(std::nothrow,offset,6,tmp);
+				UNICODE_escape = (8U<=tail) ? strstr(x.data()+offset+1,"\\u") : NULL;
+				continue;
+				}
+			}
+		UNICODE_escape = (8U<=tail) ? strstr(UNICODE_escape+10,"\\u") : NULL;
+		};
+}
+
+// flags type in Token is unsigned long
+//! \todo consider hooking into POSIX (replace ULONG_BIT with LONG_BIT)
+#define ULONG_BIT (sizeof(unsigned long)*CHAR_BIT)
+#define PREPROCESSING_DIRECTIVE_FLAG (1UL<<(ULONG_BIT-1))
+#define PACK_DIRECTIVE(A,B) {(A) &= ~((15UL)<<(ULONG_BIT-5)); (A) |= ((B)<<(ULONG_BIT-5));}
+#define UNPACK_DIRECTIVE(A) (((A) & ~PREPROCESSING_DIRECTIVE_FLAG)>>(ULONG_BIT-5))
+#define SYNTAX_CHECKED_FLAG (1UL<<(ULONG_BIT-6))
+#define INVALID_DIRECTIVE_FLAG (1UL<<(ULONG_BIT-7))
+
+/*! 
+ * Preprocesses a file with the C preprocessor, using the lexer lang specified at preprocessor construction.
+ * 
+ * \param TokenList : tokens to be preprocessed.
+ * 
+ * \return bool
+ */
+bool CPreprocessor::preprocess(autovalarray_ptr<Token<char>* >& TokenList)
+{
+	autovalarray_ptr<char*> locked_macros;
+	autovalarray_ptr<char*> macros_object;
+	autovalarray_ptr<Token<char>*> macros_object_expansion;
+	autovalarray_ptr<Token<char>*> macros_object_expansion_pre_eval;
+	autovalarray_ptr<char*> macros_function;
+	autovalarray_ptr<Token<char>*> macros_function_arglist;
+	autovalarray_ptr<Token<char>*> macros_function_expansion;
+	autovalarray_ptr<Token<char>*> macros_function_expansion_pre_eval;
+	autovalarray_ptr<POD_triple<const char*, const char*,uintptr_t> > include_file_index;
+	autovalarray_ptr<POD_pair<const char*,autovalarray_ptr<Token<char>*>* > > include_file_cache;
+	const type_system min_types((Lang::C==lang_code) ? C_atomic_types : CPP_atomic_types,(Lang::C==lang_code) ? C_TYPE_MAX : CPP_TYPE_MAX,C_int_priority+C_PP_INT_PRIORITY_ORIGIN,C_INT_PRIORITY_SIZE-C_PP_INT_PRIORITY_ORIGIN);
+
+	// this is subject to the Y10K bug, per standard.
+	// construct __DATE__, __TIME__ macro targets
+	{
+	time_date_buffer[0] = '"';
+	time_buffer[0]='"';
+	date_buffer[0]='"';
+	time_t start_time = time(NULL);
+	strcpy(time_date_buffer+1,ctime(&start_time));
+	strcpy(time_date_buffer+1+24,"\"");
+	// have base buffer, construct time
+	strncpy(time_buffer+1,time_date_buffer+12,8);
+	time_buffer[0]='"';
+	strcpy(time_buffer+9,"\"");
+	// construct date
+	strncpy(date_buffer+1,time_date_buffer+5,7);
+	strncpy(date_buffer+8,time_date_buffer+21,4);
+	date_buffer[0]='"';
+	strcpy(date_buffer+12,"\"");
+	}
+
+	{	// do detailed UNICODE error trapping here: S-zone [\uD800-\uDFFF], sub-\u00A0 processing (latter is language-sensitive), syntax
+	const autovalarray_ptr<Token<char>* >::iterator iter_end = TokenList.end();
+	autovalarray_ptr<Token<char>* >::iterator iter = TokenList.begin();
+	while(iter!=iter_end) detailed_UNICODE_syntax(**iter++);
+	}
+
+	_preprocess(TokenList, locked_macros, macros_object, macros_object_expansion, macros_object_expansion_pre_eval, macros_function, macros_function_arglist, macros_function_expansion, macros_function_expansion_pre_eval, include_file_index, include_file_cache, min_types);
+#/*cut-cpp*/
+#/*cut-nocpp*/
+//	_preprocess_alt(TokenList, locked_macros, macros_object, macros_object_expansion, macros_object_expansion_pre_eval, macros_function, macros_function_arglist, macros_function_expansion, macros_function_expansion_pre_eval, include_file_index, include_file_cache, min_types);
+#/*cut-nocpp*/
+#/*cut-cpp*/
+
+	// need whitespace tokens here to force pretty-printing
+	debug_to_stderr(TokenList,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,locked_macros);
+	die_on_pp_errors();
+	if (TokenList.empty())
+		{	//! \todo make this more efficient by providing a global flush-all
+		const char* atom_string = string_from_index(0);
+		while(NULL!=atom_string)
+			{
+			deregister_index(0);
+			atom_string = string_from_index(0);
+			};
+		return true;
+		}
+
+	// Reset internal flags
+	// for this to work, #pragma must be converted to _Pragma operators
+	// do not flush whitespace tokens here, as the standalone will need them
+	{
+	const autovalarray_ptr<Token<char>* >::iterator iter_end = TokenList.end();
+	autovalarray_ptr<Token<char>* >::iterator iter = TokenList.begin();
+	if (iter!=iter_end)
+		do	{
+			(*iter)->flags &= ~PREPROCESSING_DIRECTIVE_FLAG;
+			PACK_DIRECTIVE((*iter)->flags,0);
+			}
+		while(++iter!=iter_end);
+	}
+
+	// invoke GC on include_file_cache
+	size_t i = include_file_cache.size();
+	while(0<i)
+		{
+		delete include_file_cache[--i].second;
+		include_file_cache[i].second = NULL;	// for style reasons
+		};
+	include_file_cache.reset();	// remove
+	include_file_index.reset();	// remove
+
+	// check for unused atomic strings
+	{
+	size_t x = 0;
+	const char* atom_string = string_from_index(x);
+	while(NULL!=atom_string)
+		{
+		bool string_used = false;
+		i = TokenList.size();
+		do	if (	atom_string==TokenList[--i]->src_filename
+				|| 	atom_string==TokenList[i]->parent_dir)
+				{
+				string_used = true;
+				break;
+				}
+		while(0<i);
+		if (string_used)
+			++x;
+		else
+			deregister_index(x);
+		atom_string = string_from_index(x);
+		};
+	}
+	return true;
+}
+
+static inline bool
+pragma_locked_macro(const char* const x,const size_t x_len,const autovalarray_ptr<char*>& locked_macros)
+{
+	assert(!is_empty_string(x));
+	assert(0<x_len);
+	return 0<=binary_find(x,x_len,locked_macros);
+}
+
+static bool line_is_preprocessing_directive(Token<char>& x)
+{	// normalize leading %: to # to handle equivalency of these tokens
+	//! \test cpp/Error_error_directive2.hpp
+	if ((sizeof("%:")-1)<=x.size() && !strncmp(x.data(),"%:",sizeof("%:")-1)) x.replace_once(std::nothrow,0,sizeof("%:")-1,"#");
+	return '#'==x.front();
+}
+
+static void discard_locked_macro(autovalarray_ptr<Token<char>* >& TokenList, const size_t i,const int directive_type,const size_t first_token_len)
+{
+	message_header(*TokenList[i]);
+	INC_INFORM(ERR_STR);
+	INC_INFORM("#");
+	INC_INFORM(valid_directives[directive_type].first);
+	INC_INFORM(" applied to locked macro ");
+	INC_INFORM(TokenList[i]->data()+valid_directives[directive_type].second+2,first_token_len);
+	INFORM("; discarding directive. (ZCPP pragma effect)");
+	TokenList.DeleteIdx(i);
+	zcc_errors.inc_error();
+}
+
+static void C99_reject_keyword_macros(autovalarray_ptr<Token<char>* >& TokenList, size_t include_where, const char* look_for, const LangConf& lang, autovalarray_ptr<char*>& macros_object, autovalarray_ptr<Token<char>*>& macros_object_expansion, autovalarray_ptr<Token<char>*>& macros_object_expansion_pre_eval, autovalarray_ptr<char*>& macros_function, autovalarray_ptr<Token<char>*>& macros_function_arglist, autovalarray_ptr<Token<char>*>& macros_function_expansion, autovalarray_ptr<Token<char>*>& macros_function_expansion_pre_eval)
+{
+	assert(NULL!=look_for);
+	size_t j = lang.len_InvariantKeywords;
+	do	{
+		--j;
+		const errr object_macro_index = binary_find(lang.InvariantKeywords[j].first,lang.InvariantKeywords[j].second,macros_object);
+		const errr function_macro_index = binary_find(lang.InvariantKeywords[j].first,lang.InvariantKeywords[j].second,macros_function);
+		assert(0>object_macro_index || 0>function_macro_index);
+		if (0<=object_macro_index || 0<=function_macro_index)
+			{
+			message_header(*TokenList[include_where]);
+			INC_INFORM(ERR_STR);
+			INC_INFORM("keyword '");
+			INC_INFORM(0<=object_macro_index ? macros_object[object_macro_index] : macros_function[function_macro_index]);
+			INC_INFORM("' defined as a macro when including system header <");
+			INC_INFORM(look_for);
+			INFORM(">.  Defining undefined behavior as undefining macro and proceeding.  (C99 7.1.2p4)");
+			zcc_errors.inc_error();
+			if (0<=object_macro_index)
+				{
+				macros_object.DeleteIdx(object_macro_index);
+				macros_object_expansion.DeleteIdx(object_macro_index);
+				macros_object_expansion_pre_eval.DeleteIdx(object_macro_index);
+				};
+			if (0<=function_macro_index)
+				{
+				macros_function.DeleteIdx(function_macro_index);
+				macros_function_arglist.DeleteIdx(function_macro_index);
+				macros_function_expansion.DeleteIdx(function_macro_index);
+				macros_function_expansion_pre_eval.DeleteIdx(function_macro_index);
+				};
+			return;
+			}
+		}
+	while(0<j);
+}
+
+/*! 
+ * returns code for hardcoded system header not in the file system
+ * 
+ * \param look_for header name
+ * \param lang_code language code from preprocessor object
+ * 
+ * \return unsigned int
+ */
+static unsigned int
+detect_hardcoded_system_header(const char* const look_for,size_t lang_code)
+{
+	switch(lang_code)
+	{
+	case Lang::CPlusPlus:	// C++ hard-coded system headers
+		if (!strcmp(look_for,"climits")) return 1;
+		if (!strcmp(look_for,"cstddef")) return 2;
+		if (!strcmp(look_for,"cstdint")) return 3;
+	case Lang::C:	// C, C++ hard-coded system headers
+		if (!strcmp(look_for,"limits.h")) return 1;
+		if (!strcmp(look_for,"stddef.h")) return 2;
+		if (!strcmp(look_for,"stdint.h")) return 3;
+	}
+	return 0;
+}
+
+void
+CPreprocessor::_preprocess(autovalarray_ptr<Token<char>* >& TokenList, autovalarray_ptr<char*>& locked_macros, autovalarray_ptr<char*>& macros_object, autovalarray_ptr<Token<char>*>& macros_object_expansion, autovalarray_ptr<Token<char>*>& macros_object_expansion_pre_eval, autovalarray_ptr<char*>& macros_function, autovalarray_ptr<Token<char>*>& macros_function_arglist, autovalarray_ptr<Token<char>*>& macros_function_expansion, autovalarray_ptr<Token<char>*>& macros_function_expansion_pre_eval, autovalarray_ptr<POD_triple<const char*, const char*,uintptr_t> >& include_file_index, autovalarray_ptr<POD_pair<const char*,autovalarray_ptr<Token<char>*>* > >& include_file_cache, const type_system& min_types)
+{
+Restart:
+	size_t i = 0;
+RestartAfterInclude:
+	if (TokenList.empty()) return;
+	size_t if_depth = 0;
+	size_t if_where = 0;			// origin 0
+	size_t else_where = 0;			// origin 1; 0 is not triggered
+	size_t include_where = 0;		// origin 1; 0 is not triggered
+	size_t restart_full_scan = 0;	// origin 1; 0 is not triggered
+	do	{
+		if (line_is_preprocessing_directive(*TokenList[i]))
+			{	// directive
+			{	// scoping brace
+			const size_t token_size = TokenList[i]->size();
+			if (1==token_size)
+				{
+				TokenList.DeleteIdx(i);	// Null directive #, delete
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+			const size_t whitespace_size = strspn(TokenList[i]->data()+1,lang.WhiteSpace+1);
+			if (token_size-1 == whitespace_size)
+				{
+				TokenList.DeleteIdx(i);	// Null directive #, delete
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+
+			TokenList[i]->flags |= PREPROCESSING_DIRECTIVE_FLAG;
+			if (0<whitespace_size)
+				{	// normalize
+				TokenList[i]->c_array()[whitespace_size] = '#';
+				TokenList[i]->ltrim(whitespace_size);
+				assert(!TokenList[i]->empty());
+				assert('#'==TokenList[i]->front());
+				};
+			}	// end scoping brace
+			const errr directive_type = find_directive(TokenList[i]->data()+1,lang);
+			if (0>directive_type && 0==if_depth)
+				{	//! \test Warn_unrecognized_directive.hpp : naked unrecognized directive
+				message_header(*TokenList[i]);
+				INC_INFORM("warning: unrecognized preprocessing directive '");
+				size_t j = 0;
+				while(++j<TokenList[i]->size() && !lang.IsWS_NotFirst(TokenList[i]->data()[j]))
+					INC_INFORM(TokenList[i]->data()[j]);
+				INFORM("' (C99 6.10p1/C++98 16.1p1)");
+				if (bool_options[boolopt::warnings_are_errors]) zcc_errors.inc_error();
+				TokenList.DeleteIdx(i);
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+
+			// stripping trailing spaces damages incomplete string and character literals.
+			switch(directive_type)
+			{
+			case PP::IF:		
+			case PP::IFDEF:		
+			case PP::IFNDEF:	
+			case PP::ELIF:		
+			case PP::ELSE:		
+			case PP::ENDIF:		
+			case PP::INCLUDE:	
+			case PP::DEFINE:	
+			case PP::UNDEF:		
+			case PP::LINE:		
+			case PP::ERROR:		
+			case PP::PRAGMA:	{	// normalize the whitespace; allowed to shove directive left to do it
+								size_t critical_offset = valid_directives[directive_type].second+1;
+								if (TokenList[i]->size()>critical_offset)
+									{
+									const size_t intra_WS = strspn(TokenList[i]->data()+critical_offset,lang.WhiteSpace+1);
+									if (0==intra_WS)
+										//! \todo really should be a bit more clever about this
+										TokenList[i]->replace_once(critical_offset,0,' ');
+									else if (TokenList[i]->size()-critical_offset<=intra_WS)
+										{
+										if (PP::PRAGMA==directive_type)
+											{
+											TokenList.DeleteIdx(i);	// empty pragma is legal, but Z.C++ says it has no effect
+											if (0==i) goto Restart;
+											--i;
+											continue;
+											};
+										TokenList[i]->rtrim(intra_WS);
+										}
+									else if (1<intra_WS)
+										TokenList[i]->replace_once(std::nothrow,critical_offset,intra_WS,' ');
+									else
+										TokenList[i]->c_array()[critical_offset] = ' ';
+									}
+								PACK_DIRECTIVE(TokenList[i]->flags,directive_type);
+								assert(TokenList[i]->size()>=valid_directives[directive_type].second+1);
+								break;
+								};
+			default:			{	// Unrecognized.  Warn-and-delete when we know it's going to be executed (not within any conditional blocks.
+								PACK_DIRECTIVE(TokenList[i]->flags,PP_INVALID);
+								break;
+								};
+			};
+
+			// #if nesting-depth 0 processing
+			if (0==if_depth)
+				{
+				lex_flags first_token_flags = 0;
+				size_t first_token_len = 0;
+				if (PP::ERROR==directive_type)
+					{	// an error by fiat
+						//! \test cpp/Error_error_directive.hpp
+						//! \test cpp/Error_error_directive2.hpp
+					message_header(*TokenList[i]);
+					INC_INFORM(ERR_STR);
+					INFORM(TokenList[i]->data()+(sizeof("#error ")-1));
+					TokenList.DeleteIdx(i);
+					zcc_errors.inc_error();
+					if (0==i) goto Restart;
+					--i;
+					continue;
+					};
+				if (   PP::ELSE ==directive_type
+					|| PP::ELIF ==directive_type
+					|| PP::ENDIF==directive_type)
+					{	// no prior #if/#ifdef/#ifndef is an error
+					//! \test Error_naked_else.hpp : #else without #if/#ifdef/#ifndef
+					//! \test Error_naked_elif.hpp : #elif without #if/#ifdef/#ifndef
+					//! \test Error_naked_endif.hpp : #endif without #if/#ifdef/#ifndef
+					//! \test Error_elif_after_else.hpp : #elif after #else
+					//! \test Error_else_after_else.hpp : #else after #else
+					message_header(*TokenList[i]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("#");
+					INC_INFORM(valid_directives[directive_type].first);
+					INFORM(" without paired #if/#ifdef/#ifndef (C99 6.10p1/C++98 16.1p1)");
+					TokenList.DeleteIdx(i);
+					zcc_errors.inc_error();
+					if (0==i) goto Restart;
+					--i;
+					continue;
+					};
+				if (   PP::DEFINE ==directive_type
+					|| PP::UNDEF  ==directive_type
+					|| PP::INCLUDE==directive_type
+					|| PP::LINE   ==directive_type)
+					{	// these must have preprocessing tokens to be meaningful
+					//! \test Error_no_token_define.hpp : #define no tokens
+					//! \test Error_no_token_undef.hpp : #undef no tokens
+					//! \test Error_no_token_include.hpp : #include no tokens
+					//! \test Error_no_token_line.hpp : #line no tokens
+					if (TokenList[i]->size()==valid_directives[directive_type].second+1)
+						{
+						message_header(*TokenList[i]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("#");
+						INC_INFORM(valid_directives[directive_type].first);
+						INFORM(" must have preprocessing tokens afterwards (allowing for macro substitution); discarding. (C99 6.10p1/C++98 16.1p1)");
+						TokenList.DeleteIdx(i);
+						zcc_errors.inc_error();
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					}
+				if (   PP::DEFINE ==directive_type
+					|| PP::UNDEF  ==directive_type)
+					{	// do basic legality checks now: C identifier, not locked
+					const size_t critical_offset = valid_directives[directive_type].second+2;
+					if (TokenList[i]->size()>critical_offset) first_token_len = lang.UnfilteredNextToken(TokenList[i]->data()+critical_offset,first_token_flags);
+					if (C_TESTFLAG_IDENTIFIER!=first_token_flags)
+						{	//! \test Error_undef_no_identifier.hpp : #undef without identifier
+						message_header(*TokenList[i]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("#");
+						INC_INFORM(valid_directives[directive_type].first);
+						INFORM(" does not have an identifier afterwards; discarding. (C99 6.10p1/C++98 16.1p1)");
+						TokenList.DeleteIdx(i);
+						zcc_errors.inc_error();
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+
+					// want to catch illegal tokens before ditching a #undef of a locked macro
+					//! \test Error_undef_illegal_tokens.hpp : #undef illegal tokens
+					if (PP::UNDEF==directive_type) truncate_illegal_tokens(*TokenList[i],directive_type,critical_offset+first_token_len);
+
+					if (hard_locked_macro(TokenList[i]->data()+critical_offset,first_token_len))
+						{	//! \test Error_undef_STDC.hpp : #undef __STDC__
+						discard_locked_macro(TokenList,i,directive_type,first_token_len);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					if (	0==include_where && 0==restart_full_scan
+						&&	pragma_locked_macro(TokenList[i]->data()+critical_offset,first_token_len,locked_macros))
+						{	// here so we don't recalculate the above
+						//! \test cpp/Error_undef_locked_macro.hpp
+						discard_locked_macro(TokenList,i,directive_type,first_token_len);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					if (PP::DEFINE==directive_type && TokenList[i]->size()>critical_offset+first_token_len)
+						{	// standardize silently
+						const size_t intra_WS = strspn(TokenList[i]->data()+critical_offset+first_token_len,lang.WhiteSpace+1);
+						if (TokenList[i]->size()-(critical_offset+first_token_len)<=intra_WS)
+							TokenList[i]->rtrim(intra_WS);	// normalize -- null-def object-like macro
+						else if (1<intra_WS)
+							TokenList[i]->replace_once(std::nothrow,critical_offset+first_token_len,intra_WS,' ');
+						}
+					};
+				if (PP::PRAGMA==directive_type)
+					{
+					const size_t critical_offset = valid_directives[directive_type].second+2;
+					assert(TokenList[i]->size()>critical_offset);
+					if (C99_VA_ARGS_flinch(*TokenList[i],sizeof("pragma ")-1))
+						{	//! \test Error_pragma_VA_ARGS.hpp
+						message_header(*TokenList[i]);
+						INFORM("discarding pragma");
+						TokenList.DeleteIdx(i);	// ignore the pragma
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					first_token_len = lang.UnfilteredNextToken(TokenList[i]->data()+critical_offset,first_token_flags);
+					if (0>linear_find_lencached(TokenList[i]->data()+critical_offset, first_token_len, accept_pragma_leading_tokens, STATIC_SIZE(accept_pragma_leading_tokens)))
+						{
+						TokenList.DeleteIdx(i);	// ignore the pragma
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					}
+				if (PP::INCLUDE==directive_type && 0==include_where)
+					{	// we have an include; postpone inclusion
+						// don't think memory conservation is ISO
+					if (0==restart_full_scan)
+						intradirective_preprocess(*TokenList[i], sizeof("#include ")-1,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval);
+					include_where = i+1;
+					};
+				if (0==include_where && 0==restart_full_scan)
+					{
+					if (PP::LINE==directive_type)
+						{
+						if (C99_VA_ARGS_flinch(*TokenList[i],sizeof("#line ")-1))
+							{	//! \test cpp/line.C99/Error_VA_ARGS.h, cpp/line.C99/Error_VA_ARGS.hpp
+							message_header(*TokenList[i]);
+							INFORM("discarding #line directive");
+							TokenList.DeleteIdx(i);
+							if (0==i) goto Restart;
+							--i;
+							continue;
+							};
+
+						intradirective_preprocess(*TokenList[i], sizeof("#line ")-1,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval);
+						use_line_directive_and_discard(TokenList,i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					if (PP::UNDEF==directive_type)
+						{
+						const size_t critical_offset = valid_directives[directive_type].second+2;
+						assert(0<first_token_len);
+						assert(TokenList[i]->size()>=critical_offset+first_token_len);
+						// apply undef
+						const errr object_macro_index = binary_find(TokenList[i]->data()+critical_offset,first_token_len,macros_object);
+						const errr function_macro_index = binary_find(TokenList[i]->data()+critical_offset,first_token_len,macros_function);
+						assert(0>object_macro_index || 0>function_macro_index);
+						if (0<=object_macro_index)
+							{
+							macros_object.DeleteIdx(object_macro_index);
+							macros_object_expansion.DeleteIdx(object_macro_index);
+							macros_object_expansion_pre_eval.DeleteIdx(object_macro_index);
+							};
+						if (0<=function_macro_index)
+							{
+							macros_function.DeleteIdx(function_macro_index);
+							macros_function_arglist.DeleteIdx(function_macro_index);
+							macros_function_expansion.DeleteIdx(function_macro_index);
+							macros_function_expansion_pre_eval.DeleteIdx(function_macro_index);
+							}
+						TokenList.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					if (PP::DEFINE==directive_type)
+						{
+						const size_t critical_offset = valid_directives[directive_type].second+2;
+						assert(0<first_token_len);
+						assert(TokenList[i]->size()>=critical_offset+first_token_len);
+						const errr object_macro_index = binary_find(TokenList[i]->data()+critical_offset,first_token_len,macros_object);
+						const errr function_macro_index = binary_find(TokenList[i]->data()+critical_offset,first_token_len,macros_function);
+						assert(0>object_macro_index || 0>function_macro_index);
+						if (TokenList[i]->size()==critical_offset+first_token_len)
+							{	// object-like, empty string
+ObjectLikeMacroEmptyString:
+							if (	 0<=function_macro_index
+								|| 	(0<=object_macro_index && NULL!=macros_object_expansion[object_macro_index]))
+								{	//! \test define.C99/Error_dup1.hpp, define.C99/Error_dup1.h
+									//! \test define.C99/Error_dup2.hpp, define.C99/Error_dup2.h
+								discard_duplicate_define(TokenList,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (0<=object_macro_index)
+								{	// already present: discard silently
+									//! \test define.C99/Pass_dup1.hpp, define.C99/Pass_dup1.h
+								TokenList.DeleteIdx(i);	// discard silently
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							const size_t object_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(object_macro_index);
+							macros_object.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion_pre_eval.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object[object_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
+							strncpy(macros_object[object_macro_insertion_index],TokenList[i]->data()+critical_offset,first_token_len);
+							ZAIMONI_NULL_TERMINATE(macros_object[object_macro_insertion_index][first_token_len]);
+							}
+						else if (lang.IsWS_NotFirst(TokenList[i]->data()[critical_offset+first_token_len]))
+							{	// object-like, not empty string
+							if (	0<=function_macro_index
+								|| 	(0<=object_macro_index && NULL==macros_object_expansion[object_macro_index]))
+								{	//! \test define.C99/Error_dup3.hpp, define.C99/Error_dup3.h
+									//! \test define.C99/Error_dup4.hpp, define.C99/Error_dup4.h
+									//! \test define.C99/Pass_dup2.hpp, define.C99/Pass_dup2.h
+								discard_duplicate_define(TokenList,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+							Token<char> expansion(*TokenList[i],critical_offset+first_token_len,TokenList[i]->size()-(critical_offset+first_token_len),0);
+							normalize_macro_expansion(expansion,*TokenList[i],critical_offset,first_token_len);
+							//! \test define.C99/Pass_dup2.hpp, define.C99/Pass_dup2.h
+							//! \test define.C99/Error_concatenate1.hpp, define.C99/Error_concatenate1.h
+							//! \test define.C99/Error_concatenate2.hpp, define.C99/Error_concatenate2.h
+							if (discard_leading_trailing_concatenate_op(expansion))
+								goto ObjectLikeMacroEmptyString;
+							if (0<=object_macro_index)
+								{	//! \test define.C99/Error_dup5.hpp, define.C99/Error_dup5.h
+									//! \test define.C99/Pass_dup2.hpp, define.C99/Pass_dup2.h
+								if (strcmp(expansion.data(),macros_object_expansion[object_macro_index]->data()))
+									discard_duplicate_define(TokenList,i,critical_offset,first_token_len);
+								else
+									TokenList.DeleteIdx(i);	// discard silently even if it matches
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (C99_VA_ARGS_flinch(expansion,0))
+								{	//! \test define.C99/Error_VA_ARGS.hpp, define.C99/Error_VA_ARGS.h
+								message_header(expansion);
+								INFORM("discarding macro");
+								TokenList.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+
+							// DO NOT check for context free errors here; could legitimately want to deep-stringize every invocation of the macro
+							const size_t object_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(object_macro_index);
+							macros_object.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion_pre_eval.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object[object_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
+
+							strncpy(macros_object[object_macro_insertion_index],TokenList[i]->data()+critical_offset,first_token_len);
+							ZAIMONI_NULL_TERMINATE(macros_object[object_macro_insertion_index][first_token_len]);
+							macros_object_expansion_pre_eval[object_macro_insertion_index] = new Token<char>(expansion);
+							macros_object_expansion[object_macro_insertion_index] = new Token<char>;
+							expansion.MoveInto(*macros_object_expansion[object_macro_insertion_index]);
+							object_macro_concatenate(*macros_object_expansion_pre_eval[object_macro_insertion_index]);
+							if (C99_VA_ARGS_flinch(*macros_object_expansion_pre_eval[object_macro_insertion_index],0))
+								{	//! \test define.C99/Error_concatenate5.hpp, define.C99/Error_concatenate5.h
+								message_header(*macros_object_expansion_pre_eval[object_macro_insertion_index]);
+								INFORM("discarding macro");
+								macros_object.DeleteIdx(object_macro_insertion_index);
+								macros_object_expansion.DeleteIdx(object_macro_insertion_index);
+								macros_object_expansion_pre_eval.DeleteIdx(object_macro_insertion_index);
+								TokenList.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							//! \todo should do locked macros [not __FILE__ or __LINE__] that are not first or last identifiers on speculation
+							}
+						else if ('('==TokenList[i]->data()[critical_offset+first_token_len])
+							{	// function-like
+							const size_t argspan = function_macro_argument_span(TokenList[i]->data()+critical_offset+first_token_len);
+							if (0==argspan)
+								{
+								message_header(*TokenList[i]);
+								INC_INFORM(ERR_STR);
+								INC_INFORM(TokenList[i]->data()+critical_offset,first_token_len);
+								INFORM(" has an invalid argument list.  Discarding. (C99 6.10.3p/C++0x 16.3p10)");
+								TokenList.DeleteIdx(i);
+								zcc_errors.inc_error();
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (0<=object_macro_index)
+								{	//! \test define.C99/Error_dup6.hpp, define.C99/Error_dup6.h
+								discard_duplicate_define(TokenList,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							Token<char> arglist(*TokenList[i],critical_offset+first_token_len,argspan,0);
+							normalize_macro_expansion(arglist,*TokenList[i],critical_offset,first_token_len);	// should be no string literals here, so should be no errors here
+							if (0<=function_macro_index && strcmp(arglist.data(),macros_function_arglist[function_macro_index]->data()))
+								{	//! \test define.C99/Error_dup7.hpp, define.C99/Error_dup7.h
+								discard_duplicate_define(TokenList,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (TokenList[i]->size()-(critical_offset+first_token_len)>argspan)
+								{
+								const size_t skip_ws = strspn(TokenList[i]->data()+critical_offset+first_token_len+argspan,lang.WhiteSpace+1);
+								if (TokenList[i]->size()-(critical_offset+first_token_len+argspan)<=skip_ws)
+									TokenList[i]->rtrim(skip_ws);
+								};
+							if (TokenList[i]->size()-(critical_offset+first_token_len)<=argspan)
+								{	// empty expansion
+FunctionLikeMacroEmptyString:	if (0<=function_macro_index)
+									{	//! \test define.C99/Error_dup9.hpp, define.C99/Error_dup9.h
+										//! \test define.C99/Pass_dup4.h, define.C99/Pass_dup4.h
+									if (NULL!=macros_function_expansion[function_macro_index])
+										discard_duplicate_define(TokenList,i,critical_offset,first_token_len);
+									else
+										TokenList.DeleteIdx(i);	// ignore silently if exactly agreed
+									if (0==i) goto Restart;
+									--i;
+									continue;
+									}
+								const size_t function_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(function_macro_index);
+								macros_function.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_arglist.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_expansion.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_expansion_pre_eval.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function[function_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
+
+								strncpy(macros_function[function_macro_insertion_index],TokenList[i]->data()+critical_offset,first_token_len);
+								ZAIMONI_NULL_TERMINATE(macros_function[function_macro_insertion_index][first_token_len]);
+								macros_function_arglist[function_macro_insertion_index] = new Token<char>;
+								arglist.MoveInto(*macros_function_arglist[function_macro_insertion_index]);
+
+								TokenList.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							Token<char> expansion(*TokenList[i],critical_offset+first_token_len+argspan,TokenList[i]->size()-(critical_offset+first_token_len+argspan),0);
+							normalize_macro_expansion(expansion,*TokenList[i],critical_offset,first_token_len);
+							// white-box test policy: cases above will work
+							if (discard_leading_trailing_concatenate_op(expansion))
+								goto FunctionLikeMacroEmptyString;
+							if (0<=function_macro_index)
+								{	//! \test define.C99/Error_dup8.hpp, define.C99/Error_dup8.h
+									//! \test define.C99/Pass_dup3.h, define.C99/Pass_dup3.h
+								if (strcmp(expansion.data(),macros_function_expansion[function_macro_index]->data()))
+									discard_duplicate_define(TokenList,i,critical_offset,first_token_len);
+								else
+									TokenList.DeleteIdx(i);	// discard silently even if it matches
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if ((5>arglist.size() || strcmp(arglist.end()-(sizeof("...)")-1),"...)")) && C99_VA_ARGS_flinch(expansion,0))
+								{	//! \test define.C99/Error_VA_ARGS2.hpp, define.C99/Error_VA_ARGS2.h
+									//! \test define.C99/Pass_VA_ARGS.hpp, define.C99/Pass_VA_ARGS.h
+								message_header(expansion);
+								INFORM("discarding macro");
+								TokenList.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+
+							// DO NOT check for context free errors here; could legitimately want to deep-stringize every invocation of the macro
+							const size_t function_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(function_macro_index);
+							macros_function.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_arglist.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_expansion.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_expansion_pre_eval.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function[function_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
+
+							strncpy(macros_function[function_macro_insertion_index],TokenList[i]->data()+critical_offset,first_token_len);
+							ZAIMONI_NULL_TERMINATE(macros_function[function_macro_insertion_index][first_token_len]);
+							macros_function_arglist[function_macro_insertion_index] = new Token<char>;
+							macros_function_expansion[function_macro_insertion_index] = new Token<char>;
+							macros_function_expansion_pre_eval[function_macro_insertion_index] = new Token<char>(expansion);
+							arglist.MoveInto(*macros_function_arglist[function_macro_insertion_index]);
+							expansion.MoveInto(*macros_function_expansion[function_macro_insertion_index]);
+							if (flush_bad_stringize(*macros_function_expansion_pre_eval[function_macro_insertion_index],*macros_function_arglist[function_macro_insertion_index]))
+								{
+								delete macros_function_expansion_pre_eval[function_macro_insertion_index];
+								macros_function_expansion_pre_eval[function_macro_insertion_index] = NULL;
+								};
+							if (NULL!=macros_function_expansion_pre_eval[function_macro_insertion_index])
+								{
+								function_macro_concatenate_novars(*macros_function_expansion_pre_eval[function_macro_insertion_index], *macros_function_arglist[function_macro_insertion_index]);
+								if ((5>macros_function_arglist[function_macro_insertion_index]->size() || strcmp(macros_function_arglist[function_macro_insertion_index]->end()-(sizeof("...)")-1),"...)")) && C99_VA_ARGS_flinch(*macros_function_expansion_pre_eval[function_macro_insertion_index],0))
+									{	//! \test define.C99/Error_concatenate6.hpp, define.C99/Error_concatenate6.h
+										//! \test define.C99/Pass_concatenate3.hpp, define.C99/Pass_concatenate3.h
+									message_header(*macros_function_expansion_pre_eval[function_macro_insertion_index]);
+									INFORM("discarding macro");
+									macros_function.DeleteIdx(function_macro_insertion_index);
+									macros_function_arglist.DeleteIdx(function_macro_insertion_index);
+									macros_function_expansion.DeleteIdx(function_macro_insertion_index);
+									macros_function_expansion_pre_eval.DeleteIdx(function_macro_insertion_index);
+									TokenList.DeleteIdx(i);
+									if (0==i) goto Restart;
+									--i;
+									continue;
+									}
+								};
+							//! \todo should do locked macros [not __FILE__ or __LINE__] that are not first or last identifiers on speculation
+							};
+						TokenList.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					// should use #pragma directives
+					// all three STDC pragmas are scoped: they have to be around until fairly late in the compilation sequence
+					// we are required to ignore unrecognized pragmas -- no warnings
+					// want immediately: #pragma ZCC lock ___
+					// * locks macros
+					if (PP::PRAGMA==directive_type)
+						{
+						const size_t critical_offset = valid_directives[directive_type].second+2;
+#/*cut-cpp*/
+						const unsigned int pragma_code =
+#/*cut-cpp*/
+						interpret_pragma(TokenList[i]->data()+critical_offset,TokenList[i]->size()-critical_offset,locked_macros);
+#/*cut-cpp*/
+						switch(pragma_code)
+						{
+						default:
+#/*cut-cpp*/
+						TokenList.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+#/*cut-cpp*/
+						case RELAY_ZCC_ENABLE_TYPEID+1:
+							TokenList[i]->replace_once(0,TokenList[i]->size(),pragma_relay_keywords[pragma_code-1].first,pragma_relay_keywords[pragma_code-1].second);
+							continue;
+						}
+#/*cut-cpp*/
+						}
+					}
+				}
+
+			if (   PP::IF    ==directive_type
+				|| PP::IFDEF ==directive_type
+				|| PP::IFNDEF==directive_type)
+				{
+				if (1 == ++if_depth)
+					{
+					if_where = i;
+					else_where = 0;
+					// front-load syntax checking
+					// only report errors once
+					if (!(TokenList[i]->flags & INVALID_DIRECTIVE_FLAG) && 0==include_where)
+						{
+						if (PP::IF==directive_type)
+							{
+							if (!if_elif_syntax_ok(*TokenList[i],macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,min_types))
+								TokenList[i]->flags |= INVALID_DIRECTIVE_FLAG;
+							}
+						else{
+							if (!ifdef_ifndef_syntax_ok(*TokenList[i],macros_object,macros_function))
+								TokenList[i]->flags |= INVALID_DIRECTIVE_FLAG;
+							else
+								assert(PP::IF==UNPACK_DIRECTIVE(TokenList[i]->flags));
+							}
+						}
+					if (0==restart_full_scan)
+						{
+						restart_full_scan = i+1;
+						//! \todo do it all, have complete information
+						};
+					//! \todo front-load syntax checking, etc. when safe [0==include_where && if_where+1==restart_full_scan]
+					//! can detect gross-invalidity anyway, but anything requiring authoritiatively knowing macro (un)defined-ness won't go through
+					}
+				}
+			else if (   PP::ELSE ==directive_type
+					 || PP::ELIF ==directive_type
+					 || PP::ENDIF==directive_type)
+				{
+				assert(0<if_depth);
+				if (1==if_depth)
+					{
+					if (PP::ELIF!=directive_type)
+						//! test Error_else_with_tokens.hpp : #else with tokens
+						//! test Error_endif_with_tokens.hpp : #endif with tokens
+						truncate_illegal_tokens(*TokenList[i],directive_type,valid_directives[directive_type].second+1);
+					else if (	!(TokenList[i]->flags & INVALID_DIRECTIVE_FLAG)
+							 && !if_elif_syntax_ok(*TokenList[i],macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,min_types))
+						TokenList[i]->flags |= INVALID_DIRECTIVE_FLAG;
+					};
+
+				if (PP::ENDIF==directive_type)
+					{
+					if (0 == --if_depth)
+						{	// trigger conditional preprocessing here
+						assert(TokenList[if_where]->flags & PREPROCESSING_DIRECTIVE_FLAG);
+						assert(0==else_where || (TokenList[else_where-1]->flags & PREPROCESSING_DIRECTIVE_FLAG));
+						assert(0==else_where || (if_where<=else_where && else_where<=i));
+						if (TokenList[if_where]->flags & INVALID_DIRECTIVE_FLAG)
+							{	// already tagged as invalid
+							message_header(*TokenList[if_where]);
+							INFORM("Ignoring entire block controlled by flawed directive");
+							TokenList.DeleteNSlotsAt(i-if_where+1,if_where);
+							i = if_where;
+							if (0==i) goto Restart;
+							if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
+							if (include_where>=i+1) include_where = 0;			// failsafing
+							--i;
+							continue;
+							};
+
+						// inject reductions here
+						const unsigned int else_directive = (0==else_where) ? PP_INVALID : UNPACK_DIRECTIVE(TokenList[else_where-1]->flags);
+						assert(0==else_where || PP::ELSE==else_directive || PP::ELIF==else_directive);
+						if (!strcmp(TokenList[if_where]->data(),"#if 0"))
+							{
+							if (0==else_where)
+								{
+								TokenList.DeleteNSlotsAt(i-if_where+1,if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
+								if (include_where>=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							if (PP::ELSE==else_directive)
+								{
+								TokenList.DeleteIdx(i);
+//								TokenList.DeleteNSlotsAt((else_where-1)-if_where+1,if_where);
+								TokenList.DeleteNSlotsAt(else_where-if_where,if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
+								if (include_where>=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							if (TokenList[else_where-1]->flags & INVALID_DIRECTIVE_FLAG)
+								{	//! \test Error8.hpp : #elif no control expression, critical
+								message_header(*TokenList[else_where-1]);
+								INFORM("Ignoring all lines from invalid #elif to matching #endif");
+								TokenList.DeleteNSlotsAt(i-if_where+1,if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
+								if (include_where>=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							//! \todo do full reduction here to make errors read #elif rather than #if
+							// recurse it
+							TokenList[else_where-1]->c_array()[2] = '#';
+							TokenList[else_where-1]->ltrim(2);
+							PACK_DIRECTIVE(TokenList[else_where-1]->flags,PP::IF);
+//							TokenList.DeleteNSlotsAt((else_where-1)-if_where+1,if_where);
+							TokenList.DeleteNSlotsAt(else_where-if_where+2,if_where);
+							i = if_where;
+							if (0==i) goto Restart;
+							if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
+							if (include_where>=i+1) include_where = 0;			// failsafing
+							--i;
+							continue;
+							};
+						if (!strcmp(TokenList[if_where]->data(),"#if 1"))
+							{
+							if (0==else_where)
+								{
+								TokenList.DeleteIdx(i);
+								TokenList.DeleteIdx(if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
+								if (include_where>=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							if (PP::ELIF==else_directive && (TokenList[else_where-1]->flags & INVALID_DIRECTIVE_FLAG))
+								{	//! \test Error9.hpp : #elif no control expression, non-critical
+								message_header(*TokenList[else_where-1]);
+								INFORM("Continuing as expression for invalid #elif not needed.");
+								};
+//							TokenList.DeleteNSlotsAt(i-(else_where-1)+1,else_where-1);
+							TokenList.DeleteNSlotsAt(i-else_where+2,else_where-1);
+							TokenList.DeleteIdx(if_where);
+							i = if_where;
+							if (0==i) goto Restart;
+							if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
+							if (include_where>=i+1) include_where = 0;			// failsafing
+							--i;
+							continue;
+							};
+						}
+					}
+				else if (1==if_depth && 0==else_where)
+					else_where = i+1;
+				}
+			}
+		// non-directive; lex, and check for macros and _Pragma operators
+		// remember to convert whitespace to single-space tokens, and flush those later
+		else if (0==include_where && 0==restart_full_scan)
+			{
+			if (!tokenize_line(TokenList,i))
+				{
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+			if (C_TESTFLAG_PP_OP_PUNC & TokenList[i]->flags)
+				{	// check for categorically illegal tokens
+				const signed int old_pp_code = C_PP_DECODE(TokenList[i]->flags);
+				const signed int pp_code = (old_pp_code) ? old_pp_code : lang.pp_support->EncodePPOpPunc(TokenList[i]->data(),TokenList[i]->size());
+				assert(0<pp_code);
+				if (C_DISALLOW_POSTPROCESSED_SOURCE & lang.pp_support->GetPPOpPuncFlags(pp_code))
+					{	//! \todo need test cases
+						// actually, this might need to be language-sensitive (e.g., Perl)
+					message_header(*TokenList[i]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("Forbidden token '");
+					INC_INFORM(TokenList[i]->data(),TokenList[i]->size());
+					INFORM("' in postprocessed source.  Discarding.");
+					zcc_errors.inc_error();
+					TokenList.DeleteIdx(i);
+					if (0==i) goto Restart;
+					--i;
+					continue;
+					}
+				C_PP_ENCODE(TokenList[i]->flags,pp_code);
+				}
+			else if (C_TESTFLAG_IDENTIFIER==TokenList[i]->flags)
+				{
+				if (!strcmp(TokenList[i]->data(),"_Pragma"))
+					{	// could be pragma operator; syntax _Pragma ( C-string )
+					while(TokenList.size()>i+1 && !tokenize_line(TokenList,i+1));
+					if (        TokenList.size()<=i+1
+						||   1!=TokenList[i+1]->size()
+						|| '('!=TokenList[i+1]->front())
+						{	//! \test cpp/Pragma.C99/Error_op1.hpp, cpp/Pragma.C99/Error_op1.h
+							//! \test cpp/Pragma.C99/Error_op2.hpp, cpp/Pragma.C99/Error_op2.h
+						message_header2(*TokenList[i],TokenList[i]->logical_line.second);
+						INC_INFORM(ERR_STR);
+						INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
+						zcc_errors.inc_error();
+						TokenList.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					while(TokenList.size()>i+2 && !tokenize_line(TokenList,i+2));
+					if (   TokenList.size()<=i+2
+						|| C_TESTFLAG_STRING_LITERAL!=TokenList[i+2]->flags)
+						{	//! \test cpp/Pragma.C99/Error_op3.hpp, cpp/Pragma.C99/Error_op3.h
+							//! \test cpp/Pragma.C99/Error_op4.hpp, cpp/Pragma.C99/Error_op4.h
+						message_header2(*TokenList[i],TokenList[i]->logical_line.second);
+						INC_INFORM(ERR_STR);
+						INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
+						zcc_errors.inc_error();
+						TokenList.DeleteNSlotsAt(2,i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					while(TokenList.size()>i+3 && !tokenize_line(TokenList,i+3));
+					if (        TokenList.size()<=i+3
+						||   1!=TokenList[i+3]->size()
+						|| ')'!=TokenList[i+3]->front())
+						{	//! \test cpp/Pragma.C99/Error_op5.hpp, cpp/Pragma.C99/Error_op5.h
+							//! \test cpp/Pragma.C99/Error_op6.hpp, cpp/Pragma.C99/Error_op6.h
+						message_header2(*TokenList[i],TokenList[i]->logical_line.second);
+						INC_INFORM(ERR_STR);
+						INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
+						zcc_errors.inc_error();
+						TokenList.DeleteNSlotsAt(3,i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					if ('L'==TokenList[i+2]->front())
+						TokenList[i+2]->ltrim(1);
+					if (2<TokenList[i+2]->size())
+						{	//! \test Pass_pragma_STDC.hpp
+						autovalarray_ptr_throws<char> pragma_string(lang.UnescapeStringLength(TokenList[i+2]->data()+1,TokenList[i+2]->size()-2));
+						lang.UnescapeString(pragma_string.c_array(),TokenList[i+2]->data()+1,TokenList[i+2]->size()-2);
+#/*cut-cpp*/
+						const unsigned int pragma_code =
+#/*cut-cpp*/
+						interpret_pragma(pragma_string.data(),pragma_string.size(),locked_macros);
+#/*cut-cpp*/
+						switch(pragma_code)
+						{
+						case RELAY_ZCC_ENABLE_TYPEID+1:
+							TokenList[i]->replace_once(0,TokenList[i]->size(),pragma_relay_keywords[pragma_code-1].first,pragma_relay_keywords[pragma_code-1].second);
+							TokenList.DeleteNSlotsAt(3,i+1);
+							continue;
+						}
+#/*cut-cpp*/
+						};
+					TokenList.DeleteNSlotsAt(4,i);
+					if (0==i) goto Restart;
+					--i;
+					continue;
+					}
+
+				const errr object_macro_index = binary_find(TokenList[i]->data(),TokenList[i]->size(),macros_object);
+				const errr function_macro_index = binary_find(TokenList[i]->data(),TokenList[i]->size(),macros_function);
+				assert(0>object_macro_index || 0>function_macro_index);
+				if (0<=object_macro_index)
+					{	// object-like macro
+					if (!macros_object_expansion_pre_eval[object_macro_index])
+						{	// expands to nothing
+							//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
+						TokenList.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					assert(!macros_object_expansion_pre_eval[object_macro_index]->empty());
+					{	//! \test cpp/default/Preprocess_*.h/hpp
+					size_t discard = 0;
+					dynamic_macro_replace_once(*TokenList[i],discard,TokenList[i]->size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
+					}
+					size_t actual_tokens = tokenize_line(TokenList,i);
+					assert(0<actual_tokens);
+					i += actual_tokens-1;
+					}
+				else if (0<=function_macro_index)
+					{	// could be function-like macro
+					if (	TokenList.size()>i+1 && TokenList[i]->logical_line.first==TokenList[i+1]->logical_line.first
+						&& 	TokenList[i]->logical_line.second+TokenList[i]->size()==TokenList[i+1]->logical_line.second
+						&&	'('==TokenList[i+1]->front())
+						{
+						size_t paren_depth = 1;
+						size_t comma_count = 0;
+						size_t j = i+1;
+						do	{
+							if (TokenList.size()<=j+1)
+								{	//! \test cpp/Error_macro_arglist4.hpp
+									// error out, incomplete function-like macro
+								message_header2(*TokenList[i],TokenList[i]->logical_line.second);
+								INC_INFORM(ERR_STR);
+								INC_INFORM("macro ");
+								INC_INFORM(TokenList[i]->data(),TokenList[i]->size());
+								INFORM(" did not close its argument list in time. (C99 6.10p1/C++98 16.1p1)");
+								zcc_errors.inc_error();
+								i = j;
+								break;
+								}
+							if (TokenList[j]->logical_line.first<TokenList[j+1]->logical_line.first)
+								{	// line advance; check for pp-directives (undefined behavior), then tokenize
+								if (line_is_preprocessing_directive(*TokenList[j+1]))
+									{	//! \test cpp/Error_macro_arglist7.hpp
+										// error out, undefined behavior
+									message_header2(*TokenList[i],TokenList[i]->logical_line.second);
+									INC_INFORM(ERR_STR);
+									INFORM("macro invocation contains preprocessing directive.  Defining undefined behavior as ignoring macro invocation. (C99 6.10.3p11/C++98 16.3p10)");
+									zcc_errors.inc_error();
+									i = j;
+									break;
+									}
+								if (!tokenize_line(TokenList,j+1)) continue;
+								}
+							if (1==TokenList[++j]->size())
+								switch(TokenList[j]->front())
+								{
+								case '(':
+									++paren_depth;
+									break;
+								case ',':
+									++comma_count;
+									break;
+								case ')':
+									--paren_depth;
+									//	break;
+								};
+							}
+						while(0<paren_depth);
+						if (0==paren_depth)
+							{
+							assert(macros_function_arglist[function_macro_index]);
+							assert('('==macros_function_arglist[function_macro_index]->front());
+							assert(')'==macros_function_arglist[function_macro_index]->back());
+							const size_t formal_arg_span = macros_function_arglist[function_macro_index]->size();
+							const size_t formal_arg_count = (2<formal_arg_span) ? std::count(macros_function_arglist[function_macro_index]->begin(),macros_function_arglist[function_macro_index]->end(),',')+1 : 0;
+							const bool formal_varadic = 5<=formal_arg_span && !strncmp(macros_function_arglist[function_macro_index]->data()+(formal_arg_span-4),"...",sizeof("...")-1);
+							const size_t arg_count = (i+2==j) ? 0 : comma_count+1;
+							if (arg_count<formal_arg_count || (arg_count>formal_arg_count && !formal_varadic))
+								{	//! \test cpp/Error_macro_arglist5.hpp
+									//! \test cpp/Error_macro_arglist6.hpp
+								message_header2(*TokenList[i],TokenList[i]->logical_line.second);
+								INC_INFORM(ERR_STR);
+								INC_INFORM("macro ");
+								INC_INFORM(TokenList[i]->data(),TokenList[i]->size());
+								INC_INFORM(" had ");
+								INC_INFORM(arg_count);
+								INC_INFORM(" argument");
+								INC_INFORM((1==arg_count) ? "" : "s");
+								INC_INFORM(", needed ");
+								if (formal_varadic) INC_INFORM("at least ");
+								INC_INFORM(formal_arg_count);
+								INFORM(". (C99 6.10p1/C++0x 16.1p1)");
+								zcc_errors.inc_error();
+								i = j;
+								continue;
+								}
+							if (!macros_function_expansion_pre_eval[function_macro_index])
+								{	// expands to nothing
+									//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
+								TokenList.DeleteNSlotsAt(j-i+1,i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+							assert(!macros_function_expansion_pre_eval[function_macro_index]->empty());
+							{	//! \test default/Preprocess_*.h/hpp 
+							Token<char>* Tmp = new Token<char>(*macros_function_expansion_pre_eval[function_macro_index]);
+							Tmp->logical_line = TokenList[i]->logical_line;
+							if (!nonrecursive_macro_replacement_list(Tmp->data()))
+								{	// XXX trashes line information to reuse intrapreprocessing stuff
+								size_t discard = i;
+								Token<char>* Tmp2 = new Token<char>(*TokenList[i]);
+								while(++discard <= j) Tmp2->append(TokenList[discard]->data());
+								discard = 0;
+								dynamic_macro_replace_once(*Tmp2,discard,TokenList[i]->size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
+								delete Tmp;
+								Tmp = Tmp2;
+								}
+							TokenList.DeleteNSlotsAt(j-i,i+1);
+							delete TokenList[i];
+							TokenList[i] = Tmp;
+							}
+							size_t actual_tokens = tokenize_line(TokenList,i);
+							assert(0<actual_tokens);
+							i += actual_tokens-1;
+							};
+						}
+					}
+				else{	// replace predefined macros, if they are here
+						//! \test cpp/default/Preprocess_STDC_defines.hpp, cpp/default/Preprocess_STDC_defines.h
+					predefined_macro_replacement(*TokenList[i],0);
+					}
+				}
+			}
+		}
+	while(++i<TokenList.size());
+
+	if (0<if_depth)
+		{	//! \test Error_naked_if.hpp
+		message_header(*TokenList[if_where]);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(if_depth);
+		INC_INFORM(" #if/#ifdef/#ifndef");
+		if (1<if_depth) INC_INFORM("'s");
+		INFORM(" without matching #endif directives (first one here).  (C99 6.10p1/C++98 16.1p1)");
+		zcc_errors.inc_error();
+		}
+	assert(0==include_where || 0==restart_full_scan || include_where<restart_full_scan);
+
+	if (0<include_where)
+		{	// Need to find the file....
+		--include_where;
+		assert(PP::INCLUDE == UNPACK_DIRECTIVE(TokenList[include_where]->flags));
+		if (TokenList[include_where]->size()<=(sizeof("#include <>")-1))
+			{	//! \test Error_include_tiny1.hpp
+				//! \test Error_include_tiny2.hpp
+			message_header(*TokenList[include_where]);
+			INC_INFORM(ERR_STR);
+			INFORM("#include is too small to contain a valid filename; discarding and continuing (C99 6.10.2p2,3/C++98 16.2p2,3)");
+			TokenList.DeleteIdx(include_where);
+			zcc_errors.inc_error();
+			i = include_where;
+			if (i<TokenList.size()) goto RestartAfterInclude;
+			return;
+			}
+		// already preprocessed, fortunately
+		bool local_include = false;
+		size_t filename_len = TokenList[include_where]->size()-(sizeof("#include <>")-1);
+		switch(TokenList[include_where]->data()[sizeof("#include ")-1])
+		{
+		case '"':	{	// local-include
+					if ('"'!=TokenList[include_where]->back())
+						{	//! \test Error_include_unterminated2.hpp
+						message_header(*TokenList[include_where]);
+						INC_INFORM(ERR_STR);
+						INFORM("#include \"... does not terminate properly; discarding and continuing (C99 6.10.2p3/C++98 16.2p3)");
+						TokenList.DeleteIdx(include_where);
+						zcc_errors.inc_error();
+						i = include_where;
+						if (i<TokenList.size()) goto RestartAfterInclude;
+						return;
+						};
+					local_include = true;
+					break;
+					}
+		case '<':	{	// system-include
+					if ('>'!=TokenList[include_where]->back())
+						{	//! \test Error_include_unterminated1.hpp
+						message_header(*TokenList[include_where]);
+						INC_INFORM(ERR_STR);
+						INFORM("#include <... does not terminate properly; discarding and continuing (C99 6.10.2p2/C++98 16.2p2)");
+						TokenList.DeleteIdx(include_where);
+						zcc_errors.inc_error();
+						i = include_where;
+						if (i<TokenList.size()) goto RestartAfterInclude;
+						return;
+						};
+					break;
+					}
+		default:	{	// neither
+					message_header(*TokenList[include_where]);
+					INC_INFORM(ERR_STR);
+					INFORM("#include has bad format; discarding and continuing (C99 6.10.2p2,3/C++98 16.2p2,3)");
+					TokenList.DeleteIdx(include_where);
+					zcc_errors.inc_error();
+					i = include_where;
+					if (i<TokenList.size()) goto RestartAfterInclude;
+					return;
+					}
+		};
+		// iterate through search path until something found matching
+		// need to map following
+		// * filename given from #include
+		// * full path that actually finds the file, or positive failure to find (AtomicString)
+		// * cached content (probably separate indexing on full-path), if not include-guarded
+		// * whether include-guarded #define; if so, what the include-guard macro is...
+		// * whether the subject of a pragma-once
+		// We need a de-facto stack for the "most recent include dirctory" to deal with local includes
+#define CPP_INCLUDE_NOT_FOUND 1U
+
+		autovalarray_ptr<Token<char>* > IncludeTokenList;
+		const char* const look_for = register_substring(TokenList[include_where]->data()+sizeof("#include <")-1,filename_len);
+		assert(filename_len==strlen(look_for));
+		if (local_include)
+			{	// #include "..." prohibits interior "
+			if (strchr(look_for,'"'))
+				{	//! \test Error_include_multiterminated2.hpp
+				message_header(*TokenList[include_where]);
+				INC_INFORM(ERR_STR);
+				INFORM("#include \"...\" contains \"; discarding and continuing (C99 6.10.2p3/C++98 16.2p3)");
+				TokenList.DeleteIdx(include_where);
+				zcc_errors.inc_error();
+				i = include_where;
+				if (i<TokenList.size()) goto RestartAfterInclude;
+				return;
+				}
+			}
+		else if (strchr(look_for,'>')) // #include <...> prohibits interior >
+			{	//! \test Error_include_multiterminated1.hpp
+			message_header(*TokenList[include_where]);
+			INC_INFORM(ERR_STR);
+			INFORM("#include <...> contains >; discarding and continuing (C99 6.10.2p2/C++98 16.2p2)");
+			TokenList.DeleteIdx(include_where);
+			zcc_errors.inc_error();
+			i = include_where;
+			if (i<TokenList.size()) goto RestartAfterInclude;
+			return;
+			};
+
+		errr have_file_index = binary_find(look_for, filename_len, include_file_index);
+		// system includes use their handle for information.
+		//! \todo rewrite this to support the #include_next extension?
+		if (0<=have_file_index)
+			{	// already have this one....
+			if (CPP_INCLUDE_NOT_FOUND==include_file_index[have_file_index].third)
+				{	// don't error again....
+				TokenList.DeleteIdx(include_where);
+				i = include_where;
+				if (i<TokenList.size()) goto RestartAfterInclude;
+				return;
+				}
+			assert(NULL!=include_file_index[have_file_index].second);
+			const errr cache_index = binary_find(include_file_index[have_file_index].second, strlen(include_file_index[have_file_index].second),include_file_cache);
+			assert(0<=cache_index);
+			IncludeTokenList = *include_file_cache[cache_index].second;
+		 	}
+		else{
+			char buf[FILENAME_MAX];
+			const char* main_index_name = NULL;
+			// note: local_include needs to know where to start...
+			bool found_file = local_include && find_local_include(look_for, buf, (TokenList[include_where]->parent_dir ? TokenList[include_where]->parent_dir : "."));
+			bool hardcoded_header = false;
+			if (found_file)
+				{	// filepath known; local includes use the calculated path for information
+				main_index_name = register_string(buf);
+				have_file_index = binary_find(main_index_name, strlen(main_index_name), include_file_index);
+				if (0<=have_file_index)
+					{
+					assert(CPP_INCLUDE_NOT_FOUND!=include_file_index[have_file_index].third);
+					const errr cache_index = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
+					assert(0<=cache_index);
+					IncludeTokenList = *include_file_cache[cache_index].second;
+					}
+				else{	// filepath known; inhale and set up cache
+					if (!load_sourcefile(IncludeTokenList,buf,lang)) throw std::bad_alloc();
+					// backfit SourceFile... to look_for; parent_dir to parent directory of file in buf
+					if (!IncludeTokenList.empty())
+						{
+						char parent_path[FILENAME_MAX];
+						z_dirname(parent_path,buf);
+						const char* const parent_dir = register_string(parent_path);
+						size_t j = IncludeTokenList.size();
+						do	{
+							IncludeTokenList[--j]->src_filename = look_for;
+							IncludeTokenList[j]->parent_dir = parent_dir;
+							}
+						while(0<j);
+						};
+					// set up include_file_index, include_file_cache
+					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(have_file_index);
+					const errr cache_index = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
+					const size_t include_file_cache_target = BINARY_SEARCH_DECODE_INSERTION_POINT(cache_index);
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_cache.insertNSlotsAt(1,include_file_cache_target);
+					include_file_cache[include_file_cache_target].second = new autovalarray_ptr<Token<char>* >(IncludeTokenList);
+					include_file_cache[include_file_cache_target].first = main_index_name;
+					include_file_index[include_file_index_target].first = main_index_name;
+					include_file_index[include_file_index_target].second = main_index_name;
+					include_file_index[include_file_index_target].third = 0;
+					}
+				}
+			else{	// we're having to process it as a system include.
+				errr tmp = 0;
+				// C99 7.1.2p4 and C++98 17.3.3.1.1p2 both prohibit having any keywords defined as macros when including a library header.
+				// C++0x 17.4.3.2.2 goes further and simply prohibits defining any keywords as macros.  Oops.
+				// C0x appears to be conserving C99 exactly.
+				// We undefine the offending macros as well as erroring, mainly to prevent duplicate error messages
+				// C99 doesn't care about such defines *after* the header; C++98 does.
+				//! \test cpp/default/keywords/Error_*.h
+				if (Lang::C==lang_code && 0<lang.pp_support->LengthOfSystemHeader(look_for))
+					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+
+				const unsigned int hardcoded_header_idx = detect_hardcoded_system_header(look_for,lang_code);
+				switch(hardcoded_header_idx)
+				{
+#ifndef NDEBUG
+				default: FATAL("hardcoded_header_idx out of range");
+#endif
+				case 3:	{	// stdint.h/cstdint
+					hardcoded_header = true;
+					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+					if (0>binary_find("__STDINT_H__",sizeof("__STDINT_H__")-1,macros_object))	
+						create_stdint_header(IncludeTokenList,look_for);	// not included yet
+					break;
+					}
+				case 2:	{	// stddef.h/cstddef
+					hardcoded_header = true;
+					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+					if (0>binary_find("__STDDEF_H__",sizeof("__STDDEF_H__")-1,macros_object))	
+						create_stddef_header(IncludeTokenList,look_for);	// not included yet
+					break;
+					}
+				case 1:	{	// limits.h/climits
+					hardcoded_header = true;
+					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+					if (0>binary_find("__LIMITS_H__",sizeof("__LIMITS_H__")-1,macros_object))	
+						create_limits_header(IncludeTokenList,look_for);	// not included yet
+					break;
+					}
+				case 0:;
+				}
+
+				found_file = !hardcoded_header && find_system_include(look_for, buf);
+				if (found_file)
+					{	// filepath known; inhale and set up cache
+					if (!load_sourcefile(IncludeTokenList,buf,lang)) throw std::bad_alloc();
+					// backfit SourceFile... to look_for; parent_dir to parent directory of file in buf
+					if (!IncludeTokenList.empty())
+						{
+						char parent_path[FILENAME_MAX];
+						z_dirname(parent_path,buf);
+						const char* const parent_dir = (!strcmp(parent_path,origin_dir)) ? origin_dir : register_string(parent_path);
+						size_t j = IncludeTokenList.size();
+						do	{
+							IncludeTokenList[--j]->src_filename = look_for;
+							IncludeTokenList[j]->parent_dir = parent_dir;
+							}
+						while(0<j);
+						};
+					main_index_name = register_string(buf);
+					// set up include_file_index, include_file_cache
+					tmp = binary_find(look_for,filename_len,include_file_index);
+					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
+					tmp = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
+					const size_t include_file_cache_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_cache.insertNSlotsAt(1,include_file_cache_target);
+					include_file_cache[include_file_cache_target].second = new autovalarray_ptr<Token<char>* >(IncludeTokenList);
+					include_file_cache[include_file_cache_target].first = main_index_name;
+					include_file_index[include_file_index_target].first = look_for;
+					include_file_index[include_file_index_target].second = main_index_name;
+					include_file_index[include_file_index_target].third = 0;
+					}
+				else if (!hardcoded_header)
+					{	// not there at all...
+					// set up include_file_index
+					tmp = binary_find(look_for,filename_len,include_file_index);
+					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_index[include_file_index_target].first = look_for;
+					include_file_index[include_file_index_target].second = NULL;
+					include_file_index[include_file_index_target].third = CPP_INCLUDE_NOT_FOUND;
+
+					message_header(*TokenList[include_where]);
+					INC_INFORM(ERR_STR);
+					INFORM("#include'd file not found; discarding and continuing");
+					TokenList.DeleteIdx(include_where);
+					zcc_errors.inc_error();
+					i = include_where;
+					if (i<TokenList.size()) goto RestartAfterInclude;
+					return;
+					}
+				}
+			}
+#undef CPP_INCLUDE_NOT_FOUND
+		//! also tested in a number of data transform tests
+		//! \test Pass_include_local.hpp
+		if (!IncludeTokenList.empty())
+			{	// not sure whether C99 5.1.1.2 4 requires preprocessing the whole header before pasting, but it permits it
+				// this implies:
+				// * conditional-compilation directives must be balanced for each file
+				// * #line directives never escape files anyway
+			++include_level;
+			_preprocess(IncludeTokenList, locked_macros, macros_object, macros_object_expansion, macros_object_expansion_pre_eval, macros_function, macros_function_arglist, macros_function_expansion, macros_function_expansion_pre_eval, include_file_index, include_file_cache, min_types);
+			--include_level;
+			if (!IncludeTokenList.empty())
+				{
+				size_t j = IncludeTokenList.size();
+				TokenList.insertNSlotsAt(j,include_where+1);
+				memmove(TokenList.c_array()+include_where+1,IncludeTokenList.data(),j*sizeof(Token<char*>*));
+#ifdef ZAIMONI_NULL_REALLY_IS_ZERO
+				memset(IncludeTokenList.c_array(),0,j*sizeof(Token<char*>*));
+#else
+				std::fill(IncludeTokenList.begin(),IncludeTokenList.end(),NULL)
+#endif
+				}
+			}
+
+		// XXX fallthrough hack XXX
+		TokenList.DeleteIdx(include_where);
+		i = include_where;
+		if (i<TokenList.size()) goto RestartAfterInclude;
+//		return;
+		}
+}
+
+bool
+CPreprocessor::raw_system_include(const char* const look_for, autovalarray_ptr<Token<char>* >& IncludeTokenList) const
+{
+	char buf[FILENAME_MAX];
+	// raw system include has minimal macro context, so don't worry about legality check
+
+	switch(detect_hardcoded_system_header(look_for,lang_code))
+	{
+#ifndef NDEBUG
+	default: FATAL("detect_hardcoded_system_header() return value out of 0..3 range");
+#endif
+	case 1:	// header is limits.h/climits
+		create_limits_header(IncludeTokenList,look_for);	// not included yet
+		return true;
+	case 2:	// header is stddef.h/cstddef
+		create_stddef_header(IncludeTokenList,look_for);	// not included yet
+		return true;
+	case 3:	// header is stdint.h/cstdint
+		create_stdint_header(IncludeTokenList,look_for);	// not included yet
+		return true;
+	case 0:;
+	}
+
+	if (find_system_include(look_for, buf))
+		return load_raw_sourcefile(IncludeTokenList,buf);
+	return false;
+}
+
+unsigned int
+CPreprocessor::interpret_pragma(const char* const x, size_t x_len, autovalarray_ptr<char*>& locked_macros)
+{
+	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
+	lang.line_lex(x, x_len, pretokenized);
+
+	const errr valid_pragma_class = linear_find_lencached(x+pretokenized[0].first, pretokenized[0].second, accept_pragma_leading_tokens, STATIC_SIZE(accept_pragma_leading_tokens));
+	if (PRAGMA_LEADING_ZCC==valid_pragma_class)
+		{
+		if (1<pretokenized.size())
+			{
+#/*cut-cpp*/
+			BOOST_STATIC_ASSERT(RELAY_ZCC_ENABLE_TYPEID==STATIC_SIZE(pragma_STDC_on_off_switch)*STATIC_SIZE(pragma_STDC_keywords));
+#/*cut-cpp*/
+			const errr ZCC_pragma =  linear_find_lencached(x+pretokenized[1].first, pretokenized[1].second, pragma_ZCC_keywords, STATIC_SIZE(pragma_ZCC_keywords));
+			switch(ZCC_pragma)
+			{
+#/*cut-cpp*/
+			// #pragma ZCC enable_typeid gets rewritten to the 
+			// reserved-to-the-implementation keyword 
+			// _ZCC_pragma_enable_typeid, which in turn turns off the syntax
+			// errors for typeid .  We use this convolution so that we don't
+			// instantly break other compilers inadvertently using our 
+			// #include <typeinfo>
+			case PRAGMA_ZCC_ENABLE_TYPEID: return STATIC_SIZE(pragma_STDC_on_off_switch)*STATIC_SIZE(pragma_STDC_keywords)+1;				
+#/*cut-cpp*/
+			case PRAGMA_ZCC_LOCK:
+				{	//! \test Error_undef_locked_macro.hpp
+				size_t j = pretokenized.size();
+				while(2<j)
+					{
+					if (C_TESTFLAG_IDENTIFIER!=pretokenized[--j].third) continue;
+					char* tmp = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(pretokenized[j].second));
+					strncpy(tmp,x+pretokenized[j].first,pretokenized[j].second);
+					if (!locked_macros.InsertSlotAt(locked_macros.size(),tmp))
+						{
+						_flush(tmp);
+						throw std::bad_alloc();
+						}
+					}
+				}
+			}
+			}
+		return 0;
+		}
+	else if (PRAGMA_LEADING_STDC==valid_pragma_class)
+		{
+		if (1<pretokenized.size())
+			{
+			const errr STDC_pragma =  linear_find_lencached(x+pretokenized[1].first, pretokenized[1].second, pragma_STDC_keywords, STATIC_SIZE(pragma_STDC_keywords));
+			if (0<=STDC_pragma)
+				{	// found something we know
+				switch(STDC_pragma)
+				{
+#ifndef NDEBUG
+				default:
+					{
+					INC_INFORM(ERR_STR);
+					INC_INFORM("unhandled STDC pragma ");
+					INFORM(pragma_STDC_keywords[STDC_pragma].first);
+					zcc_errors.inc_error();
+					return 0;
+					};
+#endif
+				case PRAGMA_STDC_FP_CONTRACT:
+				case PRAGMA_STDC_FENV_ACCESS:
+				case PRAGMA_STDC_CX_LIMITED_RANGE:
+					{
+					//! \test cpp/Pragma.C99/Error_CX_LIMITED_RANGE1.hpp, cpp/Pragma.C99/Error_CX_LIMITED_RANGE1.h
+					//! \test cpp/Pragma.C99/Error_CX_LIMITED_RANGE2.hpp, cpp/Pragma.C99/Error_CX_LIMITED_RANGE2.h
+					//! \test cpp/Pragma.C99/Error_FENV_ACCESS1.hpp, cpp/Pragma.C99/Error_FENV_ACCESS1.h
+					//! \test cpp/Pragma.C99/Error_FENV_ACCESS2.hpp, cpp/Pragma.C99/Error_FENV_ACCESS2.h
+					//! \test cpp/Pragma.C99/Error_FP_CONTRACT1.hpp, cpp/Pragma.C99/Error_FP_CONTRACT1.h
+					//! \test cpp/Pragma.C99/Error_FP_CONTRACT2.hpp, cpp/Pragma.C99/Error_FP_CONTRACT2.h
+					const errr on_off_switch = (3==pretokenized.size()) ? linear_find_lencached(x+pretokenized[2].first, pretokenized[2].second, pragma_STDC_on_off_switch, STATIC_SIZE(pragma_STDC_on_off_switch)) : -2;
+					if (0>on_off_switch)
+						{
+						INC_INFORM(ERR_STR);
+						INC_INFORM("invalid STDC pragma ");
+						INFORM(x,x_len);
+						zcc_errors.inc_error();
+						return 0;
+						}
+					// valid STDC pragma: relay encoding out
+					return STATIC_SIZE(pragma_STDC_on_off_switch)*STDC_pragma+on_off_switch+1;
+					};
+				}
+			}
+			}
+		return 0;
+		}
+	else if (PRAGMA_MESSAGE==valid_pragma_class)
+		{
+		if (	4==pretokenized.size()
+			&&	1==pretokenized[1].second && '('==x[pretokenized[1].first]
+			&&	1==pretokenized[3].second && ')'==x[pretokenized[3].first]
+			&&	C_TESTFLAG_STRING_LITERAL==pretokenized[2].third)
+			{
+			// hmm...do we need to unescape anything...
+			const bool wide_str = 'L'==x[pretokenized[2].first];
+			if (0<std::count(x+pretokenized[2].first,x+pretokenized[2].first+pretokenized[2].second,'\\'))
+				{	// no escapes
+				if (wide_str) return 0; //! \todo this should do a proper unescape to UNICODE, then use a wrapper library to push the UNICODE to whatever wide-char support there is
+
+				//! \todo change target, this only handles target CHAR_BIT<=host CHAR_BIT
+				const size_t tmp_len = lang.UnescapeStringLength(x+pretokenized[2].first,pretokenized[2].second);
+				char* tmp = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(tmp_len));
+				if (NULL!=tmp)
+					{
+					lang.UnescapeString(tmp,x+pretokenized[2].first,pretokenized[2].second);
+					INFORM(tmp,tmp_len);
+					_flush(tmp);
+					return 0;
+					}
+				};
+			// no escapes, or formatting failed: do something
+			if (wide_str)
+				INFORM(x+pretokenized[2].first+2,pretokenized[2].second-3);
+			else
+				INFORM(x+pretokenized[2].first+1,pretokenized[2].second-2);
+			}
+		return 0;
+		}
+	return 0;
+}
+
+static void _complete_string_character_literal(Token<char>& x,const char delim, const char* const end_error)
+{
+	if (delim==x.back()) return;
+	message_header2(x,x.original_line.second);
+	INC_INFORM(ERR_STR);
+	INC_INFORM("unterminated");
+	if ('L'==x.front()) INC_INFORM(" wide");
+	INFORM(end_error);
+	zcc_errors.inc_error();
+	x.append(delim);
+}
+
+static void complete_string_character_literal(Token<char>& x)
+{
+	if (C_TESTFLAG_STRING_LITERAL==x.flags)
+		//! \test Error_unterminated1.hpp
+		//! \test Error_unterminated2.hpp
+		_complete_string_character_literal(x,'"'," string literal.  Terminating. (C99 6.4.5p1/C++98 2.13.4)");
+	else if (C_TESTFLAG_CHAR_LITERAL==x.flags)
+		//! \test Error_unterminated3.hpp
+		//! \test Error_unterminated4.hpp
+		_complete_string_character_literal(x,'\''," character literal.  Terminating. (C99 6.4.4.4p1/C++98 2.13.2)");
+}
+
+size_t
+CPreprocessor::tokenize_line(autovalarray_ptr<Token<char>* >& TokenList, size_t i) const
+{
+	assert(TokenList.size()>i);
+	if (TokenList[i]->empty())
+		{
+		TokenList.DeleteIdx(i);
+		return 0;
+		};
+
+	// Not really (it's a preprocessing directive), but we don't want to damage it here
+	if ('#'==TokenList[i]->front()) return 1;
+
+	//! \test Error_naked_VA_ARGS.hpp
+	if (!TokenList[i]->flags) C99_VA_ARGS_flinch(*TokenList[i],0);
+
+	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
+	lang.line_lex(TokenList[i]->data(),TokenList[i]->size(),pretokenized);
+	if (pretokenized.empty())
+		{
+		TokenList.DeleteIdx(i);
+		return 0;
+		}
+
+	size_t ub = pretokenized.size()-1;
+	if (0==ub)
+		{
+		if (!TokenList[i]->flags) TokenList[i]->flags = pretokenized[ub].third;
+		// handle trailing whitespace
+		if (ZAIMONI_LEN_WITH_NULL(pretokenized[ub].second)<TokenList[i]->size())
+			TokenList[i]->lslice(pretokenized[ub].second);
+		complete_string_character_literal(*TokenList[i]);
+		}
+	else{
+		size_t lb = 0;
+		autovalarray_ptr_throws<Token<char>* > TokenListAlt(ub+1);
+		TokenList.insertNSlotsAt(ub,i+1);
+		{
+		const Token<char>& tmp = *TokenList[i];
+		while(lb<ub)
+			{
+			if (pretokenized[lb].second<=pretokenized[ub].second)
+				{	// first token not longer
+				TokenListAlt[lb] = new Token<char>(tmp,pretokenized[lb].first,pretokenized[lb].second,pretokenized[lb].third);
+				complete_string_character_literal(*TokenListAlt[lb++]);
+				}
+			else{	// second token longer
+				TokenListAlt[ub] = new Token<char>(tmp,pretokenized[ub].first,pretokenized[ub].second,pretokenized[ub].third);
+				complete_string_character_literal(*TokenListAlt[ub--]);
+				}
+			}
+		}
+		// strip down TokenList[i] to a largest token
+		TokenListAlt[lb] = TokenList[i];
+		TokenList[i] = NULL;
+		TokenListAlt[lb]->trim(pretokenized[lb].first,TokenListAlt[lb]->size()-(pretokenized[lb].first+pretokenized[lb].second));
+		TokenListAlt[lb]->flags = pretokenized[lb].third;
+		complete_string_character_literal(*TokenListAlt[lb]);
+		memmove(TokenList.c_array()+i,TokenListAlt.data(),TokenListAlt.size()*sizeof(*TokenListAlt.data()));
+#ifdef ZAIMONI_NULL_REALLY_IS_ZERO
+		memset(TokenListAlt.c_array(),0,TokenListAlt.size()*sizeof(*TokenListAlt.data()));
+#else
+		std::fill(TokenListAlt.begin(),TokenListAlt.end(),NULL);
+#endif
+		}
+	return pretokenized.size();
+}
+
+/*! 
+ * finds a local include file
+ * 
+ * \param src : string describing file to find
+ * \param filepath_buf : pointer to character buffer of length FILENAME_MAX
+ * 
+ * \return true if and only if a filepath was found.
+ */
+bool
+CPreprocessor::find_local_include(const char* const src, char* const filepath_buf, const char* const local_root) const
+{
+	char image_filepath[FILENAME_MAX];
+	char test_filepath[FILENAME_MAX];
+
+	assert(!is_empty_string(src));
+	assert(!is_empty_string(local_root));
+	assert(NULL!=filepath_buf);
+	const size_t src_len = strlen(src);
+
+	// automatically fail anything that won't fit in FILENAME_MAX
+	//! \test Error_huge_path.hpp
+	if (FILENAME_MAX<=src_len) return false;
+
+	if (NULL!=origin_dir)
+		{
+		size_t target_length = strlen(origin_dir);
+		assert(FILENAME_MAX>target_length);
+		strcpy(test_filepath,origin_dir);
+		if (FILENAME_MAX<=target_length+(sizeof(ZAIMONI_PATH_SEP)-1)+src_len) return false;	// safe only because FILENAME_MAX is small
+		strcpy(test_filepath+target_length,ZAIMONI_PATH_SEP);
+		target_length += (sizeof(ZAIMONI_PATH_SEP)-1);
+		strcpy(test_filepath+target_length,src);
+#if ZAIMONI_PATH_SEP_CHAR!='/'
+		// path separator not POSIX, Z.C++ requires POSIX path separator for #include
+		//! \todo: actively reject non-POSIX file separators?
+		std::replace(test_filepath+target_length,test_filepath+target_length+src_len,'/',ZAIMONI_PATH_SEP_CHAR);
+#endif
+		}
+	else{	// ahem...hope that we haven't relocated yet...
+		strncpy(test_filepath,src,src_len);
+#if ZAIMONI_PATH_SEP_CHAR!='/'
+		// path separator not POSIX, Z.C++ requires POSIX path separator for #include
+		//! \todo: actively reject non-POSIX file separators?
+		std::replace(test_filepath,test_filepath+src_len,'/',ZAIMONI_PATH_SEP_CHAR);
+#endif
+		}
+	const char* const canonical_path = z_realpath(image_filepath,test_filepath);
+	if (NULL!=canonical_path && !access(canonical_path,F_OK))
+		{
+		strcpy(filepath_buf,canonical_path);
+		return true;
+		}
+	//! \todo react to local search path options as well
+	//! \test Error_include_nonexistent2.hpp
+	return false;
+}
+
+/*! 
+ * finds a system include file
+ * 
+ * \param src : string describing file to find
+ * \param filepath_buf : pointer to character buffer of length FILENAME_MAX
+ * 
+ * \return true if and only if a filepath was found.
+ */
+bool
+CPreprocessor::find_system_include(const char* const src, char* const filepath_buf) const
+{
+	char image_filepath[FILENAME_MAX];
+	char test_filepath[FILENAME_MAX];
+
+	assert(!is_empty_string(src));
+	assert(NULL!=filepath_buf);
+	const size_t src_len = strlen(src);
+	// automatically fail anything that won't fit in FILENAME_MAX
+	//! \test Error_huge_path.hpp
+	if (FILENAME_MAX<=src_len) return false;
+
+	// we do casual chroot-jailing of system includes
+
+	// disallow change to parent directory.  *NIX system symlinks mean we can't tolerate them even when balanced properly for Windows.
+	if (sizeof("..")-1<=src_len)
+		{
+		const char* parent_dir_candidate = strstr(src,"..");
+		if (src==parent_dir_candidate)
+			{
+			//! \test Error_chroot_jail1.hpp
+			if (sizeof("..")-1==src_len) return false;
+			//! \test Error_chroot_jail2.hpp
+			if ('/'==src[sizeof("..")-1]) return false;
+			parent_dir_candidate = strstr(parent_dir_candidate+(sizeof("..")-1),"..");
+			}
+		while(NULL!=parent_dir_candidate && src_len>=(parent_dir_candidate-src)+(sizeof("..")-1))
+			{
+			//! \test Error_chroot_jail3.hpp
+			if ('/'==parent_dir_candidate[-1]) return false;
+			parent_dir_candidate = (src_len==parent_dir_candidate-src+(sizeof("..")-1)) ? NULL : strstr(parent_dir_candidate+(sizeof("..")-1),"..");
+			}
+		}	
+
+	//!\todo react to system search path options as well
+
+	// check hard-coded search path options
+	// \todo more robust multi-language architecture
+	//! \test Pass13.hpp
+	size_t i = (Lang::C==lang_code) ? START_CPP_ONLY_PATHS : 0;
+	do	if (actual_system_include_search[i])
+			{
+			size_t target_length = strlen(actual_system_include_search[i]);
+			assert(FILENAME_MAX>target_length);
+			strcpy(test_filepath,actual_system_include_search[i]);
+			if (FILENAME_MAX<=target_length+(sizeof(ZAIMONI_PATH_SEP)-1)+src_len) continue;	// safe only because FILENAME_MAX is small
+			strcpy(test_filepath+target_length,ZAIMONI_PATH_SEP);
+			target_length += (sizeof(ZAIMONI_PATH_SEP)-1);
+			strcpy(test_filepath+target_length,src);
+#if ZAIMONI_TARGET_FILESYSTEM!=ZAIMONI_TARGET_FILESYSTEM_POSIX
+			// path separator not POSIX, ZCC requires POSIX path separator for #include
+			//! \todo: actively reject non-POSIX file separators?
+			std::replace(test_filepath+target_length,test_filepath+target_length+src_len,'/',ZAIMONI_PATH_SEP_CHAR);
+#endif
+			const char* const canonical_path = z_realpath(image_filepath,test_filepath);
+			if (NULL!=canonical_path && !access(canonical_path,F_OK))
+				{
+				strcpy(filepath_buf,canonical_path);
+				return true;
+				}
+			}
+	while(STATIC_SIZE(actual_system_include_search) > ++i);
+
+	return false;	//! \test Error_include_nonexistent1.hpp
+}
+
+/*! 
+ * indicates whether the definedness of the macro is context-free
+ * 
+ * \param x C string to test for macro-hood
+ * \param x_len length of C string
+ * 
+ * \return 1 if unconditionally defined; -1 if unconditionally undefined; 0 if need to preprocess to find out
+ */
+int
+CPreprocessor::context_free_defined(const char* const x, size_t x_len) const
+{
+	assert(NULL!=x);
+	assert(0<x_len);
+	if (0<=linear_find(x, x_len, macro_identifier_default, macro_identifier_default_count)) return 1;
+	// report "magic macros" as defined if the master preprocessor does
+	if (sizeof("__has_include")-1==x_len && !strncmp(x,"__has_include",x_len)) return 1;	// CLang says predefined
+	if (hard_locked_macro(x,x_len)) return -1;
+	return 0;
+}
+
+static bool
+macro_is_defined(const char* const x, const size_t x_len, const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<char*>& macros_function)
+{
+	assert(NULL!=x);
+	assert(0<x_len);
+#ifdef NDEBUG
+	return 0<=binary_find(x,x_len,macros_object) || 0<=binary_find(x,x_len,macros_function);
+#else
+	const errr object_macro_index = binary_find(x,x_len,macros_object);
+	const errr function_macro_index = binary_find(x,x_len,macros_function);
+	assert(0>object_macro_index || 0>function_macro_index);
+	return 0<=object_macro_index || 0<=function_macro_index;
+#endif
+}
+
+bool
+CPreprocessor::ifdef_ifndef_syntax_ok(Token<char>& x, const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<char*>& macros_function)
+{
+	assert(3<=x.size());
+	assert('#'==x.front());
+	const unsigned int if_directive = UNPACK_DIRECTIVE(x.flags);
+	assert(PP::IFDEF==if_directive || PP::IFNDEF==if_directive);
+	assert(!strncmp(x.data()+1,valid_directives[if_directive].first,valid_directives[if_directive].second));
+	lex_flags token_flags;
+
+	//! \test ifdef.C99/Error_noarg.hpp
+	//! \test ifdef.C99/Error_noarg2.hpp
+	if (!strcmp(x.data()+1,valid_directives[if_directive].first))
+		{
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INC_INFORM("#");
+		INC_INFORM(valid_directives[if_directive].first);
+		INFORM(" has no control expression. (C99 6.10p1/C++98 16p1)");
+		zcc_errors.inc_error();
+		return false;
+		};
+
+	const size_t critical_offset = valid_directives[if_directive].second+2;
+	assert(x.size()>critical_offset);
+	//! \todo : let this slide as a warning with new --do-what-i-mean option
+	C99_VA_ARGS_flinch(x,critical_offset);	// __VA_ARGS__ is known to be undefined, result would be well-defined anyway
+
+	const size_t token_len = lang.UnfilteredNextToken(x.data()+critical_offset,token_flags);
+	if (C_TESTFLAG_IDENTIFIER!=token_flags)
+		{	//! \test ifdef.C99/Error_nonidentifer.h
+			//! \test ifdef.C99/Error_nonidentifer.hpp
+			//! \test ifdef.C99/Error_nonidentifer2.h
+			//! \test ifdef.C99/Error_nonidentifer2.hpp
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INC_INFORM("#");
+		INC_INFORM(valid_directives[if_directive].first);
+		INFORM(" is not applied to an identifier. (C99 6.10p1/C++98 16p1)");
+		zcc_errors.inc_error();
+		return false;
+		};
+	if (x.size()-critical_offset>token_len)
+		{
+		const size_t skip_ws = strspn(x.data()+critical_offset+token_len,lang.WhiteSpace+1);
+		if (x.size()-(critical_offset+token_len)>skip_ws)
+			{	//! \test ifdef.C99/Error_extra.h
+				//! \test ifdef.C99/Error_extra.hpp
+				//! \test ifdef.C99/Error_extra2.h
+				//! \test ifdef.C99/Error_extra2.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INC_INFORM("#");
+			INC_INFORM(valid_directives[if_directive].first);
+			INFORM(" has illegal tokens following its identifier. (C99 6.10p1/C++98 16p1)");
+			zcc_errors.inc_error();
+			return false;
+			}
+		x.rtrim(skip_ws);
+		};
+
+	//! \test Pass_macro_STDC.h
+	//! \test Pass_macro_STDC.hpp
+	switch(context_free_defined(x.data()+critical_offset,token_len))
+	{
+	case 1:		{	// found it
+				x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 1" : "#if 0");
+				PACK_DIRECTIVE(x.flags,PP::IF);
+				return true;
+				}
+	case -1:	{	// hard-locked, not defined : ergo, undefined
+				x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 0" : "#if 1");
+				PACK_DIRECTIVE(x.flags,PP::IF);
+				return true;
+				}
+	};
+
+	// exercised heavily by the standard library include tests
+	if (macro_is_defined(x.data()+critical_offset, token_len,macros_object,macros_function))
+		{	// found it
+		x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 1" : "#if 0");
+		PACK_DIRECTIVE(x.flags,PP::IF);
+		return true;
+		}
+	else{	// not found, not a predefined: not defined
+		x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 0" : "#if 1");
+		PACK_DIRECTIVE(x.flags,PP::IF);
+		return true;
+		}
+}
+
+static POD_pair<size_t,size_t> balanced_character_count(const char* const x, const autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized,const char l_match,const char r_match)
+{
+	POD_pair<size_t,size_t> paren_depth = {0,0};
+	const autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >::const_iterator iter_end = pretokenized.end();
+	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >::const_iterator iter = pretokenized.begin();
+	assert(NULL!=x);
+	if (iter!=iter_end)
+		do	if (1==iter->second)
+				{
+				if 		(l_match==x[iter->first]) ++paren_depth.first;
+				else if (r_match==x[iter->first]) ++paren_depth.second;
+				}
+		while(++iter!=iter_end);
+	return paren_depth;
+}
+
+// This should notice zero errors, thanks to a prior context-free check
+static void _construct_matched_pairs(const Token<char>& x, const autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized, autovalarray_ptr<POD_pair<size_t,size_t> >& pair_stack,const char l_match,const char r_match)
+{
+	POD_pair<size_t,size_t> depth = balanced_character_count(x.data(),pretokenized,l_match,r_match);	// pre-scan
+	DEBUG_STATEMENT(size_t err_count = 0;)
+	if (0<depth.first && 0<depth.second)
+		{
+		// reality-check: balanced parentheses
+		autovalarray_ptr_throws<size_t> lparen_fixedstack(depth.first);
+		autovalarray_ptr_throws<POD_pair<size_t,size_t> > parenpair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
+		size_t balanced_paren = 0;
+		size_t i = 0;
+
+		depth.first = 0;
+		depth.second = 0;
+		do	if (1==pretokenized[i].second)
+				{
+				if 		(l_match==x.data()[pretokenized[i].first])
+					{
+					if (0<depth.second)
+						{
+						depth.second = 0;
+						DEBUG_STATEMENT(++err_count;)
+						}
+					lparen_fixedstack[depth.first++] = i;
+					}
+				else if (r_match==x.data()[pretokenized[i].first])
+					{
+					if (0<depth.first)
+						{
+						parenpair_fixedstack[balanced_paren].first = lparen_fixedstack[--depth.first];
+						parenpair_fixedstack[balanced_paren++].second = i;
+						}
+					else
+						++depth.second;
+					};
+				}
+		while(pretokenized.size() > ++i);
+		if (0==depth.first && 0==depth.second DEBUG_STATEMENT(&& 0==err_count))
+			{
+			assert(parenpair_fixedstack.size()==balanced_paren);
+			parenpair_fixedstack.MoveInto(pair_stack);
+			}
+		};
+
+	assert(0==depth.first || 0==depth.second);
+	DEBUG_STATEMENT(if (0<depth.second) ++err_count;)
+	DEBUG_STATEMENT(if (0<depth.first) ++err_count;)
+	assert(0==err_count);
+}
+
+template<char l_match,char r_match>
+inline static void construct_matched_pairs(const Token<char>& x, const autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized, autovalarray_ptr<POD_pair<size_t,size_t> >& pair_stack)
+{
+	_construct_matched_pairs(x,pretokenized,pair_stack,l_match,r_match);
+}
+
+template<>
+void construct_matched_pairs<'[',']'>(const Token<char>& x, const autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized, autovalarray_ptr<POD_pair<size_t,size_t> >& pair_stack)
+{
+	POD_pair<size_t,size_t> depth = balanced_character_count(x.data(),pretokenized,'[',']');	// pre-scan
+	DEBUG_STATEMENT(size_t err_count = 0;)
+	if (0<depth.first && 0<depth.second)
+		{
+		// reality-check: balanced parentheses
+		autovalarray_ptr_throws<size_t> lparen_fixedstack(depth.first);
+		autovalarray_ptr_throws<POD_pair<size_t,size_t> > parenpair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
+		size_t balanced_paren = 0;
+		size_t i = 0;
+
+		depth.first = 0;
+		depth.second = 0;
+		do	if 		(detect_C_left_bracket_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+				{
+				if (0<depth.second)
+					{
+					depth.second = 0;
+					DEBUG_STATEMENT(++err_count;)
+					}
+				lparen_fixedstack[depth.first++] = i;
+				}
+			else if (detect_C_right_bracket_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+				{
+				if (0<depth.first)
+					{
+					parenpair_fixedstack[balanced_paren].first = lparen_fixedstack[--depth.first];
+					parenpair_fixedstack[balanced_paren++].second = i;
+					}
+				else
+					++depth.second;
+				}
+		while(pretokenized.size() > ++i);
+		if (0==depth.first && 0==depth.second DEBUG_STATEMENT(&& 0==err_count))
+			{
+			assert(parenpair_fixedstack.size()==balanced_paren);
+			parenpair_fixedstack.MoveInto(pair_stack);
+			}
+		};
+
+	assert(0==depth.first || 0==depth.second);
+	DEBUG_STATEMENT(if (0<depth.second) ++err_count;)
+	DEBUG_STATEMENT(if (0<depth.first) ++err_count;)
+	assert(0==err_count);
+}
+
+static void pairstack_clean(const POD_pair<size_t,size_t>& target, autovalarray_ptr<POD_pair<size_t,size_t> >& pair_stack)
+{
+	autovalarray_ptr<POD_pair<size_t,size_t> >::iterator iter = pair_stack.begin();
+	const autovalarray_ptr<POD_pair<size_t,size_t> >::iterator iter_end = pair_stack.end();
+	if (iter!=iter_end)
+		do	{
+			assert(iter->first<iter->second);
+			if (target.first<iter->first)
+				{
+				if (target.second<iter->first) iter->first -= 1;
+				iter->first -= 1;
+				}
+			if (target.first<iter->second)
+				{
+				if (target.second<iter->second) iter->second -= 1;
+				iter->second -= 1;
+				}
+			}
+		while(++iter!=iter_end);
+}
+
+static void balanced_character_kill(Token<char>& x, autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized, autovalarray_ptr<POD_pair<size_t,size_t> >& parenpair_stack, size_t target_idx)
+{
+	assert(parenpair_stack.size()>target_idx);
+	POD_pair<size_t,size_t> target	= parenpair_stack[target_idx];
+	assert(pretokenized.size()>target.first);
+	assert(pretokenized.size()>target.second);
+	assert(target.first<target.second);
+	assert(1==pretokenized[target.first].second);
+	assert(1==pretokenized[target.second].second);
+	{
+	char* const tmp = x.c_array();
+	tmp[pretokenized[target.first].first] = ' ';
+	tmp[pretokenized[target.second].first] = ' ';
+	}
+	parenpair_stack.DeleteIdx(target_idx);
+	pretokenized.DeleteIdx(target.second);
+	pretokenized.DeleteIdx(target.first);
+	pairstack_clean(target,parenpair_stack);
+}
+
+template<char c>
+static inline bool
+token_is_char(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
+{
+	assert(NULL!=x);
+	return 1==lexed_token.second && c==x[lexed_token.first];
+}
+
+template<>
+inline bool
+token_is_char<'#'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
+{
+	assert(NULL!=x);
+	return detect_C_stringize_op(x+lexed_token.first,lexed_token.second);
+}
+
+template<>
+inline bool
+token_is_char<'['>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
+{
+	assert(NULL!=x);
+	return detect_C_left_bracket_op(x+lexed_token.first,lexed_token.second);
+}
+
+template<>
+inline bool
+token_is_char<']'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
+{
+	assert(NULL!=x);
+	return detect_C_right_bracket_op(x+lexed_token.first,lexed_token.second);
+}
+
+template<>
+inline bool
+token_is_char<'{'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
+{
+	assert(NULL!=x);
+	return detect_C_left_brace_op(x+lexed_token.first,lexed_token.second);
+}
+
+template<>
+inline bool
+token_is_char<'}'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
+{
+	assert(NULL!=x);
+	return detect_C_right_brace_op(x+lexed_token.first,lexed_token.second);
+}
+
+// Closely related to _C99_literal_converts_to_bool/CSupport.cpp
+/*! 
+ * examines a proposed token for whether it is suitable for an #if/#elif control expression, and if so 
+ * 
+ * \param x #if/#elif line
+ * \param lexed_token where the token is
+ * \param is_zero if suitable, set this to true iff token is 0 for purposes of preprocessing
+ * 
+ * \return true iff suitable for an #if/#elif control expression
+ */
+static bool if_elif_control_is_zero(const Token<char>& x, const POD_triple<size_t,size_t,lex_flags>& lexed_token, bool& is_zero)
+{
+	const lex_flags flags = lexed_token.third;
+	if (C_TESTFLAG_CHAR_LITERAL==flags)
+		{	//! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
+			//! \test if.C99/Pass_nonzero.hpp, if.C99/Pass_nonzero.h
+		is_zero = CCharLiteralIsFalse(x.data()+lexed_token.first,lexed_token.second);
+		return true;
+		};
+
+	//! \todo --do-what-i-mean will handle floats as well
+	if (!(C_TESTFLAG_PP_NUMERAL & flags)) return false;
+	C_REALITY_CHECK_PP_NUMERAL_FLAGS(flags);
+	if (C_TESTFLAG_FLOAT & flags) return false;
+	// zeros go to zero, everything else canonicalizes to one
+	//! \test if.C99/Pass_if_zero.hpp, if.C99/Pass_if_zero.h
+	is_zero = C99_integer_literal_is_zero(x.data()+lexed_token.first,lexed_token.second,flags);
+	return true;
+}
+
+/*! 
+ * 
+ * 
+ * \param x overall directive
+ * \param pretokenized token index for overall directive
+ * \param src
+ * \param i start token
+ * \param delta last token offset included in range to be substituted
+ * 
+ * \return bool true if and only if directive obviously completely substituted
+ */
+bool
+CPreprocessor::replace_char_into_directive(Token<char>& x,const autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized,const char src,const size_t i,const size_t delta)
+{
+	if (0==i && delta+1==pretokenized.size())
+		{
+		x.replace_once(std::nothrow,pretokenized[0].first,x.size()-pretokenized[0].first,src);
+		return true;
+		};
+
+	size_t buffer_used = 0;
+	char Buffer[4] = "";
+	if (0<pretokenized[i].first && require_padding(x.data()[pretokenized[i].first-1],src))
+		Buffer[buffer_used++] = ' ';
+	Buffer[buffer_used++] = src;
+	if (x.size()>pretokenized[i+delta].first+pretokenized[i+delta].second && require_padding(src,x.data()[pretokenized[i+delta].first+pretokenized[i+delta].second]))
+		Buffer[buffer_used++] = ' ';
+
+	x.replace_once(std::nothrow,pretokenized[i].first,(pretokenized[i+delta].first-pretokenized[i].first)+pretokenized[i+delta].second,Buffer);
+	return false;
+}
+
+/*
+ * we use goto in CPreprocessor::if_elif_syntax_ok contrary to readable style guidelines
+ *	RetryStringMerge: restart the string-merge stage (should happen only if running short on memory
+ *	OneTokenExit: centralize exit code when down to one token
+ */
+bool
+CPreprocessor::if_elif_syntax_ok(Token<char>& x, const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<Token<char>*>& macros_object_expansion, const autovalarray_ptr<char*>& macros_function, const autovalarray_ptr<Token<char>*>& macros_function_arglist, const autovalarray_ptr<Token<char>*>& macros_function_expansion,const type_system& min_types)
+{
+	const unsigned int if_directive = UNPACK_DIRECTIVE(x.flags);
+	assert(PP::IF==if_directive || PP::ELIF==if_directive);
+	//! \test if.C99/Error_no_arg.hpp, if.C99/Error_no_arg.h : #if no control expression
+	//! \test if.C99/Error_if0_no_arg_elif.hpp, if.C99/Error_if0_no_arg_elif.h : #elif no control expression, critical
+	//! \test if.C99/Error_if1_no_arg_elif.hpp, if.C99/Error_if1_no_arg_elif.h : #elif no control expression, non-critical; could allow this with a do-what-i-mean option
+	if (!strcmp(x.data()+1,valid_directives[if_directive].first))
+		{
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INC_INFORM("#");
+		INC_INFORM(valid_directives[if_directive].first);
+		INFORM(" has no control expression. (C99 6.10p1/C++98 16p1)");
+		zcc_errors.inc_error();
+		return false;
+		};
+
+	// tokenize the whole line
+	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
+	const size_t critical_offset = valid_directives[if_directive].second+2;
+	//! \test if.C99/Error_control2.hpp, if.C99/Error_control2.h (#if)
+	//! \todo __VA_ARGS__ within defined operator should only be a warning with --do-what-i-mean option
+	bool bad_control = C99_VA_ARGS_flinch(x,critical_offset);
+
+	//! \todo decide what to do when more languages are available for preprocessing
+	lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+	STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+
+	// analyze the defined operators
+	size_t i = 0;
+	do	if ((sizeof("defined")-1)==pretokenized[i].second && !strncmp(x.data()+pretokenized[i].first,"defined",(sizeof("defined")-1)))
+			{
+			if (i+1>=pretokenized.size())
+				{	//! \test cpp/defined.C99/Error_malformed1.hpp, cpp/defined.C99/Error_malformed1.h
+				message_header(x);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("malformed defined operator application (C99 6.10.1p1/C++98 16.1p1)");
+				INC_INFORM(x.data()+pretokenized[i].first,pretokenized[i].second);
+				zcc_errors.inc_error();
+				bad_control = true;
+				break;
+				};
+			if (C_TESTFLAG_IDENTIFIER==pretokenized[i+1].third)
+				{	// defined IDENTIFIER -- will evaluate to 0 or 1
+					//! \test cpp/defined.C99/Pass_defined_op.hpp, cpp/defined.C99/Pass_defined_op.h
+				int know_it_now = context_free_defined(x.data()+pretokenized[i+1].first, pretokenized[i+1].second);
+				if (0==know_it_now)
+					know_it_now = (macro_is_defined(x.data()+pretokenized[i+1].first, pretokenized[i+1].second, macros_object, macros_function)) ? 1 : -1;
+				const char subst_dest = (0<know_it_now) ? '1' : '0';
+				if (replace_char_into_directive(x,pretokenized,subst_dest,i,1)) return true;
+				lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+				STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+				continue;
+				}
+			else if (token_is_char<'('>(x.data(),pretokenized[i+1]))
+				{	// defined(IDENTIFIER) [hopefully]
+				if (i+3>=pretokenized.size())
+					{	//! \test defined.C99/Error_malformed3.hpp, defined.C99/Error_malformed3.h
+					message_header(x);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("malformed defined operator application  (C99 6.10.1p1/C++98 16.1p1)");
+					INC_INFORM(x.data()+pretokenized[i].first,pretokenized.back().second+(pretokenized.back().first-pretokenized[i].first));
+					zcc_errors.inc_error();
+					bad_control = true;
+					break;
+					}
+				if (   C_TESTFLAG_IDENTIFIER==pretokenized[i+2].third
+					&& token_is_char<')'>(x.data(),pretokenized[i+3]))
+					{	// defined(IDENTIFIER)
+						//! \test cpp/defined.C99/Pass_defined_op.hpp, cpp/defined.C99/Pass_defined_op.h
+					int know_it_now = context_free_defined(x.data()+pretokenized[i+2].first, pretokenized[i+2].second);
+					if (0==know_it_now)
+						know_it_now = (macro_is_defined(x.data()+pretokenized[i+2].first, pretokenized[i+2].second, macros_object, macros_function)) ? 1 : -1;
+
+					const char subst_dest = (0<know_it_now) ? '1' : '0';
+					if (replace_char_into_directive(x,pretokenized,subst_dest,i,3)) return true;
+					lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+					STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+					continue;
+					};
+				//! \test defined.C99/Error_nonidentifier.hpp, defined.C99/Error_nonidentifier.h
+				//! \test defined.C99/Error_excess_tokens.hpp, defined.C99/Error_excess_tokens.h
+				message_header(x);
+				INC_INFORM(ERR_STR);
+				INC_INFORM("malformed defined operator application  (C99 6.10.1p1/C++98 16.1p1)");
+				INC_INFORM(x.data()+pretokenized[i].first,pretokenized[i+3].second+(pretokenized[i+3].first-pretokenized[i].first));
+				zcc_errors.inc_error();
+				bad_control = true;
+				continue;
+				};
+			//! \test defined.C99/Error_malformed2.hpp, defined.C99/Error_malformed2.h
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INC_INFORM("malformed defined operator application  (C99 6.10.1p1/C++98 16.1p1)");
+			INC_INFORM(x.data()+pretokenized[i].first,pretokenized[i+1].second+(pretokenized[i+1].first-pretokenized[i].first));
+			zcc_errors.inc_error();
+			bad_control = true;
+			continue;
+			}
+	while(pretokenized.size() > ++i);
+
+	// if any identifiers survive, we have to do macro preprocessing to get further
+	if (bad_control) return false;	// but if we discard the block anyway it doesn't matter
+
+	// analyze the __has_include() extension operator (from CLang)
+	i = 0;
+	do	if ((sizeof("__has_include")-1)==pretokenized[i].second && !strncmp(x.data()+pretokenized[i].first,"__has_include",(sizeof("__has_include")-1)))
+			{
+			// if no space for extension, let default flush-to-zero happen silently
+			if (4>pretokenized.size()-i) break;
+			if (!token_is_char<'('>(x.data(),pretokenized[i+1]))
+				// do not trigger __has_include extension
+				continue;
+			// we want: __has_include("...") or __has_include(<...>)
+			if (   C_TESTFLAG_STRING_LITERAL==pretokenized[i+2].third
+				&& '"'==x.data()[pretokenized[i+2].first]
+				&& token_is_char<')'>(x.data(),pretokenized[i+3]))
+				{	// __has_include("...")
+					//! \todo need test cases
+				if (0==pretokenized[i+2].second-2)
+					{	// empty, automatic failure
+					if (replace_char_into_directive(x,pretokenized,'0',i,3)) return true;
+					lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+					STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+					continue;
+					}
+
+				char buf[FILENAME_MAX];
+				char* const look_for = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(pretokenized[i+2].second-2));
+				strncpy(look_for,x.data()+pretokenized[i+2].first+1,pretokenized[i+2].second-2);
+				if (strchr(look_for,'"'))
+					{
+					message_header(x);
+					INFORM("__has_include(\"...\") contains \"; preprocessing per standards rather than invoking extension __has_include");
+					free(look_for);
+					i += 2;
+					continue;
+					};
+				const char subst_dest = (detect_hardcoded_system_header(look_for,lang_code) || find_local_include(look_for, buf, (x.parent_dir ? x.parent_dir : ".")) || find_system_include(look_for, buf)) ? '1' : '0';
+				free(look_for);
+				if (replace_char_into_directive(x,pretokenized,subst_dest,i,3)) return true;
+				lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+				STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+				continue;
+				}
+			//! \todo: optimization check: does testing for < and > by leading/trailing character reduce code size
+			else if (token_is_char<'<'>(x.data(),pretokenized[i+2]))
+				{
+				size_t j = i+2;
+				while(pretokenized.size()-1 > ++j)
+					if (token_is_char<'>'>(x.data(),pretokenized[j]))
+						{	//! \todo need test cases
+						if (!token_is_char<')'>(x.data(),pretokenized[j+1])) break;
+						// __has_include(<...>)
+						if (0==pretokenized[j].first-pretokenized[i+2].first+pretokenized[j].second-2)
+							{	// empty, automatic failure
+							if (replace_char_into_directive(x,pretokenized,'0',i,j+1-i)) return true;
+							lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+							STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+							continue;
+							}
+						char buf[FILENAME_MAX];
+						char* const look_for = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(pretokenized[j].first-pretokenized[i+2].first+pretokenized[j].second-2));
+						strncpy(look_for,x.data()+pretokenized[i+2].first+1,pretokenized[j].first-pretokenized[i+2].first+pretokenized[j].second-2);
+						if (strchr(look_for,'<'))
+							{
+							message_header(x);
+							INFORM("__has_include(<...>) contains <; preprocessing per standards rather than invoking extension __has_include");
+							free(look_for);
+							i += 2;
+							continue;
+							};
+						if (strchr(look_for,'>'))
+							{
+							message_header(x);
+							INFORM("__has_include(<...>) contains >; preprocessing per standards rather than invoking extension __has_include");
+							free(look_for);
+							i += 2;
+							continue;
+							};
+						const char subst_dest = (detect_hardcoded_system_header(look_for,lang_code) || find_system_include(look_for, buf)) ? '1' : '0';
+						free(look_for);
+						if (replace_char_into_directive(x,pretokenized,subst_dest,i,j+1-i)) return true;
+						lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+						STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+						continue;
+						}
+				++i;
+				continue;
+				}
+			// not recognized as __has_include directive, preprocess per standards
+			}
+	while(pretokenized.size() > ++i);
+
+	// if any identifiers survive, we have to do macro preprocessing to get further
+	if (bad_control) return false;	// but if we discard the block anyway it doesn't matter
+
+	intradirective_preprocess(x,valid_directives[if_directive].second+2,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion);
+
+	// if we went invalid do not proceed further
+	if (x.flags & INVALID_DIRECTIVE_FLAG) return false;
+
+	intradirective_flush_identifiers_to_zero(x,valid_directives[if_directive].second+2);
+
+	// ZCC should actually calculate the control expression completely to 0/1  Error reporting for this isn't particularly compatible with destructive-evaluate.
+	// this is for both #if and #elif directives at depth 1
+	// cf. USENET discussion with Eric Sosman @ sun.com on comp.lang.c at Rationale.XXX/comp.lang.c_must_fully_process_depth1_elif_20080827.htm
+	// note that integer literals are always parsed as of type intmax_t or uintmax_t
+	lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+	STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+
+	// error the illegal preprocessing tokens here
+	{
+	const size_t old_err_count = zcc_errors.err_count();
+	i = pretokenized.size();
+	do	{
+		--i;
+		lang.pp_support->AddPostLexFlags(x.data()+pretokenized[i].first, pretokenized[i].second, pretokenized[i].third, x.src_filename, x.original_line.first);
+		if (	(C_TESTFLAG_PP_OP_PUNC & pretokenized[i].third)
+			&& 	((C_DISALLOW_POSTPROCESSED_SOURCE | C_DISALLOW_CONSTANT_EXPR | C_DISALLOW_IF_ELIF_CONTROL) & lang.pp_support->GetPPOpPuncFlags(C_PP_DECODE(pretokenized[i].third))))
+			{
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INC_INFORM("Forbidden token ");
+			INC_INFORM(x.data()+pretokenized[i].first, pretokenized[i].second);
+			INFORM(" in control expression.");
+			zcc_errors.inc_error();
+			};
+		}
+	while(0<i);
+	if (old_err_count!=zcc_errors.err_count()) return false;
+	}
+
+	// should be merging string literals at this point
+RetryStringMerge:
+	bool want_clean_ws = false;
+	bool str_concat_wants_RAM = false;
+	if (2<=pretokenized.size())
+		{	//! \bug need test cases...lots of them
+		size_t i = 0;
+		while(i<pretokenized.size())
+			{
+			if (C_TESTFLAG_STRING_LITERAL!=pretokenized[i+1].third)
+				{
+				i += 2;
+				continue;
+				}
+			if (C_TESTFLAG_STRING_LITERAL!=pretokenized[i].third)
+				{
+				++i;
+				continue;
+				}
+
+			char* test = NULL;
+			const int res_code = lang.pp_support->EscapedStringConcatenate(x.data()+pretokenized[i].first,pretokenized[i].second,x.data()+pretokenized[i+1].first,pretokenized[i+1].second,test);
+			assert(-5<=res_code && 1>=res_code);
+			assert(1==res_code || NULL==test);
+			assert(1!=res_code || NULL!=test);
+			switch(res_code)
+			{
+			case -5:	{	// intermediate memory failed
+						str_concat_wants_RAM = true;
+			case 0:		++i;		// something exotic, mergence won't work
+						continue;
+						}
+			case -4:	{	// second string literal content, but wide
+						const size_t delta = pretokenized[i+1].first-(pretokenized[i].first+1U);
+						x.intradelete(pretokenized[i].first+1U,delta);
+						pretokenized[i].second = pretokenized[i+1].second+1;
+						pretokenized.DeleteIdx(i+1);
+						STL_translate_second(delta,pretokenized.begin()+i+1,pretokenized.end());
+						continue;
+						};
+			case -3:	{	// first string literal content, but wide
+							// convolution will handle UNICODE and raw strings as well
+						const char width_tag = x.data()[pretokenized[i+1].first];
+						memset(x.c_array()+pretokenized[i+1].first,' ',pretokenized[i+1].second);
+						pretokenized.DeleteIdx(i+1);
+						memmove(x.c_array()+pretokenized[i].first+1,x.c_array()+pretokenized[i].first,pretokenized[i].second);
+						x.c_array()[pretokenized[i].first] = width_tag;
+						++(pretokenized[i].first);
+						want_clean_ws = true;
+						continue;
+						};
+			case -2:	{	// second string literal is sufficient
+						memset(x.c_array()+pretokenized[i].first,' ',pretokenized[i].second);
+						pretokenized.DeleteIdx(i);
+						want_clean_ws = true;
+						continue;
+						};
+			case -1:	{	// first string literal is sufficient
+						memset(x.c_array()+pretokenized[i+1].first,' ',pretokenized[i+1].second);
+						pretokenized.DeleteIdx(i+1);
+						want_clean_ws = true;
+						continue;
+						};
+			case 1:		{	// no fancy memory conservation
+						const size_t replace_span = (pretokenized[i+1].first-pretokenized[i].first)+pretokenized[i+1].second;
+						const size_t core_str_target_len = strlen(test);
+						assert(IsLegalCString(test,core_str_target_len));
+						x.replace_once(std::nothrow,pretokenized[i].first,replace_span,test);
+						pretokenized.DeleteIdx(i+1);
+						if (core_str_target_len!=replace_span)
+							STL_translate_second(core_str_target_len-replace_span,pretokenized.begin()+i+1,pretokenized.end());	// C99 requires wraparound for unsigned ints, so this works
+						pretokenized[i].second = core_str_target_len;
+						free(test);
+						continue;
+						};
+			}
+			}
+		};
+	if (want_clean_ws)
+		{	// conserve memory
+		if (_flush_token_gaps(x,pretokenized,lang) && str_concat_wants_RAM) goto RetryStringMerge;
+		want_clean_ws = false;
+		};
+
+	// if there is only one token: it should be a preprocessing number or a character literal.  Handle it or error here
+	if (1==pretokenized.size())
+		{
+oneTokenExit:
+		assert(!str_concat_wants_RAM);
+		bool is_zero = false;
+		if (!if_elif_control_is_zero(x,pretokenized.front(),is_zero))
+			{
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INC_INFORM(x.data()+pretokenized.front().first,pretokenized.front().second);
+			INFORM(" : value of control expression for #if/#elif must be a valid preprocessing integer (C99 6.10.1p1/C++98 16.1p1)");
+			zcc_errors.inc_error();
+			return false;
+			}
+		//! \todo --do-what-i-mean doesn't call this to evoke an error
+		C99_literal_is_legal(x.data()+pretokenized.front().first,pretokenized.front().second,pretokenized.front().third,x.src_filename,x.logical_line.first,min_types);
+		x.replace_once(std::nothrow,critical_offset,x.size()-critical_offset,(is_zero) ? '0' : '1');
+		return true;
+		}
+
+	{	// check for balancing errors (slow)
+	autovalarray_ptr<weak_token> weaktoken_list;
+	_weak_tokenize_aux(x,pretokenized,weaktoken_list);
+	// do not process further if there are context-free errors
+	if (lang.pp_support->BalancingErrorCheck(weaktoken_list.data(),weaktoken_list.size(),true,true)) return false;
+	};
+
+	autovalarray_ptr<POD_pair<size_t,size_t> > parenpair_stack;
+	// context-free check should be intercepting when these are invalid
+	construct_matched_pairs<'(',')'>(x,pretokenized,parenpair_stack);
+
+	while(!parenpair_stack.empty() && 0==parenpair_stack.back().first && pretokenized.size()-1==parenpair_stack.back().second)
+		{
+		balanced_character_kill(x,pretokenized,parenpair_stack,parenpair_stack.size()-1);	// outermost parentheses pair: erase
+		want_clean_ws = true;
+		}
+
+	// directly nested parentheses cleanup
+	i = parenpair_stack.size();
+	while(1<i)
+		{
+		--i;
+		if (   parenpair_stack[i-1].first   ==parenpair_stack[i].first+1
+			&& parenpair_stack[i-1].second+1==parenpair_stack[i].second)
+			{
+			balanced_character_kill(x,pretokenized,parenpair_stack,i);	// outer pair immediately contains inner pair
+			want_clean_ws = true;
+			}
+		};
+	// only-literal nested parentheses cleanup
+	// valid only because no functions present or macros present [no identifiers left]
+	i = parenpair_stack.size();
+	while(0<i)
+		{
+		--i;
+		if (   2==parenpair_stack[i].second-parenpair_stack[i].first
+			&& ((C_TESTFLAG_CHAR_LITERAL | C_TESTFLAG_STRING_LITERAL | C_TESTFLAG_PP_NUMERAL) & pretokenized[parenpair_stack[i].first+1].third))
+			{
+			balanced_character_kill(x,pretokenized,parenpair_stack,i);
+			want_clean_ws = true;
+			}
+		};
+
+	if (pretokenized.empty())
+		{	// if.C99/Error_control24.hpp, if.C99/Error_control24.h
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(x.data()+critical_offset,x.size()-critical_offset);
+		INFORM(" : control expression for #if/#elif must evaluate to a single integer constant (C99 6.10.1p1/C++98 16.1p1)");
+		zcc_errors.inc_error();
+		return false;
+		}
+
+	// if there is only one token: it should be a preprocessing number or a character literal.  Handle it or error here
+	if (1==pretokenized.size()) goto oneTokenExit;
+
+	if (want_clean_ws)
+		{
+		if (_flush_token_gaps(x,pretokenized,lang) && str_concat_wants_RAM) goto RetryStringMerge;
+		want_clean_ws = false;
+		}
+
+	{	// check for context-free errors
+	autovalarray_ptr<weak_token> weaktoken_list;
+	_weak_tokenize_aux(x,pretokenized,weaktoken_list);
+	// do not process further if there are context-free errors
+	if (lang.pp_support->ControlExpressionContextFreeErrorCheck(weaktoken_list.data(),weaktoken_list.size(),true,true)) return false;
+	};
+
+	// unfortunately, we need a parse tree even for this: the ternary operator ? : means we can't actually evaluate everything promiscuously
+	{
+	parse_tree_class parsetree;
+	_parsetreeize_aux(x,pretokenized,parsetree);
+	assert(parsetree.is_raw_list() || parsetree.is_atomic());
+	if (parsetree.is_raw_list() && !lang.pp_support->CondenseParseTree(parsetree,min_types)) return false;
+	if (!parsetree.is_atomic() && !lang.pp_support->EvalParseTree(parsetree,min_types)) return false;
+	lang.pp_support->PPHackTree(parsetree,min_types);
+	// final, when above is working properly
+	if (!parsetree.is_atomic())
+		{
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(x.data()+critical_offset,x.size()-critical_offset);
+		INFORM(" : control expression for #if/#elif must evaluate to a single integer constant (C99 6.10.1p1/C++98 16.1p1)");
+		zcc_errors.inc_error();
+		return false;
+		}
+	x.replace_once(std::nothrow,critical_offset,x.size()-critical_offset,parsetree.index_tokens[0].token.first,parsetree.index_tokens[0].token.second);
+	lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
+	STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
+	i = pretokenized.size();
+	do	{
+		--i;
+		lang.pp_support->AddPostLexFlags(x.data()+pretokenized[i].first, pretokenized[i].second, pretokenized[i].third, x.src_filename, x.original_line.first);
+		}
+	while(0<i);
+	str_concat_wants_RAM = false;
+	}
+	if (1==pretokenized.size()) goto oneTokenExit;
+	return true;
+}
+
+#/*cut-cpp*/
+#/*cut-nocpp*/
+// don't undef these when testing tokenize-flow preprocessing
+#/*cut-nocpp*/
+#/*cut-cpp*/
+#undef PREPROCESSING_DIRECTIVE_FLAG
+#undef PACK_DIRECTIVE
+#undef UNPACK_DIRECTIVE
+#undef MAX_PP_DIRECTIVE
+#undef PP_INVALID
+#undef SYNTAX_CHECKED_FLAG
+
+void
+CPreprocessor::predefined_macro_replacement(Token<char>& x, size_t critical_offset)
+{
+	assert(x.size()>critical_offset);
+	lex_flags token_flags;
+	while(x.size()>critical_offset)
+		{
+		const size_t token_len = lang.UnfilteredNextToken(x.data()+critical_offset,token_flags);
+		if (    C_TESTFLAG_IDENTIFIER!=token_flags
+			|| !predefined_macro_replace_once(x,critical_offset,token_len))
+			critical_offset += token_len;
+		}
+}
+
+/*! 
+ * Replaces a predefined macro if it is at the exact location named.
+ * 
+ * \param x token containing candidate for predefined macro
+ * \param critical_offset where the candidate is
+ * \param token_len length of candidate
+ * 
+ * \return true iff replaced a predefined macro.  Updates critical_offset when returning true
+ */
+bool
+CPreprocessor::predefined_macro_replace_once(Token<char>& x, size_t& critical_offset, const size_t token_len)
+{
+	assert(x.size()>critical_offset);
+	assert(x.size()>=critical_offset+token_len);
+	const errr macro_index = linear_find(x.data()+critical_offset,token_len,macro_identifier_default,macro_identifier_default_count);
+	if (-1!=macro_index)
+		{
+		const char* macro_value = NULL;
+		char buf[10];
+		char file_buf[MAX_PATH+2];
+		if (NULL!=macro_identifier_default[macro_index].second)
+			// value known, substitute in
+			macro_value = macro_identifier_default[macro_index].second;
+		// special
+		else if (!strcmp(macro_identifier_default[macro_index].first,"__FILE__"))
+			{
+			assert(NULL!=x.src_filename);
+			file_buf[0] = '"';
+			strcpy(file_buf+1,x.src_filename);
+			file_buf[1+strlen(x.src_filename)] = '"';
+			file_buf[2+strlen(x.src_filename)] = '\0';
+			macro_value = file_buf;
+			}
+		else if (!strcmp(macro_identifier_default[macro_index].first,"__LINE__"))
+			macro_value = z_umaxtoa(x.logical_line.first,buf,10);
+		else if (!strcmp(macro_identifier_default[macro_index].first,"__TIME__"))
+			macro_value = time_buffer;
+		else if (!strcmp(macro_identifier_default[macro_index].first,"__TIMESTAMP__"))
+			macro_value = time_date_buffer;
+		else if (!strcmp(macro_identifier_default[macro_index].first,"__COUNTER__"))
+			macro_value = z_umaxtoa(counter_macro++,buf,10);
+		else if (!strcmp(macro_identifier_default[macro_index].first,"__INCLUDE_LEVEL__"))
+			macro_value = z_umaxtoa(include_level,buf,10);
+		else{
+			assert(!strcmp(macro_identifier_default[macro_index].first,"__DATE__"));
+			macro_value = date_buffer;
+			}
+		_macro_replace(x,critical_offset,token_len,macro_value);
+		return true;
+		}
+	return false;
+}
+
+void
+CPreprocessor::_macro_replace(Token<char>& x, size_t& critical_offset, const size_t token_len,const char* const macro_value) const
+{
+	assert(x.size()>critical_offset);
+	assert(x.size()-critical_offset>=token_len);
+	assert(0<token_len);
+
+	if (is_empty_string(macro_value))
+		{
+		if (x.size()-critical_offset<=token_len)
+			x.rtrim(token_len);
+		else if (0==critical_offset)
+			x.ltrim(token_len);
+		else if (require_padding(x.data()[critical_offset-1],x.data()[critical_offset+token_len]))
+			x.replace_once(std::nothrow,critical_offset,token_len,' ');
+		else
+			x.intradelete(critical_offset,token_len);
+		return;
+		}
+
+	const bool pad_left = 0<critical_offset && require_padding(x.data()[critical_offset-1],macro_value[0]);
+	const bool pad_right = x.size()>critical_offset+token_len && require_padding(macro_value[strlen(macro_value)-1],x.data()[critical_offset+token_len]);
+
+	if (pad_right) x.replace_once(critical_offset+token_len,0,' ');
+	x.replace_once(critical_offset,token_len,macro_value);
+	if (pad_left) x.replace_once(critical_offset,0,' ');
+
+	critical_offset += strlen(macro_value);
+	if (pad_right) ++critical_offset;
+	if (pad_left) ++critical_offset;
+}
+
+
+void
+CPreprocessor::instantiate_function_macro_arguments(autovalarray_ptr<Token<char>*>& arguments, const Token<char>& arglist, size_t arg_count) const
+{
+	lex_flags scratch_flags;
+	size_t paren_depth = 1;
+	size_t var_origin = 0;
+	size_t offset = 1;
+	size_t count_args = 0;
+	assert(2<=arglist.size());
+	assert('('==arglist.front());
+	assert(')'==arglist.back());
+	if (2==arglist.size())
+		{
+		assert(0==arg_count);
+		arguments.reset();
+		return;
+		};
+	assert(0!=arg_count);
+	assert(arg_count<arglist.size());
+	arguments.resize(arg_count);
+	while(offset<arglist.size())
+		{
+		if 		('('==arglist.data()[offset])
+			{
+			++paren_depth;
+			++offset;
+			}
+		else if	(')'==arglist.data()[offset])
+			{
+			--paren_depth;
+			if (0==paren_depth)
+				{	// update var
+				if (var_origin+1<offset)
+					{
+					const size_t skip_ws = strspn(arglist.data()+var_origin+1,lang.WhiteSpace);
+					if (offset-var_origin+1>skip_ws)
+						{
+						arguments[count_args] = new Token<char>(arglist,var_origin+1+skip_ws,offset-var_origin-1-skip_ws,0);
+						_flush_duplicated_ws(*arguments[count_args],lang);
+						}
+					};
+				return;
+				}
+			++offset;
+			}
+		else if (','==arglist.data()[offset] && 1==paren_depth && count_args<arg_count-1)
+			{	// update var
+			if (var_origin+1<offset)
+				{
+				const size_t skip_ws = strspn(arglist.data()+var_origin+1,lang.WhiteSpace);
+				if (offset-var_origin+1>skip_ws)
+					{
+					arguments[count_args] = new Token<char>(arglist,var_origin+1+skip_ws,offset-var_origin-1-skip_ws,0);
+					_flush_duplicated_ws(*arguments[count_args],lang);
+					}
+				};
+			var_origin = offset;
+			++offset;
+			++count_args;
+			}
+		else
+			offset += lang.UnfilteredNextToken(arglist.data()+offset,scratch_flags);
+		}
+}
+
+bool
+CPreprocessor::dynamic_macro_replace_once(Token<char>& x, size_t& critical_offset, size_t token_len, const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<Token<char>*>& macros_object_expansion, const autovalarray_ptr<char*>& macros_function, const autovalarray_ptr<Token<char>*>& macros_function_arglist, const autovalarray_ptr<Token<char>*>& macros_function_expansion, autovalarray_ptr<char*>* const used_macro_stack)
+{
+	assert(x.size()>critical_offset);
+	assert(x.size()-critical_offset>=token_len);
+	assert(macros_object.size()==macros_object_expansion.size());
+	assert(macros_function.size()==macros_function_expansion.size());
+	const errr object_macro_index = binary_find(x.data()+critical_offset,token_len,macros_object);
+	const errr function_macro_index = binary_find(x.data()+critical_offset,token_len,macros_function);
+	assert(0>object_macro_index || 0>function_macro_index);
+	if (0<=object_macro_index)
+		{
+		if (NULL==macros_object_expansion[object_macro_index])
+			{
+			_macro_replace(x,critical_offset,token_len,"");
+			return true;
+			};
+		if (nonrecursive_macro_replacement_list(macros_object_expansion[object_macro_index]->data()))
+			{
+			_macro_replace(x,critical_offset,token_len,macros_object_expansion[object_macro_index]->data());
+			return true;
+			};
+		size_t test_critical_offset = 0;
+		Token<char> Test(x);
+		Test.lslice(critical_offset+token_len);
+		Test.ltrim(critical_offset);
+		_macro_replace(Test,test_critical_offset,token_len,macros_object_expansion[object_macro_index]->data());
+		predefined_macro_replacement(Test,0);
+		if (NULL==used_macro_stack)
+			{
+			autovalarray_ptr<char*> macro_stack(1);
+			macro_stack[0] = _new_buffer_nonNULL_throws<char>(token_len);
+			memmove(macro_stack[0],x.data()+critical_offset,token_len);
+			intradirective_preprocess(Test,0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,&macro_stack);
+			}
+		else{
+			used_macro_stack->insertNSlotsAt(1,used_macro_stack->size());
+			used_macro_stack->back() = _new_buffer_nonNULL_throws<char>(token_len);
+			memmove(used_macro_stack->back(),x.data()+critical_offset,token_len);
+			intradirective_preprocess(Test,0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack);
+			used_macro_stack->DeleteIdx(used_macro_stack->size()-1);
+			}
+		_macro_replace(x,critical_offset,token_len,Test.data());
+		return true;
+		};
+	if (0<=function_macro_index && x.size()>critical_offset+token_len && '('==x.data()[critical_offset+token_len])
+		{
+		assert(NULL!=macros_function_arglist[function_macro_index]);
+		assert('('==macros_function_arglist[function_macro_index]->front());
+		assert(')'==macros_function_arglist[function_macro_index]->back());
+		const size_t formal_arg_span = macros_function_arglist[function_macro_index]->size();
+		const size_t formal_arg_count = (2<formal_arg_span) ? std::count(macros_function_arglist[function_macro_index]->begin(),macros_function_arglist[function_macro_index]->end(),',')+1 : 0;
+		const bool formal_varadic = 5<=formal_arg_span && !strncmp(macros_function_arglist[function_macro_index]->data()+(formal_arg_span-4),"...",sizeof("...")-1);
+		size_t arg_count = 0;
+		const size_t arg_span = function_macro_invocation_argspan(x.data()+critical_offset+token_len,x.size()-(critical_offset+token_len),arg_count);
+		if (0==arg_span)
+			{	//! \test Error_macro_arglist1.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INC_INFORM("macro ");
+			INC_INFORM(x.data()+critical_offset,token_len);
+			INFORM(" did not close its argument list in time. (C99 6.10p1/C++98 16.1p1)");
+			zcc_errors.inc_error();
+			x.flags |= INVALID_DIRECTIVE_FLAG;
+			return false;
+			}
+		if (formal_arg_count>arg_count || (formal_arg_count<arg_count && !formal_varadic))
+			{	//! \test Error_macro_arglist2.hpp
+				//! \test Error_macro_arglist3.hpp
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INC_INFORM("macro ");
+			INC_INFORM(x.data()+critical_offset,token_len);
+			INC_INFORM(" had ");
+			INC_INFORM(arg_count);
+			INC_INFORM(" argument");
+			INC_INFORM((1==arg_count) ? "" : "s");
+			INC_INFORM(", needed ");
+			if (formal_varadic) INC_INFORM("at least ");
+			INC_INFORM(formal_arg_count);
+			INFORM(". (C99 6.10p1/C++0x 16.1p1)");
+			zcc_errors.inc_error();
+			x.flags |= INVALID_DIRECTIVE_FLAG;
+			return false;
+			}
+		if (NULL==macros_function_expansion[function_macro_index])
+			{
+			_macro_replace(x,critical_offset,token_len+arg_span,"");
+			return true;
+			};
+		if (nonrecursive_macro_replacement_list(macros_function_expansion[function_macro_index]->data()))
+			{
+			_macro_replace(x,critical_offset,token_len+arg_span,macros_function_expansion[function_macro_index]->data());
+			return true;
+			};
+
+		autovalarray_ptr<Token<char>*> formal_arguments;
+		autovalarray_ptr<Token<char>*> actual_arguments;
+		{
+		Token<char> actual_pre_args(x,critical_offset+token_len,arg_span,0);
+		instantiate_function_macro_arguments(actual_arguments,actual_pre_args,formal_arg_count);
+		}
+		//! \todo consider calling this once on-demand (space vs. time trade)
+		instantiate_function_macro_arguments(formal_arguments,*macros_function_arglist[function_macro_index],formal_arg_count);
+		// arguments should already be normal-formed coming out, with as many as requested
+		assert(formal_arguments.size()==formal_arg_count);
+		assert(actual_arguments.size()==formal_arg_count);
+#ifndef NDEBUG
+		{	// reality-check the formal argument list
+		lex_flags identifier_flags;
+		size_t j = formal_arg_count;
+		do	{
+			--j;
+			assert(NULL!=formal_arguments[j]);
+			assert(0<formal_arguments[j]->size());
+			const size_t identifier_len = lang.UnfilteredNextToken(formal_arguments[j]->data(),identifier_flags);
+			assert(C_TESTFLAG_IDENTIFIER==identifier_flags);
+			assert(identifier_len==formal_arguments[j]->size());
+			}
+		while(0<j);
+		}
+#endif
+		// ... is used as parameter __VA_ARGS__
+		//! __VA_ARGS__ occurs only in the replacement list of varadic function-like macros, so it is the proper variable name for that ...
+		if (formal_varadic) formal_arguments.back()->replace_once(0,formal_arguments.back()->size(),"__VA_ARGS__");
+		//! \todo should discard unused formal arguments and their parameter lists; not worth a warning, as there are a number of legitimate uses for discarding formal parameters
+		Token<char> Test(*macros_function_expansion[function_macro_index]);
+		if (NULL==used_macro_stack)
+			{
+			autovalarray_ptr<char*> macro_stack(1);
+			macro_stack[0] = _new_buffer_nonNULL_throws<char>(token_len);
+			memmove(macro_stack[0],x.data()+critical_offset,token_len);
+
+			dynamic_function_macro_prereplace_once(macros_object, macros_object_expansion, macros_function, macros_function_arglist, macros_function_expansion, &macro_stack, formal_arguments, actual_arguments, Test);
+			}
+		else{
+			used_macro_stack->insertNSlotsAt(1,used_macro_stack->size());
+			used_macro_stack->back() = _new_buffer_nonNULL_throws<char>(token_len);
+			memmove(used_macro_stack->back(),x.data()+critical_offset,token_len);
+
+			dynamic_function_macro_prereplace_once(macros_object, macros_object_expansion, macros_function, macros_function_arglist, macros_function_expansion, used_macro_stack, formal_arguments, actual_arguments, Test);
+			used_macro_stack->DeleteIdx(used_macro_stack->size()-1);
+			}
+		_macro_replace(x,critical_offset,token_len+arg_span,Test.data());
+		return true;
+		};
+	return false;
+}
+
+/*! 
+ * Does a single concatenation of the tokens indicated
+ * 
+ * \param x : where concatenation is being done
+ * \param pretokenized : pointer into C array where tokenization info is
+ * 
+ * \return true if and only if concatenation happened
+ */
+static bool _concatenate_single(Token<char>& x,const POD_triple<size_t,size_t,lex_flags>* pretokenized, LangConf& lang)
+{
+	assert(NULL!=pretokenized);
+	autovalarray_ptr_throws<char> new_token(pretokenized[0].second+pretokenized[2].second);
+	strncpy(new_token.c_array(),x.data()+pretokenized[0].first,pretokenized[0].second);
+	strncpy(new_token.c_array()+pretokenized[0].second,x.data()+pretokenized[2].first,pretokenized[2].second);
+	lex_flags scratch_flags;
+	const size_t new_token_len = lang.UnfilteredNextToken(new_token.data(),scratch_flags);
+	if (new_token_len!=new_token.size())
+		{	//! \test define.C99/Error_concatenate3.hpp, define.C99/Error_concatenate3.h
+			//! \test define.C99/Error_concatenate4.hpp, define.C99/Error_concatenate4.h
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INC_INFORM("## concatenation result ");
+		INC_INFORM(new_token.data());
+		INFORM(" is not a single token.  Defining undefined behavior as eliminating ## and continuing (C99 6.10.3.3p3/C++98 16.3.3p3)");
+		zcc_errors.inc_error();
+
+		const size_t offset = pretokenized[0].first+pretokenized[0].second;
+		if (new_token_len==pretokenized[0].second)
+			x.intradelete(offset,pretokenized[2].first-offset);
+		else
+			x.replace_once(offset,pretokenized[2].first-offset,' ');
+		return false;
+		};
+	// splice it
+	//! \test define.C99/Pass_concatenate1.hpp, define.C99/Pass_concatenate1.h
+	//! \test define.C99/Pass_concatenate2.hpp, define.C99/Pass_concatenate2.h
+	x.replace_once(pretokenized[0].first,(pretokenized[2].first-pretokenized[0].first)+pretokenized[2].second,new_token.data());
+	return true;
+}
+
+static void remove_ws_from_token(Token<char>& x, const autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >& pretokenized)
+{
+	// truncate everything past last token
+	x.lslice(pretokenized.back().first+pretokenized.back().second);
+	size_t i = pretokenized.size();
+	if (2<=i)
+		{
+		--i;
+		do	{
+			--i;
+			if (   pretokenized[i].first<pretokenized[i+1].first
+				&& pretokenized[i].second<pretokenized[i+1].first-pretokenized[i].first)
+				{
+				const size_t ws_origin = pretokenized[i].first+pretokenized[i].second;
+				x.replace_once(std::nothrow,ws_origin,pretokenized[i+1].first-ws_origin,' ');
+				}
+			}
+		while(0<i);
+		}
+
+	// truncate before first token
+	x.ltrim(pretokenized.front().first);
+}
+
+void
+CPreprocessor::dynamic_function_macro_prereplace_once(const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<Token<char>*>& macros_object_expansion, const autovalarray_ptr<char*>& macros_function, const autovalarray_ptr<Token<char>*>& macros_function_arglist, const autovalarray_ptr<Token<char>*>& macros_function_expansion,autovalarray_ptr<char*>* const used_macro_stack, const autovalarray_ptr<Token<char>*>& formal_arguments, const autovalarray_ptr<Token<char>*>& actual_arguments, Token<char>& x)
+{
+	// deal with # operators before macro-replacing arguments
+	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
+	if (lang.line_lex_find(x.data(),x.size(),"#",sizeof("#")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:",sizeof("%:")-1,pretokenized))
+		{
+		size_t i = pretokenized.size();
+		do	{
+			--i;
+			if (detect_C_stringize_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+				{
+				assert(pretokenized.size()>i+1);
+				assert(pretokenized[i].first+pretokenized[i].second==pretokenized[i+1].first);
+				const errr j = (C_TESTFLAG_IDENTIFIER==pretokenized[i].third) ? linear_find_STL_deref2(x.data()+pretokenized[i+1].first,pretokenized[i+1].second,formal_arguments) : -1;
+				assert(0<=j);
+
+				{
+				autovalarray_ptr<char> stringized_actual;	//! \todo inefficient, should stringize any parameter only once and reuse
+				stringize(stringized_actual,actual_arguments[j]);
+				// safe because narrow string
+				x.replace_once(pretokenized[i].first,pretokenized[i+1].second+pretokenized[i].second,stringized_actual.data());
+				// XXX leave behind garbage in pretokenized
+				}
+				}
+			}
+		while(0<i);
+		};
+
+	// deal with empty-var ## operators
+	size_t j = actual_arguments.size();
+	do if (NULL==actual_arguments[--j])
+			{	// have a genuinely empty argument
+			if (lang.line_lex_find(x.data(),x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
+				{
+				assert(!detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second));
+				assert(!detect_C_concatenation_op(x.data()+pretokenized.back().first, pretokenized.back().second));
+				size_t k = pretokenized.size();
+				if (3<=k)
+					{
+					do	if (C_TESTFLAG_NONATOMIC_PP_OP_PUNC==pretokenized[--k].third && detect_C_concatenation_op(x.data()+pretokenized[k].first,pretokenized[k].second))
+							{
+							if (C_TESTFLAG_IDENTIFIER==pretokenized[k+1].third)
+								{
+								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k+1].first,pretokenized[k+1].second,formal_arguments);
+								if (0<=j2 && NULL==actual_arguments[j2])
+									{	// we matched an empty parameter (concatenation identity)
+									const size_t replace_start = pretokenized[k-1].first+pretokenized[k-1].second;
+									size_t replace_len = (pretokenized[k+1].first-replace_start)+pretokenized[k+1].second;
+									if (x.size()>replace_start+replace_len)
+										replace_len += strspn(x.data()+replace_start+replace_len,lang.WhiteSpace+1);
+									x.replace_once(replace_start,replace_len,' ');
+									continue;
+									}
+								};
+							if (C_TESTFLAG_IDENTIFIER==pretokenized[k-1].third)
+								{	// don't need should_continue bypass for last check
+								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k-1].first,pretokenized[k-1].second,formal_arguments);
+								if (0<=j2 && NULL==actual_arguments[j2])
+									{
+									const size_t replace_start = (0<k) ? pretokenized[k-2].first+pretokenized[k-2].second : 0U;
+									size_t replace_len = (pretokenized[k].first-replace_start)+pretokenized[k].second;
+									if (x.size()>replace_start+replace_len)
+										replace_len += strspn(x.data()+replace_start+replace_len,lang.WhiteSpace+1);
+	
+									x.replace_once(pretokenized[k-1].first,(pretokenized[k].first-pretokenized[k-1].first)+pretokenized[k].second,' ');
+//									continue;
+									}
+								};
+							}
+					while(0<k);
+					};
+				}
+			break;
+			}
+	while(0<j);
+
+	// macro-replace all arguments
+	j = actual_arguments.size();
+	do	if (NULL!=actual_arguments[--j])
+			intradirective_preprocess(*actual_arguments[j],0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack);
+	while(0<j);
+
+	lang.line_lex(x.data(),x.size(),pretokenized);
+	assert(!pretokenized.empty());
+	assert(!detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second));
+	assert(!detect_C_concatenation_op(x.data()+pretokenized.back().first,pretokenized.back().second));
+
+	j = pretokenized.size();
+	do	{
+		--j;
+		const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[j].first,pretokenized[j].second,formal_arguments);
+		if (0<=j2)
+			{
+			assert(NULL!=actual_arguments[j2]);
+			_macro_replace(x,pretokenized[j].first,pretokenized[j].second,actual_arguments[j2]->data());
+			lang.line_lex(x.data(),x.size(),pretokenized);
+			}
+		else if (detect_C_concatenation_op(x.data()+pretokenized[j].first,pretokenized[j].second))
+			{	// hmm...
+			const errr j3 = linear_find_STL_deref2(x.data()+pretokenized[j-1].first,pretokenized[j-1].second,formal_arguments);
+			if (0<=j3)
+				{	// oops....must do replacement *before* the ## concatenation
+				assert(NULL!=actual_arguments[j3]);
+				assert(!actual_arguments[j3]->empty());
+				autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized_alt;
+				lang.line_lex(actual_arguments[j3]->data(),actual_arguments[j3]->size(),pretokenized_alt);
+				_macro_replace(x,pretokenized[j-1].first,pretokenized[j-1].second,actual_arguments[j3]->data());
+				lang.line_lex(x.data(),x.size(),pretokenized);
+				j += pretokenized_alt.size()-1;
+				assert(detect_C_concatenation_op(x.data()+pretokenized[j].first,pretokenized[j].second));
+				};
+			if (_concatenate_single(x,pretokenized.data()+(j-1),lang)) --j;
+			}
+		}
+	while(0<j);
+}
+
+static void _complete_string_character_literal_define(Token<char>& x, const Token<char>& src, size_t critical_offset, size_t first_token_len,const char delim, const char* const end_error)
+{
+	if (delim!=x.back())
+		{
+		message_header(src);
+		INC_INFORM(ERR_STR);
+		INC_INFORM("#define ");
+		INC_INFORM(src.data()+critical_offset,first_token_len);
+		INC_INFORM(" ends in an unterminated");
+		if ('L'==x.front()) INC_INFORM(" wide");
+		INFORM(end_error);
+		zcc_errors.inc_error();
+		x.append(delim);
+		}
+}
+
+/*! 
+ * Puts a macro expansion into a standardized form so that strcmp is sufficient to determine equivalence.
+ * 
+ * \param x macro expansion to be normalized in-place
+ * 
+ * \return false if the macro ends in an unterminated (wide?) string/character literal.  [We terminate it here, but the caller should react later on.]
+ */
+void
+CPreprocessor::normalize_macro_expansion(Token<char>& x, const Token<char>& src, size_t critical_offset, size_t first_token_len)
+{
+	if (x.empty()) return;
+	size_t offset = 0;
+	{	//! \test Pass5.hpp
+	const size_t skip_ws = strspn(x.data(),lang.WhiteSpace+1);
+	if (0<skip_ws)
+		{
+		x.ltrim(skip_ws);
+		if (x.empty()) return;
+		}
+	}
+	while(offset<x.size())
+		{
+		lex_flags token_flags;
+		offset += lang.UnfilteredNextToken(x.data()+offset,token_flags);
+		if (x.size()<=offset)
+			{
+			if 		(C_TESTFLAG_STRING_LITERAL==token_flags)
+				//! \test define.C99/Error_unterminated3.hpp, define.C99/Error_unterminated3.h
+				//! \test define.C99/Error_unterminated4.hpp, define.C99/Error_unterminated4.h
+				_complete_string_character_literal_define(x,src,critical_offset,first_token_len,'"'," string literal.  Terminating. (C99 6.4.5p1/C++98 2.13.4)");
+			else if (C_TESTFLAG_CHAR_LITERAL  ==token_flags)
+				//! \test define.C99/Error_unterminated1.hpp, define.C99/Error_unterminated1.h
+				//! \test define.C99/Error_unterminated2.hpp, define.C99/Error_unterminated2.h
+				_complete_string_character_literal_define(x,src,critical_offset,first_token_len,'\''," character literal.  Terminating. (C99 6.4.4.4p1/C++98 2.13.2)");
+			return;
+			}
+		const size_t skip_ws = strspn(x.data()+offset,lang.WhiteSpace+1);
+		if (0<skip_ws)
+			{
+			if (x.size()-offset<=skip_ws)
+				{	//! \test define.C99/Pass_dup5.hpp, define.C99/Pass_dup5.h
+				x.lslice(offset);
+				return;
+				};
+			//! \test define.C99/Pass_dup6.hpp, define.C99/Pass_dup6.h
+			x.replace_once(std::nothrow,offset,skip_ws,' ');
+			++offset;
+			};
+		};
+	return;
+}
+
+void
+CPreprocessor::intradirective_preprocess(Token<char>& x, size_t critical_offset, const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<Token<char>*>& macros_object_expansion, const autovalarray_ptr<char*>& macros_function, const autovalarray_ptr<Token<char>*>& macros_function_arglist, const autovalarray_ptr<Token<char>*>& macros_function_expansion,autovalarray_ptr<char*>* const used_macro_stack)
+{
+	while(x.size()>critical_offset)
+		{
+		const size_t skip_ws = strspn(x.data()+critical_offset,lang.WhiteSpace+1);
+		if (0<skip_ws)
+			{
+			x.replace_once(std::nothrow,critical_offset,skip_ws,' ');
+			++critical_offset;
+			continue;
+			};
+		lex_flags token_flags;
+		const size_t token_len = lang.UnfilteredNextToken(x.data()+critical_offset,token_flags);
+		if (    C_TESTFLAG_IDENTIFIER!=token_flags
+			|| (NULL!=used_macro_stack && 0<=binary_find(x.data()+critical_offset,token_len,*used_macro_stack))
+			|| (	!predefined_macro_replace_once(x,critical_offset,token_len)
+				&&	!dynamic_macro_replace_once(x,critical_offset,token_len,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack)))
+			{
+			critical_offset += token_len;
+			continue;
+			}
+		};
+}
+
+void
+CPreprocessor::intradirective_flush_identifiers_to_zero(Token<char>& x, size_t critical_offset) const
+{	//! test if.C99/Error_if_control.hpp, if.C99/Error_if_control.h
+	//! test if.C99/Pass_if_control.hpp, if.C99/Pass_if_control.h
+	while(x.size()>critical_offset)
+		{
+		const size_t skip_ws = strspn(x.data()+critical_offset,lang.WhiteSpace+1);
+		if (0<skip_ws)
+			{
+			x.replace_once(std::nothrow,critical_offset,skip_ws,' ');
+			++critical_offset;
+			continue;
+			};
+		lex_flags token_flags;
+		const size_t token_len = lang.UnfilteredNextToken(x.data()+critical_offset,token_flags);
+		if (C_TESTFLAG_IDENTIFIER!=token_flags)
+			{
+			critical_offset += token_len;
+			continue;
+			}
+		_macro_replace(x,critical_offset,token_len,"0");
+		critical_offset += 1;
+		};
+}
+
+void CPreprocessor::die_on_pp_errors() const
+{
+	if (0>=zcc_errors.err_count()) return;
+	INC_INFORM("FATAL: ");
+	INC_INFORM(zcc_errors.err_count());
+	INC_INFORM(" preprocessing error");
+	INFORM((1==zcc_errors.err_count()) ? "\n" : "s\n");
+	exit(EXIT_FAILURE);
+}
+
+void
+CPreprocessor::debug_to_stderr(const autovalarray_ptr<Token<char>* >& TokenList,const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<Token<char>*>& macros_object_expansion, const autovalarray_ptr<char*>& macros_function, const autovalarray_ptr<Token<char>*>& macros_function_arglist, const autovalarray_ptr<Token<char>*>& macros_function_expansion,const autovalarray_ptr<char*>& locked_macros) const
+{
+	// need whitespace tokens here to force pretty-printing
+	if (debug_mode)
+		{
+		const size_t list_size = TokenList.size();
+		size_t i = 0;
+		while(i<list_size)
+			{
+			if (0<i && TokenList[i-1]->logical_line.first==TokenList[i]->logical_line.first && !strcmp(TokenList[i-1]->src_filename,TokenList[i]->src_filename) && require_padding(TokenList[i-1]->back(),TokenList[i]->front()))
+				INC_INFORM(' ');
+
+			if (list_size<=i+1 || TokenList[i]->logical_line.first!=TokenList[i+1]->logical_line.first || strcmp(TokenList[i]->src_filename,TokenList[i+1]->src_filename))
+				INFORM(TokenList[i]->data());
+			else
+				INC_INFORM(TokenList[i]->data());
+			++i;
+			};
+		// dump macros and locked macros
+		INC_INFORM("#define __DATE__ ");
+		INFORM(date_buffer);
+		INC_INFORM("#define __TIME__ ");
+		INFORM(time_buffer);
+		INC_INFORM("#define __TIMESTAMP__ ");
+		INFORM(time_date_buffer);
+		i = 7;
+		while(i<macro_identifier_default_count)
+			{
+			INC_INFORM("#define ");
+			INC_INFORM(macro_identifier_default[i].first);
+			INC_INFORM(" ");
+			INFORM(macro_identifier_default[i].second);
+			++i;
+			};
+		const size_t object_macro_size = macros_object.size();
+		i = 0;
+		while(i<object_macro_size)
+			{
+			INC_INFORM("#define ");
+			INC_INFORM(macros_object[i]);
+			if (NULL!=macros_object_expansion[i])
+				{
+				INC_INFORM(" ");
+				INFORM(macros_object_expansion[i]->data());
+				}
+			else
+				INC_INFORM("\n");
+			++i;
+			}
+		const size_t function_macro_size = macros_function.size();
+		i = 0;
+		while(i<function_macro_size)
+			{
+			INC_INFORM("#define ");
+			INC_INFORM(macros_function[i]);
+			INC_INFORM(macros_function_arglist[i]->data());
+			if (NULL!=macros_function_expansion[i])
+				{
+				INC_INFORM(" ");
+				INFORM(macros_function_expansion[i]->data());
+				}
+			else
+				INC_INFORM("\n");
+			++i;
+			}
+		const size_t locked_macro_size = locked_macros.size();
+		i = 0;
+		while(i<locked_macro_size)
+			{
+			INC_INFORM("#pragma ZCC lock ");
+			INFORM(locked_macros[i++]);
+			}
+		};
+}
+
+/*! 
+ * Causes a preprocessing error if the identifier __VA_ARGS__ is found.
+ * 
+ * \param x : token to examine for __VA_ARGS__
+ * \param critical_offset : start point of examination
+ * 
+ * \return bool if and only if an error was found.
+ */
+bool
+CPreprocessor::C99_VA_ARGS_flinch(const Token<char>& x, const size_t critical_offset) const
+{	//! \todo option to bypass this
+	assert(x.size()>critical_offset);
+	if (SIZE_MAX!=lang.lex_find(x.data()+critical_offset,x.size()-critical_offset,"__VA_ARGS__",sizeof("__VA_ARGS__")-1))
+		{
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INFORM("identifier __VA_ARGS__ not allowed here.  Continuing. (C99 6.10.3p5/C++0x 16.3p5)");
+		zcc_errors.inc_error();
+		return true;
+		}
+	return false;
+}
+
+void
+CPreprocessor::discard_duplicate_define(autovalarray_ptr<Token<char>* >& TokenList, const size_t i, const size_t critical_offset, const size_t first_token_len)
+{
+	message_header(*TokenList[i]);
+	INC_INFORM(ERR_STR);
+	INC_INFORM(TokenList[i]->data()+critical_offset,first_token_len);
+	INFORM(" is already #define'd; discarding #define (C99 6.10.3p2/C++98 16.3p2,3)");
+	TokenList.DeleteIdx(i);
+	zcc_errors.inc_error();
+}
+
+/*! 
+ * Discards leading and trailing ## operators in macro expansion lists; errors but continues.
+ * 
+ * \param x : macro expansion
+ * 
+ * \return bool : true iff truncated to empty
+ */
+bool CPreprocessor::discard_leading_trailing_concatenate_op(Token<char>& x)
+{
+	if ((sizeof("##")-1)>x.size()) return false;
+	assert(!strpbrk(x.data(),lang.WhiteSpace+2));	// check for normalization
+	assert(!strchr(x.data(),'\n'));	// check for normalization
+	// tokenize the whole line
+	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
+	lang.line_lex(x.data(),x.size(),pretokenized);
+
+	if (detect_C_concatenation_op(x.data()+pretokenized.back().first,pretokenized.back().second))
+		{
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INFORM("concatenation operator ## ending a macro replacement list: removing and continuing (C99 6.10.3.3p1/C++98 16.3.3p1)");
+		zcc_errors.inc_error();
+		if (1==pretokenized.size())
+			{
+			x.reset();
+			return true;
+			}
+		pretokenized.DeleteIdx(pretokenized.size()-1);
+		x.lslice(pretokenized.back().first+pretokenized.back().second);
+		}
+
+	if (detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second))
+		{
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INFORM("concatenation operator ## starting a macro replacement list: removing and continuing (C99 6.10.3.3p1/C++98 16.3.3p1)");
+		zcc_errors.inc_error();
+		if (1==pretokenized.size())
+			{
+			x.reset();
+			return true;
+			}
+		x.ltrim(pretokenized[1].first);
+		// XXX leave data structures in an inconsistent state: they'll be immediately destructed anyway
+		}
+	return false;
+}
+
+void
+CPreprocessor::use_line_directive_and_discard(autovalarray_ptr<Token<char>* >& TokenList, const size_t i)
+{
+	assert(i<TokenList.size());
+	assert(NULL!=TokenList[i]);
+	assert(!strncmp(TokenList[i]->data(),"#line ",sizeof("#line ")-1));
+	if (TokenList[i]->flags & INVALID_DIRECTIVE_FLAG)
+		{
+		TokenList.DeleteIdx(i);
+		return;
+		};
+	C_PPDecimalInteger line_number;
+	lex_flags first_token_flags;
+	lex_flags second_token_flags;
+	size_t critical_offset = sizeof("#line ")-1;
+	// C99: check for decimal integer literal, then optional string literal; error if this is not found
+	{
+	const size_t first_token_len = lang.UnfilteredNextToken(TokenList[i]->data()+critical_offset,first_token_flags);
+	if (     C_TESTFLAG_PP_NUMERAL!=first_token_flags
+		||	!C_PPDecimalInteger::is(TokenList[i]->data()+critical_offset,first_token_len,line_number)
+		||	-1==cmp(line_number,"1",sizeof("1")-1)
+		||	 1==cmp(line_number,"2147483647",sizeof("2147483647")-1))	// constant should be stringized 2^31-1
+		{	//! \test cpp/line.C99/Error_badnum1.h, cpp/line.C99/Error_badnum1.hpp
+			//! \test cpp/line.C99/Error_badnum2.h, cpp/line.C99/Error_badnum2.hpp
+			//! \test cpp/line.C99/Error_badnum3.h, cpp/line.C99/Error_badnum3.hpp
+			//! \test cpp/line.C99/Error_badnum4.h, cpp/line.C99/Error_badnum4.hpp
+		message_header(*TokenList[i]);
+		INC_INFORM(ERR_STR);
+		INFORM("#line does not have a line number between 1 and 2147483647 inclusive (C99 6.10.4p3/C++0x 16.4p3)");
+		zcc_errors.inc_error();
+		TokenList.DeleteIdx(i);
+		return;
+		};
+	critical_offset += first_token_len;
+	}
+	if (i+1 < TokenList.size())
+		{	//! \test cpp/line.C99/Preprocess_42.h, cpp/line.C99/Preprocess_42.hpp
+			// Behavior is undefined if the syntax is bad (line number with malformed filename string), so don't worry about this happening too early.
+		size_t numeric_line_number;
+		{	// don't worry about failure (pre-validated above), *but* as errno should be a synchronized global we have to lock it anyway
+		OS::scoped_lock tmp(errno_mutex);
+		numeric_line_number = line_number.to_umax();	//! \warning can catastrophically overflow if size_t isn't at least 32-bit
+		};
+		if (TokenList[i]->logical_line.first!=numeric_line_number)
+			{
+			size_t j = i+1;
+			//! \todo loops should stop at first (valid) #line directive
+			// remember that unsigned arithmetic is modulo
+			const size_t delta = numeric_line_number - TokenList[i]->logical_line.first;
+			while(j<TokenList.size())
+				TokenList[j++]->logical_line.first += delta;
+			};
+		}
+
+	if (TokenList[i]->size()<=critical_offset)
+		{	// just the line number needed updating
+		TokenList.DeleteIdx(i);
+		return;
+		}
+
+	{
+	const size_t skip_ws = strspn(TokenList[i]->data()+critical_offset,lang.WhiteSpace+1);
+	if (skip_ws>=TokenList[i]->size()-critical_offset)
+		{	// only trailing whitespace
+		TokenList.DeleteIdx(i);
+		return;
+		}
+	critical_offset += skip_ws;
+	}
+
+	const size_t second_token_len = lang.UnfilteredNextToken(TokenList[i]->data()+critical_offset,second_token_flags);
+	//! \todo: extension?  C99 spec requires narrow string literals only
+	if (   C_TESTFLAG_STRING_LITERAL!=second_token_flags
+		|| 'L'==TokenList[i]->data()[critical_offset])
+		{	//! \test cpp/line.C99/Error_badfile1.h, cpp/line.C99/Error_badfile1.hpp
+			//! \test cpp/line.C99/Error_badfile2.h, cpp/line.C99/Error_badfile2.hpp
+		message_header(*TokenList[i]);
+		INC_INFORM(ERR_STR);
+		INFORM("#line wants a narrow string literal for the new __FILE__ (C99 6.10.4p1/C++98 16.4p1)");
+		zcc_errors.inc_error();
+		TokenList.DeleteIdx(i);
+		return;
+		}
+
+	if (i+1 < TokenList.size())
+		{	//! \test cpp/line.C99/Preprocess_42.h, cpp/line.C99/Preprocess_42.hpp
+		//! \todo loops should stop at first (valid) #line directive with a filename
+		// unescape the string, if needed
+		const char* new_FILE = NULL;
+		const size_t escape_length = lang.UnescapeStringLength(TokenList[i]->data()+critical_offset+1,second_token_len-2);
+		if (escape_length<second_token_len-2)
+			{
+			if (0==escape_length)
+				new_FILE = "";
+			else{
+				autovalarray_ptr_throws<char> tmp(escape_length);
+				lang.UnescapeString(tmp.c_array(),TokenList[i]->data()+critical_offset+1,second_token_len-2);
+				new_FILE = register_string(tmp.data());
+				}
+			}
+		else
+			new_FILE = register_substring(TokenList[i]->data()+critical_offset+1,second_token_len-2);
+
+		size_t j = i+1;
+		if (new_FILE!=TokenList[j]->src_filename)
+			while(j<TokenList.size())
+				TokenList[j++]->src_filename = new_FILE;
+		}
+
+	TokenList.DeleteIdx(i);
+}
+
+#/*cut-cpp*/
+#/*cut-nocpp*/
+// don't undef these when testing tokenize-flow preprocessing
+#/*cut-nocpp*/
+#/*cut-cpp*/
+#undef ULONG_BIT
+#undef INVALID_DIRECTIVE_FLAG
+
+void
+CPreprocessor::truncate_illegal_tokens(Token<char>& x,const int directive_type,const size_t critical_offset)
+{
+	if (x.size()<=critical_offset) return;
+	if (x.size()-critical_offset>strspn(x.data()+critical_offset,lang.WhiteSpace+1))
+		{
+		message_header(x);
+		INC_INFORM(ERR_STR);
+		INC_INFORM("#");
+		INC_INFORM(valid_directives[directive_type].first);
+		INFORM(" is trailed by illegal preprocessing tokens; discarding them. (C99 6.10p1/C++98 16p1)");
+		zcc_errors.inc_error();
+		}
+	x.lslice(critical_offset);
+}
+
+bool
+CPreprocessor::hard_locked_macro(const char* const x,const size_t x_len) const
+{
+	assert(x && *x);
+	assert(0<x_len);
+// C99: 6.11.9 Predefined macro names
+// Macro names beginning with __STDC_ are reserved for future standardization.
+//! \bug should have positive test suite for named __STDC_ macros
+	if (7<=x_len && !strncmp(x,"__STDC_",sizeof("__STDC_")-1)) return true;
+#/*cut-cpp*/
+// Lock down our relay identifiers. to be safe
+	if (0<=linear_find_lencached(x,x_len,pragma_relay_keywords,STATIC_SIZE(pragma_relay_keywords))) return true;
+#/*cut-cpp*/
+// C++0x 17.4.3.2.2 simply prohibits all keywords as macros; prefer this to C++98.  C99/C0X is handled elsewhere, as it isn't so draconian.
+// follow C++0x when generalizing to non-standard languages, as that's more intuitive.
+	if (Lang::C!=lang_code && 0<=linear_find_lencached(x,x_len,lang.InvariantKeywords,lang.len_InvariantKeywords)) return true;
+	return 0<=linear_find_lencached(x,x_len,macro_locked_default,macro_locked_default_count);
+}
+
+size_t
+CPreprocessor::function_macro_argument_span(const char* const x) const
+{
+	assert(!is_empty_string(x));
+	if ('('!=x[0]) return 0;
+	const size_t x_len = strlen(x);
+	size_t span = 1;
+	bool identifier_next = true;
+	bool any_identifier = false;
+	bool any_ellipsis = false;
+	while(x_len>span)
+		{
+		if (lang.IsWS_NotFirst(x[span]))
+			{	//! \test define.C99/Error_arglist4.hpp, define.C99/Error_arglist4.h
+				//! \test define.C99/Error_arglist8.hpp, define.C99/Error_arglist8.h
+			span += strspn(x+span,lang.WhiteSpace+1);
+			continue;
+			};
+		if (')'==x[span])
+			{	//! \test define.C99/Error_arglist5.hpp, define.C99/Error_arglist5.h
+			if (!any_identifier || any_ellipsis || !identifier_next) return span+1;
+			INFORM(") after , in function-like macro argument list.");
+			return 0;
+			}
+		if (','==x[span])
+			{
+			if (identifier_next)
+				{	//! \test define.C99/Error_arglist6.hpp, define.C99/Error_arglist6.h
+				INFORM(", when identifier or ... expected in function-like macro argument list.");
+				return 0;
+				}
+			if (any_ellipsis)
+				{	//! \test define.C99/Error_arglist7.hpp, define.C99/Error_arglist7.h
+				INFORM(", after ... in function-like macro argument list.");
+				return 0;
+				}
+			identifier_next = true;
+			++span;
+			continue;
+			}
+
+
+		lex_flags scratch_flags;
+		const size_t token_len = lang.UnfilteredNextToken(x+span,scratch_flags);
+		if (C_TESTFLAG_IDENTIFIER==scratch_flags)
+			{
+			assert(0<token_len);
+			if (identifier_next)
+				{
+				span += token_len;
+				identifier_next = false;
+				any_identifier = true;
+				continue;
+				};
+			//! \test define.C99/Error_arglist8.hpp, define.C99/Error_arglist8.h
+			INC_INFORM("Missing comma in function-like macro argument list before placeholder ");
+			INC_INFORM(x+span,token_len);
+			INFORM(".");
+			return 0;
+			}
+		else if (C_TESTFLAG_NONATOMIC_PP_OP_PUNC==scratch_flags && 3==token_len && !strncmp(x+span,"...",3))
+			{
+			if (identifier_next)
+				{	//! \test define.C99/Pass_arglist.hpp, define.C99/Pass_arglist.h
+				span += token_len;
+				identifier_next = false;
+				any_ellipsis = true;
+				continue;
+				};
+			//! \test define.C99/Error_arglist3.hpp, define.C99/Error_arglist3.h
+			//! \test define.C99/Error_arglist4.hpp, define.C99/Error_arglist4.h
+			INFORM("Missing comma in function-like macro argument list before ...");
+			return 0;
+			};
+		//! \test define.C99/Error_arglist2.hpp, define.C99/Error_arglist2.h
+		INC_INFORM("Unexpected token ");
+		INC_INFORM(x+span,token_len);
+		INFORM(" in function-like macro argument list.");
+		return 0;
+		};
+	//! \test define.C99/Error_arglist1.hpp, define.C99/Error_arglist1.h
+	return 0;
+}
+
+size_t
+CPreprocessor::defined_span(const Token<char>& x, const size_t logical_offset, POD_pair<size_t,size_t>& identifier)
+{	//! \todo more verbose error reporting
+	assert(!strncmp(x.data()+logical_offset,"defined",(sizeof("defined")-1)));
+	size_t offset = logical_offset;
+	offset += (sizeof("defined")-1);
+	if (x.size()<=offset) return 0;
+	const size_t skip_ws = strspn(x.data()+offset,lang.WhiteSpace+1);
+	offset += skip_ws;
+	if (x.size()<=offset) return 0;
+	const bool paren_delimited = ('('==x.data()[offset]);
+	if (paren_delimited)
+		{
+		if (x.size()<= ++offset) return 0;
+		}
+	else if (0==skip_ws)
+		return 0;
+
+	lex_flags scratch_flags;
+	const size_t token_len = lang.UnfilteredNextToken(x.data()+offset,scratch_flags);
+	if (C_TESTFLAG_IDENTIFIER!=scratch_flags) return 0;
+	identifier.first = offset;
+	identifier.second = token_len;
+	offset += token_len;
+	if (x.size()<=offset) return 0;
+	if (!paren_delimited) return offset-logical_offset;
+	offset += strspn(x.data()+offset,lang.WhiteSpace+1);
+	if (x.size()<=offset) return 0;
+	if (')'==x.data()[offset]) return (offset-logical_offset)+1;
+	return 0;
+}
+
+/*! 
+ * test whether two characters will glue two non-whitespace preprocessing tokens into one.
+ * This can tolerate false positives, but not false negatives.
+ * 
+ * \param lhs: left-hand character
+ * \param rhs: right-hand character
+ * 
+ * \return bool true iff they will glue tokens
+ */
+bool CPreprocessor::require_padding(char lhs, char rhs) const
+{
+	if (strchr(lang.WhiteSpace+1,lhs)) return false;	// whitespace is fine
+	if (strchr(lang.WhiteSpace+1,rhs)) return false;
+	if (strchr(lang.AtomicSymbols,lhs)) return false;	// atomic characters are fine
+	if (strchr(lang.AtomicSymbols,rhs)) return false;
+	if ('\''==lhs || '"'==lhs) return false;	// string/character literals are fine
+	if ('\''==rhs || '"'==rhs) return false;
+	// word-chars glue to word-chars
+	// symbol-chars glue to symbol-chars
+	// universal-char-names will glue as well as normal word-chars
+	if (lang.IsWordChar(lhs))
+		{
+		if ('\\'==rhs || lang.IsWordChar(rhs)) return true;
+		return false;
+		};
+	return !lang.IsWordChar(rhs);
+}
+
+/*! 
+ * Checks that a string has no identifiers within it.  That means no macro replacement can happen within it.
+ *
+ * \pre lang uses C_TESTFLAG_IDENTIFIER to indicate an identifier was lexed
+ * 
+ * \param x : string to be checked for identifiers
+ * 
+ * \return bool : true iff there are no identifiers within the string.
+ */
+bool
+CPreprocessor::nonrecursive_macro_replacement_list(const char* const x) const
+{
+	if (is_empty_string(x)) return true;
+	const size_t x_len = strlen(x);
+	size_t offset = 0;
+	lex_flags scratch_flags;
+	while(x_len>offset)
+		{
+		const size_t token_len = lang.UnfilteredNextToken(x+offset,scratch_flags);
+		if (C_TESTFLAG_IDENTIFIER==scratch_flags) return false;
+		offset += token_len;
+		};
+	return true;
+}
+
+/*! 
+ * Calculates whether a function macro invocation completely fits on the given string.
+ * 
+ * \param src		string to examine for argument list
+ * \param src_span	length of string
+ * \param arg_count	if return value non-zero, actual number of arguments found.
+ * 
+ * \return size_t	length of macro invocation argument list
+ */
+size_t
+CPreprocessor::function_macro_invocation_argspan(const char* const src,const size_t src_span,size_t& arg_count) const
+{
+	assert(!is_empty_string(src));
+	assert('('==src[0]);
+	assert(src_span==strlen(src));
+	if (2>src_span) return 0;
+	if (')'==src[1])
+		{
+		arg_count = 0;
+		return 2;
+		}
+	lex_flags scratch_flags;
+	size_t test_arg_count = 1;
+	size_t paren_depth = 1;
+	size_t i = 1;
+	do	{
+		if ('('==src[i]) ++paren_depth;
+		else if (')'==src[i])
+			{
+			if (0== --paren_depth)
+				{
+				arg_count = test_arg_count;
+				return i+1;
+				};
+			}
+		else if (','==src[i])
+			{
+			if (1==paren_depth) ++test_arg_count;
+			}
+		else{
+			const size_t token_len = lang.UnfilteredNextToken(src+i,scratch_flags);
+			assert(0<token_len);
+			i += (token_len-1);
+			}
+		}
+	while(src_span > ++i);
+	return 0;
+}
+
+/*! 
+ * implements C preprocessor stringize operator.
+ * 
+ * \param dest valid C string representing src (postcondition)
+ * \param src to be stringized
+ */
+void
+CPreprocessor::stringize(autovalarray_ptr<char>& dest,const Token<char>* const & src)
+{
+	if (NULL==src || src->empty())
+		{	// empty string
+		dest.resize(2);
+		strcpy(dest.c_array(),"\"\"");
+		return;
+		}
+	
+	dest.resize(2+lang.EscapeStringLength(src->data(),src->size()));
+	dest.front()='"';
+	dest.back()='"';
+
+	lang.EscapeString(dest.c_array()+1,src->data(),src->size());
+}
+
+/*! 
+ * errors and removes clearly bad stringize operators
+ * 
+ * \param x : macro replacement list to verify
+ * 
+ * \return bool true if macro was emptied (caller should complete the cleanup)
+ */
+bool
+CPreprocessor::flush_bad_stringize(Token<char>& x, const Token<char>& arglist)
+{
+	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
+	if (lang.line_lex_find(x.data(),x.size(),"#",sizeof("#")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:",sizeof("%:")-1,pretokenized))
+		{
+		size_t i = 0;
+		bool created_ws = false;
+		while(pretokenized.size()-1>i)
+			{
+			if (detect_C_stringize_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+				{
+				if (pretokenized[i].first+pretokenized[i].second!=pretokenized[i+1].first)
+					{	//! \test define.C99/Error_stringize2.hpp, define.C99/Error_stringize2.h
+					message_header(x);
+					INC_INFORM(ERR_STR);
+					INFORM("# followed by whitespace; excising and continuing (C99 6.10.3.2p1/C++98 16.3.2p1)");
+					zcc_errors.inc_error();
+					memset(x.c_array()+pretokenized[i].first,' ',pretokenized[i].second);
+					pretokenized.DeleteIdx(i);
+					created_ws = true;
+					continue;
+					}
+				if (   C_TESTFLAG_IDENTIFIER!=pretokenized[i+1].third
+					|| SIZE_MAX==lang.lex_find(arglist.data(),arglist.size(),x.data()+pretokenized[i+1].first,pretokenized[i+1].second))
+					{	//! \test define.C99/Error_stringize3.hpp, define.C99/Error_stringize3.h
+					message_header(x);
+					INC_INFORM(ERR_STR);
+					INFORM("# not followed by macro parameter; excising and continuing (C99 6.10.3.2p1/C++98 16.3.2p1)");
+					zcc_errors.inc_error();
+					memset(x.c_array()+pretokenized[i].first,' ',pretokenized[i].second);
+					pretokenized.DeleteIdx(i);
+					created_ws = true;
+					continue;
+					}
+				}
+			++i;
+			}
+
+		if (detect_C_stringize_op(x.data()+pretokenized.back().first,pretokenized.back().second))
+			{	//! \test define.C99/Error_stringize1.hpp, define.C99/Error_stringize1.h
+			message_header(x);
+			INC_INFORM(ERR_STR);
+			INFORM("# terminates macro replacement list; truncating and continuing (C99 6.10.3.2p1/C++98 16.3.2p1)");
+			zcc_errors.inc_error();
+			if (1==pretokenized.size())
+				{
+				x.reset();
+				return true;
+				};
+			pretokenized.DeleteIdx(pretokenized.size()-1);
+			};
+		remove_ws_from_token(x,pretokenized);
+		}
+	return false;
+}
+
+void
+CPreprocessor::object_macro_concatenate(Token<char>& x)
+{	//! \pre: x is normalized
+	//! \test cpp/default/Preprocess_macro_novar_concatenate.hpp, cpp/default/Preprocess_macro_novar_concatenate.h
+	if (4>x.size()) return;
+	assert(!strpbrk(x.data(),lang.WhiteSpace+2));	// check for normalization
+	assert(!strchr(x.data(),'\n'));					// check for normalization
+	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
+	if (lang.line_lex_find(x.data(),x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
+		{
+		assert(!pretokenized.empty());
+		assert(!detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second));
+		assert(!detect_C_concatenation_op(x.data()+pretokenized.back().first, pretokenized.back().second));
+		size_t i = pretokenized.size();
+		do	{
+			--i;
+			if (detect_C_concatenation_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+				{
+				assert(0<i && pretokenized.size()-1>i);
+				if (_concatenate_single(x,pretokenized.data()+(i-1),lang)) --i;
+				}
+			}
+		while(0<i);
+		}
+}
+
+void
+CPreprocessor::function_macro_concatenate_novars(Token<char>& x, const Token<char>& arglist)
+{	//! \pre: x is normalized
+	//! \test cpp/default/Preprocess_macro_novar_concatenate.hpp, cpp/default/Preprocess_macro_novar_concatenate.h
+	if (4>x.size()) return;
+	assert(!strpbrk(x.data(),lang.WhiteSpace+2));	// check for normalization
+	assert(!strchr(x.data(),'\n'));	// check for normalization
+	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
+	if (lang.line_lex_find(x.data(),x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
+		{
+		assert(!pretokenized.empty());
+		assert(!detect_C_concatenation_op(x.data()+pretokenized.front().first,pretokenized.front().second));
+		assert(!detect_C_concatenation_op(x.data()+pretokenized.back().first, pretokenized.back().second));
+		size_t i = pretokenized.size();
+		do	{
+			--i;
+			if (detect_C_concatenation_op(x.data()+pretokenized[i].first,pretokenized[i].second))
+				{
+				assert(0<i && pretokenized.size()-1>i);
+				const bool before_token_is_parameter = (C_TESTFLAG_IDENTIFIER==pretokenized[i-1].third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x.data()+pretokenized[i-1].first,pretokenized[i-1].second) : false;
+
+				if (detect_C_stringize_op(x.data()+pretokenized[i+1].first,pretokenized[i+1].second))
+					{
+					message_header(x);
+					INFORM("warning: order of evaluation of # and ## operators is undefined; evaluating # first (C99 6.10.3.2p2/C++98 16.3.2p2)");
+					message_header(x);
+					// would like these to be errors, but C99 requires accepting
+					if (   !before_token_is_parameter						// not a parameter at all
+						|| (1U<=pretokenized[i-1].first && '#'==x.data()[pretokenized[i-1].first-1])
+						|| (2U<=pretokenized[i-1].first && '%'==x.data()[pretokenized[i-1].first-2] && ':'==x.data()[pretokenized[i-1].first-1]))	// stringized parameter
+						{	//! \test Warn_autofail_concatenation1.hpp
+							//! \test default.nonconforming/Error_autofail_concatenation1.hpp
+							//! \test Warn_autofail_concatenation2.hpp
+							//! \test default.nonconforming/Error_autofail_concatenation2.hpp
+						INC_INFORM((bool_options[boolopt::pedantic]) ? WARN_STR : ERR_STR);
+						INC_INFORM("concatenation automatically fails at macro invocation.");
+						}
+					else{	//! \test Warn_empty_parameter_concatenation1.hpp
+							//! \test default.nonconforming/Error_empty_parameter_concatenation1.hpp
+						INC_INFORM((bool_options[boolopt::pedantic]) ? WARN_STR : ERR_STR);
+						INC_INFORM("concatenation fails at macro invocation if parameter ");
+						INC_INFORM(x.data()+pretokenized[i-1].first,pretokenized[i-1].second);
+						INC_INFORM(" is not empty.");
+						}
+					INFORM((bool_options[boolopt::pedantic]) ? "" : " (ZCPP nonconforming pragmatism)");
+					// defer to here so we get the full messages out
+					if (bool_options[boolopt::warnings_are_errors]) zcc_errors.inc_error();										// for order-of-evaluation
+					if (bool_options[boolopt::warnings_are_errors] || !bool_options[boolopt::pedantic]) zcc_errors.inc_error();	// for wonky concatenation
+					continue;
+					}
+
+				// will not be be able to complete concatenation against a parameter, bail
+				// accept some inefficiency in a weird case to avoid code duplication
+				const bool after_token_is_parameter = (C_TESTFLAG_IDENTIFIER==pretokenized[i+1].third) ? SIZE_MAX!=lang.lex_find(arglist.data(),arglist.size(),x.data()+pretokenized[i+1].first,pretokenized[i+1].second) : false;
+
+				// Of course, C/C++ can't concatenate a string with anything except an empty parameter.
+				if (before_token_is_parameter)
+					{
+					if (	(1U<=pretokenized[i-1].first && '#'==x.data()[pretokenized[i-1].first-1])
+						|| 	(2U<=pretokenized[i-1].first && '%'==x.data()[pretokenized[i-1].first-2] && ':'==x.data()[pretokenized[i-1].first-1]))
+						{	// stringized parameter
+						message_header(x);
+						INFORM("warning: order of evaluation of # and ## operators is undefined; evaluating # first (C99 6.10.3.2p2/C++98 16.3.2p2)");
+						message_header(x);
+						INC_INFORM((bool_options[boolopt::pedantic]) ? WARN_STR : ERR_STR);
+						if (after_token_is_parameter)
+							{	//! \test Warn_autofail_concatenation3.hpp
+								//! \test default.nonconforming/Error_autofail_concatenation3.hpp
+							INC_INFORM("concatenation fails at macro invocation if parameter ");
+							INC_INFORM(x.data()+pretokenized[i+1].first,pretokenized[i+1].second);
+							INC_INFORM(" is not empty.");
+							}
+						else	//! \test Warn_empty_parameter_concatenation2.hpp
+								//! \test default.nonconforming/Error_empty_parameter_concatenation2.hpp
+							INC_INFORM("concatenation automatically fails at macro invocation.");
+						INFORM((bool_options[boolopt::pedantic]) ? "" : " (ZCPP nonconforming pragmatism)");
+						// defer to here so we get the full messages out
+						if (bool_options[boolopt::warnings_are_errors]) zcc_errors.inc_error();										// for order-of-evaluation
+						if (bool_options[boolopt::warnings_are_errors] || !bool_options[boolopt::pedantic]) zcc_errors.inc_error();	// for wonky concatenation
+						};
+					// will not be be able to complete concatenation against a parameter, bail
+					continue;
+					}
+
+				// will not be be able to complete concatenation against a parameter, bail
+				if (after_token_is_parameter) continue;
+
+				if (_concatenate_single(x,pretokenized.data()+(i-1),lang)) --i;
+				}
+			}
+		while(0<i);
+		}
+}
+
+/*
+ * analyzing constant expressions that can actually make it to a control expression (we have to be self-contained)
+ ** no identifiers make it
+ ** possible primary constants
+ *** constant
+ *** string-literal (must allow for token-combination)
+ *** (expression)
+ ** no post-fix operators are valid: [] () . -> postfix ++ postfix --
+ *** well...since a string-literal is a char array [] would be valid on a string.... (and then we have to deal with code points)
+ ** allowed unary operators: + - ~ ! (note that required integral type is one of the target's intmax_t or uintmax_t); this includes interpreting character constants.
+ *** disallowed: prefix ++ prefix -- & * sizeof
+ *** sizeof won't survive identifier zeroing
+ *** * on a string-literal should dereference to a character, so allow &* cancellation on string literals
+ *** allow *& cancellation always?
+ ** no cast operators allowed
+ ** allowed multiplicative operators: * / %
+ ** allowed additive operators: + -
+ ** allowed bitwise shift operators: << >>
+ ** allowed relational operators: < > <= >=
+ ** allowed equality operators: == !=
+ ** bitwise and operator: &
+ ** bitwise exclusive or: ^
+ ** bitwise inclusive or: |
+ ** logical and: &&
+ ** logical or: ||
+ ** conditional operator: ? :
+ ** no assignment operators allowed
+ ** comma operator: , (although probably not incredibly useful...)
+
+ Since we need intmax_t and uintmax_t anyway to do this right: perhaps limits.h should be a virtual header generated from a target_info object
+ automatic header also could handle the "no keywords defined when including a system header", but there probably is a more elegant way to do this
+
+ Also: C99 7.1.2p4 prohibits all keywords from having macro definitions at the time of including the standard headers
+<assert.h>
+<complex.h>
+<ctype.h>
+<errno.h>
+<fenv.h>
+<float.h>
+<inttypes.h>
+<iso646.h>
+<limits.h>
+<locale.h>
+<math.h>
+<setjmp.h>
+<signal.h>
+<stdarg.h>
+<stdbool.h>
+<stddef.h>
+<stdint.h>
+<stdio.h>
+<stdlib.h>
+<string.h>
+<tgmath.h>
+<time.h>
+<wchar.h>
+<wctype.h>
+
+C++98 17.3.3.1.1p2 goes further and prohibits defining macros for any names declared or defined in a library header.
+<algorithm> <iomanip> <list> <ostream> <streambuf>
+<bitset> <ios> <locale> <queue> <string>
+<complex> <iosfwd> <map> <set> <typeinfo>
+<deque> <iostream> <memory> <sstream> <utility>
+<exception> <istream> <new> <stack> <valarray>
+<fstream> <iterator> <numeric> <stdexcept> <vector>
+<functional> <limits>
+
+<cassert> <ciso646> <csetjmp> <cstdio> <ctime>
+<cctype> <climits> <csignal> <cstdlib> <cwchar>
+<cerrno> <clocale> <cstdarg> <cstring> <cwctype>
+<cfloat> <cmath> <cstddef>
+
+C++98 17.3.3.1.1p1 prohibits undefining any macro defined in a library header (watch out for assert.h)
+C99 7.1.3p1,3 prohibit defining macros for any identifier declared in a library header
+ */
+#/*cut-cpp*/
+#/*cut-nocpp*/
+#if 0
+void
+CPreprocessor::_preprocess_alt(autovalarray_ptr<Token<char>* >& TokenList, autovalarray_ptr<char*>& locked_macros, autovalarray_ptr<char*>& macros_object, autovalarray_ptr<Token<char>*>& macros_object_expansion, autovalarray_ptr<Token<char>*>& macros_object_expansion_pre_eval, autovalarray_ptr<char*>& macros_function, autovalarray_ptr<Token<char>*>& macros_function_arglist, autovalarray_ptr<Token<char>*>& macros_function_expansion, autovalarray_ptr<Token<char>*>& macros_function_expansion_pre_eval, autovalarray_ptr<POD_triple<const char*, const char*,uintptr_t> >& include_file_index, autovalarray_ptr<POD_pair<const char*,autovalarray_ptr<Token<char>*>* > >& include_file_cache, const type_system& min_types)
+{
+	TokenList.MoveInto(inbound_lines);
+Restart:
+	INFORM("===");
+	INFORM(inbound_lines.size());
+	INFORM(outbound_tokens.size());
+	size_t i = 0;
+	if (inbound_lines.empty())
+		{
+		outbound_tokens.MoveInto(TokenList);
+		return;
+		}
+	size_t if_depth = 0;
+	size_t if_where = 0;			// origin 0
+	size_t else_where = 0;			// origin 1; 0 is not triggered
+	size_t include_where = 0;		// origin 1; 0 is not triggered
+	size_t restart_full_scan = 0;	// origin 1; 0 is not triggered
+	do	{
+		if (line_is_preprocessing_directive(*inbound_lines[i]))
+			{	// directive
+			{	// scoping brace
+			const size_t token_size = inbound_lines[i]->size();
+			if (1==token_size)
+				{
+				inbound_lines.DeleteIdx(i);	// Null directive #, delete
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+			const size_t whitespace_size = strspn(inbound_lines[i]->data()+1,lang.WhiteSpace+1);
+			if (token_size-1 == whitespace_size)
+				{
+				inbound_lines.DeleteIdx(i);	// Null directive #, delete
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+
+			inbound_lines[i]->flags |= PREPROCESSING_DIRECTIVE_FLAG;
+			if (0<whitespace_size)
+				{	// normalize
+				inbound_lines[i]->c_array()[whitespace_size] = '#';
+				inbound_lines[i]->ltrim(whitespace_size);
+				assert(!inbound_lines[i]->empty());
+				assert('#'==inbound_lines[i]->front());
+				};
+			}	// end scoping brace
+			const errr directive_type = find_directive(inbound_lines[i]->data()+1,lang);
+			if (0>directive_type && 0==if_depth)
+				{	//! \test Warn_unrecognized_directive.hpp : naked unrecognized directive
+				message_header(*inbound_lines[i]);
+				INC_INFORM("warning: unrecognized preprocessing directive '");
+				size_t j = 0;
+				while(++j<inbound_lines[i]->size() && !lang.IsWS_NotFirst(inbound_lines[i]->data()[j]))
+					INC_INFORM(inbound_lines[i]->data()[j]);
+				INFORM("' (C99 6.10p1/C++98 16.1p1)");
+				if (bool_options[boolopt::warnings_are_errors]) zcc_errors.inc_error();
+				inbound_lines.DeleteIdx(i);
+				if (0==i) goto Restart;
+				--i;
+				continue;
+				};
+
+			// stripping trailing spaces damages incomplete string and character literals.
+			switch(directive_type)
+			{
+			case PP::IF:		
+			case PP::IFDEF:		
+			case PP::IFNDEF:	
+			case PP::ELIF:		
+			case PP::ELSE:		
+			case PP::ENDIF:		
+			case PP::INCLUDE:	
+			case PP::DEFINE:	
+			case PP::UNDEF:		
+			case PP::LINE:		
+			case PP::ERROR:		
+			case PP::PRAGMA:	{	// normalize the whitespace; allowed to shove directive left to do it
+								size_t critical_offset = valid_directives[directive_type].second+1;
+								if (inbound_lines[i]->size()>critical_offset)
+									{
+									const size_t intra_WS = strspn(inbound_lines[i]->data()+critical_offset,lang.WhiteSpace+1);
+									if (0==intra_WS)
+										//! \todo really should be a bit more clever about this
+										inbound_lines[i]->replace_once(critical_offset,0,' ');
+									else if (inbound_lines[i]->size()-critical_offset<=intra_WS)
+										{
+										if (PP::PRAGMA==directive_type)
+											{
+											inbound_lines.DeleteIdx(i);	// empty pragma is legal, but Z.C++ says it has no effect
+											if (0==i) goto Restart;
+											--i;
+											continue;
+											};
+										inbound_lines[i]->rtrim(intra_WS);
+										}
+									else if (1<intra_WS)
+										inbound_lines[i]->replace_once(std::nothrow,critical_offset,intra_WS,' ');
+									else
+										inbound_lines[i]->c_array()[critical_offset] = ' ';
+									}
+								PACK_DIRECTIVE(inbound_lines[i]->flags,directive_type);
+								assert(inbound_lines[i]->size()>=valid_directives[directive_type].second+1);
+								break;
+								};
+			default:			{	// Unrecognized.  Warn-and-delete when we know it's going to be executed (not within any conditional blocks.
+								PACK_DIRECTIVE(inbound_lines[i]->flags,PP_INVALID);
+								break;
+								};
+			};
+
+			// #if nesting-depth 0 processing
+			if (0==if_depth)
+				{
+				lex_flags first_token_flags = 0;
+				size_t first_token_len = 0;
+				if (PP::ERROR==directive_type)
+					{	// an error by fiat
+						//! \test cpp/Error_error_directive.hpp
+						//! \test cpp/Error_error_directive2.hpp
+					message_header(*inbound_lines[i]);
+					INC_INFORM(ERR_STR);
+					INFORM(inbound_lines[i]->data()+(sizeof("#error ")-1));
+					inbound_lines.DeleteIdx(i);
+					zcc_errors.inc_error();
+					if (0==i) goto Restart;
+					--i;
+					continue;
+					};
+				if (   PP::ELSE ==directive_type
+					|| PP::ELIF ==directive_type
+					|| PP::ENDIF==directive_type)
+					{	// no prior #if/#ifdef/#ifndef is an error
+					//! \test Error_naked_else.hpp : #else without #if/#ifdef/#ifndef
+					//! \test Error_naked_elif.hpp : #elif without #if/#ifdef/#ifndef
+					//! \test Error_naked_endif.hpp : #endif without #if/#ifdef/#ifndef
+					//! \test Error_elif_after_else.hpp : #elif after #else
+					//! \test Error_else_after_else.hpp : #else after #else
+					message_header(*inbound_lines[i]);
+					INC_INFORM(ERR_STR);
+					INC_INFORM("#");
+					INC_INFORM(valid_directives[directive_type].first);
+					INFORM(" without paired #if/#ifdef/#ifndef (C99 6.10p1/C++98 16.1p1)");
+					inbound_lines.DeleteIdx(i);
+					zcc_errors.inc_error();
+					if (0==i) goto Restart;
+					--i;
+					continue;
+					};
+				if (   PP::DEFINE ==directive_type
+					|| PP::UNDEF  ==directive_type
+					|| PP::INCLUDE==directive_type
+					|| PP::LINE   ==directive_type)
+					{	// these must have preprocessing tokens to be meaningful
+					//! \test Error_no_token_define.hpp : #define no tokens
+					//! \test Error_no_token_undef.hpp : #undef no tokens
+					//! \test Error_no_token_include.hpp : #include no tokens
+					//! \test Error_no_token_line.hpp : #line no tokens
+					if (inbound_lines[i]->size()==valid_directives[directive_type].second+1)
+						{
+						message_header(*inbound_lines[i]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("#");
+						INC_INFORM(valid_directives[directive_type].first);
+						INFORM(" must have preprocessing tokens afterwards (allowing for macro substitution); discarding. (C99 6.10p1/C++98 16.1p1)");
+						inbound_lines.DeleteIdx(i);
+						zcc_errors.inc_error();
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					}
+				if (   PP::DEFINE ==directive_type
+					|| PP::UNDEF  ==directive_type)
+					{	// do basic legality checks now: C identifier, not locked
+					const size_t critical_offset = valid_directives[directive_type].second+2;
+					if (inbound_lines[i]->size()>critical_offset) first_token_len = lang.UnfilteredNextToken(inbound_lines[i]->data()+critical_offset,first_token_flags);
+					if (C_TESTFLAG_IDENTIFIER!=first_token_flags)
+						{	//! \test Error_undef_no_identifier.hpp : #undef without identifier
+						message_header(*inbound_lines[i]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("#");
+						INC_INFORM(valid_directives[directive_type].first);
+						INFORM(" does not have an identifier afterwards; discarding. (C99 6.10p1/C++98 16.1p1)");
+						inbound_lines.DeleteIdx(i);
+						zcc_errors.inc_error();
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+
+					// want to catch illegal tokens before ditching a #undef of a locked macro
+					//! \test Error_undef_illegal_tokens.hpp : #undef illegal tokens
+					if (PP::UNDEF==directive_type) truncate_illegal_tokens(*inbound_lines[i],directive_type,critical_offset+first_token_len);
+
+					if (hard_locked_macro(inbound_lines[i]->data()+critical_offset,first_token_len))
+						{	//! \test Error_undef_STDC.hpp : #undef __STDC__
+						discard_locked_macro(inbound_lines,i,directive_type,first_token_len);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					if (	0==include_where && 0==restart_full_scan
+						&&	pragma_locked_macro(inbound_lines[i]->data()+critical_offset,first_token_len,locked_macros))
+						{	// here so we don't recalculate the above
+						//! \test cpp/Error_undef_locked_macro.hpp
+						discard_locked_macro(inbound_lines,i,directive_type,first_token_len);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					if (PP::DEFINE==directive_type && inbound_lines[i]->size()>critical_offset+first_token_len)
+						{	// standardize silently
+						const size_t intra_WS = strspn(inbound_lines[i]->data()+critical_offset+first_token_len,lang.WhiteSpace+1);
+						if (inbound_lines[i]->size()-(critical_offset+first_token_len)<=intra_WS)
+							inbound_lines[i]->rtrim(intra_WS);	// normalize -- null-def object-like macro
+						else if (1<intra_WS)
+							inbound_lines[i]->replace_once(std::nothrow,critical_offset+first_token_len,intra_WS,' ');
+						}
+					};
+				if (PP::PRAGMA==directive_type)
+					{
+					const size_t critical_offset = valid_directives[directive_type].second+2;
+					assert(inbound_lines[i]->size()>critical_offset);
+					if (C99_VA_ARGS_flinch(*inbound_lines[i],sizeof("pragma ")-1))
+						{	//! \test Error_pragma_VA_ARGS.hpp
+						message_header(*inbound_lines[i]);
+						INFORM("discarding pragma");
+						inbound_lines.DeleteIdx(i);	// ignore the pragma
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					first_token_len = lang.UnfilteredNextToken(inbound_lines[i]->data()+critical_offset,first_token_flags);
+					if (0>linear_find_lencached(inbound_lines[i]->data()+critical_offset, first_token_len, accept_pragma_leading_tokens, STATIC_SIZE(accept_pragma_leading_tokens)))
+						{
+						inbound_lines.DeleteIdx(i);	// ignore the pragma
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					}
+				if (PP::INCLUDE==directive_type && 0==include_where)
+					{	// we have an include; postpone inclusion
+						// don't think memory conservation is ISO
+					if (0==restart_full_scan)
+						intradirective_preprocess(*inbound_lines[i], sizeof("#include ")-1,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval);
+					include_where = i+1;
+					};
+				if (0==include_where && 0==restart_full_scan)
+					{
+					if (PP::LINE==directive_type)
+						{
+						if (C99_VA_ARGS_flinch(*inbound_lines[i],sizeof("#line ")-1))
+							{	//! \test cpp/line.C99/Error_VA_ARGS.h, cpp/line.C99/Error_VA_ARGS.hpp
+							message_header(*inbound_lines[i]);
+							INFORM("discarding #line directive");
+							inbound_lines.DeleteIdx(i);
+							if (0==i) goto Restart;
+							--i;
+							continue;
+							};
+
+						intradirective_preprocess(*inbound_lines[i], sizeof("#line ")-1,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval);
+						use_line_directive_and_discard(inbound_lines,i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						};
+					if (PP::UNDEF==directive_type)
+						{
+						const size_t critical_offset = valid_directives[directive_type].second+2;
+						assert(0<first_token_len);
+						assert(inbound_lines[i]->size()>=critical_offset+first_token_len);
+						// apply undef
+						const errr object_macro_index = binary_find(inbound_lines[i]->data()+critical_offset,first_token_len,macros_object);
+						const errr function_macro_index = binary_find(inbound_lines[i]->data()+critical_offset,first_token_len,macros_function);
+						assert(0>object_macro_index || 0>function_macro_index);
+						if (0<=object_macro_index)
+							{
+							macros_object.DeleteIdx(object_macro_index);
+							macros_object_expansion.DeleteIdx(object_macro_index);
+							macros_object_expansion_pre_eval.DeleteIdx(object_macro_index);
+							};
+						if (0<=function_macro_index)
+							{
+							macros_function.DeleteIdx(function_macro_index);
+							macros_function_arglist.DeleteIdx(function_macro_index);
+							macros_function_expansion.DeleteIdx(function_macro_index);
+							macros_function_expansion_pre_eval.DeleteIdx(function_macro_index);
+							}
+						inbound_lines.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					if (PP::DEFINE==directive_type)
+						{
+						const size_t critical_offset = valid_directives[directive_type].second+2;
+						assert(0<first_token_len);
+						assert(inbound_lines[i]->size()>=critical_offset+first_token_len);
+						const errr object_macro_index = binary_find(inbound_lines[i]->data()+critical_offset,first_token_len,macros_object);
+						const errr function_macro_index = binary_find(inbound_lines[i]->data()+critical_offset,first_token_len,macros_function);
+						assert(0>object_macro_index || 0>function_macro_index);
+						if (inbound_lines[i]->size()==critical_offset+first_token_len)
+							{	// object-like, empty string
+ObjectLikeMacroEmptyString:
+							if (	 0<=function_macro_index
+								|| 	(0<=object_macro_index && NULL!=macros_object_expansion[object_macro_index]))
+								{	//! \test define.C99/Error_dup1.hpp, define.C99/Error_dup1.h
+									//! \test define.C99/Error_dup2.hpp, define.C99/Error_dup2.h
+								discard_duplicate_define(inbound_lines,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (0<=object_macro_index)
+								{	// already present: discard silently
+									//! \test define.C99/Pass_dup1.hpp, define.C99/Pass_dup1.h
+								inbound_lines.DeleteIdx(i);	// discard silently
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							const size_t object_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(object_macro_index);
+							macros_object.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion_pre_eval.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object[object_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
+							strncpy(macros_object[object_macro_insertion_index],inbound_lines[i]->data()+critical_offset,first_token_len);
+							ZAIMONI_NULL_TERMINATE(macros_object[object_macro_insertion_index][first_token_len]);
+							}
+						else if (lang.IsWS_NotFirst(inbound_lines[i]->data()[critical_offset+first_token_len]))
+							{	// object-like, not empty string
+							if (	0<=function_macro_index
+								|| 	(0<=object_macro_index && NULL==macros_object_expansion[object_macro_index]))
+								{	//! \test define.C99/Error_dup3.hpp, define.C99/Error_dup3.h
+									//! \test define.C99/Error_dup4.hpp, define.C99/Error_dup4.h
+									//! \test define.C99/Pass_dup2.hpp, define.C99/Pass_dup2.h
+								discard_duplicate_define(inbound_lines,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+							Token<char> expansion(*inbound_lines[i],critical_offset+first_token_len,inbound_lines[i]->size()-(critical_offset+first_token_len),0);
+							normalize_macro_expansion(expansion,*inbound_lines[i],critical_offset,first_token_len);
+							//! \test define.C99/Pass_dup2.hpp, define.C99/Pass_dup2.h
+							//! \test define.C99/Error_concatenate1.hpp, define.C99/Error_concatenate1.h
+							//! \test define.C99/Error_concatenate2.hpp, define.C99/Error_concatenate2.h
+							if (discard_leading_trailing_concatenate_op(expansion))
+								goto ObjectLikeMacroEmptyString;
+							if (0<=object_macro_index)
+								{	//! \test define.C99/Error_dup5.hpp, define.C99/Error_dup5.h
+									//! \test define.C99/Pass_dup2.hpp, define.C99/Pass_dup2.h
+								if (strcmp(expansion.data(),macros_object_expansion[object_macro_index]->data()))
+									discard_duplicate_define(inbound_lines,i,critical_offset,first_token_len);
+								else
+									inbound_lines.DeleteIdx(i);	// discard silently even if it matches
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (C99_VA_ARGS_flinch(expansion,0))
+								{	//! \test define.C99/Error_VA_ARGS.hpp, define.C99/Error_VA_ARGS.h
+								message_header(expansion);
+								INFORM("discarding macro");
+								inbound_lines.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+
+							// DO NOT check for context free errors here; could legitimately want to deep-stringize every invocation of the macro
+							const size_t object_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(object_macro_index);
+							macros_object.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object_expansion_pre_eval.insertNSlotsAt(1,object_macro_insertion_index);
+							macros_object[object_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
+
+							strncpy(macros_object[object_macro_insertion_index],inbound_lines[i]->data()+critical_offset,first_token_len);
+							ZAIMONI_NULL_TERMINATE(macros_object[object_macro_insertion_index][first_token_len]);
+							macros_object_expansion_pre_eval[object_macro_insertion_index] = new Token<char>(expansion);
+							macros_object_expansion[object_macro_insertion_index] = new Token<char>;
+							expansion.MoveInto(*macros_object_expansion[object_macro_insertion_index]);
+							object_macro_concatenate(*macros_object_expansion_pre_eval[object_macro_insertion_index]);
+							if (C99_VA_ARGS_flinch(*macros_object_expansion_pre_eval[object_macro_insertion_index],0))
+								{	//! \test define.C99/Error_concatenate5.hpp, define.C99/Error_concatenate5.h
+								message_header(*macros_object_expansion_pre_eval[object_macro_insertion_index]);
+								INFORM("discarding macro");
+								macros_object.DeleteIdx(object_macro_insertion_index);
+								macros_object_expansion.DeleteIdx(object_macro_insertion_index);
+								macros_object_expansion_pre_eval.DeleteIdx(object_macro_insertion_index);
+								inbound_lines.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							//! \todo should do locked macros [not __FILE__ or __LINE__] that are not first or last identifiers on speculation
+							}
+						else if ('('==inbound_lines[i]->data()[critical_offset+first_token_len])
+							{	// function-like
+							const size_t argspan = function_macro_argument_span(inbound_lines[i]->data()+critical_offset+first_token_len);
+							if (0==argspan)
+								{
+								message_header(*inbound_lines[i]);
+								INC_INFORM(ERR_STR);
+								INC_INFORM(inbound_lines[i]->data()+critical_offset,first_token_len);
+								INFORM(" has an invalid argument list.  Discarding. (C99 6.10.3p/C++0x 16.3p10)");
+								inbound_lines.DeleteIdx(i);
+								zcc_errors.inc_error();
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (0<=object_macro_index)
+								{	//! \test define.C99/Error_dup6.hpp, define.C99/Error_dup6.h
+								discard_duplicate_define(inbound_lines,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							Token<char> arglist(*inbound_lines[i],critical_offset+first_token_len,argspan,0);
+							normalize_macro_expansion(arglist,*inbound_lines[i],critical_offset,first_token_len);	// should be no string literals here, so should be no errors here
+							if (0<=function_macro_index && strcmp(arglist.data(),macros_function_arglist[function_macro_index]->data()))
+								{	//! \test define.C99/Error_dup7.hpp, define.C99/Error_dup7.h
+								discard_duplicate_define(inbound_lines,i,critical_offset,first_token_len);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if (inbound_lines[i]->size()-(critical_offset+first_token_len)>argspan)
+								{
+								const size_t skip_ws = strspn(inbound_lines[i]->data()+critical_offset+first_token_len+argspan,lang.WhiteSpace+1);
+								if (inbound_lines[i]->size()-(critical_offset+first_token_len+argspan)<=skip_ws)
+									inbound_lines[i]->rtrim(skip_ws);
+								};
+							if (inbound_lines[i]->size()-(critical_offset+first_token_len)<=argspan)
+								{	// empty expansion
+FunctionLikeMacroEmptyString:	if (0<=function_macro_index)
+									{	//! \test define.C99/Error_dup9.hpp, define.C99/Error_dup9.h
+										//! \test define.C99/Pass_dup4.h, define.C99/Pass_dup4.h
+									if (NULL!=macros_function_expansion[function_macro_index])
+										discard_duplicate_define(inbound_lines,i,critical_offset,first_token_len);
+									else
+										inbound_lines.DeleteIdx(i);	// ignore silently if exactly agreed
+									if (0==i) goto Restart;
+									--i;
+									continue;
+									}
+								const size_t function_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(function_macro_index);
+								macros_function.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_arglist.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_expansion.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function_expansion_pre_eval.insertNSlotsAt(1,function_macro_insertion_index);
+								macros_function[function_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
+
+								strncpy(macros_function[function_macro_insertion_index],inbound_lines[i]->data()+critical_offset,first_token_len);
+								ZAIMONI_NULL_TERMINATE(macros_function[function_macro_insertion_index][first_token_len]);
+								macros_function_arglist[function_macro_insertion_index] = new Token<char>;
+								arglist.MoveInto(*macros_function_arglist[function_macro_insertion_index]);
+
+								inbound_lines.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							Token<char> expansion(*inbound_lines[i],critical_offset+first_token_len+argspan,inbound_lines[i]->size()-(critical_offset+first_token_len+argspan),0);
+							normalize_macro_expansion(expansion,*inbound_lines[i],critical_offset,first_token_len);
+							// white-box test policy: cases above will work
+							if (discard_leading_trailing_concatenate_op(expansion))
+								goto FunctionLikeMacroEmptyString;
+							if (0<=function_macro_index)
+								{	//! \test define.C99/Error_dup8.hpp, define.C99/Error_dup8.h
+									//! \test define.C99/Pass_dup3.h, define.C99/Pass_dup3.h
+								if (strcmp(expansion.data(),macros_function_expansion[function_macro_index]->data()))
+									discard_duplicate_define(inbound_lines,i,critical_offset,first_token_len);
+								else
+									inbound_lines.DeleteIdx(i);	// discard silently even if it matches
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								};
+							if ((5>arglist.size() || strcmp(arglist.end()-(sizeof("...)")-1),"...)")) && C99_VA_ARGS_flinch(expansion,0))
+								{	//! \test define.C99/Error_VA_ARGS2.hpp, define.C99/Error_VA_ARGS2.h
+									//! \test define.C99/Pass_VA_ARGS.hpp, define.C99/Pass_VA_ARGS.h
+								message_header(expansion);
+								INFORM("discarding macro");
+								inbound_lines.DeleteIdx(i);
+								if (0==i) goto Restart;
+								--i;
+								continue;
+								}
+
+							// DO NOT check for context free errors here; could legitimately want to deep-stringize every invocation of the macro
+							const size_t function_macro_insertion_index = BINARY_SEARCH_DECODE_INSERTION_POINT(function_macro_index);
+							macros_function.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_arglist.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_expansion.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function_expansion_pre_eval.insertNSlotsAt(1,function_macro_insertion_index);
+							macros_function[function_macro_insertion_index] = _new_buffer_nonNULL_throws<char>(ZAIMONI_LEN_WITH_NULL(first_token_len));
+
+							strncpy(macros_function[function_macro_insertion_index],inbound_lines[i]->data()+critical_offset,first_token_len);
+							ZAIMONI_NULL_TERMINATE(macros_function[function_macro_insertion_index][first_token_len]);
+							macros_function_arglist[function_macro_insertion_index] = new Token<char>;
+							macros_function_expansion[function_macro_insertion_index] = new Token<char>;
+							macros_function_expansion_pre_eval[function_macro_insertion_index] = new Token<char>(expansion);
+							arglist.MoveInto(*macros_function_arglist[function_macro_insertion_index]);
+							expansion.MoveInto(*macros_function_expansion[function_macro_insertion_index]);
+							if (flush_bad_stringize(*macros_function_expansion_pre_eval[function_macro_insertion_index],*macros_function_arglist[function_macro_insertion_index]))
+								{
+								delete macros_function_expansion_pre_eval[function_macro_insertion_index];
+								macros_function_expansion_pre_eval[function_macro_insertion_index] = NULL;
+								};
+							if (NULL!=macros_function_expansion_pre_eval[function_macro_insertion_index])
+								{
+								function_macro_concatenate_novars(*macros_function_expansion_pre_eval[function_macro_insertion_index], *macros_function_arglist[function_macro_insertion_index]);
+								if ((5>macros_function_arglist[function_macro_insertion_index]->size() || strcmp(macros_function_arglist[function_macro_insertion_index]->end()-(sizeof("...)")-1),"...)")) && C99_VA_ARGS_flinch(*macros_function_expansion_pre_eval[function_macro_insertion_index],0))
+									{	//! \test define.C99/Error_concatenate6.hpp, define.C99/Error_concatenate6.h
+										//! \test define.C99/Pass_concatenate3.hpp, define.C99/Pass_concatenate3.h
+									message_header(*macros_function_expansion_pre_eval[function_macro_insertion_index]);
+									INFORM("discarding macro");
+									macros_function.DeleteIdx(function_macro_insertion_index);
+									macros_function_arglist.DeleteIdx(function_macro_insertion_index);
+									macros_function_expansion.DeleteIdx(function_macro_insertion_index);
+									macros_function_expansion_pre_eval.DeleteIdx(function_macro_insertion_index);
+									inbound_lines.DeleteIdx(i);
+									if (0==i) goto Restart;
+									--i;
+									continue;
+									}
+								};
+							//! \todo should do locked macros [not __FILE__ or __LINE__] that are not first or last identifiers on speculation
+							};
+						inbound_lines.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+						}
+					// should use #pragma directives
+					// all three STDC pragmas are scoped: they have to be around until fairly late in the compilation sequence
+					// we are required to ignore unrecognized pragmas -- no warnings
+					// want immediately: #pragma ZCC lock ___
+					// * locks macros
+					if (PP::PRAGMA==directive_type)
+						{
+						const size_t critical_offset = valid_directives[directive_type].second+2;
+//#/*cut-cpp*/
+						const unsigned int pragma_code =
+//#/*cut-cpp*/
+						interpret_pragma(inbound_lines[i]->data()+critical_offset,inbound_lines[i]->size()-critical_offset,locked_macros);
+//#/*cut-cpp*/
+						switch(pragma_code)
+						{
+						default:
+//#/*cut-cpp*/
+						inbound_lines.DeleteIdx(i);
+						if (0==i) goto Restart;
+						--i;
+						continue;
+//#/*cut-cpp*/
+						case RELAY_ZCC_ENABLE_TYPEID+1:
+							inbound_lines[i]->replace_once(0,inbound_lines[i]->size(),pragma_relay_keywords[pragma_code-1].first,pragma_relay_keywords[pragma_code-1].second);
+							continue;
+						}
+//#/*cut-cpp*/
+						}
+					}
+				}
+
+			if (   PP::IF    ==directive_type
+				|| PP::IFDEF ==directive_type
+				|| PP::IFNDEF==directive_type)
+				{
+				if (1 == ++if_depth)
+					{
+					if_where = i;
+					else_where = 0;
+					// front-load syntax checking
+					// only report errors once
+					if (!(inbound_lines[i]->flags & INVALID_DIRECTIVE_FLAG) && 0==include_where)
+						{
+						if (PP::IF==directive_type)
+							{
+							if (!if_elif_syntax_ok(*inbound_lines[i],macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,min_types))
+								inbound_lines[i]->flags |= INVALID_DIRECTIVE_FLAG;
+							}
+						else{
+							if (!ifdef_ifndef_syntax_ok(*inbound_lines[i],macros_object,macros_function))
+								inbound_lines[i]->flags |= INVALID_DIRECTIVE_FLAG;
+							else
+								assert(PP::IF==UNPACK_DIRECTIVE(inbound_lines[i]->flags));
+							}
+						}
+					if (0==restart_full_scan)
+						{
+						restart_full_scan = i+1;
+						//! \todo do it all, have complete information
+						};
+					//! \todo front-load syntax checking, etc. when safe [0==include_where && if_where+1==restart_full_scan]
+					//! can detect gross-invalidity anyway, but anything requiring authoritiatively knowing macro (un)defined-ness won't go through
+					}
+				}
+			else if (   PP::ELSE ==directive_type
+					 || PP::ELIF ==directive_type
+					 || PP::ENDIF==directive_type)
+				{
+				assert(0<if_depth);
+				if (1==if_depth)
+					{
+					if (PP::ELIF!=directive_type)
+						//! test Error_else_with_tokens.hpp : #else with tokens
+						//! test Error_endif_with_tokens.hpp : #endif with tokens
+						truncate_illegal_tokens(*inbound_lines[i],directive_type,valid_directives[directive_type].second+1);
+					else if (	!(inbound_lines[i]->flags & INVALID_DIRECTIVE_FLAG)
+							 && !if_elif_syntax_ok(*inbound_lines[i],macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,min_types))
+						inbound_lines[i]->flags |= INVALID_DIRECTIVE_FLAG;
+					};
+
+				if (PP::ENDIF==directive_type)
+					{
+					if (0 == --if_depth)
+						{	// trigger conditional preprocessing here
+						assert(inbound_lines[if_where]->flags & PREPROCESSING_DIRECTIVE_FLAG);
+						assert(0==else_where || (inbound_lines[else_where-1]->flags & PREPROCESSING_DIRECTIVE_FLAG));
+						assert(0==else_where || (if_where<=else_where && else_where<=i));
+						if (inbound_lines[if_where]->flags & INVALID_DIRECTIVE_FLAG)
+							{	// already tagged as invalid
+							message_header(*inbound_lines[if_where]);
+							INFORM("Ignoring entire block controlled by flawed directive");
+							inbound_lines.DeleteNSlotsAt(i-if_where+1,if_where);
+							i = if_where;
+							if (0==i) goto Restart;
+							if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
+							if (include_where>=i+1) include_where = 0;			// failsafing
+							--i;
+							continue;
+							};
+
+						// inject reductions here
+						const unsigned int else_directive = (0==else_where) ? PP_INVALID : UNPACK_DIRECTIVE(inbound_lines[else_where-1]->flags);
+						assert(0==else_where || PP::ELSE==else_directive || PP::ELIF==else_directive);
+						if (!strcmp(inbound_lines[if_where]->data(),"#if 0"))
+							{
+							if (0==else_where)
+								{
+								inbound_lines.DeleteNSlotsAt(i-if_where+1,if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
+								if (include_where>=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							if (PP::ELSE==else_directive)
+								{
+								inbound_lines.DeleteIdx(i);
+//								inbound_lines.DeleteNSlotsAt((else_where-1)-if_where+1,if_where);
+								inbound_lines.DeleteNSlotsAt(else_where-if_where,if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
+								if (include_where>=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							if (inbound_lines[else_where-1]->flags & INVALID_DIRECTIVE_FLAG)
+								{	//! \test Error8.hpp : #elif no control expression, critical
+								message_header(*inbound_lines[else_where-1]);
+								INFORM("Ignoring all lines from invalid #elif to matching #endif");
+								inbound_lines.DeleteNSlotsAt(i-if_where+1,if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
+								if (include_where>=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							//! \todo do full reduction here to make errors read #elif rather than #if
+							// recurse it
+							inbound_lines[else_where-1]->c_array()[2] = '#';
+							inbound_lines[else_where-1]->ltrim(2);
+							PACK_DIRECTIVE(inbound_lines[else_where-1]->flags,PP::IF);
+//							inbound_lines.DeleteNSlotsAt((else_where-1)-if_where+1,if_where);
+							inbound_lines.DeleteNSlotsAt(else_where-if_where+2,if_where);
+							i = if_where;
+							if (0==i) goto Restart;
+							if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
+							if (include_where>=i+1) include_where = 0;			// failsafing
+							--i;
+							continue;
+							};
+						if (!strcmp(inbound_lines[if_where]->data(),"#if 1"))
+							{
+							if (0==else_where)
+								{
+								inbound_lines.DeleteIdx(i);
+								inbound_lines.DeleteIdx(if_where);
+								i = if_where;
+								if (0==i) goto Restart;
+								if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
+								if (include_where>=i+1) include_where = 0;			// failsafing
+								--i;
+								continue;
+								};
+							if (PP::ELIF==else_directive && (inbound_lines[else_where-1]->flags & INVALID_DIRECTIVE_FLAG))
+								{	//! \test Error9.hpp : #elif no control expression, non-critical
+								message_header(*inbound_lines[else_where-1]);
+								INFORM("Continuing as expression for invalid #elif not needed.");
+								};
+//							inbound_lines.DeleteNSlotsAt(i-(else_where-1)+1,else_where-1);
+							inbound_lines.DeleteNSlotsAt(i-else_where+2,else_where-1);
+							inbound_lines.DeleteIdx(if_where);
+							i = if_where;
+							if (0==i) goto Restart;
+							if (restart_full_scan>=i+1) restart_full_scan = 0;	// very possible
+							if (include_where>=i+1) include_where = 0;			// failsafing
+							--i;
+							continue;
+							};
+						}
+					}
+				else if (1==if_depth && 0==else_where)
+					else_where = i+1;
+				}
+			}
+		// non-directive; lex, and check for macros and _Pragma operators
+		// remember to convert whitespace to single-space tokens, and flush those later
+		else if (0==include_where && 0==restart_full_scan)
+			{
+			assert(0==i);
+			size_t outbound_origin = outbound_tokens.size();
+			outbound_tokens.resize(outbound_origin+1);
+			outbound_tokens.back() = inbound_lines.front();
+			inbound_lines.front() = NULL;
+			inbound_lines.DeleteIdx(0);
+			if (!tokenize_line(outbound_tokens,outbound_origin))
+				goto Restart;
+			while(outbound_tokens.size()>outbound_origin)
+				{
+				if (C_TESTFLAG_PP_OP_PUNC & outbound_tokens[outbound_origin]->flags)
+					{	// check for categorically illegal tokens
+					const signed int old_pp_code = C_PP_DECODE(outbound_tokens[outbound_origin]->flags);
+					const signed int pp_code = (old_pp_code) ? old_pp_code : lang.pp_support->EncodePPOpPunc(outbound_tokens[outbound_origin]->data(),outbound_tokens[outbound_origin]->size());
+					assert(0<pp_code);
+					if (C_DISALLOW_POSTPROCESSED_SOURCE & lang.pp_support->GetPPOpPuncFlags(pp_code))
+						{	//! \todo need test cases
+							// actually, this might need to be language-sensitive (e.g., Perl)
+						message_header(*outbound_tokens[outbound_origin]);
+						INC_INFORM(ERR_STR);
+						INC_INFORM("Forbidden token '");
+						INC_INFORM(outbound_tokens[outbound_origin]->data(),outbound_tokens[outbound_origin]->size());
+						INFORM("' in postprocessed source.  Discarding.");
+						zcc_errors.inc_error();
+						outbound_tokens.DeleteIdx(outbound_origin);
+						continue;
+						}
+					C_PP_ENCODE(outbound_tokens[outbound_origin]->flags,pp_code);
+					}
+				else if (C_TESTFLAG_IDENTIFIER==outbound_tokens[outbound_origin]->flags)
+					{
+					if (!strcmp(outbound_tokens[outbound_origin]->data(),"_Pragma"))
+						{	// could be pragma operator; syntax _Pragma ( C-string )
+						while(1>=outbound_tokens.size()-outbound_origin && !line_is_preprocessing_directive(*inbound_lines[0]))
+							{
+							size_t tmp = outbound_tokens.size();
+							outbound_tokens.resize(tmp+1);
+							outbound_tokens.back() = inbound_lines.front();
+							inbound_lines.front() = NULL;
+							inbound_lines.DeleteIdx(0);
+							tokenize_line(outbound_tokens,tmp);
+							};
+						if (     1>=outbound_tokens.size()-outbound_origin
+							||   1!=outbound_tokens[outbound_origin+1]->size()
+							|| '('!=outbound_tokens[outbound_origin+1]->front())
+							{	//! \test cpp/Pragma.C99/Error_op1.hpp, cpp/Pragma.C99/Error_op1.h
+								//! \test cpp/Pragma.C99/Error_op2.hpp, cpp/Pragma.C99/Error_op2.h
+							message_header2(*outbound_tokens[outbound_origin],outbound_tokens[outbound_origin]->logical_line.second);
+							INC_INFORM(ERR_STR);
+							INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
+							zcc_errors.inc_error();
+							outbound_tokens.DeleteIdx(outbound_origin);
+							continue;
+							};
+						while(2>=outbound_tokens.size()-outbound_origin && !line_is_preprocessing_directive(*inbound_lines[0]))
+							{
+							size_t tmp = outbound_tokens.size();
+							outbound_tokens.resize(tmp+1);
+							outbound_tokens.back() = inbound_lines.front();
+							inbound_lines.front() = NULL;
+							inbound_lines.DeleteIdx(0);
+							tokenize_line(outbound_tokens,tmp);
+							};
+						if (   2>=outbound_tokens.size()-outbound_origin
+							|| C_TESTFLAG_STRING_LITERAL!=outbound_tokens[outbound_origin+2]->flags)
+							{	//! \test cpp/Pragma.C99/Error_op3.hpp, cpp/Pragma.C99/Error_op3.h
+								//! \test cpp/Pragma.C99/Error_op4.hpp, cpp/Pragma.C99/Error_op4.h
+							message_header2(*outbound_tokens[outbound_origin],outbound_tokens[outbound_origin]->logical_line.second);
+							INC_INFORM(ERR_STR);
+							INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
+							zcc_errors.inc_error();
+							outbound_tokens.DeleteNSlotsAt(2,outbound_origin);
+							continue;
+							};
+						while(3>=outbound_tokens.size()-outbound_origin && !line_is_preprocessing_directive(*inbound_lines[0]))
+							{
+							size_t tmp = outbound_tokens.size();
+							outbound_tokens.resize(tmp+1);
+							outbound_tokens.back() = inbound_lines.front();
+							inbound_lines.front() = NULL;
+							inbound_lines.DeleteIdx(0);
+							tokenize_line(outbound_tokens,tmp);
+							};
+						if (     3>=outbound_tokens.size()-outbound_origin
+							||   1!=outbound_tokens[outbound_origin+3]->size()
+							|| ')'!=outbound_tokens[outbound_origin+3]->front())
+							{	//! \test cpp/Pragma.C99/Error_op5.hpp, cpp/Pragma.C99/Error_op5.h
+								//! \test cpp/Pragma.C99/Error_op6.hpp, cpp/Pragma.C99/Error_op6.h
+							message_header2(*TokenList[i],TokenList[i]->logical_line.second);
+							INC_INFORM(ERR_STR);
+							INFORM("Invalid _Pragma operator.  Discarding. (C99 6.10.9p1/C++0x 16.9)");
+							zcc_errors.inc_error();
+							outbound_tokens.DeleteNSlotsAt(3,outbound_origin);
+							continue;
+							};
+						if ('L'==outbound_tokens[outbound_origin+2]->front())
+							outbound_tokens[outbound_origin+2]->ltrim(1);
+						if (2<outbound_tokens[outbound_origin+2]->size())
+							{	//! \test Pass_pragma_STDC.hpp
+							autovalarray_ptr_throws<char> pragma_string(lang.UnescapeStringLength(outbound_tokens[outbound_origin+2]->data()+1,outbound_tokens[outbound_origin+2]->size()-2));
+							lang.UnescapeString(pragma_string.c_array(),outbound_tokens[outbound_origin+2]->data()+1,outbound_tokens[outbound_origin+2]->size()-2);
+//#/*cut-cpp*/
+							const unsigned int pragma_code =
+//#/*cut-cpp*/
+							interpret_pragma(pragma_string.data(),pragma_string.size(),locked_macros);
+//#/*cut-cpp*/
+							switch(pragma_code)
+							{
+							case RELAY_ZCC_ENABLE_TYPEID+1:
+								outbound_tokens[outbound_origin]->replace_once(0,TokenList[outbound_origin]->size(),pragma_relay_keywords[pragma_code-1].first,pragma_relay_keywords[pragma_code-1].second);
+								outbound_tokens.DeleteNSlotsAt(3,outbound_origin+1);
+								continue;
+							}
+//#/*cut-cpp*/
+							};
+						outbound_tokens.DeleteNSlotsAt(4,outbound_origin);
+						continue;
+						};
+					const errr object_macro_index = binary_find(outbound_tokens[outbound_origin]->data(),outbound_tokens[outbound_origin]->size(),macros_object);
+					const errr function_macro_index = binary_find(outbound_tokens[outbound_origin]->data(),outbound_tokens[outbound_origin]->size(),macros_function);
+					assert(0>object_macro_index || 0>function_macro_index);
+					if (0<=object_macro_index)
+						{	// object-like macro
+						if (!macros_object_expansion_pre_eval[object_macro_index])
+							{	// expands to nothing
+								//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
+							outbound_tokens.DeleteIdx(outbound_origin);
+							continue;
+							}
+						assert(!macros_object_expansion_pre_eval[object_macro_index]->empty());
+						{	//! \test cpp/default/Preprocess_*.h/hpp
+						size_t discard = 0;
+						dynamic_macro_replace_once(*outbound_tokens[outbound_origin],discard,outbound_tokens[outbound_origin]->size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
+						}
+						size_t actual_tokens = tokenize_line(outbound_tokens,outbound_origin);
+						assert(0<actual_tokens);
+						outbound_origin += actual_tokens;
+						}
+					else if (0<=function_macro_index)
+						{	// could be function-like macro
+						if (   1<outbound_tokens.size()-outbound_origin
+							&& outbound_tokens[outbound_origin]->logical_line.first==outbound_tokens[outbound_origin+1]->logical_line.first
+							&& outbound_tokens[outbound_origin]->logical_line.second+outbound_tokens[outbound_origin]->size()==outbound_tokens[outbound_origin+1]->logical_line.second
+							&& '('==outbound_tokens[outbound_origin+1]->front())
+							{
+							size_t paren_depth = 1;
+							size_t comma_count = 0;
+							size_t j = outbound_origin+1;
+							do	{
+								if (1>=outbound_tokens.size()-j)
+									{	
+									if (inbound_lines.empty())
+										{	//! \test cpp/Error_macro_arglist4.hpp
+											// error out, incomplete function-like macro
+										message_header2(*outbound_tokens[outbound_origin],outbound_tokens[outbound_origin]->logical_line.second);
+										INC_INFORM(ERR_STR);
+										INC_INFORM("macro ");
+										INC_INFORM(outbound_tokens[outbound_origin]->data(),outbound_tokens[outbound_origin]->size());
+										INFORM(" did not close its argument list in time. (C99 6.10p1/C++98 16.1p1)");
+										zcc_errors.inc_error();
+										goto Restart;
+										}
+									if (line_is_preprocessing_directive(*inbound_lines[0]))
+										{	//! \test cpp/Error_macro_arglist7.hpp
+											// error out, undefined behavior
+										message_header2(*outbound_tokens[outbound_origin],outbound_tokens[outbound_origin]->logical_line.second);
+										INC_INFORM(ERR_STR);
+										INFORM("macro invocation contains preprocessing directive.  Defining undefined behavior as ignoring macro invocation. (C99 6.10.3p11/C++98 16.3p10)");
+										zcc_errors.inc_error();
+										goto Restart;
+										}
+									size_t tmp = outbound_tokens.size();
+									outbound_tokens.resize(tmp+1);
+									outbound_tokens.back() = inbound_lines.front();
+									inbound_lines.front() = NULL;
+									inbound_lines.DeleteIdx(0);
+									if (!tokenize_line(outbound_tokens,tmp))
+										continue;
+									}
+								if (1==outbound_tokens[++j]->size())
+									switch(outbound_tokens[j]->front())
+									{
+									case '(':
+										++paren_depth;
+										break;
+									case ',':
+										++comma_count;
+										break;
+									case ')':
+										--paren_depth;
+										//	break;
+									};
+								}
+							while(0<paren_depth);
+							assert(0==paren_depth);	// remove when above verified to be converted correctly							
+							assert(macros_function_arglist[function_macro_index]);
+							assert('('==macros_function_arglist[function_macro_index]->front());
+							assert(')'==macros_function_arglist[function_macro_index]->back());
+							const size_t formal_arg_span = macros_function_arglist[function_macro_index]->size();
+							const size_t formal_arg_count = (2<formal_arg_span) ? std::count(macros_function_arglist[function_macro_index]->begin(),macros_function_arglist[function_macro_index]->end(),',')+1 : 0;
+							const bool formal_varadic = 5<=formal_arg_span && !strncmp(macros_function_arglist[function_macro_index]->data()+(formal_arg_span-4),"...",sizeof("...")-1);
+							const size_t arg_count = (i+2==j) ? 0 : comma_count+1;
+							if (arg_count<formal_arg_count || (arg_count>formal_arg_count && !formal_varadic))
+								{	//! \test cpp/Error_macro_arglist5.hpp
+									//! \test cpp/Error_macro_arglist6.hpp
+								message_header2(*outbound_tokens[outbound_origin],outbound_tokens[outbound_origin]->logical_line.second);
+								INC_INFORM(ERR_STR);
+								INC_INFORM("macro ");
+								INC_INFORM(outbound_tokens[outbound_origin]->data(),outbound_tokens[outbound_origin]->size());
+								INC_INFORM(" had ");
+								INC_INFORM(arg_count);
+								INC_INFORM(" argument");
+								INC_INFORM((1==arg_count) ? "" : "s");
+								INC_INFORM(", needed ");
+								if (formal_varadic) INC_INFORM("at least ");
+								INC_INFORM(formal_arg_count);
+								INFORM(". (C99 6.10p1/C++0x 16.1p1)");
+								zcc_errors.inc_error();
+								outbound_origin = j;
+								continue;
+								}
+							if (!macros_function_expansion_pre_eval[function_macro_index])
+								{	// expands to nothing
+									//! \test cpp/default/Preprocess_empty_macros.hpp, cpp/default/Preprocess_empty_macros.h
+								outbound_tokens.DeleteNSlotsAt(j-outbound_origin+1,outbound_origin);
+								goto Restart;
+								}
+							assert(!macros_function_expansion_pre_eval[function_macro_index]->empty());
+							{	//! \test default/Preprocess_*.h/hpp 
+							Token<char>* Tmp = new Token<char>(*macros_function_expansion_pre_eval[function_macro_index]);
+							Tmp->logical_line = outbound_tokens[outbound_origin]->logical_line;
+							if (!nonrecursive_macro_replacement_list(Tmp->data()))
+								{	// XXX trashes line information to reuse intrapreprocessing stuff
+								size_t discard = outbound_origin;
+								Token<char>* Tmp2 = new Token<char>(*outbound_tokens[outbound_origin]);
+								while(++discard <= j) Tmp2->append(outbound_tokens[discard]->data());
+								discard = 0;
+								dynamic_macro_replace_once(*Tmp2,discard,outbound_tokens[outbound_origin]->size(),macros_object,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion_pre_eval,NULL);
+								delete Tmp;
+								Tmp = Tmp2;
+								}
+							outbound_tokens.DeleteNSlotsAt(j-outbound_origin,outbound_origin+1);
+							delete outbound_tokens[outbound_origin];
+							outbound_tokens[outbound_origin] = Tmp;
+							}
+							size_t actual_tokens = tokenize_line(outbound_tokens,outbound_origin);
+							assert(0<actual_tokens);
+							outbound_origin += actual_tokens;
+							};
+							}
+						}
+					else{	// replace predefined macros, if they are here
+							//! \test cpp/default/Preprocess_STDC_defines.hpp, cpp/default/Preprocess_STDC_defines.h
+						predefined_macro_replacement(*outbound_tokens[outbound_origin],0);
+						}
+					}
+				}
+			--i;
+			}
+	while(++i<inbound_lines.size());
+
+	if (0<if_depth)
+		{	//! \test Error_naked_if.hpp
+		message_header(*inbound_lines[if_where]);
+		INC_INFORM(ERR_STR);
+		INC_INFORM(if_depth);
+		INC_INFORM(" #if/#ifdef/#ifndef");
+		if (1<if_depth) INC_INFORM("'s");
+		INFORM(" without matching #endif directives (first one here).  (C99 6.10p1/C++98 16.1p1)");
+		zcc_errors.inc_error();
+		}
+	assert(0==include_where || 0==restart_full_scan || include_where<restart_full_scan);
+
+	if (0<include_where)
+		{	// Need to find the file....
+		assert(1==include_where);
+		--include_where;
+		assert(PP::INCLUDE == UNPACK_DIRECTIVE(inbound_lines[0]->flags));
+		if (inbound_lines[0]->size()<=(sizeof("#include <>")-1))
+			{	//! \test Error_include_tiny1.hpp
+				//! \test Error_include_tiny2.hpp
+			message_header(*inbound_lines[0]);
+			INC_INFORM(ERR_STR);
+			INFORM("#include is too small to contain a valid filename; discarding and continuing (C99 6.10.2p2,3/C++98 16.2p2,3)");
+			inbound_lines.DeleteIdx(0);
+			zcc_errors.inc_error();
+			goto Restart;
+			}
+		// already preprocessed, fortunately
+		bool local_include = false;
+		size_t filename_len = inbound_lines[0]->size()-(sizeof("#include <>")-1);
+		switch(inbound_lines[0]->data()[sizeof("#include ")-1])
+		{
+		case '"':	{	// local-include
+					if ('"'!=inbound_lines[0]->back())
+						{	//! \test Error_include_unterminated2.hpp
+						message_header(*inbound_lines[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("#include \"... does not terminate properly; discarding and continuing (C99 6.10.2p3/C++98 16.2p3)");
+						inbound_lines.DeleteIdx(include_where);
+						zcc_errors.inc_error();
+						goto Restart;
+						};
+					local_include = true;
+					break;
+					}
+		case '<':	{	// system-include
+					if ('>'!=inbound_lines[0]->back())
+						{	//! \test Error_include_unterminated1.hpp
+						message_header(*inbound_lines[0]);
+						INC_INFORM(ERR_STR);
+						INFORM("#include <... does not terminate properly; discarding and continuing (C99 6.10.2p2/C++98 16.2p2)");
+						inbound_lines.DeleteIdx(0);
+						zcc_errors.inc_error();
+						goto Restart;
+						};
+					break;
+					}
+		default:	{	// neither
+					message_header(*inbound_lines[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("#include has bad format; discarding and continuing (C99 6.10.2p2,3/C++98 16.2p2,3)");
+					inbound_lines.DeleteIdx(0);
+					zcc_errors.inc_error();
+					goto Restart;
+					}
+		};
+		// iterate through search path until something found matching
+		// need to map following
+		// * filename given from #include
+		// * full path that actually finds the file, or positive failure to find (AtomicString)
+		// * cached content (probably separate indexing on full-path), if not include-guarded
+		// * whether include-guarded #define; if so, what the include-guard macro is...
+		// * whether the subject of a pragma-once
+		// We need a de-facto stack for the "most recent include dirctory" to deal with local includes
+#define CPP_INCLUDE_NOT_FOUND 1U
+
+		autovalarray_ptr<Token<char>* > IncludeTokenList;
+		const char* const look_for = register_substring(inbound_lines[0]->data()+sizeof("#include <")-1,filename_len);
+		assert(filename_len==strlen(look_for));
+		if (local_include)
+			{	// #include "..." prohibits interior "
+			if (strchr(look_for,'"'))
+				{	//! \test Error_include_multiterminated2.hpp
+				message_header(*inbound_lines[0]);
+				INC_INFORM(ERR_STR);
+				INFORM("#include \"...\" contains \"; discarding and continuing (C99 6.10.2p3/C++98 16.2p3)");
+				inbound_lines.DeleteIdx(0);
+				zcc_errors.inc_error();
+				goto Restart;
+				}
+			}
+		else if (strchr(look_for,'>')) // #include <...> prohibits interior >
+			{	//! \test Error_include_multiterminated1.hpp
+			message_header(*inbound_lines[0]);
+			INC_INFORM(ERR_STR);
+			INFORM("#include <...> contains >; discarding and continuing (C99 6.10.2p2/C++98 16.2p2)");
+			inbound_lines.DeleteIdx(0);
+			zcc_errors.inc_error();
+			goto Restart;
+			};
+
+		errr have_file_index = binary_find(look_for, filename_len, include_file_index);
+		// system includes use their handle for information.
+		//! \todo rewrite this to support the #include_next extension?
+		if (0<=have_file_index)
+			{	// already have this one....
+			if (CPP_INCLUDE_NOT_FOUND==include_file_index[have_file_index].third)
+				{	// don't error again....
+				inbound_lines.DeleteIdx(0);
+				goto Restart;
+				}
+			assert(NULL!=include_file_index[have_file_index].second);
+			const errr cache_index = binary_find(include_file_index[have_file_index].second, strlen(include_file_index[have_file_index].second),include_file_cache);
+			assert(0<=cache_index);
+			IncludeTokenList = *include_file_cache[cache_index].second;
+		 	}
+		else{
+			char buf[FILENAME_MAX];
+			const char* main_index_name = NULL;
+			// note: local_include needs to know where to start...
+			bool found_file = local_include && find_local_include(look_for, buf, (inbound_lines[0]->parent_dir ? inbound_lines[0]->parent_dir : "."));
+			bool hardcoded_header = false;
+			if (found_file)
+				{	// filepath known; local includes use the calculated path for information
+				main_index_name = register_string(buf);
+				have_file_index = binary_find(main_index_name, strlen(main_index_name), include_file_index);
+				if (0<=have_file_index)
+					{
+					assert(CPP_INCLUDE_NOT_FOUND!=include_file_index[have_file_index].third);
+					const errr cache_index = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
+					assert(0<=cache_index);
+					IncludeTokenList = *include_file_cache[cache_index].second;
+					}
+				else{	// filepath known; inhale and set up cache
+					if (!load_sourcefile(IncludeTokenList,buf,lang)) throw std::bad_alloc();
+					// backfit SourceFile... to look_for; parent_dir to parent directory of file in buf
+					if (!IncludeTokenList.empty())
+						{
+						char parent_path[FILENAME_MAX];
+						z_dirname(parent_path,buf);
+						const char* const parent_dir = register_string(parent_path);
+						size_t j = IncludeTokenList.size();
+						do	{
+							IncludeTokenList[--j]->src_filename = look_for;
+							IncludeTokenList[j]->parent_dir = parent_dir;
+							}
+						while(0<j);
+						};
+					// set up include_file_index, include_file_cache
+					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(have_file_index);
+					const errr cache_index = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
+					const size_t include_file_cache_target = BINARY_SEARCH_DECODE_INSERTION_POINT(cache_index);
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_cache.insertNSlotsAt(1,include_file_cache_target);
+					include_file_cache[include_file_cache_target].second = new autovalarray_ptr<Token<char>* >(IncludeTokenList);
+					include_file_cache[include_file_cache_target].first = main_index_name;
+					include_file_index[include_file_index_target].first = main_index_name;
+					include_file_index[include_file_index_target].second = main_index_name;
+					include_file_index[include_file_index_target].third = 0;
+					}
+				}
+			else{	// we're having to process it as a system include.
+				errr tmp = 0;
+				// C99 7.1.2p4 and C++98 17.3.3.1.1p2 both prohibit having any keywords defined as macros when including a library header.
+				// C++0x 17.4.3.2.2 goes further and simply prohibits defining any keywords as macros.  Oops.
+				// C0x appears to be conserving C99 exactly.
+				// We undefine the offending macros as well as erroring, mainly to prevent duplicate error messages
+				// C99 doesn't care about such defines *after* the header; C++98 does.
+				//! \test cpp/default/keywords/Error_*.h
+				if (Lang::C==lang_code && 0<lang.pp_support->LengthOfSystemHeader(look_for))
+					C99_reject_keyword_macros(inbound_lines,0,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+
+				const unsigned int hardcoded_header_idx = detect_hardcoded_system_header(look_for,lang_code);
+				switch(hardcoded_header_idx)
+				{
+#ifndef NDEBUG
+				default: FATAL("hardcoded_header_idx out of range");
+#endif
+				case 3:	{	// stdint.h/cstdint
+					hardcoded_header = true;
+					C99_reject_keyword_macros(inbound_lines,0,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+					if (0>binary_find("__STDINT_H__",sizeof("__STDINT_H__")-1,macros_object))	
+						create_stdint_header(IncludeTokenList,look_for);	// not included yet
+					break;
+					}
+				case 2:	{	// stddef.h/cstddef
+					hardcoded_header = true;
+					C99_reject_keyword_macros(inbound_lines,0,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+					if (0>binary_find("__STDDEF_H__",sizeof("__STDDEF_H__")-1,macros_object))	
+						create_stddef_header(IncludeTokenList,look_for);	// not included yet
+					break;
+					}
+				case 1:	{	// limits.h/climits
+					hardcoded_header = true;
+					C99_reject_keyword_macros(inbound_lines,0,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
+					if (0>binary_find("__LIMITS_H__",sizeof("__LIMITS_H__")-1,macros_object))	
+						create_limits_header(IncludeTokenList,look_for);	// not included yet
+					break;
+					}
+				case 0:;
+				}
+
+				found_file = !hardcoded_header && find_system_include(look_for, buf);
+				if (found_file)
+					{	// filepath known; inhale and set up cache
+					if (!load_sourcefile(IncludeTokenList,buf,lang)) throw std::bad_alloc();
+					// backfit SourceFile... to look_for; parent_dir to parent directory of file in buf
+					if (!IncludeTokenList.empty())
+						{
+						char parent_path[FILENAME_MAX];
+						z_dirname(parent_path,buf);
+						const char* const parent_dir = (!strcmp(parent_path,origin_dir)) ? origin_dir : register_string(parent_path);
+						size_t j = IncludeTokenList.size();
+						do	{
+							IncludeTokenList[--j]->src_filename = look_for;
+							IncludeTokenList[j]->parent_dir = parent_dir;
+							}
+						while(0<j);
+						};
+					main_index_name = register_string(buf);
+					// set up include_file_index, include_file_cache
+					tmp = binary_find(look_for,filename_len,include_file_index);
+					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
+					tmp = binary_find(main_index_name,strlen(main_index_name),include_file_cache);
+					const size_t include_file_cache_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_cache.insertNSlotsAt(1,include_file_cache_target);
+					include_file_cache[include_file_cache_target].second = new autovalarray_ptr<Token<char>* >(IncludeTokenList);
+					include_file_cache[include_file_cache_target].first = main_index_name;
+					include_file_index[include_file_index_target].first = look_for;
+					include_file_index[include_file_index_target].second = main_index_name;
+					include_file_index[include_file_index_target].third = 0;
+					}
+				else if (!hardcoded_header)
+					{	// not there at all...
+					// set up include_file_index
+					tmp = binary_find(look_for,filename_len,include_file_index);
+					const size_t include_file_index_target = BINARY_SEARCH_DECODE_INSERTION_POINT(tmp);
+					include_file_index.insertNSlotsAt(1,include_file_index_target);
+					include_file_index[include_file_index_target].first = look_for;
+					include_file_index[include_file_index_target].second = NULL;
+					include_file_index[include_file_index_target].third = CPP_INCLUDE_NOT_FOUND;
+
+					message_header(*inbound_lines[0]);
+					INC_INFORM(ERR_STR);
+					INFORM("#include'd file not found; discarding and continuing");
+					inbound_lines.DeleteIdx(0);
+					zcc_errors.inc_error();
+					goto Restart;
+					}
+				}
+			}
+#undef CPP_INCLUDE_NOT_FOUND
+		//! also tested in a number of data transform tests
+		//! \test Pass_include_local.hpp
+		if (!IncludeTokenList.empty())
+			{	// not sure whether C99 5.1.1.2 4 requires preprocessing the whole header before pasting, but it permits it
+				// this implies:
+				// * conditional-compilation directives must be balanced for each file
+				// * #line directives never escape files anyway
+			{
+			zaimoni::autovalarray_ptr<zaimoni::Token<char>* > inbound_lines_backup;
+			zaimoni::autovalarray_ptr<zaimoni::Token<char>* > outbound_tokens_backup;
+			inbound_lines.MoveInto(inbound_lines_backup);
+			outbound_tokens.MoveInto(outbound_tokens_backup);
+			++include_level;
+			_preprocess_alt(IncludeTokenList, locked_macros, macros_object, macros_object_expansion, macros_object_expansion_pre_eval, macros_function, macros_function_arglist, macros_function_expansion, macros_function_expansion_pre_eval, include_file_index, include_file_cache, min_types);
+			--include_level;
+			inbound_lines_backup.MoveInto(inbound_lines);
+			outbound_tokens_backup.MoveInto(outbound_tokens);
+			}
+			if (!IncludeTokenList.empty())
+				{
+				size_t j = IncludeTokenList.size();
+				inbound_lines.insertNSlotsAt(j,1);
+				memmove(inbound_lines.c_array()+1,IncludeTokenList.data(),j*sizeof(Token<char*>*));
+#ifdef ZAIMONI_NULL_REALLY_IS_ZERO
+				memset(IncludeTokenList.c_array(),0,j*sizeof(Token<char*>*));
+#else
+				std::fill(IncludeTokenList.begin(),IncludeTokenList.end(),NULL)
+#endif
+				}
+			}
+
+		// XXX fallthrough hack XXX
+		inbound_lines.DeleteIdx(0);
+		goto Restart;
+		}
+	outbound_tokens.MoveInto(TokenList);
+}
+#endif
+#/*cut-nocpp*/
+#/*cut-cpp*/
+



From zaimoni at mail.berlios.de  Sat Oct 30 20:00:23 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 30 Oct 2010 20:00:23 +0200
Subject: [Zcplusplus-commits] r519 - trunk
Message-ID: <20101030180023.57E3E481039@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-30 20:00:22 +0200 (Sat, 30 Oct 2010)
New Revision: 519

Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc.cpp.in
   trunk/CPreproc_pp.cpp
Log:
stage 3: line count reduction

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2010-10-30 09:25:23 UTC (rev 518)
+++ trunk/CPreproc.cpp	2010-10-30 18:00:22 UTC (rev 519)
@@ -268,26 +268,24 @@
 {
 	switch(lang_code)
 	{
-	case Lang::C: {
-			macro_identifier_default = C99_macro_identifier_default;
-			macro_identifier_default_count = STATIC_SIZE(C99_macro_identifier_default);
-			break;
-		};
-	case Lang::CPlusPlus: {
-			macro_identifier_default = CPP0x_macro_identifier_default;
-			macro_identifier_default_count = STATIC_SIZE(CPP0x_macro_identifier_default);
-			break;
-		};
 	default: FATAL("Invalid language code");
+	case Lang::C:
+		macro_identifier_default = C99_macro_identifier_default;
+		macro_identifier_default_count = STATIC_SIZE(C99_macro_identifier_default);
+		break;
+	case Lang::CPlusPlus:
+		macro_identifier_default = CPP0x_macro_identifier_default;
+		macro_identifier_default_count = STATIC_SIZE(CPP0x_macro_identifier_default);
+//		break;
 	}
 	init_fixed_system_include_search();
 	// reality checks on the language
-	assert(NULL!=lang.EscapeStringLength);
-	assert(NULL!=lang.EscapeString);
-	assert(NULL!=lang.UnescapeStringLength);
-	assert(NULL!=lang.UnescapeString);
-	assert(NULL!=lang.pp_support);
-	assert(NULL!=lang.InvariantKeywords);
+	assert(lang.EscapeStringLength);
+	assert(lang.EscapeString);
+	assert(lang.UnescapeStringLength);
+	assert(lang.UnescapeString);
+	assert(lang.pp_support);
+	assert(lang.InvariantKeywords);
 	assert(0<lang.len_InvariantKeywords);
 }
 
@@ -1819,10 +1817,9 @@
 							};
 						}
 					}
-				else{	// replace predefined macros, if they are here
-						//! \test cpp/default/Preprocess_STDC_defines.hpp, cpp/default/Preprocess_STDC_defines.h
+				else	// replace predefined macros, if they are here
+					//! \test cpp/default/Preprocess_STDC_defines.hpp, cpp/default/Preprocess_STDC_defines.h
 					predefined_macro_replacement(*TokenList[i],0);
-					}
 				}
 			}
 		}
@@ -1861,45 +1858,42 @@
 		size_t filename_len = TokenList[include_where]->size()-(sizeof("#include <>")-1);
 		switch(TokenList[include_where]->data()[sizeof("#include ")-1])
 		{
-		case '"':	{	// local-include
-					if ('"'!=TokenList[include_where]->back())
-						{	//! \test Error_include_unterminated2.hpp
-						message_header(*TokenList[include_where]);
-						INC_INFORM(ERR_STR);
-						INFORM("#include \"... does not terminate properly; discarding and continuing (C99 6.10.2p3/C++98 16.2p3)");
-						TokenList.DeleteIdx(include_where);
-						zcc_errors.inc_error();
-						i = include_where;
-						if (i<TokenList.size()) goto RestartAfterInclude;
-						return;
-						};
-					local_include = true;
-					break;
-					}
-		case '<':	{	// system-include
-					if ('>'!=TokenList[include_where]->back())
-						{	//! \test Error_include_unterminated1.hpp
-						message_header(*TokenList[include_where]);
-						INC_INFORM(ERR_STR);
-						INFORM("#include <... does not terminate properly; discarding and continuing (C99 6.10.2p2/C++98 16.2p2)");
-						TokenList.DeleteIdx(include_where);
-						zcc_errors.inc_error();
-						i = include_where;
-						if (i<TokenList.size()) goto RestartAfterInclude;
-						return;
-						};
-					break;
-					}
-		default:	{	// neither
-					message_header(*TokenList[include_where]);
-					INC_INFORM(ERR_STR);
-					INFORM("#include has bad format; discarding and continuing (C99 6.10.2p2,3/C++98 16.2p2,3)");
-					TokenList.DeleteIdx(include_where);
-					zcc_errors.inc_error();
-					i = include_where;
-					if (i<TokenList.size()) goto RestartAfterInclude;
-					return;
-					}
+		case '"':	// local-include
+			if ('"'!=TokenList[include_where]->back())
+				{	//! \test Error_include_unterminated2.hpp
+				message_header(*TokenList[include_where]);
+				INC_INFORM(ERR_STR);
+				INFORM("#include \"... does not terminate properly; discarding and continuing (C99 6.10.2p3/C++98 16.2p3)");
+				TokenList.DeleteIdx(include_where);
+				zcc_errors.inc_error();
+				i = include_where;
+				if (i<TokenList.size()) goto RestartAfterInclude;
+				return;
+				};
+			local_include = true;
+			break;
+		case '<':	// system-include
+			if ('>'!=TokenList[include_where]->back())
+				{	//! \test Error_include_unterminated1.hpp
+				message_header(*TokenList[include_where]);
+				INC_INFORM(ERR_STR);
+				INFORM("#include <... does not terminate properly; discarding and continuing (C99 6.10.2p2/C++98 16.2p2)");
+				TokenList.DeleteIdx(include_where);
+				zcc_errors.inc_error();
+				i = include_where;
+				if (i<TokenList.size()) goto RestartAfterInclude;
+				return;
+				};
+			break;
+		default:	// neither
+			message_header(*TokenList[include_where]);
+			INC_INFORM(ERR_STR);
+			INFORM("#include has bad format; discarding and continuing (C99 6.10.2p2,3/C++98 16.2p2,3)");
+			TokenList.DeleteIdx(include_where);
+			zcc_errors.inc_error();
+			i = include_where;
+			if (i<TokenList.size()) goto RestartAfterInclude;
+			return;
 		};
 		// iterate through search path until something found matching
 		// need to map following
@@ -2019,27 +2013,24 @@
 #ifndef NDEBUG
 				default: FATAL("hardcoded_header_idx out of range");
 #endif
-				case 3:	{	// stdint.h/cstdint
+				case 3:	// stdint.h/cstdint
 					hardcoded_header = true;
 					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
 					if (0>binary_find("__STDINT_H__",sizeof("__STDINT_H__")-1,macros_object))	
 						create_stdint_header(IncludeTokenList,look_for);	// not included yet
 					break;
-					}
-				case 2:	{	// stddef.h/cstddef
+				case 2:	// stddef.h/cstddef
 					hardcoded_header = true;
 					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
 					if (0>binary_find("__STDDEF_H__",sizeof("__STDDEF_H__")-1,macros_object))	
 						create_stddef_header(IncludeTokenList,look_for);	// not included yet
 					break;
-					}
-				case 1:	{	// limits.h/climits
+				case 1:	// limits.h/climits
 					hardcoded_header = true;
 					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
 					if (0>binary_find("__LIMITS_H__",sizeof("__LIMITS_H__")-1,macros_object))	
 						create_limits_header(IncludeTokenList,look_for);	// not included yet
 					break;
-					}
 				case 0:;
 				}
 
@@ -2187,7 +2178,7 @@
 					strncpy(tmp,x+pretokenized[j].first,pretokenized[j].second);
 					if (!locked_macros.InsertSlotAt(locked_macros.size(),tmp))
 						{
-						_flush(tmp);
+						free(tmp);
 						throw std::bad_alloc();
 						}
 					}
@@ -2207,13 +2198,11 @@
 				{
 #ifndef NDEBUG
 				default:
-					{
 					INC_INFORM(ERR_STR);
 					INC_INFORM("unhandled STDC pragma ");
 					INFORM(pragma_STDC_keywords[STDC_pragma].first);
 					zcc_errors.inc_error();
 					return 0;
-					};
 #endif
 				case PRAGMA_STDC_FP_CONTRACT:
 				case PRAGMA_STDC_FENV_ACCESS:
@@ -2248,8 +2237,7 @@
 			&&	1==pretokenized[1].second && '('==x[pretokenized[1].first]
 			&&	1==pretokenized[3].second && ')'==x[pretokenized[3].first]
 			&&	C_TESTFLAG_STRING_LITERAL==pretokenized[2].third)
-			{
-			// hmm...do we need to unescape anything...
+			{	// hmm...do we need to unescape anything...
 			const bool wide_str = 'L'==x[pretokenized[2].first];
 			if (0<std::count(x+pretokenized[2].first,x+pretokenized[2].first+pretokenized[2].second,'\\'))
 				{	// no escapes
@@ -2257,12 +2245,11 @@
 
 				//! \todo change target, this only handles target CHAR_BIT<=host CHAR_BIT
 				const size_t tmp_len = lang.UnescapeStringLength(x+pretokenized[2].first,pretokenized[2].second);
-				char* tmp = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(tmp_len));
-				if (NULL!=tmp)
+				if (char* tmp = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(tmp_len)))
 					{
 					lang.UnescapeString(tmp,x+pretokenized[2].first,pretokenized[2].second);
 					INFORM(tmp,tmp_len);
-					_flush(tmp);
+					free(tmp);
 					return 0;
 					}
 				};
@@ -2305,11 +2292,7 @@
 CPreprocessor::tokenize_line(autovalarray_ptr<Token<char>* >& TokenList, size_t i) const
 {
 	assert(TokenList.size()>i);
-	if (TokenList[i]->empty())
-		{
-		TokenList.DeleteIdx(i);
-		return 0;
-		};
+	if (TokenList[i]->empty()) return TokenList.DeleteIdx(i),0; 
 
 	// Not really (it's a preprocessing directive), but we don't want to damage it here
 	if ('#'==TokenList[i]->front()) return 1;
@@ -2319,11 +2302,7 @@
 
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
 	lang.line_lex(TokenList[i]->data(),TokenList[i]->size(),pretokenized);
-	if (pretokenized.empty())
-		{
-		TokenList.DeleteIdx(i);
-		return 0;
-		}
+	if (pretokenized.empty()) return TokenList.DeleteIdx(i),0;
 
 	size_t ub = pretokenized.size()-1;
 	if (0==ub)
@@ -2347,7 +2326,7 @@
 				TokenListAlt[lb] = new Token<char>(tmp,pretokenized[lb].first,pretokenized[lb].second,pretokenized[lb].third);
 				complete_string_character_literal(*TokenListAlt[lb++]);
 				}
-			else{	// second token longer
+			else{	// first token longer
 				TokenListAlt[ub] = new Token<char>(tmp,pretokenized[ub].first,pretokenized[ub].second,pretokenized[ub].third);
 				complete_string_character_literal(*TokenListAlt[ub--]);
 				}
@@ -2383,16 +2362,16 @@
 	char image_filepath[FILENAME_MAX];
 	char test_filepath[FILENAME_MAX];
 
-	assert(!is_empty_string(src));
-	assert(!is_empty_string(local_root));
-	assert(NULL!=filepath_buf);
+	assert(src && *src);
+	assert(local_root && *local_root);
+	assert(filepath_buf);
 	const size_t src_len = strlen(src);
 
 	// automatically fail anything that won't fit in FILENAME_MAX
 	//! \test Error_huge_path.hpp
 	if (FILENAME_MAX<=src_len) return false;
 
-	if (NULL!=origin_dir)
+	if (origin_dir)
 		{
 		size_t target_length = strlen(origin_dir);
 		assert(FILENAME_MAX>target_length);
@@ -2416,7 +2395,7 @@
 #endif
 		}
 	const char* const canonical_path = z_realpath(image_filepath,test_filepath);
-	if (NULL!=canonical_path && !access(canonical_path,F_OK))
+	if (canonical_path && !access(canonical_path,F_OK))
 		{
 		strcpy(filepath_buf,canonical_path);
 		return true;

Modified: trunk/CPreproc.cpp.in
===================================================================
--- trunk/CPreproc.cpp.in	2010-10-30 09:25:23 UTC (rev 518)
+++ trunk/CPreproc.cpp.in	2010-10-30 18:00:22 UTC (rev 519)
@@ -283,26 +283,24 @@
 {
 	switch(lang_code)
 	{
-	case Lang::C: {
-			macro_identifier_default = C99_macro_identifier_default;
-			macro_identifier_default_count = STATIC_SIZE(C99_macro_identifier_default);
-			break;
-		};
-	case Lang::CPlusPlus: {
-			macro_identifier_default = CPP0x_macro_identifier_default;
-			macro_identifier_default_count = STATIC_SIZE(CPP0x_macro_identifier_default);
-			break;
-		};
 	default: FATAL("Invalid language code");
+	case Lang::C:
+		macro_identifier_default = C99_macro_identifier_default;
+		macro_identifier_default_count = STATIC_SIZE(C99_macro_identifier_default);
+		break;
+	case Lang::CPlusPlus:
+		macro_identifier_default = CPP0x_macro_identifier_default;
+		macro_identifier_default_count = STATIC_SIZE(CPP0x_macro_identifier_default);
+//		break;
 	}
 	init_fixed_system_include_search();
 	// reality checks on the language
-	assert(NULL!=lang.EscapeStringLength);
-	assert(NULL!=lang.EscapeString);
-	assert(NULL!=lang.UnescapeStringLength);
-	assert(NULL!=lang.UnescapeString);
-	assert(NULL!=lang.pp_support);
-	assert(NULL!=lang.InvariantKeywords);
+	assert(lang.EscapeStringLength);
+	assert(lang.EscapeString);
+	assert(lang.UnescapeStringLength);
+	assert(lang.UnescapeString);
+	assert(lang.pp_support);
+	assert(lang.InvariantKeywords);
 	assert(0<lang.len_InvariantKeywords);
 }
 
@@ -1851,10 +1849,9 @@
 							};
 						}
 					}
-				else{	// replace predefined macros, if they are here
-						//! \test cpp/default/Preprocess_STDC_defines.hpp, cpp/default/Preprocess_STDC_defines.h
+				else	// replace predefined macros, if they are here
+					//! \test cpp/default/Preprocess_STDC_defines.hpp, cpp/default/Preprocess_STDC_defines.h
 					predefined_macro_replacement(*TokenList[i],0);
-					}
 				}
 			}
 		}
@@ -1893,45 +1890,42 @@
 		size_t filename_len = TokenList[include_where]->size()-(sizeof("#include <>")-1);
 		switch(TokenList[include_where]->data()[sizeof("#include ")-1])
 		{
-		case '"':	{	// local-include
-					if ('"'!=TokenList[include_where]->back())
-						{	//! \test Error_include_unterminated2.hpp
-						message_header(*TokenList[include_where]);
-						INC_INFORM(ERR_STR);
-						INFORM("#include \"... does not terminate properly; discarding and continuing (C99 6.10.2p3/C++98 16.2p3)");
-						TokenList.DeleteIdx(include_where);
-						zcc_errors.inc_error();
-						i = include_where;
-						if (i<TokenList.size()) goto RestartAfterInclude;
-						return;
-						};
-					local_include = true;
-					break;
-					}
-		case '<':	{	// system-include
-					if ('>'!=TokenList[include_where]->back())
-						{	//! \test Error_include_unterminated1.hpp
-						message_header(*TokenList[include_where]);
-						INC_INFORM(ERR_STR);
-						INFORM("#include <... does not terminate properly; discarding and continuing (C99 6.10.2p2/C++98 16.2p2)");
-						TokenList.DeleteIdx(include_where);
-						zcc_errors.inc_error();
-						i = include_where;
-						if (i<TokenList.size()) goto RestartAfterInclude;
-						return;
-						};
-					break;
-					}
-		default:	{	// neither
-					message_header(*TokenList[include_where]);
-					INC_INFORM(ERR_STR);
-					INFORM("#include has bad format; discarding and continuing (C99 6.10.2p2,3/C++98 16.2p2,3)");
-					TokenList.DeleteIdx(include_where);
-					zcc_errors.inc_error();
-					i = include_where;
-					if (i<TokenList.size()) goto RestartAfterInclude;
-					return;
-					}
+		case '"':	// local-include
+			if ('"'!=TokenList[include_where]->back())
+				{	//! \test Error_include_unterminated2.hpp
+				message_header(*TokenList[include_where]);
+				INC_INFORM(ERR_STR);
+				INFORM("#include \"... does not terminate properly; discarding and continuing (C99 6.10.2p3/C++98 16.2p3)");
+				TokenList.DeleteIdx(include_where);
+				zcc_errors.inc_error();
+				i = include_where;
+				if (i<TokenList.size()) goto RestartAfterInclude;
+				return;
+				};
+			local_include = true;
+			break;
+		case '<':	// system-include
+			if ('>'!=TokenList[include_where]->back())
+				{	//! \test Error_include_unterminated1.hpp
+				message_header(*TokenList[include_where]);
+				INC_INFORM(ERR_STR);
+				INFORM("#include <... does not terminate properly; discarding and continuing (C99 6.10.2p2/C++98 16.2p2)");
+				TokenList.DeleteIdx(include_where);
+				zcc_errors.inc_error();
+				i = include_where;
+				if (i<TokenList.size()) goto RestartAfterInclude;
+				return;
+				};
+			break;
+		default:	// neither
+			message_header(*TokenList[include_where]);
+			INC_INFORM(ERR_STR);
+			INFORM("#include has bad format; discarding and continuing (C99 6.10.2p2,3/C++98 16.2p2,3)");
+			TokenList.DeleteIdx(include_where);
+			zcc_errors.inc_error();
+			i = include_where;
+			if (i<TokenList.size()) goto RestartAfterInclude;
+			return;
 		};
 		// iterate through search path until something found matching
 		// need to map following
@@ -2051,27 +2045,24 @@
 #ifndef NDEBUG
 				default: FATAL("hardcoded_header_idx out of range");
 #endif
-				case 3:	{	// stdint.h/cstdint
+				case 3:	// stdint.h/cstdint
 					hardcoded_header = true;
 					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
 					if (0>binary_find("__STDINT_H__",sizeof("__STDINT_H__")-1,macros_object))	
 						create_stdint_header(IncludeTokenList,look_for);	// not included yet
 					break;
-					}
-				case 2:	{	// stddef.h/cstddef
+				case 2:	// stddef.h/cstddef
 					hardcoded_header = true;
 					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
 					if (0>binary_find("__STDDEF_H__",sizeof("__STDDEF_H__")-1,macros_object))	
 						create_stddef_header(IncludeTokenList,look_for);	// not included yet
 					break;
-					}
-				case 1:	{	// limits.h/climits
+				case 1:	// limits.h/climits
 					hardcoded_header = true;
 					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
 					if (0>binary_find("__LIMITS_H__",sizeof("__LIMITS_H__")-1,macros_object))	
 						create_limits_header(IncludeTokenList,look_for);	// not included yet
 					break;
-					}
 				case 0:;
 				}
 
@@ -2223,7 +2214,7 @@
 					strncpy(tmp,x+pretokenized[j].first,pretokenized[j].second);
 					if (!locked_macros.InsertSlotAt(locked_macros.size(),tmp))
 						{
-						_flush(tmp);
+						free(tmp);
 						throw std::bad_alloc();
 						}
 					}
@@ -2243,13 +2234,11 @@
 				{
 #ifndef NDEBUG
 				default:
-					{
 					INC_INFORM(ERR_STR);
 					INC_INFORM("unhandled STDC pragma ");
 					INFORM(pragma_STDC_keywords[STDC_pragma].first);
 					zcc_errors.inc_error();
 					return 0;
-					};
 #endif
 				case PRAGMA_STDC_FP_CONTRACT:
 				case PRAGMA_STDC_FENV_ACCESS:
@@ -2284,8 +2273,7 @@
 			&&	1==pretokenized[1].second && '('==x[pretokenized[1].first]
 			&&	1==pretokenized[3].second && ')'==x[pretokenized[3].first]
 			&&	C_TESTFLAG_STRING_LITERAL==pretokenized[2].third)
-			{
-			// hmm...do we need to unescape anything...
+			{	// hmm...do we need to unescape anything...
 			const bool wide_str = 'L'==x[pretokenized[2].first];
 			if (0<std::count(x+pretokenized[2].first,x+pretokenized[2].first+pretokenized[2].second,'\\'))
 				{	// no escapes
@@ -2293,12 +2281,11 @@
 
 				//! \todo change target, this only handles target CHAR_BIT<=host CHAR_BIT
 				const size_t tmp_len = lang.UnescapeStringLength(x+pretokenized[2].first,pretokenized[2].second);
-				char* tmp = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(tmp_len));
-				if (NULL!=tmp)
+				if (char* tmp = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(tmp_len)))
 					{
 					lang.UnescapeString(tmp,x+pretokenized[2].first,pretokenized[2].second);
 					INFORM(tmp,tmp_len);
-					_flush(tmp);
+					free(tmp);
 					return 0;
 					}
 				};
@@ -2341,11 +2328,7 @@
 CPreprocessor::tokenize_line(autovalarray_ptr<Token<char>* >& TokenList, size_t i) const
 {
 	assert(TokenList.size()>i);
-	if (TokenList[i]->empty())
-		{
-		TokenList.DeleteIdx(i);
-		return 0;
-		};
+	if (TokenList[i]->empty()) return TokenList.DeleteIdx(i),0; 
 
 	// Not really (it's a preprocessing directive), but we don't want to damage it here
 	if ('#'==TokenList[i]->front()) return 1;
@@ -2355,11 +2338,7 @@
 
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
 	lang.line_lex(TokenList[i]->data(),TokenList[i]->size(),pretokenized);
-	if (pretokenized.empty())
-		{
-		TokenList.DeleteIdx(i);
-		return 0;
-		}
+	if (pretokenized.empty()) return TokenList.DeleteIdx(i),0;
 
 	size_t ub = pretokenized.size()-1;
 	if (0==ub)
@@ -2383,7 +2362,7 @@
 				TokenListAlt[lb] = new Token<char>(tmp,pretokenized[lb].first,pretokenized[lb].second,pretokenized[lb].third);
 				complete_string_character_literal(*TokenListAlt[lb++]);
 				}
-			else{	// second token longer
+			else{	// first token longer
 				TokenListAlt[ub] = new Token<char>(tmp,pretokenized[ub].first,pretokenized[ub].second,pretokenized[ub].third);
 				complete_string_character_literal(*TokenListAlt[ub--]);
 				}
@@ -2419,16 +2398,16 @@
 	char image_filepath[FILENAME_MAX];
 	char test_filepath[FILENAME_MAX];
 
-	assert(!is_empty_string(src));
-	assert(!is_empty_string(local_root));
-	assert(NULL!=filepath_buf);
+	assert(src && *src);
+	assert(local_root && *local_root);
+	assert(filepath_buf);
 	const size_t src_len = strlen(src);
 
 	// automatically fail anything that won't fit in FILENAME_MAX
 	//! \test Error_huge_path.hpp
 	if (FILENAME_MAX<=src_len) return false;
 
-	if (NULL!=origin_dir)
+	if (origin_dir)
 		{
 		size_t target_length = strlen(origin_dir);
 		assert(FILENAME_MAX>target_length);
@@ -2452,7 +2431,7 @@
 #endif
 		}
 	const char* const canonical_path = z_realpath(image_filepath,test_filepath);
-	if (NULL!=canonical_path && !access(canonical_path,F_OK))
+	if (canonical_path && !access(canonical_path,F_OK))
 		{
 		strcpy(filepath_buf,canonical_path);
 		return true;

Modified: trunk/CPreproc_pp.cpp
===================================================================
--- trunk/CPreproc_pp.cpp	2010-10-30 09:25:23 UTC (rev 518)
+++ trunk/CPreproc_pp.cpp	2010-10-30 18:00:22 UTC (rev 519)
@@ -267,26 +267,24 @@
 {
 	switch(lang_code)
 	{
-	case Lang::C: {
-			macro_identifier_default = C99_macro_identifier_default;
-			macro_identifier_default_count = STATIC_SIZE(C99_macro_identifier_default);
-			break;
-		};
-	case Lang::CPlusPlus: {
-			macro_identifier_default = CPP0x_macro_identifier_default;
-			macro_identifier_default_count = STATIC_SIZE(CPP0x_macro_identifier_default);
-			break;
-		};
 	default: FATAL("Invalid language code");
+	case Lang::C:
+		macro_identifier_default = C99_macro_identifier_default;
+		macro_identifier_default_count = STATIC_SIZE(C99_macro_identifier_default);
+		break;
+	case Lang::CPlusPlus:
+		macro_identifier_default = CPP0x_macro_identifier_default;
+		macro_identifier_default_count = STATIC_SIZE(CPP0x_macro_identifier_default);
+//		break;
 	}
 	init_fixed_system_include_search();
 	// reality checks on the language
-	assert(NULL!=lang.EscapeStringLength);
-	assert(NULL!=lang.EscapeString);
-	assert(NULL!=lang.UnescapeStringLength);
-	assert(NULL!=lang.UnescapeString);
-	assert(NULL!=lang.pp_support);
-	assert(NULL!=lang.InvariantKeywords);
+	assert(lang.EscapeStringLength);
+	assert(lang.EscapeString);
+	assert(lang.UnescapeStringLength);
+	assert(lang.UnescapeString);
+	assert(lang.pp_support);
+	assert(lang.InvariantKeywords);
 	assert(0<lang.len_InvariantKeywords);
 }
 
@@ -1787,10 +1785,9 @@
 							};
 						}
 					}
-				else{	// replace predefined macros, if they are here
-						//! \test cpp/default/Preprocess_STDC_defines.hpp, cpp/default/Preprocess_STDC_defines.h
+				else	// replace predefined macros, if they are here
+					//! \test cpp/default/Preprocess_STDC_defines.hpp, cpp/default/Preprocess_STDC_defines.h
 					predefined_macro_replacement(*TokenList[i],0);
-					}
 				}
 			}
 		}
@@ -1829,45 +1826,42 @@
 		size_t filename_len = TokenList[include_where]->size()-(sizeof("#include <>")-1);
 		switch(TokenList[include_where]->data()[sizeof("#include ")-1])
 		{
-		case '"':	{	// local-include
-					if ('"'!=TokenList[include_where]->back())
-						{	//! \test Error_include_unterminated2.hpp
-						message_header(*TokenList[include_where]);
-						INC_INFORM(ERR_STR);
-						INFORM("#include \"... does not terminate properly; discarding and continuing (C99 6.10.2p3/C++98 16.2p3)");
-						TokenList.DeleteIdx(include_where);
-						zcc_errors.inc_error();
-						i = include_where;
-						if (i<TokenList.size()) goto RestartAfterInclude;
-						return;
-						};
-					local_include = true;
-					break;
-					}
-		case '<':	{	// system-include
-					if ('>'!=TokenList[include_where]->back())
-						{	//! \test Error_include_unterminated1.hpp
-						message_header(*TokenList[include_where]);
-						INC_INFORM(ERR_STR);
-						INFORM("#include <... does not terminate properly; discarding and continuing (C99 6.10.2p2/C++98 16.2p2)");
-						TokenList.DeleteIdx(include_where);
-						zcc_errors.inc_error();
-						i = include_where;
-						if (i<TokenList.size()) goto RestartAfterInclude;
-						return;
-						};
-					break;
-					}
-		default:	{	// neither
-					message_header(*TokenList[include_where]);
-					INC_INFORM(ERR_STR);
-					INFORM("#include has bad format; discarding and continuing (C99 6.10.2p2,3/C++98 16.2p2,3)");
-					TokenList.DeleteIdx(include_where);
-					zcc_errors.inc_error();
-					i = include_where;
-					if (i<TokenList.size()) goto RestartAfterInclude;
-					return;
-					}
+		case '"':	// local-include
+			if ('"'!=TokenList[include_where]->back())
+				{	//! \test Error_include_unterminated2.hpp
+				message_header(*TokenList[include_where]);
+				INC_INFORM(ERR_STR);
+				INFORM("#include \"... does not terminate properly; discarding and continuing (C99 6.10.2p3/C++98 16.2p3)");
+				TokenList.DeleteIdx(include_where);
+				zcc_errors.inc_error();
+				i = include_where;
+				if (i<TokenList.size()) goto RestartAfterInclude;
+				return;
+				};
+			local_include = true;
+			break;
+		case '<':	// system-include
+			if ('>'!=TokenList[include_where]->back())
+				{	//! \test Error_include_unterminated1.hpp
+				message_header(*TokenList[include_where]);
+				INC_INFORM(ERR_STR);
+				INFORM("#include <... does not terminate properly; discarding and continuing (C99 6.10.2p2/C++98 16.2p2)");
+				TokenList.DeleteIdx(include_where);
+				zcc_errors.inc_error();
+				i = include_where;
+				if (i<TokenList.size()) goto RestartAfterInclude;
+				return;
+				};
+			break;
+		default:	// neither
+			message_header(*TokenList[include_where]);
+			INC_INFORM(ERR_STR);
+			INFORM("#include has bad format; discarding and continuing (C99 6.10.2p2,3/C++98 16.2p2,3)");
+			TokenList.DeleteIdx(include_where);
+			zcc_errors.inc_error();
+			i = include_where;
+			if (i<TokenList.size()) goto RestartAfterInclude;
+			return;
 		};
 		// iterate through search path until something found matching
 		// need to map following
@@ -1987,27 +1981,24 @@
 #ifndef NDEBUG
 				default: FATAL("hardcoded_header_idx out of range");
 #endif
-				case 3:	{	// stdint.h/cstdint
+				case 3:	// stdint.h/cstdint
 					hardcoded_header = true;
 					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
 					if (0>binary_find("__STDINT_H__",sizeof("__STDINT_H__")-1,macros_object))	
 						create_stdint_header(IncludeTokenList,look_for);	// not included yet
 					break;
-					}
-				case 2:	{	// stddef.h/cstddef
+				case 2:	// stddef.h/cstddef
 					hardcoded_header = true;
 					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
 					if (0>binary_find("__STDDEF_H__",sizeof("__STDDEF_H__")-1,macros_object))	
 						create_stddef_header(IncludeTokenList,look_for);	// not included yet
 					break;
-					}
-				case 1:	{	// limits.h/climits
+				case 1:	// limits.h/climits
 					hardcoded_header = true;
 					C99_reject_keyword_macros(TokenList,include_where,look_for,lang,macros_object,macros_object_expansion,macros_object_expansion_pre_eval,macros_function,macros_function_arglist,macros_function_expansion,macros_function_expansion_pre_eval);
 					if (0>binary_find("__LIMITS_H__",sizeof("__LIMITS_H__")-1,macros_object))	
 						create_limits_header(IncludeTokenList,look_for);	// not included yet
 					break;
-					}
 				case 0:;
 				}
 
@@ -2147,7 +2138,7 @@
 					strncpy(tmp,x+pretokenized[j].first,pretokenized[j].second);
 					if (!locked_macros.InsertSlotAt(locked_macros.size(),tmp))
 						{
-						_flush(tmp);
+						free(tmp);
 						throw std::bad_alloc();
 						}
 					}
@@ -2167,13 +2158,11 @@
 				{
 #ifndef NDEBUG
 				default:
-					{
 					INC_INFORM(ERR_STR);
 					INC_INFORM("unhandled STDC pragma ");
 					INFORM(pragma_STDC_keywords[STDC_pragma].first);
 					zcc_errors.inc_error();
 					return 0;
-					};
 #endif
 				case PRAGMA_STDC_FP_CONTRACT:
 				case PRAGMA_STDC_FENV_ACCESS:
@@ -2208,8 +2197,7 @@
 			&&	1==pretokenized[1].second && '('==x[pretokenized[1].first]
 			&&	1==pretokenized[3].second && ')'==x[pretokenized[3].first]
 			&&	C_TESTFLAG_STRING_LITERAL==pretokenized[2].third)
-			{
-			// hmm...do we need to unescape anything...
+			{	// hmm...do we need to unescape anything...
 			const bool wide_str = 'L'==x[pretokenized[2].first];
 			if (0<std::count(x+pretokenized[2].first,x+pretokenized[2].first+pretokenized[2].second,'\\'))
 				{	// no escapes
@@ -2217,12 +2205,11 @@
 
 				//! \todo change target, this only handles target CHAR_BIT<=host CHAR_BIT
 				const size_t tmp_len = lang.UnescapeStringLength(x+pretokenized[2].first,pretokenized[2].second);
-				char* tmp = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(tmp_len));
-				if (NULL!=tmp)
+				if (char* tmp = _new_buffer<char>(ZAIMONI_LEN_WITH_NULL(tmp_len)))
 					{
 					lang.UnescapeString(tmp,x+pretokenized[2].first,pretokenized[2].second);
 					INFORM(tmp,tmp_len);
-					_flush(tmp);
+					free(tmp);
 					return 0;
 					}
 				};
@@ -2265,11 +2252,7 @@
 CPreprocessor::tokenize_line(autovalarray_ptr<Token<char>* >& TokenList, size_t i) const
 {
 	assert(TokenList.size()>i);
-	if (TokenList[i]->empty())
-		{
-		TokenList.DeleteIdx(i);
-		return 0;
-		};
+	if (TokenList[i]->empty()) return TokenList.DeleteIdx(i),0; 
 
 	// Not really (it's a preprocessing directive), but we don't want to damage it here
 	if ('#'==TokenList[i]->front()) return 1;
@@ -2279,11 +2262,7 @@
 
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized;
 	lang.line_lex(TokenList[i]->data(),TokenList[i]->size(),pretokenized);
-	if (pretokenized.empty())
-		{
-		TokenList.DeleteIdx(i);
-		return 0;
-		}
+	if (pretokenized.empty()) return TokenList.DeleteIdx(i),0;
 
 	size_t ub = pretokenized.size()-1;
 	if (0==ub)
@@ -2307,7 +2286,7 @@
 				TokenListAlt[lb] = new Token<char>(tmp,pretokenized[lb].first,pretokenized[lb].second,pretokenized[lb].third);
 				complete_string_character_literal(*TokenListAlt[lb++]);
 				}
-			else{	// second token longer
+			else{	// first token longer
 				TokenListAlt[ub] = new Token<char>(tmp,pretokenized[ub].first,pretokenized[ub].second,pretokenized[ub].third);
 				complete_string_character_literal(*TokenListAlt[ub--]);
 				}
@@ -2343,16 +2322,16 @@
 	char image_filepath[FILENAME_MAX];
 	char test_filepath[FILENAME_MAX];
 
-	assert(!is_empty_string(src));
-	assert(!is_empty_string(local_root));
-	assert(NULL!=filepath_buf);
+	assert(src && *src);
+	assert(local_root && *local_root);
+	assert(filepath_buf);
 	const size_t src_len = strlen(src);
 
 	// automatically fail anything that won't fit in FILENAME_MAX
 	//! \test Error_huge_path.hpp
 	if (FILENAME_MAX<=src_len) return false;
 
-	if (NULL!=origin_dir)
+	if (origin_dir)
 		{
 		size_t target_length = strlen(origin_dir);
 		assert(FILENAME_MAX>target_length);
@@ -2376,7 +2355,7 @@
 #endif
 		}
 	const char* const canonical_path = z_realpath(image_filepath,test_filepath);
-	if (NULL!=canonical_path && !access(canonical_path,F_OK))
+	if (canonical_path && !access(canonical_path,F_OK))
 		{
 		strcpy(filepath_buf,canonical_path);
 		return true;



From zaimoni at mail.berlios.de  Sat Oct 30 20:36:38 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 30 Oct 2010 20:36:38 +0200
Subject: [Zcplusplus-commits] r520 - trunk
Message-ID: <20101030183639.06707481039@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-30 20:36:38 +0200 (Sat, 30 Oct 2010)
New Revision: 520

Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc.cpp.in
   trunk/CPreproc_pp.cpp
Log:
stage 3: line count reduction

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2010-10-30 18:00:22 UTC (rev 519)
+++ trunk/CPreproc.cpp	2010-10-30 18:36:38 UTC (rev 520)
@@ -2419,8 +2419,8 @@
 	char image_filepath[FILENAME_MAX];
 	char test_filepath[FILENAME_MAX];
 
-	assert(!is_empty_string(src));
-	assert(NULL!=filepath_buf);
+	assert(src && *src);
+	assert(filepath_buf);
 	const size_t src_len = strlen(src);
 	// automatically fail anything that won't fit in FILENAME_MAX
 	//! \test Error_huge_path.hpp
@@ -2433,16 +2433,14 @@
 		{
 		const char* parent_dir_candidate = strstr(src,"..");
 		if (src==parent_dir_candidate)
-			{
-			//! \test Error_chroot_jail1.hpp
+			{	//! \test Error_chroot_jail1.hpp
 			if (sizeof("..")-1==src_len) return false;
 			//! \test Error_chroot_jail2.hpp
 			if ('/'==src[sizeof("..")-1]) return false;
 			parent_dir_candidate = strstr(parent_dir_candidate+(sizeof("..")-1),"..");
 			}
-		while(NULL!=parent_dir_candidate && src_len>=(parent_dir_candidate-src)+(sizeof("..")-1))
-			{
-			//! \test Error_chroot_jail3.hpp
+		while(parent_dir_candidate && src_len>=(parent_dir_candidate-src)+(sizeof("..")-1))
+			{	//! \test Error_chroot_jail3.hpp
 			if ('/'==parent_dir_candidate[-1]) return false;
 			parent_dir_candidate = (src_len==parent_dir_candidate-src+(sizeof("..")-1)) ? NULL : strstr(parent_dir_candidate+(sizeof("..")-1),"..");
 			}
@@ -2469,14 +2467,13 @@
 			std::replace(test_filepath+target_length,test_filepath+target_length+src_len,'/',ZAIMONI_PATH_SEP_CHAR);
 #endif
 			const char* const canonical_path = z_realpath(image_filepath,test_filepath);
-			if (NULL!=canonical_path && !access(canonical_path,F_OK))
+			if (canonical_path && !access(canonical_path,F_OK))
 				{
 				strcpy(filepath_buf,canonical_path);
 				return true;
 				}
 			}
 	while(STATIC_SIZE(actual_system_include_search) > ++i);
-
 	return false;	//! \test Error_include_nonexistent1.hpp
 }
 
@@ -2491,7 +2488,7 @@
 int
 CPreprocessor::context_free_defined(const char* const x, size_t x_len) const
 {
-	assert(NULL!=x);
+	assert(x && *x);
 	assert(0<x_len);
 	if (0<=linear_find(x, x_len, macro_identifier_default, macro_identifier_default_count)) return 1;
 	// report "magic macros" as defined if the master preprocessor does
@@ -2503,7 +2500,7 @@
 static bool
 macro_is_defined(const char* const x, const size_t x_len, const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<char*>& macros_function)
 {
-	assert(NULL!=x);
+	assert(x && *x);
 	assert(0<x_len);
 #ifdef NDEBUG
 	return 0<=binary_find(x,x_len,macros_object) || 0<=binary_find(x,x_len,macros_function);
@@ -2580,19 +2577,18 @@
 	//! \test Pass_macro_STDC.hpp
 	switch(context_free_defined(x.data()+critical_offset,token_len))
 	{
-	case 1:		{	// found it
-				x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 1" : "#if 0");
-				PACK_DIRECTIVE(x.flags,PP::IF);
-				return true;
-				}
-	case -1:	{	// hard-locked, not defined : ergo, undefined
-				x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 0" : "#if 1");
-				PACK_DIRECTIVE(x.flags,PP::IF);
-				return true;
-				}
+	case 1:	// found it
+		x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 1" : "#if 0");
+		PACK_DIRECTIVE(x.flags,PP::IF);
+		return true;
+	case -1:	// hard-locked, not defined : ergo, undefined
+		x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 0" : "#if 1");
+		PACK_DIRECTIVE(x.flags,PP::IF);
+		return true;
 	};
 
 	// exercised heavily by the standard library include tests
+	// MingW32 4.3.3 doesn't like factoring out the last two lines
 	if (macro_is_defined(x.data()+critical_offset, token_len,macros_object,macros_function))
 		{	// found it
 		x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 1" : "#if 0");
@@ -2611,7 +2607,7 @@
 	POD_pair<size_t,size_t> paren_depth = {0,0};
 	const autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >::const_iterator iter_end = pretokenized.end();
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >::const_iterator iter = pretokenized.begin();
-	assert(NULL!=x);
+	assert(x);
 	if (iter!=iter_end)
 		do	if (1==iter->second)
 				{
@@ -2628,8 +2624,7 @@
 	POD_pair<size_t,size_t> depth = balanced_character_count(x.data(),pretokenized,l_match,r_match);	// pre-scan
 	DEBUG_STATEMENT(size_t err_count = 0;)
 	if (0<depth.first && 0<depth.second)
-		{
-		// reality-check: balanced parentheses
+		{	// reality-check: balanced parentheses
 		autovalarray_ptr_throws<size_t> lparen_fixedstack(depth.first);
 		autovalarray_ptr_throws<POD_pair<size_t,size_t> > parenpair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 		size_t balanced_paren = 0;
@@ -2685,8 +2680,7 @@
 	POD_pair<size_t,size_t> depth = balanced_character_count(x.data(),pretokenized,'[',']');	// pre-scan
 	DEBUG_STATEMENT(size_t err_count = 0;)
 	if (0<depth.first && 0<depth.second)
-		{
-		// reality-check: balanced parentheses
+		{	// reality-check: balanced parentheses
 		autovalarray_ptr_throws<size_t> lparen_fixedstack(depth.first);
 		autovalarray_ptr_throws<POD_pair<size_t,size_t> > parenpair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 		size_t balanced_paren = 0;
@@ -2772,7 +2766,7 @@
 static inline bool
 token_is_char(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return 1==lexed_token.second && c==x[lexed_token.first];
 }
 
@@ -2780,7 +2774,7 @@
 inline bool
 token_is_char<'#'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return detect_C_stringize_op(x+lexed_token.first,lexed_token.second);
 }
 
@@ -2788,7 +2782,7 @@
 inline bool
 token_is_char<'['>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return detect_C_left_bracket_op(x+lexed_token.first,lexed_token.second);
 }
 
@@ -2796,7 +2790,7 @@
 inline bool
 token_is_char<']'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return detect_C_right_bracket_op(x+lexed_token.first,lexed_token.second);
 }
 
@@ -2804,7 +2798,7 @@
 inline bool
 token_is_char<'{'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return detect_C_left_brace_op(x+lexed_token.first,lexed_token.second);
 }
 
@@ -2812,7 +2806,7 @@
 inline bool
 token_is_char<'}'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return detect_C_right_brace_op(x+lexed_token.first,lexed_token.second);
 }
 
@@ -3096,8 +3090,7 @@
 	lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
 	STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
 
-	// error the illegal preprocessing tokens here
-	{
+	{	// error the illegal preprocessing tokens here
 	const size_t old_err_count = zcc_errors.err_count();
 	i = pretokenized.size();
 	do	{
@@ -3366,13 +3359,13 @@
 		const char* macro_value = NULL;
 		char buf[10];
 		char file_buf[MAX_PATH+2];
-		if (NULL!=macro_identifier_default[macro_index].second)
+		if (macro_identifier_default[macro_index].second)
 			// value known, substitute in
 			macro_value = macro_identifier_default[macro_index].second;
 		// special
 		else if (!strcmp(macro_identifier_default[macro_index].first,"__FILE__"))
 			{
-			assert(NULL!=x.src_filename);
+			assert(x.src_filename);
 			file_buf[0] = '"';
 			strcpy(file_buf+1,x.src_filename);
 			file_buf[1+strlen(x.src_filename)] = '"';
@@ -3509,7 +3502,7 @@
 	assert(0>object_macro_index || 0>function_macro_index);
 	if (0<=object_macro_index)
 		{
-		if (NULL==macros_object_expansion[object_macro_index])
+		if (!macros_object_expansion[object_macro_index])
 			{
 			_macro_replace(x,critical_offset,token_len,"");
 			return true;
@@ -3525,7 +3518,7 @@
 		Test.ltrim(critical_offset);
 		_macro_replace(Test,test_critical_offset,token_len,macros_object_expansion[object_macro_index]->data());
 		predefined_macro_replacement(Test,0);
-		if (NULL==used_macro_stack)
+		if (!used_macro_stack)
 			{
 			autovalarray_ptr<char*> macro_stack(1);
 			macro_stack[0] = _new_buffer_nonNULL_throws<char>(token_len);
@@ -3544,7 +3537,7 @@
 		};
 	if (0<=function_macro_index && x.size()>critical_offset+token_len && '('==x.data()[critical_offset+token_len])
 		{
-		assert(NULL!=macros_function_arglist[function_macro_index]);
+		assert(macros_function_arglist[function_macro_index]);
 		assert('('==macros_function_arglist[function_macro_index]->front());
 		assert(')'==macros_function_arglist[function_macro_index]->back());
 		const size_t formal_arg_span = macros_function_arglist[function_macro_index]->size();
@@ -3582,7 +3575,7 @@
 			x.flags |= INVALID_DIRECTIVE_FLAG;
 			return false;
 			}
-		if (NULL==macros_function_expansion[function_macro_index])
+		if (!macros_function_expansion[function_macro_index])
 			{
 			_macro_replace(x,critical_offset,token_len+arg_span,"");
 			return true;
@@ -3610,7 +3603,7 @@
 		size_t j = formal_arg_count;
 		do	{
 			--j;
-			assert(NULL!=formal_arguments[j]);
+			assert(formal_arguments[j]);
 			assert(0<formal_arguments[j]->size());
 			const size_t identifier_len = lang.UnfilteredNextToken(formal_arguments[j]->data(),identifier_flags);
 			assert(C_TESTFLAG_IDENTIFIER==identifier_flags);
@@ -3624,7 +3617,7 @@
 		if (formal_varadic) formal_arguments.back()->replace_once(0,formal_arguments.back()->size(),"__VA_ARGS__");
 		//! \todo should discard unused formal arguments and their parameter lists; not worth a warning, as there are a number of legitimate uses for discarding formal parameters
 		Token<char> Test(*macros_function_expansion[function_macro_index]);
-		if (NULL==used_macro_stack)
+		if (!used_macro_stack)
 			{
 			autovalarray_ptr<char*> macro_stack(1);
 			macro_stack[0] = _new_buffer_nonNULL_throws<char>(token_len);
@@ -3656,7 +3649,7 @@
  */
 static bool _concatenate_single(Token<char>& x,const POD_triple<size_t,size_t,lex_flags>* pretokenized, LangConf& lang)
 {
-	assert(NULL!=pretokenized);
+	assert(pretokenized);
 	autovalarray_ptr_throws<char> new_token(pretokenized[0].second+pretokenized[2].second);
 	strncpy(new_token.c_array(),x.data()+pretokenized[0].first,pretokenized[0].second);
 	strncpy(new_token.c_array()+pretokenized[0].second,x.data()+pretokenized[2].first,pretokenized[2].second);

Modified: trunk/CPreproc.cpp.in
===================================================================
--- trunk/CPreproc.cpp.in	2010-10-30 18:00:22 UTC (rev 519)
+++ trunk/CPreproc.cpp.in	2010-10-30 18:36:38 UTC (rev 520)
@@ -2455,8 +2455,8 @@
 	char image_filepath[FILENAME_MAX];
 	char test_filepath[FILENAME_MAX];
 
-	assert(!is_empty_string(src));
-	assert(NULL!=filepath_buf);
+	assert(src && *src);
+	assert(filepath_buf);
 	const size_t src_len = strlen(src);
 	// automatically fail anything that won't fit in FILENAME_MAX
 	//! \test Error_huge_path.hpp
@@ -2469,16 +2469,14 @@
 		{
 		const char* parent_dir_candidate = strstr(src,"..");
 		if (src==parent_dir_candidate)
-			{
-			//! \test Error_chroot_jail1.hpp
+			{	//! \test Error_chroot_jail1.hpp
 			if (sizeof("..")-1==src_len) return false;
 			//! \test Error_chroot_jail2.hpp
 			if ('/'==src[sizeof("..")-1]) return false;
 			parent_dir_candidate = strstr(parent_dir_candidate+(sizeof("..")-1),"..");
 			}
-		while(NULL!=parent_dir_candidate && src_len>=(parent_dir_candidate-src)+(sizeof("..")-1))
-			{
-			//! \test Error_chroot_jail3.hpp
+		while(parent_dir_candidate && src_len>=(parent_dir_candidate-src)+(sizeof("..")-1))
+			{	//! \test Error_chroot_jail3.hpp
 			if ('/'==parent_dir_candidate[-1]) return false;
 			parent_dir_candidate = (src_len==parent_dir_candidate-src+(sizeof("..")-1)) ? NULL : strstr(parent_dir_candidate+(sizeof("..")-1),"..");
 			}
@@ -2505,14 +2503,13 @@
 			std::replace(test_filepath+target_length,test_filepath+target_length+src_len,'/',ZAIMONI_PATH_SEP_CHAR);
 #endif
 			const char* const canonical_path = z_realpath(image_filepath,test_filepath);
-			if (NULL!=canonical_path && !access(canonical_path,F_OK))
+			if (canonical_path && !access(canonical_path,F_OK))
 				{
 				strcpy(filepath_buf,canonical_path);
 				return true;
 				}
 			}
 	while(STATIC_SIZE(actual_system_include_search) > ++i);
-
 	return false;	//! \test Error_include_nonexistent1.hpp
 }
 
@@ -2527,7 +2524,7 @@
 int
 CPreprocessor::context_free_defined(const char* const x, size_t x_len) const
 {
-	assert(NULL!=x);
+	assert(x && *x);
 	assert(0<x_len);
 	if (0<=linear_find(x, x_len, macro_identifier_default, macro_identifier_default_count)) return 1;
 	// report "magic macros" as defined if the master preprocessor does
@@ -2539,7 +2536,7 @@
 static bool
 macro_is_defined(const char* const x, const size_t x_len, const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<char*>& macros_function)
 {
-	assert(NULL!=x);
+	assert(x && *x);
 	assert(0<x_len);
 #ifdef NDEBUG
 	return 0<=binary_find(x,x_len,macros_object) || 0<=binary_find(x,x_len,macros_function);
@@ -2616,19 +2613,18 @@
 	//! \test Pass_macro_STDC.hpp
 	switch(context_free_defined(x.data()+critical_offset,token_len))
 	{
-	case 1:		{	// found it
-				x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 1" : "#if 0");
-				PACK_DIRECTIVE(x.flags,PP::IF);
-				return true;
-				}
-	case -1:	{	// hard-locked, not defined : ergo, undefined
-				x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 0" : "#if 1");
-				PACK_DIRECTIVE(x.flags,PP::IF);
-				return true;
-				}
+	case 1:	// found it
+		x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 1" : "#if 0");
+		PACK_DIRECTIVE(x.flags,PP::IF);
+		return true;
+	case -1:	// hard-locked, not defined : ergo, undefined
+		x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 0" : "#if 1");
+		PACK_DIRECTIVE(x.flags,PP::IF);
+		return true;
 	};
 
 	// exercised heavily by the standard library include tests
+	// MingW32 4.3.3 doesn't like factoring out the last two lines
 	if (macro_is_defined(x.data()+critical_offset, token_len,macros_object,macros_function))
 		{	// found it
 		x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 1" : "#if 0");
@@ -2647,7 +2643,7 @@
 	POD_pair<size_t,size_t> paren_depth = {0,0};
 	const autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >::const_iterator iter_end = pretokenized.end();
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >::const_iterator iter = pretokenized.begin();
-	assert(NULL!=x);
+	assert(x);
 	if (iter!=iter_end)
 		do	if (1==iter->second)
 				{
@@ -2664,8 +2660,7 @@
 	POD_pair<size_t,size_t> depth = balanced_character_count(x.data(),pretokenized,l_match,r_match);	// pre-scan
 	DEBUG_STATEMENT(size_t err_count = 0;)
 	if (0<depth.first && 0<depth.second)
-		{
-		// reality-check: balanced parentheses
+		{	// reality-check: balanced parentheses
 		autovalarray_ptr_throws<size_t> lparen_fixedstack(depth.first);
 		autovalarray_ptr_throws<POD_pair<size_t,size_t> > parenpair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 		size_t balanced_paren = 0;
@@ -2721,8 +2716,7 @@
 	POD_pair<size_t,size_t> depth = balanced_character_count(x.data(),pretokenized,'[',']');	// pre-scan
 	DEBUG_STATEMENT(size_t err_count = 0;)
 	if (0<depth.first && 0<depth.second)
-		{
-		// reality-check: balanced parentheses
+		{	// reality-check: balanced parentheses
 		autovalarray_ptr_throws<size_t> lparen_fixedstack(depth.first);
 		autovalarray_ptr_throws<POD_pair<size_t,size_t> > parenpair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 		size_t balanced_paren = 0;
@@ -2808,7 +2802,7 @@
 static inline bool
 token_is_char(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return 1==lexed_token.second && c==x[lexed_token.first];
 }
 
@@ -2816,7 +2810,7 @@
 inline bool
 token_is_char<'#'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return detect_C_stringize_op(x+lexed_token.first,lexed_token.second);
 }
 
@@ -2824,7 +2818,7 @@
 inline bool
 token_is_char<'['>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return detect_C_left_bracket_op(x+lexed_token.first,lexed_token.second);
 }
 
@@ -2832,7 +2826,7 @@
 inline bool
 token_is_char<']'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return detect_C_right_bracket_op(x+lexed_token.first,lexed_token.second);
 }
 
@@ -2840,7 +2834,7 @@
 inline bool
 token_is_char<'{'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return detect_C_left_brace_op(x+lexed_token.first,lexed_token.second);
 }
 
@@ -2848,7 +2842,7 @@
 inline bool
 token_is_char<'}'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return detect_C_right_brace_op(x+lexed_token.first,lexed_token.second);
 }
 
@@ -3132,8 +3126,7 @@
 	lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
 	STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
 
-	// error the illegal preprocessing tokens here
-	{
+	{	// error the illegal preprocessing tokens here
 	const size_t old_err_count = zcc_errors.err_count();
 	i = pretokenized.size();
 	do	{
@@ -3407,13 +3400,13 @@
 		const char* macro_value = NULL;
 		char buf[10];
 		char file_buf[MAX_PATH+2];
-		if (NULL!=macro_identifier_default[macro_index].second)
+		if (macro_identifier_default[macro_index].second)
 			// value known, substitute in
 			macro_value = macro_identifier_default[macro_index].second;
 		// special
 		else if (!strcmp(macro_identifier_default[macro_index].first,"__FILE__"))
 			{
-			assert(NULL!=x.src_filename);
+			assert(x.src_filename);
 			file_buf[0] = '"';
 			strcpy(file_buf+1,x.src_filename);
 			file_buf[1+strlen(x.src_filename)] = '"';
@@ -3550,7 +3543,7 @@
 	assert(0>object_macro_index || 0>function_macro_index);
 	if (0<=object_macro_index)
 		{
-		if (NULL==macros_object_expansion[object_macro_index])
+		if (!macros_object_expansion[object_macro_index])
 			{
 			_macro_replace(x,critical_offset,token_len,"");
 			return true;
@@ -3566,7 +3559,7 @@
 		Test.ltrim(critical_offset);
 		_macro_replace(Test,test_critical_offset,token_len,macros_object_expansion[object_macro_index]->data());
 		predefined_macro_replacement(Test,0);
-		if (NULL==used_macro_stack)
+		if (!used_macro_stack)
 			{
 			autovalarray_ptr<char*> macro_stack(1);
 			macro_stack[0] = _new_buffer_nonNULL_throws<char>(token_len);
@@ -3585,7 +3578,7 @@
 		};
 	if (0<=function_macro_index && x.size()>critical_offset+token_len && '('==x.data()[critical_offset+token_len])
 		{
-		assert(NULL!=macros_function_arglist[function_macro_index]);
+		assert(macros_function_arglist[function_macro_index]);
 		assert('('==macros_function_arglist[function_macro_index]->front());
 		assert(')'==macros_function_arglist[function_macro_index]->back());
 		const size_t formal_arg_span = macros_function_arglist[function_macro_index]->size();
@@ -3623,7 +3616,7 @@
 			x.flags |= INVALID_DIRECTIVE_FLAG;
 			return false;
 			}
-		if (NULL==macros_function_expansion[function_macro_index])
+		if (!macros_function_expansion[function_macro_index])
 			{
 			_macro_replace(x,critical_offset,token_len+arg_span,"");
 			return true;
@@ -3651,7 +3644,7 @@
 		size_t j = formal_arg_count;
 		do	{
 			--j;
-			assert(NULL!=formal_arguments[j]);
+			assert(formal_arguments[j]);
 			assert(0<formal_arguments[j]->size());
 			const size_t identifier_len = lang.UnfilteredNextToken(formal_arguments[j]->data(),identifier_flags);
 			assert(C_TESTFLAG_IDENTIFIER==identifier_flags);
@@ -3665,7 +3658,7 @@
 		if (formal_varadic) formal_arguments.back()->replace_once(0,formal_arguments.back()->size(),"__VA_ARGS__");
 		//! \todo should discard unused formal arguments and their parameter lists; not worth a warning, as there are a number of legitimate uses for discarding formal parameters
 		Token<char> Test(*macros_function_expansion[function_macro_index]);
-		if (NULL==used_macro_stack)
+		if (!used_macro_stack)
 			{
 			autovalarray_ptr<char*> macro_stack(1);
 			macro_stack[0] = _new_buffer_nonNULL_throws<char>(token_len);
@@ -3697,7 +3690,7 @@
  */
 static bool _concatenate_single(Token<char>& x,const POD_triple<size_t,size_t,lex_flags>* pretokenized, LangConf& lang)
 {
-	assert(NULL!=pretokenized);
+	assert(pretokenized);
 	autovalarray_ptr_throws<char> new_token(pretokenized[0].second+pretokenized[2].second);
 	strncpy(new_token.c_array(),x.data()+pretokenized[0].first,pretokenized[0].second);
 	strncpy(new_token.c_array()+pretokenized[0].second,x.data()+pretokenized[2].first,pretokenized[2].second);

Modified: trunk/CPreproc_pp.cpp
===================================================================
--- trunk/CPreproc_pp.cpp	2010-10-30 18:00:22 UTC (rev 519)
+++ trunk/CPreproc_pp.cpp	2010-10-30 18:36:38 UTC (rev 520)
@@ -2379,8 +2379,8 @@
 	char image_filepath[FILENAME_MAX];
 	char test_filepath[FILENAME_MAX];
 
-	assert(!is_empty_string(src));
-	assert(NULL!=filepath_buf);
+	assert(src && *src);
+	assert(filepath_buf);
 	const size_t src_len = strlen(src);
 	// automatically fail anything that won't fit in FILENAME_MAX
 	//! \test Error_huge_path.hpp
@@ -2393,16 +2393,14 @@
 		{
 		const char* parent_dir_candidate = strstr(src,"..");
 		if (src==parent_dir_candidate)
-			{
-			//! \test Error_chroot_jail1.hpp
+			{	//! \test Error_chroot_jail1.hpp
 			if (sizeof("..")-1==src_len) return false;
 			//! \test Error_chroot_jail2.hpp
 			if ('/'==src[sizeof("..")-1]) return false;
 			parent_dir_candidate = strstr(parent_dir_candidate+(sizeof("..")-1),"..");
 			}
-		while(NULL!=parent_dir_candidate && src_len>=(parent_dir_candidate-src)+(sizeof("..")-1))
-			{
-			//! \test Error_chroot_jail3.hpp
+		while(parent_dir_candidate && src_len>=(parent_dir_candidate-src)+(sizeof("..")-1))
+			{	//! \test Error_chroot_jail3.hpp
 			if ('/'==parent_dir_candidate[-1]) return false;
 			parent_dir_candidate = (src_len==parent_dir_candidate-src+(sizeof("..")-1)) ? NULL : strstr(parent_dir_candidate+(sizeof("..")-1),"..");
 			}
@@ -2429,14 +2427,13 @@
 			std::replace(test_filepath+target_length,test_filepath+target_length+src_len,'/',ZAIMONI_PATH_SEP_CHAR);
 #endif
 			const char* const canonical_path = z_realpath(image_filepath,test_filepath);
-			if (NULL!=canonical_path && !access(canonical_path,F_OK))
+			if (canonical_path && !access(canonical_path,F_OK))
 				{
 				strcpy(filepath_buf,canonical_path);
 				return true;
 				}
 			}
 	while(STATIC_SIZE(actual_system_include_search) > ++i);
-
 	return false;	//! \test Error_include_nonexistent1.hpp
 }
 
@@ -2451,7 +2448,7 @@
 int
 CPreprocessor::context_free_defined(const char* const x, size_t x_len) const
 {
-	assert(NULL!=x);
+	assert(x && *x);
 	assert(0<x_len);
 	if (0<=linear_find(x, x_len, macro_identifier_default, macro_identifier_default_count)) return 1;
 	// report "magic macros" as defined if the master preprocessor does
@@ -2463,7 +2460,7 @@
 static bool
 macro_is_defined(const char* const x, const size_t x_len, const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<char*>& macros_function)
 {
-	assert(NULL!=x);
+	assert(x && *x);
 	assert(0<x_len);
 #ifdef NDEBUG
 	return 0<=binary_find(x,x_len,macros_object) || 0<=binary_find(x,x_len,macros_function);
@@ -2540,19 +2537,18 @@
 	//! \test Pass_macro_STDC.hpp
 	switch(context_free_defined(x.data()+critical_offset,token_len))
 	{
-	case 1:		{	// found it
-				x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 1" : "#if 0");
-				PACK_DIRECTIVE(x.flags,PP::IF);
-				return true;
-				}
-	case -1:	{	// hard-locked, not defined : ergo, undefined
-				x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 0" : "#if 1");
-				PACK_DIRECTIVE(x.flags,PP::IF);
-				return true;
-				}
+	case 1:	// found it
+		x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 1" : "#if 0");
+		PACK_DIRECTIVE(x.flags,PP::IF);
+		return true;
+	case -1:	// hard-locked, not defined : ergo, undefined
+		x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 0" : "#if 1");
+		PACK_DIRECTIVE(x.flags,PP::IF);
+		return true;
 	};
 
 	// exercised heavily by the standard library include tests
+	// MingW32 4.3.3 doesn't like factoring out the last two lines
 	if (macro_is_defined(x.data()+critical_offset, token_len,macros_object,macros_function))
 		{	// found it
 		x.replace_once(std::nothrow,0,x.size(),(PP::IFDEF==if_directive) ? "#if 1" : "#if 0");
@@ -2571,7 +2567,7 @@
 	POD_pair<size_t,size_t> paren_depth = {0,0};
 	const autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >::const_iterator iter_end = pretokenized.end();
 	autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> >::const_iterator iter = pretokenized.begin();
-	assert(NULL!=x);
+	assert(x);
 	if (iter!=iter_end)
 		do	if (1==iter->second)
 				{
@@ -2588,8 +2584,7 @@
 	POD_pair<size_t,size_t> depth = balanced_character_count(x.data(),pretokenized,l_match,r_match);	// pre-scan
 	DEBUG_STATEMENT(size_t err_count = 0;)
 	if (0<depth.first && 0<depth.second)
-		{
-		// reality-check: balanced parentheses
+		{	// reality-check: balanced parentheses
 		autovalarray_ptr_throws<size_t> lparen_fixedstack(depth.first);
 		autovalarray_ptr_throws<POD_pair<size_t,size_t> > parenpair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 		size_t balanced_paren = 0;
@@ -2645,8 +2640,7 @@
 	POD_pair<size_t,size_t> depth = balanced_character_count(x.data(),pretokenized,'[',']');	// pre-scan
 	DEBUG_STATEMENT(size_t err_count = 0;)
 	if (0<depth.first && 0<depth.second)
-		{
-		// reality-check: balanced parentheses
+		{	// reality-check: balanced parentheses
 		autovalarray_ptr_throws<size_t> lparen_fixedstack(depth.first);
 		autovalarray_ptr_throws<POD_pair<size_t,size_t> > parenpair_fixedstack(depth.first<depth.second ? depth.first : depth.second);
 		size_t balanced_paren = 0;
@@ -2732,7 +2726,7 @@
 static inline bool
 token_is_char(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return 1==lexed_token.second && c==x[lexed_token.first];
 }
 
@@ -2740,7 +2734,7 @@
 inline bool
 token_is_char<'#'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return detect_C_stringize_op(x+lexed_token.first,lexed_token.second);
 }
 
@@ -2748,7 +2742,7 @@
 inline bool
 token_is_char<'['>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return detect_C_left_bracket_op(x+lexed_token.first,lexed_token.second);
 }
 
@@ -2756,7 +2750,7 @@
 inline bool
 token_is_char<']'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return detect_C_right_bracket_op(x+lexed_token.first,lexed_token.second);
 }
 
@@ -2764,7 +2758,7 @@
 inline bool
 token_is_char<'{'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return detect_C_left_brace_op(x+lexed_token.first,lexed_token.second);
 }
 
@@ -2772,7 +2766,7 @@
 inline bool
 token_is_char<'}'>(const char* const x, const POD_triple<size_t,size_t,lex_flags>& lexed_token)
 {
-	assert(NULL!=x);
+	assert(x);
 	return detect_C_right_brace_op(x+lexed_token.first,lexed_token.second);
 }
 
@@ -3056,8 +3050,7 @@
 	lang.line_lex(x.data()+critical_offset,x.size()-critical_offset,pretokenized);
 	STL_translate_first(critical_offset,pretokenized);	// coordinate fixup
 
-	// error the illegal preprocessing tokens here
-	{
+	{	// error the illegal preprocessing tokens here
 	const size_t old_err_count = zcc_errors.err_count();
 	i = pretokenized.size();
 	do	{
@@ -3326,13 +3319,13 @@
 		const char* macro_value = NULL;
 		char buf[10];
 		char file_buf[MAX_PATH+2];
-		if (NULL!=macro_identifier_default[macro_index].second)
+		if (macro_identifier_default[macro_index].second)
 			// value known, substitute in
 			macro_value = macro_identifier_default[macro_index].second;
 		// special
 		else if (!strcmp(macro_identifier_default[macro_index].first,"__FILE__"))
 			{
-			assert(NULL!=x.src_filename);
+			assert(x.src_filename);
 			file_buf[0] = '"';
 			strcpy(file_buf+1,x.src_filename);
 			file_buf[1+strlen(x.src_filename)] = '"';
@@ -3469,7 +3462,7 @@
 	assert(0>object_macro_index || 0>function_macro_index);
 	if (0<=object_macro_index)
 		{
-		if (NULL==macros_object_expansion[object_macro_index])
+		if (!macros_object_expansion[object_macro_index])
 			{
 			_macro_replace(x,critical_offset,token_len,"");
 			return true;
@@ -3485,7 +3478,7 @@
 		Test.ltrim(critical_offset);
 		_macro_replace(Test,test_critical_offset,token_len,macros_object_expansion[object_macro_index]->data());
 		predefined_macro_replacement(Test,0);
-		if (NULL==used_macro_stack)
+		if (!used_macro_stack)
 			{
 			autovalarray_ptr<char*> macro_stack(1);
 			macro_stack[0] = _new_buffer_nonNULL_throws<char>(token_len);
@@ -3504,7 +3497,7 @@
 		};
 	if (0<=function_macro_index && x.size()>critical_offset+token_len && '('==x.data()[critical_offset+token_len])
 		{
-		assert(NULL!=macros_function_arglist[function_macro_index]);
+		assert(macros_function_arglist[function_macro_index]);
 		assert('('==macros_function_arglist[function_macro_index]->front());
 		assert(')'==macros_function_arglist[function_macro_index]->back());
 		const size_t formal_arg_span = macros_function_arglist[function_macro_index]->size();
@@ -3542,7 +3535,7 @@
 			x.flags |= INVALID_DIRECTIVE_FLAG;
 			return false;
 			}
-		if (NULL==macros_function_expansion[function_macro_index])
+		if (!macros_function_expansion[function_macro_index])
 			{
 			_macro_replace(x,critical_offset,token_len+arg_span,"");
 			return true;
@@ -3570,7 +3563,7 @@
 		size_t j = formal_arg_count;
 		do	{
 			--j;
-			assert(NULL!=formal_arguments[j]);
+			assert(formal_arguments[j]);
 			assert(0<formal_arguments[j]->size());
 			const size_t identifier_len = lang.UnfilteredNextToken(formal_arguments[j]->data(),identifier_flags);
 			assert(C_TESTFLAG_IDENTIFIER==identifier_flags);
@@ -3584,7 +3577,7 @@
 		if (formal_varadic) formal_arguments.back()->replace_once(0,formal_arguments.back()->size(),"__VA_ARGS__");
 		//! \todo should discard unused formal arguments and their parameter lists; not worth a warning, as there are a number of legitimate uses for discarding formal parameters
 		Token<char> Test(*macros_function_expansion[function_macro_index]);
-		if (NULL==used_macro_stack)
+		if (!used_macro_stack)
 			{
 			autovalarray_ptr<char*> macro_stack(1);
 			macro_stack[0] = _new_buffer_nonNULL_throws<char>(token_len);
@@ -3616,7 +3609,7 @@
  */
 static bool _concatenate_single(Token<char>& x,const POD_triple<size_t,size_t,lex_flags>* pretokenized, LangConf& lang)
 {
-	assert(NULL!=pretokenized);
+	assert(pretokenized);
 	autovalarray_ptr_throws<char> new_token(pretokenized[0].second+pretokenized[2].second);
 	strncpy(new_token.c_array(),x.data()+pretokenized[0].first,pretokenized[0].second);
 	strncpy(new_token.c_array()+pretokenized[0].second,x.data()+pretokenized[2].first,pretokenized[2].second);



From zaimoni at mail.berlios.de  Sat Oct 30 22:27:02 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 30 Oct 2010 22:27:02 +0200
Subject: [Zcplusplus-commits] r521 - trunk
Message-ID: <20101030202702.CA2F4481039@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-30 22:27:02 +0200 (Sat, 30 Oct 2010)
New Revision: 521

Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc.cpp.in
   trunk/CPreproc_pp.cpp
Log:
stage 3: line count reduction

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2010-10-30 18:36:38 UTC (rev 520)
+++ trunk/CPreproc.cpp	2010-10-30 20:27:02 UTC (rev 521)
@@ -3734,7 +3734,7 @@
 
 	// deal with empty-var ## operators
 	size_t j = actual_arguments.size();
-	do if (NULL==actual_arguments[--j])
+	do if (!actual_arguments[--j])
 			{	// have a genuinely empty argument
 			if (lang.line_lex_find(x.data(),x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
 				{
@@ -3748,7 +3748,7 @@
 							if (C_TESTFLAG_IDENTIFIER==pretokenized[k+1].third)
 								{
 								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k+1].first,pretokenized[k+1].second,formal_arguments);
-								if (0<=j2 && NULL==actual_arguments[j2])
+								if (0<=j2 && !actual_arguments[j2])
 									{	// we matched an empty parameter (concatenation identity)
 									const size_t replace_start = pretokenized[k-1].first+pretokenized[k-1].second;
 									size_t replace_len = (pretokenized[k+1].first-replace_start)+pretokenized[k+1].second;
@@ -3761,7 +3761,7 @@
 							if (C_TESTFLAG_IDENTIFIER==pretokenized[k-1].third)
 								{	// don't need should_continue bypass for last check
 								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k-1].first,pretokenized[k-1].second,formal_arguments);
-								if (0<=j2 && NULL==actual_arguments[j2])
+								if (0<=j2 && !actual_arguments[j2])
 									{
 									const size_t replace_start = (0<k) ? pretokenized[k-2].first+pretokenized[k-2].second : 0U;
 									size_t replace_len = (pretokenized[k].first-replace_start)+pretokenized[k].second;
@@ -3782,7 +3782,7 @@
 
 	// macro-replace all arguments
 	j = actual_arguments.size();
-	do	if (NULL!=actual_arguments[--j])
+	do	if (actual_arguments[--j])
 			intradirective_preprocess(*actual_arguments[j],0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack);
 	while(0<j);
 
@@ -3794,23 +3794,23 @@
 	j = pretokenized.size();
 	do	{
 		--j;
-		const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[j].first,pretokenized[j].second,formal_arguments);
+		errr j2 = linear_find_STL_deref2(x.data()+pretokenized[j].first,pretokenized[j].second,formal_arguments);
 		if (0<=j2)
 			{
-			assert(NULL!=actual_arguments[j2]);
+			assert(actual_arguments[j2]);
 			_macro_replace(x,pretokenized[j].first,pretokenized[j].second,actual_arguments[j2]->data());
 			lang.line_lex(x.data(),x.size(),pretokenized);
 			}
 		else if (detect_C_concatenation_op(x.data()+pretokenized[j].first,pretokenized[j].second))
 			{	// hmm...
-			const errr j3 = linear_find_STL_deref2(x.data()+pretokenized[j-1].first,pretokenized[j-1].second,formal_arguments);
-			if (0<=j3)
+			j2 = linear_find_STL_deref2(x.data()+pretokenized[j-1].first,pretokenized[j-1].second,formal_arguments);
+			if (0<=j2)
 				{	// oops....must do replacement *before* the ## concatenation
-				assert(NULL!=actual_arguments[j3]);
-				assert(!actual_arguments[j3]->empty());
+				assert(actual_arguments[j2]);
+				assert(!actual_arguments[j2]->empty());
 				autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized_alt;
-				lang.line_lex(actual_arguments[j3]->data(),actual_arguments[j3]->size(),pretokenized_alt);
-				_macro_replace(x,pretokenized[j-1].first,pretokenized[j-1].second,actual_arguments[j3]->data());
+				lang.line_lex(actual_arguments[j2]->data(),actual_arguments[j2]->size(),pretokenized_alt);
+				_macro_replace(x,pretokenized[j-1].first,pretokenized[j-1].second,actual_arguments[j2]->data());
 				lang.line_lex(x.data(),x.size(),pretokenized);
 				j += pretokenized_alt.size()-1;
 				assert(detect_C_concatenation_op(x.data()+pretokenized[j].first,pretokenized[j].second));
@@ -3951,8 +3951,7 @@
 
 void
 CPreprocessor::debug_to_stderr(const autovalarray_ptr<Token<char>* >& TokenList,const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<Token<char>*>& macros_object_expansion, const autovalarray_ptr<char*>& macros_function, const autovalarray_ptr<Token<char>*>& macros_function_arglist, const autovalarray_ptr<Token<char>*>& macros_function_expansion,const autovalarray_ptr<char*>& locked_macros) const
-{
-	// need whitespace tokens here to force pretty-printing
+{	// need whitespace tokens here to force pretty-printing
 	if (debug_mode)
 		{
 		const size_t list_size = TokenList.size();
@@ -3990,7 +3989,7 @@
 			{
 			INC_INFORM("#define ");
 			INC_INFORM(macros_object[i]);
-			if (NULL!=macros_object_expansion[i])
+			if (macros_object_expansion[i])
 				{
 				INC_INFORM(" ");
 				INFORM(macros_object_expansion[i]->data());
@@ -4006,7 +4005,7 @@
 			INC_INFORM("#define ");
 			INC_INFORM(macros_function[i]);
 			INC_INFORM(macros_function_arglist[i]->data());
-			if (NULL!=macros_function_expansion[i])
+			if (macros_function_expansion[i])
 				{
 				INC_INFORM(" ");
 				INFORM(macros_function_expansion[i]->data());
@@ -4037,15 +4036,12 @@
 CPreprocessor::C99_VA_ARGS_flinch(const Token<char>& x, const size_t critical_offset) const
 {	//! \todo option to bypass this
 	assert(x.size()>critical_offset);
-	if (SIZE_MAX!=lang.lex_find(x.data()+critical_offset,x.size()-critical_offset,"__VA_ARGS__",sizeof("__VA_ARGS__")-1))
-		{
-		message_header(x);
-		INC_INFORM(ERR_STR);
-		INFORM("identifier __VA_ARGS__ not allowed here.  Continuing. (C99 6.10.3p5/C++0x 16.3p5)");
-		zcc_errors.inc_error();
-		return true;
-		}
-	return false;
+	if (SIZE_MAX==lang.lex_find(x.data()+critical_offset,x.size()-critical_offset,"__VA_ARGS__",sizeof("__VA_ARGS__")-1)) return false;
+	message_header(x);
+	INC_INFORM(ERR_STR);
+	INFORM("identifier __VA_ARGS__ not allowed here.  Continuing. (C99 6.10.3p5/C++0x 16.3p5)");
+	zcc_errors.inc_error();
+	return true;
 }
 
 void
@@ -4081,11 +4077,7 @@
 		INC_INFORM(ERR_STR);
 		INFORM("concatenation operator ## ending a macro replacement list: removing and continuing (C99 6.10.3.3p1/C++98 16.3.3p1)");
 		zcc_errors.inc_error();
-		if (1==pretokenized.size())
-			{
-			x.reset();
-			return true;
-			}
+		if (1==pretokenized.size()) return x.reset(),true;
 		pretokenized.DeleteIdx(pretokenized.size()-1);
 		x.lslice(pretokenized.back().first+pretokenized.back().second);
 		}
@@ -4096,11 +4088,7 @@
 		INC_INFORM(ERR_STR);
 		INFORM("concatenation operator ## starting a macro replacement list: removing and continuing (C99 6.10.3.3p1/C++98 16.3.3p1)");
 		zcc_errors.inc_error();
-		if (1==pretokenized.size())
-			{
-			x.reset();
-			return true;
-			}
+		if (1==pretokenized.size()) return x.reset(),true;
 		x.ltrim(pretokenized[1].first);
 		// XXX leave data structures in an inconsistent state: they'll be immediately destructed anyway
 		}
@@ -4111,7 +4099,7 @@
 CPreprocessor::use_line_directive_and_discard(autovalarray_ptr<Token<char>* >& TokenList, const size_t i)
 {
 	assert(i<TokenList.size());
-	assert(NULL!=TokenList[i]);
+	assert(TokenList[i]);
 	assert(!strncmp(TokenList[i]->data(),"#line ",sizeof("#line ")-1));
 	if (TokenList[i]->flags & INVALID_DIRECTIVE_FLAG)
 		{
@@ -4122,8 +4110,7 @@
 	lex_flags first_token_flags;
 	lex_flags second_token_flags;
 	size_t critical_offset = sizeof("#line ")-1;
-	// C99: check for decimal integer literal, then optional string literal; error if this is not found
-	{
+	{	// C99: check for decimal integer literal, then optional string literal; error if this is not found
 	const size_t first_token_len = lang.UnfilteredNextToken(TokenList[i]->data()+critical_offset,first_token_flags);
 	if (     C_TESTFLAG_PP_NUMERAL!=first_token_flags
 		||	!C_PPDecimalInteger::is(TokenList[i]->data()+critical_offset,first_token_len,line_number)
@@ -4391,12 +4378,9 @@
 	// word-chars glue to word-chars
 	// symbol-chars glue to symbol-chars
 	// universal-char-names will glue as well as normal word-chars
-	if (lang.IsWordChar(lhs))
-		{
-		if ('\\'==rhs || lang.IsWordChar(rhs)) return true;
-		return false;
-		};
-	return !lang.IsWordChar(rhs);
+	const bool rhs_word_char = lang.IsWordChar(rhs);
+	if (lang.IsWordChar(lhs)) return '\\'==rhs || rhs_word_char;
+	return !rhs_word_char;
 }
 
 /*! 
@@ -4436,15 +4420,11 @@
 size_t
 CPreprocessor::function_macro_invocation_argspan(const char* const src,const size_t src_span,size_t& arg_count) const
 {
-	assert(!is_empty_string(src));
+	assert(src);
 	assert('('==src[0]);
 	assert(src_span==strlen(src));
 	if (2>src_span) return 0;
-	if (')'==src[1])
-		{
-		arg_count = 0;
-		return 2;
-		}
+	if (')'==src[1]) return arg_count = 0,2; 
 	lex_flags scratch_flags;
 	size_t test_arg_count = 1;
 	size_t paren_depth = 1;
@@ -4482,7 +4462,7 @@
 void
 CPreprocessor::stringize(autovalarray_ptr<char>& dest,const Token<char>* const & src)
 {
-	if (NULL==src || src->empty())
+	if (!src || src->empty())
 		{	// empty string
 		dest.resize(2);
 		strcpy(dest.c_array(),"\"\"");
@@ -4548,11 +4528,7 @@
 			INC_INFORM(ERR_STR);
 			INFORM("# terminates macro replacement list; truncating and continuing (C99 6.10.3.2p1/C++98 16.3.2p1)");
 			zcc_errors.inc_error();
-			if (1==pretokenized.size())
-				{
-				x.reset();
-				return true;
-				};
+			if (1==pretokenized.size()) return x.reset(),true;
 			pretokenized.DeleteIdx(pretokenized.size()-1);
 			};
 		remove_ws_from_token(x,pretokenized);

Modified: trunk/CPreproc.cpp.in
===================================================================
--- trunk/CPreproc.cpp.in	2010-10-30 18:36:38 UTC (rev 520)
+++ trunk/CPreproc.cpp.in	2010-10-30 20:27:02 UTC (rev 521)
@@ -3775,7 +3775,7 @@
 
 	// deal with empty-var ## operators
 	size_t j = actual_arguments.size();
-	do if (NULL==actual_arguments[--j])
+	do if (!actual_arguments[--j])
 			{	// have a genuinely empty argument
 			if (lang.line_lex_find(x.data(),x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
 				{
@@ -3789,7 +3789,7 @@
 							if (C_TESTFLAG_IDENTIFIER==pretokenized[k+1].third)
 								{
 								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k+1].first,pretokenized[k+1].second,formal_arguments);
-								if (0<=j2 && NULL==actual_arguments[j2])
+								if (0<=j2 && !actual_arguments[j2])
 									{	// we matched an empty parameter (concatenation identity)
 									const size_t replace_start = pretokenized[k-1].first+pretokenized[k-1].second;
 									size_t replace_len = (pretokenized[k+1].first-replace_start)+pretokenized[k+1].second;
@@ -3802,7 +3802,7 @@
 							if (C_TESTFLAG_IDENTIFIER==pretokenized[k-1].third)
 								{	// don't need should_continue bypass for last check
 								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k-1].first,pretokenized[k-1].second,formal_arguments);
-								if (0<=j2 && NULL==actual_arguments[j2])
+								if (0<=j2 && !actual_arguments[j2])
 									{
 									const size_t replace_start = (0<k) ? pretokenized[k-2].first+pretokenized[k-2].second : 0U;
 									size_t replace_len = (pretokenized[k].first-replace_start)+pretokenized[k].second;
@@ -3823,7 +3823,7 @@
 
 	// macro-replace all arguments
 	j = actual_arguments.size();
-	do	if (NULL!=actual_arguments[--j])
+	do	if (actual_arguments[--j])
 			intradirective_preprocess(*actual_arguments[j],0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack);
 	while(0<j);
 
@@ -3835,23 +3835,23 @@
 	j = pretokenized.size();
 	do	{
 		--j;
-		const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[j].first,pretokenized[j].second,formal_arguments);
+		errr j2 = linear_find_STL_deref2(x.data()+pretokenized[j].first,pretokenized[j].second,formal_arguments);
 		if (0<=j2)
 			{
-			assert(NULL!=actual_arguments[j2]);
+			assert(actual_arguments[j2]);
 			_macro_replace(x,pretokenized[j].first,pretokenized[j].second,actual_arguments[j2]->data());
 			lang.line_lex(x.data(),x.size(),pretokenized);
 			}
 		else if (detect_C_concatenation_op(x.data()+pretokenized[j].first,pretokenized[j].second))
 			{	// hmm...
-			const errr j3 = linear_find_STL_deref2(x.data()+pretokenized[j-1].first,pretokenized[j-1].second,formal_arguments);
-			if (0<=j3)
+			j2 = linear_find_STL_deref2(x.data()+pretokenized[j-1].first,pretokenized[j-1].second,formal_arguments);
+			if (0<=j2)
 				{	// oops....must do replacement *before* the ## concatenation
-				assert(NULL!=actual_arguments[j3]);
-				assert(!actual_arguments[j3]->empty());
+				assert(actual_arguments[j2]);
+				assert(!actual_arguments[j2]->empty());
 				autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized_alt;
-				lang.line_lex(actual_arguments[j3]->data(),actual_arguments[j3]->size(),pretokenized_alt);
-				_macro_replace(x,pretokenized[j-1].first,pretokenized[j-1].second,actual_arguments[j3]->data());
+				lang.line_lex(actual_arguments[j2]->data(),actual_arguments[j2]->size(),pretokenized_alt);
+				_macro_replace(x,pretokenized[j-1].first,pretokenized[j-1].second,actual_arguments[j2]->data());
 				lang.line_lex(x.data(),x.size(),pretokenized);
 				j += pretokenized_alt.size()-1;
 				assert(detect_C_concatenation_op(x.data()+pretokenized[j].first,pretokenized[j].second));
@@ -3992,8 +3992,7 @@
 
 void
 CPreprocessor::debug_to_stderr(const autovalarray_ptr<Token<char>* >& TokenList,const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<Token<char>*>& macros_object_expansion, const autovalarray_ptr<char*>& macros_function, const autovalarray_ptr<Token<char>*>& macros_function_arglist, const autovalarray_ptr<Token<char>*>& macros_function_expansion,const autovalarray_ptr<char*>& locked_macros) const
-{
-	// need whitespace tokens here to force pretty-printing
+{	// need whitespace tokens here to force pretty-printing
 	if (debug_mode)
 		{
 		const size_t list_size = TokenList.size();
@@ -4031,7 +4030,7 @@
 			{
 			INC_INFORM("#define ");
 			INC_INFORM(macros_object[i]);
-			if (NULL!=macros_object_expansion[i])
+			if (macros_object_expansion[i])
 				{
 				INC_INFORM(" ");
 				INFORM(macros_object_expansion[i]->data());
@@ -4047,7 +4046,7 @@
 			INC_INFORM("#define ");
 			INC_INFORM(macros_function[i]);
 			INC_INFORM(macros_function_arglist[i]->data());
-			if (NULL!=macros_function_expansion[i])
+			if (macros_function_expansion[i])
 				{
 				INC_INFORM(" ");
 				INFORM(macros_function_expansion[i]->data());
@@ -4078,15 +4077,12 @@
 CPreprocessor::C99_VA_ARGS_flinch(const Token<char>& x, const size_t critical_offset) const
 {	//! \todo option to bypass this
 	assert(x.size()>critical_offset);
-	if (SIZE_MAX!=lang.lex_find(x.data()+critical_offset,x.size()-critical_offset,"__VA_ARGS__",sizeof("__VA_ARGS__")-1))
-		{
-		message_header(x);
-		INC_INFORM(ERR_STR);
-		INFORM("identifier __VA_ARGS__ not allowed here.  Continuing. (C99 6.10.3p5/C++0x 16.3p5)");
-		zcc_errors.inc_error();
-		return true;
-		}
-	return false;
+	if (SIZE_MAX==lang.lex_find(x.data()+critical_offset,x.size()-critical_offset,"__VA_ARGS__",sizeof("__VA_ARGS__")-1)) return false;
+	message_header(x);
+	INC_INFORM(ERR_STR);
+	INFORM("identifier __VA_ARGS__ not allowed here.  Continuing. (C99 6.10.3p5/C++0x 16.3p5)");
+	zcc_errors.inc_error();
+	return true;
 }
 
 void
@@ -4122,11 +4118,7 @@
 		INC_INFORM(ERR_STR);
 		INFORM("concatenation operator ## ending a macro replacement list: removing and continuing (C99 6.10.3.3p1/C++98 16.3.3p1)");
 		zcc_errors.inc_error();
-		if (1==pretokenized.size())
-			{
-			x.reset();
-			return true;
-			}
+		if (1==pretokenized.size()) return x.reset(),true;
 		pretokenized.DeleteIdx(pretokenized.size()-1);
 		x.lslice(pretokenized.back().first+pretokenized.back().second);
 		}
@@ -4137,11 +4129,7 @@
 		INC_INFORM(ERR_STR);
 		INFORM("concatenation operator ## starting a macro replacement list: removing and continuing (C99 6.10.3.3p1/C++98 16.3.3p1)");
 		zcc_errors.inc_error();
-		if (1==pretokenized.size())
-			{
-			x.reset();
-			return true;
-			}
+		if (1==pretokenized.size()) return x.reset(),true;
 		x.ltrim(pretokenized[1].first);
 		// XXX leave data structures in an inconsistent state: they'll be immediately destructed anyway
 		}
@@ -4152,7 +4140,7 @@
 CPreprocessor::use_line_directive_and_discard(autovalarray_ptr<Token<char>* >& TokenList, const size_t i)
 {
 	assert(i<TokenList.size());
-	assert(NULL!=TokenList[i]);
+	assert(TokenList[i]);
 	assert(!strncmp(TokenList[i]->data(),"#line ",sizeof("#line ")-1));
 	if (TokenList[i]->flags & INVALID_DIRECTIVE_FLAG)
 		{
@@ -4163,8 +4151,7 @@
 	lex_flags first_token_flags;
 	lex_flags second_token_flags;
 	size_t critical_offset = sizeof("#line ")-1;
-	// C99: check for decimal integer literal, then optional string literal; error if this is not found
-	{
+	{	// C99: check for decimal integer literal, then optional string literal; error if this is not found
 	const size_t first_token_len = lang.UnfilteredNextToken(TokenList[i]->data()+critical_offset,first_token_flags);
 	if (     C_TESTFLAG_PP_NUMERAL!=first_token_flags
 		||	!C_PPDecimalInteger::is(TokenList[i]->data()+critical_offset,first_token_len,line_number)
@@ -4439,12 +4426,9 @@
 	// word-chars glue to word-chars
 	// symbol-chars glue to symbol-chars
 	// universal-char-names will glue as well as normal word-chars
-	if (lang.IsWordChar(lhs))
-		{
-		if ('\\'==rhs || lang.IsWordChar(rhs)) return true;
-		return false;
-		};
-	return !lang.IsWordChar(rhs);
+	const bool rhs_word_char = lang.IsWordChar(rhs);
+	if (lang.IsWordChar(lhs)) return '\\'==rhs || rhs_word_char;
+	return !rhs_word_char;
 }
 
 /*! 
@@ -4484,15 +4468,11 @@
 size_t
 CPreprocessor::function_macro_invocation_argspan(const char* const src,const size_t src_span,size_t& arg_count) const
 {
-	assert(!is_empty_string(src));
+	assert(src);
 	assert('('==src[0]);
 	assert(src_span==strlen(src));
 	if (2>src_span) return 0;
-	if (')'==src[1])
-		{
-		arg_count = 0;
-		return 2;
-		}
+	if (')'==src[1]) return arg_count = 0,2; 
 	lex_flags scratch_flags;
 	size_t test_arg_count = 1;
 	size_t paren_depth = 1;
@@ -4530,7 +4510,7 @@
 void
 CPreprocessor::stringize(autovalarray_ptr<char>& dest,const Token<char>* const & src)
 {
-	if (NULL==src || src->empty())
+	if (!src || src->empty())
 		{	// empty string
 		dest.resize(2);
 		strcpy(dest.c_array(),"\"\"");
@@ -4596,11 +4576,7 @@
 			INC_INFORM(ERR_STR);
 			INFORM("# terminates macro replacement list; truncating and continuing (C99 6.10.3.2p1/C++98 16.3.2p1)");
 			zcc_errors.inc_error();
-			if (1==pretokenized.size())
-				{
-				x.reset();
-				return true;
-				};
+			if (1==pretokenized.size()) return x.reset(),true;
 			pretokenized.DeleteIdx(pretokenized.size()-1);
 			};
 		remove_ws_from_token(x,pretokenized);

Modified: trunk/CPreproc_pp.cpp
===================================================================
--- trunk/CPreproc_pp.cpp	2010-10-30 18:36:38 UTC (rev 520)
+++ trunk/CPreproc_pp.cpp	2010-10-30 20:27:02 UTC (rev 521)
@@ -3694,7 +3694,7 @@
 
 	// deal with empty-var ## operators
 	size_t j = actual_arguments.size();
-	do if (NULL==actual_arguments[--j])
+	do if (!actual_arguments[--j])
 			{	// have a genuinely empty argument
 			if (lang.line_lex_find(x.data(),x.size(),"##",sizeof("##")-1,pretokenized) || lang.line_lex_find(x.data(),x.size(),"%:%:",sizeof("%:%:")-1,pretokenized))
 				{
@@ -3708,7 +3708,7 @@
 							if (C_TESTFLAG_IDENTIFIER==pretokenized[k+1].third)
 								{
 								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k+1].first,pretokenized[k+1].second,formal_arguments);
-								if (0<=j2 && NULL==actual_arguments[j2])
+								if (0<=j2 && !actual_arguments[j2])
 									{	// we matched an empty parameter (concatenation identity)
 									const size_t replace_start = pretokenized[k-1].first+pretokenized[k-1].second;
 									size_t replace_len = (pretokenized[k+1].first-replace_start)+pretokenized[k+1].second;
@@ -3721,7 +3721,7 @@
 							if (C_TESTFLAG_IDENTIFIER==pretokenized[k-1].third)
 								{	// don't need should_continue bypass for last check
 								const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[k-1].first,pretokenized[k-1].second,formal_arguments);
-								if (0<=j2 && NULL==actual_arguments[j2])
+								if (0<=j2 && !actual_arguments[j2])
 									{
 									const size_t replace_start = (0<k) ? pretokenized[k-2].first+pretokenized[k-2].second : 0U;
 									size_t replace_len = (pretokenized[k].first-replace_start)+pretokenized[k].second;
@@ -3742,7 +3742,7 @@
 
 	// macro-replace all arguments
 	j = actual_arguments.size();
-	do	if (NULL!=actual_arguments[--j])
+	do	if (actual_arguments[--j])
 			intradirective_preprocess(*actual_arguments[j],0,macros_object,macros_object_expansion,macros_function,macros_function_arglist,macros_function_expansion,used_macro_stack);
 	while(0<j);
 
@@ -3754,23 +3754,23 @@
 	j = pretokenized.size();
 	do	{
 		--j;
-		const errr j2 = linear_find_STL_deref2(x.data()+pretokenized[j].first,pretokenized[j].second,formal_arguments);
+		errr j2 = linear_find_STL_deref2(x.data()+pretokenized[j].first,pretokenized[j].second,formal_arguments);
 		if (0<=j2)
 			{
-			assert(NULL!=actual_arguments[j2]);
+			assert(actual_arguments[j2]);
 			_macro_replace(x,pretokenized[j].first,pretokenized[j].second,actual_arguments[j2]->data());
 			lang.line_lex(x.data(),x.size(),pretokenized);
 			}
 		else if (detect_C_concatenation_op(x.data()+pretokenized[j].first,pretokenized[j].second))
 			{	// hmm...
-			const errr j3 = linear_find_STL_deref2(x.data()+pretokenized[j-1].first,pretokenized[j-1].second,formal_arguments);
-			if (0<=j3)
+			j2 = linear_find_STL_deref2(x.data()+pretokenized[j-1].first,pretokenized[j-1].second,formal_arguments);
+			if (0<=j2)
 				{	// oops....must do replacement *before* the ## concatenation
-				assert(NULL!=actual_arguments[j3]);
-				assert(!actual_arguments[j3]->empty());
+				assert(actual_arguments[j2]);
+				assert(!actual_arguments[j2]->empty());
 				autovalarray_ptr<POD_triple<size_t,size_t,lex_flags> > pretokenized_alt;
-				lang.line_lex(actual_arguments[j3]->data(),actual_arguments[j3]->size(),pretokenized_alt);
-				_macro_replace(x,pretokenized[j-1].first,pretokenized[j-1].second,actual_arguments[j3]->data());
+				lang.line_lex(actual_arguments[j2]->data(),actual_arguments[j2]->size(),pretokenized_alt);
+				_macro_replace(x,pretokenized[j-1].first,pretokenized[j-1].second,actual_arguments[j2]->data());
 				lang.line_lex(x.data(),x.size(),pretokenized);
 				j += pretokenized_alt.size()-1;
 				assert(detect_C_concatenation_op(x.data()+pretokenized[j].first,pretokenized[j].second));
@@ -3911,8 +3911,7 @@
 
 void
 CPreprocessor::debug_to_stderr(const autovalarray_ptr<Token<char>* >& TokenList,const autovalarray_ptr<char*>& macros_object, const autovalarray_ptr<Token<char>*>& macros_object_expansion, const autovalarray_ptr<char*>& macros_function, const autovalarray_ptr<Token<char>*>& macros_function_arglist, const autovalarray_ptr<Token<char>*>& macros_function_expansion,const autovalarray_ptr<char*>& locked_macros) const
-{
-	// need whitespace tokens here to force pretty-printing
+{	// need whitespace tokens here to force pretty-printing
 	if (debug_mode)
 		{
 		const size_t list_size = TokenList.size();
@@ -3950,7 +3949,7 @@
 			{
 			INC_INFORM("#define ");
 			INC_INFORM(macros_object[i]);
-			if (NULL!=macros_object_expansion[i])
+			if (macros_object_expansion[i])
 				{
 				INC_INFORM(" ");
 				INFORM(macros_object_expansion[i]->data());
@@ -3966,7 +3965,7 @@
 			INC_INFORM("#define ");
 			INC_INFORM(macros_function[i]);
 			INC_INFORM(macros_function_arglist[i]->data());
-			if (NULL!=macros_function_expansion[i])
+			if (macros_function_expansion[i])
 				{
 				INC_INFORM(" ");
 				INFORM(macros_function_expansion[i]->data());
@@ -3997,15 +3996,12 @@
 CPreprocessor::C99_VA_ARGS_flinch(const Token<char>& x, const size_t critical_offset) const
 {	//! \todo option to bypass this
 	assert(x.size()>critical_offset);
-	if (SIZE_MAX!=lang.lex_find(x.data()+critical_offset,x.size()-critical_offset,"__VA_ARGS__",sizeof("__VA_ARGS__")-1))
-		{
-		message_header(x);
-		INC_INFORM(ERR_STR);
-		INFORM("identifier __VA_ARGS__ not allowed here.  Continuing. (C99 6.10.3p5/C++0x 16.3p5)");
-		zcc_errors.inc_error();
-		return true;
-		}
-	return false;
+	if (SIZE_MAX==lang.lex_find(x.data()+critical_offset,x.size()-critical_offset,"__VA_ARGS__",sizeof("__VA_ARGS__")-1)) return false;
+	message_header(x);
+	INC_INFORM(ERR_STR);
+	INFORM("identifier __VA_ARGS__ not allowed here.  Continuing. (C99 6.10.3p5/C++0x 16.3p5)");
+	zcc_errors.inc_error();
+	return true;
 }
 
 void
@@ -4041,11 +4037,7 @@
 		INC_INFORM(ERR_STR);
 		INFORM("concatenation operator ## ending a macro replacement list: removing and continuing (C99 6.10.3.3p1/C++98 16.3.3p1)");
 		zcc_errors.inc_error();
-		if (1==pretokenized.size())
-			{
-			x.reset();
-			return true;
-			}
+		if (1==pretokenized.size()) return x.reset(),true;
 		pretokenized.DeleteIdx(pretokenized.size()-1);
 		x.lslice(pretokenized.back().first+pretokenized.back().second);
 		}
@@ -4056,11 +4048,7 @@
 		INC_INFORM(ERR_STR);
 		INFORM("concatenation operator ## starting a macro replacement list: removing and continuing (C99 6.10.3.3p1/C++98 16.3.3p1)");
 		zcc_errors.inc_error();
-		if (1==pretokenized.size())
-			{
-			x.reset();
-			return true;
-			}
+		if (1==pretokenized.size()) return x.reset(),true;
 		x.ltrim(pretokenized[1].first);
 		// XXX leave data structures in an inconsistent state: they'll be immediately destructed anyway
 		}
@@ -4071,7 +4059,7 @@
 CPreprocessor::use_line_directive_and_discard(autovalarray_ptr<Token<char>* >& TokenList, const size_t i)
 {
 	assert(i<TokenList.size());
-	assert(NULL!=TokenList[i]);
+	assert(TokenList[i]);
 	assert(!strncmp(TokenList[i]->data(),"#line ",sizeof("#line ")-1));
 	if (TokenList[i]->flags & INVALID_DIRECTIVE_FLAG)
 		{
@@ -4082,8 +4070,7 @@
 	lex_flags first_token_flags;
 	lex_flags second_token_flags;
 	size_t critical_offset = sizeof("#line ")-1;
-	// C99: check for decimal integer literal, then optional string literal; error if this is not found
-	{
+	{	// C99: check for decimal integer literal, then optional string literal; error if this is not found
 	const size_t first_token_len = lang.UnfilteredNextToken(TokenList[i]->data()+critical_offset,first_token_flags);
 	if (     C_TESTFLAG_PP_NUMERAL!=first_token_flags
 		||	!C_PPDecimalInteger::is(TokenList[i]->data()+critical_offset,first_token_len,line_number)
@@ -4349,12 +4336,9 @@
 	// word-chars glue to word-chars
 	// symbol-chars glue to symbol-chars
 	// universal-char-names will glue as well as normal word-chars
-	if (lang.IsWordChar(lhs))
-		{
-		if ('\\'==rhs || lang.IsWordChar(rhs)) return true;
-		return false;
-		};
-	return !lang.IsWordChar(rhs);
+	const bool rhs_word_char = lang.IsWordChar(rhs);
+	if (lang.IsWordChar(lhs)) return '\\'==rhs || rhs_word_char;
+	return !rhs_word_char;
 }
 
 /*! 
@@ -4394,15 +4378,11 @@
 size_t
 CPreprocessor::function_macro_invocation_argspan(const char* const src,const size_t src_span,size_t& arg_count) const
 {
-	assert(!is_empty_string(src));
+	assert(src);
 	assert('('==src[0]);
 	assert(src_span==strlen(src));
 	if (2>src_span) return 0;
-	if (')'==src[1])
-		{
-		arg_count = 0;
-		return 2;
-		}
+	if (')'==src[1]) return arg_count = 0,2; 
 	lex_flags scratch_flags;
 	size_t test_arg_count = 1;
 	size_t paren_depth = 1;
@@ -4440,7 +4420,7 @@
 void
 CPreprocessor::stringize(autovalarray_ptr<char>& dest,const Token<char>* const & src)
 {
-	if (NULL==src || src->empty())
+	if (!src || src->empty())
 		{	// empty string
 		dest.resize(2);
 		strcpy(dest.c_array(),"\"\"");
@@ -4506,11 +4486,7 @@
 			INC_INFORM(ERR_STR);
 			INFORM("# terminates macro replacement list; truncating and continuing (C99 6.10.3.2p1/C++98 16.3.2p1)");
 			zcc_errors.inc_error();
-			if (1==pretokenized.size())
-				{
-				x.reset();
-				return true;
-				};
+			if (1==pretokenized.size()) return x.reset(),true;
 			pretokenized.DeleteIdx(pretokenized.size()-1);
 			};
 		remove_ws_from_token(x,pretokenized);



From zaimoni at mail.berlios.de  Sat Oct 30 22:31:44 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 30 Oct 2010 22:31:44 +0200
Subject: [Zcplusplus-commits] r522 - trunk
Message-ID: <20101030203144.8E8B0481039@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-30 22:31:44 +0200 (Sat, 30 Oct 2010)
New Revision: 522

Modified:
   trunk/CPreproc.cpp.in
   trunk/CSupport.cpp.in
   trunk/type_system.hpp.in
Log:
build system tweak

Modified: trunk/CPreproc.cpp.in
===================================================================
--- trunk/CPreproc.cpp.in	2010-10-30 20:27:02 UTC (rev 521)
+++ trunk/CPreproc.cpp.in	2010-10-30 20:31:44 UTC (rev 522)
@@ -1,4 +1,9 @@
+#/*cut-cpp*/
 // CPreproc.cpp
+#/*cut-cpp*/
+#/*cut-nocpp*/
+// CPreproc_pp.cpp
+#/*cut-nocpp*/
 // (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #/*cut-cpp*/

Modified: trunk/CSupport.cpp.in
===================================================================
--- trunk/CSupport.cpp.in	2010-10-30 20:27:02 UTC (rev 521)
+++ trunk/CSupport.cpp.in	2010-10-30 20:31:44 UTC (rev 522)
@@ -1,4 +1,9 @@
+#/*cut-cpp*/
 // CSupport.cpp
+#/*cut-cpp*/
+#/*cut-nocpp*/
+// CSupport_pp.cpp
+#/*cut-nocpp*/
 // support for C/C++ parsing
 // (C)2009, 2010 Kenneth Boyd, license: MIT.txt
 

Modified: trunk/type_system.hpp.in
===================================================================
--- trunk/type_system.hpp.in	2010-10-30 20:27:02 UTC (rev 521)
+++ trunk/type_system.hpp.in	2010-10-30 20:31:44 UTC (rev 522)
@@ -1,4 +1,9 @@
+#/*cut-cpp*/
 // type_system.hpp
+#/*cut-cpp*/
+#/*cut-nocpp*/
+// type_system_pp.hpp
+#/*cut-nocpp*/
 // (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #ifndef TYPE_SYSTEM_HPP



From zaimoni at mail.berlios.de  Sat Oct 30 22:45:04 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sat, 30 Oct 2010 22:45:04 +0200
Subject: [Zcplusplus-commits] r523 - trunk
Message-ID: <20101030204504.70899481039@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-30 22:45:04 +0200 (Sat, 30 Oct 2010)
New Revision: 523

Modified:
   trunk/type_system.cpp.in
Log:
build system tweak

Modified: trunk/type_system.cpp.in
===================================================================
--- trunk/type_system.cpp.in	2010-10-30 20:31:44 UTC (rev 522)
+++ trunk/type_system.cpp.in	2010-10-30 20:45:04 UTC (rev 523)
@@ -1,4 +1,9 @@
+#/*cut-cpp*/
 // type_system.cpp
+#/*cut-cpp*/
+#/*cut-nocpp*/
+// type_system_pp.cpp
+#/*cut-nocpp*/
 // (C)2009,2010 Kenneth Boyd, license: MIT.txt
 
 #/*cut-cpp*/



From zaimoni at mail.berlios.de  Sun Oct 31 04:03:35 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 31 Oct 2010 04:03:35 +0100
Subject: [Zcplusplus-commits] r524 - trunk
Message-ID: <20101031030335.BAC52480E7B@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-31 04:03:35 +0100 (Sun, 31 Oct 2010)
New Revision: 524

Modified:
   trunk/type_system.cpp
   trunk/type_system.cpp.in
   trunk/type_system.hpp
   trunk/type_system.hpp.in
Log:
adjust use-counting part of type_system

Modified: trunk/type_system.cpp
===================================================================
--- trunk/type_system.cpp	2010-10-30 20:45:04 UTC (rev 523)
+++ trunk/type_system.cpp	2010-10-31 03:03:35 UTC (rev 524)
@@ -259,6 +259,23 @@
 	return _get_id_enum_CPP(alias);
 }
 
+void type_system::use_type(type_index id)
+{
+	assert(core_types_size+dynamic_types.size()>=id);
+	if (core_types_size>=id) return;
+	if (SIZE_MAX==dynamic_types[id-=(core_types_size+1)].fourth) return;
+	++dynamic_types[id].fourth;
+}
+
+void type_system::unuse_type(type_index id)
+{
+	assert(core_types_size+dynamic_types.size()>=id);
+	if (core_types_size>=id) return;
+	if (SIZE_MAX==dynamic_types[id-=(core_types_size+1)].fourth) return;
+	assert(0<dynamic_types[id].fourth);
+	--dynamic_types[id].fourth;
+}
+
 const char* type_system::_name(size_t id) const
 {
 	if (0==id) return "(?)";

Modified: trunk/type_system.cpp.in
===================================================================
--- trunk/type_system.cpp.in	2010-10-30 20:45:04 UTC (rev 523)
+++ trunk/type_system.cpp.in	2010-10-31 03:03:35 UTC (rev 524)
@@ -269,6 +269,23 @@
 		}
 	return _get_id_enum_CPP(alias);
 }
+
+void type_system::use_type(type_index id)
+{
+	assert(core_types_size+dynamic_types.size()>=id);
+	if (core_types_size>=id) return;
+	if (SIZE_MAX==dynamic_types[id-=(core_types_size+1)].fourth) return;
+	++dynamic_types[id].fourth;
+}
+
+void type_system::unuse_type(type_index id)
+{
+	assert(core_types_size+dynamic_types.size()>=id);
+	if (core_types_size>=id) return;
+	if (SIZE_MAX==dynamic_types[id-=(core_types_size+1)].fourth) return;
+	assert(0<dynamic_types[id].fourth);
+	--dynamic_types[id].fourth;
+}
 #/*cut-cpp*/
 
 const char* type_system::_name(size_t id) const

Modified: trunk/type_system.hpp
===================================================================
--- trunk/type_system.hpp	2010-10-30 20:45:04 UTC (rev 523)
+++ trunk/type_system.hpp	2010-10-31 03:03:35 UTC (rev 524)
@@ -60,20 +60,14 @@
 		return _get_id_enum(x);
 		}
 	type_index get_id_enum_CPP(const char* alias,const char* active_namespace) const;
-	void use_type(type_index id)
+	void use_type(type_index id);
+	void unuse_type(type_index id);
+	size_t use_count(type_index id) const
 		{
 		assert(core_types_size+dynamic_types.size()>=id);
-		if (core_types_size>=id) return;
-		if (SIZE_MAX==dynamic_types[id-=core_types_size].fourth) return;
-		++dynamic_types[id].fourth;
-		};
-	void unuse_type(type_index id)
-		{
-		assert(core_types_size+dynamic_types.size()>=id);
-		if (core_types_size>=id) return;
-		if (SIZE_MAX==dynamic_types[id-=core_types_size].fourth) return;
-		--dynamic_types[id].fourth;
-		};
+		if (core_types_size>=id) return SIZE_MAX;
+		return dynamic_types[id-core_types_size].fourth;
+		}
 	const char* name(type_index id) const
 		{
 		assert(core_types_size+dynamic_types.size()>=id);

Modified: trunk/type_system.hpp.in
===================================================================
--- trunk/type_system.hpp.in	2010-10-30 20:45:04 UTC (rev 523)
+++ trunk/type_system.hpp.in	2010-10-31 03:03:35 UTC (rev 524)
@@ -75,20 +75,14 @@
 		return _get_id_enum(x);
 		}
 	type_index get_id_enum_CPP(const char* alias,const char* active_namespace) const;
-	void use_type(type_index id)
+	void use_type(type_index id);
+	void unuse_type(type_index id);
+	size_t use_count(type_index id) const
 		{
 		assert(core_types_size+dynamic_types.size()>=id);
-		if (core_types_size>=id) return;
-		if (SIZE_MAX==dynamic_types[id-=core_types_size].fourth) return;
-		++dynamic_types[id].fourth;
-		};
-	void unuse_type(type_index id)
-		{
-		assert(core_types_size+dynamic_types.size()>=id);
-		if (core_types_size>=id) return;
-		if (SIZE_MAX==dynamic_types[id-=core_types_size].fourth) return;
-		--dynamic_types[id].fourth;
-		};
+		if (core_types_size>=id) return SIZE_MAX;
+		return dynamic_types[id-core_types_size].fourth;
+		}
 #/*cut-cpp*/
 	const char* name(type_index id) const
 		{



From zaimoni at mail.berlios.de  Sun Oct 31 06:01:50 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 31 Oct 2010 06:01:50 +0100
Subject: [Zcplusplus-commits] r525 - trunk
Message-ID: <20101031050150.8233F48103B@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-31 06:01:49 +0100 (Sun, 31 Oct 2010)
New Revision: 525

Modified:
   trunk/CPreproc.cpp
   trunk/CPreproc.cpp.in
   trunk/CPreproc_pp.cpp
   trunk/POSIX.dep
Log:
make sure parse_tree::types is valid when preprocessing

Modified: trunk/CPreproc.cpp
===================================================================
--- trunk/CPreproc.cpp	2010-10-31 03:03:35 UTC (rev 524)
+++ trunk/CPreproc.cpp	2010-10-31 05:01:49 UTC (rev 525)
@@ -28,6 +28,7 @@
 #include "Zaimoni.STL/search.hpp"
 #include "Zaimoni.STL/OS/mutex.hpp"
 #include "Zaimoni.STL/Pure.C/format_util.h"
+#include "Zaimoni.STL/Perl_localize.hpp"
 
 #include "DebugCSupport.h"
 
@@ -685,7 +686,7 @@
 	autovalarray_ptr<Token<char>*> macros_function_expansion_pre_eval;
 	autovalarray_ptr<POD_triple<const char*, const char*,uintptr_t> > include_file_index;
 	autovalarray_ptr<POD_pair<const char*,autovalarray_ptr<Token<char>*>* > > include_file_cache;
-	const type_system min_types((Lang::C==lang_code) ? C_atomic_types : CPP_atomic_types,(Lang::C==lang_code) ? C_TYPE_MAX : CPP_TYPE_MAX,C_int_priority+C_PP_INT_PRIORITY_ORIGIN,C_INT_PRIORITY_SIZE-C_PP_INT_PRIORITY_ORIGIN);
+	type_system min_types((Lang::C==lang_code) ? C_atomic_types : CPP_atomic_types,(Lang::C==lang_code) ? C_TYPE_MAX : CPP_TYPE_MAX,C_int_priority+C_PP_INT_PRIORITY_ORIGIN,C_INT_PRIORITY_SIZE-C_PP_INT_PRIORITY_ORIGIN);
 
 	// this is subject to the Y10K bug, per standard.
 	// construct __DATE__, __TIME__ macro targets
@@ -713,6 +714,7 @@
 	while(iter!=iter_end) detailed_UNICODE_syntax(**iter++);
 	}
 
+	zaimoni::Perl::localize<type_system*> lock_types(parse_tree::types,&min_types);
 	_preprocess(TokenList, locked_macros, macros_object, macros_object_expansion, macros_object_expansion_pre_eval, macros_function, macros_function_arglist, macros_function_expansion, macros_function_expansion_pre_eval, include_file_index, include_file_cache, min_types);
 
 	// need whitespace tokens here to force pretty-printing

Modified: trunk/CPreproc.cpp.in
===================================================================
--- trunk/CPreproc.cpp.in	2010-10-31 03:03:35 UTC (rev 524)
+++ trunk/CPreproc.cpp.in	2010-10-31 05:01:49 UTC (rev 525)
@@ -48,6 +48,7 @@
 #include "Zaimoni.STL/search.hpp"
 #include "Zaimoni.STL/OS/mutex.hpp"
 #include "Zaimoni.STL/Pure.C/format_util.h"
+#include "Zaimoni.STL/Perl_localize.hpp"
 
 #include "DebugCSupport.h"
 
@@ -707,7 +708,7 @@
 	autovalarray_ptr<Token<char>*> macros_function_expansion_pre_eval;
 	autovalarray_ptr<POD_triple<const char*, const char*,uintptr_t> > include_file_index;
 	autovalarray_ptr<POD_pair<const char*,autovalarray_ptr<Token<char>*>* > > include_file_cache;
-	const type_system min_types((Lang::C==lang_code) ? C_atomic_types : CPP_atomic_types,(Lang::C==lang_code) ? C_TYPE_MAX : CPP_TYPE_MAX,C_int_priority+C_PP_INT_PRIORITY_ORIGIN,C_INT_PRIORITY_SIZE-C_PP_INT_PRIORITY_ORIGIN);
+	type_system min_types((Lang::C==lang_code) ? C_atomic_types : CPP_atomic_types,(Lang::C==lang_code) ? C_TYPE_MAX : CPP_TYPE_MAX,C_int_priority+C_PP_INT_PRIORITY_ORIGIN,C_INT_PRIORITY_SIZE-C_PP_INT_PRIORITY_ORIGIN);
 
 	// this is subject to the Y10K bug, per standard.
 	// construct __DATE__, __TIME__ macro targets
@@ -735,6 +736,7 @@
 	while(iter!=iter_end) detailed_UNICODE_syntax(**iter++);
 	}
 
+	zaimoni::Perl::localize<type_system*> lock_types(parse_tree::types,&min_types);
 	_preprocess(TokenList, locked_macros, macros_object, macros_object_expansion, macros_object_expansion_pre_eval, macros_function, macros_function_arglist, macros_function_expansion, macros_function_expansion_pre_eval, include_file_index, include_file_cache, min_types);
 #/*cut-cpp*/
 #/*cut-nocpp*/

Modified: trunk/CPreproc_pp.cpp
===================================================================
--- trunk/CPreproc_pp.cpp	2010-10-31 03:03:35 UTC (rev 524)
+++ trunk/CPreproc_pp.cpp	2010-10-31 05:01:49 UTC (rev 525)
@@ -27,6 +27,7 @@
 #include "Zaimoni.STL/search.hpp"
 #include "Zaimoni.STL/OS/mutex.hpp"
 #include "Zaimoni.STL/Pure.C/format_util.h"
+#include "Zaimoni.STL/Perl_localize.hpp"
 
 #include "DebugCSupport.h"
 
@@ -669,7 +670,7 @@
 	autovalarray_ptr<Token<char>*> macros_function_expansion_pre_eval;
 	autovalarray_ptr<POD_triple<const char*, const char*,uintptr_t> > include_file_index;
 	autovalarray_ptr<POD_pair<const char*,autovalarray_ptr<Token<char>*>* > > include_file_cache;
-	const type_system min_types((Lang::C==lang_code) ? C_atomic_types : CPP_atomic_types,(Lang::C==lang_code) ? C_TYPE_MAX : CPP_TYPE_MAX,C_int_priority+C_PP_INT_PRIORITY_ORIGIN,C_INT_PRIORITY_SIZE-C_PP_INT_PRIORITY_ORIGIN);
+	type_system min_types((Lang::C==lang_code) ? C_atomic_types : CPP_atomic_types,(Lang::C==lang_code) ? C_TYPE_MAX : CPP_TYPE_MAX,C_int_priority+C_PP_INT_PRIORITY_ORIGIN,C_INT_PRIORITY_SIZE-C_PP_INT_PRIORITY_ORIGIN);
 
 	// this is subject to the Y10K bug, per standard.
 	// construct __DATE__, __TIME__ macro targets
@@ -697,6 +698,7 @@
 	while(iter!=iter_end) detailed_UNICODE_syntax(**iter++);
 	}
 
+	zaimoni::Perl::localize<type_system*> lock_types(parse_tree::types,&min_types);
 	_preprocess(TokenList, locked_macros, macros_object, macros_object_expansion, macros_object_expansion_pre_eval, macros_function, macros_function_arglist, macros_function_expansion, macros_function_expansion_pre_eval, include_file_index, include_file_cache, min_types);
 
 	// need whitespace tokens here to force pretty-printing

Modified: trunk/POSIX.dep
===================================================================
--- trunk/POSIX.dep	2010-10-31 03:03:35 UTC (rev 524)
+++ trunk/POSIX.dep	2010-10-31 05:01:49 UTC (rev 525)
@@ -32,11 +32,11 @@
 end_lc.o: end_lc.hpp Zaimoni.STL/MetaRAM2.hpp errors.hpp errcount.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 end_nl.o: end_nl.hpp Zaimoni.STL/MetaRAM2.hpp errors.hpp errcount.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h
 load_src.o: Zaimoni.STL/cstdio Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp AtomicString.h errors.hpp errcount.hpp end_nl.hpp Zaimoni.STL/Logging.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/Pure.C/stdio_c.h Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/POD.hpp
-CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system_pp.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/lo
 gic_lt.hpp Zaimoni.STL/metatype/operator.hpp
+CPreproc_pp.o: CPreproc_pp.hpp AtomicString.h CSupport_pp.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system_pp.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/Perl_localize.hpp DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimon
 i.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 CPreproc_autogen_pp.o: CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 zcc.o: Zaimoni.STL/LexParse/Token.hpp _CSupport2.hpp CPreproc.hpp load_src.hpp AtomicString.h filesystem.h errors.hpp langroute.hpp CPUInfo.hpp errcount.hpp ParseTree.hpp ZParser.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/LexParse/std.h Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp weak_token.hpp Zaimoni.STL/Lexparse/std.h type_system.hpp Zaimoni.STL/Perl_localize.hpp
 type_system.o: type_system.hpp enum_type.hpp struct_type.hpp Zaimoni.STL/search.hpp Zaimoni.STL/Pure.C/auto_int.h AtomicString.h str_aux.h Zaimoni.STL/POD.hpp Zaimoni.STL/AutoPtr.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp
 CSupport.o: CSupport.hpp _CSupport3.hpp _CSupport4.hpp _CSupport1.hpp _CSupport2.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/lite_alg.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/simple_lock.hpp AtomicString.h str_aux.h Trigraph.hpp Flat_UNI.hpp end_lc.hpp end_nl.hpp errors.hpp errcount.hpp CPUInfo.hpp ParseTree.hpp type_system.hpp type_algebra.hpp weak_token.hpp C_PPDecimalInteger.hpp C_PPHexInteger.hpp C_PPOctalInteger.hpp C_PPDecimalFloat.hpp C_PPHexFloat.hpp enum_type.hpp struct_type.hpp kleene_star.hpp cond_act.hpp CheckReturn.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/bits/lite_alg.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/logic_l
 t.hpp Zaimoni.STL/metatype/operator.hpp unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp type_spec.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp
-CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp _CSupport3.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/
 operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
+CPreproc.o: CPreproc.hpp AtomicString.h CSupport.hpp _CSupport3.hpp C_PPDecimalInteger.hpp CPUInfo.hpp errors.hpp errcount.hpp filesystem.h langroute.hpp load_src.hpp ParseTree.hpp type_system.hpp weak_token.hpp _version.h Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/search.hpp Zaimoni.STL/OS/mutex.hpp Zaimoni.STL/Pure.C/format_util.h Zaimoni.STL/Perl_localize.hpp DebugCSupport.h Zaimoni.STL/LexParse/std.h type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/Logging.h Zaimoni.STL/pure.C/format_util.h C_PPNumCore.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/boost_core.hpp type_spec.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/algorithm Zaimoni.STL/logi
 c_lt.hpp Zaimoni.STL/metatype/operator.hpp Zaimoni.STL/LexParse/MetaToken.hpp
 CPreproc_autogen.o: CPreproc.hpp CPreproc_pp.hpp CPUInfo.hpp errors.hpp Zaimoni.STL/POD.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/pure.C/format_util.h Zaimoni.STL/LexParse/std.h unsigned_var_int.hpp unsigned_aux.hpp uchar_blob.hpp Zaimoni.STL/Logging.h Zaimoni.STL/Compiler.h Zaimoni.STL/flat_alg.h Zaimoni.STL/boost_core.hpp Zaimoni.STL/LexParse/MetaToken.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp
 ZParser.o: ZParser.hpp CSupport.hpp _CSupport3.hpp _CSupport4.hpp errors.hpp errcount.hpp langroute.hpp ParseTree.hpp type_system.hpp Zaimoni.STL/AutoPtr.hpp Zaimoni.STL/search.hpp Zaimoni.STL/LexParse/LangConf.hpp Zaimoni.STL/LexParse/Token.hpp Zaimoni.STL/Perl_localize.hpp Zaimoni.STL/POD.hpp type_spec.hpp Zaimoni.STL/boost_core.hpp Zaimoni.STL/MetaRAM2.hpp Zaimoni.STL/metatype/c_array.hpp Zaimoni.STL/bits/cstdio_autoptr.hpp Zaimoni.STL/MetaRAM.hpp Zaimoni.STL/z_memory.h Zaimoni.STL/Logging.h Zaimoni.STL/flat_alg.h Zaimoni.STL/polymorphic.hpp Zaimoni.STL/Compiler.h Zaimoni.STL/algorithm Zaimoni.STL/logic_lt.hpp Zaimoni.STL/metatype/operator.hpp uchar_blob.hpp type_algebra.hpp lex_core.h Zaimoni.STL/pure.C/auto_int.h Zaimoni.STL/LexParse/std.h weak_token.hpp Zaimoni.STL/Lexparse/std.h Zaimoni.STL/LexParse/MetaToken.hpp



From zaimoni at mail.berlios.de  Sun Oct 31 19:23:20 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 31 Oct 2010 19:23:20 +0100
Subject: [Zcplusplus-commits] r526 - in trunk: . lib
Message-ID: <20101031182321.3C092480BF9@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-31 19:23:20 +0100 (Sun, 31 Oct 2010)
New Revision: 526

Added:
   trunk/lib/zc++-0.0.6/
Removed:
   trunk/lib/zc++-0.0.5/
Modified:
   trunk/_version.h
Log:
version tweak

Modified: trunk/_version.h
===================================================================
--- trunk/_version.h	2010-10-31 05:01:49 UTC (rev 525)
+++ trunk/_version.h	2010-10-31 18:23:20 UTC (rev 526)
@@ -3,9 +3,9 @@
 /* (C)2010 Kenneth Boyd, license: MIT.txt */
 
 #ifndef ZCC_VERSION
-#define ZCC_VERSION "0.0.5"
+#define ZCC_VERSION "0.0.6"
 #define ZCC_VERSION_MAJOR 0
 #define ZCC_VERSION_MINOR 0
-#define ZCC_VERSION_PATCH 5
+#define ZCC_VERSION_PATCH 6
 #endif
 



From zaimoni at mail.berlios.de  Sun Oct 31 21:55:28 2010
From: zaimoni at mail.berlios.de (zaimoni at mail.berlios.de)
Date: Sun, 31 Oct 2010 21:55:28 +0100
Subject: [Zcplusplus-commits] r527 - trunk/Zaimoni.STL
Message-ID: <20101031205528.710C1480BF9@sheep.berlios.de>

Author: zaimoni
Date: 2010-10-31 21:55:28 +0100 (Sun, 31 Oct 2010)
New Revision: 527

Modified:
   trunk/Zaimoni.STL/POD.hpp
Log:
fix MingW32 4.2.1 build

Modified: trunk/Zaimoni.STL/POD.hpp
===================================================================
--- trunk/Zaimoni.STL/POD.hpp	2010-10-31 18:23:20 UTC (rev 526)
+++ trunk/Zaimoni.STL/POD.hpp	2010-10-31 20:55:28 UTC (rev 527)
@@ -200,6 +200,12 @@
 #undef ZAIMONI_CLASS_SPEC
 #undef ZAIMONI_TEMPLATE_SPEC
 
+#define ZAIMONI_TEMPLATE_SPEC template<typename _T1,typename _T2,typename _T3,typename _T4>
+#define ZAIMONI_CLASS_SPEC zaimoni::POD_quartet<_T1,_T2,_T3,_T4>
+ZAIMONI_POD_STRUCT(ZAIMONI_TEMPLATE_SPEC,ZAIMONI_CLASS_SPEC,_T1)
+#undef ZAIMONI_CLASS_SPEC
+#undef ZAIMONI_TEMPLATE_SPEC
+
 #define ZAIMONI_TEMPLATE_SPEC template<typename _T1,typename _T2>
 #define ZAIMONI_CLASS_SPEC zaimoni::union_pair<_T1,_T2>
 ZAIMONI_POD_STRUCT(ZAIMONI_TEMPLATE_SPEC,ZAIMONI_CLASS_SPEC,_T1)



