<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Zcplusplus-commits] r256 - in trunk: . tests/zcc	tests/zcc/staticassert.C1X tests/zcc.in
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/zcplusplus-commits/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r256%20-%20in%20trunk%3A%20.%20tests/zcc%0A%09tests/zcc/staticassert.C1X%20tests/zcc.in&In-Reply-To=%3C200909240303.n8O33EQk013760%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000022.html">
   <LINK REL="Next"  HREF="000024.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Zcplusplus-commits] r256 - in trunk: . tests/zcc	tests/zcc/staticassert.C1X tests/zcc.in</H1>
    <B>zaimoni at mail.berlios.de</B> 
    <A HREF="mailto:zcplusplus-commits%40lists.berlios.de?Subject=Re%3A%20%5BZcplusplus-commits%5D%20r256%20-%20in%20trunk%3A%20.%20tests/zcc%0A%09tests/zcc/staticassert.C1X%20tests/zcc.in&In-Reply-To=%3C200909240303.n8O33EQk013760%40sheep.berlios.de%3E"
       TITLE="[Zcplusplus-commits] r256 - in trunk: . tests/zcc	tests/zcc/staticassert.C1X tests/zcc.in">zaimoni at mail.berlios.de
       </A><BR>
    <I>Thu Sep 24 05:03:14 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="000022.html">[Zcplusplus-commits] r255 - in trunk: . Zaimoni.STL
</A></li>
        <LI>Next message: <A HREF="000024.html">[Zcplusplus-commits] r257 - in trunk: . Zaimoni.STL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23">[ date ]</a>
              <a href="thread.html#23">[ thread ]</a>
              <a href="subject.html#23">[ subject ]</a>
              <a href="author.html#23">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: zaimoni
Date: 2009-09-24 05:03:00 +0200 (Thu, 24 Sep 2009)
New Revision: 256

Added:
   trunk/tests/zcc/staticassert.C1X/Error_autofail.h
   trunk/tests/zcc/staticassert.C1X/Error_autofail.hpp
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
   trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
Modified:
   trunk/CSupport.cpp
   trunk/ZParser.cpp
   trunk/tests/zcc.in/run_tests.in
   trunk/tests/zcc/run_tests.bat
   trunk/tests/zcc/run_tests.sh
Log:
make trivial static assertions work

Modified: trunk/CSupport.cpp
===================================================================
--- trunk/CSupport.cpp	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/CSupport.cpp	2009-09-24 03:03:00 UTC (rev 256)
@@ -2872,13 +2872,13 @@
 	union_pair&lt;char*,my_UNICODE*&gt; buf;
 	if (str_target_wide)
 		{
-		buf.second = reinterpret_cast&lt;my_UNICODE*&gt;(calloc(buf_len,sizeof(my_UNICODE)));
+		buf.second = zaimoni::_new_buffer&lt;my_UNICODE&gt;(buf_len);
 		if (NULL==buf.second) return -5;
 		UnescapeCWideString(buf.second,str1,str1_len);
 		UnescapeCWideString(buf.second+str1_un_len,str2,str2_len);
 		//! \todo C vs C++
 		const size_t target_len = LengthOfEscapedCString(buf.second,buf_len);
-		target = reinterpret_cast&lt;char*&gt;(calloc(target_len,1));
+		target = zaimoni::_new_buffer&lt;char&gt;(target_len);
 		if (NULL==target)
 			{
 			free(buf.second);
@@ -2890,12 +2890,12 @@
 		return 1;
 		}
 	else{
-		buf.first = reinterpret_cast&lt;char*&gt;(calloc(buf_len,1));
+		buf.first = zaimoni::_new_buffer&lt;char&gt;(buf_len);
 		if (NULL==buf.first) return -5;
 		UnescapeCString(buf.first,str1,str1_len);
 		UnescapeCString(buf.first+str1_un_len,str2,str2_len);
 		const size_t target_len = LengthOfEscapedCString(buf.first,buf_len);
-		target = reinterpret_cast&lt;char*&gt;(calloc(target_len,1));		
+		target = zaimoni::_new_buffer&lt;char&gt;(target_len);
 		if (NULL==target)
 			{
 			free(buf.first);
@@ -8872,9 +8872,6 @@
 	if (!_match_pairs(src)) return false;
 	C99_locate_expressions(src,SIZE_MAX,types);
 	if (starting_errors&lt;zcc_errors.err_count()) return false;
-
-	// ...
-
 	while(src.is_raw_list() &amp;&amp; 1==src.size&lt;0&gt;()) src.eval_to_arg&lt;0&gt;(0);
 	return true;
 }
@@ -8891,9 +8888,6 @@
 	if (!_this_vaguely_where_it_could_be_cplusplus(src)) return false;
 	CPP_locate_expressions(src,SIZE_MAX,types);
 	if (starting_errors&lt;zcc_errors.err_count()) return false;
-
-	// ...
-
 	while(src.is_raw_list() &amp;&amp; 1==src.size&lt;0&gt;()) src.eval_to_arg&lt;0&gt;(0);
 	return true;
 }
@@ -8917,6 +8911,626 @@
 	CPP_notice_primary_type(src);
 }
 
+//! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
+bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
+{
+	assert(NULL!=x);
+	assert(0&lt;x_len);
+	assert(C_TESTFLAG_PP_NUMERAL &amp; flags);
+	assert(!(C_TESTFLAG_FLOAT &amp; flags));
+	C_REALITY_CHECK_PP_NUMERAL_FLAGS(flags);
+	//! \todo need some way to signal legality for integer literals
+	switch(C_EXTRACT_BASE_CODE(flags))
+	{
+#ifndef NDEBUG
+	default: FATAL_CODE(&quot;unclassified integer literal&quot;,3);
+#endif
+	case C_BASE_OCTAL:
+		{	// all-zeros is zero, ok with leading 0 prefix
+		C_PPOctalInteger test_oct;
+#ifdef NDEBUG
+		C_PPOctalInteger::is(x,x_len,test_oct);
+#else
+		assert(C_PPOctalInteger::is(x,x_len,test_oct));
+#endif
+		return strspn(test_oct.ptr,&quot;0&quot;) == test_oct.digit_span;
+		};
+	case C_BASE_DECIMAL:
+		{	// decimal is easy
+		C_PPDecimalInteger test_dec;
+#ifdef NDEBUG
+		C_PPDecimalInteger::is(x,x_len,test_dec);
+#else
+		assert(C_PPDecimalInteger::is(x,x_len,test_dec));
+#endif
+		return 1==test_dec.digit_span &amp;&amp; '0'==test_dec.ptr[0];
+		};
+	case C_BASE_HEXADECIMAL:
+		{	// all-zeros is zero, but ignore the leading 0x prefix
+		C_PPHexInteger test_hex;
+#ifdef NDEBUG
+		C_PPHexInteger::is(x,x_len,test_hex);
+#else
+		assert(C_PPHexInteger::is(x,x_len,test_hex));
+#endif
+		return strspn(test_hex.ptr+2,&quot;0&quot;)+2 == test_hex.digit_span;
+		};
+	}
+#ifdef NDEBUG
+	return false;
+#endif
+}
+
+static void eval_string_literal_deref(parse_tree&amp; src,const type_system&amp; types,const POD_pair&lt;const char*,size_t&gt;&amp; str_lit,const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; tmp,bool is_negative,bool index_src_is_char)
+{
+	const size_t strict_ub = LengthOfCStringLiteral(str_lit.first,str_lit.second);
+	// C99 6.2.6.2p3 -0 is not actually allowed to generate the bitpattern -0, so no trapping
+	if (is_negative &amp;&amp; tmp==0) is_negative = false;
+	if (is_negative)
+		{	//! \test default/Error_if_control66.hpp, default/Error_if_control66.h
+			//! \test default/Error_if_control67.hpp, default/Error_if_control67.h
+		if (!(src.flags &amp; parse_tree::INVALID))
+			{
+			message_header(src.index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INC_INFORM(&quot;undefined behavior: &quot;);
+			INC_INFORM(src);
+			INFORM(&quot; dereferences string literal with negative index&quot;);
+			if (index_src_is_char)
+				INFORM(&quot;(does this source code want char to act like unsigned char?)&quot;);
+			src.flags |= parse_tree::INVALID;
+			zcc_errors.inc_error();
+			}
+		return;
+		}
+	else if (strict_ub &lt;= tmp)
+		{	//! \test default/Error_if_control68.hpp, default/Error_if_control68.h
+			//! \test default/Error_if_control69.hpp, default/Error_if_control69.h
+		if (!(src.flags &amp; parse_tree::INVALID))
+			{
+			message_header(src.index_tokens[0]);
+			INC_INFORM(ERR_STR);
+			INC_INFORM(&quot;undefined behavior: &quot;);
+			INC_INFORM(src);
+			INFORM(&quot; dereferences string literal past its end&quot;);
+			if (index_src_is_char &amp;&amp; target_machine-&gt;signed_max&lt;virtual_machine::std_int_char&gt;()&lt;tmp)
+				{
+				if (tmp.to_uint()-1==target_machine-&gt;signed_max&lt;virtual_machine::std_int_char&gt;())
+					{
+					INFORM(&quot;(does this source code want char to act like signed char, with integer representation sign-and-magnitude?)&quot;);
+					}
+				else if (tmp==target_machine-&gt;unsigned_max&lt;virtual_machine::std_int_char&gt;())
+					{
+					INFORM(&quot;(does this source code want char to act like signed char, with integer representation one's complement?)&quot;);
+					}
+				}
+			src.flags |= parse_tree::INVALID;
+			zcc_errors.inc_error();
+			}
+		return;
+		};
+	char* tmp2 = NULL;
+	assert(tmp.representable_as_uint());
+	GetCCharacterLiteralAt(str_lit.first,str_lit.second,tmp.to_uint(),tmp2);
+	assert(NULL!=tmp2);
+	src.destroy();	// str_lit goes invalid here, don't use again
+	src.grab_index_token_from&lt;0&gt;(tmp2,C_TESTFLAG_CHAR_LITERAL);
+	_label_one_literal(src,types);
+}
+
+static bool
+eval_array_deref(parse_tree&amp; src,const type_system&amp; types,
+				 func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+				 func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type literal_converts_to_integer,
+				 func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+{
+	if (!is_array_deref(src)) return false;
+	// crunch __[...]
+	// canonical definition: *((__)+(...))
+	EvalParseTree(*src.c_array&lt;0&gt;(),types);
+	EvalParseTree(*src.c_array&lt;1&gt;(),types);
+	if (parse_tree::CONSTANT_EXPRESSION &amp; src.flags)
+		{
+		const unsigned int str_index = 	(C_TESTFLAG_STRING_LITERAL==src.data&lt;0&gt;()-&gt;index_tokens[0].flags) ? 0 :
+										(C_TESTFLAG_STRING_LITERAL==src.data&lt;1&gt;()-&gt;index_tokens[0].flags) ? 1 : UINT_MAX;
+		if (UINT_MAX&gt;str_index)
+			{
+			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; tmp; 
+			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index))) return false;
+			const size_t promoted_type = default_promote_type(src.type_code.base_type_index);
+			const virtual_machine::std_int_enum machine_type = (virtual_machine::std_int_enum)((promoted_type-C_TYPE::INT)/2+virtual_machine::std_int_int);
+			eval_string_literal_deref(src,types,src.data(str_index)-&gt;index_tokens[0].token,tmp,tmp.test(target_machine-&gt;C_bit(machine_type)-1),C_TESTFLAG_CHAR_LITERAL==src.data(1-str_index)-&gt;index_tokens[0].flags);
+			return true;
+			}
+		}
+	return false;
+}
+
+static bool eval_deref(	parse_tree&amp; src, const type_system&amp; types,
+						func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree)
+{
+	//! \todo handle operator overloading (fork to handle C/C++?)
+	//! \todo catch *&amp; cancellation
+	if (is_C99_unary_operator_expression&lt;'*'&gt;(src))
+		{
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (C_TESTFLAG_STRING_LITERAL==src.data&lt;2&gt;()-&gt;index_tokens[0].flags)
+			{
+			//! \test default/Pass_if_zero.hpp
+			//! \test default/Pass_if_zero.h
+			//! \test default/Pass_if_nonzero.hpp
+			//! \test default/Pass_if_nonzero.h
+			eval_string_literal_deref(src,types,src.data&lt;2&gt;()-&gt;index_tokens[0].token,unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;(0),false,false);
+			return true;
+			}
+		}
+	return false;
+}
+
+static bool eval_logical_NOT(parse_tree&amp; src, const type_system&amp; types,
+							 func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+							 func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_logical_NOT_expression,
+							 func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool)
+{
+	if (is_logical_NOT_expression(src))
+		{
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_logical_NOT(src,types,is_logical_NOT_expression,literal_converts_to_bool)) return true;
+		}
+	return false;
+}
+
+static bool eval_bitwise_compl(	parse_tree&amp; src, const type_system&amp; types,
+								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+								func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_complement_expression,
+								func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+{
+	if (is_bitwise_complement_expression(src))
+		{
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_bitwise_compl(src,types,true,is_bitwise_complement_expression,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_unary_plus(parse_tree&amp; src, const type_system&amp; types,
+							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree)
+{
+	if (is_C99_unary_operator_expression&lt;'+'&gt;(src))
+		{
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_unary_plus(src,types)) return true;
+		}
+	return false;
+}
+
+static bool eval_unary_minus(parse_tree&amp; src, const type_system&amp; types,
+							 func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+							 func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+							 func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_unary_operator_expression&lt;'-'&gt;(src))
+		{
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_unary_minus(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_mult_expression(parse_tree&amp; src,const type_system&amp; types,
+								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+								func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+								func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_mult_operator_expression&lt;'*'&gt;(src))
+		{
+		EvalParseTree(*src.c_array&lt;1&gt;(),types);
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_mult_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_div_expression(parse_tree&amp; src,const type_system&amp; types,
+								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+								func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+								func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_mult_operator_expression&lt;'/'&gt;(src))
+		{
+		EvalParseTree(*src.c_array&lt;1&gt;(),types);
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_div_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_mod_expression(parse_tree&amp; src,const type_system&amp; types,
+								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+								func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+								func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_mult_operator_expression&lt;'%'&gt;(src))
+		{
+		EvalParseTree(*src.c_array&lt;1&gt;(),types);
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_mod_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_add_expression(parse_tree&amp; src,const type_system&amp; types,
+							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_add_operator_expression&lt;'+'&gt;(src))
+		{
+		EvalParseTree(*src.c_array&lt;1&gt;(),types);
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_add_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_sub_expression(parse_tree&amp; src,const type_system&amp; types,
+							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_add_operator_expression&lt;'-'&gt;(src))
+		{
+		EvalParseTree(*src.c_array&lt;1&gt;(),types);
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_sub_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_shift(parse_tree&amp; src,const type_system&amp; types,
+							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_shift_expression(src))
+		{
+		EvalParseTree(*src.c_array&lt;1&gt;(),types);
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_shift(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_relation_expression(parse_tree&amp; src,const type_system&amp; types,
+							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+{
+	if (is_C99_relation_expression(src))
+		{
+		EvalParseTree(*src.c_array&lt;1&gt;(),types);
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_relation_expression(src,types,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_equality_expression(parse_tree&amp; src,const type_system&amp; types,
+							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_equality_expression,
+							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+{
+	if (is_equality_expression(src))
+		{
+		EvalParseTree(*src.c_array&lt;1&gt;(),types);
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_equality_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_bitwise_AND(parse_tree&amp; src,const type_system&amp; types,
+							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_AND_expression,
+							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+{
+	if (is_bitwise_AND_expression(src))
+		{
+		EvalParseTree(*src.c_array&lt;1&gt;(),types);
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_bitwise_AND(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_bitwise_XOR(parse_tree&amp; src,const type_system&amp; types,
+							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_XOR_expression,
+							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+{
+	if (is_bitwise_XOR_expression(src))
+		{
+		EvalParseTree(*src.c_array&lt;1&gt;(),types);
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_bitwise_XOR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_bitwise_OR(parse_tree&amp; src,const type_system&amp; types,
+							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_OR_expression,
+							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
+							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
+{
+	if (is_bitwise_OR_expression(src))
+		{
+		EvalParseTree(*src.c_array&lt;1&gt;(),types);
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_bitwise_OR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
+		}
+	return false;
+}
+
+static bool eval_logical_AND(parse_tree&amp; src,const type_system&amp; types,
+							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_logical_AND_expression,
+							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool)
+{
+	if (is_logical_AND_expression(src))
+		{
+		EvalParseTree(*src.c_array&lt;1&gt;(),types);
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_logical_AND(src,types,literal_converts_to_bool)) return true;
+		}
+	return false;
+}
+
+static bool eval_logical_OR(parse_tree&amp; src,const type_system&amp; types,
+							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_logical_OR_expression,
+							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool)
+{
+	if (is_logical_OR_expression(src))
+		{
+		EvalParseTree(*src.c_array&lt;1&gt;(),types);
+		EvalParseTree(*src.c_array&lt;2&gt;(),types);
+		if (eval_logical_OR(src,types,literal_converts_to_bool)) return true;
+		}
+	return false;
+}
+
+static bool eval_conditional_operator(parse_tree&amp; src,const type_system&amp; types,
+									  func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
+									  func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool)
+{
+	if (is_C99_conditional_operator_expression(src))
+		{	// prefix operator is boolean
+		EvalParseTree(*src.c_array&lt;1&gt;(),types);
+		if (eval_conditional_op(src,literal_converts_to_bool)) return true;
+		}
+	return false;
+}
+
+#if 0
+static bool cancel_addressof_deref_operators(parse_tree&amp; src)
+{
+	assert(is_C99_unary_operator_expression(src));
+	if ('&amp;'==*src.index_tokens[0].token.first)
+		{	// strip off &amp;*, and remove lvalue-ness of target
+		if (is_C99_unary_operator_expression&lt;'*'&gt;(*src.data&lt;2&gt;()) &amp;&amp; 0&lt;src.data&lt;2&gt;()-&gt;data&lt;2&gt;()-&gt;type_code.pointer_power_after_array_decay())
+			{
+			parse_tree tmp = *src.data&lt;2&gt;()-&gt;data&lt;2&gt;();
+			tmp.type_code.traits &amp;= ~type_spec::lvalue;
+			src.c_array&lt;2&gt;()-&gt;c_array&lt;2&gt;()-&gt;clear();
+			src.destroy();
+			src = tmp;
+			return true;
+			}
+#if 0
+		if (is_array_deref(*src.data&lt;2&gt;()))
+			{	//! \todo convert &amp;(___[...]) to (__+...)
+			}
+#endif
+		};
+	return false;
+}
+#endif
+
+static bool C99_EvalParseTree(parse_tree&amp; src,const type_system&amp; types)
+{
+	const size_t starting_errors = zcc_errors.err_count();
+RestartEval:
+	if (src.is_atomic() || (parse_tree::INVALID &amp; src.flags)) return starting_errors==zcc_errors.err_count();
+	if (eval_array_deref(src,types,C99_EvalParseTree,C99_literal_converts_to_integer,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_conditional_operator(src,types,C99_EvalParseTree,C99_literal_converts_to_bool)) goto RestartEval;
+	if (eval_logical_OR(src,types,C99_EvalParseTree,is_C99_logical_OR_expression,C99_literal_converts_to_bool)) goto RestartEval;
+	if (eval_logical_AND(src,types,C99_EvalParseTree,is_C99_logical_AND_expression,C99_literal_converts_to_bool)) goto RestartEval;
+	if (eval_deref(src,types,C99_EvalParseTree)) goto RestartEval; 
+	if (eval_logical_NOT(src,types,C99_EvalParseTree,is_C99_unary_operator_expression&lt;'!'&gt;,C99_literal_converts_to_bool)) goto RestartEval;
+	if (eval_unary_plus(src,types,C99_EvalParseTree)) goto RestartEval;
+	if (eval_unary_minus(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_mult_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_div_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_mod_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_add_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_sub_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_shift(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_relation_expression(src,types,C99_EvalParseTree,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_equality_expression(src,types,C99_EvalParseTree,is_C99_equality_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_AND(src,types,C99_EvalParseTree,is_C99_bitwise_AND_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_XOR(src,types,C99_EvalParseTree,is_C99_bitwise_XOR_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_OR(src,types,C99_EvalParseTree,is_C99_bitwise_OR_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_compl(src,types,C99_EvalParseTree,is_C99_unary_operator_expression&lt;'~'&gt;,C99_intlike_literal_to_VM)) goto RestartEval;
+	return starting_errors==zcc_errors.err_count();
+}
+
+static bool CPP_EvalParseTree(parse_tree&amp; src,const type_system&amp; types)
+{
+	const size_t starting_errors = zcc_errors.err_count();
+RestartEval:
+	if (src.is_atomic() || (parse_tree::INVALID &amp; src.flags)) return starting_errors==zcc_errors.err_count();
+	if (eval_array_deref(src,types,CPP_EvalParseTree,CPP_literal_converts_to_integer,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_conditional_operator(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool)) goto RestartEval;
+	if (eval_logical_OR(src,types,CPP_EvalParseTree,is_CPP_logical_OR_expression,CPP_literal_converts_to_bool)) goto RestartEval;
+	if (eval_logical_AND(src,types,CPP_EvalParseTree,is_CPP_logical_AND_expression,CPP_literal_converts_to_bool)) goto RestartEval;
+	if (eval_deref(src,types,CPP_EvalParseTree)) goto RestartEval; 
+	if (eval_logical_NOT(src,types,CPP_EvalParseTree,is_CPP_logical_NOT_expression,CPP_literal_converts_to_bool)) goto RestartEval;
+	if (eval_unary_plus(src,types,CPP_EvalParseTree)) goto RestartEval;
+	if (eval_unary_minus(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_mult_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_div_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_mod_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_add_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_sub_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_shift(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_relation_expression(src,types,CPP_EvalParseTree,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_equality_expression(src,types,CPP_EvalParseTree,is_CPP_equality_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_AND(src,types,CPP_EvalParseTree,is_CPP_bitwise_AND_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_XOR(src,types,CPP_EvalParseTree,is_CPP_bitwise_XOR_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_OR(src,types,CPP_EvalParseTree,is_CPP_bitwise_OR_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
+	if (eval_bitwise_compl(src,types,CPP_EvalParseTree,is_CPP_bitwise_complement_expression,CPP_intlike_literal_to_VM)) goto RestartEval;
+	return starting_errors==zcc_errors.err_count();
+}
+
+void C99_PPHackTree(parse_tree&amp; src,const type_system&amp; types)
+{
+	if (parse_tree::INVALID &amp; src.flags) return;
+	if (	is_C99_unary_operator_expression&lt;'-'&gt;(src)
+		&amp;&amp;	(PARSE_PRIMARY_EXPRESSION &amp; src.data&lt;2&gt;()-&gt;flags))
+		{	// compact - literal to literal to get past preprocessor
+		src.eval_to_arg&lt;2&gt;(0);
+		return;
+		};
+	const type_spec old_type = src.type_code;
+	const bool non_representable_int_min = virtual_machine::twos_complement==target_machine-&gt;C_signed_int_representation() &amp;&amp; !bool_options[boolopt::int_traps];
+	//! \todo handle other instances of non-representable int min constant expressions
+	if (is_C99_add_operator_expression&lt;'-'&gt;(src))
+		{
+		bool is_equal = false;
+		if (C_string_literal_equal_content(*src.data&lt;1&gt;(),*src.data&lt;2&gt;(),is_equal))
+			{
+			assert(!is_equal);	// should have intercepted equal-literal reduction earlier
+#ifndef NDEBUG
+			force_decimal_literal(src,&quot;1&quot;,types);
+#else
+			force_decimal_literal(src,is_equal ? &quot;0&quot; : &quot;1&quot;,types);
+#endif
+			src.type_code.set_type(C_TYPE::INT);
+			return;
+			};
+		if (non_representable_int_min)
+			{
+			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int;
+			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data&lt;1&gt;());
+			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;());
+			if (lhs_converted &amp;&amp; rhs_converted)
+				{	//! \todo deal with signed integer arithmetic
+				const promote_aux old(old_type.base_type_index);
+				assert(old.is_signed);
+				const promote_aux lhs(src.data&lt;1&gt;()-&gt;type_code.base_type_index);
+				assert(old.bitcount&gt;=lhs.bitcount);
+				const promote_aux rhs(src.data&lt;2&gt;()-&gt;type_code.base_type_index);
+				assert(old.bitcount&gt;=rhs.bitcount);
+
+				// handle sign-extension of lhs, rhs
+#ifndef NDEBUG
+				const bool lhs_negative = target_machine-&gt;C_promote_integer(res_int,lhs,old);
+				const bool rhs_negative = target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
+#else
+				target_machine-&gt;C_promote_integer(res_int,lhs,old);
+				target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
+#endif
+				assert(lhs_negative &amp;&amp; !rhs_negative);
+				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_test(res_int);
+				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_test(rhs_int);
+				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; ub(target_machine-&gt;signed_max(old.machine_type));
+				target_machine-&gt;signed_additive_inverse(lhs_test,old.machine_type);
+				ub += 1;
+				assert(ub&gt;=lhs_test &amp;&amp; ub&gt;=rhs_test);
+				ub -= lhs_test;
+				assert(ub&gt;=rhs_test);
+				lhs_test += rhs_test;
+				assert(target_machine-&gt;signed_max(old.machine_type)&lt;lhs_test);
+				// ok...valid but won't reduce.  pick an argument and mock this up
+				src.eval_to_arg&lt;2&gt;(0);
+				return;
+				}
+			}
+		}
+}
+
+void CPP_PPHackTree(parse_tree&amp; src,const type_system&amp; types)
+{
+	if (parse_tree::INVALID &amp; src.flags) return;
+	if (	is_C99_unary_operator_expression&lt;'-'&gt;(src)
+		&amp;&amp;	(PARSE_PRIMARY_EXPRESSION &amp; src.data&lt;2&gt;()-&gt;flags))
+		{	// compact - literal to literal to get past preprocessor
+		src.eval_to_arg&lt;2&gt;(0);
+		return;
+		};
+	const type_spec old_type = src.type_code;
+	const bool non_representable_int_min = virtual_machine::twos_complement==target_machine-&gt;C_signed_int_representation() &amp;&amp; !bool_options[boolopt::int_traps];
+	//! \todo handle other instances of non-representable int min constant expressions
+	if (is_C99_add_operator_expression&lt;'-'&gt;(src))
+		{
+		bool is_equal = false;
+		if (C_string_literal_equal_content(*src.data&lt;1&gt;(),*src.data&lt;2&gt;(),is_equal))
+			{
+			assert(!is_equal);	// should have intercepted equal-literal reduction earlier
+#ifndef NDEBUG
+			force_decimal_literal(src,&quot;1&quot;,types);
+#else
+			force_decimal_literal(src,is_equal ? &quot;0&quot; : &quot;1&quot;,types);
+#endif
+			src.type_code.set_type(C_TYPE::INT);
+			return;
+			};
+		if (non_representable_int_min)
+			{
+			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int;
+			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
+			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data&lt;1&gt;());
+			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;());
+			if (lhs_converted &amp;&amp; rhs_converted)
+				{	//! \todo deal with signed integer arithmetic
+				const promote_aux old(old_type.base_type_index);
+				assert(old.is_signed);
+				const promote_aux lhs(src.data&lt;1&gt;()-&gt;type_code.base_type_index);
+				assert(old.bitcount&gt;=lhs.bitcount);
+				const promote_aux rhs(src.data&lt;2&gt;()-&gt;type_code.base_type_index);
+				assert(old.bitcount&gt;=rhs.bitcount);
+
+				// handle sign-extension of lhs, rhs
+#ifndef NDEBUG
+				const bool lhs_negative = target_machine-&gt;C_promote_integer(res_int,lhs,old);
+				const bool rhs_negative = target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
+#else
+				target_machine-&gt;C_promote_integer(res_int,lhs,old);
+				target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
+#endif
+				assert(lhs_negative &amp;&amp; !rhs_negative);
+				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_test(res_int);
+				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_test(rhs_int);
+				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; ub(target_machine-&gt;signed_max(old.machine_type));
+				target_machine-&gt;signed_additive_inverse(lhs_test,old.machine_type);
+				ub += 1;
+				assert(ub&gt;=lhs_test &amp;&amp; ub&gt;=rhs_test);
+				ub -= lhs_test;
+				assert(ub&gt;=rhs_test);
+				lhs_test += rhs_test;
+				assert(target_machine-&gt;signed_max(old.machine_type)&lt;lhs_test);
+				// ok...valid but won't reduce.  pick an argument and mock this up
+				src.eval_to_arg&lt;2&gt;(0);
+				return;
+				}
+			}
+		}
+}
+
 static void conserve_tokens(parse_tree&amp; x)
 {
 	if (x.own_index_token&lt;0&gt;())
@@ -9463,7 +10077,92 @@
 				src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
 				continue;
 				};
-			//! \todo actually use the static assertion correctly.
+			// actually use the static assertion correctly.
+			parse_tree_class parsetree;
+			{
+			const size_t k = src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-2;
+			if (!parsetree.resize&lt;0&gt;(k))
+				{
+				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				_fatal(&quot;insufficient RAM to parse static assertion&quot;);
+				};
+			zaimoni::autotransform_n(parsetree.c_array&lt;0&gt;(),src.data&lt;0&gt;()[i+1].data&lt;0&gt;(),k,value_copy);
+			}
+			// init above correctly
+			// snip from Condense
+			const size_t starting_errors = zcc_errors.err_count();
+			C99_locate_expressions(parsetree,SIZE_MAX,types);
+			if (starting_errors==zcc_errors.err_count())
+				{
+				while(parsetree.is_raw_list() &amp;&amp; 1==parsetree.size&lt;0&gt;()) parsetree.eval_to_arg&lt;0&gt;(0);
+				// end snip from Condense
+				// snip from CPreproc
+				if (!parsetree.is_atomic() &amp;&amp; !C99_EvalParseTree(parsetree,types))
+					{
+					parsetree.destroy();	// efficiency
+					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM(&quot; : control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)&quot;);
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
+					continue;
+					}
+				C99_PPHackTree(parsetree,types);
+				// final, when above is working properly
+				if (!parsetree.is_atomic())
+					{
+					parsetree.destroy();	// efficiency
+					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM(&quot; : control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)&quot;);
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
+					continue;
+					}
+				// end snip from CPreproc
+				bool is_true = false;
+				if (!C99_literal_converts_to_bool(parsetree,is_true))
+					{
+					parsetree.destroy();	// efficiency
+					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM(&quot; : control expression for static assertion must evaluate to a single integer constant (C1X 6.7.9p3)&quot;);
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
+					continue;
+					};
+				parsetree.destroy();	// efficiency
+				if (!is_true)
+					{	// oops
+					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					// hmm...really should unescape string before emitting
+					const size_t tmp_size = LengthOfCStringLiteral(src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].token.first,src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].token.second);
+					if (1U&gt;=tmp_size || 'L'== *src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].token.first)
+						{	//! \todo handle wide-strings later
+						INFORM(&quot;(static assertion failure)&quot;);
+						zcc_errors.inc_error();
+						src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
+						continue;
+						};
+					
+					char* tmp = _new_buffer&lt;char&gt;(tmp_size);
+					if (NULL==tmp)
+						{
+						INFORM(&quot;(static assertion failure)&quot;);
+						zcc_errors.inc_error();
+						src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
+						continue;
+						}
+					UnescapeCString(tmp,src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].token.first+1,src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].token.second-2);
+					INFORM(tmp);
+					free(tmp);
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
+					continue;
+					};
+				}
 			src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
 			continue;
 			};
@@ -9748,7 +10447,90 @@
 				src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
 				continue;
 				};
-			//! \todo actually use the static assertion correctly.
+			// actually use the static assertion correctly.
+			parse_tree_class parsetree;
+			{	// work on a copy of the argument list
+			const size_t k = src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-2;
+			if (!parsetree.resize&lt;0&gt;(k))
+				{
+				message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+				INC_INFORM(ERR_STR);
+				_fatal(&quot;insufficient RAM to parse static assertion&quot;);
+				};
+			zaimoni::autotransform_n(parsetree.c_array&lt;0&gt;(),src.data&lt;0&gt;()[i+1].data&lt;0&gt;(),k,value_copy);
+			}
+			// snip from Condense
+			const size_t starting_errors = zcc_errors.err_count();
+			CPP_locate_expressions(parsetree,SIZE_MAX,types);
+			if (starting_errors==zcc_errors.err_count())
+				{
+				while(parsetree.is_raw_list() &amp;&amp; 1==parsetree.size&lt;0&gt;()) parsetree.eval_to_arg&lt;0&gt;(0);
+				// end snip from Condense
+				// snip from CPreproc
+				if (!parsetree.is_atomic() &amp;&amp; !CPP_EvalParseTree(parsetree,types))
+					{
+					parsetree.destroy();	// efficiency
+					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM(&quot; : control expression for static assertion must be a constant convertible to bool (C++0X 7p4)&quot;);
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
+					continue;
+					}
+				CPP_PPHackTree(parsetree,types);
+				if (!parsetree.is_atomic())
+					{
+					parsetree.destroy();	// efficiency
+					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM(&quot; : control expression for static assertion must be a constant convertible to bool (C++0X 7p4)&quot;);
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
+					continue;
+					}
+				// end snip from CPreproc
+				bool is_true = false;
+				if (!CPP_literal_converts_to_bool(parsetree,is_true))
+					{
+					parsetree.destroy();	// efficiency
+					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					INFORM(&quot; : control expression for static assertion must be a constant convertible to bool (C++0X 7p4)&quot;);
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
+					continue;
+					};
+				parsetree.destroy();	// efficiency
+				if (!is_true)
+					{	// oops
+					message_header(src.data&lt;0&gt;()[i].index_tokens[0]);
+					INC_INFORM(ERR_STR);
+					// hmm...really should unescape string before emitting
+					const size_t tmp_size = LengthOfCStringLiteral(src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].token.first,src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].token.second);
+					if (1U&gt;=tmp_size || 'L'== *src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].token.first)
+						{	//! \todo handle wide-strings later
+						INFORM(&quot;(static assertion failure)&quot;);
+						zcc_errors.inc_error();
+						src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
+						continue;
+						};
+					
+					char* tmp = _new_buffer&lt;char&gt;(tmp_size);
+					if (NULL==tmp)
+						{
+						INFORM(&quot;(static assertion failure)&quot;);
+						zcc_errors.inc_error();
+						src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
+						continue;
+						}
+					UnescapeCString(tmp,src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].token.first+1,src.data&lt;0&gt;()[i+1].data&lt;0&gt;()[src.data&lt;0&gt;()[i+1].size&lt;0&gt;()-1].index_tokens[0].token.second-2);
+					INFORM(tmp);
+					free(tmp);
+					zcc_errors.inc_error();
+					src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
+					continue;
+					};
+				}
 			src.DeleteNSlotsAt&lt;0&gt;(j-i+1,i);
 			continue;
 			};
@@ -10086,626 +10868,6 @@
 	CPP_ParseNamespace(src,types,NULL);
 }
 
-//! \test if.C99/Pass_zero.hpp, if.C99/Pass_zero.h
-bool C99_integer_literal_is_zero(const char* const x,const size_t x_len,const lex_flags flags)
-{
-	assert(NULL!=x);
-	assert(0&lt;x_len);
-	assert(C_TESTFLAG_PP_NUMERAL &amp; flags);
-	assert(!(C_TESTFLAG_FLOAT &amp; flags));
-	C_REALITY_CHECK_PP_NUMERAL_FLAGS(flags);
-	//! \todo need some way to signal legality for integer literals
-	switch(C_EXTRACT_BASE_CODE(flags))
-	{
-#ifndef NDEBUG
-	default: FATAL_CODE(&quot;unclassified integer literal&quot;,3);
-#endif
-	case C_BASE_OCTAL:
-		{	// all-zeros is zero, ok with leading 0 prefix
-		C_PPOctalInteger test_oct;
-#ifdef NDEBUG
-		C_PPOctalInteger::is(x,x_len,test_oct);
-#else
-		assert(C_PPOctalInteger::is(x,x_len,test_oct));
-#endif
-		return strspn(test_oct.ptr,&quot;0&quot;) == test_oct.digit_span;
-		};
-	case C_BASE_DECIMAL:
-		{	// decimal is easy
-		C_PPDecimalInteger test_dec;
-#ifdef NDEBUG
-		C_PPDecimalInteger::is(x,x_len,test_dec);
-#else
-		assert(C_PPDecimalInteger::is(x,x_len,test_dec));
-#endif
-		return 1==test_dec.digit_span &amp;&amp; '0'==test_dec.ptr[0];
-		};
-	case C_BASE_HEXADECIMAL:
-		{	// all-zeros is zero, but ignore the leading 0x prefix
-		C_PPHexInteger test_hex;
-#ifdef NDEBUG
-		C_PPHexInteger::is(x,x_len,test_hex);
-#else
-		assert(C_PPHexInteger::is(x,x_len,test_hex));
-#endif
-		return strspn(test_hex.ptr+2,&quot;0&quot;)+2 == test_hex.digit_span;
-		};
-	}
-#ifdef NDEBUG
-	return false;
-#endif
-}
-
-static void eval_string_literal_deref(parse_tree&amp; src,const type_system&amp; types,const POD_pair&lt;const char*,size_t&gt;&amp; str_lit,const unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp; tmp,bool is_negative,bool index_src_is_char)
-{
-	const size_t strict_ub = LengthOfCStringLiteral(str_lit.first,str_lit.second);
-	// C99 6.2.6.2p3 -0 is not actually allowed to generate the bitpattern -0, so no trapping
-	if (is_negative &amp;&amp; tmp==0) is_negative = false;
-	if (is_negative)
-		{	//! \test default/Error_if_control66.hpp, default/Error_if_control66.h
-			//! \test default/Error_if_control67.hpp, default/Error_if_control67.h
-		if (!(src.flags &amp; parse_tree::INVALID))
-			{
-			message_header(src.index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INC_INFORM(&quot;undefined behavior: &quot;);
-			INC_INFORM(src);
-			INFORM(&quot; dereferences string literal with negative index&quot;);
-			if (index_src_is_char)
-				INFORM(&quot;(does this source code want char to act like unsigned char?)&quot;);
-			src.flags |= parse_tree::INVALID;
-			zcc_errors.inc_error();
-			}
-		return;
-		}
-	else if (strict_ub &lt;= tmp)
-		{	//! \test default/Error_if_control68.hpp, default/Error_if_control68.h
-			//! \test default/Error_if_control69.hpp, default/Error_if_control69.h
-		if (!(src.flags &amp; parse_tree::INVALID))
-			{
-			message_header(src.index_tokens[0]);
-			INC_INFORM(ERR_STR);
-			INC_INFORM(&quot;undefined behavior: &quot;);
-			INC_INFORM(src);
-			INFORM(&quot; dereferences string literal past its end&quot;);
-			if (index_src_is_char &amp;&amp; target_machine-&gt;signed_max&lt;virtual_machine::std_int_char&gt;()&lt;tmp)
-				{
-				if (tmp.to_uint()-1==target_machine-&gt;signed_max&lt;virtual_machine::std_int_char&gt;())
-					{
-					INFORM(&quot;(does this source code want char to act like signed char, with integer representation sign-and-magnitude?)&quot;);
-					}
-				else if (tmp==target_machine-&gt;unsigned_max&lt;virtual_machine::std_int_char&gt;())
-					{
-					INFORM(&quot;(does this source code want char to act like signed char, with integer representation one's complement?)&quot;);
-					}
-				}
-			src.flags |= parse_tree::INVALID;
-			zcc_errors.inc_error();
-			}
-		return;
-		};
-	char* tmp2 = NULL;
-	assert(tmp.representable_as_uint());
-	GetCCharacterLiteralAt(str_lit.first,str_lit.second,tmp.to_uint(),tmp2);
-	assert(NULL!=tmp2);
-	src.destroy();	// str_lit goes invalid here, don't use again
-	src.grab_index_token_from&lt;0&gt;(tmp2,C_TESTFLAG_CHAR_LITERAL);
-	_label_one_literal(src,types);
-}
-
-static bool
-eval_array_deref(parse_tree&amp; src,const type_system&amp; types,
-				 func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-				 func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type literal_converts_to_integer,
-				 func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
-{
-	if (!is_array_deref(src)) return false;
-	// crunch __[...]
-	// canonical definition: *((__)+(...))
-	EvalParseTree(*src.c_array&lt;0&gt;(),types);
-	EvalParseTree(*src.c_array&lt;1&gt;(),types);
-	if (parse_tree::CONSTANT_EXPRESSION &amp; src.flags)
-		{
-		const unsigned int str_index = 	(C_TESTFLAG_STRING_LITERAL==src.data&lt;0&gt;()-&gt;index_tokens[0].flags) ? 0 :
-										(C_TESTFLAG_STRING_LITERAL==src.data&lt;1&gt;()-&gt;index_tokens[0].flags) ? 1 : UINT_MAX;
-		if (UINT_MAX&gt;str_index)
-			{
-			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; tmp; 
-			if (!intlike_literal_to_VM(tmp,*src.data(1-str_index))) return false;
-			const size_t promoted_type = default_promote_type(src.type_code.base_type_index);
-			const virtual_machine::std_int_enum machine_type = (virtual_machine::std_int_enum)((promoted_type-C_TYPE::INT)/2+virtual_machine::std_int_int);
-			eval_string_literal_deref(src,types,src.data(str_index)-&gt;index_tokens[0].token,tmp,tmp.test(target_machine-&gt;C_bit(machine_type)-1),C_TESTFLAG_CHAR_LITERAL==src.data(1-str_index)-&gt;index_tokens[0].flags);
-			return true;
-			}
-		}
-	return false;
-}
-
-static bool eval_deref(	parse_tree&amp; src, const type_system&amp; types,
-						func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree)
-{
-	//! \todo handle operator overloading (fork to handle C/C++?)
-	//! \todo catch *&amp; cancellation
-	if (is_C99_unary_operator_expression&lt;'*'&gt;(src))
-		{
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (C_TESTFLAG_STRING_LITERAL==src.data&lt;2&gt;()-&gt;index_tokens[0].flags)
-			{
-			//! \test default/Pass_if_zero.hpp
-			//! \test default/Pass_if_zero.h
-			//! \test default/Pass_if_nonzero.hpp
-			//! \test default/Pass_if_nonzero.h
-			eval_string_literal_deref(src,types,src.data&lt;2&gt;()-&gt;index_tokens[0].token,unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;(0),false,false);
-			return true;
-			}
-		}
-	return false;
-}
-
-static bool eval_logical_NOT(parse_tree&amp; src, const type_system&amp; types,
-							 func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-							 func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_logical_NOT_expression,
-							 func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool)
-{
-	if (is_logical_NOT_expression(src))
-		{
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_logical_NOT(src,types,is_logical_NOT_expression,literal_converts_to_bool)) return true;
-		}
-	return false;
-}
-
-static bool eval_bitwise_compl(	parse_tree&amp; src, const type_system&amp; types,
-								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-								func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_complement_expression,
-								func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
-{
-	if (is_bitwise_complement_expression(src))
-		{
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_bitwise_compl(src,types,true,is_bitwise_complement_expression,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_unary_plus(parse_tree&amp; src, const type_system&amp; types,
-							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree)
-{
-	if (is_C99_unary_operator_expression&lt;'+'&gt;(src))
-		{
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_unary_plus(src,types)) return true;
-		}
-	return false;
-}
-
-static bool eval_unary_minus(parse_tree&amp; src, const type_system&amp; types,
-							 func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-							 func_traits&lt;bool (*)(const parse_tree&amp;, bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
-							 func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_unary_operator_expression&lt;'-'&gt;(src))
-		{
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_unary_minus(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_mult_expression(parse_tree&amp; src,const type_system&amp; types,
-								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-								func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
-								func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_mult_operator_expression&lt;'*'&gt;(src))
-		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_mult_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_div_expression(parse_tree&amp; src,const type_system&amp; types,
-								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-								func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
-								func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_mult_operator_expression&lt;'/'&gt;(src))
-		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_div_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_mod_expression(parse_tree&amp; src,const type_system&amp; types,
-								func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-								func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
-								func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_mult_operator_expression&lt;'%'&gt;(src))
-		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_mod_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_add_expression(parse_tree&amp; src,const type_system&amp; types,
-							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
-							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_add_operator_expression&lt;'+'&gt;(src))
-		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_add_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_sub_expression(parse_tree&amp; src,const type_system&amp; types,
-							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
-							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_add_operator_expression&lt;'-'&gt;(src))
-		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_sub_expression(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_shift(parse_tree&amp; src,const type_system&amp; types,
-							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
-							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_shift_expression(src))
-		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_shift(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_relation_expression(parse_tree&amp; src,const type_system&amp; types,
-							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
-{
-	if (is_C99_relation_expression(src))
-		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_relation_expression(src,types,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_equality_expression(parse_tree&amp; src,const type_system&amp; types,
-							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_equality_expression,
-							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
-							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
-{
-	if (is_equality_expression(src))
-		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_equality_expression(src,types,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_bitwise_AND(parse_tree&amp; src,const type_system&amp; types,
-							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_AND_expression,
-							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
-							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
-{
-	if (is_bitwise_AND_expression(src))
-		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_bitwise_AND(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_bitwise_XOR(parse_tree&amp; src,const type_system&amp; types,
-							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_XOR_expression,
-							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
-							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
-{
-	if (is_bitwise_XOR_expression(src))
-		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_bitwise_XOR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_bitwise_OR(parse_tree&amp; src,const type_system&amp; types,
-							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_bitwise_OR_expression,
-							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool,
-							func_traits&lt;bool (*)(unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt;&amp;,const parse_tree&amp;)&gt;::function_ref_type intlike_literal_to_VM)
-{
-	if (is_bitwise_OR_expression(src))
-		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_bitwise_OR(src,types,true,literal_converts_to_bool,intlike_literal_to_VM)) return true;
-		}
-	return false;
-}
-
-static bool eval_logical_AND(parse_tree&amp; src,const type_system&amp; types,
-							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_logical_AND_expression,
-							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool)
-{
-	if (is_logical_AND_expression(src))
-		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_logical_AND(src,types,literal_converts_to_bool)) return true;
-		}
-	return false;
-}
-
-static bool eval_logical_OR(parse_tree&amp; src,const type_system&amp; types,
-							func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-							func_traits&lt;bool (*)(const parse_tree&amp;)&gt;::function_ref_type is_logical_OR_expression,
-							func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool)
-{
-	if (is_logical_OR_expression(src))
-		{
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		EvalParseTree(*src.c_array&lt;2&gt;(),types);
-		if (eval_logical_OR(src,types,literal_converts_to_bool)) return true;
-		}
-	return false;
-}
-
-static bool eval_conditional_operator(parse_tree&amp; src,const type_system&amp; types,
-									  func_traits&lt;bool (*)(parse_tree&amp;,const type_system&amp;)&gt;::function_ref_type EvalParseTree,
-									  func_traits&lt;bool (*)(const parse_tree&amp;,bool&amp;)&gt;::function_ref_type literal_converts_to_bool)
-{
-	if (is_C99_conditional_operator_expression(src))
-		{	// prefix operator is boolean
-		EvalParseTree(*src.c_array&lt;1&gt;(),types);
-		if (eval_conditional_op(src,literal_converts_to_bool)) return true;
-		}
-	return false;
-}
-
-#if 0
-static bool cancel_addressof_deref_operators(parse_tree&amp; src)
-{
-	assert(is_C99_unary_operator_expression(src));
-	if ('&amp;'==*src.index_tokens[0].token.first)
-		{	// strip off &amp;*, and remove lvalue-ness of target
-		if (is_C99_unary_operator_expression&lt;'*'&gt;(*src.data&lt;2&gt;()) &amp;&amp; 0&lt;src.data&lt;2&gt;()-&gt;data&lt;2&gt;()-&gt;type_code.pointer_power_after_array_decay())
-			{
-			parse_tree tmp = *src.data&lt;2&gt;()-&gt;data&lt;2&gt;();
-			tmp.type_code.traits &amp;= ~type_spec::lvalue;
-			src.c_array&lt;2&gt;()-&gt;c_array&lt;2&gt;()-&gt;clear();
-			src.destroy();
-			src = tmp;
-			return true;
-			}
-#if 0
-		if (is_array_deref(*src.data&lt;2&gt;()))
-			{	//! \todo convert &amp;(___[...]) to (__+...)
-			}
-#endif
-		};
-	return false;
-}
-#endif
-
-static bool C99_EvalParseTree(parse_tree&amp; src,const type_system&amp; types)
-{
-	const size_t starting_errors = zcc_errors.err_count();
-RestartEval:
-	if (src.is_atomic() || (parse_tree::INVALID &amp; src.flags)) return starting_errors==zcc_errors.err_count();
-	if (eval_array_deref(src,types,C99_EvalParseTree,C99_literal_converts_to_integer,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_conditional_operator(src,types,C99_EvalParseTree,C99_literal_converts_to_bool)) goto RestartEval;
-	if (eval_logical_OR(src,types,C99_EvalParseTree,is_C99_logical_OR_expression,C99_literal_converts_to_bool)) goto RestartEval;
-	if (eval_logical_AND(src,types,C99_EvalParseTree,is_C99_logical_AND_expression,C99_literal_converts_to_bool)) goto RestartEval;
-	if (eval_deref(src,types,C99_EvalParseTree)) goto RestartEval; 
-	if (eval_logical_NOT(src,types,C99_EvalParseTree,is_C99_unary_operator_expression&lt;'!'&gt;,C99_literal_converts_to_bool)) goto RestartEval;
-	if (eval_unary_plus(src,types,C99_EvalParseTree)) goto RestartEval;
-	if (eval_unary_minus(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_mult_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_div_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_mod_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_add_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_sub_expression(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_shift(src,types,C99_EvalParseTree,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_relation_expression(src,types,C99_EvalParseTree,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_equality_expression(src,types,C99_EvalParseTree,is_C99_equality_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_AND(src,types,C99_EvalParseTree,is_C99_bitwise_AND_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_XOR(src,types,C99_EvalParseTree,is_C99_bitwise_XOR_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_OR(src,types,C99_EvalParseTree,is_C99_bitwise_OR_expression,C99_literal_converts_to_bool,C99_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_compl(src,types,C99_EvalParseTree,is_C99_unary_operator_expression&lt;'~'&gt;,C99_intlike_literal_to_VM)) goto RestartEval;
-	return starting_errors==zcc_errors.err_count();
-}
-
-static bool CPP_EvalParseTree(parse_tree&amp; src,const type_system&amp; types)
-{
-	const size_t starting_errors = zcc_errors.err_count();
-RestartEval:
-	if (src.is_atomic() || (parse_tree::INVALID &amp; src.flags)) return starting_errors==zcc_errors.err_count();
-	if (eval_array_deref(src,types,CPP_EvalParseTree,CPP_literal_converts_to_integer,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_conditional_operator(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool)) goto RestartEval;
-	if (eval_logical_OR(src,types,CPP_EvalParseTree,is_CPP_logical_OR_expression,CPP_literal_converts_to_bool)) goto RestartEval;
-	if (eval_logical_AND(src,types,CPP_EvalParseTree,is_CPP_logical_AND_expression,CPP_literal_converts_to_bool)) goto RestartEval;
-	if (eval_deref(src,types,CPP_EvalParseTree)) goto RestartEval; 
-	if (eval_logical_NOT(src,types,CPP_EvalParseTree,is_CPP_logical_NOT_expression,CPP_literal_converts_to_bool)) goto RestartEval;
-	if (eval_unary_plus(src,types,CPP_EvalParseTree)) goto RestartEval;
-	if (eval_unary_minus(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_mult_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_div_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_mod_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_add_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_sub_expression(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_shift(src,types,CPP_EvalParseTree,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_relation_expression(src,types,CPP_EvalParseTree,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_equality_expression(src,types,CPP_EvalParseTree,is_CPP_equality_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_AND(src,types,CPP_EvalParseTree,is_CPP_bitwise_AND_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_XOR(src,types,CPP_EvalParseTree,is_CPP_bitwise_XOR_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_OR(src,types,CPP_EvalParseTree,is_CPP_bitwise_OR_expression,CPP_literal_converts_to_bool,CPP_intlike_literal_to_VM)) goto RestartEval;
-	if (eval_bitwise_compl(src,types,CPP_EvalParseTree,is_CPP_bitwise_complement_expression,CPP_intlike_literal_to_VM)) goto RestartEval;
-	return starting_errors==zcc_errors.err_count();
-}
-
-void C99_PPHackTree(parse_tree&amp; src,const type_system&amp; types)
-{
-	if (parse_tree::INVALID &amp; src.flags) return;
-	if (	is_C99_unary_operator_expression&lt;'-'&gt;(src)
-		&amp;&amp;	(PARSE_PRIMARY_EXPRESSION &amp; src.data&lt;2&gt;()-&gt;flags))
-		{	// compact - literal to literal to get past preprocessor
-		src.eval_to_arg&lt;2&gt;(0);
-		return;
-		};
-	const type_spec old_type = src.type_code;
-	const bool non_representable_int_min = virtual_machine::twos_complement==target_machine-&gt;C_signed_int_representation() &amp;&amp; !bool_options[boolopt::int_traps];
-	//! \todo handle other instances of non-representable int min constant expressions
-	if (is_C99_add_operator_expression&lt;'-'&gt;(src))
-		{
-		bool is_equal = false;
-		if (C_string_literal_equal_content(*src.data&lt;1&gt;(),*src.data&lt;2&gt;(),is_equal))
-			{
-			assert(!is_equal);	// should have intercepted equal-literal reduction earlier
-#ifndef NDEBUG
-			force_decimal_literal(src,&quot;1&quot;,types);
-#else
-			force_decimal_literal(src,is_equal ? &quot;0&quot; : &quot;1&quot;,types);
-#endif
-			src.type_code.set_type(C_TYPE::INT);
-			return;
-			};
-		if (non_representable_int_min)
-			{
-			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int;
-			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
-			const bool lhs_converted = C99_intlike_literal_to_VM(res_int,*src.data&lt;1&gt;());
-			const bool rhs_converted = C99_intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;());
-			if (lhs_converted &amp;&amp; rhs_converted)
-				{	//! \todo deal with signed integer arithmetic
-				const promote_aux old(old_type.base_type_index);
-				assert(old.is_signed);
-				const promote_aux lhs(src.data&lt;1&gt;()-&gt;type_code.base_type_index);
-				assert(old.bitcount&gt;=lhs.bitcount);
-				const promote_aux rhs(src.data&lt;2&gt;()-&gt;type_code.base_type_index);
-				assert(old.bitcount&gt;=rhs.bitcount);
-
-				// handle sign-extension of lhs, rhs
-#ifndef NDEBUG
-				const bool lhs_negative = target_machine-&gt;C_promote_integer(res_int,lhs,old);
-				const bool rhs_negative = target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
-#else
-				target_machine-&gt;C_promote_integer(res_int,lhs,old);
-				target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
-#endif
-				assert(lhs_negative &amp;&amp; !rhs_negative);
-				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_test(res_int);
-				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_test(rhs_int);
-				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; ub(target_machine-&gt;signed_max(old.machine_type));
-				target_machine-&gt;signed_additive_inverse(lhs_test,old.machine_type);
-				ub += 1;
-				assert(ub&gt;=lhs_test &amp;&amp; ub&gt;=rhs_test);
-				ub -= lhs_test;
-				assert(ub&gt;=rhs_test);
-				lhs_test += rhs_test;
-				assert(target_machine-&gt;signed_max(old.machine_type)&lt;lhs_test);
-				// ok...valid but won't reduce.  pick an argument and mock this up
-				src.eval_to_arg&lt;2&gt;(0);
-				return;
-				}
-			}
-		}
-}
-
-void CPP_PPHackTree(parse_tree&amp; src,const type_system&amp; types)
-{
-	if (parse_tree::INVALID &amp; src.flags) return;
-	if (	is_C99_unary_operator_expression&lt;'-'&gt;(src)
-		&amp;&amp;	(PARSE_PRIMARY_EXPRESSION &amp; src.data&lt;2&gt;()-&gt;flags))
-		{	// compact - literal to literal to get past preprocessor
-		src.eval_to_arg&lt;2&gt;(0);
-		return;
-		};
-	const type_spec old_type = src.type_code;
-	const bool non_representable_int_min = virtual_machine::twos_complement==target_machine-&gt;C_signed_int_representation() &amp;&amp; !bool_options[boolopt::int_traps];
-	//! \todo handle other instances of non-representable int min constant expressions
-	if (is_C99_add_operator_expression&lt;'-'&gt;(src))
-		{
-		bool is_equal = false;
-		if (C_string_literal_equal_content(*src.data&lt;1&gt;(),*src.data&lt;2&gt;(),is_equal))
-			{
-			assert(!is_equal);	// should have intercepted equal-literal reduction earlier
-#ifndef NDEBUG
-			force_decimal_literal(src,&quot;1&quot;,types);
-#else
-			force_decimal_literal(src,is_equal ? &quot;0&quot; : &quot;1&quot;,types);
-#endif
-			src.type_code.set_type(C_TYPE::INT);
-			return;
-			};
-		if (non_representable_int_min)
-			{
-			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; res_int;
-			unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_int;
-			const bool lhs_converted = CPP_intlike_literal_to_VM(res_int,*src.data&lt;1&gt;());
-			const bool rhs_converted = CPP_intlike_literal_to_VM(rhs_int,*src.data&lt;2&gt;());
-			if (lhs_converted &amp;&amp; rhs_converted)
-				{	//! \todo deal with signed integer arithmetic
-				const promote_aux old(old_type.base_type_index);
-				assert(old.is_signed);
-				const promote_aux lhs(src.data&lt;1&gt;()-&gt;type_code.base_type_index);
-				assert(old.bitcount&gt;=lhs.bitcount);
-				const promote_aux rhs(src.data&lt;2&gt;()-&gt;type_code.base_type_index);
-				assert(old.bitcount&gt;=rhs.bitcount);
-
-				// handle sign-extension of lhs, rhs
-#ifndef NDEBUG
-				const bool lhs_negative = target_machine-&gt;C_promote_integer(res_int,lhs,old);
-				const bool rhs_negative = target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
-#else
-				target_machine-&gt;C_promote_integer(res_int,lhs,old);
-				target_machine-&gt;C_promote_integer(rhs_int,rhs,old);
-#endif
-				assert(lhs_negative &amp;&amp; !rhs_negative);
-				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; lhs_test(res_int);
-				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; rhs_test(rhs_int);
-				unsigned_fixed_int&lt;VM_MAX_BIT_PLATFORM&gt; ub(target_machine-&gt;signed_max(old.machine_type));
-				target_machine-&gt;signed_additive_inverse(lhs_test,old.machine_type);
-				ub += 1;
-				assert(ub&gt;=lhs_test &amp;&amp; ub&gt;=rhs_test);
-				ub -= lhs_test;
-				assert(ub&gt;=rhs_test);
-				lhs_test += rhs_test;
-				assert(target_machine-&gt;signed_max(old.machine_type)&lt;lhs_test);
-				// ok...valid but won't reduce.  pick an argument and mock this up
-				src.eval_to_arg&lt;2&gt;(0);
-				return;
-				}
-			}
-		}
-}
-
 PP_auxfunc C99_aux
  = 	{
 	LengthOfCSystemHeader,

Modified: trunk/ZParser.cpp
===================================================================
--- trunk/ZParser.cpp	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/ZParser.cpp	2009-09-24 03:03:00 UTC (rev 256)
@@ -3,6 +3,7 @@
 #include &quot;ZParser.hpp&quot;
 
 #include &quot;CSupport.hpp&quot;
+#include &quot;errors.hpp&quot;
 #include &quot;errcount.hpp&quot;
 #include &quot;langroute.hpp&quot;
 #include &quot;ParseTree.hpp&quot;
@@ -55,7 +56,12 @@
 			i = pretokenized.size();
 			do	{
 				--i;
+				// XXX optimized for preprocessor -- should actually be its own hook
+				// disable pedantic warnings to avoid fake warnings about string literals
+				const bool pedantic_backup = bool_options[boolopt::pedantic];
+				bool_options[boolopt::pedantic] = false;
 				lang.pp_support-&gt;AddPostLexFlags(TokenList.front()-&gt;data()+pretokenized[i].first, pretokenized[i].second, pretokenized[i].third, TokenList.front()-&gt;src_filename, TokenList.front()-&gt;original_line.first);
+				bool_options[boolopt::pedantic] = pedantic_backup;
 				if (	(C_TESTFLAG_PP_OP_PUNC &amp; pretokenized[i].third)
 					&amp;&amp; 	(C_DISALLOW_POSTPROCESSED_SOURCE &amp; lang.pp_support-&gt;GetPPOpPuncFlags(C_PP_DECODE(pretokenized[i].third))))
 					{

Modified: trunk/tests/zcc/run_tests.bat
===================================================================
--- trunk/tests/zcc/run_tests.bat	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/tests/zcc/run_tests.bat	2009-09-24 03:03:00 UTC (rev 256)
@@ -37,6 +37,10 @@
 @for %%f in (Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
 @for %%f in (Pass*.hpp) do @echo %CPP_ISO% %%f &amp; @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 &amp; set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
 @for %%f in (Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
<A HREF="https://lists.berlios.de/mailman/listinfo/zcplusplus-commits">+ at for</A> %%f in (staticassert.C1X\Pass*.h) do @echo %CPP_ISO% %%f &amp; @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 &amp; set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
<A HREF="https://lists.berlios.de/mailman/listinfo/zcplusplus-commits">+ at for</A> %%f in (staticassert.C1X\Pass*.h) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
<A HREF="https://lists.berlios.de/mailman/listinfo/zcplusplus-commits">+ at for</A> %%f in (staticassert.C1X\Pass*.hpp) do @echo %CPP_ISO% %%f &amp; @%CPP_ISO% %%f || (set /a FAILED=FAILED+1 &amp; set BAD_FAIL_NAME=%BAD_FAIL_NAME% %%f)
<A HREF="https://lists.berlios.de/mailman/listinfo/zcplusplus-commits">+ at for</A> %%f in (staticassert.C1X\Pass*.hpp) do @set /a ACCEPT_TEST=ACCEPT_TEST+1
 
 @echo %BAD_PASS% of %REJECT_TEST% rejection tests accepted
 @if not &quot;%BAD_PASS_NAME%&quot;==&quot;LastAccepted:&quot; @echo %BAD_PASS_NAME%

Modified: trunk/tests/zcc/run_tests.sh
===================================================================
--- trunk/tests/zcc/run_tests.sh	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/tests/zcc/run_tests.sh	2009-09-24 03:03:00 UTC (rev 256)
@@ -36,6 +36,8 @@
 	echo ====
 	for F in Pass*.h; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME=&quot;$BAD_FAIL_NAME $F&quot;; fi; done;
 	for F in Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME=&quot;$BAD_FAIL_NAME $F&quot;; fi; done;
+	for F in staticassert.C1X/Pass*.h; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME=&quot;$BAD_FAIL_NAME $F&quot;; fi; done;
+	for F in staticassert.C1X/Pass*.hpp; do let ++ACCEPT_TEST; echo $CPP_ISO $F; if $CPP_ISO $F; then :; else code_screen $? $F; let ++FAILED; BAD_FAIL_NAME=&quot;$BAD_FAIL_NAME $F&quot;; fi; done;
 
 	echo -E $BAD_PASS of $REJECT_TEST rejection tests accepted
 	if test -n &quot;$BAD_PASS_NAME&quot;; then echo -E $BAD_PASS_NAME; fi

Added: trunk/tests/zcc/staticassert.C1X/Error_autofail.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_autofail.h	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/tests/zcc/staticassert.C1X/Error_autofail.h	2009-09-24 03:03:00 UTC (rev 256)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_autofail.h
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+_Static_Assert(0,&quot;automatic failure&quot;);
+

Added: trunk/tests/zcc/staticassert.C1X/Error_autofail.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Error_autofail.hpp	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/tests/zcc/staticassert.C1X/Error_autofail.hpp	2009-09-24 03:03:00 UTC (rev 256)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_autofail.hpp
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+static_assert(0,&quot;automatic failure&quot;);
+

Added: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.h	2009-09-24 03:03:00 UTC (rev 256)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_autosuccess.h
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+_Static_Assert(1,&quot;automatic success&quot;);
+

Added: trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp
===================================================================
--- trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/tests/zcc/staticassert.C1X/Pass_autosuccess.hpp	2009-09-24 03:03:00 UTC (rev 256)
@@ -0,0 +1,5 @@
+// tests/zcc/staticassert.C99/Error_autosuccess.hpp
+// (C)2009 Kenneth Boyd, license: MIT.txt
+
+static_assert(1,&quot;automatic success&quot;);
+

Modified: trunk/tests/zcc.in/run_tests.in
===================================================================
--- trunk/tests/zcc.in/run_tests.in	2009-09-24 02:16:20 UTC (rev 255)
+++ trunk/tests/zcc.in/run_tests.in	2009-09-24 03:03:00 UTC (rev 256)
@@ -16,6 +16,7 @@
 
 ECHO Checking ISO acceptance requirements
 PASS CPP_ISO Pass*
+PASS CPP_ISO staticassert.C1X/Pass*
 
 EPILOG
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000022.html">[Zcplusplus-commits] r255 - in trunk: . Zaimoni.STL
</A></li>
	<LI>Next message: <A HREF="000024.html">[Zcplusplus-commits] r257 - in trunk: . Zaimoni.STL
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#23">[ date ]</a>
              <a href="thread.html#23">[ thread ]</a>
              <a href="subject.html#23">[ subject ]</a>
              <a href="author.html#23">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/zcplusplus-commits">More information about the Zcplusplus-commits
mailing list</a><br>
</body></html>
